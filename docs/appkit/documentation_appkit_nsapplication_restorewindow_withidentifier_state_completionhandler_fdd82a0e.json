{
  "abstract" : "Invoked to request that a window be restored.",
  "codeExamples" : [

  ],
  "contentHash" : "3520cedf49f72a396fb890268a71fd16950e254c80a0c2825a98d8d9e3245250",
  "crawledAt" : "2025-12-04T19:35:15Z",
  "declaration" : {
    "code" : "@MainActor func restoreWindow(withIdentifier identifier: NSUserInterfaceItemIdentifier, state: NSCoder, completionHandler: @escaping (NSWindow?, (any Error)?) -> Void) -> Bool",
    "language" : "swift"
  },
  "id" : "74A56D4B-6537-4978-81CB-33D5CBBEF52B",
  "kind" : "method",
  "language" : "swift",
  "module" : "AppKit",
  "overview" : "## Return Value\n\n[doc:\/\/com.apple.documentation\/documentation\/Swift\/true] if the window was restored; otherwise [doc:\/\/com.apple.documentation\/documentation\/Swift\/false].\n\n## Discussion\n\nIf the receiver knows how to restore the identified window, it should invoke the completion handler with the window, possibly creating it. It is acceptable to use a pre-existing window, though you should not pass the same window to more than one completion handler. If the receiver cannot restore the identified window (for example, the window referenced a document that has been deleted), it should invoke the completion handler with a nil window.\n\nThe receiver is app is passed the identifier of the window, which allows it to quickly check for known windows.  For example, you might give your preferences window an identifier of “preferences” in the nib, and then check for that identifier in your implementation.  The receiver is also passed the `NSCoder` instance containing the combined restorable state of the window, its delegate, the window controller, and any document.  The receiver may decode information previously stored in the coder to determine what window to restore.",
  "platforms" : [
    "macOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AppKit\/NSApplication\/restoreWindow(withIdentifier:state:completionHandler:)\ncrawled: 2025-12-04T19:35:15Z\n---\n\n# restoreWindow(withIdentifier:state:completionHandler:)\n\n**Instance Method**\n\nInvoked to request that a window be restored.\n\n## Declaration\n\n```swift\n@MainActor func restoreWindow(withIdentifier identifier: NSUserInterfaceItemIdentifier, state: NSCoder, completionHandler: @escaping (NSWindow?, (any Error)?) -> Void) -> Bool\n```\n\n## Parameters\n\n- **identifier**: The unique interface item identifier string that was previously associated with the window. Use this string to determine which window to create.\n- **state**: A coder object containing the window state information. This coder object contains the combined restorable state of the window, which can include the state of the window, its delegate, window controller, and document object. You can use this state to determine which window to create.\n- **completionHandler**: A Block object to execute with the results of creating the window. You must execute this block at some point but may do so after the method returns if needed. This block takes the following parameters:\n\n- The window that was created or nil if the window could not be created.\n- An error object if the window was not recognized or could not be created for whatever reason; otherwise, specify `nil`. In OS X v10.7, the error parameter is ignored.\n\n## Return Value\n\n[doc:\/\/com.apple.documentation\/documentation\/Swift\/true] if the window was restored; otherwise [doc:\/\/com.apple.documentation\/documentation\/Swift\/false].\n\n## Discussion\n\nIf the receiver knows how to restore the identified window, it should invoke the completion handler with the window, possibly creating it. It is acceptable to use a pre-existing window, though you should not pass the same window to more than one completion handler. If the receiver cannot restore the identified window (for example, the window referenced a document that has been deleted), it should invoke the completion handler with a nil window.\n\nThe receiver is app is passed the identifier of the window, which allows it to quickly check for known windows.  For example, you might give your preferences window an identifier of “preferences” in the nib, and then check for that identifier in your implementation.  The receiver is also passed the `NSCoder` instance containing the combined restorable state of the window, its delegate, the window controller, and any document.  The receiver may decode information previously stored in the coder to determine what window to restore.\n\n\n\n## Restoring App Windows at Launch\n\n- **isProtectedDataAvailable**\n- **extendStateRestoration()**: Allows an app to extend its state restoration period.\n- **completeStateRestoration()**: Completes the extended state restoration.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "isProtectedDataAvailable",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSApplication\/isProtectedDataAvailable"
        },
        {
          "description" : "Allows an app to extend its state restoration period.",
          "name" : "extendStateRestoration()",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSApplication\/extendStateRestoration()"
        },
        {
          "description" : "Completes the extended state restoration.",
          "name" : "completeStateRestoration()",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSApplication\/completeStateRestoration()"
        }
      ],
      "title" : "Restoring App Windows at Launch"
    }
  ],
  "source" : "appleJSON",
  "title" : "restoreWindow(withIdentifier:state:completionHandler:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSApplication\/restoreWindow(withIdentifier:state:completionHandler:)"
}