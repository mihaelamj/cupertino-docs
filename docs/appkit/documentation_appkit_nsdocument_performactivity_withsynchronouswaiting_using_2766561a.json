{
  "abstract" : "Waits for any work scheduled by previous invocations of this method to complete, then invokes the passed-in block.",
  "codeExamples" : [

  ],
  "contentHash" : "ac87cdc5c0befdef063add66775ce2ceb95f9f075353720954ff47ea543d720e",
  "crawledAt" : "2025-12-02T18:07:24Z",
  "declaration" : {
    "code" : "@MainActor func performActivity(withSynchronousWaiting waitSynchronously: Bool, using block: @escaping (@escaping () -> Void) -> Void)",
    "language" : "swift"
  },
  "id" : "E11EB71D-C24C-410B-86DC-A6CCE2BA95F0",
  "kind" : "method",
  "language" : "swift",
  "module" : "AppKit",
  "overview" : "## Discussion\n\nThe block is passed another block, the activity completion handler, which must be invoked when the activity is complete.\n\nThis method’s primary use is to wait for asynchronous saving. With asynchronous saving it is possible for the user to instigate a user interface action that might present modal dialog, a sheet for example, when asynchronous saving is about to fail and present an error alert sheet of its own, which would not work. This method solves that problem. If your `NSDocument` subclass supports asynchronous saving you should invoke this method around the performance of any work that might cause the presentation of a modal dialog, regardless of whether that work is performed synchronously or asynchronously. Here is a list of `NSDocument` methods whose default implementations invoke this method because they might present sheets, either to ask the user what to do as they begin their work or because they may fail and present errors to user:\n\nMore uses of this method may be added to `NSDocument` in the future.\n\nThis method must be invoked on the main thread. If [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] is passed for the `waitSynchronously` parameter, the method waits on the main thread, blocking further user interaction with the document. The purpose of blocking the main thread is so that the user cannot continue to change the document while an activity is pending. This prevents, for example, the situation in which the user chooses to revert the document, but reverting does not happen immediately because asynchronous saving is still in progress, yet the user is able to continue changing the document, and then those changes are immediately discarded when the asynchronous saving is complete and the document is reverted. All of the `NSDocument` methods listed above pass [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] for `waitSynchronously`.\n\nYou pass [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] for `waitSynchronously` when the work to be done is instigated by the user so indirectly that the work might begin when a modal dialog is already being presented. For example, another method whose default implementation invokes this method, this time passing [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] for `waitSynchronously`, is:\n\n[doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/autosave(withDelegate:didAutosave:contextInfo:)]\n\nThis method might present an error alert, but it is typically invoked by a timer. If it passed [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] for `waitSynchronously`, and the timer fired while the user was looking at a sheet presented by a previous activity, blocking of the main thread would prevent the handling of the user interface events necessary to dismiss that sheet and complete that previous activity. Deadlock would result.\n\nWhether you make this method wait synchronously or asynchronously to do your work is separate from whether your work is done synchronously or asynchronously. For example, as mentioned above, [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/save(to:ofType:for:delegate:didSave:contextInfo:)] passes [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] for `waitSynchronously` when it uses this method, even though the majority of the work it does may be done asynchronously.\n\nYou should not invoke this method during the invocation of the block passed to [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performSynchronousFileAccess(_:)] or in between the time [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performAsynchronousFileAccess(_:)] invokes the block passed to it and the time at which the corresponding file access completion handler is invoked. If you do, deadlock can result. In other words, you cannot begin a new activity as part of file access. You can, on the other hand, invoke [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performSynchronousFileAccess(_:)] or [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performAsynchronousFileAccess(_:)] as part of an activity.\n\nSome asynchronous activities, such as saving, need to do work on the main thread as they are completing. A deadlock would be inevitable if there were no way to interrupt this method’s blocking of the main thread. See [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/continueAsynchronousWorkOnMainThread(_:)] to find out how to interrupt this method’s blocking of the main thread.",
  "platforms" : [
    "macOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AppKit\/NSDocument\/performActivity(withSynchronousWaiting:using:)\ncrawled: 2025-12-02T18:07:24Z\n---\n\n# performActivity(withSynchronousWaiting:using:)\n\n**Instance Method**\n\nWaits for any work scheduled by previous invocations of this method to complete, then invokes the passed-in block.\n\n## Declaration\n\n```swift\n@MainActor func performActivity(withSynchronousWaiting waitSynchronously: Bool, using block: @escaping (@escaping () -> Void) -> Void)\n```\n\n## Parameters\n\n- **waitSynchronously**: If [doc:\/\/com.apple.documentation\/documentation\/Swift\/true], the method does not return until previous activities are complete and the passed-in block has been invoked. If [doc:\/\/com.apple.documentation\/documentation\/Swift\/false], the method might return before passed-in block is invoked. It might instead be invoked later, on the main thread, after previous activities are complete.\n- **block**: A block that performs work that might result in the presentation of a modal dialog.\n\n## Discussion\n\nThe block is passed another block, the activity completion handler, which must be invoked when the activity is complete.\n\nThis method’s primary use is to wait for asynchronous saving. With asynchronous saving it is possible for the user to instigate a user interface action that might present modal dialog, a sheet for example, when asynchronous saving is about to fail and present an error alert sheet of its own, which would not work. This method solves that problem. If your `NSDocument` subclass supports asynchronous saving you should invoke this method around the performance of any work that might cause the presentation of a modal dialog, regardless of whether that work is performed synchronously or asynchronously. Here is a list of `NSDocument` methods whose default implementations invoke this method because they might present sheets, either to ask the user what to do as they begin their work or because they may fail and present errors to user:\n\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/revertToSaved(_:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/save(withDelegate:didSave:contextInfo:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/runModalSavePanel(for:delegate:didSave:contextInfo:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/save(to:ofType:for:delegate:didSave:contextInfo:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/canClose(withDelegate:shouldClose:contextInfo:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/duplicate(withDelegate:didDuplicate:contextInfo:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/runModalPageLayout(with:delegate:didRun:contextInfo:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/print(withSettings:showPrintPanel:delegate:didPrint:contextInfo:)]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/runModalPrintOperation(_:delegate:didRun:contextInfo:)]\n\nMore uses of this method may be added to `NSDocument` in the future.\n\nThis method must be invoked on the main thread. If [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] is passed for the `waitSynchronously` parameter, the method waits on the main thread, blocking further user interaction with the document. The purpose of blocking the main thread is so that the user cannot continue to change the document while an activity is pending. This prevents, for example, the situation in which the user chooses to revert the document, but reverting does not happen immediately because asynchronous saving is still in progress, yet the user is able to continue changing the document, and then those changes are immediately discarded when the asynchronous saving is complete and the document is reverted. All of the `NSDocument` methods listed above pass [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] for `waitSynchronously`.\n\nYou pass [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] for `waitSynchronously` when the work to be done is instigated by the user so indirectly that the work might begin when a modal dialog is already being presented. For example, another method whose default implementation invokes this method, this time passing [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] for `waitSynchronously`, is:\n\n[doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/autosave(withDelegate:didAutosave:contextInfo:)]\n\nThis method might present an error alert, but it is typically invoked by a timer. If it passed [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] for `waitSynchronously`, and the timer fired while the user was looking at a sheet presented by a previous activity, blocking of the main thread would prevent the handling of the user interface events necessary to dismiss that sheet and complete that previous activity. Deadlock would result.\n\nWhether you make this method wait synchronously or asynchronously to do your work is separate from whether your work is done synchronously or asynchronously. For example, as mentioned above, [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/save(to:ofType:for:delegate:didSave:contextInfo:)] passes [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] for `waitSynchronously` when it uses this method, even though the majority of the work it does may be done asynchronously.\n\nYou should not invoke this method during the invocation of the block passed to [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performSynchronousFileAccess(_:)] or in between the time [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performAsynchronousFileAccess(_:)] invokes the block passed to it and the time at which the corresponding file access completion handler is invoked. If you do, deadlock can result. In other words, you cannot begin a new activity as part of file access. You can, on the other hand, invoke [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performSynchronousFileAccess(_:)] or [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/performAsynchronousFileAccess(_:)] as part of an activity.\n\nSome asynchronous activities, such as saving, need to do work on the main thread as they are completing. A deadlock would be inevitable if there were no way to interrupt this method’s blocking of the main thread. See [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSDocument\/continueAsynchronousWorkOnMainThread(_:)] to find out how to interrupt this method’s blocking of the main thread.\n\n## Performing Tasks Serially\n\n- **performSynchronousFileAccess(_:)**: Waits for any scheduled file access to complete, then invokes the passed-in block.\n- **performAsynchronousFileAccess(_:)**: Waits for any scheduled file access to complete but without blocking the main thread, then invokes the passed-in block.\n- **continueActivity(_:)**: Continues to perform the task for a user activity object using a different block.\n- **continueAsynchronousWorkOnMainThread(_:)**: Invokes the passed-in block on the main thread.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Waits for any scheduled file access to complete, then invokes the passed-in block.",
          "name" : "performSynchronousFileAccess(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSDocument\/performSynchronousFileAccess(_:)"
        },
        {
          "description" : "Waits for any scheduled file access to complete but without blocking the main thread, then invokes the passed-in block.",
          "name" : "performAsynchronousFileAccess(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSDocument\/performAsynchronousFileAccess(_:)"
        },
        {
          "description" : "Continues to perform the task for a user activity object using a different block.",
          "name" : "continueActivity(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSDocument\/continueActivity(_:)"
        },
        {
          "description" : "Invokes the passed-in block on the main thread.",
          "name" : "continueAsynchronousWorkOnMainThread(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSDocument\/continueAsynchronousWorkOnMainThread(_:)"
        }
      ],
      "title" : "Performing Tasks Serially"
    }
  ],
  "source" : "appleJSON",
  "title" : "performActivity(withSynchronousWaiting:using:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSDocument\/performActivity(withSynchronousWaiting:using:)"
}