{
  "abstract" : "An object that provides dynamic contextual controls in the Touch Bar of supported models of MacBook Pro.",
  "codeExamples" : [
    {
      "code" : "override func makeTouchBar() -> NSTouchBar? {\n    let mainBar = NSTouchBar()\n    mainBar.delegate = self    mainBar.customizationIdentifier = .imageViewer\n    mainBar.defaultItemIdentifiers = [.sharingPicker, .strokePopover, .strokeColorPicker, .photoPicker, .flexibleSpace, .clearButton, .otherItemsProxy]\n    mainBar.customizationAllowedItemIdentifiers = [.strokeSlider, .strokePopover, .photoPicker, .strokeColorPicker, .clearButton, .sharingPicker, .flexibleSpace]\n    mainBar.principalItemIdentifier = .photoPicker\n    return mainBar\n}",
      "language" : "swift"
    },
    {
      "code" : "[(1)(2)(other-items-proxy)(3)]",
      "language" : "other"
    },
    {
      "code" : "[(A)(B)(C)]",
      "language" : "other"
    },
    {
      "code" : "[(1)(2)(A)(B)(C)(3)]",
      "language" : "other"
    }
  ],
  "conformsTo" : [
    "CVarArg",
    "Copyable",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Equatable",
    "Hashable",
    "NSCoding",
    "NSObjectProtocol",
    "Sendable"
  ],
  "contentHash" : "8816044231d7331e9fafe023f5d23f019492862da77eb4df8ff9bf6148bb419e",
  "crawledAt" : "2025-12-02T16:06:13Z",
  "declaration" : {
    "code" : "@MainActor class NSTouchBar",
    "language" : "swift"
  },
  "id" : "26B2DC70-E90B-408C-A7FA-187015C620C9",
  "kind" : "class",
  "language" : "swift",
  "module" : "AppKit",
  "overview" : "## Overview\n\nOn supported MacBook Pro models, the Touch Bar, above the keyboard, shows instances of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] class from the front-most app. Such an instance is called a *bar*. You define a bar to provide controls relevant to the user’s context. Each such control is an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] class, called an *item*.\n\n\n\nYou can provide many bars within your app, one for each responder instance; macOS frameworks can provide bars, as well, that can appear alongside your app’s bars. The system determines which bars to show at any given time. For example, an app that uses standard AppKit objects, such as text fields (instances of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTextField] class), obtains appropriate bars along with relevant items automatically.\n\nRefer to the following sample code projects, which demonstrate how to use [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] and related classes, including the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSScrubber] class, with its rich API that lets you build a highly customized picker control:\n\nTo use the Touch Bar, define bars in objects in your app’s responder chain. At run time, the system traverses up the responder chain to discover, combine, and show bars from your app and from frameworks you link against.\n\nYou can configure a bar to support dynamic composition, in which the system shows the bar in an expanded form that contains items from bars lower in the responder chain (from closer to the first responder). Because of dynamic composition and placement of items shown on the Touch Bar, always ensure that your bars appear as you expect them to, testing on the versions of macOS that you support.\n\nInstances of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] class employ gesture recognizers and take advantage of macOS 10.12.1 event enhancements. Because of the physical geometry of the Touch Bar, touch events passed to gesture recognizers have only a meaningful *x*, or horizontal, component.\n\nThere’s no need, and no API, for your app to know whether or not there’s a Touch Bar available. Whether your app is running on a machine that supports the Touch Bar or not, your app’s onscreen user interface (UI) appears and behaves the same way.\n\nThe Touch Bar is a Retina display, like the screen of a MacBook Pro. To perform custom drawing or animation within the Touch Bar, follow the same best practices that you would on the screen.\n\nOn the right side of the Touch Bar, the system supplies the always-available *Control Strip*. The Control Strip gives the user access to standard controls for display brightness, sound volume, Siri, and so on. Your app’s bars appear to the left of the Control Strip. The user can choose to hide the Control Strip, which gives the frontmost app the entire Touch Bar width.\n\nTo the right of the Control Strip is a Touch ID sensor. To use Touch ID on supported MacBook Pro models, use methods from the [doc:\/\/com.apple.documentation\/documentation\/LocalAuthentication] framework.\n\nThe Touch Bar dims automatically and wakes when the user touches it. Don’t show alerts in the Touch Bar, and don’t use the Touch Bar for widgets.\n\nFor Touch Bar design guidance, read [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/inputs\/touch-bar\/].\n\n### Bar objects\n\nYou can think of an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object (or *bar*), with its array of [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] objects (or *items*), as analogous to a window toolbar with its toolbar items, or a menu with its menu items.\n\nTo provide a bar in your app, define it in an object that meets three requirements. The object that defines the bar must:\n\nThe built-in responder classes conform to the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider] protocol and support key-value observing (KVO), both of which are used and required by the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] infrastructure. In the context of Touch Bar support, a responder instance can also be called a *bar provider*.\n\nThe following code shows an example implementation of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSResponder\/makeTouchBar()] delegate method. In this code snippet, you can see some statements related to bar customization.\n\nYou can take advantage of built-in KVO support to keep track of bar state, such as which items are visible as the user customizes and interacts with the Touch Bar.\n\nIf you explicitly adopt the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider] protocol in the app delegate or in a window delegate, you must also explicitly send the associated key-value observing notifications from within your implementations of [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] methods; this lets the system respond appropriately to changes in the bar. To avoid the need to manually support KVO, use the *app object* as a bar provider, instead of the app delegate, or use a *window controller* or *window* as a bar provider, instead of the associated window delegate.\n\nTo programmatically invalidate a bar associated with a bar provider, such as because you’re changing the bar’s state, set its [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider\/touchBar] property to a value of `nil`.\n\n### Item objects\n\nA bar itself (an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object) has no visible representation in a MacBook Pro Touch Bar. A user instead sees the bar’s items, each of which is an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] class.\n\nThe items presented in a bar are the elements in a private array owned by the bar. To specify the items for a bar, you don’t fill this array directly, but rather rely on the bar to manage its items based on various groups of items and item identifiers that you do specify directly.\n\nIn specifying items for a bar you have two options, giving you flexibility for optimizing resource use and efficiency in your app.\n\nWhichever of these two approaches you employ, the system is in charge of populating a bar’s private items array based on three things:\n\nAs your app runs, you can obtain the identifiers of the items eligible for presentation in a bar — specifically, those in its private items array — by accessing the read-only [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/itemIdentifiers] property. This property reflects the current state of the bar instance, including any customization that has been performed by the user and any dynamic composition that has been performed by the system.\n\n### Customization\n\nAppKit provides a rich Touch Bar customization facility for users that appears, upon user request, on the main display. Make your bars customizable unless you have a specific UI need not to do so.\n\nA customizable bar automatically obtains onscreen UI which lets the user:\n\nA user invokes the onscreen customization UI by choosing a dedicated menu item.\n\nTo make an `NSTouchBar` object eligible for customization, assign it a globally-unique [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationIdentifier-swift.property] identifier. For the identifier string, use reverse-DNS style, such as “`com.company-name.app-name.alphanumeric-ID`”.\n\nNext, specify the bar’s items and customization possibilities by populating its item identifier lists. Each such list is an array, each of whose elements is the identifier (of type [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/Identifier-swift.struct]) for an item (an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] object). A bar’s item identifier lists are:\n\n**Default item identifiers**, specified in a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers] property. Always specify this property for an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object, even if you elect to make the bar noncustomizable. The system:\n\n**Additional item identifiers**, specified in a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationAllowedItemIdentifiers] property. Always configure this property for a customizable bar. The system uses this list by showing representations of its items individually in the customization UI, arranged in the same order as you specify in the property array. When there’s available geometric space, a user can drag in to the active bar any of the items in this list. If there isn’t enough space, a dragged item replaces the item or items under the spot the new item is dropped.\n\n**Required item identifiers**, specified in a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationRequiredItemIdentifiers] property. Configure this property at your discretion, depending on the design of your app. The user can’t remove from the bar any of the items you specify in this list.\n\nTo provide textual labels in the customization UI, use the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/customizationLabel] property on each [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] instance you include in a customizable bar. The accessibility system in macOS also makes use of these labels.\n\nIf your app design requires a noncustomizable [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object:\n\n#### Group item, popover item, and composed bar customization\n\nAppKit lets you specify any bar as customizable or not. The customization configuration you provide for a bar remains associated with the bar and its items — even when those items are nested by the system into another bar higher in the responder chain.\n\nThe system also respects your bar customization configuration when you use group and popover items. Each of these item types itself contains one or more bars—which can, in turn contain group items and popover items, and so on. The rest of this section explains how customization works for the bars containing, and bars within, group items and popover items.\n\n**A group item** (an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem] class) has one bar, held in the object’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] property. AppKit supports nesting of group items, in that you can configure a [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar to itself contain one or more group items (or, for that matter, items of any other type, guided by what works well in your app).Here are some examples of how customization for group items works in practice:\n\n**A popover item** (an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem] class) has two bars: one bar you specify in its [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] property and a second, optional bar you can specify in its [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/pressAndHoldTouchBar] property. Here are some examples of how customization for popover items works in practice:\n\n#### Customization menu item\n\nA user invokes the customization UI for a particular [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object, when it’s visible in the Touch Bar, by choosing the bar customization menu item. To enable this menu item you must explicitly opt-in, which you can do in the following ways:\n\nIf you attempt to employ the customization menu item (using either of these two approaches), but do not provide a customization identifier property ([doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationIdentifier-swift.property]) for a bar, the customization menu item appears when that bar is active — but the menu item, in this case, is disabled.\n\nIf your app attempts to use both automatic and explicit placement of the customization menu item, the system respects your explicit control and doesn’t place the item automatically.\n\n### Layout\n\nThe user controls the width of the Control Strip and can choose to hide it, and the system is in charge of the nesting of [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] instances (for the bars you make eligible for composition). As a result, the available display width for your bars can vary. There’s no API for you to obtain the current available display width.\n\nIn your layout design, don’t depend on a particular Control Strip size. Do anticipate dynamic composition and nesting for your bars.\n\nIf you need more horizontal space than might be available, use a popover item, a scrubber, or a scroll view — as they fit your design needs, but in that, descending, order of preference.\n\nIn geometric-space-constrained scenarios, the system hides [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] instances according to their visibility priority.\n\nIf you need to center an item in the Touch Bar, designate it as a *principal item* by assigning it to its bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/principalItemIdentifier] property. Don’t hard-code spacing in an attempt to ensure an item is centered. If you want a group of items to appear centered in the Touch Bar, designate the group item (of type [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem]) as the principal item.\n\n### Composition and nesting\n\nYou can configure a bar to support dynamic composition, in which the system shows the bar in an expanded form that contains items from bars lower in the responder chain (closer to the first responder).\n\nTo allow a bar to serve as a container for nesting, add the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/Identifier-swift.struct\/otherItemsProxy] item identifier to the bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers] array. A bar that includes this identifier, and that’s relatively higher in the responder chain, can then (at runtime) include the items from an eligible bar relatively lower in the responder chain.\n\nThe position that you specify for the other-items proxy, within a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers] array, tells the system where you want nested items to be placed.\n\nThe system determines whether or not to compose bars in this way, based on system policy and available geometric space in the Touch Bar.\n\n[doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object nesting can be chained, according to available geometric space in the Touch Bar. For example, a view and a text field within that view could each contribute their items to the bar defined for a parent window controller.\n\nWhen the system nests one bar’s items into another bar higher in the responder chain, the items appear to the user, in the Touch Bar, as fully incorporated into the higher bar. There’s no visual boundary or additional spacing to distinguish the items as being nested.\n\nIf a bar doesn’t employ the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/Identifier-swift.struct\/otherItemsProxy] identifier, the system hides that bar when another bar, lower in the responder chain, is eligible for display.\n\nWhen determining which items to show in the Touch Bar for the current first responder, the system traverses up the entire responder chain. This lets the system accommodate any proxy items in bars defined for objects higher in the chain, thereby respecting the fact that any bar, defined for an object at any position in the responder chain, might include the other-items-proxy identifier.\n\n#### Customization for composed bars\n\nThe logical, geometric boundary for a nested [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object isn’t visible to the user in the Touch Bar. However, the boundary remains in effect in terms of customization. A user can’t rearrange a nested bar’s items outside of its boundary.\n\nFor example, say you have a bar, higher in the responder chain, configured like this:\n\nAnd say you also have a bar, lower in the responder chain, eligible for display in the Touch Bar according to the system and the current app state, configured like this:\n\nThe composed bar would correspond to this arrangement in the Touch Bar:\n\nWith the customization UI, the user could then rearrange the items represented here by `(A)`, `(B)`, and `(C)`, but only as long as those items remained contiguous during the rearrangement, thereby respecting the logical boundary of the bar that defines them.\n\n#### Item spacing for composed bars\n\nWhen the system nests [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] objects that include spacing items, it merges any resulting adjacent spacing. Ensure that your bars appear as you expect them to, testing on the versions of macOS that you support. For more on spacing items, see [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem].\n\n### Bar discovery and the responder chain\n\nAt runtime, the system traverses up the responder chain, starting at the object with focus, to discover objects that conform to the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider] protocol. Such objects are called *bar providers*. The system then populates the Touch Bar, potentially with multiple, nested bars, according to system policy and available geometric space.\n\nSpecifically, bar discovery by the system proceeds in the following order:\n\nWhen the system encounters a bar provider that’s an instance of an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSResponder] subclass, the system then additionally searches up the responder chain anchored at that object.\n\nFor example, in a complicated but otherwise standard app, bar discovery might proceed in this order:\n\nThe Touch Bar can show one bar nested within another, as described in [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar#Composition-and-nesting].\n\n### Accessibility and the Touch Bar\n\nAppKit views and controls adopt the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSAccessibilityProtocol] protocol and automatically send appropriate accessibility notifications. Because the Touch Bar is designed to work with AppKit, it’s fully accessible.\n\nBe sure to use the `customizationLabel` property on every [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] instance that you designate as customizable. The accessibility system in macOS makes use of these labels.\n\nTo learn more about accessibility, read [doc:\/\/com.apple.appkit\/documentation\/AppKit\/accessibility-for-appkit].\n\n### AppKit support for the Touch Bar\n\nTo support the Touch Bar feature, AppKit provides several enhancements, first available in macOS 10.12.1:\n\n### Development considerations for the Touch Bar\n\nThe Xcode Touch Bar simulator represents the Touch Bar onscreen and supports some user interaction. However, some interactions are unavailable in the simulator. For example, you can’t perform two-finger gestures in the Touch Bar simulator.\n\nIf you’re adopting Touch Bar support for your app, but running Xcode on a Mac without a Touch Bar, you can enable the Xcode Touch Bar simulator by choosing Window > Show Touch Bar in Xcode.\n\nInterface Builder supports development for the Touch Bar with nib objects available in the object library. Drag and drop bars and items from the object library into your canvas, and then attach them to your app’s responders as desired. For more information, see Xcode Help.\n\n### Performance considerations for the Touch Bar\n\nThe Touch Bar’s display and the MacBook screen share resources, including the main CPU and GPU of the MacBook. To ensure that your Touch Bar controls perform well, follow the usual best practice of protecting your app’s main thread from doing too much work. For example, don’t perform rendering work for the main display on the main thread.\n\nIn addition, pay attention to the relative amounts of time your app spends on updates to the main display relative to updates to the Touch Bar. The optimum ratio can vary according to what the user is doing. For example:\n\nAlways test Touch Bar performance using the specific MacBook hardware you support. Specifically, don’t rely on the Xcode Touch Bar simulator when tuning your app for Touch Bar performance.",
  "platforms" : [
    "Mac Catalyst",
    "macOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\ncrawled: 2025-12-02T16:06:13Z\n---\n\n# NSTouchBar\n\n**Class**\n\nAn object that provides dynamic contextual controls in the Touch Bar of supported models of MacBook Pro.\n\n## Declaration\n\n```swift\n@MainActor class NSTouchBar\n```\n\n## Overview\n\nOn supported MacBook Pro models, the Touch Bar, above the keyboard, shows instances of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] class from the front-most app. Such an instance is called a *bar*. You define a bar to provide controls relevant to the user’s context. Each such control is an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] class, called an *item*.\n\n\n\nYou can provide many bars within your app, one for each responder instance; macOS frameworks can provide bars, as well, that can appear alongside your app’s bars. The system determines which bars to show at any given time. For example, an app that uses standard AppKit objects, such as text fields (instances of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTextField] class), obtains appropriate bars along with relevant items automatically.\n\nRefer to the following sample code projects, which demonstrate how to use [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] and related classes, including the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSScrubber] class, with its rich API that lets you build a highly customized picker control:\n\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/creating-and-customizing-the-touch-bar]\n- [doc:\/\/com.apple.appkit\/documentation\/AppKit\/integrating-a-toolbar-and-touch-bar-into-your-app]\n\nTo use the Touch Bar, define bars in objects in your app’s responder chain. At run time, the system traverses up the responder chain to discover, combine, and show bars from your app and from frameworks you link against.\n\nYou can configure a bar to support dynamic composition, in which the system shows the bar in an expanded form that contains items from bars lower in the responder chain (from closer to the first responder). Because of dynamic composition and placement of items shown on the Touch Bar, always ensure that your bars appear as you expect them to, testing on the versions of macOS that you support.\n\nInstances of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] class employ gesture recognizers and take advantage of macOS 10.12.1 event enhancements. Because of the physical geometry of the Touch Bar, touch events passed to gesture recognizers have only a meaningful *x*, or horizontal, component.\n\nThere’s no need, and no API, for your app to know whether or not there’s a Touch Bar available. Whether your app is running on a machine that supports the Touch Bar or not, your app’s onscreen user interface (UI) appears and behaves the same way.\n\nThe Touch Bar is a Retina display, like the screen of a MacBook Pro. To perform custom drawing or animation within the Touch Bar, follow the same best practices that you would on the screen.\n\n\n\nOn the right side of the Touch Bar, the system supplies the always-available *Control Strip*. The Control Strip gives the user access to standard controls for display brightness, sound volume, Siri, and so on. Your app’s bars appear to the left of the Control Strip. The user can choose to hide the Control Strip, which gives the frontmost app the entire Touch Bar width.\n\nTo the right of the Control Strip is a Touch ID sensor. To use Touch ID on supported MacBook Pro models, use methods from the [doc:\/\/com.apple.documentation\/documentation\/LocalAuthentication] framework.\n\nThe Touch Bar dims automatically and wakes when the user touches it. Don’t show alerts in the Touch Bar, and don’t use the Touch Bar for widgets.\n\nFor Touch Bar design guidance, read [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/inputs\/touch-bar\/].\n\n### Bar objects\n\nYou can think of an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object (or *bar*), with its array of [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] objects (or *items*), as analogous to a window toolbar with its toolbar items, or a menu with its menu items.\n\nTo provide a bar in your app, define it in an object that meets three requirements. The object that defines the bar must:\n\n- Be a responder (an instance of an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSResponder] subclass) that’s present within a responder chain at runtime.\n- Implement the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSResponder\/makeTouchBar()] delegate method from the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider] protocol.\n\nThe built-in responder classes conform to the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider] protocol and support key-value observing (KVO), both of which are used and required by the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] infrastructure. In the context of Touch Bar support, a responder instance can also be called a *bar provider*.\n\nThe following code shows an example implementation of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSResponder\/makeTouchBar()] delegate method. In this code snippet, you can see some statements related to bar customization.\n\n```swift\noverride func makeTouchBar() -> NSTouchBar? {\n    let mainBar = NSTouchBar()\n    mainBar.delegate = self    mainBar.customizationIdentifier = .imageViewer\n    mainBar.defaultItemIdentifiers = [.sharingPicker, .strokePopover, .strokeColorPicker, .photoPicker, .flexibleSpace, .clearButton, .otherItemsProxy]\n    mainBar.customizationAllowedItemIdentifiers = [.strokeSlider, .strokePopover, .photoPicker, .strokeColorPicker, .clearButton, .sharingPicker, .flexibleSpace]\n    mainBar.principalItemIdentifier = .photoPicker\n    return mainBar\n}\n```\n\nYou can take advantage of built-in KVO support to keep track of bar state, such as which items are visible as the user customizes and interacts with the Touch Bar.\n\nIf you explicitly adopt the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider] protocol in the app delegate or in a window delegate, you must also explicitly send the associated key-value observing notifications from within your implementations of [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] methods; this lets the system respond appropriately to changes in the bar. To avoid the need to manually support KVO, use the *app object* as a bar provider, instead of the app delegate, or use a *window controller* or *window* as a bar provider, instead of the associated window delegate.\n\nTo programmatically invalidate a bar associated with a bar provider, such as because you’re changing the bar’s state, set its [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider\/touchBar] property to a value of `nil`.\n\n### Item objects\n\nA bar itself (an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object) has no visible representation in a MacBook Pro Touch Bar. A user instead sees the bar’s items, each of which is an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] class.\n\n\n\nThe items presented in a bar are the elements in a private array owned by the bar. To specify the items for a bar, you don’t fill this array directly, but rather rely on the bar to manage its items based on various groups of items and item identifiers that you do specify directly.\n\nIn specifying items for a bar you have two options, giving you flexibility for optimizing resource use and efficiency in your app.\n\n- The [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/templateItems] property is a set that you can directly populate with item instances for a bar. Use this option when your items are lightweight enough to stay in memory for the duration of your app’s lifetime, and when they don’t contain state that might change over time.\n- The [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarDelegate] protocol, and its [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarDelegate\/touchBar(_:makeItemForIdentifier:)] delegate method, give your app a way to create items on-demand. Use this option when it makes more sense in terms of resource usage and reflecting dynamic state.\n\nWhichever of these two approaches you employ, the system is in charge of populating a bar’s private items array based on three things:\n\n1. Your configuration of the bar’s item-identifiers properties\n2. Any nesting you have specified\n3. Any customization that the user has specified for the bar\n\nAs your app runs, you can obtain the identifiers of the items eligible for presentation in a bar — specifically, those in its private items array — by accessing the read-only [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/itemIdentifiers] property. This property reflects the current state of the bar instance, including any customization that has been performed by the user and any dynamic composition that has been performed by the system.\n\n### Customization\n\nAppKit provides a rich Touch Bar customization facility for users that appears, upon user request, on the main display. Make your bars customizable unless you have a specific UI need not to do so.\n\nA customizable bar automatically obtains onscreen UI which lets the user:\n\n- Change which items are part of the shown bar\n- Rearrange items within the shown bar\n\nA user invokes the onscreen customization UI by choosing a dedicated menu item.\n\nTo make an `NSTouchBar` object eligible for customization, assign it a globally-unique [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationIdentifier-swift.property] identifier. For the identifier string, use reverse-DNS style, such as “`com.company-name.app-name.alphanumeric-ID`”.\n\nNext, specify the bar’s items and customization possibilities by populating its item identifier lists. Each such list is an array, each of whose elements is the identifier (of type [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/Identifier-swift.struct]) for an item (an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] object). A bar’s item identifier lists are:\n\n**Default item identifiers**, specified in a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers] property. Always specify this property for an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object, even if you elect to make the bar noncustomizable. The system:\n\n- Shows this list’s items by default when the system displays the bar.\n- Includes a preconfigured bar representation, containing these items, in the associated customization UI (when you have designated the bar as customizable by assigning it a [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationIdentifier-swift.property] property value); the user can drag the default bar into the Touch Bar, should they want to return to the default configuration.\n\n**Additional item identifiers**, specified in a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationAllowedItemIdentifiers] property. Always configure this property for a customizable bar. The system uses this list by showing representations of its items individually in the customization UI, arranged in the same order as you specify in the property array. When there’s available geometric space, a user can drag in to the active bar any of the items in this list. If there isn’t enough space, a dragged item replaces the item or items under the spot the new item is dropped.\n\n**Required item identifiers**, specified in a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationRequiredItemIdentifiers] property. Configure this property at your discretion, depending on the design of your app. The user can’t remove from the bar any of the items you specify in this list.\n\nTo provide textual labels in the customization UI, use the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/customizationLabel] property on each [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] instance you include in a customizable bar. The accessibility system in macOS also makes use of these labels.\n\nIf your app design requires a noncustomizable [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object:\n\n- List all of the bar’s items in the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers] property, and only in this property.\n- Don’t use the other properties described in this section and, in particular, don’t assign the bar a [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationIdentifier-swift.property] property value.\n\n#### Group item, popover item, and composed bar customization\n\nAppKit lets you specify any bar as customizable or not. The customization configuration you provide for a bar remains associated with the bar and its items — even when those items are nested by the system into another bar higher in the responder chain.\n\nThe system also respects your bar customization configuration when you use group and popover items. Each of these item types itself contains one or more bars—which can, in turn contain group items and popover items, and so on. The rest of this section explains how customization works for the bars containing, and bars within, group items and popover items.\n\n**A group item** (an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem] class) has one bar, held in the object’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] property. AppKit supports nesting of group items, in that you can configure a [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar to itself contain one or more group items (or, for that matter, items of any other type, guided by what works well in your app).Here are some examples of how customization for group items works in practice:\n\n- If you configure a bar as customizable, and give it a group item whose bar you configure as *not* customizable, then the array of items in the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar appears in the customization UI as an atomic unit. During customization, a user can manipulate the array of items, but strictly as a unit: If the (noncustomizable) [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar is visible in the Touch Bar, the user can remove it as a unit, or can rearrange it among the other items in the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar; if the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar is instead visible in the customization UI, the user can add it back to the Touch Bar, as a unit, placing it within the bar that owns the group item.\n- If you configure a bar as *not* customizable, and give it a group item whose bar you configure as customizable, then the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar’s items appear in the customization UI as individual items. During customization, a user can manipulate each item separately: If an item from the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar is visible in the Touch Bar, the user can remove it or can rearrange its position individually among the other items in the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar; if an item from the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar is instead visible in the customization UI, the user can add it back to the Touch Bar, individually, placing it anywhere within the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem\/groupTouchBar] bar that owns it.\n\n**A popover item** (an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem] class) has two bars: one bar you specify in its [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] property and a second, optional bar you can specify in its [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/pressAndHoldTouchBar] property. Here are some examples of how customization for popover items works in practice:\n\n- If you configure a bar as customizable, and give it a popover item whose [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] bar you configure as *not* customizable, the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] bar never appears in the customization UI. If the user invokes the customization UI when the (noncustomizable) popover item itself (not the button’s associated [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] bar) is visible in the Touch Bar, the customization UI lets the user rearrange the position of the popover item relative to the other items in the containing bar. If, on the other hand, the user invokes the customization UI when the (noncustomizable) [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] bar is visible in the Touch Bar, the system dismisses the popover bar and shows, in the customization UI, customization options for the bar that contains the popover item.\n- If you configure a [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] bar as customizable, the user can invoke the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] bar (by tapping the popover item that owns it, in the Touch Bar) and then use the customization UI to manipulate the items in the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPopoverTouchBarItem\/popoverTouchBar] bar itself.\n\n#### Customization menu item\n\nA user invokes the customization UI for a particular [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object, when it’s visible in the Touch Bar, by choosing the bar customization menu item. To enable this menu item you must explicitly opt-in, which you can do in the following ways:\n\n- If you want the system to automatically name, place, validate, and activate this menu item in your app’s menus, set the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSApplication\/isAutomaticCustomizeTouchBarMenuItemEnabled] property of your app object (of type [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSApplication]) to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true].\n- To explicitly place the customization menu item in one of your app’s menus, employ the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSApplication\/toggleTouchBarCustomizationPalette(_:)] method of your app object. When you do this, the system still names and validates the menu item, and hides it on systems that don’t have a Touch Bar.\n\nIf you attempt to employ the customization menu item (using either of these two approaches), but do not provide a customization identifier property ([doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/customizationIdentifier-swift.property]) for a bar, the customization menu item appears when that bar is active — but the menu item, in this case, is disabled.\n\nIf your app attempts to use both automatic and explicit placement of the customization menu item, the system respects your explicit control and doesn’t place the item automatically.\n\n### Layout\n\nThe user controls the width of the Control Strip and can choose to hide it, and the system is in charge of the nesting of [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] instances (for the bars you make eligible for composition). As a result, the available display width for your bars can vary. There’s no API for you to obtain the current available display width.\n\nIn your layout design, don’t depend on a particular Control Strip size. Do anticipate dynamic composition and nesting for your bars.\n\nIf you need more horizontal space than might be available, use a popover item, a scrubber, or a scroll view — as they fit your design needs, but in that, descending, order of preference.\n\nIn geometric-space-constrained scenarios, the system hides [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] instances according to their visibility priority.\n\nIf you need to center an item in the Touch Bar, designate it as a *principal item* by assigning it to its bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/principalItemIdentifier] property. Don’t hard-code spacing in an attempt to ensure an item is centered. If you want a group of items to appear centered in the Touch Bar, designate the group item (of type [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem]) as the principal item.\n\n### Composition and nesting\n\nYou can configure a bar to support dynamic composition, in which the system shows the bar in an expanded form that contains items from bars lower in the responder chain (closer to the first responder).\n\nTo allow a bar to serve as a container for nesting, add the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/Identifier-swift.struct\/otherItemsProxy] item identifier to the bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers] array. A bar that includes this identifier, and that’s relatively higher in the responder chain, can then (at runtime) include the items from an eligible bar relatively lower in the responder chain.\n\nThe position that you specify for the other-items proxy, within a bar’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers] array, tells the system where you want nested items to be placed.\n\nThe system determines whether or not to compose bars in this way, based on system policy and available geometric space in the Touch Bar.\n\n[doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object nesting can be chained, according to available geometric space in the Touch Bar. For example, a view and a text field within that view could each contribute their items to the bar defined for a parent window controller.\n\nWhen the system nests one bar’s items into another bar higher in the responder chain, the items appear to the user, in the Touch Bar, as fully incorporated into the higher bar. There’s no visual boundary or additional spacing to distinguish the items as being nested.\n\nIf a bar doesn’t employ the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem\/Identifier-swift.struct\/otherItemsProxy] identifier, the system hides that bar when another bar, lower in the responder chain, is eligible for display.\n\nWhen determining which items to show in the Touch Bar for the current first responder, the system traverses up the entire responder chain. This lets the system accommodate any proxy items in bars defined for objects higher in the chain, thereby respecting the fact that any bar, defined for an object at any position in the responder chain, might include the other-items-proxy identifier.\n\n#### Customization for composed bars\n\nThe logical, geometric boundary for a nested [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] object isn’t visible to the user in the Touch Bar. However, the boundary remains in effect in terms of customization. A user can’t rearrange a nested bar’s items outside of its boundary.\n\nFor example, say you have a bar, higher in the responder chain, configured like this:\n\n```other\n[(1)(2)(other-items-proxy)(3)]\n```\n\nAnd say you also have a bar, lower in the responder chain, eligible for display in the Touch Bar according to the system and the current app state, configured like this:\n\n```other\n[(A)(B)(C)]\n```\n\nThe composed bar would correspond to this arrangement in the Touch Bar:\n\n```other\n[(1)(2)(A)(B)(C)(3)]\n```\n\nWith the customization UI, the user could then rearrange the items represented here by `(A)`, `(B)`, and `(C)`, but only as long as those items remained contiguous during the rearrangement, thereby respecting the logical boundary of the bar that defines them.\n\n#### Item spacing for composed bars\n\nWhen the system nests [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar] objects that include spacing items, it merges any resulting adjacent spacing. Ensure that your bars appear as you expect them to, testing on the versions of macOS that you support. For more on spacing items, see [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem].\n\n### Bar discovery and the responder chain\n\nAt runtime, the system traverses up the responder chain, starting at the object with focus, to discover objects that conform to the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarProvider] protocol. Such objects are called *bar providers*. The system then populates the Touch Bar, potentially with multiple, nested bars, according to system policy and available geometric space.\n\nSpecifically, bar discovery by the system proceeds in the following order:\n\n1. Key window’s first responder\n2. Key window\n3. Key window’s delegate\n4. Key window’s controller\n5. Main window’s first responder\n6. Main window\n7. Main window’s delegate\n8. Main window’s controller\n9. App object\n10. App delegate\n\nWhen the system encounters a bar provider that’s an instance of an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSResponder] subclass, the system then additionally searches up the responder chain anchored at that object.\n\nFor example, in a complicated but otherwise standard app, bar discovery might proceed in this order:\n\n1. Key window’s first responder\n2. View controller of key window’s first responder\n3. Intermediate view controllers and views\n4. View that’s closest to root of window\n5. View controller that’s closest to root of window\n6. Key window\n7. Key window’s controller\n8. App object\n9. App delegate\n\nThe Touch Bar can show one bar nested within another, as described in [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBar#Composition-and-nesting].\n\n### Accessibility and the Touch Bar\n\nAppKit views and controls adopt the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSAccessibilityProtocol] protocol and automatically send appropriate accessibility notifications. Because the Touch Bar is designed to work with AppKit, it’s fully accessible.\n\nBe sure to use the `customizationLabel` property on every [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] instance that you designate as customizable. The accessibility system in macOS makes use of these labels.\n\nTo learn more about accessibility, read [doc:\/\/com.apple.appkit\/documentation\/AppKit\/accessibility-for-appkit].\n\n### AppKit support for the Touch Bar\n\nTo support the Touch Bar feature, AppKit provides several enhancements, first available in macOS 10.12.1:\n\n- **Scrubbers.** The [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSScrubber] class, along with related APIs, provide a way for you to add a flexible, horizontally-oriented picker to a custom item (an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSCustomTouchBarItem] class).\n- **Gesture recognizer support.**\n- You can use the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSMagnificationGestureRecognizer] class in bar items. To enable two-finger pinch gestures, set the recognizer’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/allowedTouchTypes] mask property, on the gesture recognizer, to the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouch\/TouchType\/direct] constant from the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouch\/TouchTypeMask] enumeration.\n- The [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer] abstract class is enhanced with a set of methods that let you implement responses to touch events: [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/touchesBegan(with:)], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/touchesCancelled(with:)], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/touchesEnded(with:)], and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/touchesMoved(with:)].\n- The [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSClickGestureRecognizer], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPanGestureRecognizer], and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSPressGestureRecognizer] concrete classes are each enhanced with a `numberOfTouchesRequired` property to let you specify the number of touches required for a gesture match.\n- **Touch type changes.** To enable touch events in a custom view, you must set the value of a view’s [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/allowedTouchTypes] property to a value of [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouch\/TouchTypeMask\/direct]. (In macOS 10.12.1, the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSView\/acceptsTouchEvents] property is deprecated in favor of the new [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/allowedTouchTypes] property.)\n- **Touch changes.** The [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouch] class has a new property and two new methods for supporting the Touch Bar: [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouch\/TouchType], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGestureRecognizer\/location(in:)], and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouch\/previousLocation(in:)].\n- **Control appearance support.** The [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSButton], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSegmentedControl], and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSlider] classes are each enhanced with appearance support properties: [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSButton\/bezelColor] for buttons, [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSegmentedControl\/selectedSegmentBezelColor] for segmented controls, and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSlider\/trackFillColor] for sliders. (With the Touch Bar, you employ sliders indirectly, as used by slider items.)\n- **Convenience initializers.** Starting in macOS 10.12, you can use a rich set of convenience initializers for controls. These initializers simplify the definition of bar items and take care of appearance and sizing for the Touch Bar. In particular, the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSButton], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSegmentedControl], and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSlider] classes now offer a variety of convenience initializers such as [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSButton\/init(title:image:target:action:)].\n- **Text support.** Methods and properties in the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSpellChecker], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTextField], and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTextView] classes, and in the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTextFieldDelegate] and [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTextViewDelegate] protocols, support using the Touch Bar for spell checking, predictive text suggestion, text completion, and automatic handling of trailing space. For example:\n- When you use an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTextView] object, you gain automatic Touch Bar support for text styling and predictive text suggestions.\n- When you use an [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSCandidateListTouchBarItem] object, you can use the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSSpellChecker\/requestCandidates(forSelectedRange:in:types:options:inSpellDocumentWithTag:completionHandler:)] method. This method provides a completion handler that you can use to filter or otherwise manage the candidate text.\n- **New template images.** AppKit adds many new template images for you to use in your [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem] objects. A few examples of these images are: [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSImage\/touchBarAddTemplateName], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSImage\/touchBarComposeTemplateName], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSImage\/touchBarGoBackTemplateName], [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSImage\/touchBarGoForwardTemplateName], and `NSImageNameTouchBarHomeTemplate`. Always use templates for images in your items: they respond automatically to system white-point changes. Note that these images are exclusively for use in the Touch Bar and *not* in onscreen windows. For a complete list of these template images, see [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSTouchBarItem].\n- **Scroll views.** If your UI for a popover item needs more horizontal space, you can use a scroll view (an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSScrollView] class). *Don’t*, in this case, enable the popover item’s press-and-hold option, because doing so interferes with scrolling.\n- **Stack views.** You can group bar items by using an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSStackView] class. However, doing so loses system support for spacing. When you instead place items into a group item (an instance of the [doc:\/\/com.apple.appkit\/documentation\/AppKit\/NSGroupTouchBarItem] class), the system:\n- Manages inter-item spacing\n- Supports user customization for the individual items\n\n### Development considerations for the Touch Bar\n\nThe Xcode Touch Bar simulator represents the Touch Bar onscreen and supports some user interaction. However, some interactions are unavailable in the simulator. For example, you can’t perform two-finger gestures in the Touch Bar simulator.\n\nIf you’re adopting Touch Bar support for your app, but running Xcode on a Mac without a Touch Bar, you can enable the Xcode Touch Bar simulator by choosing Window > Show Touch Bar in Xcode.\n\nInterface Builder supports development for the Touch Bar with nib objects available in the object library. Drag and drop bars and items from the object library into your canvas, and then attach them to your app’s responders as desired. For more information, see Xcode Help.\n\n### Performance considerations for the Touch Bar\n\nThe Touch Bar’s display and the MacBook screen share resources, including the main CPU and GPU of the MacBook. To ensure that your Touch Bar controls perform well, follow the usual best practice of protecting your app’s main thread from doing too much work. For example, don’t perform rendering work for the main display on the main thread.\n\nIn addition, pay attention to the relative amounts of time your app spends on updates to the main display relative to updates to the Touch Bar. The optimum ratio can vary according to what the user is doing. For example:\n\n- When a user is interacting with the Touch Bar *and* watching the Touch Bar, such as to control audio, ensure that your app gives priority to updating the Touch Bar.\n- When a user is instead interacting with the Touch Bar but watching the main display, such as when using a scrubber to browse pages of content, balance your app’s display update work between the Touch Bar and the main display.\n\nAlways test Touch Bar performance using the specific MacBook hardware you support. Specifically, don’t rely on the Xcode Touch Bar simulator when tuning your app for Touch Bar performance.\n\n## Creating a bar\n\n- **init()**: Creates a Touch Bar object.\n- **init(coder:)**: Creates a Touch Bar object from a coder object provided by a storyboard or NIB file.\n\n## Providing bar items\n\n- **delegate**: The delegate that provides items to the Touch Bar.\n- **templateItems**: The primary source of items that the Touch Bar uses to fill its private items array, unless you provide items using a delegate.\n- **defaultItemIdentifiers**: A required list of identifiers for items that you want to appear in the Touch Bar after instantiating it.\n- **principalItemIdentifier**: The identifier of an item you want the system to center in the Touch Bar.\n- **escapeKeyReplacementItemIdentifier**: The identifier of an item that replaces the system-provided button in the Touch Bar.\n\n## Observing bar status\n\n- **isVisible**: A Boolean value that Indicates whether the Touch Bar is eligible for display.\n- **itemIdentifiers**: The list of identifiers for the current items in the Touch Bar.\n- **item(forIdentifier:)**: Returns the Touch Bar item that corresponds to a given identifier.\n\n## Configuring user customization\n\n- **customizationIdentifier**: A globally unique string that makes the Touch Bar eligible for user customization.\n- **customizationAllowedItemIdentifiers**: A list of identifiers for items to show in the Touch Bar’s customization UI.\n- **customizationRequiredItemIdentifiers**: An optional list of identifiers for items you want to always appear in the Touch Bar and which the user can’t remove during customization.\n- **NSTouchBar.CustomizationIdentifier**: The default type for a Touch Bar customization identifier.\n- **isAutomaticCustomizeTouchBarMenuItemEnabled**: A Boolean value indicating whether the main menu contains an item for customizing the contents of the Touch Bar.\n\n## Essentials\n\n- **Integrating a Toolbar and Touch Bar into Your App**: Provide users quick access to your app’s features from a toolbar and corresponding Touch Bar.\n- **Creating and Customizing the Touch Bar**: Adopt Touch Bar support by displaying interactive content and controls for your macOS apps.\n- **NSTouchBarDelegate**: A protocol that allows you to provide the items for a bar dynamically.\n- **NSTouchBarProvider**: A protocol that an object adopts to create a bar object in your app.\n\n## Inherits From\n\n- NSObject\n\n## Conforms To\n\n- CVarArg\n- Copyable\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Equatable\n- Hashable\n- NSCoding\n- NSObjectProtocol\n- Sendable\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a Touch Bar object.",
          "name" : "init()",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/init()"
        },
        {
          "description" : "Creates a Touch Bar object from a coder object provided by a storyboard or NIB file.",
          "name" : "init(coder:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/init(coder:)"
        }
      ],
      "title" : "Creating a bar"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The delegate that provides items to the Touch Bar.",
          "name" : "delegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/delegate"
        },
        {
          "description" : "The primary source of items that the Touch Bar uses to fill its private items array, unless you provide items using a delegate.",
          "name" : "templateItems",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/templateItems"
        },
        {
          "description" : "A required list of identifiers for items that you want to appear in the Touch Bar after instantiating it.",
          "name" : "defaultItemIdentifiers",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/defaultItemIdentifiers"
        },
        {
          "description" : "The identifier of an item you want the system to center in the Touch Bar.",
          "name" : "principalItemIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/principalItemIdentifier"
        },
        {
          "description" : "The identifier of an item that replaces the system-provided button in the Touch Bar.",
          "name" : "escapeKeyReplacementItemIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/escapeKeyReplacementItemIdentifier"
        }
      ],
      "title" : "Providing bar items"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A Boolean value that Indicates whether the Touch Bar is eligible for display.",
          "name" : "isVisible",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/isVisible"
        },
        {
          "description" : "The list of identifiers for the current items in the Touch Bar.",
          "name" : "itemIdentifiers",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/itemIdentifiers"
        },
        {
          "description" : "Returns the Touch Bar item that corresponds to a given identifier.",
          "name" : "item(forIdentifier:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/item(forIdentifier:)"
        }
      ],
      "title" : "Observing bar status"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A globally unique string that makes the Touch Bar eligible for user customization.",
          "name" : "customizationIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/customizationIdentifier-swift.property"
        },
        {
          "description" : "A list of identifiers for items to show in the Touch Bar’s customization UI.",
          "name" : "customizationAllowedItemIdentifiers",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/customizationAllowedItemIdentifiers"
        },
        {
          "description" : "An optional list of identifiers for items you want to always appear in the Touch Bar and which the user can’t remove during customization.",
          "name" : "customizationRequiredItemIdentifiers",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/customizationRequiredItemIdentifiers"
        },
        {
          "description" : "The default type for a Touch Bar customization identifier.",
          "name" : "NSTouchBar.CustomizationIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/CustomizationIdentifier-swift.typealias"
        },
        {
          "description" : "A Boolean value indicating whether the main menu contains an item for customizing the contents of the Touch Bar.",
          "name" : "isAutomaticCustomizeTouchBarMenuItemEnabled",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar\/isAutomaticCustomizeTouchBarMenuItemEnabled"
        }
      ],
      "title" : "Configuring user customization"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Provide users quick access to your app’s features from a toolbar and corresponding Touch Bar.",
          "name" : "Integrating a Toolbar and Touch Bar into Your App",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/integrating-a-toolbar-and-touch-bar-into-your-app"
        },
        {
          "description" : "Adopt Touch Bar support by displaying interactive content and controls for your macOS apps.",
          "name" : "Creating and Customizing the Touch Bar",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/creating-and-customizing-the-touch-bar"
        },
        {
          "description" : "A protocol that allows you to provide the items for a bar dynamically.",
          "name" : "NSTouchBarDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBarDelegate"
        },
        {
          "description" : "A protocol that an object adopts to create a bar object in your app.",
          "name" : "NSTouchBarProvider",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBarProvider"
        }
      ],
      "title" : "Essentials"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "NSObject"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "NSTouchBar",
  "url" : "https:\/\/developer.apple.com\/documentation\/AppKit\/NSTouchBar"
}