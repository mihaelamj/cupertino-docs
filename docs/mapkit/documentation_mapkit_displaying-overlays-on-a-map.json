{
  "abstract" : "Add regions of layered content to a map view.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ A rectangular area containing San Francisco.\nstatic let sanFranciscoRectangle = [\n    CLLocationCoordinate2D(latitude: 37.816_41, longitude: -122.522_62),\n    CLLocationCoordinate2D(latitude: 37.816_41, longitude: -122.355_54),\n    CLLocationCoordinate2D(latitude: 37.702_08, longitude: -122.355_54),\n    CLLocationCoordinate2D(latitude: 37.702_08, longitude: -122.522_62)\n]",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Creates a rectangle polygon.\nvar rectangleOverlay: MKPolygon {\n    return MKPolygon(coordinates: LocationData.sanFranciscoRectangle, count: LocationData.sanFranciscoRectangle.count)\n}",
      "language" : "swift"
    },
    {
      "code" : "init() {\n    \/\/\/ In a real app, the event data probably downloads from a server. This sample loads GeoJSON data from a local file instead.\n    if let jsonUrl = Bundle.main.url(forResource: \"event\", withExtension: \"json\") {\n        do {\n            let eventData = try Data(contentsOf: jsonUrl)\n\n            \/\/ Use the `MKGeoJSONDecoder` to convert the JSON data into MapKit objects, such as `MKGeoJSONFeature`.\n            let decoder = MKGeoJSONDecoder()\n            let jsonObjects = try decoder.decode(eventData)\n\n            parse(jsonObjects)\n        } catch {\n            print(\"Error decoding GeoJSON: \\(error).\")\n        }\n    }\n}\n\nprivate func parse(_ jsonObjects: [MKGeoJSONObject]) {\n    for object in jsonObjects {\n\n        \/**\n         In this sample's GeoJSON data, there are only GeoJSON features at the top level, so this parse method only checks for those. An\n         implementation that parses arbitrary GeoJSON files needs to check for GeoJSON geometry objects too.\n        *\/\n        if let feature = object as? MKGeoJSONFeature {\n            for geometry in feature.geometry {\n\n                \/**\n                 Separate annotation objects from overlay objects because you add them to the map view in different ways. This sample\n                 GeoJSON only contains `Point` and `MultiPolygon` geometry. In a generic parser, check for all possible geometry types.\n                *\/\n                if let multiPolygon = geometry as? MKMultiPolygon {\n                    overlays.append(multiPolygon)\n                } else if let point = geometry as? MKPointAnnotation {\n                     \/\/ The name of the annotation passes in the feature properties.\n                     \/\/ Parse the name and apply it to the annotation.\n                    configure(annotation: point, using: feature.properties)\n                    annotations.append(point)\n                }\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "mapView.addOverlay(reliefTileOverlay, level: .aboveLabels)",
      "language" : "swift"
    },
    {
      "code" : "func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {\n    switch overlay {\n    case let overlay as MKCircle:\n        return createCircleRenderer(for: overlay)\n    case let overlay as MKGeodesicPolyline:\n        return createGeodesicPolylineRenderer(for: overlay)\n    case let overlay as MKPolyline where currentExample == .gradientPolyline:\n        return createGradientPolylineRenderer(for: overlay)\n    case let overlay as MKPolyline:\n        return createPolylineRenderer(for: overlay)\n    case let overlay as MKPolygon where currentExample == .blendModes:\n        return createBlendModesPolygonRenderer(for: overlay)\n    case let overlay as MKPolygon:\n        return createPolygonRenderer(for: overlay)\n    case let overlay as MKMultiPolygon:\n        return createMultiPolylineRenderer(for: overlay)\n    case let overlay as PeakGroundAccelerationGrid:\n        return createCustomRenderer(for: overlay)\n    case let overlay as MKTileOverlay:\n        return createTileRenderer(for: overlay)\n    default:\n        return MKOverlayRenderer(overlay: overlay)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Create a circle overlay that centers on San Francisco.\nlet circleOverlay = MKCircle(center: LocationData.sanFranciscoGeographicCenter, radius: 9000)\nmapView.addOverlay(circleOverlay, level: overlayLevel)",
      "language" : "swift"
    },
    {
      "code" : "func createCircleRenderer(for circle: MKCircle) -> MKCircleRenderer {\n    \/**\n     Some of the most common customizations for an `MKOverlayRenderer` include customizing drawing settings, such as the\n     fill color of an enclosed shape, or the stroke color for the edge of the shape.\n     *\/\n    let renderer = MKCircleRenderer(circle: circle)\n    renderer.lineWidth = 2\n    renderer.strokeColor = .systemBlue\n    renderer.fillColor = .systemTeal\n    renderer.alpha = 0.5\n    \n    return renderer\n}",
      "language" : "swift"
    },
    {
      "code" : "\/**\n Apply a custom pattern to the line, alternating dash length with space length in drawing points.\n The pattern repeats for the length of the polyline.\n *\/\nrenderer.lineDashPattern = [20 as NSNumber,   \/\/ Long dash\n                            10 as NSNumber,   \/\/ Space\n                             5 as NSNumber,   \/\/ Shorter dash\n                            10 as NSNumber,   \/\/ Space\n                             1 as NSNumber,   \/\/ Dot\n                            10 as NSNumber]   \/\/ Space",
      "language" : "swift"
    },
    {
      "code" : "func createGradientPolylineRenderer(for line: MKPolyline) -> MKGradientPolylineRenderer {\n    let renderer = MKGradientPolylineRenderer(polyline: line)\n    \n    let colorPalette: [UIColor] = [.systemPurple, .systemMint, .systemOrange, .systemTeal, .systemRed]\n    \n    \/**\n     Gradient polylines take an array of colors and an array of locations to place each color within the gradient.\n     The system describes the location values as a fractional distance along the polyline between 0.0 (representing the first point) and\n     1.0 (representing the last point).\n     \n     For apps that add a color to the gradient per point in the polyline, `MKPolyline` offers the `location(atPointIndex:)` function to\n     compute the location value for use with the gradient polyline.\n     *\/\n    var unitDistances = [CGFloat]()\n    var colors = [UIColor]()\n    var index = 0\n    while index < line.pointCount {\n        \/\/ Figure out the location of a point in the polyline as a fraction of unit distance between 0 and 1.\n        unitDistances.append(line.location(atPointIndex: index))\n        \n        \/\/ Pick a color to add to the gradient.\n        colors.append(colorPalette[index % colorPalette.count])\n        \n        index += 1\n    }\n    \n    renderer.setColors(colors, locations: unitDistances)\n    renderer.lineWidth = 2\n    \n    return renderer\n}",
      "language" : "swift"
    },
    {
      "code" : "func createMultiPolylineRenderer(for multiPolygon: MKMultiPolygon) -> MKMultiPolygonRenderer {\n    let renderer = MKMultiPolygonRenderer(multiPolygon: multiPolygon)\n    renderer.fillColor = UIColor(named: \"MultiPolygonOverlayFill\")\n    renderer.strokeColor = UIColor(named: \"MultiPolygonOverlayStroke\")\n    renderer.lineWidth = 2.0\n\n    return renderer\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Turn an array of points into a polygon. You can also load the polygon from a GeoJSON file by using `MKGeoJSONDecoder`.\nlet parkPolygon = MKPolygon(coordinates: LocationData.plazaDeCesarChavezParkOutline,\n                                 count: LocationData.plazaDeCesarChavezParkOutline.count)\n\n\/\/\/ Create an overlay polygon that covers the entire world, except for a cutout of the highlighted park.\nlet worldPoints = [MKMapRect.world.origin,\n                   MKMapPoint(x: MKMapRect.world.origin.x, y: MKMapRect.world.origin.y + MKMapRect.world.size.height),\n                   MKMapPoint(x: MKMapRect.world.origin.x + MKMapRect.world.size.width, y: MKMapRect.world.origin.y),\n                   MKMapPoint(x: MKMapRect.world.origin.x + MKMapRect.world.size.width,\n                              y: MKMapRect.world.origin.y + MKMapRect.world.size.height)]\nlet desaturatedBase = MKPolygon(points: worldPoints, count: worldPoints.count, interiorPolygons: [parkPolygon])",
      "language" : "swift"
    },
    {
      "code" : "func createBlendModesPolygonRenderer(for overlay: MKPolygon) -> MKPolygonRenderer {\n    let renderer = MKPolygonRenderer(polygon: overlay)\n    \n    if overlay.interiorPolygons == nil {\n        \/\/\/ An overlay without `interiorPolygons` is the overlay highlighting the park.\n        renderer.fillColor = traitCollection.userInterfaceStyle == .light ? .darkGray : .white\n        renderer.blendMode = .colorBurn\n    } else {\n        \/\/\/ An overlay with `interiorPolygons` is the background overlay to desaturate.\n        renderer.fillColor = .gray\n        renderer.blendMode = .screen\n    }\n    return renderer\n}",
      "language" : "swift"
    },
    {
      "code" : "override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n    \/\/ Don't draw anything that doesn't intersect the data set.\n    guard mapRect.intersects(data.boundingMapRect) else { return }\n    \n    \/**\n     Determine the section of the overlay to render. MapKit breaks overlays into multiple rectangles for rendering on multiple threads.\n     Each call to `draw(_:zoomScale:in:)` should only render within bounds of the provided `mapRect`.\n     If your drawing implementation needs to draw content outside of the provided `mapRect` as part of its drawing algorithm, apply a clipping\n     rectangle by calling `clip(to:)` on the `CGContext`.\n     *\/\n    let intersection = mapRect.intersection(data.boundingMapRect)",
      "language" : "swift"
    },
    {
      "code" : "let point1Conversion = point(for: coord1.mapPoint)",
      "language" : "swift"
    },
    {
      "code" : "let tileDirectoryName = \"tileData\"\nguard let resourcePath = Bundle.main.resourcePath else { return }\nlet localPath = \"file:\/\/\\(resourcePath)\/\\(tileDirectoryName)\/{z}\/{x}\/{y}.jpg\"\nlet tileOverlay = MKTileOverlay(urlTemplate: localPath)",
      "language" : "swift"
    },
    {
      "code" : "\/**\n Types that derive from `MKOverlay`, such as `MKPolygon`, also conform to `MKAnnotation`, enabling you to add them to the map as an overlay,\n as well as place an annotation on the overlay to label it.\n *\/\nparkPolygon.title = \"Concert Location\"\nmapView.addAnnotation(parkPolygon)",
      "language" : "swift"
    }
  ],
  "contentHash" : "96f61d755e717273d2656f26976c7af625152f8401f6cd1c74130a37eebbc2d8",
  "crawledAt" : "2025-12-02T15:49:00Z",
  "id" : "B9C7F050-AC30-4D96-8EF4-F35CC870EDAA",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "MapKit",
  "overview" : "## Overview\n\nOverlays offer a way to layer content over regions of a map and have that content scale with the map. This sample code project demonstrates how to draw common shapes, how to perform custom drawing outside of a common shape, and how to use map tiles from additional data sources.\n\n### Define overlays with geographic coordinates\n\nOverlays are data objects that represent geographic information. Most overlays use geographic coordinates to create contiguous or noncontiguous sets of lines, rectangles, circles, and other shapes. For example, this sample app defines a rectangular area enclosing San Francisco as an array of [doc:\/\/com.apple.documentation\/documentation\/CoreLocation\/CLLocationCoordinate2D] coordinates.\n\nThe app creates the overlay objects by providing the coordinate data to an object that conforms to the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlay] protocol. This data object is responsible for managing the data that defines the overlay. MapKit defines several concrete overlay objects for specifying different types of standard shapes, such as circles and polygons. The app uses the coordinate array above to create one of these provided overlay objects — a polygon.\n\nBecause MapKit defines overlays using a protocol, any class in an app can be an overlay object by conforming to the `MKOverlay` protocol, or by subclassing [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKShape] or [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMultiPoint]. For example, `PeakGroundAccelerationGrid` in this sample app is a custom data class representing an overlay, so it subclasses `MKShape`.\n\nAn overlay contains two key properties, a [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlay\/coordinate] that defines the center point of the overlay, and the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlay\/boundingMapRect] that the system expresses as an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapRect] that completely encompasses the overlay’s content. When the app uses system-provided overlay objects, the system automatically computes the values of these properties. When defining a custom overlay object, the class needs to implement these properties and return appropriate values, as the `PeakGroundAccelerationGrid` class in this app demonstrates.\n\n### Load overlay data using GeoJSON\n\n[https:\/\/tools.ietf.org\/html\/rfc7946] is a standards-based data format for representing geographic data, and apps often receive overlay data from a server in GeoJSON format. Rather than connect to a server, this app uses a local GeoJSON file containing `MultiPolygon` features into an `MKMultiPolygon` by using [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKGeoJSONDecoder].\n\n### Display overlays on a map view\n\nThe app adds the overlay data objects to the map in a specific order to ensure that certain overlays display on top of others. To specify whether an overlay is above or below content that the map provides, such as roads and labels, the app calls [doc:\/\/com.apple.documentation\/documentation\/mapkit\/mkmapview\/1452635-addoverlay] with the `level` parameter as a value that [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayLevel] provides.\n\nThe overlay data object doesn’t draw the overlay on the map. A second object, called an *overlay renderer*, handles the drawing responsibilities for displaying the overlay on the map view. After adding an overlay, the map view calls [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapViewDelegate\/mapView(_:rendererFor:)] on its delegate to create an appropriate renderer object. Because this app demonstrates many different overlays, its implementation of `mapView(_:rendererFor:)` creates many different types of overlay renderers. Most apps only use a small number of overlay types, so this function only needs to create the small number of corresponding overlay renderer types.\n\nAfter the app creates the renderer and returns it from `mapView(_:rendererFor:)`, the map view uses the `boundingMapRect` property on the overlay data object to determine when the returned overlay renderer draws the overlay on the map.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/mapkit\/mkmapview\/1452784-overlays] property of [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapView] stores the registered overlays, but the order of the array doesn’t necessarily reflect their visual order on the map. To understand the rendering order of overlays at a specific level, see [doc:\/\/com.apple.documentation\/documentation\/mapkit\/mkmapview\/1452757-overlays].\n\n### Use the standard overlay objects for common shapes\n\nThe app highlights specific map regions with basic shapes by using the standard overlay classes, including [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKCircle], [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolyline], and [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolygon]. For example, it creates a circle overlay using `MKCircle` with a center coordinate and a radius specified in meters to highlight San Francisco.\n\nThe standard overlay classes define the basic shape of the overlay, and the app uses them in conjunction with the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKCircleRenderer], [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolylineRenderer], or [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolygonRenderer] classes to handle the rendering of that shape on the map. The app creates a renderer for the circle described above with the following code:\n\nWhen the app uses the provided renderer classes for common shapes, MapKit vectorizes overlay shapes so that they always remain sharp while the map scales. The app doesn’t change the default value of the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayPathRenderer\/shouldRasterize] property, so the standard overlay shapes always remain sharp. Subclassing any of the provided renderer objects and providing a custom implementation of [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/draw(_:zoomScale:in:)], like the `PeakGroundAccelerationOverlayRenderer` class, automatically enables rasterized rendering.\n\n### Set drawing properties to customize the overlay rendering\n\nThe standard overlay renderers allow customization of common drawing properties for the fill and edges. For example, the app displays an `MKPolyline` overlay using dashes instead of a solid line, and sets a customized dash pattern using the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayPathRenderer\/lineDashPattern] property of an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolylineRenderer].\n\nMapKit also provides [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKGradientPolylineRenderer] to draw a polyline with a color gradient. The app configures a gradient renderer in the following way:\n\n### Render multiple overlays with the same style efficiently\n\nIt’s common to have multiple related overlays appear on the map with an identical visual style. For example, the app displays a map of an outdoor event that uses multiple overlays to show where the stage is located in relation to different event booths. Because the app shows each of these overlays using the same color scheme, it groups the individual overlay objects together using an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMultiPolygon] object.\n\nThe app then adds the grouped overlay to the map view, rather than adding the individual overlays, to avoid requesting a separate renderer for each overlay from its delegate. Instead, the app returns an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMultiPolygonRenderer] from the delegate. This returned renderer applies the same drawing properties to all overlays within the  `MKMultiPolygon`. This is more efficient than creating a renderer for each overlay.\n\n### Create visual effects using blend modes\n\n*Blend modes* relate the content that draws in an overlay to the content that draws behind the overlay. This enables creating visual effects on the map by adding overlays with a specific Z-order and applying a blend mode on the different overlays. For example, the app highlights a park hosting an outdoor event by using blend modes to lighten the map areas outside the park and to amplify the colors within the park.\n\nTo create such an effect, the app uses two overlays. The first overlay covers the entire map except for an inner polygon for the park, and the second overlay is a polygon outlining only the park.\n\nWhen the map view requests renderer objects from the map delegate for these overlay objects, the app configures the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/blendMode] property with the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGBlendMode\/screen] blend mode to lighten the map area outside the park, and the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGBlendMode\/colorBurn] blend mode to darken the colors within the park.\n\nFor further information on blend modes, see “Setting Blend Modes” and “Using Blend Modes with Images” in [https:\/\/developer.apple.com\/library\/archive\/documentation\/GraphicsImaging\/Conceptual\/drawingwithquartz2d\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP30001066].\n\n### Define a custom overlay renderer\n\nTo draw complex overlays that go beyond drawing boundaries and filling standard overlay shapes, this sample code project creates a custom overlay renderer. The app contains data related to earthquake hazards, and defines a custom `MKOverlay` to represent that hazard data. It also defines a custom overlay renderer to draw a color-coded, shaded map of hazards based on the data.\n\nTo create a custom overlay renderer, the app subclasses `MKOverlayRenderer` and implements `draw(_:zoomScale:in:)` to draw the earthquake data into the provided [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGContext]. MapKit calls this method concurrently on multiple background queues for the app to draw the overlay, with each call rendering a specific section of the overlay within the bounds of the `mapRect` parameter.\n\nWhen the app draws the custom overlay, it uses [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapPoint] data associated with the overlay to define shapes. When it needs to convert data between MapKit geometry and Core Graphics geometry, it uses [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/point(for:)].\n\nMapKit also provides [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/mapRect(for:)] for converting rectangles between MapKit geometry and Core Graphics geometry. When implementing a custom renderer, the app doesn’t use the `bounds` or `frame` of the `MKMapView` as reference points during drawing.\n\n### Load custom map tiles\n\nMapKit supports using custom bitmap map tiles to provide an underlying map that’s customizable. For example, this app displays map tiles that emphasize rivers and mountains.\n\nTo use a custom bitmap map tile overlay, the app uses [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKTileOverlay] to manage loading the tile data and [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKTileOverlayRenderer] to render the map tiles. When creating the tile overlay, the app provides a URL template with placeholder values for the tile position, zoom level, and scale factor to the `MKTileOverlay`. When the tile overlay loads the data, MapKit replaces the placeholder values with the required values to load tiles for a specific map region according to the EPSG:3857 spherical Mercator projection coordinate system.\n\nThe URL template can be either an HTTP URL or a file URL, and this app uses both. For example, it loads some map tiles bundled with the app and specifies a file URL template that locates the map tiles within the app’s bundle.\n\nWhen the app loads tiles from a server, it also does so with a URL template, replacing the file URL with an HTTP URL.\n\nThe `CustomLoadingTileOverlay` class in this sample code project implements [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKTileOverlay\/loadTile(at:result:)] to show how to customize tile-loading behavior for specialized loading needs.\n\n### Use an overlay as an annotation\n\nThe `MKOverlay` protocol conforms to the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKAnnotation] protocol. As a result, all overlay objects are also annotation objects. When adding an overlay as an annotation to the map, `MKMapView` displays it at the overlay’s `coordinate` property. For example, the app uses a polygon outlining the park for an outdoor concert as an annotation to label the concert location.\n\nBecause the app treats the overlay object as both an overlay and an annotation, it’s responsible for adding and removing the object from the map view as both an annotation and as an overlay.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/MapKit\/displaying-overlays-on-a-map\ncrawled: 2025-12-02T15:49:00Z\n---\n\n# Displaying overlays on a map\n\n**Sample Code**\n\nAdd regions of layered content to a map view.\n\n## Overview\n\nOverlays offer a way to layer content over regions of a map and have that content scale with the map. This sample code project demonstrates how to draw common shapes, how to perform custom drawing outside of a common shape, and how to use map tiles from additional data sources.\n\n### Define overlays with geographic coordinates\n\nOverlays are data objects that represent geographic information. Most overlays use geographic coordinates to create contiguous or noncontiguous sets of lines, rectangles, circles, and other shapes. For example, this sample app defines a rectangular area enclosing San Francisco as an array of [doc:\/\/com.apple.documentation\/documentation\/CoreLocation\/CLLocationCoordinate2D] coordinates.\n\n```swift\n\/\/\/ A rectangular area containing San Francisco.\nstatic let sanFranciscoRectangle = [\n    CLLocationCoordinate2D(latitude: 37.816_41, longitude: -122.522_62),\n    CLLocationCoordinate2D(latitude: 37.816_41, longitude: -122.355_54),\n    CLLocationCoordinate2D(latitude: 37.702_08, longitude: -122.355_54),\n    CLLocationCoordinate2D(latitude: 37.702_08, longitude: -122.522_62)\n]\n```\n\nThe app creates the overlay objects by providing the coordinate data to an object that conforms to the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlay] protocol. This data object is responsible for managing the data that defines the overlay. MapKit defines several concrete overlay objects for specifying different types of standard shapes, such as circles and polygons. The app uses the coordinate array above to create one of these provided overlay objects — a polygon.\n\n```swift\n\/\/\/ Creates a rectangle polygon.\nvar rectangleOverlay: MKPolygon {\n    return MKPolygon(coordinates: LocationData.sanFranciscoRectangle, count: LocationData.sanFranciscoRectangle.count)\n}\n```\n\nBecause MapKit defines overlays using a protocol, any class in an app can be an overlay object by conforming to the `MKOverlay` protocol, or by subclassing [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKShape] or [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMultiPoint]. For example, `PeakGroundAccelerationGrid` in this sample app is a custom data class representing an overlay, so it subclasses `MKShape`.\n\nAn overlay contains two key properties, a [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlay\/coordinate] that defines the center point of the overlay, and the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlay\/boundingMapRect] that the system expresses as an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapRect] that completely encompasses the overlay’s content. When the app uses system-provided overlay objects, the system automatically computes the values of these properties. When defining a custom overlay object, the class needs to implement these properties and return appropriate values, as the `PeakGroundAccelerationGrid` class in this app demonstrates.\n\n### Load overlay data using GeoJSON\n\n[https:\/\/tools.ietf.org\/html\/rfc7946] is a standards-based data format for representing geographic data, and apps often receive overlay data from a server in GeoJSON format. Rather than connect to a server, this app uses a local GeoJSON file containing `MultiPolygon` features into an `MKMultiPolygon` by using [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKGeoJSONDecoder].\n\n```swift\ninit() {\n    \/\/\/ In a real app, the event data probably downloads from a server. This sample loads GeoJSON data from a local file instead.\n    if let jsonUrl = Bundle.main.url(forResource: \"event\", withExtension: \"json\") {\n        do {\n            let eventData = try Data(contentsOf: jsonUrl)\n\n            \/\/ Use the `MKGeoJSONDecoder` to convert the JSON data into MapKit objects, such as `MKGeoJSONFeature`.\n            let decoder = MKGeoJSONDecoder()\n            let jsonObjects = try decoder.decode(eventData)\n\n            parse(jsonObjects)\n        } catch {\n            print(\"Error decoding GeoJSON: \\(error).\")\n        }\n    }\n}\n\nprivate func parse(_ jsonObjects: [MKGeoJSONObject]) {\n    for object in jsonObjects {\n\n        \/**\n         In this sample's GeoJSON data, there are only GeoJSON features at the top level, so this parse method only checks for those. An\n         implementation that parses arbitrary GeoJSON files needs to check for GeoJSON geometry objects too.\n        *\/\n        if let feature = object as? MKGeoJSONFeature {\n            for geometry in feature.geometry {\n\n                \/**\n                 Separate annotation objects from overlay objects because you add them to the map view in different ways. This sample\n                 GeoJSON only contains `Point` and `MultiPolygon` geometry. In a generic parser, check for all possible geometry types.\n                *\/\n                if let multiPolygon = geometry as? MKMultiPolygon {\n                    overlays.append(multiPolygon)\n                } else if let point = geometry as? MKPointAnnotation {\n                     \/\/ The name of the annotation passes in the feature properties.\n                     \/\/ Parse the name and apply it to the annotation.\n                    configure(annotation: point, using: feature.properties)\n                    annotations.append(point)\n                }\n            }\n        }\n    }\n}\n```\n\n### Display overlays on a map view\n\nThe app adds the overlay data objects to the map in a specific order to ensure that certain overlays display on top of others. To specify whether an overlay is above or below content that the map provides, such as roads and labels, the app calls [doc:\/\/com.apple.documentation\/documentation\/mapkit\/mkmapview\/1452635-addoverlay] with the `level` parameter as a value that [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayLevel] provides.\n\n```swift\nmapView.addOverlay(reliefTileOverlay, level: .aboveLabels)\n```\n\nThe overlay data object doesn’t draw the overlay on the map. A second object, called an *overlay renderer*, handles the drawing responsibilities for displaying the overlay on the map view. After adding an overlay, the map view calls [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapViewDelegate\/mapView(_:rendererFor:)] on its delegate to create an appropriate renderer object. Because this app demonstrates many different overlays, its implementation of `mapView(_:rendererFor:)` creates many different types of overlay renderers. Most apps only use a small number of overlay types, so this function only needs to create the small number of corresponding overlay renderer types.\n\n```swift\nfunc mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {\n    switch overlay {\n    case let overlay as MKCircle:\n        return createCircleRenderer(for: overlay)\n    case let overlay as MKGeodesicPolyline:\n        return createGeodesicPolylineRenderer(for: overlay)\n    case let overlay as MKPolyline where currentExample == .gradientPolyline:\n        return createGradientPolylineRenderer(for: overlay)\n    case let overlay as MKPolyline:\n        return createPolylineRenderer(for: overlay)\n    case let overlay as MKPolygon where currentExample == .blendModes:\n        return createBlendModesPolygonRenderer(for: overlay)\n    case let overlay as MKPolygon:\n        return createPolygonRenderer(for: overlay)\n    case let overlay as MKMultiPolygon:\n        return createMultiPolylineRenderer(for: overlay)\n    case let overlay as PeakGroundAccelerationGrid:\n        return createCustomRenderer(for: overlay)\n    case let overlay as MKTileOverlay:\n        return createTileRenderer(for: overlay)\n    default:\n        return MKOverlayRenderer(overlay: overlay)\n    }\n}\n```\n\nAfter the app creates the renderer and returns it from `mapView(_:rendererFor:)`, the map view uses the `boundingMapRect` property on the overlay data object to determine when the returned overlay renderer draws the overlay on the map.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/mapkit\/mkmapview\/1452784-overlays] property of [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapView] stores the registered overlays, but the order of the array doesn’t necessarily reflect their visual order on the map. To understand the rendering order of overlays at a specific level, see [doc:\/\/com.apple.documentation\/documentation\/mapkit\/mkmapview\/1452757-overlays].\n\n### Use the standard overlay objects for common shapes\n\nThe app highlights specific map regions with basic shapes by using the standard overlay classes, including [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKCircle], [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolyline], and [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolygon]. For example, it creates a circle overlay using `MKCircle` with a center coordinate and a radius specified in meters to highlight San Francisco.\n\n```swift\n\/\/\/ Create a circle overlay that centers on San Francisco.\nlet circleOverlay = MKCircle(center: LocationData.sanFranciscoGeographicCenter, radius: 9000)\nmapView.addOverlay(circleOverlay, level: overlayLevel)\n```\n\nThe standard overlay classes define the basic shape of the overlay, and the app uses them in conjunction with the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKCircleRenderer], [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolylineRenderer], or [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolygonRenderer] classes to handle the rendering of that shape on the map. The app creates a renderer for the circle described above with the following code:\n\n```swift\nfunc createCircleRenderer(for circle: MKCircle) -> MKCircleRenderer {\n    \/**\n     Some of the most common customizations for an `MKOverlayRenderer` include customizing drawing settings, such as the\n     fill color of an enclosed shape, or the stroke color for the edge of the shape.\n     *\/\n    let renderer = MKCircleRenderer(circle: circle)\n    renderer.lineWidth = 2\n    renderer.strokeColor = .systemBlue\n    renderer.fillColor = .systemTeal\n    renderer.alpha = 0.5\n    \n    return renderer\n}\n```\n\nWhen the app uses the provided renderer classes for common shapes, MapKit vectorizes overlay shapes so that they always remain sharp while the map scales. The app doesn’t change the default value of the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayPathRenderer\/shouldRasterize] property, so the standard overlay shapes always remain sharp. Subclassing any of the provided renderer objects and providing a custom implementation of [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/draw(_:zoomScale:in:)], like the `PeakGroundAccelerationOverlayRenderer` class, automatically enables rasterized rendering.\n\n### Set drawing properties to customize the overlay rendering\n\nThe standard overlay renderers allow customization of common drawing properties for the fill and edges. For example, the app displays an `MKPolyline` overlay using dashes instead of a solid line, and sets a customized dash pattern using the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayPathRenderer\/lineDashPattern] property of an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKPolylineRenderer].\n\n```swift\n\/**\n Apply a custom pattern to the line, alternating dash length with space length in drawing points.\n The pattern repeats for the length of the polyline.\n *\/\nrenderer.lineDashPattern = [20 as NSNumber,   \/\/ Long dash\n                            10 as NSNumber,   \/\/ Space\n                             5 as NSNumber,   \/\/ Shorter dash\n                            10 as NSNumber,   \/\/ Space\n                             1 as NSNumber,   \/\/ Dot\n                            10 as NSNumber]   \/\/ Space\n```\n\nMapKit also provides [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKGradientPolylineRenderer] to draw a polyline with a color gradient. The app configures a gradient renderer in the following way:\n\n```swift\nfunc createGradientPolylineRenderer(for line: MKPolyline) -> MKGradientPolylineRenderer {\n    let renderer = MKGradientPolylineRenderer(polyline: line)\n    \n    let colorPalette: [UIColor] = [.systemPurple, .systemMint, .systemOrange, .systemTeal, .systemRed]\n    \n    \/**\n     Gradient polylines take an array of colors and an array of locations to place each color within the gradient.\n     The system describes the location values as a fractional distance along the polyline between 0.0 (representing the first point) and\n     1.0 (representing the last point).\n     \n     For apps that add a color to the gradient per point in the polyline, `MKPolyline` offers the `location(atPointIndex:)` function to\n     compute the location value for use with the gradient polyline.\n     *\/\n    var unitDistances = [CGFloat]()\n    var colors = [UIColor]()\n    var index = 0\n    while index < line.pointCount {\n        \/\/ Figure out the location of a point in the polyline as a fraction of unit distance between 0 and 1.\n        unitDistances.append(line.location(atPointIndex: index))\n        \n        \/\/ Pick a color to add to the gradient.\n        colors.append(colorPalette[index % colorPalette.count])\n        \n        index += 1\n    }\n    \n    renderer.setColors(colors, locations: unitDistances)\n    renderer.lineWidth = 2\n    \n    return renderer\n}\n```\n\n### Render multiple overlays with the same style efficiently\n\nIt’s common to have multiple related overlays appear on the map with an identical visual style. For example, the app displays a map of an outdoor event that uses multiple overlays to show where the stage is located in relation to different event booths. Because the app shows each of these overlays using the same color scheme, it groups the individual overlay objects together using an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMultiPolygon] object.\n\nThe app then adds the grouped overlay to the map view, rather than adding the individual overlays, to avoid requesting a separate renderer for each overlay from its delegate. Instead, the app returns an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMultiPolygonRenderer] from the delegate. This returned renderer applies the same drawing properties to all overlays within the  `MKMultiPolygon`. This is more efficient than creating a renderer for each overlay.\n\n```swift\nfunc createMultiPolylineRenderer(for multiPolygon: MKMultiPolygon) -> MKMultiPolygonRenderer {\n    let renderer = MKMultiPolygonRenderer(multiPolygon: multiPolygon)\n    renderer.fillColor = UIColor(named: \"MultiPolygonOverlayFill\")\n    renderer.strokeColor = UIColor(named: \"MultiPolygonOverlayStroke\")\n    renderer.lineWidth = 2.0\n\n    return renderer\n}\n```\n\n\n\n### Create visual effects using blend modes\n\n*Blend modes* relate the content that draws in an overlay to the content that draws behind the overlay. This enables creating visual effects on the map by adding overlays with a specific Z-order and applying a blend mode on the different overlays. For example, the app highlights a park hosting an outdoor event by using blend modes to lighten the map areas outside the park and to amplify the colors within the park.\n\nTo create such an effect, the app uses two overlays. The first overlay covers the entire map except for an inner polygon for the park, and the second overlay is a polygon outlining only the park.\n\n```swift\n\/\/\/ Turn an array of points into a polygon. You can also load the polygon from a GeoJSON file by using `MKGeoJSONDecoder`.\nlet parkPolygon = MKPolygon(coordinates: LocationData.plazaDeCesarChavezParkOutline,\n                                 count: LocationData.plazaDeCesarChavezParkOutline.count)\n\n\/\/\/ Create an overlay polygon that covers the entire world, except for a cutout of the highlighted park.\nlet worldPoints = [MKMapRect.world.origin,\n                   MKMapPoint(x: MKMapRect.world.origin.x, y: MKMapRect.world.origin.y + MKMapRect.world.size.height),\n                   MKMapPoint(x: MKMapRect.world.origin.x + MKMapRect.world.size.width, y: MKMapRect.world.origin.y),\n                   MKMapPoint(x: MKMapRect.world.origin.x + MKMapRect.world.size.width,\n                              y: MKMapRect.world.origin.y + MKMapRect.world.size.height)]\nlet desaturatedBase = MKPolygon(points: worldPoints, count: worldPoints.count, interiorPolygons: [parkPolygon])\n```\n\nWhen the map view requests renderer objects from the map delegate for these overlay objects, the app configures the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/blendMode] property with the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGBlendMode\/screen] blend mode to lighten the map area outside the park, and the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGBlendMode\/colorBurn] blend mode to darken the colors within the park.\n\n```swift\nfunc createBlendModesPolygonRenderer(for overlay: MKPolygon) -> MKPolygonRenderer {\n    let renderer = MKPolygonRenderer(polygon: overlay)\n    \n    if overlay.interiorPolygons == nil {\n        \/\/\/ An overlay without `interiorPolygons` is the overlay highlighting the park.\n        renderer.fillColor = traitCollection.userInterfaceStyle == .light ? .darkGray : .white\n        renderer.blendMode = .colorBurn\n    } else {\n        \/\/\/ An overlay with `interiorPolygons` is the background overlay to desaturate.\n        renderer.fillColor = .gray\n        renderer.blendMode = .screen\n    }\n    return renderer\n}\n```\n\nFor further information on blend modes, see “Setting Blend Modes” and “Using Blend Modes with Images” in [https:\/\/developer.apple.com\/library\/archive\/documentation\/GraphicsImaging\/Conceptual\/drawingwithquartz2d\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP30001066].\n\n### Define a custom overlay renderer\n\nTo draw complex overlays that go beyond drawing boundaries and filling standard overlay shapes, this sample code project creates a custom overlay renderer. The app contains data related to earthquake hazards, and defines a custom `MKOverlay` to represent that hazard data. It also defines a custom overlay renderer to draw a color-coded, shaded map of hazards based on the data.\n\nTo create a custom overlay renderer, the app subclasses `MKOverlayRenderer` and implements `draw(_:zoomScale:in:)` to draw the earthquake data into the provided [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGContext]. MapKit calls this method concurrently on multiple background queues for the app to draw the overlay, with each call rendering a specific section of the overlay within the bounds of the `mapRect` parameter.\n\n```swift\noverride func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n    \/\/ Don't draw anything that doesn't intersect the data set.\n    guard mapRect.intersects(data.boundingMapRect) else { return }\n    \n    \/**\n     Determine the section of the overlay to render. MapKit breaks overlays into multiple rectangles for rendering on multiple threads.\n     Each call to `draw(_:zoomScale:in:)` should only render within bounds of the provided `mapRect`.\n     If your drawing implementation needs to draw content outside of the provided `mapRect` as part of its drawing algorithm, apply a clipping\n     rectangle by calling `clip(to:)` on the `CGContext`.\n     *\/\n    let intersection = mapRect.intersection(data.boundingMapRect)\n```\n\nWhen the app draws the custom overlay, it uses [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapPoint] data associated with the overlay to define shapes. When it needs to convert data between MapKit geometry and Core Graphics geometry, it uses [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/point(for:)].\n\n```swift\nlet point1Conversion = point(for: coord1.mapPoint)\n```\n\nMapKit also provides [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKOverlayRenderer\/mapRect(for:)] for converting rectangles between MapKit geometry and Core Graphics geometry. When implementing a custom renderer, the app doesn’t use the `bounds` or `frame` of the `MKMapView` as reference points during drawing.\n\n### Load custom map tiles\n\nMapKit supports using custom bitmap map tiles to provide an underlying map that’s customizable. For example, this app displays map tiles that emphasize rivers and mountains.\n\nTo use a custom bitmap map tile overlay, the app uses [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKTileOverlay] to manage loading the tile data and [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKTileOverlayRenderer] to render the map tiles. When creating the tile overlay, the app provides a URL template with placeholder values for the tile position, zoom level, and scale factor to the `MKTileOverlay`. When the tile overlay loads the data, MapKit replaces the placeholder values with the required values to load tiles for a specific map region according to the EPSG:3857 spherical Mercator projection coordinate system.\n\nThe URL template can be either an HTTP URL or a file URL, and this app uses both. For example, it loads some map tiles bundled with the app and specifies a file URL template that locates the map tiles within the app’s bundle.\n\n```swift\nlet tileDirectoryName = \"tileData\"\nguard let resourcePath = Bundle.main.resourcePath else { return }\nlet localPath = \"file:\/\/\\(resourcePath)\/\\(tileDirectoryName)\/{z}\/{x}\/{y}.jpg\"\nlet tileOverlay = MKTileOverlay(urlTemplate: localPath)\n```\n\nWhen the app loads tiles from a server, it also does so with a URL template, replacing the file URL with an HTTP URL.\n\nThe `CustomLoadingTileOverlay` class in this sample code project implements [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKTileOverlay\/loadTile(at:result:)] to show how to customize tile-loading behavior for specialized loading needs.\n\n### Use an overlay as an annotation\n\nThe `MKOverlay` protocol conforms to the [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKAnnotation] protocol. As a result, all overlay objects are also annotation objects. When adding an overlay as an annotation to the map, `MKMapView` displays it at the overlay’s `coordinate` property. For example, the app uses a polygon outlining the park for an outdoor concert as an annotation to label the concert location.\n\n```swift\n\/**\n Types that derive from `MKOverlay`, such as `MKPolygon`, also conform to `MKAnnotation`, enabling you to add them to the map as an overlay,\n as well as place an annotation on the overlay to label it.\n *\/\nparkPolygon.title = \"Concert Location\"\nmapView.addAnnotation(parkPolygon)\n```\n\nBecause the app treats the overlay object as both an overlay and an annotation, it’s responsible for adding and removing the object from the map view as both an annotation and as an overlay.\n\n## Samples\n\n- **Displaying an updating path of a user’s location history**: Continually update a MapKit overlay displaying the path a user travels.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Continually update a MapKit overlay displaying the path a user travels.",
          "name" : "Displaying an updating path of a user’s location history",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/displaying-an-updating-path-of-a-user-s-location-history"
        }
      ],
      "title" : "Samples"
    }
  ],
  "source" : "appleJSON",
  "title" : "Displaying overlays on a map",
  "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/displaying-overlays-on-a-map"
}