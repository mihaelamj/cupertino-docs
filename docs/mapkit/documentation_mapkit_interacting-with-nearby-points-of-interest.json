{
  "abstract" : "Provide automatic search completions for a partial search query, search the map for relevant locations nearby, and retrieve details for selected points of interest.",
  "codeExamples" : [
    {
      "code" : ".searchable(text: $searchQuery, placement: .navigationBarDrawer(displayMode: .always), prompt: searchPrompt)",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Ask for completion suggestions based on the query text.\nfunc provideCompletionSuggestions(for query: String) {\n    \/**\n     Configure the search to return completion results based only on the options in the app. For example,\n     someone can configure the app to exclude specific point-of-interest categories, or to only return results for addresses.\n     *\/\n    searchCompleter?.resultTypes = mapConfiguration.resultType.completionResultType\n    searchCompleter?.regionPriority = mapConfiguration.regionPriority.localSearchRegionPriority\n    if mapConfiguration.resultType == .pointsOfInterest {\n        searchCompleter?.pointOfInterestFilter = mapConfiguration.pointOfInterestOptions.filter\n    } else if mapConfiguration.resultType == .addresses {\n        searchCompleter?.addressFilter = mapConfiguration.addressOptions.filter\n    }\n    \n    searchCompleter?.region = mapConfiguration.region\n    searchCompleter?.queryFragment = query\n}",
      "language" : "swift"
    },
    {
      "code" : "nonisolated func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {\n    Task { @MainActor in\n        \/**\n         As a person types, new completion suggestions continuously return to this method. Update the property storing the current\n         results, so that the app UI can observe the change and display the updated suggestions.\n         *\/\n        let suggestedCompletions = completer.results\n        resultStreamContinuation?.yield(suggestedCompletions)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : ".searchSuggestions {\n    \/\/ Treat each `MKMapItem` object as unique, using `\\.self` for the identity. The `identifier` property of `MKMapItem`\n    \/\/ is an optional value, and the meaning of the identifier for `MKMapItem` doesn't have the same semantics as\n    \/\/ the `Identifable` protocol that `ForEach` requires.\n    ForEach($searchCompletions, id: \\.self) { completion in\n        SearchCompletionItemView(completion: completion.wrappedValue)\n        .onTapGesture {\n            convertSearchCompletionToSearchResults(completion.wrappedValue)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func createHighlightedString(text: String, rangeValues: [NSValue]) -> NSAttributedString {\n    let attributes = [NSAttributedString.Key.backgroundColor: UIColor(named: \"suggestionHighlight\")!]\n    let highlightedString = NSMutableAttributedString(string: text)\n\n    \/\/ Each `NSValue` wraps an `NSRange` that functions as a style attribute's range with `NSAttributedString`.\n    let ranges = rangeValues.map { $0.rangeValue }\n    for range in ranges {\n        highlightedString.addAttributes(attributes, range: range)\n    }\n\n    return highlightedString\n}",
      "language" : "swift"
    },
    {
      "code" : "let search = MKLocalSearch(request: request)\ncurrentSearch = search\ndefer {\n    \/\/ After the search completes, the reference is no longer needed.\n    currentSearch = nil\n}\n\nvar results: [MKMapItem]\n\ndo {\n    let response = try await search.start()\n    results = response.mapItems\n} catch let error {\n    searchLogging.error(\"Search error: \\(error.localizedDescription)\")\n    results = []\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Use the standard map style, with an option to display specific point-of-interest categories.\n.mapStyle(.standard(pointsOfInterest: mapModel.searchConfiguration.pointOfInterestOptions.categories))\n\n\/\/ Only allow selection for points of interest, and disable selection of other labels, like city names.\n.mapFeatureSelectionDisabled { feature in\n    feature.kind != MapFeature.FeatureKind.pointOfInterest\n}\n\n\/*\n The selection accessory allows people to tap on map features and get more detailed information, which displays\n as either a sheet or a callout according to the `style` parameter. Along with the `selection` binding, this determines\n which feature to display additional information for.\n \n This modifier differs from the `mapItemDetailSelectionAccessory(:_) modifier, which enables the same selection\n behaviors on annotations that the app adds to `Map` for search results.\n *\/\n.mapFeatureSelectionAccessory(.automatic)",
      "language" : "swift"
    },
    {
      "code" : "guard let identifier = mapItem.identifier else { return }\nlet visit = VisitedPlace(id: identifier.rawValue)",
      "language" : "swift"
    },
    {
      "code" : "@MainActor\nfunc convertToMapItem() async -> MKMapItem? {\n    guard let identifier = MKMapItem.Identifier(rawValue: id) else { return nil }\n    let request = MKMapItemRequest(mapItemIdentifier: identifier)\n    var mapItem: MKMapItem? = nil\n    do {\n        mapItem = try await request.mapItem\n    } catch let error {\n        let logger = Logger(subsystem: Bundle.main.bundleIdentifier!, category: \"Map Item Requests\")\n        logger.error(\"Getting map item from identifier failed. Error: \\(error.localizedDescription)\")\n    }\n    return mapItem\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "599fc4704b707c3f9f437ebb1b2175b9fcc0bb9ca0a51c4b53f3a9101b40e1e6",
  "crawledAt" : "2025-12-04T01:21:13Z",
  "id" : "6CCDE910-B557-45E8-A6E5-3EE0521BD2B2",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "MapKit",
  "overview" : "## Overview\n\nThis sample code project demonstrates how to programmatically search for map-based addresses and points of interest using a natural language string, and how to get more information about points of interest that a person selects on the map. The search results center around the locations visible in the map view.\n\n### Request search completions\n\n[doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompleter] retrieves autocomplete suggestions for a partial search query within a map region. A person can type “cof”, and a search completion suggests “coffee” as the query string. As the person types a query into a search bar, the sample app updates the query. In SwiftUI, the sample creates the search field using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/searchable(text:placement:prompt:)] modifier.\n\nAs someone types a query into a search bar, the sample app updates the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompleter\/queryFragment] for the search completion through the `searchQuery` binding.\n\n### Receive completion results\n\nCompletion results represent fully formed query strings based on the query fragment someone types. The sample app uses completion results to populate UI elements to quickly fill in a search query. The app receives the latest completion results as an array of [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompletion] objects by adopting the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompleterDelegate] protocol.\n\nThe app uses an [doc:\/\/com.apple.documentation\/documentation\/Swift\/AsyncStream] to deliver the completion results to the UI, which the `SidebarView`  stores in its `searchCompletions` property. The app displays the search suggestions with the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/searchSuggestions(_:)] modifier, which takes a binding to the `searchCompletions` property.\n\n### Highlight the relationship of a query fragment to the suggestion\n\nWithin the UI elements that represent each query result, the sample code uses the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompletion\/titleHighlightRanges] on an `MKLocalSearchCompletion` to show how the query someone enters relates to the suggested result. For example, the following code applies a highlight with [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSAttributedString]:\n\n### Search for map items\n\nAn `MKLocalSearch.Request` takes either an `MKLocalSearchCompletion` or a natural language query string, and returns an array of [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItem] objects. Each `MKMapItem` represents a geographic location, like a specific address, that matches the search query. The sample code asynchronously retrieves the array of `MKMapItem` objects by calling [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearch\/start(completionHandler:)] on [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearch].\n\n### Allow someone to select points of interest on the map\n\nIf a person is exploring the map, they can get information for a point of interest by tapping it. To provide these interactions, the sample code enables selectable map features as follows:\n\nWhen someone taps a point of interest, the system presents the map item’s details, including information like a phone number, business hours, and buttons to start navigation to the location using Apple Maps. The system presents the information using the style that the `mapFeatureSelectionAccessory(_:)` modifier configures. The sample app uses the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MapItemDetailSelectionAccessoryStyle\/automatic] style, but the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MapItemDetailSelectionAccessoryStyle] structure offers several other options.\n\n### Persist and retrieve map items\n\nIf someone is exploring the map, they may want the app to store places they looked at so that they can come back to them later, including across app launches. `MKMapItem` has an [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItem\/identifier-swift.property] property, which the app stores in its `VisitedPlace` model using `SwiftData`.\n\nWhen the app launches, it retrieves the history of visited locations from SwiftData. To get the `MKMapItem` from the previously stored identifier, the app creates an [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItemRequest] with the stored identifier and calls [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItemRequest\/getMapItem(completionHandler:)].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/mapkit\/interacting-with-nearby-points-of-interest\ncrawled: 2025-12-04T01:21:13Z\n---\n\n# Interacting with nearby points of interest\n\n**Sample Code**\n\nProvide automatic search completions for a partial search query, search the map for relevant locations nearby, and retrieve details for selected points of interest.\n\n## Overview\n\nThis sample code project demonstrates how to programmatically search for map-based addresses and points of interest using a natural language string, and how to get more information about points of interest that a person selects on the map. The search results center around the locations visible in the map view.\n\n### Request search completions\n\n[doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompleter] retrieves autocomplete suggestions for a partial search query within a map region. A person can type “cof”, and a search completion suggests “coffee” as the query string. As the person types a query into a search bar, the sample app updates the query. In SwiftUI, the sample creates the search field using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/searchable(text:placement:prompt:)] modifier.\n\n```swift\n.searchable(text: $searchQuery, placement: .navigationBarDrawer(displayMode: .always), prompt: searchPrompt)\n```\n\nAs someone types a query into a search bar, the sample app updates the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompleter\/queryFragment] for the search completion through the `searchQuery` binding.\n\n```swift\n\/\/\/ Ask for completion suggestions based on the query text.\nfunc provideCompletionSuggestions(for query: String) {\n    \/**\n     Configure the search to return completion results based only on the options in the app. For example,\n     someone can configure the app to exclude specific point-of-interest categories, or to only return results for addresses.\n     *\/\n    searchCompleter?.resultTypes = mapConfiguration.resultType.completionResultType\n    searchCompleter?.regionPriority = mapConfiguration.regionPriority.localSearchRegionPriority\n    if mapConfiguration.resultType == .pointsOfInterest {\n        searchCompleter?.pointOfInterestFilter = mapConfiguration.pointOfInterestOptions.filter\n    } else if mapConfiguration.resultType == .addresses {\n        searchCompleter?.addressFilter = mapConfiguration.addressOptions.filter\n    }\n    \n    searchCompleter?.region = mapConfiguration.region\n    searchCompleter?.queryFragment = query\n}\n```\n\n### Receive completion results\n\nCompletion results represent fully formed query strings based on the query fragment someone types. The sample app uses completion results to populate UI elements to quickly fill in a search query. The app receives the latest completion results as an array of [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompletion] objects by adopting the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompleterDelegate] protocol.\n\n```swift\nnonisolated func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {\n    Task { @MainActor in\n        \/**\n         As a person types, new completion suggestions continuously return to this method. Update the property storing the current\n         results, so that the app UI can observe the change and display the updated suggestions.\n         *\/\n        let suggestedCompletions = completer.results\n        resultStreamContinuation?.yield(suggestedCompletions)\n    }\n}\n```\n\nThe app uses an [doc:\/\/com.apple.documentation\/documentation\/Swift\/AsyncStream] to deliver the completion results to the UI, which the `SidebarView`  stores in its `searchCompletions` property. The app displays the search suggestions with the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/searchSuggestions(_:)] modifier, which takes a binding to the `searchCompletions` property.\n\n```swift\n.searchSuggestions {\n    \/\/ Treat each `MKMapItem` object as unique, using `\\.self` for the identity. The `identifier` property of `MKMapItem`\n    \/\/ is an optional value, and the meaning of the identifier for `MKMapItem` doesn't have the same semantics as\n    \/\/ the `Identifable` protocol that `ForEach` requires.\n    ForEach($searchCompletions, id: \\.self) { completion in\n        SearchCompletionItemView(completion: completion.wrappedValue)\n        .onTapGesture {\n            convertSearchCompletionToSearchResults(completion.wrappedValue)\n        }\n    }\n}\n```\n\n### Highlight the relationship of a query fragment to the suggestion\n\nWithin the UI elements that represent each query result, the sample code uses the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearchCompletion\/titleHighlightRanges] on an `MKLocalSearchCompletion` to show how the query someone enters relates to the suggested result. For example, the following code applies a highlight with [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSAttributedString]:\n\n```swift\nprivate func createHighlightedString(text: String, rangeValues: [NSValue]) -> NSAttributedString {\n    let attributes = [NSAttributedString.Key.backgroundColor: UIColor(named: \"suggestionHighlight\")!]\n    let highlightedString = NSMutableAttributedString(string: text)\n\n    \/\/ Each `NSValue` wraps an `NSRange` that functions as a style attribute's range with `NSAttributedString`.\n    let ranges = rangeValues.map { $0.rangeValue }\n    for range in ranges {\n        highlightedString.addAttributes(attributes, range: range)\n    }\n\n    return highlightedString\n}\n```\n\n### Search for map items\n\nAn `MKLocalSearch.Request` takes either an `MKLocalSearchCompletion` or a natural language query string, and returns an array of [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItem] objects. Each `MKMapItem` represents a geographic location, like a specific address, that matches the search query. The sample code asynchronously retrieves the array of `MKMapItem` objects by calling [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearch\/start(completionHandler:)] on [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKLocalSearch].\n\n```swift\nlet search = MKLocalSearch(request: request)\ncurrentSearch = search\ndefer {\n    \/\/ After the search completes, the reference is no longer needed.\n    currentSearch = nil\n}\n\nvar results: [MKMapItem]\n\ndo {\n    let response = try await search.start()\n    results = response.mapItems\n} catch let error {\n    searchLogging.error(\"Search error: \\(error.localizedDescription)\")\n    results = []\n}\n```\n\n### Allow someone to select points of interest on the map\n\nIf a person is exploring the map, they can get information for a point of interest by tapping it. To provide these interactions, the sample code enables selectable map features as follows:\n\n```swift\n\/\/ Use the standard map style, with an option to display specific point-of-interest categories.\n.mapStyle(.standard(pointsOfInterest: mapModel.searchConfiguration.pointOfInterestOptions.categories))\n\n\/\/ Only allow selection for points of interest, and disable selection of other labels, like city names.\n.mapFeatureSelectionDisabled { feature in\n    feature.kind != MapFeature.FeatureKind.pointOfInterest\n}\n\n\/*\n The selection accessory allows people to tap on map features and get more detailed information, which displays\n as either a sheet or a callout according to the `style` parameter. Along with the `selection` binding, this determines\n which feature to display additional information for.\n \n This modifier differs from the `mapItemDetailSelectionAccessory(:_) modifier, which enables the same selection\n behaviors on annotations that the app adds to `Map` for search results.\n *\/\n.mapFeatureSelectionAccessory(.automatic)\n```\n\nWhen someone taps a point of interest, the system presents the map item’s details, including information like a phone number, business hours, and buttons to start navigation to the location using Apple Maps. The system presents the information using the style that the `mapFeatureSelectionAccessory(_:)` modifier configures. The sample app uses the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MapItemDetailSelectionAccessoryStyle\/automatic] style, but the [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MapItemDetailSelectionAccessoryStyle] structure offers several other options.\n\n### Persist and retrieve map items\n\nIf someone is exploring the map, they may want the app to store places they looked at so that they can come back to them later, including across app launches. `MKMapItem` has an [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItem\/identifier-swift.property] property, which the app stores in its `VisitedPlace` model using `SwiftData`.\n\n```swift\nguard let identifier = mapItem.identifier else { return }\nlet visit = VisitedPlace(id: identifier.rawValue)\n```\n\nWhen the app launches, it retrieves the history of visited locations from SwiftData. To get the `MKMapItem` from the previously stored identifier, the app creates an [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItemRequest] with the stored identifier and calls [doc:\/\/com.apple.mapkit\/documentation\/MapKit\/MKMapItemRequest\/getMapItem(completionHandler:)].\n\n```swift\n@MainActor\nfunc convertToMapItem() async -> MKMapItem? {\n    guard let identifier = MKMapItem.Identifier(rawValue: id) else { return nil }\n    let request = MKMapItemRequest(mapItemIdentifier: identifier)\n    var mapItem: MKMapItem? = nil\n    do {\n        mapItem = try await request.mapItem\n    } catch let error {\n        let logger = Logger(subsystem: Bundle.main.bundleIdentifier!, category: \"Map Item Requests\")\n        logger.error(\"Getting map item from identifier failed. Error: \\(error.localizedDescription)\")\n    }\n    return mapItem\n}\n```\n\n## Local search\n\n- **MKLocalSearchRegionPriority**: A value that indicates the importance of the configured region.\n- **MKLocalSearch.ResultType**: Options that indicate types of search results.\n- **MKLocalSearch**: A utility object for initiating map-based searches and processing the results.\n- **MKAddressFilter.Options**: A structure that contains options for filtering results in a search.\n- **MKAddressFilter**: An object that filters which address options to include or exclude in search results.\n- **MKLocalSearchCompleter.ResultType**: Options that indicate types of search completions.\n- **MKLocalSearchCompleter**: A utility object for generating a list of completion strings based on a partial search string that you provide.\n- **MKLocalSearchCompletion**: A fully formed string that completes a partial string.\n- **MKLocalPointsOfInterestRequest**: A structured request to use when searching for points of interest.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A value that indicates the importance of the configured region.",
          "name" : "MKLocalSearchRegionPriority",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKLocalSearchRegionPriority"
        },
        {
          "description" : "Options that indicate types of search results.",
          "name" : "MKLocalSearch.ResultType",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKLocalSearch\/ResultType"
        },
        {
          "description" : "A utility object for initiating map-based searches and processing the results.",
          "name" : "MKLocalSearch",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKLocalSearch"
        },
        {
          "description" : "A structure that contains options for filtering results in a search.",
          "name" : "MKAddressFilter.Options",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKAddressFilter\/Options"
        },
        {
          "description" : "An object that filters which address options to include or exclude in search results.",
          "name" : "MKAddressFilter",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKAddressFilter"
        },
        {
          "description" : "Options that indicate types of search completions.",
          "name" : "MKLocalSearchCompleter.ResultType",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKLocalSearchCompleter\/ResultType"
        },
        {
          "description" : "A utility object for generating a list of completion strings based on a partial search string that you provide.",
          "name" : "MKLocalSearchCompleter",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKLocalSearchCompleter"
        },
        {
          "description" : "A fully formed string that completes a partial string.",
          "name" : "MKLocalSearchCompletion",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKLocalSearchCompletion"
        },
        {
          "description" : "A structured request to use when searching for points of interest.",
          "name" : "MKLocalPointsOfInterestRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/MapKit\/MKLocalPointsOfInterestRequest"
        }
      ],
      "title" : "Local search"
    }
  ],
  "source" : "appleJSON",
  "title" : "Interacting with nearby points of interest",
  "url" : "https:\/\/developer.apple.com\/documentation\/mapkit\/interacting-with-nearby-points-of-interest"
}