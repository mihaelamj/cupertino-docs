{
  "abstract" : "Play media full screen, embedded inline, or in a floating Picture in Picture (PiP) window using a player view controller.",
  "codeExamples" : [
    {
      "code" : "private func loadPlayerViewControllerIfNeeded() {\n    if playerViewControllerIfLoaded == nil {\n        playerViewControllerIfLoaded = AVPlayerViewController()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "playerViewController.delegate = self",
      "language" : "swift"
    },
    {
      "code" : "if !playerViewController.hasContent(fromVideo: video) {\n    let playerItem = AVPlayerItem(url: video.hlsUrl)\n    playerViewController.player = AVPlayer(playerItem: playerItem)\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let playerViewController = playerViewControllerIfLoaded else { return }\npresentingViewController.present(playerViewController, animated: true) {\n    playerViewController.player?.play()\n}",
      "language" : "swift"
    },
    {
      "code" : "func playerViewController(\n    _ playerViewController: AVPlayerViewController,\n    willBeginFullScreenPresentationWithAnimationCoordinator coordinator: UIViewControllerTransitionCoordinator\n    ) {\n    status.insert([.fullScreenActive, .beingPresented])\n    \n    coordinator.animate(alongsideTransition: nil) { context in\n        self.status.remove(.beingPresented)\n        \/\/ Check context.isCancelled to determine whether the transition is successful.\n        if context.isCancelled {\n            self.status.remove(.fullScreenActive)\n        } else {\n            \/\/ Keep note of the view controller that the system uses to present full screen.\n            self.fullScreenViewController = context.viewController(forKey: .to)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func playerViewController(\n    _ playerViewController: AVPlayerViewController,\n    willEndFullScreenPresentationWithAnimationCoordinator coordinator: UIViewControllerTransitionCoordinator\n    ) {\n    status.insert([.beingDismissed])\n    delegate?.playerViewControllerCoordinatorWillDismiss(self)\n    \n    coordinator.animate(alongsideTransition: nil) { context in\n        self.status.remove(.beingDismissed)\n        if !context.isCancelled {\n            self.status.remove(.fullScreenActive)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func addDebugHUDToPlayerViewControllerIfNeeded() {\n    if status.contains(.embeddedInline) || status.contains(.fullScreenActive) {\n        if let playerViewController = playerViewControllerIfLoaded,\n            let contentOverlayView = playerViewController.contentOverlayView,\n            !debugHud.isDescendant(of: contentOverlayView) {\n            playerViewController.contentOverlayView?.addSubview(debugHud)",
      "language" : "swift"
    },
    {
      "code" : "private(set) var status: Status = [] {\n    didSet {\n        debugHud.status = status\n        externalDebugHud.status = status\n        if oldValue.isBeingShown && !status.isBeingShown {\n            playerViewControllerIfLoaded = nil\n        }\n        addDebugHUDToPlayerViewControllerIfNeeded()\n    }",
      "language" : "swift"
    },
    {
      "code" : "readyForDisplayObservation = playerViewController.observe(\\.isReadyForDisplay) { [weak self] observed, _ in\n    if observed.isReadyForDisplay {\n        self?.status.insert(.readyForDisplay)\n    } else {\n        self?.status.remove(.readyForDisplay)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func embedInline(in parent: UIViewController, container: UIView) {\n    loadPlayerViewControllerIfNeeded()\n    guard let playerViewController = playerViewControllerIfLoaded, playerViewController.parent != parent else { return }\n    removeFromParentIfNeeded()\n    status.insert(.embeddedInline)\n    parent.addChild(playerViewController)\n    container.addSubview(playerViewController.view)\n    playerViewController.view.translatesAutoresizingMaskIntoConstraints = false\n    NSLayoutConstraint.activate([\n        playerViewController.view.centerXAnchor.constraint(equalTo: container.centerXAnchor),\n        playerViewController.view.centerYAnchor.constraint(equalTo: container.centerYAnchor),\n        playerViewController.view.widthAnchor.constraint(equalTo: container.widthAnchor),\n        playerViewController.view.heightAnchor.constraint(equalTo: container.heightAnchor)\n    ])\n    playerViewController.didMove(toParent: parent)\n}",
      "language" : "swift"
    },
    {
      "code" : "func playerViewControllerWillStartPictureInPicture(_ playerViewController: AVPlayerViewController) {\n    status.insert(.pictureInPictureActive)\n}\n\nfunc playerViewControllerDidStopPictureInPicture(_ playerViewController: AVPlayerViewController) {\n    status.remove(.pictureInPictureActive)\n}\n\nfunc playerViewController(_ playerViewController: AVPlayerViewController, failedToStartPictureInPictureWithError error: Error) {\n    status.remove(.pictureInPictureActive)\n}",
      "language" : "swift"
    },
    {
      "code" : "func playerViewController(\n    _ playerViewController: AVPlayerViewController,\n    restoreUserInterfaceForPictureInPictureStopWithCompletionHandler completionHandler: @escaping (Bool) -> Void\n    ) {\n    if let delegate = delegate {\n        delegate.playerViewControllerCoordinator(self, restoreUIForPIPStop: completionHandler)\n    } else {\n        completionHandler(false)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "6d1e5fe5dcdbb94f17c7574ff387a2f9a801e8cd24734dbfb0f20235e003d464",
  "crawledAt" : "2025-12-03T08:21:01Z",
  "id" : "EF11F6EB-083F-4899-9A62-483E3C802988",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "AVKit",
  "overview" : "## Overview\n\nAVKit is a cross-platform media playback UI framework built on top of [doc:\/\/com.apple.documentation\/documentation\/AVFoundation] and [doc:\/\/com.apple.documentation\/documentation\/CoreMedia]. It makes it easy to play [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer]-based media content using the same user interface as Apple’s own apps. For UIKit apps, AVKit provides [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController], a view controller that displays content from a player and presents a native user interface to control playback.\n\nThis sample app demonstrates three display options for media playback using [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController]: full screen, embedded inline, or in a floating PiP window.\n\nThe sample uses `AVPlayerViewController` in full-screen playback mode to scale the video to fill the display, enabling a distraction-free environment that hides the system and app controls until people take action to reveal them.  To demonstrate video inline playback, the sample embeds the `AVPlayerViewController` view in the app’s user interface. The sample also uses `AVPlayerViewController` to play video in PiP mode, where the video remains in view in a floating video overlay while the user interacts with other apps. The user manages the player using the standard player interface.\n\nGetting started with [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] is straightforward. You create an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer], and then create an `AVPlayerViewController` and assign the player to it. And finally, you present the `AVPlayerViewController`. When playing full screen, embedded inline, or in a floating PiP window, you implement callback methods to respond to the various `AVPlayerViewController` events.\n\n### Create and configure the player view controller\n\nThe sample’s `loadPlayerViewControllerIfNeeded` function creates an [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] that it uses to play the videos in the various playback modes.\n\nThe sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate] methods to respond to player view controller events. This allows the sample to handle the app’s user interface based on the player view controller state, along with observing for potential errors. To receive notifications of the player view controller events, the project’s `PlayerViewControllerCoordinator` assigns itself as the player view controller delegate.\n\nA player view controller requires an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer] object to provide the media content to display. The `AVPlayer` plays media assets that AVFoundation models using the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVAsset] class, which represent the media to play. However, an `AVAsset` only models the static aspects of the media, such as its duration or creation date, and on its own, is unsuitable for playback with an `AVPlayer`. To play an asset, the sample creates an instance of its dynamic counterpart, [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayerItem]. This object models the timing and presentation state of an asset that an instance of `AVPlayer` plays. The sample creates an `AVPlayer` from the `AVPlayerItem`, and assigns the `AVPlayer` to the `AVPlayerViewController`.\n\n### Play media full screen\n\nWhen the user taps on one of the app’s views to play video full screen, the sample calls the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/present(_:animated:completion:)] method to present the video full screen modally, not as a subview controller of some other view controller. The sample uses the default modal presentation style [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIModalPresentationStyle\/automatic], which resolves to a full-screen presentation. To begin playback, the sample calls the `AVPlayerViewController` player’s [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer\/play()] method.\n\n### Handle player view controller full-screen events\n\nThe sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewController(_:willBeginFullScreenPresentationWithAnimationCoordinator:)] delegate method to receive notifications when the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] is about to start displaying its contents full screen. This delegate method passes the player view controller and transition coordinator to use for coordinating animations. When the sample presents or dismisses a view controller, UIKit creates a transition coordinator object automatically and assigns it to the view controller’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/transitionCoordinator] property. The transition coordinator object only lasts for the duration of the transition animation.\n\nThe sample calls the transition coordinator’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewControllerTransitionCoordinator\/animate(alongsideTransition:completion:)] method to run the animations at the same time as the view controller transition animations. The sample also implements the `animate(alongsideTransition:completion:)` method’s completion handler that executes after the transition finishes. In the completion handler, the sample updates the playback state string that displays in the content overlay view on top of the player view controller. The sample also checks whether the transition succeeds or the user cancels it. If it succeeds, the sample saves a strong reference to the player view controller. The sample uses this reference to dismiss any active player view controllers before restoring the app’s interface when PiP stops.\n\nThe sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewController(_:willEndFullScreenPresentationWithAnimationCoordinator:)] delegate method to receive notifications when the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] is about to stop displaying its contents full screen. In this method, the sample also calls the transition coordinator’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewControllerTransitionCoordinator\/animate(alongsideTransition:completion:)] method to run the animations at the same time as the view controller transition animations. The sample implements the `animate(alongsideTransition:completion:)` method’s completion handler to update the debug string that displays in the content overlay view on top of the player view controller.\n\n### Display custom overlays in the player view controller\n\n[doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] provides a [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController\/contentOverlayView] property for adding noninteractive custom views, such as a logo or watermark, between the video content and the controls.\n\nThe sample creates a custom view `DebugHUD` for displaying the current playback state (embedded inline, full-screen active, and so on) of a video playback item. The sample’s `addDebugHUDToPlayerViewControllerIfNeeded` function adds this custom view to the `contentOverlayView`.\n\nThe sample’s `PlayerViewControllerCoordinator` declares the `status` variable that maintains the current playback state.\n\nThe `PlayerViewControllerCoordinator` updates the playback state in the `DebugHUD` view in response to player view controller events and other state changes. For example, to receive notifications when the player view controller video frames are ready for display, the sample observes the player view controller’s [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController\/isReadyForDisplay] property. When the property changes, the `PlayerViewControllerCoordinator` updates the `status` variable to reflect the current playback state.\n\n### Play media inline\n\nThe sample’s `embedInline` function incorporates the player view controller’s view into the app’s view hierarchy for inline playback. To do this, the function first checks whether an `AVPlayerViewController` object already exists in the view hierarchy, and if so, removes it. Next, the function adds the `AVPlayerViewController` as a subview of the current view controller. After that, it adds the `AVPlayerViewController` `view` to the specified containing view so that it resides on top of any subviews. Lastly, the function calls the view controller [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/didMove(toParent:)] function. Container view controller subclasses need to call `didMove(toParent:)` after a transition to the new subview completes or, in the case of no transition, immediately after the call to [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/addChild(_:)].\n\nThe user manages inline playback using the standard player interface.\n\n### Configure audio session and background modes for PiP\n\nTo use PiP, the sample configures its audio session and background modes. For more information, see [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/configuring-your-app-for-media-playback]. After this configuration, the player view controller automatically supports PiP playback.\n\n### Handle PiP player view controller events\n\nTo receive notifications when PiP is about to start, or fails to start, the sample implements the delegate methods [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewControllerWillStartPictureInPicture(_:)] and [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewPictureInPictureDelegate\/playerView(_:failedToStartPictureInPictureWithError:)], respectively. To receive notifications when PiP stops, the sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewControllerDidStopPictureInPicture(_:)] method.\n\nEach of the sample’s `AVPlayerViewControllerDelegate` method implementations updates the `DebugHUD` custom view to reflect the current playback state.\n\n### Restore the video playback interface when PiP stops\n\nTo handle the restore process when PiP stops, the sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewPictureInPictureDelegate\/playerView(_:restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:)] method. The framework calls this method when control returns to the app, giving the app the opportunity to determine how to properly restore its video playback interface. The sample sends the callback up to its own delegate to handle the restore operation.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/avkit\/playing-video-content-in-a-standard-user-interface\ncrawled: 2025-12-03T08:21:01Z\n---\n\n# Playing video content in a standard user interface\n\n**Sample Code**\n\nPlay media full screen, embedded inline, or in a floating Picture in Picture (PiP) window using a player view controller.\n\n## Overview\n\nAVKit is a cross-platform media playback UI framework built on top of [doc:\/\/com.apple.documentation\/documentation\/AVFoundation] and [doc:\/\/com.apple.documentation\/documentation\/CoreMedia]. It makes it easy to play [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer]-based media content using the same user interface as Apple’s own apps. For UIKit apps, AVKit provides [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController], a view controller that displays content from a player and presents a native user interface to control playback.\n\nThis sample app demonstrates three display options for media playback using [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController]: full screen, embedded inline, or in a floating PiP window.\n\nThe sample uses `AVPlayerViewController` in full-screen playback mode to scale the video to fill the display, enabling a distraction-free environment that hides the system and app controls until people take action to reveal them.  To demonstrate video inline playback, the sample embeds the `AVPlayerViewController` view in the app’s user interface. The sample also uses `AVPlayerViewController` to play video in PiP mode, where the video remains in view in a floating video overlay while the user interacts with other apps. The user manages the player using the standard player interface.\n\nGetting started with [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] is straightforward. You create an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer], and then create an `AVPlayerViewController` and assign the player to it. And finally, you present the `AVPlayerViewController`. When playing full screen, embedded inline, or in a floating PiP window, you implement callback methods to respond to the various `AVPlayerViewController` events.\n\n\n\n### Create and configure the player view controller\n\nThe sample’s `loadPlayerViewControllerIfNeeded` function creates an [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] that it uses to play the videos in the various playback modes.\n\n```swift\nprivate func loadPlayerViewControllerIfNeeded() {\n    if playerViewControllerIfLoaded == nil {\n        playerViewControllerIfLoaded = AVPlayerViewController()\n    }\n}\n```\n\nThe sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate] methods to respond to player view controller events. This allows the sample to handle the app’s user interface based on the player view controller state, along with observing for potential errors. To receive notifications of the player view controller events, the project’s `PlayerViewControllerCoordinator` assigns itself as the player view controller delegate.\n\n```swift\nplayerViewController.delegate = self\n```\n\nA player view controller requires an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer] object to provide the media content to display. The `AVPlayer` plays media assets that AVFoundation models using the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVAsset] class, which represent the media to play. However, an `AVAsset` only models the static aspects of the media, such as its duration or creation date, and on its own, is unsuitable for playback with an `AVPlayer`. To play an asset, the sample creates an instance of its dynamic counterpart, [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayerItem]. This object models the timing and presentation state of an asset that an instance of `AVPlayer` plays. The sample creates an `AVPlayer` from the `AVPlayerItem`, and assigns the `AVPlayer` to the `AVPlayerViewController`.\n\n```swift\nif !playerViewController.hasContent(fromVideo: video) {\n    let playerItem = AVPlayerItem(url: video.hlsUrl)\n    playerViewController.player = AVPlayer(playerItem: playerItem)\n}\n```\n\n### Play media full screen\n\nWhen the user taps on one of the app’s views to play video full screen, the sample calls the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/present(_:animated:completion:)] method to present the video full screen modally, not as a subview controller of some other view controller. The sample uses the default modal presentation style [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIModalPresentationStyle\/automatic], which resolves to a full-screen presentation. To begin playback, the sample calls the `AVPlayerViewController` player’s [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer\/play()] method.\n\n```swift\nguard let playerViewController = playerViewControllerIfLoaded else { return }\npresentingViewController.present(playerViewController, animated: true) {\n    playerViewController.player?.play()\n}\n```\n\n### Handle player view controller full-screen events\n\nThe sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewController(_:willBeginFullScreenPresentationWithAnimationCoordinator:)] delegate method to receive notifications when the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] is about to start displaying its contents full screen. This delegate method passes the player view controller and transition coordinator to use for coordinating animations. When the sample presents or dismisses a view controller, UIKit creates a transition coordinator object automatically and assigns it to the view controller’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/transitionCoordinator] property. The transition coordinator object only lasts for the duration of the transition animation.\n\nThe sample calls the transition coordinator’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewControllerTransitionCoordinator\/animate(alongsideTransition:completion:)] method to run the animations at the same time as the view controller transition animations. The sample also implements the `animate(alongsideTransition:completion:)` method’s completion handler that executes after the transition finishes. In the completion handler, the sample updates the playback state string that displays in the content overlay view on top of the player view controller. The sample also checks whether the transition succeeds or the user cancels it. If it succeeds, the sample saves a strong reference to the player view controller. The sample uses this reference to dismiss any active player view controllers before restoring the app’s interface when PiP stops.\n\n```swift\nfunc playerViewController(\n    _ playerViewController: AVPlayerViewController,\n    willBeginFullScreenPresentationWithAnimationCoordinator coordinator: UIViewControllerTransitionCoordinator\n    ) {\n    status.insert([.fullScreenActive, .beingPresented])\n    \n    coordinator.animate(alongsideTransition: nil) { context in\n        self.status.remove(.beingPresented)\n        \/\/ Check context.isCancelled to determine whether the transition is successful.\n        if context.isCancelled {\n            self.status.remove(.fullScreenActive)\n        } else {\n            \/\/ Keep note of the view controller that the system uses to present full screen.\n            self.fullScreenViewController = context.viewController(forKey: .to)\n        }\n    }\n}\n```\n\nThe sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewController(_:willEndFullScreenPresentationWithAnimationCoordinator:)] delegate method to receive notifications when the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] is about to stop displaying its contents full screen. In this method, the sample also calls the transition coordinator’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewControllerTransitionCoordinator\/animate(alongsideTransition:completion:)] method to run the animations at the same time as the view controller transition animations. The sample implements the `animate(alongsideTransition:completion:)` method’s completion handler to update the debug string that displays in the content overlay view on top of the player view controller.\n\n```swift\nfunc playerViewController(\n    _ playerViewController: AVPlayerViewController,\n    willEndFullScreenPresentationWithAnimationCoordinator coordinator: UIViewControllerTransitionCoordinator\n    ) {\n    status.insert([.beingDismissed])\n    delegate?.playerViewControllerCoordinatorWillDismiss(self)\n    \n    coordinator.animate(alongsideTransition: nil) { context in\n        self.status.remove(.beingDismissed)\n        if !context.isCancelled {\n            self.status.remove(.fullScreenActive)\n        }\n    }\n}\n```\n\n### Display custom overlays in the player view controller\n\n[doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] provides a [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController\/contentOverlayView] property for adding noninteractive custom views, such as a logo or watermark, between the video content and the controls.\n\nThe sample creates a custom view `DebugHUD` for displaying the current playback state (embedded inline, full-screen active, and so on) of a video playback item. The sample’s `addDebugHUDToPlayerViewControllerIfNeeded` function adds this custom view to the `contentOverlayView`.\n\n```swift\nprivate func addDebugHUDToPlayerViewControllerIfNeeded() {\n    if status.contains(.embeddedInline) || status.contains(.fullScreenActive) {\n        if let playerViewController = playerViewControllerIfLoaded,\n            let contentOverlayView = playerViewController.contentOverlayView,\n            !debugHud.isDescendant(of: contentOverlayView) {\n            playerViewController.contentOverlayView?.addSubview(debugHud)\n```\n\nThe sample’s `PlayerViewControllerCoordinator` declares the `status` variable that maintains the current playback state.\n\n```swift\nprivate(set) var status: Status = [] {\n    didSet {\n        debugHud.status = status\n        externalDebugHud.status = status\n        if oldValue.isBeingShown && !status.isBeingShown {\n            playerViewControllerIfLoaded = nil\n        }\n        addDebugHUDToPlayerViewControllerIfNeeded()\n    }\n```\n\nThe `PlayerViewControllerCoordinator` updates the playback state in the `DebugHUD` view in response to player view controller events and other state changes. For example, to receive notifications when the player view controller video frames are ready for display, the sample observes the player view controller’s [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController\/isReadyForDisplay] property. When the property changes, the `PlayerViewControllerCoordinator` updates the `status` variable to reflect the current playback state.\n\n```swift\nreadyForDisplayObservation = playerViewController.observe(\\.isReadyForDisplay) { [weak self] observed, _ in\n    if observed.isReadyForDisplay {\n        self?.status.insert(.readyForDisplay)\n    } else {\n        self?.status.remove(.readyForDisplay)\n    }\n}\n```\n\n### Play media inline\n\nThe sample’s `embedInline` function incorporates the player view controller’s view into the app’s view hierarchy for inline playback. To do this, the function first checks whether an `AVPlayerViewController` object already exists in the view hierarchy, and if so, removes it. Next, the function adds the `AVPlayerViewController` as a subview of the current view controller. After that, it adds the `AVPlayerViewController` `view` to the specified containing view so that it resides on top of any subviews. Lastly, the function calls the view controller [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/didMove(toParent:)] function. Container view controller subclasses need to call `didMove(toParent:)` after a transition to the new subview completes or, in the case of no transition, immediately after the call to [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/addChild(_:)].\n\nThe user manages inline playback using the standard player interface.\n\n```swift\nfunc embedInline(in parent: UIViewController, container: UIView) {\n    loadPlayerViewControllerIfNeeded()\n    guard let playerViewController = playerViewControllerIfLoaded, playerViewController.parent != parent else { return }\n    removeFromParentIfNeeded()\n    status.insert(.embeddedInline)\n    parent.addChild(playerViewController)\n    container.addSubview(playerViewController.view)\n    playerViewController.view.translatesAutoresizingMaskIntoConstraints = false\n    NSLayoutConstraint.activate([\n        playerViewController.view.centerXAnchor.constraint(equalTo: container.centerXAnchor),\n        playerViewController.view.centerYAnchor.constraint(equalTo: container.centerYAnchor),\n        playerViewController.view.widthAnchor.constraint(equalTo: container.widthAnchor),\n        playerViewController.view.heightAnchor.constraint(equalTo: container.heightAnchor)\n    ])\n    playerViewController.didMove(toParent: parent)\n}\n```\n\n### Configure audio session and background modes for PiP\n\nTo use PiP, the sample configures its audio session and background modes. For more information, see [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/configuring-your-app-for-media-playback]. After this configuration, the player view controller automatically supports PiP playback.\n\n### Handle PiP player view controller events\n\nTo receive notifications when PiP is about to start, or fails to start, the sample implements the delegate methods [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewControllerWillStartPictureInPicture(_:)] and [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewPictureInPictureDelegate\/playerView(_:failedToStartPictureInPictureWithError:)], respectively. To receive notifications when PiP stops, the sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewControllerDelegate\/playerViewControllerDidStopPictureInPicture(_:)] method.\n\nEach of the sample’s `AVPlayerViewControllerDelegate` method implementations updates the `DebugHUD` custom view to reflect the current playback state.\n\n```swift\nfunc playerViewControllerWillStartPictureInPicture(_ playerViewController: AVPlayerViewController) {\n    status.insert(.pictureInPictureActive)\n}\n\nfunc playerViewControllerDidStopPictureInPicture(_ playerViewController: AVPlayerViewController) {\n    status.remove(.pictureInPictureActive)\n}\n\nfunc playerViewController(_ playerViewController: AVPlayerViewController, failedToStartPictureInPictureWithError error: Error) {\n    status.remove(.pictureInPictureActive)\n}\n```\n\n### Restore the video playback interface when PiP stops\n\nTo handle the restore process when PiP stops, the sample implements the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewPictureInPictureDelegate\/playerView(_:restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:)] method. The framework calls this method when control returns to the app, giving the app the opportunity to determine how to properly restore its video playback interface. The sample sends the callback up to its own delegate to handle the restore operation.\n\n```swift\nfunc playerViewController(\n    _ playerViewController: AVPlayerViewController,\n    restoreUserInterfaceForPictureInPictureStopWithCompletionHandler completionHandler: @escaping (Bool) -> Void\n    ) {\n    if let delegate = delegate {\n        delegate.playerViewControllerCoordinator(self, restoreUIForPIPStop: completionHandler)\n    } else {\n        completionHandler(false)\n    }\n}\n```\n\n## iOS playback and capture\n\n- **AVPlayerViewController**: A view controller that displays content from a player and presents a native user interface to control playback.\n- **AVPlayerViewControllerDelegate**: A protocol that defines the methods to implement to respond to player view controller events.\n- **AVCaptureEventInteraction**: An object that registers handlers to respond to capture events from system hardware buttons.\n- **AVCaptureEvent**: An object that describes a user interaction with a system hardware button.\n- **AVCaptureEventSound**: A sound object for a capture event.\n- **AVInputPickerInteraction**: Use `AVInputPickerInteraction` to present an input picker.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A view controller that displays content from a player and presents a native user interface to control playback.",
          "name" : "AVPlayerViewController",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVPlayerViewController"
        },
        {
          "description" : "A protocol that defines the methods to implement to respond to player view controller events.",
          "name" : "AVPlayerViewControllerDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVPlayerViewControllerDelegate"
        },
        {
          "description" : "An object that registers handlers to respond to capture events from system hardware buttons.",
          "name" : "AVCaptureEventInteraction",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVCaptureEventInteraction"
        },
        {
          "description" : "An object that describes a user interaction with a system hardware button.",
          "name" : "AVCaptureEvent",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVCaptureEvent"
        },
        {
          "description" : "A sound object for a capture event.",
          "name" : "AVCaptureEventSound",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVCaptureEventSound"
        },
        {
          "description" : "Use `AVInputPickerInteraction` to present an input picker.",
          "name" : "AVInputPickerInteraction",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVInputPickerInteraction"
        }
      ],
      "title" : "iOS playback and capture"
    }
  ],
  "source" : "appleJSON",
  "title" : "Playing video content in a standard user interface",
  "url" : "https:\/\/developer.apple.com\/documentation\/avkit\/playing-video-content-in-a-standard-user-interface"
}