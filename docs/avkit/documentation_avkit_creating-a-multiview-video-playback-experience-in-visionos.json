{
  "abstract" : "Build an interface that plays multiple videos simultaneously and handles transitions to different experience types gracefully.",
  "codeExamples" : [
    {
      "code" : "struct SystemVideoPlayer: UIViewControllerRepresentable {\n    let player: AVPlayer\n\n    func makeUIViewController(context: Context) -> AVPlayerViewController {\n        let playerController = AVPlayerViewController()\n        playerController.player = player\n\n        return playerController\n    }\n\n    func updateUIViewController(_ uiViewController: AVPlayerViewController, context: Context) {}\n}",
      "language" : "swift"
    },
    {
      "code" : "let playerController = AVPlayerViewController()\n\/\/ Enable the multiview experience, along with the default recommended set.\nplayerController.experienceController.allowedExperiences = .recommended(\n    including: [.multiview]\n)",
      "language" : "swift"
    },
    {
      "code" : "let hostingController = UIHostingController(rootView: rootView)\nlet contentSelectionViewController = AVContentSelectionViewController()\ncontentSelectionViewController.preferredContentSize = .init(width: 1200, height: 340.0)\n\n\/\/ Add the `hostingController` and its view to the empty `contentSelectionViewController`.\ncontentSelectionViewController.addChild(hostingController)\ncontentSelectionViewController.view.addSubview(hostingController.view)\n\n\/\/ Notify the `hostingController` that the move is complete.\nhostingController.didMove(toParent: contentSelectionViewController)\n\n\/\/ Set the constraints so that the `hostingController` matches the size of the `contentSelectionViewController`.\nhostingController.view.translatesAutoresizingMaskIntoConstraints = false\nNSLayoutConstraint.activate([\n    contentSelectionViewController.view.leadingAnchor.constraint(equalTo: hostingController.view.leadingAnchor),\n    contentSelectionViewController.view.trailingAnchor.constraint(equalTo: hostingController.view.trailingAnchor),\n    contentSelectionViewController.view.topAnchor.constraint(equalTo: hostingController.view.topAnchor),\n    contentSelectionViewController.view.bottomAnchor.constraint(equalTo: hostingController.view.bottomAnchor)\n])\n\nAVMultiviewManager.default.contentSelectionViewController = contentSelectionViewController",
      "language" : "swift"
    },
    {
      "code" : "self.videoModels.forEach { videoModel in\n    videoModel.viewController.experienceController.delegate = self\n}",
      "language" : "swift"
    },
    {
      "code" : "if let embeddedVideo = multiviewStateModel.embeddedVideo {\n    \/\/ When displaying an embedded video, identify it based on the item\n    \/\/ so that `UIViewControllerRepresentable` can provide the new\n    \/\/ view controller in `makeUIViewController`.\n    ItemVideoPlayer(videoModel: embeddedVideo)\n        .id(embeddedVideo.video.id)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Pause the current embedded video, if there is one.\nawait embeddedVideo?.pauseVideoAndResetPlaybackCursor()\n\n\/\/ If the selected video isn't in the view hierarchy,\n\/\/ add and play it; otherwise, pause and remove it.\nif videoModel.viewController.parent == nil {\n    embeddedVideo = videoModel\n    await videoModel.resetPlaybackCursorAndPlayVideo()\n} else {\n    embeddedVideo = nil\n    await videoModel.pauseVideoAndResetPlaybackCursor()\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Deselecting a video from the content selection view transitions it\n\/\/ to the embedded experience even when there's one video playing.\n\/\/ Deselecting the last video removes the user from the multiview\n\/\/ experience, and returns them to the embedded playback experience.\nawait videoModel.viewController.experienceController.transition(\n    to: videoModel.isAddedToMultiview ? .embedded : .multiview\n)",
      "language" : "swift"
    },
    {
      "code" : "func experienceController(\n    _ controller: AVExperienceController,\n    didChangeTransitionContext context: AVExperienceController.TransitionContext\n) {\n    guard let videoModel = videoModel(for: controller) else {\n        assertionFailure(\"Failed to get item for experience controller\")\n        return\n    }\n\n    if case .transitioning = context.status, videosInMultiview == 0 {\n        \/\/ If there aren't any videos in the multiview experience,\n        \/\/ update the selection state so that while the transition\n        \/\/ is occurring, the UI reflects the added video.\n        videoModel.isAddedToMultiview = context.toExperience != .embedded\n    }\n\n    guard\n        case .finished(let result) = context.status,\n        .completed == result\n    else { return }\n\n    videoModel.isAddedToMultiview = context.toExperience == .multiview\n\n    \/\/ Play new videos that someone successfully adds to the multiview experience.\n    if videoModel.isAddedToMultiview, videosInMultiview > 1 {\n        Task { await videoModel.resetPlaybackCursorAndPlayVideo() }\n    }\n\n    \/\/ If the initial playback experience isn't embedded, remove the embedded video\n    \/\/ from the view hierarchy when transitioning back to the embedded experience.\n    if !supportsEmbeddedPlaybackExperience, context.toExperience == .embedded {\n        embeddedVideo = nil\n        Task { await videoModel.pauseVideoAndResetPlaybackCursor() }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func experienceController(\n    _ controller: AVExperienceController,\n    prepareForTransitionUsing context: AVExperienceController.TransitionContext\n) async {\n    guard let videoModel = videoModel(for: controller) else {\n        assertionFailure(\"Failed to get item for experience controller\")\n        return\n    }\n\n    if context.toExperience == .embedded, videosInMultiview == 1 {\n        embeddedVideo = videoModel\n    }\n\n    setFallbackScene(for: controller, using: context)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ The fallback placement is required for cases where the video doesn't start from the embedded state,\n\/\/ or the video needs to present on top of another scene.\n\/\/ If the video starts in the embedded state, you don't need to set the fallback placement.\nif !supportsEmbeddedPlaybackExperience, context.toExperience == .expanded {\n    if let scene {\n        controller.configuration.expanded.fallbackPlacement = .over(scene: scene)\n    } else {\n        controller.configuration.expanded.fallbackPlacement = .unspecified\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "28db988e7789bc508f03f6fad6887277c40d0435d4bf1accee4e47a8bc748c34",
  "crawledAt" : "2025-12-02T15:33:41Z",
  "id" : "9AC7359D-34D6-42F4-B63A-D5B488E410BD",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "AVKit",
  "overview" : "## Overview\n\nThis sample code project demonstrates how to use the multiview video playback APIs using SwiftUI. It illustrates how an app might display video when showing a video in the embedded experience, and how apps might immediately display a video in the expanded experience. From these experiences, someone can enter the multiview video playback experience to display multiple videos simultaneously.\n\nThe multiview experience lets your app display multiple videos simultaneously. Use this type of experience in apps where watching multiple videos makes sense, such as in a sports app or a security camera app. In a multiview experience, a person starts with one video as their main focus, and adds more videos that interest them. In visionOS, your app can display up to five simultaneous videos.\n\n\n\nMultiview experiences work with the existing [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] class to manage your content. Each instance of the player view controller exposes an [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController\/experienceController] property that manages the available experiences for your content and the transitions between embedded, expanded, and multiview experiences. Use this experience controller to configure the experiences you support, and to initiate transitions between different experience types.\n\nTo facilitate the addition of new videos to your app’s multiview experience, create a custom browsing user interface and provide it to the shared [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager] class. The `AVMultiviewManager` instance coordinates the arrangement of [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] instances in the multiview experience. As your app adds new view controllers, the `AVMultiviewManager` updates the layout to maintain a comfortable and engaging user experience.\n\n### Display the system video player\n\nAdding support for the multiview experience starts with displaying the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController]. The `AVPlayerViewController` is a UIKit view controller that AVKit provides. Use [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewControllerRepresentable] to adapt this for SwiftUI. The following code example creates a `SystemVideoPlayer` view with an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer] property. This property allows the SwiftUI view that contains the `SystemVideoPlayer` view to initialize the player with an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayerItem] and change the video using the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer\/replaceCurrentItem(with:)] method.\n\n### Enable the multiview experience on your video players\n\nThe multiview experience is disabled by default, so your app needs to allow it by setting [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/allowedExperiences] on [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController] to include `.multiview`. In the multiview experience, you can present video from multiple [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] instances together in an interface that an [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager] manages.\n\nAfter allowing the multiview experience, the system player includes a Multiview button in the top left corner of the expanded and embedded video player. People can close the multiview experience to return to the embedded video player at any time.\n\n\n\n### Create a content browser for adding and removing videos\n\nAn [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] displays a single video. When someone enters the multiview experience, [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager] manages the layout of the system video players and displays your content browser beneath the videos. The content browser allows people to select additional videos to play within the experience. Anyone can remove a video from the multiview experience by clicking the close button in the corner of a video, or by using your content browser. After selecting multiple videos, a person can close the content browser to navigate to the playback controls for each video. To provide the view for the content browser, set the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager\/contentSelectionViewController] property on the shared `AVMultiviewManager`.\n\n\n\nWhen designing your content selection view, follow the [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/designing-for-visionos] to create an intuitive experience. This sample code project uses a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIHostingController] class to provide a SwiftUI view as the content selection view controller.\n\nTo provide visual context, it’s important to show an image that represents each video. Depending on your app, this may be a generated thumbnail or a graphic unique to each video. For information about creating an image from a video asset, see [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/creating-images-from-a-video-asset].\n\n### Observe changes in the multiview experience\n\nUsing the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol] methods, your app can react to changes in the multiview experience. This protocol informs your app about the transitions you programmatically initiate and the transitions that trigger within the multiview experience. Update your class to conform to this protocol and set it as the delegate.\n\nThe sample code project uses this protocol to start videos that someone adds to the multiview experience, swap which video is showing in the embedded video player, and update the state that shows which videos are part of the multiview experience. The sample app creates a `MultiviewStateModel` class to conform to this protocol, retains the videos and their player view controllers, and sets this delegate on each of the `VideoModel` objects in the initialization of the `MultiviewStateModel`.\n\n### Change the embedded video\n\nIf your app displays the video player in the embedded state, your view needs to handle changing the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] that’s displaying when someone changes the video within the multiview experience.\n\nThe `SystemVideoPlayer` view in the “Display the system video player” section above is responsible for displaying a single video. To switch which video is playing in the embedded experience and retain the current playback state of the video, create a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewControllerRepresentable] that has an `AVPlayerViewController` property. To insure that SwiftUI provides the updated view controller in `makeUIViewController`, identify the view using the video’s ID.\n\nTo support changing the embedded video set the `embeddedVideo` property to the video item that you want to play. If the video is already selected, consider pausing the video and removing it from the view hierarchy.\n\n### Show and hide videos from your content browser\n\nYour content selection view is responsible for adding and removing videos from the multiview experience. To determine whether to add or remove a video when a person selects an item, keep track of which videos are present in the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager]. Depending on the needs of your app, you can either create all [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] instances on initialization, or create them on demand as you display additional videos.\n\nWhen a person selects a video in the content browser, your app adds or removes the video from the multiview experience by calling [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/transition(to:)] on the associated `AVPlayerViewController` instance.\n\nThe [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/transition(to:)] function performs a request to transition the video to the provided state, but this doesn’t always succeed. This transition fails if you already presented the maximum number of videos. Transitioning to the `.embedded` state fails for the last video in the `AVMultiviewManager` if the view controller isn’t in the view hierarchy. Only update the state and view hierarchy when the transition completes successfully. Use the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol\/experienceController(_:didChangeTransitionContext:)]  delegate method to update your state and view hierarchy for completed transitions. The system calls these delegate methods for changes that your content selection view and the `AVMultiviewManager` trigger.\n\n### Set the newly selected embedded video\n\nPeople can add and remove videos from the multiview experience through the user interface that your content selection view or the `AVMultiviewManager` provides. If your app supports displaying embedded videos, the video playing when someone first enters the multiview experience may be different than the one playing when they return to the embedded experience. Continue to show the currently playing video when a person returns to the embedded experience.\n\nFor example, a person may start the multiview experience viewing video A, and then add video B and others. They may then remove video A prior to closing the experience and returning to your view with the embedded experience. In this case, update the view they return to so it displays video B rather than the initial video A. You can perform view hierarchy and state changes to prepare for a transition in [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol\/experienceController(_:prepareForTransitionUsing:)].\n\n### Show expanded videos outside the view hierarchy\n\nTo display a video in the expanded or embedded states, the original container needs to be in the view hierarchy. This transition fails to complete when the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] isn’t in the view hierarchy because the system requires a scene to transition to these states.\n\nIf you aren’t embedding the video in the view hierarchy, specify a [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/ExpandedConfiguration\/fallbackPlacement] to display the video over the provided scene. You can specify this just before presenting the video in [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol\/experienceController(_:prepareForTransitionUsing:)], or set it earlier in the app life cycle. Retrieve this `UIScene` argument from the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowSceneDelegate] object. For more information about how to provide this delegate in your SwiftUI app, see [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIApplicationDelegateAdaptor].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AVKit\/creating-a-multiview-video-playback-experience-in-visionos\ncrawled: 2025-12-02T15:33:41Z\n---\n\n# Creating a multiview video playback experience in visionOS\n\n**Sample Code**\n\nBuild an interface that plays multiple videos simultaneously and handles transitions to different experience types gracefully.\n\n## Overview\n\nThis sample code project demonstrates how to use the multiview video playback APIs using SwiftUI. It illustrates how an app might display video when showing a video in the embedded experience, and how apps might immediately display a video in the expanded experience. From these experiences, someone can enter the multiview video playback experience to display multiple videos simultaneously.\n\nThe multiview experience lets your app display multiple videos simultaneously. Use this type of experience in apps where watching multiple videos makes sense, such as in a sports app or a security camera app. In a multiview experience, a person starts with one video as their main focus, and adds more videos that interest them. In visionOS, your app can display up to five simultaneous videos.\n\n\n\nMultiview experiences work with the existing [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] class to manage your content. Each instance of the player view controller exposes an [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController\/experienceController] property that manages the available experiences for your content and the transitions between embedded, expanded, and multiview experiences. Use this experience controller to configure the experiences you support, and to initiate transitions between different experience types.\n\nTo facilitate the addition of new videos to your app’s multiview experience, create a custom browsing user interface and provide it to the shared [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager] class. The `AVMultiviewManager` instance coordinates the arrangement of [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] instances in the multiview experience. As your app adds new view controllers, the `AVMultiviewManager` updates the layout to maintain a comfortable and engaging user experience.\n\n### Display the system video player\n\nAdding support for the multiview experience starts with displaying the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController]. The `AVPlayerViewController` is a UIKit view controller that AVKit provides. Use [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewControllerRepresentable] to adapt this for SwiftUI. The following code example creates a `SystemVideoPlayer` view with an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer] property. This property allows the SwiftUI view that contains the `SystemVideoPlayer` view to initialize the player with an [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayerItem] and change the video using the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPlayer\/replaceCurrentItem(with:)] method.\n\n```swift\nstruct SystemVideoPlayer: UIViewControllerRepresentable {\n    let player: AVPlayer\n\n    func makeUIViewController(context: Context) -> AVPlayerViewController {\n        let playerController = AVPlayerViewController()\n        playerController.player = player\n\n        return playerController\n    }\n\n    func updateUIViewController(_ uiViewController: AVPlayerViewController, context: Context) {}\n}\n```\n\n### Enable the multiview experience on your video players\n\nThe multiview experience is disabled by default, so your app needs to allow it by setting [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/allowedExperiences] on [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController] to include `.multiview`. In the multiview experience, you can present video from multiple [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] instances together in an interface that an [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager] manages.\n\n```swift\nlet playerController = AVPlayerViewController()\n\/\/ Enable the multiview experience, along with the default recommended set.\nplayerController.experienceController.allowedExperiences = .recommended(\n    including: [.multiview]\n)\n```\n\nAfter allowing the multiview experience, the system player includes a Multiview button in the top left corner of the expanded and embedded video player. People can close the multiview experience to return to the embedded video player at any time.\n\n\n\n### Create a content browser for adding and removing videos\n\nAn [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] displays a single video. When someone enters the multiview experience, [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager] manages the layout of the system video players and displays your content browser beneath the videos. The content browser allows people to select additional videos to play within the experience. Anyone can remove a video from the multiview experience by clicking the close button in the corner of a video, or by using your content browser. After selecting multiple videos, a person can close the content browser to navigate to the playback controls for each video. To provide the view for the content browser, set the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager\/contentSelectionViewController] property on the shared `AVMultiviewManager`.\n\n\n\nWhen designing your content selection view, follow the [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/designing-for-visionos] to create an intuitive experience. This sample code project uses a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIHostingController] class to provide a SwiftUI view as the content selection view controller.\n\n```swift\nlet hostingController = UIHostingController(rootView: rootView)\nlet contentSelectionViewController = AVContentSelectionViewController()\ncontentSelectionViewController.preferredContentSize = .init(width: 1200, height: 340.0)\n\n\/\/ Add the `hostingController` and its view to the empty `contentSelectionViewController`.\ncontentSelectionViewController.addChild(hostingController)\ncontentSelectionViewController.view.addSubview(hostingController.view)\n\n\/\/ Notify the `hostingController` that the move is complete.\nhostingController.didMove(toParent: contentSelectionViewController)\n\n\/\/ Set the constraints so that the `hostingController` matches the size of the `contentSelectionViewController`.\nhostingController.view.translatesAutoresizingMaskIntoConstraints = false\nNSLayoutConstraint.activate([\n    contentSelectionViewController.view.leadingAnchor.constraint(equalTo: hostingController.view.leadingAnchor),\n    contentSelectionViewController.view.trailingAnchor.constraint(equalTo: hostingController.view.trailingAnchor),\n    contentSelectionViewController.view.topAnchor.constraint(equalTo: hostingController.view.topAnchor),\n    contentSelectionViewController.view.bottomAnchor.constraint(equalTo: hostingController.view.bottomAnchor)\n])\n\nAVMultiviewManager.default.contentSelectionViewController = contentSelectionViewController\n```\n\nTo provide visual context, it’s important to show an image that represents each video. Depending on your app, this may be a generated thumbnail or a graphic unique to each video. For information about creating an image from a video asset, see [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/creating-images-from-a-video-asset].\n\n### Observe changes in the multiview experience\n\nUsing the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol] methods, your app can react to changes in the multiview experience. This protocol informs your app about the transitions you programmatically initiate and the transitions that trigger within the multiview experience. Update your class to conform to this protocol and set it as the delegate.\n\nThe sample code project uses this protocol to start videos that someone adds to the multiview experience, swap which video is showing in the embedded video player, and update the state that shows which videos are part of the multiview experience. The sample app creates a `MultiviewStateModel` class to conform to this protocol, retains the videos and their player view controllers, and sets this delegate on each of the `VideoModel` objects in the initialization of the `MultiviewStateModel`.\n\n```swift\nself.videoModels.forEach { videoModel in\n    videoModel.viewController.experienceController.delegate = self\n}\n```\n\n### Change the embedded video\n\nIf your app displays the video player in the embedded state, your view needs to handle changing the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] that’s displaying when someone changes the video within the multiview experience.\n\nThe `SystemVideoPlayer` view in the “Display the system video player” section above is responsible for displaying a single video. To switch which video is playing in the embedded experience and retain the current playback state of the video, create a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewControllerRepresentable] that has an `AVPlayerViewController` property. To insure that SwiftUI provides the updated view controller in `makeUIViewController`, identify the view using the video’s ID.\n\n```swift\nif let embeddedVideo = multiviewStateModel.embeddedVideo {\n    \/\/ When displaying an embedded video, identify it based on the item\n    \/\/ so that `UIViewControllerRepresentable` can provide the new\n    \/\/ view controller in `makeUIViewController`.\n    ItemVideoPlayer(videoModel: embeddedVideo)\n        .id(embeddedVideo.video.id)\n}\n```\n\nTo support changing the embedded video set the `embeddedVideo` property to the video item that you want to play. If the video is already selected, consider pausing the video and removing it from the view hierarchy.\n\n```swift\n\/\/ Pause the current embedded video, if there is one.\nawait embeddedVideo?.pauseVideoAndResetPlaybackCursor()\n\n\/\/ If the selected video isn't in the view hierarchy,\n\/\/ add and play it; otherwise, pause and remove it.\nif videoModel.viewController.parent == nil {\n    embeddedVideo = videoModel\n    await videoModel.resetPlaybackCursorAndPlayVideo()\n} else {\n    embeddedVideo = nil\n    await videoModel.pauseVideoAndResetPlaybackCursor()\n}\n```\n\n### Show and hide videos from your content browser\n\nYour content selection view is responsible for adding and removing videos from the multiview experience. To determine whether to add or remove a video when a person selects an item, keep track of which videos are present in the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVMultiviewManager]. Depending on the needs of your app, you can either create all [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] instances on initialization, or create them on demand as you display additional videos.\n\nWhen a person selects a video in the content browser, your app adds or removes the video from the multiview experience by calling [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/transition(to:)] on the associated `AVPlayerViewController` instance.\n\n```swift\n\/\/ Deselecting a video from the content selection view transitions it\n\/\/ to the embedded experience even when there's one video playing.\n\/\/ Deselecting the last video removes the user from the multiview\n\/\/ experience, and returns them to the embedded playback experience.\nawait videoModel.viewController.experienceController.transition(\n    to: videoModel.isAddedToMultiview ? .embedded : .multiview\n)\n```\n\nThe [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/transition(to:)] function performs a request to transition the video to the provided state, but this doesn’t always succeed. This transition fails if you already presented the maximum number of videos. Transitioning to the `.embedded` state fails for the last video in the `AVMultiviewManager` if the view controller isn’t in the view hierarchy. Only update the state and view hierarchy when the transition completes successfully. Use the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol\/experienceController(_:didChangeTransitionContext:)]  delegate method to update your state and view hierarchy for completed transitions. The system calls these delegate methods for changes that your content selection view and the `AVMultiviewManager` trigger.\n\n```swift\nfunc experienceController(\n    _ controller: AVExperienceController,\n    didChangeTransitionContext context: AVExperienceController.TransitionContext\n) {\n    guard let videoModel = videoModel(for: controller) else {\n        assertionFailure(\"Failed to get item for experience controller\")\n        return\n    }\n\n    if case .transitioning = context.status, videosInMultiview == 0 {\n        \/\/ If there aren't any videos in the multiview experience,\n        \/\/ update the selection state so that while the transition\n        \/\/ is occurring, the UI reflects the added video.\n        videoModel.isAddedToMultiview = context.toExperience != .embedded\n    }\n\n    guard\n        case .finished(let result) = context.status,\n        .completed == result\n    else { return }\n\n    videoModel.isAddedToMultiview = context.toExperience == .multiview\n\n    \/\/ Play new videos that someone successfully adds to the multiview experience.\n    if videoModel.isAddedToMultiview, videosInMultiview > 1 {\n        Task { await videoModel.resetPlaybackCursorAndPlayVideo() }\n    }\n\n    \/\/ If the initial playback experience isn't embedded, remove the embedded video\n    \/\/ from the view hierarchy when transitioning back to the embedded experience.\n    if !supportsEmbeddedPlaybackExperience, context.toExperience == .embedded {\n        embeddedVideo = nil\n        Task { await videoModel.pauseVideoAndResetPlaybackCursor() }\n    }\n}\n```\n\n### Set the newly selected embedded video\n\nPeople can add and remove videos from the multiview experience through the user interface that your content selection view or the `AVMultiviewManager` provides. If your app supports displaying embedded videos, the video playing when someone first enters the multiview experience may be different than the one playing when they return to the embedded experience. Continue to show the currently playing video when a person returns to the embedded experience.\n\nFor example, a person may start the multiview experience viewing video A, and then add video B and others. They may then remove video A prior to closing the experience and returning to your view with the embedded experience. In this case, update the view they return to so it displays video B rather than the initial video A. You can perform view hierarchy and state changes to prepare for a transition in [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol\/experienceController(_:prepareForTransitionUsing:)].\n\n```swift\nfunc experienceController(\n    _ controller: AVExperienceController,\n    prepareForTransitionUsing context: AVExperienceController.TransitionContext\n) async {\n    guard let videoModel = videoModel(for: controller) else {\n        assertionFailure(\"Failed to get item for experience controller\")\n        return\n    }\n\n    if context.toExperience == .embedded, videosInMultiview == 1 {\n        embeddedVideo = videoModel\n    }\n\n    setFallbackScene(for: controller, using: context)\n}\n```\n\n### Show expanded videos outside the view hierarchy\n\nTo display a video in the expanded or embedded states, the original container needs to be in the view hierarchy. This transition fails to complete when the [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVPlayerViewController] isn’t in the view hierarchy because the system requires a scene to transition to these states.\n\nIf you aren’t embedding the video in the view hierarchy, specify a [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/ExpandedConfiguration\/fallbackPlacement] to display the video over the provided scene. You can specify this just before presenting the video in [doc:\/\/com.apple.avkit\/documentation\/AVKit\/AVExperienceController\/Delegate-swift.protocol\/experienceController(_:prepareForTransitionUsing:)], or set it earlier in the app life cycle. Retrieve this `UIScene` argument from the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowSceneDelegate] object. For more information about how to provide this delegate in your SwiftUI app, see [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIApplicationDelegateAdaptor].\n\n```swift\n\/\/ The fallback placement is required for cases where the video doesn't start from the embedded state,\n\/\/ or the video needs to present on top of another scene.\n\/\/ If the video starts in the embedded state, you don't need to set the fallback placement.\nif !supportsEmbeddedPlaybackExperience, context.toExperience == .expanded {\n    if let scene {\n        controller.configuration.expanded.fallbackPlacement = .over(scene: scene)\n    } else {\n        controller.configuration.expanded.fallbackPlacement = .unspecified\n    }\n}\n```\n\n## visionOS playback\n\n- **Playing immersive media with AVKit**: Adopt the system playback interface to provide an immersive video watching experience.\n- **Adopting the system player interface in visionOS**: Provide an optimized viewing experience for watching 3D video content.\n- **Trimming and exporting media in visionOS**: Display standard controls in your app to edit the timeline of the currently playing media.\n- **AVPlayerViewController**: A view controller that displays content from a player and presents a native user interface to control playback.\n- **AVPlayerViewControllerDelegate**: A protocol that defines the methods to implement to respond to player view controller events.\n- **AVExperienceController**: An object that controls video experiences.\n- **AVMultiviewManager**: An object that manages viewing multiple videos at once.\n- **AVGroupExperienceCoordinator**: An object that synchronizes viewing environment state across participants in a SharePlay session.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Adopt the system playback interface to provide an immersive video watching experience.",
          "name" : "Playing immersive media with AVKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/playing-immersive-media-with-avkit"
        },
        {
          "description" : "Provide an optimized viewing experience for watching 3D video content.",
          "name" : "Adopting the system player interface in visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/adopting-the-system-player-interface-in-visionos"
        },
        {
          "description" : "Display standard controls in your app to edit the timeline of the currently playing media.",
          "name" : "Trimming and exporting media in visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/trimming-and-exporting-media-in-visionos"
        },
        {
          "description" : "A view controller that displays content from a player and presents a native user interface to control playback.",
          "name" : "AVPlayerViewController",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVPlayerViewController"
        },
        {
          "description" : "A protocol that defines the methods to implement to respond to player view controller events.",
          "name" : "AVPlayerViewControllerDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVPlayerViewControllerDelegate"
        },
        {
          "description" : "An object that controls video experiences.",
          "name" : "AVExperienceController",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVExperienceController"
        },
        {
          "description" : "An object that manages viewing multiple videos at once.",
          "name" : "AVMultiviewManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVMultiviewManager"
        },
        {
          "description" : "An object that synchronizes viewing environment state across participants in a SharePlay session.",
          "name" : "AVGroupExperienceCoordinator",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/AVGroupExperienceCoordinator"
        }
      ],
      "title" : "visionOS playback"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a multiview video playback experience in visionOS",
  "url" : "https:\/\/developer.apple.com\/documentation\/AVKit\/creating-a-multiview-video-playback-experience-in-visionos"
}