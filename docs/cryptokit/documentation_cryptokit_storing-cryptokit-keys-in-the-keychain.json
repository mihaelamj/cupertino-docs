{
  "abstract" : "Convert between strongly typed cryptographic keys and native keychain types.",
  "codeExamples" : [
    {
      "code" : "protocol SecKeyConvertible: CustomStringConvertible {\n    \/\/\/ Creates a key from an X9.63 representation.\n    init<Bytes>(x963Representation: Bytes) throws where Bytes: ContiguousBytes\n    \n    \/\/\/ An X9.63 representation of the key.\n    var x963Representation: Data { get }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension P256.Signing.PrivateKey: SecKeyConvertible {}\nextension P256.KeyAgreement.PrivateKey: SecKeyConvertible {}\nextension P384.Signing.PrivateKey: SecKeyConvertible {}\nextension P384.KeyAgreement.PrivateKey: SecKeyConvertible {}\nextension P521.Signing.PrivateKey: SecKeyConvertible {}\nextension P521.KeyAgreement.PrivateKey: SecKeyConvertible {}",
      "language" : "swift"
    },
    {
      "code" : "protocol GenericPasswordConvertible: CustomStringConvertible {\n    \/\/\/ Creates a key from a generic key representation.\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes\n    \n    \/\/\/ A generic representation of the key.\n    var genericKeyRepresentation: SymmetricKey { get }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Curve25519.KeyAgreement.PrivateKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        try self.init(rawRepresentation: data)\n    }\n\n    var genericKeyRepresentation: SymmetricKey {\n        self.rawRepresentation.withUnsafeBytes {\n            SymmetricKey(data: $0)\n        }\n    }\n}\nextension Curve25519.Signing.PrivateKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        try self.init(rawRepresentation: data)\n    }\n\n    var genericKeyRepresentation: SymmetricKey {\n        self.rawRepresentation.withUnsafeBytes {\n            SymmetricKey(data: $0)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension SymmetricKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        self.init(data: data)\n    }\n    \n    var genericKeyRepresentation: SymmetricKey {\n        self\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension SecureEnclave.P256.Signing.PrivateKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        try self.init(dataRepresentation: data.withUnsafeBytes { Data($0) })\n    }\n\n    var genericKeyRepresentation: SymmetricKey {\n        return SymmetricKey(data: dataRepresentation)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func storeKey<T: SecKeyConvertible>(_ key: T, label: String) throws {",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Describe the key.\nlet attributes = [kSecAttrKeyType: kSecAttrKeyTypeECSECPrimeRandom,\n                  kSecAttrKeyClass: kSecAttrKeyClassPrivate] as [String: Any]\n\n\/\/ Get a SecKey representation.\nguard let secKey = SecKeyCreateWithData(key.x963Representation as CFData,\n                                        attributes as CFDictionary,\n                                        nil)\n    else {\n        throw KeyStoreError(\"Unable to create SecKey representation.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Describe the add operation.\nlet query = [kSecClass: kSecClassKey,\n             kSecAttrApplicationLabel: label,\n             kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked,\n             kSecUseDataProtectionKeychain: true,\n             kSecValueRef: secKey] as [String: Any]\n\n\/\/ Add the key to the keychain.\nlet status = SecItemAdd(query as CFDictionary, nil)\nguard status == errSecSuccess else {\n    throw KeyStoreError(\"Unable to store item: \\(status.message)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "func storeKey<T: GenericPasswordConvertible>(_ key: T, account: String) throws {",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Treat the key data as a generic password.\ntry key.genericKeyRepresentation.withUnsafeBytes { keyBytes in\n    let cfd = Data(bytesNoCopy: UnsafeMutableRawPointer(mutating: keyBytes.baseAddress!), count: keyBytes.count, deallocator: .none)\n    let query = [kSecClass: kSecClassGenericPassword,\n                 kSecAttrAccount: account,\n                 kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked,\n                 kSecUseDataProtectionKeychain: true,\n                 kSecValueData: cfd] as [String: Any]\n\n    \/\/ Add the key data.\n    let status = SecItemAdd(query as CFDictionary, nil)\n    guard status == errSecSuccess else {\n        throw KeyStoreError(\"Unable to store item: \\(status.message)\")\n    }\n}\n",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Seek an elliptic-curve key with a given label.\nlet query = [kSecClass: kSecClassKey,\n             kSecAttrApplicationLabel: label,\n             kSecAttrKeyType: kSecAttrKeyTypeECSECPrimeRandom,\n             kSecUseDataProtectionKeychain: true,\n             kSecReturnRef: true] as [String: Any]\n\n\/\/ Find and cast the result as a SecKey instance.\nvar item: CFTypeRef?\nvar secKey: SecKey\nswitch SecItemCopyMatching(query as CFDictionary, &item) {\ncase errSecSuccess: secKey = item as! SecKey\ncase errSecItemNotFound: return nil\ncase let status: throw KeyStoreError(\"Keychain read failed: \\(status.message)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Convert the SecKey into a CryptoKit key.\nvar error: Unmanaged<CFError>?\nguard let data = SecKeyCopyExternalRepresentation(secKey, &error) as Data? else {\n    throw KeyStoreError(error.debugDescription)\n}\nlet key = try T(x963Representation: data)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Seek a generic password with the given account.\nlet query = [kSecClass: kSecClassGenericPassword,\n             kSecAttrAccount: account,\n             kSecUseDataProtectionKeychain: true,\n             kSecReturnData: true] as [String: Any]\n\n\/\/ Find and cast the result as data.\nvar item: CFTypeRef?\nswitch SecItemCopyMatching(query as CFDictionary, &item) {\ncase errSecSuccess:\n    guard let data = item as? Data else { return nil }\n    return try T(genericKeyRepresentation: data)  \/\/ Convert back to a key.\ncase errSecItemNotFound: return nil\ncase let status: throw KeyStoreError(\"Keychain read failed: \\(status.message)\")\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "289b59b3743fe3394f95b38d372ef7cea4ad924ecf50deb6eeed5d9e847a4cb2",
  "crawledAt" : "2025-12-02T16:04:36Z",
  "id" : "170A4CC5-8F04-4667-AC6A-4859C93BCCD5",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Apple CryptoKit",
  "overview" : "## Overview\n\nCryptoKit defines highly specific key types that embody a particular cryptographic algorithm and purpose. Some of these key types, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P256\/Signing\/PrivateKey], correspond to items that the [doc:\/\/com.apple.documentation\/documentation\/Security\/keychain-services] API stores natively as [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instances. Other key types, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/Curve25519\/Signing\/PrivateKey], have no direct keychain corollary. To store these kinds of keys, you package them as generic passwords.\n\nThis sample code project demonstrates the conversions needed to store all the CryptoKit key types in the keychain.\n\n### Configure the Sample Code Project\n\nThe sample provides targets for both iOS and macOS. For both platforms, specify your developer team in the Xcode Signing & Capabilities tab before building. The macOS target also sets the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/keychain-access-groups], to enable access to the keychain on that platform.\n\n### Declare the Convertibility of NIST Keys\n\n[doc:\/\/com.apple.documentation\/documentation\/Security\/keychain-services] lets you convert between [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instances and data in the X9.63 data format. For NIST keys that support that representation, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P256], [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P384], and [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P521], CryptoKit defines a property that you use to get the X9.63 data. The framework also provides a complementary initializer that creates a new key from data in that format.\n\nDefine a protocol called `SecKeyConvertible` to express this interface:\n\nThen assert that all the NIST private keys adopt this protocol:\n\n### Declare the Convertibility of Other Key Types\n\n[doc:\/\/com.apple.documentation\/documentation\/Security\/keychain-services] also lets you securely store small chunks of data as a generic password keychain item. For any CryptoKit key without a X9.63 representation, CryptoKit provides a means to obtain a data representation of the key, enabling generic password storage. Define the `GenericPasswordConvertible` protocol to establish an interface for these items:\n\nSome keys, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/Curve25519], adopt this interface directly, and you simply assert that they do:\n\nOther keys offer similar functionality, but require modest adjustments to their interface. For example, you provide a secure conversion for instances of [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/SymmetricKey]:\n\nKeys that you store in the Secure Enclave expose a raw representation as well, but in this case the data isn’t the raw key. Instead, the Secure Enclave exports an encrypted block that only the same Secure Enclave can later use to restore the key. You can adopt the same convertibility protocol to store the Secure Enclave’s encrypted data in the keychain as a generic password, and later allow the Secure Enclave to reconstruct the key on the same device:\n\n### Store a NIST Key\n\nTo store a NIST key in the keychain, create a storage method that constrains input keys to be of type `SecKeyConvertible`:\n\nThen call the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKeyCreateWithData(_:_:_:)] function with the X9.63 representation of the key to create a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instance. Include attributes that describe the key as a private, elliptic-curve key.\n\nStore the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] representation in the keychain by placing it in an add query and calling the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemAdd(_:_:)] function. Give the key a label to make it easier to find later.\n\n### Store Other Key Types in the Keychain\n\nTo store other kinds of keys, create a different storage method that constrains input keys to be of type `GenericPasswordConvertible`:\n\nIn this case, you provide the raw representation as the data for the password item, and store that with a call to the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemAdd(_:_:)] function:\n\n### Retrieve a NIST Key as a Native Keychain Key\n\nYou retrieve a key from the keychain using a call to the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemCopyMatching(_:_:)] function. Construct a query dictionary that pinpoints the particular key that you want to find. After your search returns the desired key—stored as a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKeychainItem] instance—you cast it as a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instance.\n\nAfter you get the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] reference, initialize a CryptoKit key using the X9.63 representation returned by the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKeyCopyExternalRepresentation(_:_:)] function.\n\nMake sure that the type of the key that you initialize using the data matches the type of the original key. For example, initializing a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P256] key from the data corresponding to a keychain item that you created using a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P384] key produces undefined results.\n\n### Retrieve Keys Stored as Generic Passwords\n\nYou also retrieve generic passwords using the  [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemCopyMatching(_:_:)] function, in this case using [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecClassGenericPassword] for the item’s class. You convert the returned item to data, and use it directly to instantiate a key of the corresponding type:\n\nAs long as the type you initialize matches the type that you previously used to store the item in the keychain, the initialization correctly reconstructs the key.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CryptoKit\/storing-cryptokit-keys-in-the-keychain\ncrawled: 2025-12-02T16:04:36Z\n---\n\n# Storing CryptoKit Keys in the Keychain\n\n**Sample Code**\n\nConvert between strongly typed cryptographic keys and native keychain types.\n\n## Overview\n\nCryptoKit defines highly specific key types that embody a particular cryptographic algorithm and purpose. Some of these key types, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P256\/Signing\/PrivateKey], correspond to items that the [doc:\/\/com.apple.documentation\/documentation\/Security\/keychain-services] API stores natively as [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instances. Other key types, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/Curve25519\/Signing\/PrivateKey], have no direct keychain corollary. To store these kinds of keys, you package them as generic passwords.\n\nThis sample code project demonstrates the conversions needed to store all the CryptoKit key types in the keychain.\n\n### Configure the Sample Code Project\n\nThe sample provides targets for both iOS and macOS. For both platforms, specify your developer team in the Xcode Signing & Capabilities tab before building. The macOS target also sets the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/keychain-access-groups], to enable access to the keychain on that platform.\n\n### Declare the Convertibility of NIST Keys\n\n[doc:\/\/com.apple.documentation\/documentation\/Security\/keychain-services] lets you convert between [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instances and data in the X9.63 data format. For NIST keys that support that representation, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P256], [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P384], and [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P521], CryptoKit defines a property that you use to get the X9.63 data. The framework also provides a complementary initializer that creates a new key from data in that format.\n\nDefine a protocol called `SecKeyConvertible` to express this interface:\n\n```swift\nprotocol SecKeyConvertible: CustomStringConvertible {\n    \/\/\/ Creates a key from an X9.63 representation.\n    init<Bytes>(x963Representation: Bytes) throws where Bytes: ContiguousBytes\n    \n    \/\/\/ An X9.63 representation of the key.\n    var x963Representation: Data { get }\n}\n```\n\nThen assert that all the NIST private keys adopt this protocol:\n\n```swift\nextension P256.Signing.PrivateKey: SecKeyConvertible {}\nextension P256.KeyAgreement.PrivateKey: SecKeyConvertible {}\nextension P384.Signing.PrivateKey: SecKeyConvertible {}\nextension P384.KeyAgreement.PrivateKey: SecKeyConvertible {}\nextension P521.Signing.PrivateKey: SecKeyConvertible {}\nextension P521.KeyAgreement.PrivateKey: SecKeyConvertible {}\n```\n\n### Declare the Convertibility of Other Key Types\n\n[doc:\/\/com.apple.documentation\/documentation\/Security\/keychain-services] also lets you securely store small chunks of data as a generic password keychain item. For any CryptoKit key without a X9.63 representation, CryptoKit provides a means to obtain a data representation of the key, enabling generic password storage. Define the `GenericPasswordConvertible` protocol to establish an interface for these items:\n\n```swift\nprotocol GenericPasswordConvertible: CustomStringConvertible {\n    \/\/\/ Creates a key from a generic key representation.\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes\n    \n    \/\/\/ A generic representation of the key.\n    var genericKeyRepresentation: SymmetricKey { get }\n}\n```\n\nSome keys, like [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/Curve25519], adopt this interface directly, and you simply assert that they do:\n\n```swift\nextension Curve25519.KeyAgreement.PrivateKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        try self.init(rawRepresentation: data)\n    }\n\n    var genericKeyRepresentation: SymmetricKey {\n        self.rawRepresentation.withUnsafeBytes {\n            SymmetricKey(data: $0)\n        }\n    }\n}\nextension Curve25519.Signing.PrivateKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        try self.init(rawRepresentation: data)\n    }\n\n    var genericKeyRepresentation: SymmetricKey {\n        self.rawRepresentation.withUnsafeBytes {\n            SymmetricKey(data: $0)\n        }\n    }\n}\n```\n\nOther keys offer similar functionality, but require modest adjustments to their interface. For example, you provide a secure conversion for instances of [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/SymmetricKey]:\n\n```swift\nextension SymmetricKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        self.init(data: data)\n    }\n    \n    var genericKeyRepresentation: SymmetricKey {\n        self\n    }\n}\n```\n\nKeys that you store in the Secure Enclave expose a raw representation as well, but in this case the data isn’t the raw key. Instead, the Secure Enclave exports an encrypted block that only the same Secure Enclave can later use to restore the key. You can adopt the same convertibility protocol to store the Secure Enclave’s encrypted data in the keychain as a generic password, and later allow the Secure Enclave to reconstruct the key on the same device:\n\n```swift\nextension SecureEnclave.P256.Signing.PrivateKey: GenericPasswordConvertible {\n    init<D>(genericKeyRepresentation data: D) throws where D: ContiguousBytes {\n        try self.init(dataRepresentation: data.withUnsafeBytes { Data($0) })\n    }\n\n    var genericKeyRepresentation: SymmetricKey {\n        return SymmetricKey(data: dataRepresentation)\n    }\n}\n```\n\n### Store a NIST Key\n\nTo store a NIST key in the keychain, create a storage method that constrains input keys to be of type `SecKeyConvertible`:\n\n```swift\nfunc storeKey<T: SecKeyConvertible>(_ key: T, label: String) throws {\n```\n\nThen call the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKeyCreateWithData(_:_:_:)] function with the X9.63 representation of the key to create a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instance. Include attributes that describe the key as a private, elliptic-curve key.\n\n```swift\n\/\/ Describe the key.\nlet attributes = [kSecAttrKeyType: kSecAttrKeyTypeECSECPrimeRandom,\n                  kSecAttrKeyClass: kSecAttrKeyClassPrivate] as [String: Any]\n\n\/\/ Get a SecKey representation.\nguard let secKey = SecKeyCreateWithData(key.x963Representation as CFData,\n                                        attributes as CFDictionary,\n                                        nil)\n    else {\n        throw KeyStoreError(\"Unable to create SecKey representation.\")\n}\n```\n\nStore the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] representation in the keychain by placing it in an add query and calling the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemAdd(_:_:)] function. Give the key a label to make it easier to find later.\n\n```swift\n\/\/ Describe the add operation.\nlet query = [kSecClass: kSecClassKey,\n             kSecAttrApplicationLabel: label,\n             kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked,\n             kSecUseDataProtectionKeychain: true,\n             kSecValueRef: secKey] as [String: Any]\n\n\/\/ Add the key to the keychain.\nlet status = SecItemAdd(query as CFDictionary, nil)\nguard status == errSecSuccess else {\n    throw KeyStoreError(\"Unable to store item: \\(status.message)\")\n}\n```\n\n### Store Other Key Types in the Keychain\n\nTo store other kinds of keys, create a different storage method that constrains input keys to be of type `GenericPasswordConvertible`:\n\n```swift\nfunc storeKey<T: GenericPasswordConvertible>(_ key: T, account: String) throws {\n```\n\nIn this case, you provide the raw representation as the data for the password item, and store that with a call to the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemAdd(_:_:)] function:\n\n```swift\n\/\/ Treat the key data as a generic password.\ntry key.genericKeyRepresentation.withUnsafeBytes { keyBytes in\n    let cfd = Data(bytesNoCopy: UnsafeMutableRawPointer(mutating: keyBytes.baseAddress!), count: keyBytes.count, deallocator: .none)\n    let query = [kSecClass: kSecClassGenericPassword,\n                 kSecAttrAccount: account,\n                 kSecAttrAccessible: kSecAttrAccessibleWhenUnlocked,\n                 kSecUseDataProtectionKeychain: true,\n                 kSecValueData: cfd] as [String: Any]\n\n    \/\/ Add the key data.\n    let status = SecItemAdd(query as CFDictionary, nil)\n    guard status == errSecSuccess else {\n        throw KeyStoreError(\"Unable to store item: \\(status.message)\")\n    }\n}\n\n```\n\n### Retrieve a NIST Key as a Native Keychain Key\n\nYou retrieve a key from the keychain using a call to the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemCopyMatching(_:_:)] function. Construct a query dictionary that pinpoints the particular key that you want to find. After your search returns the desired key—stored as a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKeychainItem] instance—you cast it as a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] instance.\n\n```swift\n\/\/ Seek an elliptic-curve key with a given label.\nlet query = [kSecClass: kSecClassKey,\n             kSecAttrApplicationLabel: label,\n             kSecAttrKeyType: kSecAttrKeyTypeECSECPrimeRandom,\n             kSecUseDataProtectionKeychain: true,\n             kSecReturnRef: true] as [String: Any]\n\n\/\/ Find and cast the result as a SecKey instance.\nvar item: CFTypeRef?\nvar secKey: SecKey\nswitch SecItemCopyMatching(query as CFDictionary, &item) {\ncase errSecSuccess: secKey = item as! SecKey\ncase errSecItemNotFound: return nil\ncase let status: throw KeyStoreError(\"Keychain read failed: \\(status.message)\")\n}\n```\n\n\n\nAfter you get the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKey] reference, initialize a CryptoKit key using the X9.63 representation returned by the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecKeyCopyExternalRepresentation(_:_:)] function.\n\n```swift\n\/\/ Convert the SecKey into a CryptoKit key.\nvar error: Unmanaged<CFError>?\nguard let data = SecKeyCopyExternalRepresentation(secKey, &error) as Data? else {\n    throw KeyStoreError(error.debugDescription)\n}\nlet key = try T(x963Representation: data)\n```\n\nMake sure that the type of the key that you initialize using the data matches the type of the original key. For example, initializing a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P256] key from the data corresponding to a keychain item that you created using a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/P384] key produces undefined results.\n\n### Retrieve Keys Stored as Generic Passwords\n\nYou also retrieve generic passwords using the  [doc:\/\/com.apple.documentation\/documentation\/Security\/SecItemCopyMatching(_:_:)] function, in this case using [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecClassGenericPassword] for the item’s class. You convert the returned item to data, and use it directly to instantiate a key of the corresponding type:\n\n```swift\n\/\/ Seek a generic password with the given account.\nlet query = [kSecClass: kSecClassGenericPassword,\n             kSecAttrAccount: account,\n             kSecUseDataProtectionKeychain: true,\n             kSecReturnData: true] as [String: Any]\n\n\/\/ Find and cast the result as data.\nvar item: CFTypeRef?\nswitch SecItemCopyMatching(query as CFDictionary, &item) {\ncase errSecSuccess:\n    guard let data = item as? Data else { return nil }\n    return try T(genericKeyRepresentation: data)  \/\/ Convert back to a key.\ncase errSecItemNotFound: return nil\ncase let status: throw KeyStoreError(\"Keychain read failed: \\(status.message)\")\n}\n```\n\nAs long as the type you initialize matches the type that you previously used to store the item in the keychain, the initialization correctly reconstructs the key.\n\n## Essentials\n\n- **Complying with Encryption Export Regulations**: Declare the use of encryption in your app to streamline the app submission process.\n- **Performing Common Cryptographic Operations**: Use CryptoKit to carry out operations like hashing, key generation, and encryption.\n- **Enhancing your app’s privacy and security with quantum-secure workflows**: Use quantum-secure cryptography to protect your app from quantum attacks.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Declare the use of encryption in your app to streamline the app submission process.",
          "name" : "Complying with Encryption Export Regulations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Security\/complying-with-encryption-export-regulations"
        },
        {
          "description" : "Use CryptoKit to carry out operations like hashing, key generation, and encryption.",
          "name" : "Performing Common Cryptographic Operations",
          "url" : "https:\/\/developer.apple.com\/documentation\/CryptoKit\/performing-common-cryptographic-operations"
        },
        {
          "description" : "Use quantum-secure cryptography to protect your app from quantum attacks.",
          "name" : "Enhancing your app’s privacy and security with quantum-secure workflows",
          "url" : "https:\/\/developer.apple.com\/documentation\/CryptoKit\/enhancing-your-app-s-privacy-and-security-with-quantum-secure-workflows"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Storing CryptoKit Keys in the Keychain",
  "url" : "https:\/\/developer.apple.com\/documentation\/CryptoKit\/storing-cryptokit-keys-in-the-keychain"
}