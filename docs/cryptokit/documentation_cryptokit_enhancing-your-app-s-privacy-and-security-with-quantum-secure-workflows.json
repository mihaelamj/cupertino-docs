{
  "abstract" : "Use quantum-secure cryptography to protect your app from quantum attacks.",
  "codeExamples" : [
    {
      "code" : "let info = \"INFO\"\nvar sender = try HPKE.Sender(recipientKey: key.publicKey, ciphersuite: ciphersuite, info: Data(info.utf8))",
      "language" : "swift"
    },
    {
      "code" : "let encapsulation = sender.encapsulatedKey",
      "language" : "swift"
    },
    {
      "code" : "var recipient = try HPKE.Recipient(privateKey: key, ciphersuite: ciphersuite, info: Data(info.utf8), encapsulatedKey: encapsulation)",
      "language" : "swift"
    },
    {
      "code" : "let message = \"MESSAGE\"\nlet authenticatedMetadata = \"METADATA\"\nlet ciphertext = try sender.seal(Data(message.utf8), authenticating: Data(authenticatedMetadata.utf8))",
      "language" : "swift"
    },
    {
      "code" : "let decryption = try recipient.open(ciphertext, authenticating: Data(authenticatedMetadata.utf8))",
      "language" : "swift"
    },
    {
      "code" : "internal func testPQHPKE(type: PQHPKEType) throws -> (TestStatus, String) {\n    switch type {\n    case .XWingMLKEM768X25519:\n        return try check(try XWingMLKEM768X25519.PrivateKey(), ciphersuite: .XWingMLKEM768X25519_SHA256_AES_GCM_256)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let encapsulation = try key.publicKey.encapsulate()",
      "language" : "swift"
    },
    {
      "code" : "let sharedSecret = try key.decapsulate(encapsulation.encapsulated)",
      "language" : "swift"
    },
    {
      "code" : "internal func testMLKEM(type: MLKEMType, useSecureEnclave: Bool) throws -> (TestStatus, String) {\n    switch type {\n    case .MLKEM768:\n        return useSecureEnclave ? try check(try SecureEnclave.MLKEM768.PrivateKey()) : try check(try MLKEM768.PrivateKey())\n    case .MLKEM1024:\n        return useSecureEnclave ? try check(try SecureEnclave.MLKEM1024.PrivateKey()) : try check(try MLKEM1024.PrivateKey())\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let message = \"TEST MESSAGE\"\nlet signature = try key.signature(for: Data(message.utf8))",
      "language" : "swift"
    },
    {
      "code" : "if !key.publicKey.isValidSignature(signature: signature, for: Data(message.utf8)) {\n    return (.fail, description + \"\\n❌ Signature verification failed\")\n}",
      "language" : "swift"
    },
    {
      "code" : "internal func testMLDSA(type: MLDSAType) throws -> (TestStatus, String) {\n    switch type {\n    case .MLDSA65:\n        return useSecureEnclave ? try check(try SecureEnclave.MLDSA65.PrivateKey()) : try check(try MLDSA65.PrivateKey())\n    case .MLDSA87:\n        return useSecureEnclave ? try check(try SecureEnclave.MLDSA87.PrivateKey()) : try check(try MLDSA87.PrivateKey())\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let message = \"TEST MESSAGE\"\nlet PQSignature = try PQKey.signature(for: Data(message.utf8))\nlet PQSignatureSize = PQSignature.count\nlet ECSignature = try ECKey.signature(for: Data(message.utf8)).rawRepresentation\nlet signature = PQSignature + ECSignature",
      "language" : "swift"
    },
    {
      "code" : "let receivedPQSignature = signature.subdata(in: 0..<PQSignatureSize)\nlet isValidPQSignature = PQKey.publicKey.isValidSignature(signature: receivedPQSignature, for: Data(message.utf8))\nlet receivedECSignature = try P384.Signing.ECDSASignature(rawRepresentation: signature.subdata(in: PQSignatureSize..<signature.count))\nlet isValidECSignature = ECKey.publicKey.isValidSignature(receivedECSignature, for: Data(message.utf8))\nif !(isValidPQSignature && isValidECSignature) {\n    return (.fail, description + \"\\n❌ Signature verification failed\")\n}",
      "language" : "swift"
    },
    {
      "code" : "internal func testHybridSig(type: HybridSigType) throws -> (TestStatus, String) {\n    switch type {\n    case .MLDSA65xP256:\n        if useSecureEnclave {\n            return try check(try SecureEnclave.MLDSA65.PrivateKey(), SecureEnclave.P256.Signing.PrivateKey())\n        }\n        return try check(try MLDSA65.PrivateKey(), P256.Signing.PrivateKey())\n    case .MLDSA87xP384:\n        return try check(try MLDSA87.PrivateKey(), P384.Signing.PrivateKey())\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "fbb51d20876acb56772ad897884b95a6fba9001b1dddb526f9b776e4c708a1d6",
  "crawledAt" : "2025-12-05T11:48:36Z",
  "id" : "82E0804D-1BAE-4027-ADC7-C37D825D97CC",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Apple CryptoKit",
  "overview" : "## Overview\n\nQuantum attacks represent a threat to the security of widely-deployed cryptographic methods, which assume that attackers use classical, non-quantum computers. Cryptographers have created new algorithms that are secure against quantum attacks, known as *quantum-secure cryptography*. Quantum-secure algorithms remain secure from attacks by both classical and quantum computers.\n\nEven if an attacker doesn’t currently have access to a quantum computer, they can store any ciphertext they gain access to, and attack the encryption with a quantum computer later to recover the cleartext. You can help protect your data against these attacks by adopting quantum-secure cryptographic mechanisms and algorithms in your app now.\n\nInstead of switching to a cryptographic mechanism that only uses a quantum-secure algorithm, you can use a *hybrid* mechanism, which combines the strengths of both a classical and a quantum-secure algorithm. A hybrid scheme remains secure if an attacker breaks either one of the algorithms the scheme uses. For more information, see [https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/314].\n\nThis sample uses round-trip processes — encrypting then decrypting data, or generating a signature then verifying it — to demonstrate how to adopt quantum-secure cryptographic algorithms using [doc:\/\/com.apple.documentation\/documentation\/CryptoKit]. In your app, implement the two stages separately; for example, one person might encrypt a message and send it to another person who decrypts it. The sample demonstrates how to use quantum-secure hybrid public-key encryption (HPKE) to securely share a secret between two people.\n\n## Exchange cryptographic keys\n\nThe function `KeyTest\/check(_:ciphersuite:)` in the file `KeyTest+PQHPKE.swift` performs a full round-trip using HPKE, encrypting a cleartext message using the encapsulated key and verifying that the recipient recovers the same cleartext when they use the encapsulated key to decrypt the ciphertext they receive. It does this by following these steps:\n\nThe function `testPQHPKE(type:)` in the same file calls the `check(_:ciphersuite:)` function using the quantum-secure [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/HPKE\/Ciphersuite\/XWingMLKEM768X25519_SHA256_AES_GCM_256] ciphersuite:\n\n## Encapsulate cryptographic keys\n\nThe function `KeyTest\/check(_:)` in the file `KeyTest+MLKEM.swift` generates, encapsulates, and decapsulates a shared secret using the quantum-secure Module-Lattice Key Encapsulation Mechanism (ML-KEM). It first generates and encapsulates the shared secret using the public key:\n\nThe result of this operation is a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/KEM\/EncapsulationResult] that contains both the shared secret and the encapsulated version. The function passes the encapsulated version to the private key’s [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/KEMPrivateKey\/decapsulate(_:)] method to recover the shared secret:\n\nThe function `testMLKEM(type:useSecureEnclave:)` in the same file calls the `check(_:)` function using two different ML-KEM key lengths, either using keys in memory or stored in the Secure Enclave depending on the value of `useSecureEnclave`:\n\n## Create digital signatures\n\nThe two `check(_:)` functions in the file `KeyTest+MLDSA.swift` generate and validate digital signatures using the quantum-secure Module-Lattice Digital Signature Algorithm (ML-DSA), by calling methods on the [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/MLDSA65] and [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/MLDSA87] types. Each function accepts a private key, which it uses to sign a test message:\n\nIt then uses the corresponding public key to validate the signature:\n\nThe function `testMLDSA(type:)` in the same file calls the `check(_:)` function using two different ML-DSA key lengths, either using keys in memory or stored in the Secure Enclave depending on the value of `useSecureEnclave`:\n\n## Create hybrid signatures\n\nThe two `check(_:_:)` functions in the file `KeyTest+HybridSig.swift` generate and validate hybrid digital signatures that use both the quantum-secure ML-DSA, and classic elliptic curve (EC) methods. Each function accepts both an ML-DSA and EC private key, uses both keys to sign a test message, and then concatenates the two signatures:\n\nIt then extracts the two signatures from the concatenated data, and uses the corresponding public keys to validate both:\n\nThe function `testHybridSig(type:)` in the same file calls the `check(_:_:)` function using two different ML-DSA key lengths and two different EC key lengths, either using keys in memory or stored in the Secure Enclave, depending on the value of `useSecureEnclave`:\n\n## Store cryptographic keys in the keychain or in the Secure Enclave\n\nThese workflows store the CryptoKit keys in the keychain by converting between strongly typed cryptographic keys and native Keychain types. Where applicable, they also show how to protect keys with the Secure Enclave. For more information, see [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/storing-cryptokit-keys-in-the-keychain].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/cryptokit\/enhancing-your-app-s-privacy-and-security-with-quantum-secure-workflows\ncrawled: 2025-12-05T11:48:36Z\n---\n\n# Enhancing your app’s privacy and security with quantum-secure workflows\n\n**Sample Code**\n\nUse quantum-secure cryptography to protect your app from quantum attacks.\n\n## Overview\n\nQuantum attacks represent a threat to the security of widely-deployed cryptographic methods, which assume that attackers use classical, non-quantum computers. Cryptographers have created new algorithms that are secure against quantum attacks, known as *quantum-secure cryptography*. Quantum-secure algorithms remain secure from attacks by both classical and quantum computers.\n\nEven if an attacker doesn’t currently have access to a quantum computer, they can store any ciphertext they gain access to, and attack the encryption with a quantum computer later to recover the cleartext. You can help protect your data against these attacks by adopting quantum-secure cryptographic mechanisms and algorithms in your app now.\n\nInstead of switching to a cryptographic mechanism that only uses a quantum-secure algorithm, you can use a *hybrid* mechanism, which combines the strengths of both a classical and a quantum-secure algorithm. A hybrid scheme remains secure if an attacker breaks either one of the algorithms the scheme uses. For more information, see [https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/314].\n\nThis sample uses round-trip processes — encrypting then decrypting data, or generating a signature then verifying it — to demonstrate how to adopt quantum-secure cryptographic algorithms using [doc:\/\/com.apple.documentation\/documentation\/CryptoKit]. In your app, implement the two stages separately; for example, one person might encrypt a message and send it to another person who decrypts it. The sample demonstrates how to use quantum-secure hybrid public-key encryption (HPKE) to securely share a secret between two people.\n\n## Exchange cryptographic keys\n\nThe function `KeyTest\/check(_:ciphersuite:)` in the file `KeyTest+PQHPKE.swift` performs a full round-trip using HPKE, encrypting a cleartext message using the encapsulated key and verifying that the recipient recovers the same cleartext when they use the encapsulated key to decrypt the ciphertext they receive. It does this by following these steps:\n\n1. It creates an [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/HPKE\/Sender] using the recipient’s public key, the specified ciphersuite, and additional key-derivation information:\n\n```swift\nlet info = \"INFO\"\nvar sender = try HPKE.Sender(recipientKey: key.publicKey, ciphersuite: ciphersuite, info: Data(info.utf8))\n```\n\n1. It retrieves the sender’s encapsulated key:\n\n```swift\nlet encapsulation = sender.encapsulatedKey\n```\n\n1. It creates an [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/HPKE\/Recipient] using the recipient’s private key, the ciphersuite, additional key-derivation information, and the encapsulated key:\n\n```swift\nvar recipient = try HPKE.Recipient(privateKey: key, ciphersuite: ciphersuite, info: Data(info.utf8), encapsulatedKey: encapsulation)\n```\n\n1. It encrypts a message, passing additional metadata that the `Sender` signs:\n\n```swift\nlet message = \"MESSAGE\"\nlet authenticatedMetadata = \"METADATA\"\nlet ciphertext = try sender.seal(Data(message.utf8), authenticating: Data(authenticatedMetadata.utf8))\n```\n\n1. Finally, it passes the ciphertext to the `Recipient` to recover the cleartext:\n\n```swift\nlet decryption = try recipient.open(ciphertext, authenticating: Data(authenticatedMetadata.utf8))\n```\n\nThe function `testPQHPKE(type:)` in the same file calls the `check(_:ciphersuite:)` function using the quantum-secure [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/HPKE\/Ciphersuite\/XWingMLKEM768X25519_SHA256_AES_GCM_256] ciphersuite:\n\n```swift\ninternal func testPQHPKE(type: PQHPKEType) throws -> (TestStatus, String) {\n    switch type {\n    case .XWingMLKEM768X25519:\n        return try check(try XWingMLKEM768X25519.PrivateKey(), ciphersuite: .XWingMLKEM768X25519_SHA256_AES_GCM_256)\n    }\n}\n```\n\n## Encapsulate cryptographic keys\n\nThe function `KeyTest\/check(_:)` in the file `KeyTest+MLKEM.swift` generates, encapsulates, and decapsulates a shared secret using the quantum-secure Module-Lattice Key Encapsulation Mechanism (ML-KEM). It first generates and encapsulates the shared secret using the public key:\n\n```swift\nlet encapsulation = try key.publicKey.encapsulate()\n```\n\nThe result of this operation is a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/KEM\/EncapsulationResult] that contains both the shared secret and the encapsulated version. The function passes the encapsulated version to the private key’s [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/KEMPrivateKey\/decapsulate(_:)] method to recover the shared secret:\n\n```swift\nlet sharedSecret = try key.decapsulate(encapsulation.encapsulated)\n```\n\nThe function `testMLKEM(type:useSecureEnclave:)` in the same file calls the `check(_:)` function using two different ML-KEM key lengths, either using keys in memory or stored in the Secure Enclave depending on the value of `useSecureEnclave`:\n\n```swift\ninternal func testMLKEM(type: MLKEMType, useSecureEnclave: Bool) throws -> (TestStatus, String) {\n    switch type {\n    case .MLKEM768:\n        return useSecureEnclave ? try check(try SecureEnclave.MLKEM768.PrivateKey()) : try check(try MLKEM768.PrivateKey())\n    case .MLKEM1024:\n        return useSecureEnclave ? try check(try SecureEnclave.MLKEM1024.PrivateKey()) : try check(try MLKEM1024.PrivateKey())\n    }\n}\n```\n\n## Create digital signatures\n\nThe two `check(_:)` functions in the file `KeyTest+MLDSA.swift` generate and validate digital signatures using the quantum-secure Module-Lattice Digital Signature Algorithm (ML-DSA), by calling methods on the [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/MLDSA65] and [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/MLDSA87] types. Each function accepts a private key, which it uses to sign a test message:\n\n```swift\nlet message = \"TEST MESSAGE\"\nlet signature = try key.signature(for: Data(message.utf8))\n```\n\nIt then uses the corresponding public key to validate the signature:\n\n```swift\nif !key.publicKey.isValidSignature(signature: signature, for: Data(message.utf8)) {\n    return (.fail, description + \"\\n❌ Signature verification failed\")\n}\n```\n\nThe function `testMLDSA(type:)` in the same file calls the `check(_:)` function using two different ML-DSA key lengths, either using keys in memory or stored in the Secure Enclave depending on the value of `useSecureEnclave`:\n\n```swift\ninternal func testMLDSA(type: MLDSAType) throws -> (TestStatus, String) {\n    switch type {\n    case .MLDSA65:\n        return useSecureEnclave ? try check(try SecureEnclave.MLDSA65.PrivateKey()) : try check(try MLDSA65.PrivateKey())\n    case .MLDSA87:\n        return useSecureEnclave ? try check(try SecureEnclave.MLDSA87.PrivateKey()) : try check(try MLDSA87.PrivateKey())\n    }\n}\n```\n\n## Create hybrid signatures\n\nThe two `check(_:_:)` functions in the file `KeyTest+HybridSig.swift` generate and validate hybrid digital signatures that use both the quantum-secure ML-DSA, and classic elliptic curve (EC) methods. Each function accepts both an ML-DSA and EC private key, uses both keys to sign a test message, and then concatenates the two signatures:\n\n```swift\nlet message = \"TEST MESSAGE\"\nlet PQSignature = try PQKey.signature(for: Data(message.utf8))\nlet PQSignatureSize = PQSignature.count\nlet ECSignature = try ECKey.signature(for: Data(message.utf8)).rawRepresentation\nlet signature = PQSignature + ECSignature\n```\n\nIt then extracts the two signatures from the concatenated data, and uses the corresponding public keys to validate both:\n\n```swift\nlet receivedPQSignature = signature.subdata(in: 0..<PQSignatureSize)\nlet isValidPQSignature = PQKey.publicKey.isValidSignature(signature: receivedPQSignature, for: Data(message.utf8))\nlet receivedECSignature = try P384.Signing.ECDSASignature(rawRepresentation: signature.subdata(in: PQSignatureSize..<signature.count))\nlet isValidECSignature = ECKey.publicKey.isValidSignature(receivedECSignature, for: Data(message.utf8))\nif !(isValidPQSignature && isValidECSignature) {\n    return (.fail, description + \"\\n❌ Signature verification failed\")\n}\n```\n\nThe function `testHybridSig(type:)` in the same file calls the `check(_:_:)` function using two different ML-DSA key lengths and two different EC key lengths, either using keys in memory or stored in the Secure Enclave, depending on the value of `useSecureEnclave`:\n\n```swift\ninternal func testHybridSig(type: HybridSigType) throws -> (TestStatus, String) {\n    switch type {\n    case .MLDSA65xP256:\n        if useSecureEnclave {\n            return try check(try SecureEnclave.MLDSA65.PrivateKey(), SecureEnclave.P256.Signing.PrivateKey())\n        }\n        return try check(try MLDSA65.PrivateKey(), P256.Signing.PrivateKey())\n    case .MLDSA87xP384:\n        return try check(try MLDSA87.PrivateKey(), P384.Signing.PrivateKey())\n    }\n}\n```\n\n## Store cryptographic keys in the keychain or in the Secure Enclave\n\nThese workflows store the CryptoKit keys in the keychain by converting between strongly typed cryptographic keys and native Keychain types. Where applicable, they also show how to protect keys with the Secure Enclave. For more information, see [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/storing-cryptokit-keys-in-the-keychain].\n\n## Essentials\n\n- **Complying with Encryption Export Regulations**: Declare the use of encryption in your app to streamline the app submission process.\n- **Performing Common Cryptographic Operations**: Use CryptoKit to carry out operations like hashing, key generation, and encryption.\n- **Storing CryptoKit Keys in the Keychain**: Convert between strongly typed cryptographic keys and native keychain types.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Declare the use of encryption in your app to streamline the app submission process.",
          "name" : "Complying with Encryption Export Regulations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Security\/complying-with-encryption-export-regulations"
        },
        {
          "description" : "Use CryptoKit to carry out operations like hashing, key generation, and encryption.",
          "name" : "Performing Common Cryptographic Operations",
          "url" : "https:\/\/developer.apple.com\/documentation\/CryptoKit\/performing-common-cryptographic-operations"
        },
        {
          "description" : "Convert between strongly typed cryptographic keys and native keychain types.",
          "name" : "Storing CryptoKit Keys in the Keychain",
          "url" : "https:\/\/developer.apple.com\/documentation\/CryptoKit\/storing-cryptokit-keys-in-the-keychain"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Enhancing your app’s privacy and security with quantum-secure workflows",
  "url" : "https:\/\/developer.apple.com\/documentation\/cryptokit\/enhancing-your-app-s-privacy-and-security-with-quantum-secure-workflows"
}