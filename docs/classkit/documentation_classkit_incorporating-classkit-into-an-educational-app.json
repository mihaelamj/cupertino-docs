{
  "abstract" : "Walk through the process of setting up assignments and recording student progress.",
  "codeExamples" : [
    {
      "code" : "protocol Node {\n    var parent: Node? { get }\n    var children: [Node]? { get }\n    var identifier: String { get }\n    var contextType: CLSContextType { get }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Act: Node {\n    var parent: Node? {\n        return play\n    }\n    \n    var children: [Node]? {\n        return scenes\n    }\n    \n    var identifier: String {\n        return \"Act \\(number)\"\n    }\n    \n    var contextType: CLSContextType {\n        return .chapter\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Node {\n    var identifierPath: [String] {\n        var pathComponents: [String] = [identifier]\n        \n        if let parent = self.parent {\n            pathComponents = parent.identifierPath + pathComponents\n        }\n        \n        return pathComponents\n    }\n    \n    \/\/\/ Finds a node in the play list hierarchy by its identifier path.\n    func descendant(matching identifierPath: [String]) -> Node? {\n        if let identifier = identifierPath.first {\n            if let child = children?.first(where: { $0.identifier == identifier }) {\n                return child.descendant(matching: Array(identifierPath.suffix(identifierPath.count - 1)))\n            } else {\n                return nil\n            }\n        } else {\n            return self\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func addPlay(_ play: Play, creatingContexts: Bool = true) {\n    if !plays.contains(where: { $0.title == play.title }) {\n        plays.append(play)\n\n        \/\/ Give ClassKit a chance to set up its contexts.\n        if creatingContexts {\n            setupContext(play: play)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func setupContext(play: Play) {\n    for act in play.acts {\n        for scene in act.scenes {\n            \n            \/\/ Get the deepest path: the quiz if there is one, or the scene if not.\n            let path = scene.quiz?.identifierPath ?? scene.identifierPath\n            \n            \/\/ Asking for a context causes it (and its ancestors) to be built, as needed.\n            CLSDataStore.shared.mainAppContext.descendant(matchingIdentifierPath: path) { _, _ in }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func setupClassKit() {\n    CLSDataStore.shared.delegate = self\n}",
      "language" : "swift"
    },
    {
      "code" : "func createContext(forIdentifier identifier: String, parentContext: CLSContext, parentIdentifierPath: [String]) -> CLSContext? {\n    \n    \/\/ Find a node in the model hierarchy based on the identifier path.\n    let identifierPath = parentIdentifierPath + [identifier]\n\n    guard let playIdentifier = identifierPath.first,\n        let play = PlayLibrary.shared.plays.first(where: { $0.identifier == playIdentifier }),\n        let node = play.descendant(matching: Array(identifierPath.suffix(identifierPath.count - 1))) else {\n        return nil\n    }\n    \n    \/\/ Use the node to create and customize a context.\n    let context = CLSContext(type: node.contextType, identifier: identifier, title: node.identifier)\n    context.topic = .literacyAndWriting\n\n    \/\/ Users of 11.3 rely on a user activity instead.\n    if #available(iOS 11.4, *),\n        let path = identifierPath.joined(separator: \"\/\").addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) {\n\n        \/\/ Use custom URLs to locate activities.\n        \/\/  Comment this assignment to rely on a user activity for all users.\n        context.universalLinkURL = URL(string: \"greatplays:\/\/\" + path)\n    }\n\n    \/\/ No need to save: the framework handles that automatically.\n    os_log(\"%s Built\", node.identifierPath.description)\n    return context\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Start with plays as child nodes. Then look for a descendant.\nvar childNodes: [Node] = PlayLibrary.shared.plays\n\nif let identifier = identifierPath.first,\n    let play = PlayLibrary.shared.plays.first(where: { $0.identifier == identifier }),\n    let node = play.descendant(matching: Array(identifierPath.suffix(identifierPath.count - 1))) {\n\n    childNodes = node.children ?? []\n}",
      "language" : "swift"
    },
    {
      "code" : "let predicate = NSPredicate(format: \"%K = %@\",\n                            CLSPredicateKeyPath.parent as CVarArg,\n                            context)\nCLSDataStore.shared.contexts(matching: predicate) { childContexts, _ in\n    for childNode in childNodes {\n        if !childContexts.contains(where: { $0.identifier == childNode.identifier }),\n            let childContext = PlayLibrary.shared.createContext(forIdentifier: childNode.identifier,\n                                                                parentContext: context,\n                                                                parentIdentifierPath: identifierPath) {\n            context.addChildContext(childContext)\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "    CLSDataStore.shared.save { error in\n        if let error = error {\n            os_log(\"Save error: %s\", error.localizedDescription)\n        } else {\n            os_log(\"Saved\")\n        }\n        completion(error)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func startActivity(asNew: Bool = false) {\n    os_log(\"%s Start\", identifierPath.description)\n\n    CLSDataStore.shared.mainAppContext.descendant(matchingIdentifierPath: identifierPath) { context, _ in\n\n        \/\/ Activate the context.\n        context?.becomeActive()\n\n        if asNew == false,\n            let activity = context?.currentActivity {\n            \n            \/\/ Re-start the existing activity\n            activity.start()\n            \n        } else {\n            \/\/ Create and start an activity.\n            context?.createNewActivity().start()\n        }\n        \n        CLSDataStore.shared.save { error in\n            guard error == nil else {\n                os_log(\"%s Start save error: %s\", self.identifierPath.description, error!.localizedDescription)\n                return\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "override func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n\n    scene?.startActivity()\n}",
      "language" : "swift"
    },
    {
      "code" : "func start() {\n    startActivity(asNew: true)\n}",
      "language" : "swift"
    },
    {
      "code" : "func scrollViewDidScroll(_ scrollView: UIScrollView) {\n    let position = sceneText.contentOffset.y + sceneText.frame.size.height\n    let total = sceneText.contentSize.height\n    \n    \/\/ The scroll view can bounce, so use care to bound the progress.\n    let progress = Double(max(0, min(1, position \/ total)))\n    \n    scene?.update(progress: progress)\n}",
      "language" : "swift"
    },
    {
      "code" : "override func viewWillDisappear(_ animated: Bool) {\n    super.viewWillDisappear(animated)\n\n    scene?.stopActivity()\n}",
      "language" : "swift"
    },
    {
      "code" : "func record() {\n    \/\/ The score is the primary metric for a quiz.\n    addScore(score, title: \"Score\", primary: true)\n    addQuantity(Double(hints), title: \"Hints\")\n    markAsDone()\n    stopActivity()\n}",
      "language" : "swift"
    },
    {
      "code" : "func markAsDone() {\n    if #available(iOS 12.2, *) {\n        os_log(\"%s Done\", identifierPath.description)\n        CLSDataStore.shared.completeAllAssignedActivities(matching: identifierPath)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "if primary {\n    activity.primaryActivityItem = item\n} else {\n    activity.addAdditionalActivityItem(item)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "50bf427685b8ab29d00bff1ea0282a3ec91017569c23518497312981ad87293e",
  "crawledAt" : "2025-12-02T15:28:55Z",
  "id" : "4D9E64E8-3094-4CA1-B920-B4897D43FD1D",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ClassKit",
  "overview" : "## Overview\n\nYou adopt ClassKit in an existing educational app to enable teachers to create assignments and monitor students’ progress through those assignments. This sample code project demonstrates ClassKit adoption in an app that lets users read plays.\n\nBefore starting, be sure to read [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/enabling-classkit-in-your-app] to learn how to configure your environment to work with ClassKit, and Testing Your App During Development to prepare to debug your ClassKit adoption.\n\n### Start with an Existing Educational App\n\nThe GreatPlays app provides a navigable hierarchy of plays, acts, and scenes, along with quizzes that test the reader’s comprehension. The app uses a simple data model that represents a collection of plays—the shared `PlayLibrary` instance holds `Play` instances, each of which contain an array of `Act` instances, and so on. These all exist independent of ClassKit.\n\n\n\nFor this example, the structure of a single play—Shakespeare’s *Hamlet*—is added to the library at launch, from inside the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)] method.\n\nIn a real app, in addition to the structure, you would also add the play’s text, along with quiz questions tailored to each scene. You might also support other plays, either distributed with the app, or downloaded later.\n\n### Define Assignable Content\n\nYour first task in adopting ClassKit is to define your app’s assignable content. You represent a unit of assignable content to ClassKit as a [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContext] instance, and then establish relationships between contexts by grouping them together into a hierarchy. For the play reader, teachers might want to assign a quiz, an individual scene, an act (with all its scenes), or even the whole play. So the existing model hierarchy provides a good template for a context hierarchy.\n\nBecause ClassKit layers on top of what your app already does, it’s often best to isolate ClassKit support into class extensions. This scheme avoids disrupting the app’s normal flow. The sample app therefore declares a `Node` protocol that model objects can adopt in an extension to readily associate with a related context:\n\nIn adopting this protocol, a model object discloses its immediate ancestor and descendants, a unique identifier, and a [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextType] value that indicates what kind of content it contains. For example, the `Node` extension to `Act`, shown below, defines its `parent` as the `play` that contains it, and its `children` as the `scenes` it contains. It provides an identifier that is unique to the act, and a context type of [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextType\/chapter], which is a reasonable approximation of the role of an act within a play.\n\nFurther, an extension to the `Node` protocol provides default behavior to all model objects for handling identifiers. In particular, a model object that adopts the protocol gains the ability to report its own identifier path (a collection of `identifier` strings that trace through the hierarchy from one node to another), and to find a descendant node from an identifier path:\n\n### Advertise Your Content to Teachers\n\nContexts are the mechanism by which your app advertises its assignable content to teachers. Contexts you tell ClassKit about appear as tasks in Apple’s Schoolwork app, where teachers go to create assignments based on your content. So it’s important to declare contexts as soon (and as atomically) as possible. Otherwise teachers won’t see your app’s content in Schoolwork, or might only see a partial list of tasks.\n\nYou deal with this by declaring the context hierarchy for static content at application launch, or immediately after you download dynamic content. In the play reader app, you do this by making context declaration an integral step of building a new play instance in the `addPlay` method:\n\nYou declare an entire play context hierarchy by asking the data store for all the leaf nodes, which implicitly also declares all of the contexts that are ancestors of the leaf nodes:\n\nBecause you’re only declaring the contexts at this point, you don’t need to do anything with the returned values.\n\n### Build Contexts on Demand\n\nAny time you ask the data store ([doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStore]) for a context, whether during declaration or because you want to activate the context, the data store first looks in its database of stored contexts. If the context is available there, perhaps from a previous launch of your app, the data store returns that. But if it’s not available, the data store asks its [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStore\/delegate] to build the context.\n\nBy defining contexts that parallel your model hierarchy, you facilitate the building of new contexts. In your implementation of the [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStoreDelegate] protocol’s [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStoreDelegate\/createContext(forIdentifier:parentContext:parentIdentifierPath:)] method, you can use characteristics of your model objects to inform context creation.\n\nIn the play reader, the shared instance of the `PlayLibrary` class takes the role of delegate, again using an extension. Its `ClassKit` extension includes the `setupClassKit()` method that assigns itself as the delegate:\n\nThe extension also implements the delegate callback, relying on each model object’s `Node` extension to provide data needed for context creation:\n\n### Build Contexts from an App Extension\n\nThe app includes a ClassKit context provider app extension by defining a target called `ClassKitContextProvider`. A ClassKit extension’s primary class conforms to the [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextProvider] protocol. Schoolwork calls this protocol’s [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextProvider\/updateDescendants(of:completion:)] method to create or update the children of a given context as the teacher browses assignable content. This enables Schoolwork to advertise the most up-to-date version of an app’s assignable content, even before the teacher runs the main app for the first time.\n\nUsing the identifier path of the passed-in context, the update method finds the corresponding node in the data model, and then finds the children of that node:\n\nThe update method then finds existing child contexts at the same hierarchical level as the node, and creates any that are missing:\n\nIn this app, contexts never change, so the loop moves to the next iteration without taking any action when it finds an existing context. If your app has contexts that can change, use this opportunity to reconfigure the context. Either way, after finishing the loop, save the updates and call the completion handler:\n\n### Record Progress with Activities\n\nWhile contexts declare the structure of your app, you use [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSActivity] instances to report progress through those contexts. For example, for a context representing a scene, the corresponding activity reports how much of the scene the student has read and how long they took to read it.\n\nIn addition to the identifier extension, the sample app includes another extension to `Node` that provides default behavior for working with ClassKit activities. Model objects use their own identifier path to locate the matching context, and then use the context to manage activities. For example, the `startActivity()` method defined in the extension begins an activity:\n\n`Node` also defines methods for reporting progress as a fraction of task completion and ending an activity. Notice that all these methods retrieve the context every time, rather than storing a reference to it. It’s important to do this, because the underlying instance could change between calls as a result of network synchronization.\n\n### Start Recording When the User Begins an Activity\n\nYou typically call methods to record activity from your view controllers. Consider an assignment to read a particular scene. The scene’s view controller knows when the scene appears on screen and has a handle on the scene instance. So the controller is in the best position to tell the scene to begin recording an activity from its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/viewDidAppear(_:)] method:\n\nNotice that when the student starts to read a scene, the controller doesn’t set the `startActivity()` method’s `asNew` parameter, leaving it to have the default value of `false`. As a result, a previously stopped activity, if available, is resumed. This allows the user to begin reading a scene, then navigate elsewhere in the app (for example to review an earlier scene) without finalizing the current attempt. When the user returns, progress and duration pick up from where the user left off.\n\nIn contrast, the `startQuiz()` method does set the `startActivity()` method’s `asNew` parameter to `true`. Quizzes, once started, must be finished before the user can move to another task. So the app treats each new attempt as a new activity.\n\nHow you handle this for a particular activity depends on the characteristics of the tasks you define.\n\n### Add Progress When the User Scrolls\n\nWhile the scene view controller (which manages a scroll view) is visible, it uses its knowledge of the content offset as an indication of how far through the scene the student has read. For each scroll view delegate update, the controller reports a new progress value to the scene by measuring scroll position as a proxy for how much the student has read:\n\n### Stop Recording When the User Stops an Activity\n\nThe controller informs the scene when the activity is over in its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/viewWillDisappear(_:)] method:\n\n### Report Additional Metrics with Activity Items\n\nActivities report duration and progress automatically. But sometimes you want to provide additional metrics about an activity. For example, you might want to report a quiz score, or record how many times a hint was used in solving a problem. For this, you use activity items.\n\nIn GreatPlays, the `Node` protocol extension provides the `addScore()` and `addQuantity()` methods for this purpose. These are called when the user completes the quiz, but before ending the activity, to report the quiz results:\n\n### Mark an Activity as Done\n\nWhile recording the quiz score, the app also calls the `markAsDone()` method, as shown in the previous section, which in turn calls the data store’s [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStore\/completeAllAssignedActivities(matching:)] method to indicate that the student has finalized the attempt.\n\nThe student can’t go back and change anything after reaching the end of the quiz, so the app can safely mark the activity as done. In contrast, reading a scene has no easily detected end point, and so the app doesn’t make a call to the completion method in that case. Instead, the student decides when to mark the activity complete in Schoolwork.\n\n### Designate a Primary Activity Item\n\nWhen you add activity items, you can choose to make one of them the primary item. The primary gets a more prominent role in summarized results that teachers see. In the play reader example, for a quiz, the score is considered the primary item, as shown above. Alternatively, you can choose not to set any activity item as the primary, in which case progress becomes the most prominent result displayed to teachers. The `addScore()` method demonstrates the two ways in which you can register an activity item, either as primary or not:\n\nIf you do decide to set a primary item, make sure you always set the same kind of primary item for a given activity. For example, once you register the score item as the primary for a quiz activity, you must always use score this way. Making the hint quantity the primary at a later time generates an error.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ClassKit\/incorporating-classkit-into-an-educational-app\ncrawled: 2025-12-02T15:28:55Z\n---\n\n# Incorporating ClassKit into an Educational App\n\n**Sample Code**\n\nWalk through the process of setting up assignments and recording student progress.\n\n## Overview\n\nYou adopt ClassKit in an existing educational app to enable teachers to create assignments and monitor students’ progress through those assignments. This sample code project demonstrates ClassKit adoption in an app that lets users read plays.\n\nBefore starting, be sure to read [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/enabling-classkit-in-your-app] to learn how to configure your environment to work with ClassKit, and Testing Your App During Development to prepare to debug your ClassKit adoption.\n\n### Start with an Existing Educational App\n\nThe GreatPlays app provides a navigable hierarchy of plays, acts, and scenes, along with quizzes that test the reader’s comprehension. The app uses a simple data model that represents a collection of plays—the shared `PlayLibrary` instance holds `Play` instances, each of which contain an array of `Act` instances, and so on. These all exist independent of ClassKit.\n\n\n\nFor this example, the structure of a single play—Shakespeare’s *Hamlet*—is added to the library at launch, from inside the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)] method.\n\n\n\nIn a real app, in addition to the structure, you would also add the play’s text, along with quiz questions tailored to each scene. You might also support other plays, either distributed with the app, or downloaded later.\n\n### Define Assignable Content\n\nYour first task in adopting ClassKit is to define your app’s assignable content. You represent a unit of assignable content to ClassKit as a [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContext] instance, and then establish relationships between contexts by grouping them together into a hierarchy. For the play reader, teachers might want to assign a quiz, an individual scene, an act (with all its scenes), or even the whole play. So the existing model hierarchy provides a good template for a context hierarchy.\n\nBecause ClassKit layers on top of what your app already does, it’s often best to isolate ClassKit support into class extensions. This scheme avoids disrupting the app’s normal flow. The sample app therefore declares a `Node` protocol that model objects can adopt in an extension to readily associate with a related context:\n\n```swift\nprotocol Node {\n    var parent: Node? { get }\n    var children: [Node]? { get }\n    var identifier: String { get }\n    var contextType: CLSContextType { get }\n}\n```\n\nIn adopting this protocol, a model object discloses its immediate ancestor and descendants, a unique identifier, and a [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextType] value that indicates what kind of content it contains. For example, the `Node` extension to `Act`, shown below, defines its `parent` as the `play` that contains it, and its `children` as the `scenes` it contains. It provides an identifier that is unique to the act, and a context type of [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextType\/chapter], which is a reasonable approximation of the role of an act within a play.\n\n```swift\nextension Act: Node {\n    var parent: Node? {\n        return play\n    }\n    \n    var children: [Node]? {\n        return scenes\n    }\n    \n    var identifier: String {\n        return \"Act \\(number)\"\n    }\n    \n    var contextType: CLSContextType {\n        return .chapter\n    }\n}\n```\n\nFurther, an extension to the `Node` protocol provides default behavior to all model objects for handling identifiers. In particular, a model object that adopts the protocol gains the ability to report its own identifier path (a collection of `identifier` strings that trace through the hierarchy from one node to another), and to find a descendant node from an identifier path:\n\n```swift\nextension Node {\n    var identifierPath: [String] {\n        var pathComponents: [String] = [identifier]\n        \n        if let parent = self.parent {\n            pathComponents = parent.identifierPath + pathComponents\n        }\n        \n        return pathComponents\n    }\n    \n    \/\/\/ Finds a node in the play list hierarchy by its identifier path.\n    func descendant(matching identifierPath: [String]) -> Node? {\n        if let identifier = identifierPath.first {\n            if let child = children?.first(where: { $0.identifier == identifier }) {\n                return child.descendant(matching: Array(identifierPath.suffix(identifierPath.count - 1)))\n            } else {\n                return nil\n            }\n        } else {\n            return self\n        }\n    }\n}\n```\n\n### Advertise Your Content to Teachers\n\nContexts are the mechanism by which your app advertises its assignable content to teachers. Contexts you tell ClassKit about appear as tasks in Apple’s Schoolwork app, where teachers go to create assignments based on your content. So it’s important to declare contexts as soon (and as atomically) as possible. Otherwise teachers won’t see your app’s content in Schoolwork, or might only see a partial list of tasks.\n\nYou deal with this by declaring the context hierarchy for static content at application launch, or immediately after you download dynamic content. In the play reader app, you do this by making context declaration an integral step of building a new play instance in the `addPlay` method:\n\n```swift\nfunc addPlay(_ play: Play, creatingContexts: Bool = true) {\n    if !plays.contains(where: { $0.title == play.title }) {\n        plays.append(play)\n\n        \/\/ Give ClassKit a chance to set up its contexts.\n        if creatingContexts {\n            setupContext(play: play)\n        }\n    }\n}\n```\n\nYou declare an entire play context hierarchy by asking the data store for all the leaf nodes, which implicitly also declares all of the contexts that are ancestors of the leaf nodes:\n\n```swift\nfunc setupContext(play: Play) {\n    for act in play.acts {\n        for scene in act.scenes {\n            \n            \/\/ Get the deepest path: the quiz if there is one, or the scene if not.\n            let path = scene.quiz?.identifierPath ?? scene.identifierPath\n            \n            \/\/ Asking for a context causes it (and its ancestors) to be built, as needed.\n            CLSDataStore.shared.mainAppContext.descendant(matchingIdentifierPath: path) { _, _ in }\n        }\n    }\n}\n```\n\nBecause you’re only declaring the contexts at this point, you don’t need to do anything with the returned values.\n\n### Build Contexts on Demand\n\nAny time you ask the data store ([doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStore]) for a context, whether during declaration or because you want to activate the context, the data store first looks in its database of stored contexts. If the context is available there, perhaps from a previous launch of your app, the data store returns that. But if it’s not available, the data store asks its [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStore\/delegate] to build the context.\n\nBy defining contexts that parallel your model hierarchy, you facilitate the building of new contexts. In your implementation of the [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStoreDelegate] protocol’s [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStoreDelegate\/createContext(forIdentifier:parentContext:parentIdentifierPath:)] method, you can use characteristics of your model objects to inform context creation.\n\nIn the play reader, the shared instance of the `PlayLibrary` class takes the role of delegate, again using an extension. Its `ClassKit` extension includes the `setupClassKit()` method that assigns itself as the delegate:\n\n```swift\nfunc setupClassKit() {\n    CLSDataStore.shared.delegate = self\n}\n```\n\nThe extension also implements the delegate callback, relying on each model object’s `Node` extension to provide data needed for context creation:\n\n```swift\nfunc createContext(forIdentifier identifier: String, parentContext: CLSContext, parentIdentifierPath: [String]) -> CLSContext? {\n    \n    \/\/ Find a node in the model hierarchy based on the identifier path.\n    let identifierPath = parentIdentifierPath + [identifier]\n\n    guard let playIdentifier = identifierPath.first,\n        let play = PlayLibrary.shared.plays.first(where: { $0.identifier == playIdentifier }),\n        let node = play.descendant(matching: Array(identifierPath.suffix(identifierPath.count - 1))) else {\n        return nil\n    }\n    \n    \/\/ Use the node to create and customize a context.\n    let context = CLSContext(type: node.contextType, identifier: identifier, title: node.identifier)\n    context.topic = .literacyAndWriting\n\n    \/\/ Users of 11.3 rely on a user activity instead.\n    if #available(iOS 11.4, *),\n        let path = identifierPath.joined(separator: \"\/\").addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) {\n\n        \/\/ Use custom URLs to locate activities.\n        \/\/  Comment this assignment to rely on a user activity for all users.\n        context.universalLinkURL = URL(string: \"greatplays:\/\/\" + path)\n    }\n\n    \/\/ No need to save: the framework handles that automatically.\n    os_log(\"%s Built\", node.identifierPath.description)\n    return context\n}\n```\n\n### Build Contexts from an App Extension\n\nThe app includes a ClassKit context provider app extension by defining a target called `ClassKitContextProvider`. A ClassKit extension’s primary class conforms to the [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextProvider] protocol. Schoolwork calls this protocol’s [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSContextProvider\/updateDescendants(of:completion:)] method to create or update the children of a given context as the teacher browses assignable content. This enables Schoolwork to advertise the most up-to-date version of an app’s assignable content, even before the teacher runs the main app for the first time.\n\nUsing the identifier path of the passed-in context, the update method finds the corresponding node in the data model, and then finds the children of that node:\n\n```swift\n\/\/ Start with plays as child nodes. Then look for a descendant.\nvar childNodes: [Node] = PlayLibrary.shared.plays\n\nif let identifier = identifierPath.first,\n    let play = PlayLibrary.shared.plays.first(where: { $0.identifier == identifier }),\n    let node = play.descendant(matching: Array(identifierPath.suffix(identifierPath.count - 1))) {\n\n    childNodes = node.children ?? []\n}\n```\n\nThe update method then finds existing child contexts at the same hierarchical level as the node, and creates any that are missing:\n\n```swift\nlet predicate = NSPredicate(format: \"%K = %@\",\n                            CLSPredicateKeyPath.parent as CVarArg,\n                            context)\nCLSDataStore.shared.contexts(matching: predicate) { childContexts, _ in\n    for childNode in childNodes {\n        if !childContexts.contains(where: { $0.identifier == childNode.identifier }),\n            let childContext = PlayLibrary.shared.createContext(forIdentifier: childNode.identifier,\n                                                                parentContext: context,\n                                                                parentIdentifierPath: identifierPath) {\n            context.addChildContext(childContext)\n        }\n    }\n```\n\nIn this app, contexts never change, so the loop moves to the next iteration without taking any action when it finds an existing context. If your app has contexts that can change, use this opportunity to reconfigure the context. Either way, after finishing the loop, save the updates and call the completion handler:\n\n```swift\n    CLSDataStore.shared.save { error in\n        if let error = error {\n            os_log(\"Save error: %s\", error.localizedDescription)\n        } else {\n            os_log(\"Saved\")\n        }\n        completion(error)\n    }\n}\n```\n\n### Record Progress with Activities\n\nWhile contexts declare the structure of your app, you use [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSActivity] instances to report progress through those contexts. For example, for a context representing a scene, the corresponding activity reports how much of the scene the student has read and how long they took to read it.\n\nIn addition to the identifier extension, the sample app includes another extension to `Node` that provides default behavior for working with ClassKit activities. Model objects use their own identifier path to locate the matching context, and then use the context to manage activities. For example, the `startActivity()` method defined in the extension begins an activity:\n\n```swift\nfunc startActivity(asNew: Bool = false) {\n    os_log(\"%s Start\", identifierPath.description)\n\n    CLSDataStore.shared.mainAppContext.descendant(matchingIdentifierPath: identifierPath) { context, _ in\n\n        \/\/ Activate the context.\n        context?.becomeActive()\n\n        if asNew == false,\n            let activity = context?.currentActivity {\n            \n            \/\/ Re-start the existing activity\n            activity.start()\n            \n        } else {\n            \/\/ Create and start an activity.\n            context?.createNewActivity().start()\n        }\n        \n        CLSDataStore.shared.save { error in\n            guard error == nil else {\n                os_log(\"%s Start save error: %s\", self.identifierPath.description, error!.localizedDescription)\n                return\n            }\n        }\n    }\n}\n```\n\n`Node` also defines methods for reporting progress as a fraction of task completion and ending an activity. Notice that all these methods retrieve the context every time, rather than storing a reference to it. It’s important to do this, because the underlying instance could change between calls as a result of network synchronization.\n\n### Start Recording When the User Begins an Activity\n\nYou typically call methods to record activity from your view controllers. Consider an assignment to read a particular scene. The scene’s view controller knows when the scene appears on screen and has a handle on the scene instance. So the controller is in the best position to tell the scene to begin recording an activity from its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/viewDidAppear(_:)] method:\n\n```swift\noverride func viewDidAppear(_ animated: Bool) {\n    super.viewDidAppear(animated)\n\n    scene?.startActivity()\n}\n```\n\nNotice that when the student starts to read a scene, the controller doesn’t set the `startActivity()` method’s `asNew` parameter, leaving it to have the default value of `false`. As a result, a previously stopped activity, if available, is resumed. This allows the user to begin reading a scene, then navigate elsewhere in the app (for example to review an earlier scene) without finalizing the current attempt. When the user returns, progress and duration pick up from where the user left off.\n\nIn contrast, the `startQuiz()` method does set the `startActivity()` method’s `asNew` parameter to `true`. Quizzes, once started, must be finished before the user can move to another task. So the app treats each new attempt as a new activity.\n\n```swift\nfunc start() {\n    startActivity(asNew: true)\n}\n```\n\nHow you handle this for a particular activity depends on the characteristics of the tasks you define.\n\n### Add Progress When the User Scrolls\n\nWhile the scene view controller (which manages a scroll view) is visible, it uses its knowledge of the content offset as an indication of how far through the scene the student has read. For each scroll view delegate update, the controller reports a new progress value to the scene by measuring scroll position as a proxy for how much the student has read:\n\n```swift\nfunc scrollViewDidScroll(_ scrollView: UIScrollView) {\n    let position = sceneText.contentOffset.y + sceneText.frame.size.height\n    let total = sceneText.contentSize.height\n    \n    \/\/ The scroll view can bounce, so use care to bound the progress.\n    let progress = Double(max(0, min(1, position \/ total)))\n    \n    scene?.update(progress: progress)\n}\n```\n\n### Stop Recording When the User Stops an Activity\n\nThe controller informs the scene when the activity is over in its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/viewWillDisappear(_:)] method:\n\n```swift\noverride func viewWillDisappear(_ animated: Bool) {\n    super.viewWillDisappear(animated)\n\n    scene?.stopActivity()\n}\n```\n\n### Report Additional Metrics with Activity Items\n\nActivities report duration and progress automatically. But sometimes you want to provide additional metrics about an activity. For example, you might want to report a quiz score, or record how many times a hint was used in solving a problem. For this, you use activity items.\n\nIn GreatPlays, the `Node` protocol extension provides the `addScore()` and `addQuantity()` methods for this purpose. These are called when the user completes the quiz, but before ending the activity, to report the quiz results:\n\n```swift\nfunc record() {\n    \/\/ The score is the primary metric for a quiz.\n    addScore(score, title: \"Score\", primary: true)\n    addQuantity(Double(hints), title: \"Hints\")\n    markAsDone()\n    stopActivity()\n}\n```\n\n### Mark an Activity as Done\n\nWhile recording the quiz score, the app also calls the `markAsDone()` method, as shown in the previous section, which in turn calls the data store’s [doc:\/\/com.apple.documentation\/documentation\/ClassKit\/CLSDataStore\/completeAllAssignedActivities(matching:)] method to indicate that the student has finalized the attempt.\n\n```swift\nfunc markAsDone() {\n    if #available(iOS 12.2, *) {\n        os_log(\"%s Done\", identifierPath.description)\n        CLSDataStore.shared.completeAllAssignedActivities(matching: identifierPath)\n    }\n}\n```\n\nThe student can’t go back and change anything after reaching the end of the quiz, so the app can safely mark the activity as done. In contrast, reading a scene has no easily detected end point, and so the app doesn’t make a call to the completion method in that case. Instead, the student decides when to mark the activity complete in Schoolwork.\n\n### Designate a Primary Activity Item\n\nWhen you add activity items, you can choose to make one of them the primary item. The primary gets a more prominent role in summarized results that teachers see. In the play reader example, for a quiz, the score is considered the primary item, as shown above. Alternatively, you can choose not to set any activity item as the primary, in which case progress becomes the most prominent result displayed to teachers. The `addScore()` method demonstrates the two ways in which you can register an activity item, either as primary or not:\n\n```swift\nif primary {\n    activity.primaryActivityItem = item\n} else {\n    activity.addAdditionalActivityItem(item)\n}\n```\n\nIf you do decide to set a primary item, make sure you always set the same kind of primary item for a given activity. For example, once you register the score item as the primary for a quiz activity, you must always use score this way. Making the hint quantity the primary at a later time generates an error.\n\n## Essentials\n\n- **Enabling ClassKit in your app**: Prepare your app and your development environment to adopt ClassKit.\n- **ClassKit Environment Entitlement**: The ClassKit development or production environment for an education app that works with the Schoolwork app.\n- **CLSDataStore**: A container for all the ClassKit data in your app.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Prepare your app and your development environment to adopt ClassKit.",
          "name" : "Enabling ClassKit in your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/ClassKit\/enabling-classkit-in-your-app"
        },
        {
          "description" : "The ClassKit development or production environment for an education app that works with the Schoolwork app.",
          "name" : "ClassKit Environment Entitlement",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.ClassKit-environment"
        },
        {
          "description" : "A container for all the ClassKit data in your app.",
          "name" : "CLSDataStore",
          "url" : "https:\/\/developer.apple.com\/documentation\/ClassKit\/CLSDataStore"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Incorporating ClassKit into an Educational App",
  "url" : "https:\/\/developer.apple.com\/documentation\/ClassKit\/incorporating-classkit-into-an-educational-app"
}