{
  "abstract" : "Create visual effects in a scene by defining a rendering technique with custom symbols.",
  "codeExamples" : [
    {
      "code" : "    \"symbols\": [\n        \"color_weights_symbol\": [\n            \"type\": \"vec3\"\n        ],\n        \"time_symbol\": [\n            \"type\": \"float\"\n        ]\n    ],",
      "language" : "json"
    },
    {
      "code" : "    \"inputs\": [\n        \"color\": \"COLOR\",\n        \"color_weights\": \"color_weights_symbol\",\n        \"time\": \"time_symbol\"\n    ],",
      "language" : "json"
    },
    {
      "code" : "struct Symbols {\n    float3 color_weights;\n    float time;\n};",
      "language" : "c"
    },
    {
      "code" : "fragment half4 myFragmentShader(VertexOut in [[stage_in]],\n                                constant Symbols &symbols [[buffer(0)]],\n                                texture2d<half, access::sample> color [[texture(0)]]) { ... }",
      "language" : "c"
    }
  ],
  "contentHash" : "3ffdff2c51df87aa7dd3c16ebc5444734061569b14c52215d62b9baacbd29d4b",
  "crawledAt" : "2025-12-02T15:30:39Z",
  "id" : "4A2C71C5-06A8-42A4-ABBA-9827A1DDD9F8",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SceneKit",
  "overview" : "## Overview\n\nGames and 3D apps are often distinguishable because of unique visual effects.  Many games offer settings where users can select filters which change the visual aesthetic of a game.  For example, a user might select a grayscale filter to achieve a grittier feeling, or a pixelation filter make the game retro.\n\nThis sample app uses an [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique] with custom symbols to create a user-adjustable color filter for the scene. The sample app binds values for each custom symbol to the Metal shader used by the [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique]. The Metal shader accesses the bound values to produce the color filter effect in the scene.  See the “Defining a Technique” section of the [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique] documentation for detailed information about the steps required to define a technique.\n\n### Configure the Sample Code Project\n\nThe scene used in this project is configured entirely within the `max.scn` file.\n\n### Define the Postprocess Rendering Technique\n\nThe sample uses custom symbols as input to the fragment function in `MyShaders.metal`. The technique defines the custom symbols used by the fragment function:\n\nIn this sample, the `color_weights_symbol` has a type of `vec3`, even though it’s a `float3` in the Metal shaders.\n\n`\"color_weights\": \"color_weights_symbol\"`\n\nIn the key-value pair above, the key, on the left, is the name of the symbol as defined in the shader, and the value, on the right, is the name of the symbol as defined in the `symbols` dictionary of the technique.\n\n### Bind a Value to Each Custom Symbol\n\nTo bind values to the custom symbols, the sample project uses the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/setValue(_:forKey:)] method of [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique].  Once bound, the values are available in the Metal shading program.\n\nValue bindings use the logical type that corresponds with the Metal type. For example, custom symbols defined in the technique with a type of `vec3`, with a type of `float3` in the shader, use a `SCNVector3` value when bound. Reference the table on the [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNShadable] page of the documentation to identify corresponding types between GLSL, Metal, and Swift.\n\n### Access Your Custom Symbols in Metal\n\nThis sample declares the `Symbols` struct as a constant input and assigns it to buffer index 0 of the fragment shader in `MyShaders.metal`.  The name of the struct, and the buffer index it is assigned to is flexible.  SceneKit binds the values solely based on the names of the fields in the struct.  The `Symbols` struct defined in `MyShaders.metal` contains a field for each custom symbol.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SceneKit\/postprocessing-a-scene-with-custom-symbols\ncrawled: 2025-12-02T15:30:39Z\n---\n\n# Postprocessing a Scene With Custom Symbols\n\n**Sample Code**\n\nCreate visual effects in a scene by defining a rendering technique with custom symbols.\n\n## Overview\n\nGames and 3D apps are often distinguishable because of unique visual effects.  Many games offer settings where users can select filters which change the visual aesthetic of a game.  For example, a user might select a grayscale filter to achieve a grittier feeling, or a pixelation filter make the game retro.\n\nThis sample app uses an [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique] with custom symbols to create a user-adjustable color filter for the scene. The sample app binds values for each custom symbol to the Metal shader used by the [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique]. The Metal shader accesses the bound values to produce the color filter effect in the scene.  See the “Defining a Technique” section of the [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique] documentation for detailed information about the steps required to define a technique.\n\n### Configure the Sample Code Project\n\nThe scene used in this project is configured entirely within the `max.scn` file.\n\n### Define the Postprocess Rendering Technique\n\nThe sample uses custom symbols as input to the fragment function in `MyShaders.metal`. The technique defines the custom symbols used by the fragment function:\n\n1. The `symbols` dictionary defines the custom symbols used by the `inputs` dictionary of each pass. Each custom symbol specifies a `type` using the GLSL type that logically maps to the corresponding Metal type.\n\n```json\n    \"symbols\": [\n        \"color_weights_symbol\": [\n            \"type\": \"vec3\"\n        ],\n        \"time_symbol\": [\n            \"type\": \"float\"\n        ]\n    ],\n```\n\nIn this sample, the `color_weights_symbol` has a type of `vec3`, even though it’s a `float3` in the Metal shaders.\n\n1. The `inputs` dictionary of each pass associates each custom symbol with the corresponding field in Metal.\n\n```json\n    \"inputs\": [\n        \"color\": \"COLOR\",\n        \"color_weights\": \"color_weights_symbol\",\n        \"time\": \"time_symbol\"\n    ],\n```\n\n`\"color_weights\": \"color_weights_symbol\"`\n\nIn the key-value pair above, the key, on the left, is the name of the symbol as defined in the shader, and the value, on the right, is the name of the symbol as defined in the `symbols` dictionary of the technique.\n\n### Bind a Value to Each Custom Symbol\n\nTo bind values to the custom symbols, the sample project uses the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/setValue(_:forKey:)] method of [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNTechnique].  Once bound, the values are available in the Metal shading program.\n\nValue bindings use the logical type that corresponds with the Metal type. For example, custom symbols defined in the technique with a type of `vec3`, with a type of `float3` in the shader, use a `SCNVector3` value when bound. Reference the table on the [doc:\/\/com.apple.documentation\/documentation\/SceneKit\/SCNShadable] page of the documentation to identify corresponding types between GLSL, Metal, and Swift.\n\n### Access Your Custom Symbols in Metal\n\nThis sample declares the `Symbols` struct as a constant input and assigns it to buffer index 0 of the fragment shader in `MyShaders.metal`.  The name of the struct, and the buffer index it is assigned to is flexible.  SceneKit binds the values solely based on the names of the fields in the struct.  The `Symbols` struct defined in `MyShaders.metal` contains a field for each custom symbol.\n\n```c\nstruct Symbols {\n    float3 color_weights;\n    float time;\n};\n```\n\n```c\nfragment half4 myFragmentShader(VertexOut in [[stage_in]],\n                                constant Symbols &symbols [[buffer(0)]],\n                                texture2d<half, access::sample> color [[texture(0)]]) { ... }\n```\n\n## Renderer Customization\n\n- **SCNShadable**: Methods for customizing SceneKit’s rendering of geometry and materials using Metal or OpenGL shader programs.\n- **SCNProgram**: A complete Metal or OpenGL shader program that replaces SceneKit’s rendering of a geometry or material.\n- **SCNBufferStream**: An object that manages a Metal buffer used by a custom shader program.\n- **SCNTechnique**: A specification for augmenting or postprocessing SceneKit’s rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\n- **SCNTechniqueSupport**: The common interface for SceneKit objects that support multipass rendering using [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique] objects.\n- **SCNNodeRendererDelegate**: Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Methods for customizing SceneKit’s rendering of geometry and materials using Metal or OpenGL shader programs.",
          "name" : "SCNShadable",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNShadable"
        },
        {
          "description" : "A complete Metal or OpenGL shader program that replaces SceneKit’s rendering of a geometry or material.",
          "name" : "SCNProgram",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNProgram"
        },
        {
          "description" : "An object that manages a Metal buffer used by a custom shader program.",
          "name" : "SCNBufferStream",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNBufferStream"
        },
        {
          "description" : "A specification for augmenting or postprocessing SceneKit’s rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.",
          "name" : "SCNTechnique",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique"
        },
        {
          "description" : "The common interface for SceneKit objects that support multipass rendering using [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique] objects.",
          "name" : "SCNTechniqueSupport",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechniqueSupport"
        },
        {
          "description" : "Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.",
          "name" : "SCNNodeRendererDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNNodeRendererDelegate"
        }
      ],
      "title" : "Renderer Customization"
    }
  ],
  "source" : "appleJSON",
  "title" : "Postprocessing a Scene With Custom Symbols",
  "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/postprocessing-a-scene-with-custom-symbols"
}