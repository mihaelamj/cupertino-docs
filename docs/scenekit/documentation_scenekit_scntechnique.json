{
  "abstract" : "A specification for augmenting or postprocessing SceneKit’s rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.",
  "codeExamples" : [
    {
      "code" : "{\n  \"passes\" : {\n    \"displacement\" : {\n      \"outputs\" : {\n        \"color\" : \"COLOR\"\n      },\n      \"inputs\" : {\n        \"colorSampler\" : \"COLOR\",\n        \"noiseSampler\" : \"noiseSymbol\",\n        \"a_position\" : \"a_position-symbol\"\n      },\n      \"program\" : \"displacement\",\n      \"draw\" : \"DRAW_QUAD\"\n    }\n  },\n  \"sequence\" : [\n    \"displacement\"\n  ],\n  \"symbols\" : {\n    \"a_position-symbol\" : {\n      \"semantic\" : \"vertex\"\n    },\n    \"noiseSymbol\" : {\n      \"image\" : \"noise.png\",\n      \"type\" : \"sampler2D\"\n    }\n  }\n}",
      "language" : "objc"
    },
    {
      "code" : "attribute vec4 a_position;\nvarying vec2 uv;\n \nvoid main() {\n    gl_Position = a_position;\n    uv = (a_position.xy + 1.0) * 0.5;\n}",
      "language" : "objc"
    },
    {
      "code" : "uniform sampler2D colorSampler;\nuniform sampler2D noiseSampler;\n \nvarying vec2 uv;\n \nvoid main() {\n    vec2 displacement = texture2D(noiseSampler, uv).rg - vec2(0.5, 0.5);\n    gl_FragColor = texture2D(colorSampler, uv + displacement * vec2(0.1,0.1));\n}",
      "language" : "objc"
    }
  ],
  "conformsTo" : [
    "CVarArg",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Equatable",
    "Hashable",
    "NSCoding",
    "NSCopying",
    "NSObjectProtocol",
    "NSSecureCoding",
    "SCNAnimatable"
  ],
  "contentHash" : "0ee5fc1857dab7c0951a9b210664c710ce4f7e7232cdda113d738895f45434a3",
  "crawledAt" : "2025-12-03T12:34:19Z",
  "declaration" : {
    "code" : "class SCNTechnique",
    "language" : "swift"
  },
  "id" : "87B4CA96-47C7-4E61-A044-40775FCF2252",
  "kind" : "class",
  "language" : "swift",
  "module" : "SceneKit",
  "overview" : "## Overview\n\nExamples of multipass rendering techniques include:\n\n\n\nTo create an [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique] object, you supply a technique definition that specifies the input and output image buffers, shader programs, shader input variables, and rendering options for each drawing pass in the technique. Defining a technique does not require Metal or OpenGL client code, but you should be familiar with the terminology and conventions of GPU rendering.\n\nTo use a technique, assign it to the [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechniqueSupport\/technique] property of a view (or other SceneKit renderer object) or a camera.\n\n### Defining a Technique\n\nSceneKit treats rendering techniques—along with shaders, 3D models, and 2D art assets—as resources rather than as part of your application code. Because the effects you create with techniques are highly visual, this approach allows you to separate design efforts from development efforts and quickly iterate on creating the visual content of your app or game.\n\nCreate a technique object using the [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique\/init(dictionary:)] method, providing a dictionary that defines the technique as a series of drawing passes, each with its own shader program, inputs and outputs, and rendering options. Typically, you obtain this dictionary from a property list file included in your app’s bundle resources. Table 1 and the additional tables and sections that follow specify the format of this dictionary’s contents.\n\n#### Category Masks\n\nWhen SceneKit performs a rendering pass whose `draw` option is `DRAW_SCENE` or `DRAW_NODE`, you can use category masks to filter the set of nodes drawn during that pass. For each node in the scene (or for `DRAW_NODE`, in the node subtree), SceneKit compares the node’s [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNNode\/categoryBitMask] property and the `includeCategoryMask` and `excludeCategoryMask` options in the pass definition using bitwise AND operations. If the node’s category mask and the include mask overlap (that is, the bitwise AND results in a nonzero value) and the node’s category mask and the exclude mask do not overlap, SceneKit includes the node in the drawing pass. Otherwise the node is not rendered in the pass.\n\n#### Render Targets, Inputs and Outputs\n\nA drawing pass renders pixel data into one or more target image buffer (or framebuffer). In SceneKit’s main drawing pass, the color render target is the screen (or rather, a view or layer for screen display), and a depth render target temporarily stores the information needed to ensure that rendered surfaces appear in the correct depth order.\n\nA pass in a custom rendering technique may postprocess the pixel data in SceneKit’s render target, generate its own pixel data for display, or render to an intermediate target to be used as input in a later pass. You specify render targets using the following identifiers in the `inputs` and `outputs` dictionaries of a pass definition:\n\nUse the `COLOR` target as an output to identify the image buffer displayed as the end result of a technique.\n\nTo specify a render target or image sampler in the `inputs` dictionary of a pass definition, you can provide either an identifier string or a dictionary with the format described in Table 6. The options for samplers correspond to similar properties for SceneKit material textures. For more details on each, see [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNMaterialProperty].\n\n#### Blending\n\nThe `blendStates` key of a pass definition defines color blending options. Blending is disabled by default for faster rendering performance. Including a dictionary for this key enables blending (unless the dictionary’s `enable` key specifies [doc:\/\/com.apple.documentation\/documentation\/Swift\/false]). Color blending combines a source color (the color output by the drawing pass’s shader program) with a destination color (the existing contents of the output buffer) using specified modes and operations.\n\nThese values correspond to blending options defined by the OpenGL specification. For further details, consult the [http:\/\/www.opengl.org\/registry\/] or [http:\/\/www.khronos.org\/registry\/gles\/].\n\n### Example Technique Definition\n\nListing 1 shows an example definition dictionary for a technique that uses displacement mapping with a noise texture to postprocess a rendered scene. For ease of reading, the dictionary is formatted in JSON syntax. (To load an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSDictionary] object from text in this format, use the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/JSONSerialization] class.) Listing 2 and Listing 3 show the GLSL source code for the technique’s vertex and fragment shaders.\n\nListing 1. JSON definition dictionary for a technique\n\nListing 2. GLSL Vertex shader source code for displacement mapping technique\n\nListing 3. GLSL Fragment shader source code for displacement mapping technique",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/scenekit\/scntechnique\ncrawled: 2025-12-03T12:34:19Z\n---\n\n# SCNTechnique\n\n**Class**\n\nA specification for augmenting or postprocessing SceneKit’s rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.\n\n## Declaration\n\n```swift\nclass SCNTechnique\n```\n\n## Overview\n\nExamples of multipass rendering techniques include:\n\n- Postprocessing rendered pixels. To create effects such as color grading and displacement mapping, define techniques that use as input the color buffer rendered by SceneKit and process that buffer with a fragment shader.\n- Deferred shading. To create effects such as motion blur and screen-space ambient occlusion (SSAO), define techniques that capture information about the scene into an intermediary buffer during the main rendering pass and then perform additional drawing passes using that buffer to create the final output image. The figure below illustrates the rendering process for an SSAO technique.\n\n\n\nTo create an [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique] object, you supply a technique definition that specifies the input and output image buffers, shader programs, shader input variables, and rendering options for each drawing pass in the technique. Defining a technique does not require Metal or OpenGL client code, but you should be familiar with the terminology and conventions of GPU rendering.\n\nTo use a technique, assign it to the [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechniqueSupport\/technique] property of a view (or other SceneKit renderer object) or a camera.\n\n### Defining a Technique\n\nSceneKit treats rendering techniques—along with shaders, 3D models, and 2D art assets—as resources rather than as part of your application code. Because the effects you create with techniques are highly visual, this approach allows you to separate design efforts from development efforts and quickly iterate on creating the visual content of your app or game.\n\nCreate a technique object using the [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique\/init(dictionary:)] method, providing a dictionary that defines the technique as a series of drawing passes, each with its own shader program, inputs and outputs, and rendering options. Typically, you obtain this dictionary from a property list file included in your app’s bundle resources. Table 1 and the additional tables and sections that follow specify the format of this dictionary’s contents.\n\n\n\n\n\n\n\n\n\n#### Category Masks\n\nWhen SceneKit performs a rendering pass whose `draw` option is `DRAW_SCENE` or `DRAW_NODE`, you can use category masks to filter the set of nodes drawn during that pass. For each node in the scene (or for `DRAW_NODE`, in the node subtree), SceneKit compares the node’s [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNNode\/categoryBitMask] property and the `includeCategoryMask` and `excludeCategoryMask` options in the pass definition using bitwise AND operations. If the node’s category mask and the include mask overlap (that is, the bitwise AND results in a nonzero value) and the node’s category mask and the exclude mask do not overlap, SceneKit includes the node in the drawing pass. Otherwise the node is not rendered in the pass.\n\n#### Render Targets, Inputs and Outputs\n\nA drawing pass renders pixel data into one or more target image buffer (or framebuffer). In SceneKit’s main drawing pass, the color render target is the screen (or rather, a view or layer for screen display), and a depth render target temporarily stores the information needed to ensure that rendered surfaces appear in the correct depth order.\n\nA pass in a custom rendering technique may postprocess the pixel data in SceneKit’s render target, generate its own pixel data for display, or render to an intermediate target to be used as input in a later pass. You specify render targets using the following identifiers in the `inputs` and `outputs` dictionaries of a pass definition:\n\n- Use the `COLOR` and `DEPTH` targets as inputs to identify the color and depth buffers rendered to in SceneKit’s main drawing pass.\n\nUse the `COLOR` target as an output to identify the image buffer displayed as the end result of a technique.\n\n- To create an intermediate target, define your own identifier as a key in the `targets` dictionary of a technique definition. For the corresponding value, provide a dictionary defining the render target using the keys and values in Table 5. Intermediate targets may be color, depth, or combined depth and stencil buffers. After you define a target, you can use its identifier in the `inputs` and `outputs` dictionaries of a pass definition.\n- To use an image as an input texture for a pass, define a symbol of type `sampler2D` in the technique’s `symbols` dictionary.\n\nTo specify a render target or image sampler in the `inputs` dictionary of a pass definition, you can provide either an identifier string or a dictionary with the format described in Table 6. The options for samplers correspond to similar properties for SceneKit material textures. For more details on each, see [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNMaterialProperty].\n\n\n\n\n\n#### Blending\n\nThe `blendStates` key of a pass definition defines color blending options. Blending is disabled by default for faster rendering performance. Including a dictionary for this key enables blending (unless the dictionary’s `enable` key specifies [doc:\/\/com.apple.documentation\/documentation\/Swift\/false]). Color blending combines a source color (the color output by the drawing pass’s shader program) with a destination color (the existing contents of the output buffer) using specified modes and operations.\n\n- Available blend modes (for the `colorSrc`, `colorDst`, `alphaSrc`, and `alphaDst` keys): `zero`, `one`, `srcColor`, `oneMinusSrcColor`, `srcAlpha`, `oneMinusSrcAlpha`, `dstColor`, `oneMinusDstColor`, `dstAlpha`, `oneMinusDstAlpha`, `constantColor`, `oneMinusConstantColor`, `constantAlpha`, `oneMinusConstantAlpha`, and `alphaSaturate`.\n- Available blend operations (for the `colorOp` and `alphaOp` keys): `add`, `subtract`, `reverseSubtract`, `min`, `max`.\n\nThese values correspond to blending options defined by the OpenGL specification. For further details, consult the [http:\/\/www.opengl.org\/registry\/] or [http:\/\/www.khronos.org\/registry\/gles\/].\n\n### Example Technique Definition\n\nListing 1 shows an example definition dictionary for a technique that uses displacement mapping with a noise texture to postprocess a rendered scene. For ease of reading, the dictionary is formatted in JSON syntax. (To load an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSDictionary] object from text in this format, use the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/JSONSerialization] class.) Listing 2 and Listing 3 show the GLSL source code for the technique’s vertex and fragment shaders.\n\nListing 1. JSON definition dictionary for a technique\n\n```objc\n{\n  \"passes\" : {\n    \"displacement\" : {\n      \"outputs\" : {\n        \"color\" : \"COLOR\"\n      },\n      \"inputs\" : {\n        \"colorSampler\" : \"COLOR\",\n        \"noiseSampler\" : \"noiseSymbol\",\n        \"a_position\" : \"a_position-symbol\"\n      },\n      \"program\" : \"displacement\",\n      \"draw\" : \"DRAW_QUAD\"\n    }\n  },\n  \"sequence\" : [\n    \"displacement\"\n  ],\n  \"symbols\" : {\n    \"a_position-symbol\" : {\n      \"semantic\" : \"vertex\"\n    },\n    \"noiseSymbol\" : {\n      \"image\" : \"noise.png\",\n      \"type\" : \"sampler2D\"\n    }\n  }\n}\n```\n\nListing 2. GLSL Vertex shader source code for displacement mapping technique\n\n```objc\nattribute vec4 a_position;\nvarying vec2 uv;\n \nvoid main() {\n    gl_Position = a_position;\n    uv = (a_position.xy + 1.0) * 0.5;\n}\n```\n\nListing 3. GLSL Fragment shader source code for displacement mapping technique\n\n```objc\nuniform sampler2D colorSampler;\nuniform sampler2D noiseSampler;\n \nvarying vec2 uv;\n \nvoid main() {\n    vec2 displacement = texture2D(noiseSampler, uv).rg - vec2(0.5, 0.5);\n    gl_FragColor = texture2D(colorSampler, uv + displacement * vec2(0.1,0.1));\n}\n```\n\n## Creating a Technique\n\n- **init(dictionary:)**: Creates a technique from a technique definition dictionary.,\n\n## Combining Techniques\n\n- **init(bySequencingTechniques:)**: Creates a new rendering technique that combines a series of techniques.\n\n## Retrieving a Technique’s Definition\n\n- **dictionaryRepresentation**: The dictionary defining the rendering technique.\n\n## Handling Parameters for a Technique’s Shader Programs\n\n- **handleBinding(ofSymbol:using:)**: Specifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.\n- **setObject(_:forKeyedSubscript:)**: Sets a value for the specified shader  variable or attribute name, using subscript syntax.\n- **subscript(_:)**: Returns the value associated with the specified GLSL uniform variable or attribute name, using subscript syntax.\n\n## Instance Properties\n\n- **library**\n\n## Renderer Customization\n\n- **SCNShadable**: Methods for customizing SceneKit’s rendering of geometry and materials using Metal or OpenGL shader programs.\n- **SCNProgram**: A complete Metal or OpenGL shader program that replaces SceneKit’s rendering of a geometry or material.\n- **SCNBufferStream**: An object that manages a Metal buffer used by a custom shader program.\n- **SCNTechniqueSupport**: The common interface for SceneKit objects that support multipass rendering using [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique] objects.\n- **SCNNodeRendererDelegate**: Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.\n- **Postprocessing a Scene With Custom Symbols**: Create visual effects in a scene by defining a rendering technique with custom symbols.\n\n## Inherits From\n\n- NSObject\n\n## Conforms To\n\n- CVarArg\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Equatable\n- Hashable\n- NSCoding\n- NSCopying\n- NSObjectProtocol\n- NSSecureCoding\n- SCNAnimatable\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a technique from a technique definition dictionary.,",
          "name" : "init(dictionary:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique\/init(dictionary:)"
        }
      ],
      "title" : "Creating a Technique"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a new rendering technique that combines a series of techniques.",
          "name" : "init(bySequencingTechniques:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique\/init(bySequencingTechniques:)"
        }
      ],
      "title" : "Combining Techniques"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The dictionary defining the rendering technique.",
          "name" : "dictionaryRepresentation",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique\/dictionaryRepresentation"
        }
      ],
      "title" : "Retrieving a Technique’s Definition"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Specifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.",
          "name" : "handleBinding(ofSymbol:using:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique\/handleBinding(ofSymbol:using:)"
        },
        {
          "description" : "Sets a value for the specified shader  variable or attribute name, using subscript syntax.",
          "name" : "setObject(_:forKeyedSubscript:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique\/setObject(_:forKeyedSubscript:)"
        },
        {
          "description" : "Returns the value associated with the specified GLSL uniform variable or attribute name, using subscript syntax.",
          "name" : "subscript(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique\/subscript(_:)"
        }
      ],
      "title" : "Handling Parameters for a Technique’s Shader Programs"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "library",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechnique\/library"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Methods for customizing SceneKit’s rendering of geometry and materials using Metal or OpenGL shader programs.",
          "name" : "SCNShadable",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNShadable"
        },
        {
          "description" : "A complete Metal or OpenGL shader program that replaces SceneKit’s rendering of a geometry or material.",
          "name" : "SCNProgram",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNProgram"
        },
        {
          "description" : "An object that manages a Metal buffer used by a custom shader program.",
          "name" : "SCNBufferStream",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNBufferStream"
        },
        {
          "description" : "The common interface for SceneKit objects that support multipass rendering using [doc:\/\/com.apple.scenekit\/documentation\/SceneKit\/SCNTechnique] objects.",
          "name" : "SCNTechniqueSupport",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNTechniqueSupport"
        },
        {
          "description" : "Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node.",
          "name" : "SCNNodeRendererDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/SCNNodeRendererDelegate"
        },
        {
          "description" : "Create visual effects in a scene by defining a rendering technique with custom symbols.",
          "name" : "Postprocessing a Scene With Custom Symbols",
          "url" : "https:\/\/developer.apple.com\/documentation\/SceneKit\/postprocessing-a-scene-with-custom-symbols"
        }
      ],
      "title" : "Renderer Customization"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "NSObject"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "SCNTechnique",
  "url" : "https:\/\/developer.apple.com\/documentation\/scenekit\/scntechnique"
}