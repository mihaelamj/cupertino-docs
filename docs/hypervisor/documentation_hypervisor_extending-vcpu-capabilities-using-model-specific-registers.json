{
  "abstract" : "Configure specific client performance monitoring and enable other vCPU capabilities using Model-Specific Registers.",
  "codeExamples" : [
    {
      "code" : "hv_vcpuid_t vcpuid;\nif (hv_vcpu_create(&vcpuid, HV_VCPU_DEFAULT) != 0) { \/\/ Create a vCPU.\n    exit(1, \"create_vcpu failed \");\n}\n\nbool arch_cap_available = \/\/ The result of CPUID invoked with eax=7, ecx=0 returns bit 29 in edx set;\nif (arch_cap_available) {\n    \/\/ The IA32_ARCH_CAPABILITIES MSR is available on this platform.\n    ret = hv_vcpu_enable_managed_msr(vcpuid, HV_MSR_IA32_ARCH_CAPABILITIES, true);\n\n    if (ret == HV_SUCCESS) {\n       ret = hv_vcpu_set_msr_access(vcpuid, HV_MSR_IA32_ARCH_CAPABILITIES, HV_MSR_READ);\n    }\n\n   assert(ret == HV_SUCCESS);\n\n\/\/ Arrange to advertise this MSR to the guest via the clients VMX_REASON_CPUID exit handler.\n\n}\n",
      "language" : "objc"
    },
    {
      "code" : "\/\/ Check with CPUID to see if this MSR is available.\nmovl $IA32_ARCH_CAPABILITIES, %ecx\nrdmsr\n\/\/ Returns MSR in <%edx:%eax>\n",
      "language" : "C"
    }
  ],
  "contentHash" : "092ef2d9e02a5396d329adf8ae93050e51fea5238f884729bbfe9c812f3c7480",
  "crawledAt" : "2025-12-07T22:19:00Z",
  "id" : "F7A4C3A8-F30E-4607-9ADC-8B827498BDB0",
  "kind" : "article",
  "language" : "swift",
  "module" : "Hypervisor",
  "overview" : "## Overview\n\nThe Hypervisor framework supports managed Model-Specific Registers (MSRs). MSRs covers a wide range of functionality, including enabling guest access to a variety of extended hardware features, such as:\n\nMSRs are also useful in monitoring guest performance, and using them to customize a vCPU, including:\n\nTo bind and an MSR to the current vCPU, use the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vcpu_enable_managed_msr(_:_:_:)] function. Use the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vcpu_set_msr_access(_:_:_:)] function to grant or remove the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_READ] or [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_WRITE] permissions (or both). Unbinding an MSR removes read and write permissions from the guest.\n\nSome MSR facilities require saving and restoring the MSRs in a particular order. The hypervisor framework keeps a list of MSRs that it saves and restores on entry to, and exit from running the guest, along with the rest of the guest state across context switches. In macOS 10 and earlier, the framework appended new MSR requests to the end of the list. When removing an existing request, the framework copied the last entry down to the entry that the framework is deleting. In macOS 11 and later, the framework processes MSRs in the order that they’re added. The MSRs associated with the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS] register have additional requirements, described below, relating to binding of registers to the vCPU.\n\nBecause of the variety of possible host hardware, there’s no general formula that’s useful for discovering every MSR supported by the platform. Most approaches to determining specific MSR availability start with executing the `CPUID` instruction to determine the underlying hardware features. Then, using [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vmx_get_msr_info(_:_:)] it’s possible to discover more information about the particular subset of the MSRs that are available.\n\nThe example below checks for the availability of one of the speculation control and cache flushing MSRs. Here, a Boolean value, `arch_cap_enabled`, contains the result of a `CPUID` instruction that tests availability of the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_ARCH_CAPABILITIES] MSR on the Hypervisor host. If successful, the code enables the MSR and grants [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_READ] permission to the guest.\n\nIn the guest OS, test for the availability of [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_ARCH_CAPABILITIES] MSR using the `CPUID` instruction, and then read the register using the following assembly language fragment:\n\n### Analyze Guest Performance\n\nYou can use the performance counter MSRs to allow the guest OS to use hardware performance counters to measure aspects of guest performance. These measurements can be in the guest kernel or apps running in the guest OS.\n\nThe available performance counters and their capabilities vary greatly across machines and configurations, but include:\n\nBecause there are complex interactions between the registers, the framework places restrictions on some of these MSRs:\n\n### Record Branch Addresses with Last Branch MSRs\n\nYou use Last Branch MSRs when you need to record branching information from guest vCPUs; this can be useful for analyzing and understanding guest crashes.\n\nYou can bind Last Branch Register MSRs on more recent processors that support them. However, because of the interdependencies between MSRs, the framework requires that if you bind any of these Last Branch MSRs to a vCPU, you must bind all of them to the vCPU:\n\n### Control Security-Related Performance Impacts with Speculation Control MSRs\n\nThe framework supports several speculation control MSRs which can impact guest performance, including:\n\nFor more information about these MSRs, see [https:\/\/software.intel.com\/security-software-guidance\/insights\/deep-dive-cpuid-enumeration-and-architectural-msrs] (Intel Corporation).\n\nThe framework’s [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vmx_get_msr_info(_:_:)] function returns the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_ARCH_CAPABILITIES] MSR value on the platform, and describes the platform-specific capabilities through the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_VMX_INFO_MSR_IA32_ARCH_CAPABILITIES] value.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/hypervisor\/extending-vcpu-capabilities-using-model-specific-registers\ncrawled: 2025-12-07T22:19:00Z\n---\n\n# Extending vCPU Capabilities Using Model-Specific Registers\n\n**Article**\n\nConfigure specific client performance monitoring and enable other vCPU capabilities using Model-Specific Registers.\n\n## Overview\n\nThe Hypervisor framework supports managed Model-Specific Registers (MSRs). MSRs covers a wide range of functionality, including enabling guest access to a variety of extended hardware features, such as:\n\n- Enabling `sysenter` and `syscall` instructions for guest OS syscalls.\n- Accessing the timestamp counter to measure guest performance or measure time in a guest OS.\n- Managing the base address of the FS and GS segment registers.\n- Enabling access to extended supervisor state that allows access to certain protected mode register flags.\n\nMSRs are also useful in monitoring guest performance, and using them to customize a vCPU, including:\n\n- Enabling performance counters that make a vCPU to look more like real hardware, allowing guest operating systems to measure app and kernel performance.\n- Enabling last branch registers recording in order to gather information useful in debugging crashes in a guest OS or in the apps running in a guest OS.\n- Enabling or disabling branch and speculation control in the vCPU to mitigate known security issues for apps running in a guest OS.\n\nTo bind and an MSR to the current vCPU, use the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vcpu_enable_managed_msr(_:_:_:)] function. Use the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vcpu_set_msr_access(_:_:_:)] function to grant or remove the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_READ] or [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_WRITE] permissions (or both). Unbinding an MSR removes read and write permissions from the guest.\n\nSome MSR facilities require saving and restoring the MSRs in a particular order. The hypervisor framework keeps a list of MSRs that it saves and restores on entry to, and exit from running the guest, along with the rest of the guest state across context switches. In macOS 10 and earlier, the framework appended new MSR requests to the end of the list. When removing an existing request, the framework copied the last entry down to the entry that the framework is deleting. In macOS 11 and later, the framework processes MSRs in the order that they’re added. The MSRs associated with the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS] register have additional requirements, described below, relating to binding of registers to the vCPU.\n\nBecause of the variety of possible host hardware, there’s no general formula that’s useful for discovering every MSR supported by the platform. Most approaches to determining specific MSR availability start with executing the `CPUID` instruction to determine the underlying hardware features. Then, using [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vmx_get_msr_info(_:_:)] it’s possible to discover more information about the particular subset of the MSRs that are available.\n\nThe example below checks for the availability of one of the speculation control and cache flushing MSRs. Here, a Boolean value, `arch_cap_enabled`, contains the result of a `CPUID` instruction that tests availability of the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_ARCH_CAPABILITIES] MSR on the Hypervisor host. If successful, the code enables the MSR and grants [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_READ] permission to the guest.\n\n```objc\nhv_vcpuid_t vcpuid;\nif (hv_vcpu_create(&vcpuid, HV_VCPU_DEFAULT) != 0) { \/\/ Create a vCPU.\n    exit(1, \"create_vcpu failed \");\n}\n\nbool arch_cap_available = \/\/ The result of CPUID invoked with eax=7, ecx=0 returns bit 29 in edx set;\nif (arch_cap_available) {\n    \/\/ The IA32_ARCH_CAPABILITIES MSR is available on this platform.\n    ret = hv_vcpu_enable_managed_msr(vcpuid, HV_MSR_IA32_ARCH_CAPABILITIES, true);\n\n    if (ret == HV_SUCCESS) {\n       ret = hv_vcpu_set_msr_access(vcpuid, HV_MSR_IA32_ARCH_CAPABILITIES, HV_MSR_READ);\n    }\n\n   assert(ret == HV_SUCCESS);\n\n\/\/ Arrange to advertise this MSR to the guest via the clients VMX_REASON_CPUID exit handler.\n\n}\n\n```\n\nIn the guest OS, test for the availability of [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_ARCH_CAPABILITIES] MSR using the `CPUID` instruction, and then read the register using the following assembly language fragment:\n\n```C\n\/\/ Check with CPUID to see if this MSR is available.\nmovl $IA32_ARCH_CAPABILITIES, %ecx\nrdmsr\n\/\/ Returns MSR in <%edx:%eax>\n\n```\n\n\n\n### Analyze Guest Performance\n\nYou can use the performance counter MSRs to allow the guest OS to use hardware performance counters to measure aspects of guest performance. These measurements can be in the guest kernel or apps running in the guest OS.\n\nThe available performance counters and their capabilities vary greatly across machines and configurations, but include:\n\n- `HV_MSR_IA32_PMCn`\n- `HV_MSR_IA32_A_PMCn`\n- `HV_MSR_IA32_PERFEVNTSELn`\n- `HV_MSR_IA32_FIXED_CTRn`\n- `HV_MSR_PERF_METRICS`\n- `HV_MSR_IA32_FIXED_CTR_CTRL`\n- `HV_MSR_IA32_PERF_GLOBAL_CTRL`\n- `HV_MSR_IA32_PERF_GLOBAL_INUSE` (read-only register)\n- `HV_MSR_IA32_PERF_GLOBAL_STATUS` (read-only register)\n- `HV_MSR_IA32_PERF_GLOBAL_STATUS_RESET` (write-only register)\n- `HV_MSR_IA32_PERF_GLOBAL_STATUS_SET` (write-only register)\n\nBecause there are complex interactions between the registers, the framework places restrictions on some of these MSRs:\n\n- The framework reserves many of the fields in these registers: setting them to invalid or unsupported values prevents the guest from running. You can determine which bit positions represent available MSRs using the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vmx_get_msr_info(_:_:)] function.\n- The guest can’t set the `HV_MSR_IA32_PERFEVNTSELn` and the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_FIXED_CTR_CTRL] registers to be directly writable; the client must validate writes to these registers.\n- The framework requires enabling the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/VMENTRY_LOAD_IA32_PERF_GLOBAL_CTRL] and [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/VMEXIT_LOAD_IA32_PERF_GLOBAL_CTRL] controls. The framework uses these to stop the counters before loading the MSRs.\n- The `HV_MSR_IA32_PMCn` and `IA32_FIXED_CTR0n` registers can count more than 32 bits, but the context switches truncate the values to 32 bits (using the MSR write permission) upon restoration of the register state. One way the client can work around this limitation is by enabling the hardware counters without native access, and simulating wider registers through software. The `HV_MSR_IA32_A_PMCn` alias registers can be useful here as they can contain larger values.\n- If you bind to the `HV_MSR_IA32_PERFEVNTSELn` event selection registers, then you must bind the corresponding `HV_MSR_IA32_PMCn` registers`,` or its alias registers `HV_MSR_IA32_A_PMCn`. Similarly, if you bind the `HV_MSR_IA32_FIXED_CTR_CTRL` register, you must bind all valid `IA32_FIXED_CTRn` registers.\n- The framework doesn’t support native write-access to the `HV_MSR_IA32_PERFEVNTSELn`, [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_FIXED_CTR_CTRL], and [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_CTRL] registers. The client must intercept and handle writes to these registers to ensure that the guest isn’t given access to unsupported facilities or unbound counters.\n- If a full-width alias register — like [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_A_PMC0] or [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_A_PMC7] — is available in addition to the original [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PMC0] or [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PMC7] register, you can only bind one of them to a vCPU at a time. If there’s a binding to either, both MSRs are eligible for guest access.\n- You must bind the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS], [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS_RESET], and [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS_SET] registers to the vCPU. Use of the latter two registers should be in the order [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS_RESET] followed by [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS_SET]. The framework ensures the restoration of the status register first, and saves it last when switching contexts. You can grant native access to all three MSRs that map to the underlying status register. The guest global status register [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS_RESET] should be both read and written using [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_PERF_GLOBAL_STATUS]. Use of the same MSR name is intentional, the framework determines at runtime the right sequence of operations to call). The framework doesn’t support binding this register on processors with architectural performance monitoring version 3 or earlier.\n- The `RDPMC` instruction still requires a VM exit to occur. However, if you use the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_VCPU_ACCEL_RDPMC] flag when creating the vCPU, then the kernel automatically handles the `RDPMC` exit, and returns the values of any virtualized PMC register directly to the guest without exiting.\n\n### Record Branch Addresses with Last Branch MSRs\n\nYou use Last Branch MSRs when you need to record branching information from guest vCPUs; this can be useful for analyzing and understanding guest crashes.\n\nYou can bind Last Branch Register MSRs on more recent processors that support them. However, because of the interdependencies between MSRs, the framework requires that if you bind any of these Last Branch MSRs to a vCPU, you must bind all of them to the vCPU:\n\n- `HV_MSR_LASTBRANCH_n_FROM_IP`\n- `HV_MSR_LASTBRANCH_n_TO_IP`\n- `HV_MSR_LASTBRANCH_INFO_n`\n- `HV_MSR_LBR_SELECT`\n- `HV_MSR_LASTBRANCH_TOS`\n- `HV_MSR_LASTINT_FROM_IP`\n- `HV_MSR_LASTINT_TO_IP`\n\n### Control Security-Related Performance Impacts with Speculation Control MSRs\n\nThe framework supports several speculation control MSRs which can impact guest performance, including:\n\n- `HV_MSR_IA32_SPEC_CTRL`\n- `HV_MSR_IA32_PRED_CMD`\n- `HV_MSR_IA32_FLUSH_CMD`\n- `HV_MSR_IA32_ARCH_CAPABILITIES` (read-only register)\n\nFor more information about these MSRs, see [https:\/\/software.intel.com\/security-software-guidance\/insights\/deep-dive-cpuid-enumeration-and-architectural-msrs] (Intel Corporation).\n\nThe framework’s [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/hv_vmx_get_msr_info(_:_:)] function returns the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_MSR_IA32_ARCH_CAPABILITIES] MSR value on the platform, and describes the platform-specific capabilities through the [doc:\/\/com.apple.hypervisor\/documentation\/Hypervisor\/HV_VMX_INFO_MSR_IA32_ARCH_CAPABILITIES] value.\n\n## Model-Specific Registers\n\n- **hv_vcpu_read_msr(_:_:_:)**: Returns, by reference, the current value of a Model-Specific Register (MSR) of a vCPU.\n- **hv_vcpu_write_msr(_:_:_:)**: Sets the value of a Model-Specific Register (MSR) of a vCPU.\n- **hv_vcpu_enable_native_msr(_:_:_:)**: Enables or disables a Model-Specific Register (MSR) that the VM uses natively.\n- **hv_vcpu_set_msr_access(_:_:_:)**: Controls the guest access of a managed Model-Specific Register (MSR).\n- **hv_vcpu_enable_managed_msr(_:_:_:)**: Enables the guest access of a managed Model-Specific Register (MSR).\n- **hv_msr_flags_t**: The type representing the native Model-Specific Register (MSR) permissions.\n- **Model-Specific Registers**\n- **MSR Permissions**: An enumeration that describes possible Model-Specific Register (MSR) permisssions.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns, by reference, the current value of a Model-Specific Register (MSR) of a vCPU.",
          "name" : "hv_vcpu_read_msr(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/hv_vcpu_read_msr(_:_:_:)"
        },
        {
          "description" : "Sets the value of a Model-Specific Register (MSR) of a vCPU.",
          "name" : "hv_vcpu_write_msr(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/hv_vcpu_write_msr(_:_:_:)"
        },
        {
          "description" : "Enables or disables a Model-Specific Register (MSR) that the VM uses natively.",
          "name" : "hv_vcpu_enable_native_msr(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/hv_vcpu_enable_native_msr(_:_:_:)"
        },
        {
          "description" : "Controls the guest access of a managed Model-Specific Register (MSR).",
          "name" : "hv_vcpu_set_msr_access(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/hv_vcpu_set_msr_access(_:_:_:)"
        },
        {
          "description" : "Enables the guest access of a managed Model-Specific Register (MSR).",
          "name" : "hv_vcpu_enable_managed_msr(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/hv_vcpu_enable_managed_msr(_:_:_:)"
        },
        {
          "description" : "The type representing the native Model-Specific Register (MSR) permissions.",
          "name" : "hv_msr_flags_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/hv_msr_flags_t"
        },
        {
          "description" : "",
          "name" : "Model-Specific Registers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/3727856-model-specific-registers"
        },
        {
          "description" : "An enumeration that describes possible Model-Specific Register (MSR) permisssions.",
          "name" : "MSR Permissions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Hypervisor\/3567078-msr_permissions-enum"
        }
      ],
      "title" : "Model-Specific Registers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Extending vCPU Capabilities Using Model-Specific Registers",
  "url" : "https:\/\/developer.apple.com\/documentation\/hypervisor\/extending-vcpu-capabilities-using-model-specific-registers"
}