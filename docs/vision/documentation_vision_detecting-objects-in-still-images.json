{
  "abstract" : "Locate and demarcate rectangles, faces, barcodes, and text in images using the Vision framework.",
  "codeExamples" : [
    {
      "code" : "\/\/ Create a request handler.\nlet imageRequestHandler = VNImageRequestHandler(cgImage: image,\n                                                orientation: orientation,\n                                                options: [:])",
      "language" : "swift"
    },
    {
      "code" : "lazy var rectangleDetectionRequest: VNDetectRectanglesRequest = {\n    let rectDetectRequest = VNDetectRectanglesRequest(completionHandler: self.handleDetectedRectangles)\n    \/\/ Customize & configure the request to detect only certain rectangles.\n    rectDetectRequest.maximumObservations = 8 \/\/ Vision currently supports up to 16.\n    rectDetectRequest.minimumConfidence = 0.6 \/\/ Be confident.\n    rectDetectRequest.minimumAspectRatio = 0.3 \/\/ height \/ width\n    return rectDetectRequest\n}()",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Send the requests to the request handler.\nDispatchQueue.global(qos: .userInitiated).async {\n    do {\n        try imageRequestHandler.perform(requests)\n    } catch let error as NSError {\n        print(\"Failed to perform image request: \\(error)\")\n        self.presentAlert(\"Image Request Failed\", error: error)\n        return\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Perform drawing on the main thread.\nDispatchQueue.main.async {\n    guard let drawLayer = self.pathLayer,\n        let results = request?.results as? [VNFaceObservation] else {\n            return\n    }\n    self.draw(faces: results, onImageWithBounds: drawLayer.bounds)\n    drawLayer.setNeedsDisplay()\n}",
      "language" : "swift"
    },
    {
      "code" : "CATransaction.begin()\nfor observation in faces {\n    let faceBox = boundingBox(forRegionOfInterest: observation.boundingBox, withinImageBounds: bounds)\n    let faceLayer = shapeLayer(color: .yellow, frame: faceBox)\n    \n    \/\/ Add to pathLayer on top of image.\n    pathLayer?.addSublayer(faceLayer)\n}\nCATransaction.commit()",
      "language" : "swift"
    }
  ],
  "contentHash" : "4084fe8057b54ee6fbf73f7e81eb4f9d1cad3ca601e7fa88f443a148484f4a61",
  "crawledAt" : "2025-12-04T02:34:00Z",
  "id" : "6E0AC433-7A30-455A-A1FA-7653B3286540",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Vision",
  "overview" : "## Overview\n\nThe [https:\/\/developer.apple.com\/documentation\/vision] framework can detect rectangles, faces, text, and barcodes at any orientation.  This sample code shows how to create requests to detect these types of objects, and how to interpret the results of those requests.  To help you visualize where an observation occurs, and how it looks, this code uses Core Animation layers to draw paths around detected features in images.  For example, the following mock gift card has a QR code and rectangles that surface through the detector.  The sample highlights not only text blocks (shown in red) but also individual characters within text (shown in purple):\n\n\n\nThis sample code project runs on iOS 11. However, you can also use Vision in your own apps on macOS 10.13, iOS 11, or tvOS 11.\n\nTo see this sample in action, build and run the project, then use the toggle switches to choose which kinds of objects (any combination of rectangles, faces, barcodes, and text) to detect.  Tapping anywhere else prompts the sample to request a picture, which you either capture by camera or select from your photo library. The sample then applies computer vision algorithms to find the desired features in the provided image. Finally, the sample draws colored paths around observed features on [https:\/\/developer.apple.com\/documentation\/quartzcore] layers.\n\n### Prepare an Input Image for Vision\n\nVision handles still image-based requests using a [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler] and assumes that images are oriented upright, so pass your image with orientation in mind. [https:\/\/developer.apple.com\/documentation\/coregraphics\/cgimageref], [https:\/\/developer.apple.com\/documentation\/coreimage\/ciimage], and [https:\/\/developer.apple.com\/documentation\/corevideo\/cvpixelbuffer] objects don’t carry orientation, so provide it as part of the initializer.\n\nYou can initialize a [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler] from image data in the following formats:\n\nVision may not detect sideways or upside-down features properly if it assumes the wrong orientation.  Photos selected in the sample’s image picker contain orientation information.  Access this data through the `UIImage` property [https:\/\/developer.apple.com\/documentation\/uikit\/uiimage\/1624141-imageorientation]. If you acquire your photos through other means, such as from the web or other apps, be sure to check for orientation and provide it separately if it doesn’t come baked into the image.\n\n### Create Vision Requests\n\nCreate a [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler] object with the image to be processed.\n\nIf you’re making multiple requests from the same image (for example, detecting facial features as well as faces), create and bundle all requests to pass into the image request handler. Vision runs each request and executes its completion handler on its own thread.\n\nYou can pair each request with a completion handler to run request-specific code after Vision finishes all requests. The sample draws boxes differently based on the type of request, so this code differs from request to request. Specify your completion handler when initializing each request.\n\nAfter you’ve created all your requests, pass them as an array to the request handler’s synchronous [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2880297-perform]. Vision computations may consume resources and take time, so use a background queue to avoid blocking the main queue as it executes.\n\n### Interpret Detection Results\n\nThe method [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2880297-perform] returns a Boolean representing whether the requests succeeded or resulted in an error. If it succeeded, its [https:\/\/developer.apple.com\/documentation\/vision\/vnrequest\/2867238-results] property contains observation or tracking data, such as a detected object’s location and bounding box.\n\nYou can access results in two ways:\n\nFor example, the sample uses facial observations and their landmarks’ bounding boxes to locate the features and draw a rectangle around them.\n\nEven when Vision calls its completion handlers on a background thread, always dispatch UI calls like the path-drawing code to the main thread. Access to UIKit, AppKit & resources must be serialized, so changes that affect the app’s immediate appearance belong on the main thread.\n\nFor face landmark requests, the detector provides [https:\/\/developer.apple.com\/documentation\/vision\/vnfaceobservation] results with greater detail, such as [https:\/\/developer.apple.com\/documentation\/vision\/vnfacelandmarkregion2d].\n\nFor text observations, you can locate individual characters by checking the [https:\/\/developer.apple.com\/documentation\/vision\/vntextobservation\/2867213-characterboxes] property.\n\nFor barcode observations, some supported [https:\/\/developer.apple.com\/documentation\/vision\/vndetectbarcodesrequest\/2875397-symbologies] contain payload information in the [https:\/\/developer.apple.com\/documentation\/vision\/vnbarcodeobservation\/2923485-payloadstringvalue] property, allowing you to parse the content of detected barcodes. Like a supermarket scanner, barcode detection is optimized for finding one barcode per image.\n\nIt’s up to your app to use or store data from the observations before exiting the completion handler.  Instead of drawing paths like the sample does, write custom code to extract what your app needs from each observation.\n\n### Follow Best Practices\n\nTo reduce unnecessary computation, don’t create multiple request handlers and submit them multiple times on the same image.  Instead, create all your requests before querying Vision, bundle them inside a requests array, and submit that array in a single call.\n\nTo perform detection across multiple, unrelated images, create a separate image handler for each image and make requests to each handler on separate threads, so they run in parallel. Each image request handler costs additional processing time and memory, so try not to run them on the main thread. Dispatch these handlers on additional background threads, calling back to the main thread only for UI updates such as displaying images or paths.\n\nThe image-based handler that this sample introduces works for detection across any number of images, but it doesn’t track objects.  To perform object tracking, use a [https:\/\/developer.apple.com\/documentation\/vision\/vnsequencerequesthandler] instead.  For more information about object tracking, see Tracking the User’s Face in Real Time.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/vision\/detecting-objects-in-still-images\ncrawled: 2025-12-04T02:34:00Z\n---\n\n# Detecting Objects in Still Images\n\n**Sample Code**\n\nLocate and demarcate rectangles, faces, barcodes, and text in images using the Vision framework.\n\n## Overview\n\nThe [https:\/\/developer.apple.com\/documentation\/vision] framework can detect rectangles, faces, text, and barcodes at any orientation.  This sample code shows how to create requests to detect these types of objects, and how to interpret the results of those requests.  To help you visualize where an observation occurs, and how it looks, this code uses Core Animation layers to draw paths around detected features in images.  For example, the following mock gift card has a QR code and rectangles that surface through the detector.  The sample highlights not only text blocks (shown in red) but also individual characters within text (shown in purple):\n\n\n\nThis sample code project runs on iOS 11. However, you can also use Vision in your own apps on macOS 10.13, iOS 11, or tvOS 11.\n\nTo see this sample in action, build and run the project, then use the toggle switches to choose which kinds of objects (any combination of rectangles, faces, barcodes, and text) to detect.  Tapping anywhere else prompts the sample to request a picture, which you either capture by camera or select from your photo library. The sample then applies computer vision algorithms to find the desired features in the provided image. Finally, the sample draws colored paths around observed features on [https:\/\/developer.apple.com\/documentation\/quartzcore] layers.\n\n### Prepare an Input Image for Vision\n\nVision handles still image-based requests using a [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler] and assumes that images are oriented upright, so pass your image with orientation in mind. [https:\/\/developer.apple.com\/documentation\/coregraphics\/cgimageref], [https:\/\/developer.apple.com\/documentation\/coreimage\/ciimage], and [https:\/\/developer.apple.com\/documentation\/corevideo\/cvpixelbuffer] objects don’t carry orientation, so provide it as part of the initializer.\n\nYou can initialize a [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler] from image data in the following formats:\n\n- [https:\/\/developer.apple.com\/documentation\/coregraphics\/cgimageref]: The [https:\/\/developer.apple.com\/documentation\/coregraphics] image format, obtainable from any [https:\/\/developer.apple.com\/documentation\/uikit\/uiimage] through its helper method [https:\/\/developer.apple.com\/documentation\/uikit\/uiimage\/1624147-cgimage]. Specify orientation through the initializer using [https:\/\/developer.apple.com\/documentation\/imageio\/cgimagepropertyorientation].\n- [https:\/\/developer.apple.com\/documentation\/coreimage\/ciimage]: The [https:\/\/developer.apple.com\/documentation\/coreimage] format, best used if you already have Core Image in your image processing pipeline. `CIImage` objects don’t contain orientation, so supply it in the initializer [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2869641-init].\n- [https:\/\/developer.apple.com\/documentation\/corevideo\/cvpixelbuffer]: The [https:\/\/developer.apple.com\/documentation\/corevideo] image format for data from a live feed and movies.  `CVPixelBuffer` objects don’t contain orientation, so supply it in the initializer [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2880303-init].\n- [https:\/\/developer.apple.com\/documentation\/foundation\/nsdata]: Image data compressed or held in memory, as you might receive over a network connection. For example, photos downloaded from a website or the cloud fall into this category. Check that any images downloaded from the web have upright orientation; if they don’t, inform Vision about the orientation through the initializer  [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2869635-init].\n- [https:\/\/developer.apple.com\/documentation\/foundation\/nsurl]: A URL path to the image on disk.\n\nVision may not detect sideways or upside-down features properly if it assumes the wrong orientation.  Photos selected in the sample’s image picker contain orientation information.  Access this data through the `UIImage` property [https:\/\/developer.apple.com\/documentation\/uikit\/uiimage\/1624141-imageorientation]. If you acquire your photos through other means, such as from the web or other apps, be sure to check for orientation and provide it separately if it doesn’t come baked into the image.\n\n### Create Vision Requests\n\nCreate a [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler] object with the image to be processed.\n\n```swift\n\/\/ Create a request handler.\nlet imageRequestHandler = VNImageRequestHandler(cgImage: image,\n                                                orientation: orientation,\n                                                options: [:])\n```\n\nIf you’re making multiple requests from the same image (for example, detecting facial features as well as faces), create and bundle all requests to pass into the image request handler. Vision runs each request and executes its completion handler on its own thread.\n\nYou can pair each request with a completion handler to run request-specific code after Vision finishes all requests. The sample draws boxes differently based on the type of request, so this code differs from request to request. Specify your completion handler when initializing each request.\n\n```swift\nlazy var rectangleDetectionRequest: VNDetectRectanglesRequest = {\n    let rectDetectRequest = VNDetectRectanglesRequest(completionHandler: self.handleDetectedRectangles)\n    \/\/ Customize & configure the request to detect only certain rectangles.\n    rectDetectRequest.maximumObservations = 8 \/\/ Vision currently supports up to 16.\n    rectDetectRequest.minimumConfidence = 0.6 \/\/ Be confident.\n    rectDetectRequest.minimumAspectRatio = 0.3 \/\/ height \/ width\n    return rectDetectRequest\n}()\n```\n\nAfter you’ve created all your requests, pass them as an array to the request handler’s synchronous [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2880297-perform]. Vision computations may consume resources and take time, so use a background queue to avoid blocking the main queue as it executes.\n\n```swift\n\/\/ Send the requests to the request handler.\nDispatchQueue.global(qos: .userInitiated).async {\n    do {\n        try imageRequestHandler.perform(requests)\n    } catch let error as NSError {\n        print(\"Failed to perform image request: \\(error)\")\n        self.presentAlert(\"Image Request Failed\", error: error)\n        return\n    }\n}\n```\n\n### Interpret Detection Results\n\nThe method [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2880297-perform] returns a Boolean representing whether the requests succeeded or resulted in an error. If it succeeded, its [https:\/\/developer.apple.com\/documentation\/vision\/vnrequest\/2867238-results] property contains observation or tracking data, such as a detected object’s location and bounding box.\n\nYou can access results in two ways:\n\n- Check the [https:\/\/developer.apple.com\/documentation\/vision\/vnrequest\/2867238-results] property after calling [https:\/\/developer.apple.com\/documentation\/vision\/vnimagerequesthandler\/2880297-perform].\n- In the [https:\/\/developer.apple.com\/documentation\/vision\/vnimagebasedrequest] object’s completion handler, use the callback’s observation parameter to retrieve detection information.  The callback results may contain multiple observations, so loop through the observations array to process each one.\n\nFor example, the sample uses facial observations and their landmarks’ bounding boxes to locate the features and draw a rectangle around them.\n\n```swift\n\/\/ Perform drawing on the main thread.\nDispatchQueue.main.async {\n    guard let drawLayer = self.pathLayer,\n        let results = request?.results as? [VNFaceObservation] else {\n            return\n    }\n    self.draw(faces: results, onImageWithBounds: drawLayer.bounds)\n    drawLayer.setNeedsDisplay()\n}\n```\n\nEven when Vision calls its completion handlers on a background thread, always dispatch UI calls like the path-drawing code to the main thread. Access to UIKit, AppKit & resources must be serialized, so changes that affect the app’s immediate appearance belong on the main thread.\n\n```swift\nCATransaction.begin()\nfor observation in faces {\n    let faceBox = boundingBox(forRegionOfInterest: observation.boundingBox, withinImageBounds: bounds)\n    let faceLayer = shapeLayer(color: .yellow, frame: faceBox)\n    \n    \/\/ Add to pathLayer on top of image.\n    pathLayer?.addSublayer(faceLayer)\n}\nCATransaction.commit()\n```\n\nFor face landmark requests, the detector provides [https:\/\/developer.apple.com\/documentation\/vision\/vnfaceobservation] results with greater detail, such as [https:\/\/developer.apple.com\/documentation\/vision\/vnfacelandmarkregion2d].\n\nFor text observations, you can locate individual characters by checking the [https:\/\/developer.apple.com\/documentation\/vision\/vntextobservation\/2867213-characterboxes] property.\n\nFor barcode observations, some supported [https:\/\/developer.apple.com\/documentation\/vision\/vndetectbarcodesrequest\/2875397-symbologies] contain payload information in the [https:\/\/developer.apple.com\/documentation\/vision\/vnbarcodeobservation\/2923485-payloadstringvalue] property, allowing you to parse the content of detected barcodes. Like a supermarket scanner, barcode detection is optimized for finding one barcode per image.\n\nIt’s up to your app to use or store data from the observations before exiting the completion handler.  Instead of drawing paths like the sample does, write custom code to extract what your app needs from each observation.\n\n### Follow Best Practices\n\nTo reduce unnecessary computation, don’t create multiple request handlers and submit them multiple times on the same image.  Instead, create all your requests before querying Vision, bundle them inside a requests array, and submit that array in a single call.\n\nTo perform detection across multiple, unrelated images, create a separate image handler for each image and make requests to each handler on separate threads, so they run in parallel. Each image request handler costs additional processing time and memory, so try not to run them on the main thread. Dispatch these handlers on additional background threads, calling back to the main thread only for UI updates such as displaying images or paths.\n\nThe image-based handler that this sample introduces works for detection across any number of images, but it doesn’t track objects.  To perform object tracking, use a [https:\/\/developer.apple.com\/documentation\/vision\/vnsequencerequesthandler] instead.  For more information about object tracking, see Tracking the User’s Face in Real Time.\n\n## Still-image analysis\n\n- **Classifying images for categorization and search**: Analyze and label images using a Vision classification request.\n- **Analyzing Image Similarity with Feature Print**: Generate a feature print to compute distance between images.\n- **VNRequest**: The abstract superclass for analysis requests.\n- **VNImageBasedRequest**: The abstract superclass for image-analysis requests that focus on a specific part of an image.\n- **VNClassifyImageRequest**: A request to classify an image.\n- **VNGenerateImageFeaturePrintRequest**: An image-based request to generate feature prints from an image.\n- **VNFeaturePrintObservation**: An observation that provides the recognized feature print.\n- **VNImageRequestHandler**: An object that processes one or more image-analysis request pertaining to a single image.\n- **VNObservation**: The abstract superclass for analysis results.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Analyze and label images using a Vision classification request.",
          "name" : "Classifying images for categorization and search",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/classifying-images-for-categorization-and-search"
        },
        {
          "description" : "Generate a feature print to compute distance between images.",
          "name" : "Analyzing Image Similarity with Feature Print",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/analyzing-image-similarity-with-feature-print"
        },
        {
          "description" : "The abstract superclass for analysis requests.",
          "name" : "VNRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/VNRequest"
        },
        {
          "description" : "The abstract superclass for image-analysis requests that focus on a specific part of an image.",
          "name" : "VNImageBasedRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/VNImageBasedRequest"
        },
        {
          "description" : "A request to classify an image.",
          "name" : "VNClassifyImageRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/VNClassifyImageRequest"
        },
        {
          "description" : "An image-based request to generate feature prints from an image.",
          "name" : "VNGenerateImageFeaturePrintRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/VNGenerateImageFeaturePrintRequest"
        },
        {
          "description" : "An observation that provides the recognized feature print.",
          "name" : "VNFeaturePrintObservation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/VNFeaturePrintObservation"
        },
        {
          "description" : "An object that processes one or more image-analysis request pertaining to a single image.",
          "name" : "VNImageRequestHandler",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/VNImageRequestHandler"
        },
        {
          "description" : "The abstract superclass for analysis results.",
          "name" : "VNObservation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Vision\/VNObservation"
        }
      ],
      "title" : "Still-image analysis"
    }
  ],
  "source" : "appleJSON",
  "title" : "Detecting Objects in Still Images",
  "url" : "https:\/\/developer.apple.com\/documentation\/vision\/detecting-objects-in-still-images"
}