{
  "abstract" : "Leverage the spatial awareness of ARKit and Apple Ultra Wideband Chips in your app to guide users to a nearby device.",
  "codeExamples" : [
    {
      "code" : "if #available(iOS 17.0, watchOS 10.0, *) {\n    guard NISession.deviceCapabilities.supportsExtendedDistanceMeasurement else {\n        NSLog(\"This device isn't capable of finding visitors.\")\n        return\n    }\n    \n    guard token.deviceCapabilities.supportsExtendedDistanceMeasurement else {\n        NSLog(\"Peer device \\(peer.displayName) isn't capable of finding visitors.\")\n        return\n    }\n    \n    config.isExtendedDistanceMeasurementEnabled = true\n    NSLog(\"The Nearby Interaction session uses extended distance measurement.\")\n    \n} else {\n    NSLog(\"This version of iOS isn't capable of finding visitors.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "func startup() {\n    \/\/ The initial view.\n    Task { @MainActor in\n        self.updateViewState(with: nil, quality: .unknown, nearbyObject: nil, worldTransform: nil, showUpDownText: false)\n    }\n\n    \/\/ Create the interaction session.\n    session = NISession()\n    session?.delegateQueue = sessionQueue\n    \n    \/\/ Set a delegate.\n    session?.delegate = self\n\n    \/\/ Because this is a new session, reset the token-shared flag.\n    sharedTokenWithPeer = false\n    connectedPeer = nil\n\n    \/\/ Start multipeer connectivity (MPC) to discover peers.\n    startupMPC()\n}",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: NISession, didUpdate nearbyObjects: [NINearbyObject]) {\n    guard let peerToken = peerDiscoveryToken else {\n        fatalError(\"don't have peer token\")\n    }\n\n    \/\/ Find the right peer.\n    let peerObj = nearbyObjects.first { (obj) -> Bool in\n        return obj.discoveryToken == peerToken\n    }\n\n    guard let nearbyObjectUpdate = peerObj else {\n        return\n    }\n    \n    \/\/ When the session is ranging with its peer, the data connection might\n    \/\/ drop; after which which you don't need to keep it.\n    \/\/ Tear down the MPC session after the app initially started ranging with the peer.\n    \/\/ After the current ranging session stops and is invalidated, the app\n    \/\/ restarts a new MPC data connection for a new peer.\n    if mpc != nil {\n        tearDownMpc()\n    }\n\n    \/\/ Update and compute with updated `nearbyObject`.\n    currentNearbyObject = nearbyObjectUpdate\n    computeViewState(with: convergenceContext, nearbyObject: nearbyObjectUpdate)\n}",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: NISession, didInvalidateWith error: Error) {\n    \/\/ If the app doesn't have approval for Nearby Interaction, present\n    \/\/ an option to open the Settings app where the they can update the access.\n    if #available(iOS 17.0, watchOS 10.0, *) {\n        switch error {\n        case NIError.userDidNotAllow,\n            NIError.invalidARConfiguration,\n            NIError.incompatiblePeerDevice,\n            NIError.activeSessionsLimitExceeded,\n            NIError.activeExtendedDistanceSessionsLimitExceeded:\n            return\n        default:\n            break\n        }\n    } else {\n        switch error {\n        case NIError.userDidNotAllow,\n            NIError.invalidARConfiguration,\n            NIError.activeSessionsLimitExceeded:\n            return\n        default:\n            break\n        }\n    }\n    \n    \/\/ Recreate a valid session in other failure cases.\n    startup()\n}",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: NISession, didUpdateAlgorithmConvergence convergence: NIAlgorithmConvergence, for object: NINearbyObject?) {\n    guard let peerToken = peerDiscoveryToken else {\n        fatalError(\"Don't have peer token.\")\n    }\n\n    guard let nearbyObject = object, nearbyObject.discoveryToken == peerToken else {\n        return\n    }\n\n    \/\/ Update and compute with updated algorithm `convergence` and `nearbyObject`.\n    currentNearbyObject = nearbyObject\n    convergenceContext = convergence\n    computeViewState(with: convergence, nearbyObject: currentNearbyObject)\n}",
      "language" : "swift"
    },
    {
      "code" : "class MeasurementQualityEstimator {\n\n    \/\/ Define the criteria that qualify a peer with \"good\" characteristics:\n    \/\/ these include:\n\n    \/\/ A time window, in seconds.\n    let freshnessWindow = TimeInterval(floatLiteral: 2.0)\n    \/\/ A minimum number of samples in that time window.\n    let minSamples: Int = 8\n    \/\/ A maximim distance, in meters.\n    let maxDistance: Float = 50\n    \/\/ A minimum distance, in meters.\n    let closeDistance: Float = 10\n    \n    \/\/ A buffer to hold the individual quality measurements.\n    private var measurements: [TimedNIObject] = []\n    \n    \/\/ An enumeration that defines levels of peer quality.\n    enum MeasurementQuality {\n        \/\/ The peer fails to meet any of the measurement quality criteria.\n        case unknown\n\n        \/\/ The extended distance measurements indicate the peer iPhone or device\n        \/\/ satisfies the criteria for \"good\" quality and falls inside the\n        \/\/ minimum and maximum acceptable distance.\n        case good\n\n        \/\/ The extended distance measurements indicate the current device\n        \/\/ satisfies the criteria for being \"close\" to the peer iPhone or device.\n        case close\n    }\n\n    \/\/ A structure that captures the range of a peer at a specific time.\n    struct TimedNIObject {\n        let time: TimeInterval\n        let distance: Float\n    }\n\n    func estimateQuality(update: NINearbyObject?) -> MeasurementQuality {\n        let timeNow = NSDate().timeIntervalSinceReferenceDate\n        if let distance = update?.distance {\n            if let lastMeasureMent = measurements.last {\n                if lastMeasureMent.distance != distance {\n                    \/\/ Before adding a new measurement to buffers, check\n                    \/\/ if the reported distance is unique.\n                    measurements.append(TimedNIObject(time: timeNow, distance: distance))\n                }\n            } else {\n                \/\/ If the buffer is empty, unconditionally add the new measurement.\n                measurements.append(TimedNIObject(time: timeNow, distance: distance))\n            }\n        }\n        let validTimestamp = timeNow - freshnessWindow\n        measurements.removeAll { $0.time < validTimestamp }\n        if measurements.count > minSamples, let lastDistance = measurements.last?.distance {\n            if lastDistance <= closeDistance { return .close }\n            return lastDistance < maxDistance ? .good : .unknown\n        }\n        return .unknown\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "1e0959260c8f9d0d6770e65a6cbe04e6a8f8a5bc8beba0811511179e04c832a1",
  "crawledAt" : "2025-12-02T15:30:54Z",
  "id" : "99299BD7-1EA0-487C-A332-B3BAE3A01D9C",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Nearby Interaction",
  "overview" : "## Overview\n\nThis sample code project demonstrates how to use ARKit to find devices equipped with Apple Ultra Wideband (UWB) chips using a technique known as *ranging*. Ranging estimates the distance between devices using parameters such as signal strength and packet timing.\n\nTo use the Nearby Interaction framework in your app, it needs to implement the following three processes to use precision device finding:\n\n### Configure the sample code project\n\nTo run the app:\n\n### Check availability\n\nBecause there are two types of UWB chips, always check to ensure that the peer devices support the mode the app is interested in, as shown in the example below:\n\n### Start ARKit and ranging for peer devices\n\nBefore the app can start ranging for potential peer devices, it needs to setup ARKit and the [doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity] frameworks, as shown in this example:\n\n### Respond to changes in peer devices\n\nAfter the app initializes the Multipeer Connectivity framework, the Nearby Interaction framework provides a protocol for tracking changes to peer devices and provides information necessary to interact with peers it discovers in the environment.\n\nUse [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NISessionDelegate\/session(_:didUpdate:)] to track changes to peer connectivity, as shown in the sample below:\n\nWhen peers drop out of range or their session validity (user permissions) changes, the framework announces these changes using [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NISessionDelegate\/session(_:didInvalidateWith:)] and the app responds accordingly, as shown here:\n\nWhen the app sets [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NINearbyPeerConfiguration\/isCameraAssistanceEnabled] to `true`, the framework provides coaching suggestions through [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NISessionDelegate\/session(_:didUpdateAlgorithmConvergence:for:)], as shown here:\n\n### Define a distance quality estimator\n\nFinally, the key to using EDM is by creating a distance quality estimator function that the app uses to determine which peers to interact with. The specific criteria for such estimators are specific to your app’s use case; the following example is one such implementation:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/NearbyInteraction\/finding-devices-with-precision\ncrawled: 2025-12-02T15:30:54Z\n---\n\n# Finding devices with precision\n\n**Sample Code**\n\nLeverage the spatial awareness of ARKit and Apple Ultra Wideband Chips in your app to guide users to a nearby device.\n\n## Overview\n\nThis sample code project demonstrates how to use ARKit to find devices equipped with Apple Ultra Wideband (UWB) chips using a technique known as *ranging*. Ranging estimates the distance between devices using parameters such as signal strength and packet timing.\n\n\n\nTo use the Nearby Interaction framework in your app, it needs to implement the following three processes to use precision device finding:\n\n1. Check for availability of UWB and specific versions according to iOS releases if your app needs capabilities such as EDM.\n2. Start [doc:\/\/com.apple.documentation\/documentation\/ARKit], begin ranging for peer devices, and respond to changes in their status — this is how your app discovers compatible nearby devices and responds to changes in their availability.\n3. Implement a distance quality estimator function, if your app needs to take advantage of the EDM capabilities of the second-generation UWB chip. This is a function that uses data the Nearby Interaction framework returns to make decisions about signal quality to estimate the distance and direction between devices. This sample code project includes one possible implementation of a distance quality estimator function and its use to guide the people using the appropriate UI.\n\n### Configure the sample code project\n\nTo run the app:\n\n1. Install the app on two iPhone 15 devices or later.\n2. Rest one iPhone in portrait orientation as a stationary device.\n3. Run the app. If available, tap “Discuss jetpacks with another visitor” on both devices to run ranging with EDM capabilities (available on devices with second-generation UWB chips). Otherwise, tap “Go to next Exhibit” on both devices to run first-generation UWB ranging.\n4. On the first run, accept the request prompts for local network and camera access.\n5. Wait a few moments for the apps to discover each other, then accept the Nearby Interaction access prompt.\n6. To initialize ARKit, move the nonstationary device from side to side.\n7. With the stationary device in the immediate vicinity, move the active device up and down until the app displays an arrow.\n8. Move the active device until the arrow points upward in the direction of the stationary device.\n9. On the active device, the app’s blurred background fades and several virtual spheres display above the stationary device as it appears within the active device’s AR view.\n\n\n\n### Check availability\n\nBecause there are two types of UWB chips, always check to ensure that the peer devices support the mode the app is interested in, as shown in the example below:\n\n```swift\nif #available(iOS 17.0, watchOS 10.0, *) {\n    guard NISession.deviceCapabilities.supportsExtendedDistanceMeasurement else {\n        NSLog(\"This device isn't capable of finding visitors.\")\n        return\n    }\n    \n    guard token.deviceCapabilities.supportsExtendedDistanceMeasurement else {\n        NSLog(\"Peer device \\(peer.displayName) isn't capable of finding visitors.\")\n        return\n    }\n    \n    config.isExtendedDistanceMeasurementEnabled = true\n    NSLog(\"The Nearby Interaction session uses extended distance measurement.\")\n    \n} else {\n    NSLog(\"This version of iOS isn't capable of finding visitors.\")\n}\n```\n\n### Start ARKit and ranging for peer devices\n\nBefore the app can start ranging for potential peer devices, it needs to setup ARKit and the [doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity] frameworks, as shown in this example:\n\n```swift\nfunc startup() {\n    \/\/ The initial view.\n    Task { @MainActor in\n        self.updateViewState(with: nil, quality: .unknown, nearbyObject: nil, worldTransform: nil, showUpDownText: false)\n    }\n\n    \/\/ Create the interaction session.\n    session = NISession()\n    session?.delegateQueue = sessionQueue\n    \n    \/\/ Set a delegate.\n    session?.delegate = self\n\n    \/\/ Because this is a new session, reset the token-shared flag.\n    sharedTokenWithPeer = false\n    connectedPeer = nil\n\n    \/\/ Start multipeer connectivity (MPC) to discover peers.\n    startupMPC()\n}\n```\n\n### Respond to changes in peer devices\n\nAfter the app initializes the Multipeer Connectivity framework, the Nearby Interaction framework provides a protocol for tracking changes to peer devices and provides information necessary to interact with peers it discovers in the environment.\n\nUse [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NISessionDelegate\/session(_:didUpdate:)] to track changes to peer connectivity, as shown in the sample below:\n\n```swift\nfunc session(_ session: NISession, didUpdate nearbyObjects: [NINearbyObject]) {\n    guard let peerToken = peerDiscoveryToken else {\n        fatalError(\"don't have peer token\")\n    }\n\n    \/\/ Find the right peer.\n    let peerObj = nearbyObjects.first { (obj) -> Bool in\n        return obj.discoveryToken == peerToken\n    }\n\n    guard let nearbyObjectUpdate = peerObj else {\n        return\n    }\n    \n    \/\/ When the session is ranging with its peer, the data connection might\n    \/\/ drop; after which which you don't need to keep it.\n    \/\/ Tear down the MPC session after the app initially started ranging with the peer.\n    \/\/ After the current ranging session stops and is invalidated, the app\n    \/\/ restarts a new MPC data connection for a new peer.\n    if mpc != nil {\n        tearDownMpc()\n    }\n\n    \/\/ Update and compute with updated `nearbyObject`.\n    currentNearbyObject = nearbyObjectUpdate\n    computeViewState(with: convergenceContext, nearbyObject: nearbyObjectUpdate)\n}\n```\n\nWhen peers drop out of range or their session validity (user permissions) changes, the framework announces these changes using [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NISessionDelegate\/session(_:didInvalidateWith:)] and the app responds accordingly, as shown here:\n\n```swift\nfunc session(_ session: NISession, didInvalidateWith error: Error) {\n    \/\/ If the app doesn't have approval for Nearby Interaction, present\n    \/\/ an option to open the Settings app where the they can update the access.\n    if #available(iOS 17.0, watchOS 10.0, *) {\n        switch error {\n        case NIError.userDidNotAllow,\n            NIError.invalidARConfiguration,\n            NIError.incompatiblePeerDevice,\n            NIError.activeSessionsLimitExceeded,\n            NIError.activeExtendedDistanceSessionsLimitExceeded:\n            return\n        default:\n            break\n        }\n    } else {\n        switch error {\n        case NIError.userDidNotAllow,\n            NIError.invalidARConfiguration,\n            NIError.activeSessionsLimitExceeded:\n            return\n        default:\n            break\n        }\n    }\n    \n    \/\/ Recreate a valid session in other failure cases.\n    startup()\n}\n```\n\nWhen the app sets [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NINearbyPeerConfiguration\/isCameraAssistanceEnabled] to `true`, the framework provides coaching suggestions through [doc:\/\/com.apple.nearbyinteraction\/documentation\/NearbyInteraction\/NISessionDelegate\/session(_:didUpdateAlgorithmConvergence:for:)], as shown here:\n\n```swift\nfunc session(_ session: NISession, didUpdateAlgorithmConvergence convergence: NIAlgorithmConvergence, for object: NINearbyObject?) {\n    guard let peerToken = peerDiscoveryToken else {\n        fatalError(\"Don't have peer token.\")\n    }\n\n    guard let nearbyObject = object, nearbyObject.discoveryToken == peerToken else {\n        return\n    }\n\n    \/\/ Update and compute with updated algorithm `convergence` and `nearbyObject`.\n    currentNearbyObject = nearbyObject\n    convergenceContext = convergence\n    computeViewState(with: convergence, nearbyObject: currentNearbyObject)\n}\n```\n\n### Define a distance quality estimator\n\nFinally, the key to using EDM is by creating a distance quality estimator function that the app uses to determine which peers to interact with. The specific criteria for such estimators are specific to your app’s use case; the following example is one such implementation:\n\n```swift\nclass MeasurementQualityEstimator {\n\n    \/\/ Define the criteria that qualify a peer with \"good\" characteristics:\n    \/\/ these include:\n\n    \/\/ A time window, in seconds.\n    let freshnessWindow = TimeInterval(floatLiteral: 2.0)\n    \/\/ A minimum number of samples in that time window.\n    let minSamples: Int = 8\n    \/\/ A maximim distance, in meters.\n    let maxDistance: Float = 50\n    \/\/ A minimum distance, in meters.\n    let closeDistance: Float = 10\n    \n    \/\/ A buffer to hold the individual quality measurements.\n    private var measurements: [TimedNIObject] = []\n    \n    \/\/ An enumeration that defines levels of peer quality.\n    enum MeasurementQuality {\n        \/\/ The peer fails to meet any of the measurement quality criteria.\n        case unknown\n\n        \/\/ The extended distance measurements indicate the peer iPhone or device\n        \/\/ satisfies the criteria for \"good\" quality and falls inside the\n        \/\/ minimum and maximum acceptable distance.\n        case good\n\n        \/\/ The extended distance measurements indicate the current device\n        \/\/ satisfies the criteria for being \"close\" to the peer iPhone or device.\n        case close\n    }\n\n    \/\/ A structure that captures the range of a peer at a specific time.\n    struct TimedNIObject {\n        let time: TimeInterval\n        let distance: Float\n    }\n\n    func estimateQuality(update: NINearbyObject?) -> MeasurementQuality {\n        let timeNow = NSDate().timeIntervalSinceReferenceDate\n        if let distance = update?.distance {\n            if let lastMeasureMent = measurements.last {\n                if lastMeasureMent.distance != distance {\n                    \/\/ Before adding a new measurement to buffers, check\n                    \/\/ if the reported distance is unique.\n                    measurements.append(TimedNIObject(time: timeNow, distance: distance))\n                }\n            } else {\n                \/\/ If the buffer is empty, unconditionally add the new measurement.\n                measurements.append(TimedNIObject(time: timeNow, distance: distance))\n            }\n        }\n        let validTimestamp = timeNow - freshnessWindow\n        measurements.removeAll { $0.time < validTimestamp }\n        if measurements.count > minSamples, let lastDistance = measurements.last?.distance {\n            if lastDistance <= closeDistance { return .close }\n            return lastDistance < maxDistance ? .good : .unknown\n        }\n        return .unknown\n    }\n}\n```\n\n## Camera assistance\n\n- **NIAlgorithmConvergence**: An object that provides the state and reason for user coaching recommendations.\n- **NIAlgorithmConvergenceStatus**: The possible states of Camera Assistance.\n- **Algorithm Convergence Status**: The possible Objective-C states of Camera Assistance.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object that provides the state and reason for user coaching recommendations.",
          "name" : "NIAlgorithmConvergence",
          "url" : "https:\/\/developer.apple.com\/documentation\/NearbyInteraction\/NIAlgorithmConvergence"
        },
        {
          "description" : "The possible states of Camera Assistance.",
          "name" : "NIAlgorithmConvergenceStatus",
          "url" : "https:\/\/developer.apple.com\/documentation\/NearbyInteraction\/NIAlgorithmConvergenceStatus-2fnve"
        },
        {
          "description" : "The possible Objective-C states of Camera Assistance.",
          "name" : "Algorithm Convergence Status",
          "url" : "https:\/\/developer.apple.com\/documentation\/NearbyInteraction\/algorithm-convergence-status"
        }
      ],
      "title" : "Camera assistance"
    }
  ],
  "source" : "appleJSON",
  "title" : "Finding devices with precision",
  "url" : "https:\/\/developer.apple.com\/documentation\/NearbyInteraction\/finding-devices-with-precision"
}