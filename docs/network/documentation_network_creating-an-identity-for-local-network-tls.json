{
  "abstract" : "Learn how to create and use a digital identity in your application for local network TLS.",
  "codeExamples" : [
    {
      "code" : "let password = <# A password from the Keychain #>\nlet options = [kSecImportExportPassphrase: password ] as NSDictionary\nvar rawItems: CFArray?\nlet status = SecPKCS12Import(data as CFData, \/\/ Data from imported Identity.\n                             options as CFDictionary,\n                             &rawItems)\n\nguard status == errSecSuccess,\n      let items = rawItems,\n      let dictionaryItems = items as? Array<Dictionary<String, Any>> else {\n    \/\/ handle error …\n}\n\nlet secIdentity: SecIdentity = dictionaryItems[0][kSecImportItemIdentity as String] as! SecIdentity\n\n\/\/ Notice that kSecClass as String: kSecClassIdentity isn't used here as this is inferred from kSecValueRef.\nlet identityAddition = [\n    kSecValueRef: secIdentity,\n    kSecAttrLabel: \"ListenerIdentityLabel\"\n] as NSDictionary\n\nlet identityStatus = SecItemAdd(identityAddition as CFDictionary, nil)\n\nguard identityStatus == errSecSuccess else {\n    \/\/ handle error …\n}\n\/\/ Added identity successfully.",
      "language" : "swift"
    },
    {
      "code" : "func getSecIdentity() -> SecIdentity? {\n\n    \/\/ On the query, use kSecClassIdentity to make sure a SecIdentity is extracted.\n    let identityQuery = [\n        kSecClass: kSecClassIdentity,\n        kSecReturnRef: true,\n        kSecAttrLabel: \"ListenerIdentityLabel\"\n    ] as NSDictionary\n    var identityItem: CFTypeRef?\n    let getIdentityStatus = SecItemCopyMatching(identityQuery as CFDictionary, &identityItem)\n\n    guard getIdentityStatus == errSecSuccess else {\n        \/\/ handle error …\n    }\n    let secIdentity = identityItem as! SecIdentity\n    return secIdentity\n}",
      "language" : "swift"
    },
    {
      "code" : "let tlsOptions = NWProtocolTLS.Options()\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\nif let secIdentity = getSecIdentity(),\n   let identity = sec_identity_create(secIdentity) {\n    sec_protocol_options_set_min_tls_protocol_version(\n        tlsOptions.securityProtocolOptions, .TLSv12)\n    sec_protocol_options_set_local_identity(\n        tlsOptions.securityProtocolOptions, identity)\n} \nlet listener = try NWListener(using: tlsParams, on: 4433)",
      "language" : "swift"
    },
    {
      "code" : "func getSecIdentity() -> SecIdentity? {\n\n    var identity: SecIdentity?\n    let getquery = [kSecClass: kSecClassCertificate,\n        kSecAttrLabel: \"certificate_name_in_keychain\",\n        kSecReturnRef: true] as NSDictionary\n\n    var item: CFTypeRef?\n    let status = SecItemCopyMatching(getquery as CFDictionary, &item)\n    guard status == errSecSuccess else {\n        \/\/ handle error …\n    }\n    let certificate = item as! SecCertificate\n\n    let identityStatus = SecIdentityCreateWithCertificate(nil, certificate, &identity)\n    guard identityStatus == errSecSuccess else {\n        \/\/ handle error …\n    }\n    return identity\n}",
      "language" : "swift"
    },
    {
      "code" : "let tlsOptions = NWProtocolTLS.Options()\nsec_protocol_options_set_min_tls_protocol_version(\n    tlsOptions.securityProtocolOptions, \n    .TLSv12)\n\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\nlet endpoint = NWEndpoint.hostPort(host: \"listener-name.local\", port: 4433)\nlet connection = NWConnection(to: endpoint, using: tlsParams)",
      "language" : "swift"
    },
    {
      "code" : "let tlsOptions = NWProtocolTLS.Options()\nsec_protocol_options_set_min_tls_protocol_version(\n    tlsOptions.securityProtocolOptions, \n    .TLSv12)\n\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\nlet endpoint = NWEndpoint.hostPort(host: \"x.x.x.x\", port: 4433)\nlet connection = NWConnection(to: endpoint, using: tlsParams)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ [BoringSSL] boringssl_context_error_print(1863) boringssl ctx 0x2813acbe0: 4348594328:error:1000007d:SSL routines:OPENSSL_internal:CERTIFICATE_VERIFY_FAILED\n\/\/ [BoringSSL] boringssl_session_handshake_incomplete(164) [C1:1][0x1032186d0] SSL library error"
    },
    {
      "code" : "sec_protocol_options_set_verify_block(tlsOptions.securityProtocolOptions, { (_, trust, completionHandler) in\n    let secTrustRef = sec_trust_copy_ref(trust).takeRetainedValue() as SecTrust\n\n    \/\/ Cannot do hostname here because of IP.\n    let x509Policy = SecPolicyCreateBasicX509()\n    SecTrustSetPolicies(secTrustRef, x509Policy)\n\n    var error: CFError?\n    if !SecTrustEvaluateWithError(secTrustRef, &error) {\n        completionHandler(false)\n    }\n    \/\/ Perfom other certificate-based checks.  \n\n    completionHandler(true)\n}, .main)",
      "language" : "swift"
    }
  ],
  "contentHash" : "831379afeb952b2934685c2c35fe1556010c72d093e0bbae6a7406362055ce5c",
  "crawledAt" : "2025-12-06T14:21:38Z",
  "id" : "5B35393E-881E-43EA-9E46-5A330D780912",
  "kind" : "article",
  "language" : "swift",
  "module" : "Network",
  "overview" : "## Overview\n\nIn the context of Transport Layer Security (TLS), a *digital identity* is a cryptographic asset that contains a certificate and an associated private key for encrypting network traffic sent between a client and a server. Creating a digital identity for iOS or macOS is done so clients can communicate using TLS over the internet or a local network.\n\nIn this scenario, a server accepts client connections on a local network. While this article focuses on local network TLS, you can apply many of the concepts for other use cases. For example, setting up TLS with a certificate obtained from third-party Certificate Authority or configuring any system that needs to establish chain of trust to a root certificate.\n\n### Prepare the Environment\n\nImagine you’re building an app to handle orders in a restaurant. This app runs on a server device  — like an iPad or Mac — located at the front desk. Out in the restaurant, customers create and send orders to the server to be processed by the server using iOS client devices. In this situation, the server uses a digital identity from a local certificate authority to provide TLS to the clients. The following article explains how to setup both the server and client devices for local network TLS.\n\nTo create an identity for local network TLS the first thing you need to do is create and manage a local Certificate Authority (CA). A CA is a trusted entity that issues certificates for use in cryptographic operations. In this case, the CA serves as the trusted source of truth to issue a certificate that is used in a digital identity for TLS. Without this trusted authority, clients won’t be able to verify the issuer of the certificate they are using.\n\nAfter creating the CA, you need to issue a leaf certificate for the digital identity that is installed on the server. Next, you need to distribute the identity to the server. In the restaurant example, this is either the macOS or iOS device acting as the server. Lastly, you also need to distribute the root certificate to all of the iOS client devices in the restaurant network so that they can establish the chain of trust during the handshake process, and trust evaluation doesn’t need to be overridden.\n\nAn overview of how this would work can be described as follows:\n\n### Distribute the Identity to the Server\n\nOn iOS, the certificate authority owner is faced with the challenge of distributing the identity to the server. After transferring the identity on the server — either through thumb drive or through secure network transfer — save it to the Keychain. To save the identity in the iOS Keychain, use the following:\n\nTo retrieve the identity from the iOS Keychain, use the following:\n\nWith the local identity accessible from the Keychain, set it to [doc:\/\/com.apple.network\/documentation\/Network\/NWListener] to serve connections using TLS 1.2+ with the following:\n\nOn macOS, the code is largely the same except if the `NWListener` is running on the same machine that set up the local certificate authority then the app’s code can reference the identity by loading a reference from the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecCertificate] in the Keychain. To retrieve the identity from the Keychain on macOS, use the following:\n\nAfter loading the identity on macOS, you can use the exact same `NWListener` code on iOS.\n\n### Configure the Client Devices\n\nFor clients that connect to the server, install the root certificate on the client device to avoid overriding trust evaluation. After installing the root certificate on the client device, the client connects to the server using a local network name. When connecting from the client side of the connection, use the following:\n\nIf your client needs to connect over IP, instead of using a local network name, the server needs to use a leaf certificate that lists the IP in the “IP Address” field of the Subject Alternative Name. This also avoids having to override trust evaluation on the client and allows client connections to use the following:\n\nAttempting to connect from a client to a server without the root certificate installed on the client iOS device results in application errors similar to the following:\n\nTo work around this on the client, use `sec_protocol_options_set_verify_block` to perform your own verification checks on the peer’s leaf certificate. This isn’t the recommended path, but could be done in extreme cases. In the following example, [doc:\/\/com.apple.documentation\/documentation\/Security\/SecPolicyCreateBasicX509()] checks against the certificate’s basic x509 policy:\n\nFrom there the client can set up a handshake using TLS on a local network.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Network\/creating-an-identity-for-local-network-tls\ncrawled: 2025-12-06T14:21:38Z\n---\n\n# Creating an Identity for Local Network TLS\n\n**Article**\n\nLearn how to create and use a digital identity in your application for local network TLS.\n\n## Overview\n\nIn the context of Transport Layer Security (TLS), a *digital identity* is a cryptographic asset that contains a certificate and an associated private key for encrypting network traffic sent between a client and a server. Creating a digital identity for iOS or macOS is done so clients can communicate using TLS over the internet or a local network.\n\nIn this scenario, a server accepts client connections on a local network. While this article focuses on local network TLS, you can apply many of the concepts for other use cases. For example, setting up TLS with a certificate obtained from third-party Certificate Authority or configuring any system that needs to establish chain of trust to a root certificate.\n\n### Prepare the Environment\n\nImagine you’re building an app to handle orders in a restaurant. This app runs on a server device  — like an iPad or Mac — located at the front desk. Out in the restaurant, customers create and send orders to the server to be processed by the server using iOS client devices. In this situation, the server uses a digital identity from a local certificate authority to provide TLS to the clients. The following article explains how to setup both the server and client devices for local network TLS.\n\nTo create an identity for local network TLS the first thing you need to do is create and manage a local Certificate Authority (CA). A CA is a trusted entity that issues certificates for use in cryptographic operations. In this case, the CA serves as the trusted source of truth to issue a certificate that is used in a digital identity for TLS. Without this trusted authority, clients won’t be able to verify the issuer of the certificate they are using.\n\nAfter creating the CA, you need to issue a leaf certificate for the digital identity that is installed on the server. Next, you need to distribute the identity to the server. In the restaurant example, this is either the macOS or iOS device acting as the server. Lastly, you also need to distribute the root certificate to all of the iOS client devices in the restaurant network so that they can establish the chain of trust during the handshake process, and trust evaluation doesn’t need to be overridden.\n\nAn overview of how this would work can be described as follows:\n\n1. Create and manage your own certificate authority using the Keychain app on macOS.\n2. Distribute the identity to the server. On macOS, either create and use an identity on the same machine the server is running on, or securely distribute the PKCS#12 file to the device Keychain. On iOS, import the PKCS#12 file onto the server device. For example, you could load the PKCS#12 file onto a thumb drive and import it to the iOS server app and save it in the Keychain.\n3. On iOS client devices, install the root certificate onto the iOS device to form the chain of trust.\n\n### Distribute the Identity to the Server\n\nOn iOS, the certificate authority owner is faced with the challenge of distributing the identity to the server. After transferring the identity on the server — either through thumb drive or through secure network transfer — save it to the Keychain. To save the identity in the iOS Keychain, use the following:\n\n```swift\nlet password = <# A password from the Keychain #>\nlet options = [kSecImportExportPassphrase: password ] as NSDictionary\nvar rawItems: CFArray?\nlet status = SecPKCS12Import(data as CFData, \/\/ Data from imported Identity.\n                             options as CFDictionary,\n                             &rawItems)\n\nguard status == errSecSuccess,\n      let items = rawItems,\n      let dictionaryItems = items as? Array<Dictionary<String, Any>> else {\n    \/\/ handle error …\n}\n\nlet secIdentity: SecIdentity = dictionaryItems[0][kSecImportItemIdentity as String] as! SecIdentity\n\n\/\/ Notice that kSecClass as String: kSecClassIdentity isn't used here as this is inferred from kSecValueRef.\nlet identityAddition = [\n    kSecValueRef: secIdentity,\n    kSecAttrLabel: \"ListenerIdentityLabel\"\n] as NSDictionary\n\nlet identityStatus = SecItemAdd(identityAddition as CFDictionary, nil)\n\nguard identityStatus == errSecSuccess else {\n    \/\/ handle error …\n}\n\/\/ Added identity successfully.\n```\n\nTo retrieve the identity from the iOS Keychain, use the following:\n\n```swift\nfunc getSecIdentity() -> SecIdentity? {\n\n    \/\/ On the query, use kSecClassIdentity to make sure a SecIdentity is extracted.\n    let identityQuery = [\n        kSecClass: kSecClassIdentity,\n        kSecReturnRef: true,\n        kSecAttrLabel: \"ListenerIdentityLabel\"\n    ] as NSDictionary\n    var identityItem: CFTypeRef?\n    let getIdentityStatus = SecItemCopyMatching(identityQuery as CFDictionary, &identityItem)\n\n    guard getIdentityStatus == errSecSuccess else {\n        \/\/ handle error …\n    }\n    let secIdentity = identityItem as! SecIdentity\n    return secIdentity\n}\n```\n\nWith the local identity accessible from the Keychain, set it to [doc:\/\/com.apple.network\/documentation\/Network\/NWListener] to serve connections using TLS 1.2+ with the following:\n\n```swift\nlet tlsOptions = NWProtocolTLS.Options()\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\nif let secIdentity = getSecIdentity(),\n   let identity = sec_identity_create(secIdentity) {\n    sec_protocol_options_set_min_tls_protocol_version(\n        tlsOptions.securityProtocolOptions, .TLSv12)\n    sec_protocol_options_set_local_identity(\n        tlsOptions.securityProtocolOptions, identity)\n} \nlet listener = try NWListener(using: tlsParams, on: 4433)\n```\n\nOn macOS, the code is largely the same except if the `NWListener` is running on the same machine that set up the local certificate authority then the app’s code can reference the identity by loading a reference from the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecCertificate] in the Keychain. To retrieve the identity from the Keychain on macOS, use the following:\n\n```swift\nfunc getSecIdentity() -> SecIdentity? {\n\n    var identity: SecIdentity?\n    let getquery = [kSecClass: kSecClassCertificate,\n        kSecAttrLabel: \"certificate_name_in_keychain\",\n        kSecReturnRef: true] as NSDictionary\n\n    var item: CFTypeRef?\n    let status = SecItemCopyMatching(getquery as CFDictionary, &item)\n    guard status == errSecSuccess else {\n        \/\/ handle error …\n    }\n    let certificate = item as! SecCertificate\n\n    let identityStatus = SecIdentityCreateWithCertificate(nil, certificate, &identity)\n    guard identityStatus == errSecSuccess else {\n        \/\/ handle error …\n    }\n    return identity\n}\n```\n\nAfter loading the identity on macOS, you can use the exact same `NWListener` code on iOS.\n\n### Configure the Client Devices\n\nFor clients that connect to the server, install the root certificate on the client device to avoid overriding trust evaluation. After installing the root certificate on the client device, the client connects to the server using a local network name. When connecting from the client side of the connection, use the following:\n\n```swift\nlet tlsOptions = NWProtocolTLS.Options()\nsec_protocol_options_set_min_tls_protocol_version(\n    tlsOptions.securityProtocolOptions, \n    .TLSv12)\n\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\nlet endpoint = NWEndpoint.hostPort(host: \"listener-name.local\", port: 4433)\nlet connection = NWConnection(to: endpoint, using: tlsParams)\n```\n\n\n\nIf your client needs to connect over IP, instead of using a local network name, the server needs to use a leaf certificate that lists the IP in the “IP Address” field of the Subject Alternative Name. This also avoids having to override trust evaluation on the client and allows client connections to use the following:\n\n```swift\nlet tlsOptions = NWProtocolTLS.Options()\nsec_protocol_options_set_min_tls_protocol_version(\n    tlsOptions.securityProtocolOptions, \n    .TLSv12)\n\nlet tlsParams = NWParameters(tls: tlsOptions, tcp: .init())\n\nlet endpoint = NWEndpoint.hostPort(host: \"x.x.x.x\", port: 4433)\nlet connection = NWConnection(to: endpoint, using: tlsParams)\n```\n\nAttempting to connect from a client to a server without the root certificate installed on the client iOS device results in application errors similar to the following:\n\n```\n\/\/ [BoringSSL] boringssl_context_error_print(1863) boringssl ctx 0x2813acbe0: 4348594328:error:1000007d:SSL routines:OPENSSL_internal:CERTIFICATE_VERIFY_FAILED\n\/\/ [BoringSSL] boringssl_session_handshake_incomplete(164) [C1:1][0x1032186d0] SSL library error\n```\n\n\n\nTo work around this on the client, use `sec_protocol_options_set_verify_block` to perform your own verification checks on the peer’s leaf certificate. This isn’t the recommended path, but could be done in extreme cases. In the following example, [doc:\/\/com.apple.documentation\/documentation\/Security\/SecPolicyCreateBasicX509()] checks against the certificate’s basic x509 policy:\n\n```swift\nsec_protocol_options_set_verify_block(tlsOptions.securityProtocolOptions, { (_, trust, completionHandler) in\n    let secTrustRef = sec_trust_copy_ref(trust).takeRetainedValue() as SecTrust\n\n    \/\/ Cannot do hostname here because of IP.\n    let x509Policy = SecPolicyCreateBasicX509()\n    SecTrustSetPolicies(secTrustRef, x509Policy)\n\n    var error: CFError?\n    if !SecTrustEvaluateWithError(secTrustRef, &error) {\n        completionHandler(false)\n    }\n    \/\/ Perfom other certificate-based checks.  \n\n    completionHandler(true)\n}, .main)\n```\n\nFrom there the client can set up a handshake using TLS on a local network.\n\n## Network Security and Privacy\n\n- **Security Options**: Configure security options for TLS handshakes.\n- **Privacy Management**: Configure parameters related to user privacy.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Configure security options for TLS handshakes.",
          "name" : "Security Options",
          "url" : "https:\/\/developer.apple.com\/documentation\/Network\/security-options"
        },
        {
          "description" : "Configure parameters related to user privacy.",
          "name" : "Privacy Management",
          "url" : "https:\/\/developer.apple.com\/documentation\/Network\/privacy-management"
        }
      ],
      "title" : "Network Security and Privacy"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating an Identity for Local Network TLS",
  "url" : "https:\/\/developer.apple.com\/documentation\/Network\/creating-an-identity-for-local-network-tls"
}