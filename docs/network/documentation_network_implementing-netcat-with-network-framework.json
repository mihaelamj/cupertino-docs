{
  "abstract" : "Build a simple `netcat` tool that establishes network connections and transfers data.",
  "codeExamples" : [
    {
      "code" : "$ nwcat example.com 80",
      "language" : "shell"
    },
    {
      "code" : "$ nwcat -l 12345",
      "language" : "shell"
    },
    {
      "code" : "nw_parameters_configure_protocol_block_t configure_tls = NW_PARAMETERS_DISABLE_PROTOCOL;\nif (g_use_udp) {\n    parameters = nw_parameters_create_secure_udp(\n        configure_tls,\n        NW_PARAMETERS_DEFAULT_CONFIGURATION\n    );\n} else {\n    parameters = nw_parameters_create_secure_tcp(\n        configure_tls,\n        NW_PARAMETERS_DEFAULT_CONFIGURATION\n    );\n}",
      "language" : "objc"
    },
    {
      "code" : "nw_endpoint_t endpoint = nw_endpoint_create_host(name, port);",
      "language" : "objc"
    },
    {
      "code" : "nw_connection_t connection = nw_connection_create(endpoint, parameters);",
      "language" : "objc"
    },
    {
      "code" : "void\nstart_connection(nw_connection_t connection)\n{\n    nw_connection_set_queue(connection, dispatch_get_main_queue());\n    nw_retain(connection);\n    nw_connection_set_state_changed_handler(connection, ^(nw_connection_state_t state, nw_error_t error) {\n        … your state changed handler …\n    });\n    nw_connection_start(connection);\n}",
      "language" : "objc"
    },
    {
      "code" : "if (state == nw_connection_state_waiting) {\n    … tell the user that a connection couldn’t be opened but will retry when conditions are favourable …\n} else if (state == nw_connection_state_failed) {\n    … tell the user that the connection has failed irrecoverably …\n} else if (state == nw_connection_state_ready) {\n    … tell the user that you are connected …\n} else if (state == nw_connection_state_cancelled) {\n    nw_release(connection);\n}",
      "language" : "objc"
    },
    {
      "code" : "if (address || port) {\n    nw_endpoint_t local_endpoint = nw_endpoint_create_host(address ? address : \"::\", port ? port : \"0\");\n    nw_parameters_set_local_endpoint(parameters, local_endpoint);\n    nw_release(local_endpoint);\n}",
      "language" : "objc"
    },
    {
      "code" : "nw_listener_t listener = nw_listener_create(parameters);",
      "language" : "objc"
    },
    {
      "code" : "nw_listener_set_queue(listener, dispatch_get_main_queue());\nnw_retain(listener);\nnw_listener_set_state_changed_handler(listener, ^(nw_listener_state_t state, nw_error_t error) {\n    … your state changed handler …\n});\nnw_listener_set_new_connection_handler(listener, ^(nw_connection_t connection) {\n    … your new connection handler …\n});\nnw_listener_start(listener);",
      "language" : "objc"
    },
    {
      "code" : "if (g_inbound_connection != NULL) {\n    nw_connection_cancel(connection);\n} else {\n    g_inbound_connection = connection;\n    nw_retain(g_inbound_connection);\n\n    start_connection(g_inbound_connection);\n}",
      "language" : "objc"
    },
    {
      "code" : "void\nreceive_loop(nw_connection_t connection)\n{\n    nw_connection_receive(connection, 1, UINT32_MAX, ^(dispatch_data_t content, nw_content_context_t context, bool is_complete, nw_error_t receive_error) {\n\n        nw_retain(context);\n        dispatch_block_t schedule_next_receive = ^{\n            … discussed below …\n            nw_release(context);\n        };\n\n        if (content != NULL) {\n            schedule_next_receive = Block_copy(schedule_next_receive);\n            dispatch_write(STDOUT_FILENO, content, dispatch_get_main_queue(), ^(__unused dispatch_data_t _Nullable data, int stdout_error) {\n                if (stdout_error != 0) {\n                    … error logging …\n                } else {\n                    schedule_next_receive();\n                }\n                Block_release(schedule_next_receive);\n            });\n        } else {\n            \/\/ No content, so directly schedule the next receive\n            schedule_next_receive();\n        }\n    });\n}",
      "language" : "objc"
    },
    {
      "code" : "nw_retain(context);\ndispatch_block_t schedule_next_receive = ^{\n    if (is_complete &&\n        (context == NULL || nw_content_context_get_is_final(context))) {\n        exit(0);\n    }\n    if (receive_error == NULL) {\n        receive_loop(connection);\n    } else {\n        … error logging …\n    }\n    nw_release(context);\n};",
      "language" : "objc"
    },
    {
      "code" : "void\nsend_loop(nw_connection_t connection)\n{\n    dispatch_read(STDIN_FILENO, 8192, dispatch_get_main_queue(), ^(dispatch_data_t _Nonnull read_data, int stdin_error) {\n        if (stdin_error != 0) {\n            … error logging …\n        } else if (read_data == NULL) {\n            … handle end of file …\n        } else {\n            nw_connection_send(connection, read_data, NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT, true, ^(nw_error_t  _Nullable error) {\n                if (error != NULL) {\n                    … error logging …\n                } else {\n                    send_loop(connection);\n                }\n            });\n        }\n    });\n}",
      "language" : "objc"
    }
  ],
  "contentHash" : "df3e872b95dff7e1d6479b8fb437674c0b44dbcc55ed0fe0eda0692e6c05a962",
  "crawledAt" : "2025-12-02T15:33:30Z",
  "id" : "D737F35E-E978-4D31-A478-A182BB5AEAF9",
  "kind" : "unknown",
  "language" : "occ",
  "module" : "Network",
  "overview" : "## Overview\n\nThe `netcat` tool (abbreviated `nc` on macOS) is a UNIX tool that lets you:\n\nThis sample code shows how you can build `nwcat`, which provides this functionality and also adds TLS and Bonjour support.\n\nThe `nwcat` tool supports two modes: one that makes an outbound connection and one that listens for an inbound connection.  You select the mode using command-line arguments.  To make an outbound connection to port 80 on `example.com`, you run:\n\nTo listen for an inbound connection, you supply the `-l` option and the port number to listen on:\n\nBy default, `nwcat` uses TCP. The `-u` argument switches to UDP, and the `-t` argument adds TLS to TCP connections and DTLS to UDP connections. The `-b` argument enables use of Bonjour service names rather than host names.\n\n### Create an Outbound Connection\n\nIn the Network framework, a bidirectional flow of data is represented as a connection object ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_connection_t]).  If you’re using TCP, there’s a direct mapping between the connection object and the underlying TCP connection. If you’re using UDP, a connection object represents a bidirectional flow of datagrams between a local port and a port on a specific remote peer.\n\nTo create an outbound connection object, you must supply a parameters object ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_parameters_t]) and an endpoint ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_endpoint_type_t]).\n\n**Create a Parameters Object.** A parameters object, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_parameters_t], holds all the parameters necessary to configure a network connection.  These include:\n\nTo create a parameters object, call either the [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_tcp(_:_:)] or the [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_udp(_:_:)] convenience function, depending on whether you want to use TCP or UDP.\n\nThese functions take two arguments:\n\n**Create an Endpoint.** An endpoint, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_endpoint_type_t], holds a network host or service name.  For an outbound connection, the endpoint determines the remote host to which you want to connect.  In most cases this consists of a host name and a port number, but there are other options.  For example, you can also create endpoints that target a Bonjour service.\n\nIn the `nwcat` tool, the user supplies a host name and a port number via command-line arguments, and you will need to create an endpoint from those two strings.  You do this by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_endpoint_create_host(_:_:)].\n\nThese strings support both symbolic and numeric values:\n\n**Create the Connection Object.**  Once you have your parameters object and endpoint, you can create a connection object by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_create(_:_:)].\n\n**Start the Connection.** To start the connection establishment process:\n\nYou must set your queue before starting the connection, and you cannot change the queue after that.\n\nA state changed handler is a block that’s called by the connection object whenever the connection state changes.  For a simple application, like `nwcat`, you can use a very simple state changed handler.\n\nMake sure you handle the [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_connection_state_cancelled] state.  Once the connection is no longer needed, you have to release the reference you took when you started the connection.\n\n### Listen for an Inbound Connection\n\nA listener object, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_listener_t], listens for inbound connections and creates a new connection object for each one.  To create a listener object you must supply a parameters object ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_parameters_t]) to indicate what protocols to use and information about the local endpoint on which you want to listen.\n\n**Create a Parameters Object.** Creating a parameters object for a listener object is very similar to creating a parameters object for an outbound connection. Use the [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_tcp(_:_:)] and [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_udp(_:_:)] convenience functions to define which protocols you want your listener to use. These parameters will be applied to any inbound connections your listener accepts. For example, if you enable TLS in the parameters object, all inbound connections will negotiate TLS once you call [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_start(_:)].\n\n**Set a Local Endpoint.** A listener object must know what local endpoint to listen on, that is, the endpoint to which clients must connect.  The local endpoint can include a port number and an interface address, both of which are optional.  If you don’t specify a port number, the system chooses a port for you.  If you don’t specify an interface address, the system listens on all interfaces and addresses.\n\nMost applications don’t need to listen on a specific interface address and thus can create a listener using the [doc:\/\/com.apple.network\/documentation\/Network\/nw_listener_create_with_port(_:_:)] convenience function.  However, `nwcat` allows the user to specify an interface address (via a command line argument) and thus you have to use a slightly more complex technique.  If the user has specified an interface address or a port, you can call [doc:\/\/com.apple.network\/documentation\/Network\/nw_endpoint_create_host(_:_:)] to create an endpoint representing the address to listen on, and then call [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_set_local_endpoint(_:_:)] to apply that to your parameters object.\n\nWhen calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_endpoint_create_host(_:_:)] to create an endpoint for the local address, keep the following in mind:\n\n**Create the Listener Object.** Once you’ve set up your parameters object, you can create a listener object by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_listener_create(_:)].\n\n**Start the Listener.** Starting a listener object is much like starting a connection object, with one significant difference: in addition to setting a state changed handler, you must also set a new connection handler, which is called whenever the listener object receives a new inbound connection.\n\n**Accept or Reject Inbound Connections.** Your new connection handler is responsible for either starting the network connection or rejecting it.  The `nwcat` command can only handle one connection at a time, so if there’s already a network connection in place, call [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_cancel(_:)] to reject the new connection.  If not, retain the network connection and then run the connection using the same `start_connection` function you used in the outbound case.\n\n### Transfer Data\n\nOnce you have created and started a connection, either outbound or inbound, you’ll need code to transfer data on that connection.  Each connection has two directions:\n\nBoth directions are asynchronous.  When receiving data from the network, you supply a completion handler that’s called when data is available.  Similarly, when writing data to the network, you supply a completion handler that’s called when the data has been accepted for transmission.\n\nWhen working with asynchronous networking, you need to consider flow control.  For example, if you receive data from the network faster than you can write it to `stdout`, you’ll waste a lot of memory buffering that data.  You’ll have similar problems if you read data from `stdin` faster than you can send it over the network.  You can solve this problem by using asynchronous routines for reading from `stdin` and writing to `stdout`.  The basic strategy is this:\n\nYou use a similar strategy for both inbound and outbound data, but there are some subtle differences, discussed in the sections that follow.\n\n**Receive Data.** You can receive data with code like this.\n\nThe function starts by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_receive(_:_:_:_:)], which is an asynchronous function that receives data from the connection object.  The function has two parameters that control the minimum and maximum amount of data to be received.  The exact amount of data received isn’t relevant here, so pass `1` and `UINT32_MAX` respectively.\n\nWhen the receive is complete, [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_receive(_:_:_:_:)] calls the completion handler that you pass it.  The completion handler has four parameters:\n\nA content context, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_content_context_t], holds extra information about the data received.  A typical application that uses only TCP can often ignore this value entirely.  However, a `netcat` implementation must work equally well with TCP and UDP, and you need the content context to do that.\n\nThe completion handler you pass to [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_receive(_:_:_:_:)] does the following:\n\nIn `schedule_next_receive` you must handle three cases:\n\nTo check for the end of the data stream:\n\n**Send Data.** Your send code should have the same basic structure as your receive code.\n\nThere are, however, some subtle differences:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Network\/implementing-netcat-with-network-framework\ncrawled: 2025-12-02T15:33:30Z\n---\n\n# Implementing netcat with Network Framework\n\n**Sample Code**\n\nBuild a simple `netcat` tool that establishes network connections and transfers data.\n\n## Overview\n\nThe `netcat` tool (abbreviated `nc` on macOS) is a UNIX tool that lets you:\n\n- Establish outbound TCP and UDP connections.\n- Listen for inbound TCP and UDP connections.\n- Transfer data between a network connection and `stdin` and `stdout`.\n\nThis sample code shows how you can build `nwcat`, which provides this functionality and also adds TLS and Bonjour support.\n\nThe `nwcat` tool supports two modes: one that makes an outbound connection and one that listens for an inbound connection.  You select the mode using command-line arguments.  To make an outbound connection to port 80 on `example.com`, you run:\n\n```shell\n$ nwcat example.com 80\n```\n\nTo listen for an inbound connection, you supply the `-l` option and the port number to listen on:\n\n```shell\n$ nwcat -l 12345\n```\n\nBy default, `nwcat` uses TCP. The `-u` argument switches to UDP, and the `-t` argument adds TLS to TCP connections and DTLS to UDP connections. The `-b` argument enables use of Bonjour service names rather than host names.\n\n### Create an Outbound Connection\n\nIn the Network framework, a bidirectional flow of data is represented as a connection object ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_connection_t]).  If you’re using TCP, there’s a direct mapping between the connection object and the underlying TCP connection. If you’re using UDP, a connection object represents a bidirectional flow of datagrams between a local port and a port on a specific remote peer.\n\nTo create an outbound connection object, you must supply a parameters object ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_parameters_t]) and an endpoint ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_endpoint_type_t]).\n\n**Create a Parameters Object.** A parameters object, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_parameters_t], holds all the parameters necessary to configure a network connection.  These include:\n\n- The protocols involved, like TCP or UDP, or whether to enable TLS.\n- Any options for those protocols.\n- Any constraints on the connection, like whether or not to use the cellular interface.\n\nTo create a parameters object, call either the [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_tcp(_:_:)] or the [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_udp(_:_:)] convenience function, depending on whether you want to use TCP or UDP.\n\n```objc\nnw_parameters_configure_protocol_block_t configure_tls = NW_PARAMETERS_DISABLE_PROTOCOL;\nif (g_use_udp) {\n    parameters = nw_parameters_create_secure_udp(\n        configure_tls,\n        NW_PARAMETERS_DEFAULT_CONFIGURATION\n    );\n} else {\n    parameters = nw_parameters_create_secure_tcp(\n        configure_tls,\n        NW_PARAMETERS_DEFAULT_CONFIGURATION\n    );\n}\n```\n\nThese functions take two arguments:\n\n- The first configures the security protocol for the connection.  Pass `NW_PARAMETERS_DISABLE_PROTOCOL` to use no security.\n- The second configures the transport protocol for the connection.  Pass `NW_PARAMETERS_DEFAULT_CONFIGURATION` to get a default configuration.\n\n\n\n**Create an Endpoint.** An endpoint, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_endpoint_type_t], holds a network host or service name.  For an outbound connection, the endpoint determines the remote host to which you want to connect.  In most cases this consists of a host name and a port number, but there are other options.  For example, you can also create endpoints that target a Bonjour service.\n\nIn the `nwcat` tool, the user supplies a host name and a port number via command-line arguments, and you will need to create an endpoint from those two strings.  You do this by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_endpoint_create_host(_:_:)].\n\n```objc\nnw_endpoint_t endpoint = nw_endpoint_create_host(name, port);\n```\n\nThese strings support both symbolic and numeric values:\n\n- The host name can be a DNS name, like `example.com`, or the string representation of an IP address, like `\"203.0.113.7\"` for IPv4 or `\"2606:2800:220:1:248:1893:25c8:1946\"` for IPv6.\n- The port can be a numeric value, like `\"80\"`, or a service name, like `\"https\"`.\n\n\n\n**Create the Connection Object.**  Once you have your parameters object and endpoint, you can create a connection object by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_create(_:_:)].\n\n```objc\nnw_connection_t connection = nw_connection_create(endpoint, parameters);\n```\n\n**Start the Connection.** To start the connection establishment process:\n\n1. Call [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_set_queue(_:_:)] to set the [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/dispatch_queue_t] on which all callbacks will be scheduled.  For a simple application like `nwcat`, you can use the main queue for your callbacks.  A more complex application would typically use a custom serial queue instead.\n2. Install any update handler blocks. The most important of these is the state changed handler, discussed below.\n3. Start the connection by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_start(_:)].\n\nYou must set your queue before starting the connection, and you cannot change the queue after that.\n\n```objc\nvoid\nstart_connection(nw_connection_t connection)\n{\n    nw_connection_set_queue(connection, dispatch_get_main_queue());\n    nw_retain(connection);\n    nw_connection_set_state_changed_handler(connection, ^(nw_connection_state_t state, nw_error_t error) {\n        … your state changed handler …\n    });\n    nw_connection_start(connection);\n}\n```\n\n\n\nA state changed handler is a block that’s called by the connection object whenever the connection state changes.  For a simple application, like `nwcat`, you can use a very simple state changed handler.\n\n```objc\nif (state == nw_connection_state_waiting) {\n    … tell the user that a connection couldn’t be opened but will retry when conditions are favourable …\n} else if (state == nw_connection_state_failed) {\n    … tell the user that the connection has failed irrecoverably …\n} else if (state == nw_connection_state_ready) {\n    … tell the user that you are connected …\n} else if (state == nw_connection_state_cancelled) {\n    nw_release(connection);\n}\n```\n\nMake sure you handle the [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_connection_state_cancelled] state.  Once the connection is no longer needed, you have to release the reference you took when you started the connection.\n\n### Listen for an Inbound Connection\n\nA listener object, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_listener_t], listens for inbound connections and creates a new connection object for each one.  To create a listener object you must supply a parameters object ([doc:\/\/com.apple.documentation\/documentation\/Network\/nw_parameters_t]) to indicate what protocols to use and information about the local endpoint on which you want to listen.\n\n**Create a Parameters Object.** Creating a parameters object for a listener object is very similar to creating a parameters object for an outbound connection. Use the [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_tcp(_:_:)] and [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_create_secure_udp(_:_:)] convenience functions to define which protocols you want your listener to use. These parameters will be applied to any inbound connections your listener accepts. For example, if you enable TLS in the parameters object, all inbound connections will negotiate TLS once you call [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_start(_:)].\n\n**Set a Local Endpoint.** A listener object must know what local endpoint to listen on, that is, the endpoint to which clients must connect.  The local endpoint can include a port number and an interface address, both of which are optional.  If you don’t specify a port number, the system chooses a port for you.  If you don’t specify an interface address, the system listens on all interfaces and addresses.\n\nMost applications don’t need to listen on a specific interface address and thus can create a listener using the [doc:\/\/com.apple.network\/documentation\/Network\/nw_listener_create_with_port(_:_:)] convenience function.  However, `nwcat` allows the user to specify an interface address (via a command line argument) and thus you have to use a slightly more complex technique.  If the user has specified an interface address or a port, you can call [doc:\/\/com.apple.network\/documentation\/Network\/nw_endpoint_create_host(_:_:)] to create an endpoint representing the address to listen on, and then call [doc:\/\/com.apple.network\/documentation\/Network\/nw_parameters_set_local_endpoint(_:_:)] to apply that to your parameters object.\n\n```objc\nif (address || port) {\n    nw_endpoint_t local_endpoint = nw_endpoint_create_host(address ? address : \"::\", port ? port : \"0\");\n    nw_parameters_set_local_endpoint(parameters, local_endpoint);\n    nw_release(local_endpoint);\n}\n```\n\nWhen calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_endpoint_create_host(_:_:)] to create an endpoint for the local address, keep the following in mind:\n\n- The `port` parameter can either be a numeric string, like `\"443\"`, or a service name, like `\"https\"`.\n- If you pass `\"0\"` to the `port` parameter the system will choose a port on your behalf.\n\n**Create the Listener Object.** Once you’ve set up your parameters object, you can create a listener object by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_listener_create(_:)].\n\n```objc\nnw_listener_t listener = nw_listener_create(parameters);\n```\n\n**Start the Listener.** Starting a listener object is much like starting a connection object, with one significant difference: in addition to setting a state changed handler, you must also set a new connection handler, which is called whenever the listener object receives a new inbound connection.\n\n```objc\nnw_listener_set_queue(listener, dispatch_get_main_queue());\nnw_retain(listener);\nnw_listener_set_state_changed_handler(listener, ^(nw_listener_state_t state, nw_error_t error) {\n    … your state changed handler …\n});\nnw_listener_set_new_connection_handler(listener, ^(nw_connection_t connection) {\n    … your new connection handler …\n});\nnw_listener_start(listener);\n```\n\n**Accept or Reject Inbound Connections.** Your new connection handler is responsible for either starting the network connection or rejecting it.  The `nwcat` command can only handle one connection at a time, so if there’s already a network connection in place, call [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_cancel(_:)] to reject the new connection.  If not, retain the network connection and then run the connection using the same `start_connection` function you used in the outbound case.\n\n```objc\nif (g_inbound_connection != NULL) {\n    nw_connection_cancel(connection);\n} else {\n    g_inbound_connection = connection;\n    nw_retain(g_inbound_connection);\n\n    start_connection(g_inbound_connection);\n}\n```\n\n### Transfer Data\n\nOnce you have created and started a connection, either outbound or inbound, you’ll need code to transfer data on that connection.  Each connection has two directions:\n\n- Inbound data is received from the network connection and written to `stdout`.\n- Outbound data is read from `stdin` and sent to the network connection.\n\nBoth directions are asynchronous.  When receiving data from the network, you supply a completion handler that’s called when data is available.  Similarly, when writing data to the network, you supply a completion handler that’s called when the data has been accepted for transmission.\n\nWhen working with asynchronous networking, you need to consider flow control.  For example, if you receive data from the network faster than you can write it to `stdout`, you’ll waste a lot of memory buffering that data.  You’ll have similar problems if you read data from `stdin` faster than you can send it over the network.  You can solve this problem by using asynchronous routines for reading from `stdin` and writing to `stdout`.  The basic strategy is this:\n\n1. Start an asynchronous read.\n2. When the read completes, start an asynchronous write.\n3. When the write completes, set up the next asynchronous read, which starts again at step 1.\n\nYou use a similar strategy for both inbound and outbound data, but there are some subtle differences, discussed in the sections that follow.\n\n**Receive Data.** You can receive data with code like this.\n\n```objc\nvoid\nreceive_loop(nw_connection_t connection)\n{\n    nw_connection_receive(connection, 1, UINT32_MAX, ^(dispatch_data_t content, nw_content_context_t context, bool is_complete, nw_error_t receive_error) {\n\n        nw_retain(context);\n        dispatch_block_t schedule_next_receive = ^{\n            … discussed below …\n            nw_release(context);\n        };\n\n        if (content != NULL) {\n            schedule_next_receive = Block_copy(schedule_next_receive);\n            dispatch_write(STDOUT_FILENO, content, dispatch_get_main_queue(), ^(__unused dispatch_data_t _Nullable data, int stdout_error) {\n                if (stdout_error != 0) {\n                    … error logging …\n                } else {\n                    schedule_next_receive();\n                }\n                Block_release(schedule_next_receive);\n            });\n        } else {\n            \/\/ No content, so directly schedule the next receive\n            schedule_next_receive();\n        }\n    });\n}\n```\n\n\n\nThe function starts by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_receive(_:_:_:_:)], which is an asynchronous function that receives data from the connection object.  The function has two parameters that control the minimum and maximum amount of data to be received.  The exact amount of data received isn’t relevant here, so pass `1` and `UINT32_MAX` respectively.\n\n\n\nWhen the receive is complete, [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_receive(_:_:_:_:)] calls the completion handler that you pass it.  The completion handler has four parameters:\n\n- A [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/dispatch_data_t] which, if not `NULL`, contains the data received.\n- A content context, discussed below.\n- An `is_complete` parameter that is true if the data received is the last part of a logical unit of data.\n- A `receive_error` parameter, which is not `NULL` if an error occurred during the receive process.\n\nA content context, of type [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_content_context_t], holds extra information about the data received.  A typical application that uses only TCP can often ignore this value entirely.  However, a `netcat` implementation must work equally well with TCP and UDP, and you need the content context to do that.\n\nThe completion handler you pass to [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_receive(_:_:_:_:)] does the following:\n\n1. It processes any data that was received by starting an asynchronous write to `stdout`.\n2. When that asynchronous write completes—or immediately if there was no content—it calls `schedule_next_receive` to continue the receive.\n\nIn `schedule_next_receive` you must handle three cases:\n\n- If you just received the end of the data stream, call `exit` to terminate the program.  This is how the program stops when the remote peer closes the network connection.\n- If the receive failed with an error, handle that error.\n- Otherwise, start the next asynchronous receive by calling `receive_loop`.\n\n```objc\nnw_retain(context);\ndispatch_block_t schedule_next_receive = ^{\n    if (is_complete &&\n        (context == NULL || nw_content_context_get_is_final(context))) {\n        exit(0);\n    }\n    if (receive_error == NULL) {\n        receive_loop(connection);\n    } else {\n        … error logging …\n    }\n    nw_release(context);\n};\n```\n\n\n\nTo check for the end of the data stream:\n\n- Generally, you can use the technique shown by `schedule_next_receive`, that is, check both the `is_complete` flag and that the context is marked as final or is not present.  This technique works correctly for both TCP and UDP, and thus is necessary for a `netcat` implementation.\n- If you only handle TCP, you can simply test the `is_complete` flag.\n\n**Send Data.** Your send code should have the same basic structure as your receive code.\n\n```objc\nvoid\nsend_loop(nw_connection_t connection)\n{\n    dispatch_read(STDIN_FILENO, 8192, dispatch_get_main_queue(), ^(dispatch_data_t _Nonnull read_data, int stdin_error) {\n        if (stdin_error != 0) {\n            … error logging …\n        } else if (read_data == NULL) {\n            … handle end of file …\n        } else {\n            nw_connection_send(connection, read_data, NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT, true, ^(nw_error_t  _Nullable error) {\n                if (error != NULL) {\n                    … error logging …\n                } else {\n                    send_loop(connection);\n                }\n            });\n        }\n    });\n}\n```\n\nThere are, however, some subtle differences:\n\n- If, as in this case, you support UDP, you must limit the amount of data you read from `stdin`.  If you read more than 64 Kibibytes (KiB), the resulting read won’t fit in a single UDP datagram.  This code use a 8 KiB limit.\n- You must tell the network connection to send the data as a single message by calling [doc:\/\/com.apple.network\/documentation\/Network\/nw_connection_send(_:_:_:_:_:)] with `NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT` and passing true to the `is_complete` parameter.  This approach is appropriate for both TCP and UDP connections.  For TCP connections, message boundaries don’t affect how the protocol sends data, but the boundaries are required for sending UDP datagrams.\n- Finally, when you receive an end of file from `stdin`, you must close the send side of your connection.  The code for this is shown below.\n\n```objc\nnw_connection_send(connection, NULL, NW_CONNECTION_FINAL_MESSAGE_CONTEXT, true, ^(nw_error_t  _Nullable error) {\n    if (error != NULL) {\n        … handle error …\n    }\n    \/\/ Stop reading from stdin, so don't schedule another send_loop\n});\n```\n\nThis passes a special context, `NW_CONNECTION_FINAL_MESSAGE_CONTEXT`, and passes true to the `is_complete`.  Together, these actions indicate that no more data will be sent, allowing the network connection to close the sending side of the connection.\n\n## Connections and Listeners\n\n- **nw_connection_t**: A bidirectional data connection between a local endpoint and a remote endpoint.\n- **nw_listener_t**: An object you use to listen for incoming network connections.\n- **nw_browser_t**: An object you use to browse for available network services.\n- **nw_connection_group_t**: An object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.\n- **nw_ethernet_channel_t**: An object you use to send and receive custom Ethernet frames.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A bidirectional data connection between a local endpoint and a remote endpoint.",
          "name" : "nw_connection_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/Network\/nw_connection_t"
        },
        {
          "description" : "An object you use to listen for incoming network connections.",
          "name" : "nw_listener_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/Network\/nw_listener_t"
        },
        {
          "description" : "An object you use to browse for available network services.",
          "name" : "nw_browser_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/Network\/nw_browser_t"
        },
        {
          "description" : "An object you use to communicate with a group of endpoints, such as an IP multicast group on a local network.",
          "name" : "nw_connection_group_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/Network\/nw_connection_group_t"
        },
        {
          "description" : "An object you use to send and receive custom Ethernet frames.",
          "name" : "nw_ethernet_channel_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/Network\/nw_ethernet_channel_t"
        }
      ],
      "title" : "Connections and Listeners"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing netcat with Network Framework",
  "url" : "https:\/\/developer.apple.com\/documentation\/Network\/implementing-netcat-with-network-framework"
}