{
  "abstract" : "Receive controller input using either polling or callbacks.",
  "codeExamples" : [
    {
      "code" : "let controller: GCController\nlet input: GCControllerLiveInput \n\n\/\/ Get the input profile object.\ninput = controller.input",
      "language" : "swift"
    },
    {
      "code" : "let racingWheel: GCRacingWheel\nlet input: GCRacingWheelInput \n\n\/\/ Get the racing wheel input profile object.\ninput = racingWheel.wheelInput",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Get the A button element.\nlet aButton = input.buttons[.a]",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Get the left thumbstick element.\nlet leftThumbstick = input.dpads[.leftThumbstick]",
      "language" : "swift"
    },
    {
      "code" : "let input: GCControllerLiveInput\n\n\/\/ Read the current A button element pressed state.\nlet aButtonPressed = input.buttons[.a].pressedInput.isPressed",
      "language" : "swift"
    },
    {
      "code" : "let input: GCControllerLiveInput\nlet snapshot: GCControllerInputState\n\n\/\/ Capture the current controller input state.\nsnapshot = input.capture()\n\n\/\/ Read the current A and B button pressed states from the snapshot.\nlet aButtonPressed = snapshot.buttons[.a].pressedInput.isPressed\nlet bButtonPressed = snapshot.buttons[.b].pressedInput.isPressed",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Set the queue depth.\ninput.inputStateQueueDepth = 20",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Set the input state available handler.\ninput.inputStateAvailableHandler = { (input) in\n    \/\/ Either handle the queued input states,\n    \/\/ or wake up your game loop to handle the input\n    \/\/ states later.\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Set the input handler.\ninput.inputStateAvailableHandler = { (input) in\n    while let nextInputState = input.nextInputState() {\n        \/\/ Handle the input for specific elements.\n        if let buttonA = nextInputState.buttons[.a] {\n            let buttonAPressed = buttonA.pressedInput.isPressed;\n            if (buttonAPressed) {\n                \/\/ Handle when the user presses the button.\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Handle all the input since the last game loop iteration.\nwhile let nextInputState = input.nextInputState() {\n    \/\/ Get all the elements with changed inputs.\n    if let changedElements = nextInputState.changedElements() {\n        for changedElement in changedElements {\n            \/\/ Handle the change to the element.\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Register a callback for the press\/release of the A button.\nif let aButton = input.buttons[.a] {\n    aButton.pressedInput.pressedDidChangeHandler = { (_, _, pressed) in\n        if pressed {\n            \/\/ Handle when the user presses the button.\n        } else {\n            \/\/ Handle when the user releases the button.\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Register a callback for any element change.\ninput.elementValueDidChangeHandler = { (input, element) in\n    if element === input.buttons[.a] {\n        \/\/ Handle A button input.\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "438e133239b64debdf59e2e7385673a2560779247c90d527147bad75aafd645c",
  "crawledAt" : "2025-12-01T10:14:40Z",
  "id" : "D0D6F9F3-BE63-4D2E-9BD2-4460C282F550",
  "kind" : "article",
  "module" : "Game Controller",
  "overview" : "## Overview\n\nThe Game Controller framework provides your game with low-level and fast access to input from connected gamepads, arcade sticks, and racing wheels. Not all games receive and process input the same way. The Game Controller framework input APIs support several ways for your game to receive controller input:\n\n### Get the input profile\n\nYou get game controller input from the device’s input profile. The [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput] protocol declares the common properties for the input profile. The [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] classes provide the concrete implementations for gamepads and arcade sticks, and racing wheels, respectively.\n\nFor gamepads and arcade sticks, first get the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] object from the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCController] object using the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCController\/input] property.\n\nFor racing wheels, first get the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] object from the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheel] object using the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheel\/wheelInput] property.\n\n### Configure the input dispatch queue\n\nThe Game Controller framework processes input events, and invokes any configured callbacks, on the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCController] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheel] [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevice\/handlerQueue] property of the device. The [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevice\/handlerQueue] property is the main queue by default. To configure a dedicated queue for input processing, set the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/queue] property of the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] object.\n\n### Access input elements\n\nGame controllers organize their input states by elements. These elements correspond to the individual buttons, directional pads, thumbsticks, and other kinds of controls on the gamepad, arcade stick, or racing wheel. Game controllers identify elements by their semantic name, and group them into one or more collections, such as the `elements`, `buttons`, `dpads`, `axes`, and `switches` properties.\n\nTo get objects representing specific elements of a controller, use the subscript notation with the collection properties from an object conforming to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputState] protocol. This includes the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects.\n\nFor example, to get the A button of a controller, use `.a` with the `buttons` property, as in the following example:\n\nTo get the left thumbstick of a directional pad, use `.leftThumbstick` with the `dpads` property.\n\n### Get the current input state\n\nBoth the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects track the last received input state from the game controller. If you poll for input, but just need the current input values, get the elements from the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects and read their input values.\n\nReading a single input value is an atomic operation. However, the current input state can change between reading distinct input values. To avoid these inconsistencies, use the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput]. [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/capture()] method to obtain a snapshot of the input state at the current moment. Then read the input values from the snapshot. Snapshots carry very little performance overhead as long as your game doesn’t hold onto the snapshot for long periods of time.\n\n### Poll for input changes\n\nSometimes an input device generates input more frequently than your game can process it. For example, a racing wheel with a high refresh rate generates hundreds of inputs per second. If you read the current input values every frame (at 60 frames per second), you miss input events. In this case, configure the Game Controller framework to maintain a queue of input states that you retrieve and process later.\n\nFirst, change the input queue depth to a value that’s appropriate for the frequency at which your game polls for input. The input queue depth specifies the maximum number of input states that the Game Controller framework buffers before it purges older input states from the queue. The default value of `1` indicates no buffering.\n\nIn your game loop, handle all the inputs that occur after the last iteration of your game loop using the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method. Call the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method until the queue is empty.\n\nOptionally, assign a callback to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/inputStateAvailableHandler] property of the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects. The Game Controller framework calls this block when a new input state becomes available, and not again until your game processes all input states in the queue.\n\nEach call to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method returns a snapshot of the oldest input state in the queue. Use the snapshot to access individual elements and read their input values.\n\nTo determine whether an element’s input changed compared to the previous input state, use the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/change(for:)] method. To get a collection of all the elements with changed inputs compared to the previous input state, use the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/changedElements()-2zzwm] method.\n\nHandle when the queue overflows. If the queue is empty, the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method returns `nil`. If the queue overflows, the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/changedElements()-2zzwm] method returns `nil` and the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/change(for:)] method returns [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputElementChange\/unknownChange].\n\n### Receive callbacks for input changes\n\nTo receive callbacks from specific elements when their inputs change, assign a callback to one or more of the element’s inputs. Then implement the handlers to take the appropriate action for your game.\n\nFor example, a button element has a pressed input representing its pressed state. Assign a block to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCPressedStateInput\/pressedDidChangeHandler] property of the button’s [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCButtonElement\/pressedInput] property to take an action when the user presses it.\n\nTo receive a callback when the inputs of any element change, assign a callback to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/elementValueDidChangeHandler] property of the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects. When input occurs, the Game Controller framework calls the block once for each element that changes. Your code reads the latest values from the element that Game Controller passes to the handler.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/gamecontroller\/handling-input-events\ncrawled: 2025-12-01T10:14:40Z\n---\n\n# Handling input events\n\n**Article**\n\nReceive controller input using either polling or callbacks.\n\n## Overview\n\nThe Game Controller framework provides your game with low-level and fast access to input from connected gamepads, arcade sticks, and racing wheels. Not all games receive and process input the same way. The Game Controller framework input APIs support several ways for your game to receive controller input:\n\n- Use polling when input handling occurs at a fixed interval as part of your game’s loop. You request the latest input state from the Game Controller framework each time you handle input. This can occur once per frame, or at a lower frequency than the frame rate.\n- Use callbacks when the input handling in your game is event-driven. You provide one or more blocks that the Game Controller framework invokes when any or certain elements’ input values change.\n\n### Get the input profile\n\nYou get game controller input from the device’s input profile. The [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput] protocol declares the common properties for the input profile. The [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] classes provide the concrete implementations for gamepads and arcade sticks, and racing wheels, respectively.\n\nFor gamepads and arcade sticks, first get the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] object from the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCController] object using the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCController\/input] property.\n\n```swift\nlet controller: GCController\nlet input: GCControllerLiveInput \n\n\/\/ Get the input profile object.\ninput = controller.input\n```\n\nFor racing wheels, first get the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] object from the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheel] object using the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheel\/wheelInput] property.\n\n```swift\nlet racingWheel: GCRacingWheel\nlet input: GCRacingWheelInput \n\n\/\/ Get the racing wheel input profile object.\ninput = racingWheel.wheelInput\n```\n\n### Configure the input dispatch queue\n\nThe Game Controller framework processes input events, and invokes any configured callbacks, on the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCController] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheel] [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevice\/handlerQueue] property of the device. The [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevice\/handlerQueue] property is the main queue by default. To configure a dedicated queue for input processing, set the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/queue] property of the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] object.\n\n### Access input elements\n\nGame controllers organize their input states by elements. These elements correspond to the individual buttons, directional pads, thumbsticks, and other kinds of controls on the gamepad, arcade stick, or racing wheel. Game controllers identify elements by their semantic name, and group them into one or more collections, such as the `elements`, `buttons`, `dpads`, `axes`, and `switches` properties.\n\nTo get objects representing specific elements of a controller, use the subscript notation with the collection properties from an object conforming to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputState] protocol. This includes the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects.\n\nFor example, to get the A button of a controller, use `.a` with the `buttons` property, as in the following example:\n\n```swift\n\/\/ Get the A button element.\nlet aButton = input.buttons[.a]\n```\n\nTo get the left thumbstick of a directional pad, use `.leftThumbstick` with the `dpads` property.\n\n```swift\n\/\/ Get the left thumbstick element.\nlet leftThumbstick = input.dpads[.leftThumbstick]\n```\n\n### Get the current input state\n\nBoth the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects track the last received input state from the game controller. If you poll for input, but just need the current input values, get the elements from the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] and [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects and read their input values.\n\n```swift\nlet input: GCControllerLiveInput\n\n\/\/ Read the current A button element pressed state.\nlet aButtonPressed = input.buttons[.a].pressedInput.isPressed\n```\n\nReading a single input value is an atomic operation. However, the current input state can change between reading distinct input values. To avoid these inconsistencies, use the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput]. [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/capture()] method to obtain a snapshot of the input state at the current moment. Then read the input values from the snapshot. Snapshots carry very little performance overhead as long as your game doesn’t hold onto the snapshot for long periods of time.\n\n```swift\nlet input: GCControllerLiveInput\nlet snapshot: GCControllerInputState\n\n\/\/ Capture the current controller input state.\nsnapshot = input.capture()\n\n\/\/ Read the current A and B button pressed states from the snapshot.\nlet aButtonPressed = snapshot.buttons[.a].pressedInput.isPressed\nlet bButtonPressed = snapshot.buttons[.b].pressedInput.isPressed\n```\n\n### Poll for input changes\n\nSometimes an input device generates input more frequently than your game can process it. For example, a racing wheel with a high refresh rate generates hundreds of inputs per second. If you read the current input values every frame (at 60 frames per second), you miss input events. In this case, configure the Game Controller framework to maintain a queue of input states that you retrieve and process later.\n\nFirst, change the input queue depth to a value that’s appropriate for the frequency at which your game polls for input. The input queue depth specifies the maximum number of input states that the Game Controller framework buffers before it purges older input states from the queue. The default value of `1` indicates no buffering.\n\n```swift\n\/\/ Set the queue depth.\ninput.inputStateQueueDepth = 20\n```\n\nIn your game loop, handle all the inputs that occur after the last iteration of your game loop using the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method. Call the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method until the queue is empty.\n\nOptionally, assign a callback to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/inputStateAvailableHandler] property of the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects. The Game Controller framework calls this block when a new input state becomes available, and not again until your game processes all input states in the queue.\n\n```swift\n\/\/ Set the input state available handler.\ninput.inputStateAvailableHandler = { (input) in\n    \/\/ Either handle the queued input states,\n    \/\/ or wake up your game loop to handle the input\n    \/\/ states later.\n}\n```\n\nEach call to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method returns a snapshot of the oldest input state in the queue. Use the snapshot to access individual elements and read their input values.\n\n```swift\n\/\/ Set the input handler.\ninput.inputStateAvailableHandler = { (input) in\n    while let nextInputState = input.nextInputState() {\n        \/\/ Handle the input for specific elements.\n        if let buttonA = nextInputState.buttons[.a] {\n            let buttonAPressed = buttonA.pressedInput.isPressed;\n            if (buttonAPressed) {\n                \/\/ Handle when the user presses the button.\n            }\n        }\n    }\n}\n```\n\nTo determine whether an element’s input changed compared to the previous input state, use the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/change(for:)] method. To get a collection of all the elements with changed inputs compared to the previous input state, use the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/changedElements()-2zzwm] method.\n\n```swift\n\/\/ Handle all the input since the last game loop iteration.\nwhile let nextInputState = input.nextInputState() {\n    \/\/ Get all the elements with changed inputs.\n    if let changedElements = nextInputState.changedElements() {\n        for changedElement in changedElements {\n            \/\/ Handle the change to the element.\n        }\n    }\n}\n```\n\nHandle when the queue overflows. If the queue is empty, the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/nextInputState()] method returns `nil`. If the queue overflows, the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/changedElements()-2zzwm] method returns `nil` and the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputStateDiff\/change(for:)] method returns [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInputElementChange\/unknownChange].\n\n### Receive callbacks for input changes\n\nTo receive callbacks from specific elements when their inputs change, assign a callback to one or more of the element’s inputs. Then implement the handlers to take the appropriate action for your game.\n\nFor example, a button element has a pressed input representing its pressed state. Assign a block to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCPressedStateInput\/pressedDidChangeHandler] property of the button’s [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCButtonElement\/pressedInput] property to take an action when the user presses it.\n\n```swift\n\/\/ Register a callback for the press\/release of the A button.\nif let aButton = input.buttons[.a] {\n    aButton.pressedInput.pressedDidChangeHandler = { (_, _, pressed) in\n        if pressed {\n            \/\/ Handle when the user presses the button.\n        } else {\n            \/\/ Handle when the user releases the button.\n        }\n    }\n}\n```\n\nTo receive a callback when the inputs of any element change, assign a callback to the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCDevicePhysicalInput\/elementValueDidChangeHandler] property of the [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCControllerLiveInput] or [doc:\/\/com.apple.gamecontroller\/documentation\/GameController\/GCRacingWheelInput] objects. When input occurs, the Game Controller framework calls the block once for each element that changes. Your code reads the latest values from the element that Game Controller passes to the handler.\n\n```swift\n\/\/ Register a callback for any element change.\ninput.elementValueDidChangeHandler = { (input, element) in\n    if element === input.buttons[.a] {\n        \/\/ Handle A button input.\n    }\n}\n```\n\n## Essentials\n\n- **Game Controller updates**: Learn about important changes to Game Controller.\n- **GCSupportsControllerUserInteraction**: A Boolean value indicating whether the app supports a game controller.\n- **GCSupportedGameControllers**: The types of game controller profiles that the app supports or requires.\n- **GCSupportsMultipleMicroGamepads**: A Boolean value indicating whether the physical Apple TV Remote and the Apple TV Remote app operate as separate game controllers.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn about important changes to Game Controller.",
          "name" : "Game Controller updates",
          "url" : "https:\/\/developer.apple.com\/documentation\/Updates\/GameController"
        },
        {
          "description" : "A Boolean value indicating whether the app supports a game controller.",
          "name" : "GCSupportsControllerUserInteraction",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/GCSupportsControllerUserInteraction"
        },
        {
          "description" : "The types of game controller profiles that the app supports or requires.",
          "name" : "GCSupportedGameControllers",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/GCSupportedGameControllers"
        },
        {
          "description" : "A Boolean value indicating whether the physical Apple TV Remote and the Apple TV Remote app operate as separate game controllers.",
          "name" : "GCSupportsMultipleMicroGamepads",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/GCSupportsMultipleMicroGamepads"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Handling input events",
  "url" : "https:\/\/developer.apple.com\/documentation\/gamecontroller\/handling-input-events"
}