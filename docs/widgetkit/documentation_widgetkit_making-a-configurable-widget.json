{
  "abstract" : "Give people the option to customize their widgets by adding a custom app intent to your project.",
  "codeExamples" : [
    {
      "code" : "struct SelectCharacterIntent: WidgetConfigurationIntent {\n    static var title: LocalizedStringResource = \"Select Character\"\n    static var description = IntentDescription(\"Selects the character to display information for.\")\n\n    @Parameter(title: \"Character\")\n    var character: CharacterDetail\n\n    init(character: CharacterDetail) {\n        self.character = character\n    }\n\n    init() {\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CharacterDetail: AppEntity {\n    let id: String\n    let avatar: String\n    let healthLevel: Double\n    let heroType: String\n    let isAvailable = true\n    \n    static var typeDisplayRepresentation: TypeDisplayRepresentation = \"Character\"\n    static var defaultQuery = CharacterQuery()\n            \n    var displayRepresentation: DisplayRepresentation {\n        DisplayRepresentation(title: \"\\(avatar) \\(id)\")\n    }\n\n    static let allCharacters: [CharacterDetail] = [\n        CharacterDetail(id: \"Power Panda\", avatar: \"ðŸ¼\", healthLevel: 0.14, heroType: \"Forest Dweller\"),\n        CharacterDetail(id: \"Unipony\", avatar: \"ðŸ¦„\", healthLevel: 0.67, heroType: \"Free Rangers\"),\n        CharacterDetail(id: \"Spouty\", avatar: \"ðŸ³\", healthLevel: 0.83, heroType: \"Deep Sea Goer\")\n    ]\n}",
      "language" : "swift"
    },
    {
      "code" : "@Parameter(title: \"Title\", default: \"A Default Title\")\nvar title: String",
      "language" : "swift"
    },
    {
      "code" : "struct CharacterQuery: EntityQuery {\n    func entities(for identifiers: [CharacterDetail.ID]) async throws -> [CharacterDetail] {\n        CharacterDetail.allCharacters.filter { identifiers.contains($0.id) }\n    }\n    \n    func suggestedEntities() async throws -> [CharacterDetail] {\n        CharacterDetail.allCharacters.filter { $0.isAvailable }\n    }\n    \n    func defaultResult() async -> CharacterDetail? {\n        try? await suggestedEntities().first\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CharacterDetailWidget: Widget {\n    var body: some WidgetConfiguration {\n        AppIntentConfiguration(\n            kind: kind,\n            intent: SelectCharacterIntent.self,\n            provider: CharacterDetailProvider()) { entry in\n            CharacterDetailView(entry: entry)\n        }\n        .configurationDisplayName(\"Character Details\")\n        .description(\"Displays a character's health and other details\")\n        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CharacterDetailProvider: AppIntentTimelineProvider {\n    func timeline(for configuration: SelectCharacterIntent, in context: Context) async -> Timeline<CharacterDetailEntry> {\n        \/\/ Create the timeline and return it. The .never reload policy indicates\n        \/\/ that the containing app uses WidgetCenter methods to reload the\n        \/\/ widget's timeline when the details change.\n        let entry = CharacterDetailEntry(date: Date(), detail: configuration.character)\n        let timeline = Timeline(entries: [entry], policy: .never)\n        return timeline\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ad54cfb169aa46261d108f6b342a652406a4c5d5bd71b97f1a21d2f4a2906966",
  "crawledAt" : "2025-12-02T16:44:00Z",
  "id" : "D36438F7-C681-4DDC-AF38-D17A4928E125",
  "kind" : "article",
  "language" : "swift",
  "module" : "WidgetKit",
  "overview" : "## Overview\n\nTo make the most relevant information easily accessible to people, widgets can provide customizable properties. For example, a person can select a specific stock for a stock quote widget, or enter a tracking number for a package delivery widget. Widgets define customizable properties by using app intents, the same mechanism that Siri Suggestions and Siri Shortcuts use for customizing those interactions.\n\nTo add configurable properties to your widget:\n\nIf your app already supports Siri Suggestions or Siri Shortcuts and you have a custom app intent, youâ€™ve probably done most of the work already. Otherwise, consider leveraging the work you do for your widget to add support for Siri Suggestions or Siri Shortcuts. For more information on how to get the most from app intents, see [doc:\/\/com.apple.documentation\/documentation\/AppIntents].\n\n### Add a custom app intent to your project\n\nTo show the characterâ€™s information, the person needs a way to select the character. The following code shows how to define a custom app intent to represent the choice the person makes:\n\nThe static `title` property describes the action the intent enables the person to take. Use a title case string that combines a verb with a noun. Set the static `description` to a human-readable string that describes the intent.\n\nTo add parameters to the intent, add one or more `@Parameter` property wrappers. WidgetKit uses the parameter type information to automatically create the user interface for editing the widget. For example, if the type is [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], the person enters a string value. If the type is an [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], they use a number pad. For a parameter that is a predefined, static, list of values, define a custom type that conforms to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEnum].\n\nIn the example above, the parameter uses a custom `CharacterDetail` type the app defines to represent a character in the game. To use a custom type as an app intent parameter, it must conform to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEntity]. To implement the `CharacterDetail` parameter type, the game-status widget uses a structure that exists in the gameâ€™s project. This structure defines a list of available characters and their details, as follows:\n\nBecause characters might vary from game to game, the intent generates the list dynamically at runtime. WidgetKit uses the app entityâ€™s `defaultQuery` property to access the dynamic values, as described below.\n\nIf your widget includes nonoptional parameters, you must supply a default value. For types such as `String`, `Int`, or enumerations that use `AppEnum`, one option is to supply a default value as follows:\n\nA second option is to use a query type that implements `defaultResult()`, as shown in the next section.\n\nFor custom intents with parameters that conform to `AppEntity`, implement initializer methods to provide default values for the nonoptional parameters, such as the `init(character:)` method in the code for `SelectCharacterIntent` shown above. In your timeline providerâ€™s `placeholder(in:)` method, use one of these initializer methods to initialize the app intent that you pass to the timeline entry. These methods enable you to customize the placeholder with values that might be different from the default, if needed.\n\n### Implement a query to provide dynamic values\n\nSome of the tasks that an [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery] performs include:\n\nWhen a person edits a widget with a custom intent that provides dynamic values, the system invokes the query objectâ€™s [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery\/suggestedEntities()] method to get the list of possible choices.\n\nIn the entity query, the result is an array of all the `CharacterDetail` types available.\n\nWith the configuration of the custom app intent done, a person can edit the widget to select a specific character to display.\n\nAfter the person edits the widget and selects a character, the next step is to incorporate that choice into the widgetâ€™s display.\n\n### Handle customized values in your widget\n\nTo support configurable properties, a widget uses the [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] configuration. For example, the character-details widget defines its configuration as follows:\n\nThe `SelectCharacterIntent` parameter determines the customizable properties for the widget. The configuration uses `CharacterDetailProvider` to manage the timeline events for the widget. For more information about timeline providers, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Keeping-a-Widget-Up-To-Date].\n\nAfter a person edits the widget, WidgetKit passes the customized values to the provider when requesting timeline entries. You typically include relevant details from the intent in the timeline entries the provider generates. In the following example, the provider uses the `defaultQuery` to look up the `CharacterDetail` using the characterâ€™s `id` in the intent, and then creates a timeline with an entry containing the characterâ€™s detail:\n\nWhen you include the customized values in the timeline entry, your widgetâ€™s view can display the appropriate content.\n\n### Access customized values in your app\n\nWhen a person taps on a widget to open your app, WidgetKit passes the customized intent to your app in an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity]. In your appâ€™s code that handles the user activity, such as [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/onContinueUserActivity(_:perform:)] for a SwiftUI app or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneDelegate\/scene(_:continue:)] for a UIKit app, use the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity\/widgetConfigurationIntent(of:)] method to access the widgetâ€™s intent.\n\nTo access the intent of any widget that the user has installed, use [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetCenter\/getCurrentConfigurations(_:)] to fetch the [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetInfo] objects. Iterate over the `WidgetInfo` objects and call [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetInfo\/widgetConfigurationIntent(of:)].\n\n### Offer configurable widgets and complications on Apple Watch\n\nLike widgets in iOS and macOS, watch complications use app intents to display user-configurable data, and implementing configurable complications and widgets in watchOS works the same as in iOS or macOS. However, you have a choice whether you want to offer a preconfigured complication or widget or allow people to configure it themselves.\n\nIn your [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] code, implement the  [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider\/recommendations()] and return:\n\nIf you offer a preconfigured complication or widget, and your app receives new data thatâ€™s relevant to your recommended widget configurations, invalidate the now outdated recommendations by calling [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetCenter\/invalidateConfigurationRecommendations()]. This invalidation tells WidgetKit to get new recommendations for your preconfigured complications and widgets. When you invalidate the recommendations for preconfigured complications, make sure you return updated `AppIntentRecommendation` objects in the `recommendations()` callback.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/WidgetKit\/Making-a-Configurable-Widget\ncrawled: 2025-12-02T16:44:00Z\n---\n\n# Making a configurable widget\n\n**Article**\n\nGive people the option to customize their widgets by adding a custom app intent to your project.\n\n## Overview\n\nTo make the most relevant information easily accessible to people, widgets can provide customizable properties. For example, a person can select a specific stock for a stock quote widget, or enter a tracking number for a package delivery widget. Widgets define customizable properties by using app intents, the same mechanism that Siri Suggestions and Siri Shortcuts use for customizing those interactions.\n\nTo add configurable properties to your widget:\n\n1. Add custom app intent types that conform to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/WidgetConfigurationIntent] to define the configurable properties to your Xcode project.\n2. Specify an [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] as your widgetâ€™s timeline provider to incorporate the personâ€™s choices into your timeline entries.\n3. Add code to your custom app intent types to provide the data if their properties rely on dynamic data.\n\nIf your app already supports Siri Suggestions or Siri Shortcuts and you have a custom app intent, youâ€™ve probably done most of the work already. Otherwise, consider leveraging the work you do for your widget to add support for Siri Suggestions or Siri Shortcuts. For more information on how to get the most from app intents, see [doc:\/\/com.apple.documentation\/documentation\/AppIntents].\n\n\n\n### Add a custom app intent to your project\n\nTo show the characterâ€™s information, the person needs a way to select the character. The following code shows how to define a custom app intent to represent the choice the person makes:\n\n```swift\nstruct SelectCharacterIntent: WidgetConfigurationIntent {\n    static var title: LocalizedStringResource = \"Select Character\"\n    static var description = IntentDescription(\"Selects the character to display information for.\")\n\n    @Parameter(title: \"Character\")\n    var character: CharacterDetail\n\n    init(character: CharacterDetail) {\n        self.character = character\n    }\n\n    init() {\n    }\n}\n```\n\nThe static `title` property describes the action the intent enables the person to take. Use a title case string that combines a verb with a noun. Set the static `description` to a human-readable string that describes the intent.\n\nTo add parameters to the intent, add one or more `@Parameter` property wrappers. WidgetKit uses the parameter type information to automatically create the user interface for editing the widget. For example, if the type is [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], the person enters a string value. If the type is an [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], they use a number pad. For a parameter that is a predefined, static, list of values, define a custom type that conforms to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEnum].\n\n\n\nIn the example above, the parameter uses a custom `CharacterDetail` type the app defines to represent a character in the game. To use a custom type as an app intent parameter, it must conform to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEntity]. To implement the `CharacterDetail` parameter type, the game-status widget uses a structure that exists in the gameâ€™s project. This structure defines a list of available characters and their details, as follows:\n\n```swift\nstruct CharacterDetail: AppEntity {\n    let id: String\n    let avatar: String\n    let healthLevel: Double\n    let heroType: String\n    let isAvailable = true\n    \n    static var typeDisplayRepresentation: TypeDisplayRepresentation = \"Character\"\n    static var defaultQuery = CharacterQuery()\n            \n    var displayRepresentation: DisplayRepresentation {\n        DisplayRepresentation(title: \"\\(avatar) \\(id)\")\n    }\n\n    static let allCharacters: [CharacterDetail] = [\n        CharacterDetail(id: \"Power Panda\", avatar: \"ðŸ¼\", healthLevel: 0.14, heroType: \"Forest Dweller\"),\n        CharacterDetail(id: \"Unipony\", avatar: \"ðŸ¦„\", healthLevel: 0.67, heroType: \"Free Rangers\"),\n        CharacterDetail(id: \"Spouty\", avatar: \"ðŸ³\", healthLevel: 0.83, heroType: \"Deep Sea Goer\")\n    ]\n}\n```\n\nBecause characters might vary from game to game, the intent generates the list dynamically at runtime. WidgetKit uses the app entityâ€™s `defaultQuery` property to access the dynamic values, as described below.\n\nIf your widget includes nonoptional parameters, you must supply a default value. For types such as `String`, `Int`, or enumerations that use `AppEnum`, one option is to supply a default value as follows:\n\n```swift\n@Parameter(title: \"Title\", default: \"A Default Title\")\nvar title: String\n```\n\nA second option is to use a query type that implements `defaultResult()`, as shown in the next section.\n\nFor custom intents with parameters that conform to `AppEntity`, implement initializer methods to provide default values for the nonoptional parameters, such as the `init(character:)` method in the code for `SelectCharacterIntent` shown above. In your timeline providerâ€™s `placeholder(in:)` method, use one of these initializer methods to initialize the app intent that you pass to the timeline entry. These methods enable you to customize the placeholder with values that might be different from the default, if needed.\n\n### Implement a query to provide dynamic values\n\nSome of the tasks that an [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery] performs include:\n\n- Mapping `AppEntity` identifiers to the corresponding entity instances.\n- Providing a list of suggested values when a person edits a widget.\n- Specifying a default value for a parameter.\n\nWhen a person edits a widget with a custom intent that provides dynamic values, the system invokes the query objectâ€™s [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery\/suggestedEntities()] method to get the list of possible choices.\n\nIn the entity query, the result is an array of all the `CharacterDetail` types available.\n\n```swift\nstruct CharacterQuery: EntityQuery {\n    func entities(for identifiers: [CharacterDetail.ID]) async throws -> [CharacterDetail] {\n        CharacterDetail.allCharacters.filter { identifiers.contains($0.id) }\n    }\n    \n    func suggestedEntities() async throws -> [CharacterDetail] {\n        CharacterDetail.allCharacters.filter { $0.isAvailable }\n    }\n    \n    func defaultResult() async -> CharacterDetail? {\n        try? await suggestedEntities().first\n    }\n}\n```\n\nWith the configuration of the custom app intent done, a person can edit the widget to select a specific character to display.\n\nAfter the person edits the widget and selects a character, the next step is to incorporate that choice into the widgetâ€™s display.\n\n### Handle customized values in your widget\n\nTo support configurable properties, a widget uses the [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] configuration. For example, the character-details widget defines its configuration as follows:\n\n```swift\nstruct CharacterDetailWidget: Widget {\n    var body: some WidgetConfiguration {\n        AppIntentConfiguration(\n            kind: kind,\n            intent: SelectCharacterIntent.self,\n            provider: CharacterDetailProvider()) { entry in\n            CharacterDetailView(entry: entry)\n        }\n        .configurationDisplayName(\"Character Details\")\n        .description(\"Displays a character's health and other details\")\n        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge])\n    }\n}\n```\n\nThe `SelectCharacterIntent` parameter determines the customizable properties for the widget. The configuration uses `CharacterDetailProvider` to manage the timeline events for the widget. For more information about timeline providers, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Keeping-a-Widget-Up-To-Date].\n\nAfter a person edits the widget, WidgetKit passes the customized values to the provider when requesting timeline entries. You typically include relevant details from the intent in the timeline entries the provider generates. In the following example, the provider uses the `defaultQuery` to look up the `CharacterDetail` using the characterâ€™s `id` in the intent, and then creates a timeline with an entry containing the characterâ€™s detail:\n\n```swift\nstruct CharacterDetailProvider: AppIntentTimelineProvider {\n    func timeline(for configuration: SelectCharacterIntent, in context: Context) async -> Timeline<CharacterDetailEntry> {\n        \/\/ Create the timeline and return it. The .never reload policy indicates\n        \/\/ that the containing app uses WidgetCenter methods to reload the\n        \/\/ widget's timeline when the details change.\n        let entry = CharacterDetailEntry(date: Date(), detail: configuration.character)\n        let timeline = Timeline(entries: [entry], policy: .never)\n        return timeline\n    }\n}\n```\n\nWhen you include the customized values in the timeline entry, your widgetâ€™s view can display the appropriate content.\n\n### Access customized values in your app\n\nWhen a person taps on a widget to open your app, WidgetKit passes the customized intent to your app in an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity]. In your appâ€™s code that handles the user activity, such as [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/onContinueUserActivity(_:perform:)] for a SwiftUI app or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneDelegate\/scene(_:continue:)] for a UIKit app, use the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity\/widgetConfigurationIntent(of:)] method to access the widgetâ€™s intent.\n\nTo access the intent of any widget that the user has installed, use [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetCenter\/getCurrentConfigurations(_:)] to fetch the [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetInfo] objects. Iterate over the `WidgetInfo` objects and call [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetInfo\/widgetConfigurationIntent(of:)].\n\n### Offer configurable widgets and complications on Apple Watch\n\nLike widgets in iOS and macOS, watch complications use app intents to display user-configurable data, and implementing configurable complications and widgets in watchOS works the same as in iOS or macOS. However, you have a choice whether you want to offer a preconfigured complication or widget or allow people to configure it themselves.\n\nIn your [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] code, implement the  [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider\/recommendations()] and return:\n\n- An array of [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentRecommendation] objects you create using your custom app intents to offer a preconfigured complication or widget\n- An empty array (`return []`) to let people configure the complication or widget\n\n\n\nIf you offer a preconfigured complication or widget, and your app receives new data thatâ€™s relevant to your recommended widget configurations, invalidate the now outdated recommendations by calling [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetCenter\/invalidateConfigurationRecommendations()]. This invalidation tells WidgetKit to get new recommendations for your preconfigured complications and widgets. When you invalidate the recommendations for preconfigured complications, make sure you return updated `AppIntentRecommendation` objects in the `recommendations()` callback.\n\n## Configurable widgets\n\n- **Migrating widgets from SiriKit Intents to App Intents**: Configure your widgets for backward compatibility.\n- **AppIntentConfiguration**: An object describing the content of a widget that uses a custom intent to provide user-configurable options.\n- **WidgetInfo**: A structure that contains information about user-configured widgets.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Configure your widgets for backward compatibility.",
          "name" : "Migrating widgets from SiriKit Intents to App Intents",
          "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/Migrating-from-SiriKit-Intents-to-App-Intents"
        },
        {
          "description" : "An object describing the content of a widget that uses a custom intent to provide user-configurable options.",
          "name" : "AppIntentConfiguration",
          "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/AppIntentConfiguration"
        },
        {
          "description" : "A structure that contains information about user-configured widgets.",
          "name" : "WidgetInfo",
          "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/WidgetInfo"
        }
      ],
      "title" : "Configurable widgets"
    }
  ],
  "source" : "appleJSON",
  "title" : "Making a configurable widget",
  "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/Making-a-Configurable-Widget"
}