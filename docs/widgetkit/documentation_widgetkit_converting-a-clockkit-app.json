{
  "abstract" : "Leverage WidgetKit’s API to create watchOS complications using SwiftUI.",
  "codeExamples" : [
    {
      "code" : "struct CoffeeTrackerEntry: TimelineEntry {\n    let date: Date\n    let mgCaffeine: Double\n    let totalCups: Double\n}",
      "language" : "swift"
    },
    {
      "code" : "func placeholder(in context: Context) -> SimpleEntry {\n    \n    \/\/ Show a complication with generic data.\n    CoffeeTrackerEntry(date: Date(),\n                       mgCaffeine: 250.0,\n                       totalCups: 2.0)\n}",
      "language" : "swift"
    },
    {
      "code" : "func getSnapshot(in context: Context, completion: @escaping (CoffeeTrackerEntry) -> Void) {\n    \n    if context.isPreview {\n        \/\/ Show a complication with generic data.\n        let entry = CoffeeTrackerEntry(date: Date(),\n                    mgCaffeine: 250.0,\n                    totalCups: 2.0)\n        \n        completion(entry)\n        return\n    }\n    \n    Task {\n        \n        let date = Date()\n        \n        \/\/ Get the current data from the model.\n        let mgCaffeine = await data.mgCaffeine(atDate: date)\n        let totalCups = await data.totalCupsToday\n        \n        \/\/ Create the entry.\n        let entry = CoffeeTrackerEntry(date: date,\n                                mgCaffeine: mgCaffeine,\n                                totalCups: totalCups)\n        \n        \/\/ Pass the entry to the completion handler.\n        completion(entry)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> Void) {\n    Task {\n\n        \/\/ Create an array to hold the events.\n        var entries: [CoffeeTrackerEntry] = []\n        \n        \/\/ The total number of cups consumed only changes when the user actively adds a drink,\n        \/\/ so it remains constant in this timeline.\n        let totalCups = await data.totalCupsToday\n\n        \/\/ Generate a timeline covering every 5 minutes for the next 24 hours.\n        let currentDate = Date()\n        for minuteOffset in stride(from: 0, to: 60 * 24, by: 5) {\n            let entryDate = Calendar.current.date(byAdding: .minute, value: minuteOffset, to: currentDate)!\n            \n            \/\/ Get the projected data for the specified date.\n            let mgCaffeine = await data.mgCaffeine(atDate: entryDate)\n            \n            \/\/ Create the entry.\n            let entry = CoffeeTrackerEntry(date: entryDate,\n                                           mgCaffeine: mgCaffeine,\n                                           totalCups: totalCups)\n            \n            \/\/ Add the event to the array.\n            entries.append(entry)\n        }\n\n        \/\/ Create the timeline and pass it to the completion handler.\n        \/\/ Because the caffeine dose drops to 0.0 mg after 24 hours,\n        \/\/ there's no need to reload this timeline unless the user adds\n        \/\/ a new drink. Setting the reload policy to .never.\n        let timeline = Timeline(entries: entries, policy: .never)\n        \n        \/\/ Pass the timeline to the completion handler.\n        completion(timeline)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@main\nstruct CoffeeTrackerWidgets: WidgetBundle {\n   var body: some Widget {\n       CaffeineComplication()\n       CupsComplication()\n       CaffeineAndCupsComplication()\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "func recommendations() -> [AppIntentRecommendation<ConfigurationAppIntent>] {\n    var recommendations = [AppIntentRecommendation<ConfigurationAppIntent>]()\n    \n    for cityID in favoriteCityIDs {\n        let intent = ConfigurationAppIntent()\n        intent.cityID = cityID\n        recommendations.append(AppIntentRecommendation(intent: intent, description: cityName(id: cityID)))\n    }\n\n    return recommendations\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CaffeineComplication: Widget {\n    \n    \/\/ Create a unique string to identify the complication.\n    let kind: String = \"com.example.caffeine-complication\"\n\n    var body: some WidgetConfiguration {\n        StaticConfiguration(kind: kind, provider: Provider()) { entry in\n            CoffeeTrackerComplicationsEntryView(entry: entry)\n        }\n        .configurationDisplayName(\"Coffee Tracker\")\n        .description(\"Shows the current caffeine dose in your system.\")\n        .supportedFamilies([.accessoryCorner, .accessoryCircular, .accessoryInline])\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CaffeineComplicationView: View {\n    \n    \/\/ Get the widget's family.\n    @Environment(\\.widgetFamily) private var family\n    \n    var entry: Provider.Entry\n    \n    var body: some View {\n        switch family {\n        case .accessoryCircular:\n            MyCircularComplication(mgCaffeine: entry.mgCaffeine,\n                                   totalCups: entry.totalCups)\n            \n        case .accessoryCorner:\n            MyCornerComplication(mgCaffeine: entry.mgCaffeine,\n                                 totalCups: entry.totalCups)\n            \n        case .accessoryInline:\n            MyInlineComplication(mgCaffeine: entry.mgCaffeine,\n                                 totalCups: entry.totalCups)\n            \n        default:\n            Image(\"AppIcon\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyCircularComplication: View {\n    \/\/ Get the rendering mode.\n    @Environment(\\.widgetRenderingMode) var renderingMode\n    \n    var mgCaffeine: Double\n    var totalCups: Double\n    let maxMG = 500.0\n    \n    var body: some View {\n        Gauge( value: min(mgCaffeine, maxMG), in: 0.0...maxMG ) {\n            Text(\"mg\")\n        } currentValueLabel: {\n            if renderingMode == .fullColor {\n                \/\/ Add a foreground color to the label.\n                Text(mgCaffeine.formatted(myFloatFormatter))\n                    .foregroundStyle(.doseColor(for: mgCaffeine))\n            }\n            else {\n                \/\/ Otherwise, use the default text color.\n                Text(mgCaffeine.formatted(myFloatFormatter))\n            }\n        }\n        .gaugeStyle(\n            \/\/ Add a gradient to the gauge.\n            CircularGaugeStyle(tint: Gradient(stops: myStops)))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class ComplicationController: NSObject, CLKComplicationDataSource, CLKComplicationWidgetMigrator {\n   \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "var widgetMigrator: CLKComplicationWidgetMigrator {\n    self\n}",
      "language" : "swift"
    },
    {
      "code" : "func widgetConfiguration(from complicationDescriptor: CLKComplicationDescriptor) async -> CLKComplicationWidgetMigrationConfiguration? {\n    \n    switch complicationDescriptor.identifier {\n    case caffeineDoseIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"com.example.Caffeine-Complication\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n    case cupTotalIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"com.example.CupTotal-Complication\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n    case cupAndCaffeineIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"com.example.CupAndCaffeine-Complication\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n    default:\n        return nil\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "38bd6abf98dc42c8e2e43a95c66e308330362566d83f2dd35c88260e84afb7fa",
  "crawledAt" : "2025-12-02T15:52:34Z",
  "id" : "4B72B280-6FAC-498F-A80B-3A2C47C12C88",
  "kind" : "article",
  "language" : "swift",
  "module" : "WidgetKit",
  "overview" : "## Overview\n\nWith watchOS 9 and later, you can create complications for your watchOS app using SwiftUI views in WidgetKit. WidgetKit provides a modern API for creating and updating glanceable elements — making it an ideal fit for watchOS complications. Because WidgetKit’s design is inspired by ClockKit, if you’ve already designed ClockKit complications for your app, the process feels familiar. Similarly, if you’re already using widgets for iOS, you can quickly set up WidgetKit complications for a watchOS app. In many cases, you can use the same code to display WidgetKit complications in watchOS and widgets on the Lock Screen on iPhone. For more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Creating-accessory-widgets-and-watch-complications].\n\n### Add WidgetKit to your project\n\nTo convert ClockKit complications to WidgetKit, start by adding a WidgetKit extension to your watchOS project.\n\n\n\nXcode creates a new target containing Swift files for the widget, an asset catalog, and an `Info.plist` file for the extension. The WidgetKit template provides you with structures that adopt the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Widget] and [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View] protocols. It also includes a starting implementation for your [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider], or [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] if you enabled Include Configuration App Intent.\n\n\n\n### Configure your timeline provider\n\nThe template creates a `Provider` structure that adopts the `TimelineProvider` or `AppIntentTimelineProvider` protocol, and provides a default implementation for the protocol’s methods. WidgetKit calls these methods to get the data needed to create the widget view.\n\nIn each of the protocol methods, your app needs to create and return one or more [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineEntry] instances:\n\nThe template provides a timeline entry that contains the date when the system should display it. Add any extra properties that you need for your complications.\n\nThen, begin updating the timeline provider’s methods. For the placeholder, the system automatically redacts all of the widget’s content, unless you explicitly mark items with the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/unredacted()] view modifier in your complication’s SwiftUI view. As a result, you may want to provide generic data that fills out the redacted version.\n\nThe system can display the placeholder when the watch is locked, when it’s in Always On mode, and when it can’t otherwise display a live version of your complication.\n\nFor the snapshot, return a single entry. In general, you want to return the current state of your app. However, the system also uses the snapshot when displaying your complication in the complication picker. When returning your snapshot entry, be sure to check the `context` parameter [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProviderContext\/isPreview] property. This property indicates whether the snapshot will be used in the complication picker. If this is `true`, provide generic data that shows your app’s typical appearance.\n\nFor the timeline, create an array of entries, and then create a [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Timeline] instance from that array. You can also select a reload policy for the timeline. By default, the system reloads the timeline when you reach its end. However, in the example below, the system only reloads the timeline when you explicitly request it.\n\nFor more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Making-a-Configurable-Widget] and [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Keeping-a-Widget-Up-To-Date].\n\n### Support multiple complications\n\nIf your app provides a static set of widgets, you can define multiple widgets using a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WidgetBundle] protocol. For example, the code listing below provides three complications: one that displays the user’s current caffeine dose, one that provides the total number of cups of coffee for the day, and one that provides both. Each widget can then support a different subset of the available families.\n\nHowever, if you need to dynamically configure a set of complications, provide a custom app intent. For example, a weather app may let people install complications for any cities in their favorites list.\n\nWidgetKit uses app intents for customizable properties, the same method that Siri Suggestions and Siri Shortcuts use to customize those interactions. In iOS, the app intents describe elements that the user can customize. For WidgetKit complications in watchOS, these intents aren’t user configurable. Instead, they represent items that your app can dynamically configure.\n\nTo customize the widgets, implement your [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] structure’s [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider\/recommendations()] method to return an array of [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentRecommendation] instances.\n\nFor more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Making-a-Configurable-Widget].\n\n### Design the complication using SwiftUI\n\nUse SwiftUI static views, such as text, shapes, or images, to create your complication’s content. You can also add render effects like blurs and gradients, but keep in mind that complications only have one or two frames in which to render the effect.\n\nBecause complications show a snapshot of the app’s data at a particular point in time, they don’t support features like animation. Additionally, if the user touches your complication, the system launches your app instead of passing the touch event to the SwiftUI views, so a complication can’t use interactive elements like buttons or switches.\n\nStart by updating your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Widget] structure.\n\nThe body of the widget contains either a static or intent configuration, depending on whether your app uses custom app intent definitions. Use the configuration to set items like the complication’s display name and the supported families. The configuration also takes a closure that returns a SwiftUI view for the specified entry.\n\nWidgetKit reduces the number of families you need to support. In some cases, a WidgetKit accessory family covers more than one ClockKit family, which reduces the number of supported families from 12 to 4.\n\nUse the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/widgetFamily] environment value to determine the complication’s family. You can provide a different SwiftUI view for each family. You can also get the family from the context passed to your timeline provider’s [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider\/getTimeline(in:completion:)], [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider\/getSnapshot(in:completion:)], and [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider\/placeholder(in:)] methods.\n\nThen, check the [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetRenderingMode] environmental value to determine whether your complication is rendered in full color or using accent colors. Modify your design to best suit the current rendering mode.\n\nIn [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetRenderingMode\/accented] mode, you can explicitly partition your view into an accented group and the default group by adding the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/widgetAccentable(_:)] view modifier to part of your complication’s view hierarchy. For more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Creating-accessory-widgets-and-watch-complications] and [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Creating-views-for-widgets-Live-Activities-and-watch-complications].\n\nWhen designing your WidgetKit complications, build your complication views so that they can adapt to different sizes. For example, you can use [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ViewThatFits] to provide a set of different-sized views, letting the system pick the best fit for the current context.\n\nYou can add a standard background to your complication by adding a [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AccessoryWidgetBackground] in a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ZStack] behind your widget’s content, and you can also add additional information to circular and corner complications using a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/widgetLabel(label:)]. Use the widget label to add gauges, progress views, or text along the inside curve of the corner view, or to add an image and text along the bezel of the Infograph watch face.\n\nFinally, consider how Always On affects your complications. You may need to redact sensitive information, or adjust the widget’s appearance for reduced luminance. You can explicitly redact sensitive information using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/privacySensitive(_:)] view modifier. If you do, the system displays the redacted version of your view during Always On. For more information, see [doc:\/\/com.apple.documentation\/documentation\/watchOS-Apps\/designing-your-app-for-the-always-on-state].\n\n## Migrate complications on a watch face\n\nWhen users upgrade your app, you need to transition them from the old ClockKit complications to your new WidgetKit complications. Start by implementing your [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationDataSource] type’s [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationDataSource\/widgetMigrator] method. Use your implementation to return an instance that conforms to the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationWidgetMigrator] protocol.\n\nFor example, update your data source so that it conforms to the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationWidgetMigrator] protocol.\n\nThen, have the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationDataSource\/widgetMigrator] property return `self`.\n\nFinally, implement the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationWidgetMigrator\/getWidgetConfiguration(from:completionHandler:)] method. This method determines the best WidgetKit configuration for the given complication descriptor. This example uses the Swift async version of the method:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/WidgetKit\/Converting-A-ClockKit-App\ncrawled: 2025-12-02T15:52:34Z\n---\n\n# Migrating ClockKit complications to WidgetKit\n\n**Article**\n\nLeverage WidgetKit’s API to create watchOS complications using SwiftUI.\n\n## Overview\n\nWith watchOS 9 and later, you can create complications for your watchOS app using SwiftUI views in WidgetKit. WidgetKit provides a modern API for creating and updating glanceable elements — making it an ideal fit for watchOS complications. Because WidgetKit’s design is inspired by ClockKit, if you’ve already designed ClockKit complications for your app, the process feels familiar. Similarly, if you’re already using widgets for iOS, you can quickly set up WidgetKit complications for a watchOS app. In many cases, you can use the same code to display WidgetKit complications in watchOS and widgets on the Lock Screen on iPhone. For more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Creating-accessory-widgets-and-watch-complications].\n\n### Add WidgetKit to your project\n\nTo convert ClockKit complications to WidgetKit, start by adding a WidgetKit extension to your watchOS project.\n\n\n\n1. In Xcode, select the project icon in the Project navigator.\n2. Click the “Add a target” button.\n3. In the watchOS tab, select the Widget Extension template and click Next.\n4. Give the new target a name.\n5. If your app dynamically creates the set of [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationDescriptor] objects to support multiple complication types, enable the Include Configuration App Intent option. If you don’t plan to configure your complications using app intents, you can disable this option.\n6. Click Finish.\n\nXcode creates a new target containing Swift files for the widget, an asset catalog, and an `Info.plist` file for the extension. The WidgetKit template provides you with structures that adopt the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Widget] and [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View] protocols. It also includes a starting implementation for your [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider], or [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] if you enabled Include Configuration App Intent.\n\n\n\n\n\n### Configure your timeline provider\n\nThe template creates a `Provider` structure that adopts the `TimelineProvider` or `AppIntentTimelineProvider` protocol, and provides a default implementation for the protocol’s methods. WidgetKit calls these methods to get the data needed to create the widget view.\n\n\n\nIn each of the protocol methods, your app needs to create and return one or more [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineEntry] instances:\n\n\n\nThe template provides a timeline entry that contains the date when the system should display it. Add any extra properties that you need for your complications.\n\n```swift\nstruct CoffeeTrackerEntry: TimelineEntry {\n    let date: Date\n    let mgCaffeine: Double\n    let totalCups: Double\n}\n```\n\nThen, begin updating the timeline provider’s methods. For the placeholder, the system automatically redacts all of the widget’s content, unless you explicitly mark items with the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/unredacted()] view modifier in your complication’s SwiftUI view. As a result, you may want to provide generic data that fills out the redacted version.\n\n```swift\nfunc placeholder(in context: Context) -> SimpleEntry {\n    \n    \/\/ Show a complication with generic data.\n    CoffeeTrackerEntry(date: Date(),\n                       mgCaffeine: 250.0,\n                       totalCups: 2.0)\n}\n```\n\nThe system can display the placeholder when the watch is locked, when it’s in Always On mode, and when it can’t otherwise display a live version of your complication.\n\nFor the snapshot, return a single entry. In general, you want to return the current state of your app. However, the system also uses the snapshot when displaying your complication in the complication picker. When returning your snapshot entry, be sure to check the `context` parameter [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProviderContext\/isPreview] property. This property indicates whether the snapshot will be used in the complication picker. If this is `true`, provide generic data that shows your app’s typical appearance.\n\n```swift\nfunc getSnapshot(in context: Context, completion: @escaping (CoffeeTrackerEntry) -> Void) {\n    \n    if context.isPreview {\n        \/\/ Show a complication with generic data.\n        let entry = CoffeeTrackerEntry(date: Date(),\n                    mgCaffeine: 250.0,\n                    totalCups: 2.0)\n        \n        completion(entry)\n        return\n    }\n    \n    Task {\n        \n        let date = Date()\n        \n        \/\/ Get the current data from the model.\n        let mgCaffeine = await data.mgCaffeine(atDate: date)\n        let totalCups = await data.totalCupsToday\n        \n        \/\/ Create the entry.\n        let entry = CoffeeTrackerEntry(date: date,\n                                mgCaffeine: mgCaffeine,\n                                totalCups: totalCups)\n        \n        \/\/ Pass the entry to the completion handler.\n        completion(entry)\n    }\n}\n```\n\nFor the timeline, create an array of entries, and then create a [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Timeline] instance from that array. You can also select a reload policy for the timeline. By default, the system reloads the timeline when you reach its end. However, in the example below, the system only reloads the timeline when you explicitly request it.\n\n```swift\nfunc getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> Void) {\n    Task {\n\n        \/\/ Create an array to hold the events.\n        var entries: [CoffeeTrackerEntry] = []\n        \n        \/\/ The total number of cups consumed only changes when the user actively adds a drink,\n        \/\/ so it remains constant in this timeline.\n        let totalCups = await data.totalCupsToday\n\n        \/\/ Generate a timeline covering every 5 minutes for the next 24 hours.\n        let currentDate = Date()\n        for minuteOffset in stride(from: 0, to: 60 * 24, by: 5) {\n            let entryDate = Calendar.current.date(byAdding: .minute, value: minuteOffset, to: currentDate)!\n            \n            \/\/ Get the projected data for the specified date.\n            let mgCaffeine = await data.mgCaffeine(atDate: entryDate)\n            \n            \/\/ Create the entry.\n            let entry = CoffeeTrackerEntry(date: entryDate,\n                                           mgCaffeine: mgCaffeine,\n                                           totalCups: totalCups)\n            \n            \/\/ Add the event to the array.\n            entries.append(entry)\n        }\n\n        \/\/ Create the timeline and pass it to the completion handler.\n        \/\/ Because the caffeine dose drops to 0.0 mg after 24 hours,\n        \/\/ there's no need to reload this timeline unless the user adds\n        \/\/ a new drink. Setting the reload policy to .never.\n        let timeline = Timeline(entries: entries, policy: .never)\n        \n        \/\/ Pass the timeline to the completion handler.\n        completion(timeline)\n    }\n}\n```\n\nFor more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Making-a-Configurable-Widget] and [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Keeping-a-Widget-Up-To-Date].\n\n### Support multiple complications\n\nIf your app provides a static set of widgets, you can define multiple widgets using a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WidgetBundle] protocol. For example, the code listing below provides three complications: one that displays the user’s current caffeine dose, one that provides the total number of cups of coffee for the day, and one that provides both. Each widget can then support a different subset of the available families.\n\n```swift\n@main\nstruct CoffeeTrackerWidgets: WidgetBundle {\n   var body: some Widget {\n       CaffeineComplication()\n       CupsComplication()\n       CaffeineAndCupsComplication()\n   }\n}\n```\n\nHowever, if you need to dynamically configure a set of complications, provide a custom app intent. For example, a weather app may let people install complications for any cities in their favorites list.\n\nWidgetKit uses app intents for customizable properties, the same method that Siri Suggestions and Siri Shortcuts use to customize those interactions. In iOS, the app intents describe elements that the user can customize. For WidgetKit complications in watchOS, these intents aren’t user configurable. Instead, they represent items that your app can dynamically configure.\n\nTo customize the widgets, implement your [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider] structure’s [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentTimelineProvider\/recommendations()] method to return an array of [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AppIntentRecommendation] instances.\n\n```swift\nfunc recommendations() -> [AppIntentRecommendation<ConfigurationAppIntent>] {\n    var recommendations = [AppIntentRecommendation<ConfigurationAppIntent>]()\n    \n    for cityID in favoriteCityIDs {\n        let intent = ConfigurationAppIntent()\n        intent.cityID = cityID\n        recommendations.append(AppIntentRecommendation(intent: intent, description: cityName(id: cityID)))\n    }\n\n    return recommendations\n}\n```\n\nFor more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Making-a-Configurable-Widget].\n\n### Design the complication using SwiftUI\n\nUse SwiftUI static views, such as text, shapes, or images, to create your complication’s content. You can also add render effects like blurs and gradients, but keep in mind that complications only have one or two frames in which to render the effect.\n\nBecause complications show a snapshot of the app’s data at a particular point in time, they don’t support features like animation. Additionally, if the user touches your complication, the system launches your app instead of passing the touch event to the SwiftUI views, so a complication can’t use interactive elements like buttons or switches.\n\nStart by updating your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Widget] structure.\n\n```swift\nstruct CaffeineComplication: Widget {\n    \n    \/\/ Create a unique string to identify the complication.\n    let kind: String = \"com.example.caffeine-complication\"\n\n    var body: some WidgetConfiguration {\n        StaticConfiguration(kind: kind, provider: Provider()) { entry in\n            CoffeeTrackerComplicationsEntryView(entry: entry)\n        }\n        .configurationDisplayName(\"Coffee Tracker\")\n        .description(\"Shows the current caffeine dose in your system.\")\n        .supportedFamilies([.accessoryCorner, .accessoryCircular, .accessoryInline])\n    }\n}\n```\n\nThe body of the widget contains either a static or intent configuration, depending on whether your app uses custom app intent definitions. Use the configuration to set items like the complication’s display name and the supported families. The configuration also takes a closure that returns a SwiftUI view for the specified entry.\n\nWidgetKit reduces the number of families you need to support. In some cases, a WidgetKit accessory family covers more than one ClockKit family, which reduces the number of supported families from 12 to 4.\n\n\n\n\n\nUse the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/widgetFamily] environment value to determine the complication’s family. You can provide a different SwiftUI view for each family. You can also get the family from the context passed to your timeline provider’s [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider\/getTimeline(in:completion:)], [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider\/getSnapshot(in:completion:)], and [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/TimelineProvider\/placeholder(in:)] methods.\n\n```swift\nstruct CaffeineComplicationView: View {\n    \n    \/\/ Get the widget's family.\n    @Environment(\\.widgetFamily) private var family\n    \n    var entry: Provider.Entry\n    \n    var body: some View {\n        switch family {\n        case .accessoryCircular:\n            MyCircularComplication(mgCaffeine: entry.mgCaffeine,\n                                   totalCups: entry.totalCups)\n            \n        case .accessoryCorner:\n            MyCornerComplication(mgCaffeine: entry.mgCaffeine,\n                                 totalCups: entry.totalCups)\n            \n        case .accessoryInline:\n            MyInlineComplication(mgCaffeine: entry.mgCaffeine,\n                                 totalCups: entry.totalCups)\n            \n        default:\n            Image(\"AppIcon\")\n        }\n    }\n}\n```\n\nThen, check the [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetRenderingMode] environmental value to determine whether your complication is rendered in full color or using accent colors. Modify your design to best suit the current rendering mode.\n\n```swift\nstruct MyCircularComplication: View {\n    \/\/ Get the rendering mode.\n    @Environment(\\.widgetRenderingMode) var renderingMode\n    \n    var mgCaffeine: Double\n    var totalCups: Double\n    let maxMG = 500.0\n    \n    var body: some View {\n        Gauge( value: min(mgCaffeine, maxMG), in: 0.0...maxMG ) {\n            Text(\"mg\")\n        } currentValueLabel: {\n            if renderingMode == .fullColor {\n                \/\/ Add a foreground color to the label.\n                Text(mgCaffeine.formatted(myFloatFormatter))\n                    .foregroundStyle(.doseColor(for: mgCaffeine))\n            }\n            else {\n                \/\/ Otherwise, use the default text color.\n                Text(mgCaffeine.formatted(myFloatFormatter))\n            }\n        }\n        .gaugeStyle(\n            \/\/ Add a gradient to the gauge.\n            CircularGaugeStyle(tint: Gradient(stops: myStops)))\n    }\n}\n```\n\nIn [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/WidgetRenderingMode\/accented] mode, you can explicitly partition your view into an accented group and the default group by adding the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/widgetAccentable(_:)] view modifier to part of your complication’s view hierarchy. For more information, see [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Creating-accessory-widgets-and-watch-complications] and [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/Creating-views-for-widgets-Live-Activities-and-watch-complications].\n\nWhen designing your WidgetKit complications, build your complication views so that they can adapt to different sizes. For example, you can use [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ViewThatFits] to provide a set of different-sized views, letting the system pick the best fit for the current context.\n\nYou can add a standard background to your complication by adding a [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AccessoryWidgetBackground] in a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ZStack] behind your widget’s content, and you can also add additional information to circular and corner complications using a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/widgetLabel(label:)]. Use the widget label to add gauges, progress views, or text along the inside curve of the corner view, or to add an image and text along the bezel of the Infograph watch face.\n\nFinally, consider how Always On affects your complications. You may need to redact sensitive information, or adjust the widget’s appearance for reduced luminance. You can explicitly redact sensitive information using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/privacySensitive(_:)] view modifier. If you do, the system displays the redacted version of your view during Always On. For more information, see [doc:\/\/com.apple.documentation\/documentation\/watchOS-Apps\/designing-your-app-for-the-always-on-state].\n\n\n\n## Migrate complications on a watch face\n\nWhen users upgrade your app, you need to transition them from the old ClockKit complications to your new WidgetKit complications. Start by implementing your [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationDataSource] type’s [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationDataSource\/widgetMigrator] method. Use your implementation to return an instance that conforms to the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationWidgetMigrator] protocol.\n\nFor example, update your data source so that it conforms to the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationWidgetMigrator] protocol.\n\n```swift\nclass ComplicationController: NSObject, CLKComplicationDataSource, CLKComplicationWidgetMigrator {\n   \/\/ ...\n}\n```\n\nThen, have the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationDataSource\/widgetMigrator] property return `self`.\n\n```swift\nvar widgetMigrator: CLKComplicationWidgetMigrator {\n    self\n}\n```\n\nFinally, implement the [doc:\/\/com.apple.documentation\/documentation\/ClockKit\/CLKComplicationWidgetMigrator\/getWidgetConfiguration(from:completionHandler:)] method. This method determines the best WidgetKit configuration for the given complication descriptor. This example uses the Swift async version of the method:\n\n```swift\nfunc widgetConfiguration(from complicationDescriptor: CLKComplicationDescriptor) async -> CLKComplicationWidgetMigrationConfiguration? {\n    \n    switch complicationDescriptor.identifier {\n    case caffeineDoseIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"com.example.Caffeine-Complication\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n    case cupTotalIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"com.example.CupTotal-Complication\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n    case cupAndCaffeineIdentifier:\n        return CLKComplicationStaticWidgetMigrationConfiguration(\n            kind: \"com.example.CupAndCaffeine-Complication\",\n            extensionBundleIdentifier: \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeTracker-Complications\")\n\n    default:\n        return nil\n    }\n}\n```\n\n## Accessory and watchOS widgets\n\n- **Creating accessory widgets and watch complications**: Support accessory widgets that appear on the Lock Screen and as complications on Apple Watch.\n- **AccessoryWidgetGroup**: A view type that has a label at the top and three content views masked with a circle or rounded square.\n- **AccessoryWidgetGroupStyle**: The style for an [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AccessoryWidgetGroup] view.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Support accessory widgets that appear on the Lock Screen and as complications on Apple Watch.",
          "name" : "Creating accessory widgets and watch complications",
          "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/Creating-accessory-widgets-and-watch-complications"
        },
        {
          "description" : "A view type that has a label at the top and three content views masked with a circle or rounded square.",
          "name" : "AccessoryWidgetGroup",
          "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/AccessoryWidgetGroup"
        },
        {
          "description" : "The style for an [doc:\/\/com.apple.WidgetKit\/documentation\/WidgetKit\/AccessoryWidgetGroup] view.",
          "name" : "AccessoryWidgetGroupStyle",
          "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/AccessoryWidgetGroupStyle"
        }
      ],
      "title" : "Accessory and watchOS widgets"
    }
  ],
  "source" : "appleJSON",
  "title" : "Migrating ClockKit complications to WidgetKit",
  "url" : "https:\/\/developer.apple.com\/documentation\/WidgetKit\/Converting-A-ClockKit-App"
}