{
  "abstract" : "Create a web browser app and associated extensions.",
  "codeExamples" : [
    {
      "code" : "struct TabContentView: View {\n  \n  @ObservedObject var tab: TabViewModel\n  \n  var body: some View {\n    if let error = tab.error {\n      VStack {\n        Image(systemName: \"exclamationmark.triangle\")\n        Text(error.localizedDescription)\n      }\n    } else {\n      WebViewRepresentable(webView: tab.webView)\n    }\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "    let contentProcess = try await getOrLaunchContentProcess(pageID: id)\n    let contentConnection = try contentProcess.makeLibXPCConnection()\n    let contentProxy = WebContentExtensionProxy(connection: contentConnection)\n    try contentProxy.lockdown(version: lockdownVersion)"
    },
    {
      "code" : "    let renderingProcess = try await getOrLaunchRenderingProcess()\n    let renderingConnection = try renderingProcess.makeLibXPCConnection()\n    let renderingProxy = RenderingExtensionProxy(connection: renderingConnection)"
    },
    {
      "code" : "    let renderingEndpoint = try await renderingProxy.getEndpoint()"
    },
    {
      "code" : "    let networkProcess = try await getOrLaunchNetworkProcess()\n    let networkConnection = try networkProcess.makeLibXPCConnection()\n    let networkProxy = NetworkingExtensionProxy(connection: networkConnection)\n    let networkEndpoint = try await networkProxy.getEndpoint()"
    },
    {
      "code" : "    try await contentProxy.bootstrap(renderingExtension: renderingEndpoint, networkExtension: networkEndpoint)"
    },
    {
      "code" : "  private func perform(bootstrap cmd: WebContentExtensionBootstrapCommand) async throws {\n    log.log(\"performing bootstrap\")\n    \n    if let renderingProxy = self.renderingProxy { \/\/ Connect to the Rendering extension if needed\n      log.log(\"already connected to rendering extension: \\(String(describing: renderingProxy.connection))\")\n    } else {\n      let endpoint = cmd.renderingEndpoint\n      log.log(\"connecting to rendering extension at: \\(String(describing: endpoint))\")\n      let connection = xpc_connection_create_from_endpoint(endpoint)\n      self.renderingProxy = .init(connection: connection)\n      try await connection.ping()\n      log.log(\"connected to rendering extension: \\(String(describing: connection))\")\n    }\n    \n    if let networkProxy = self.networkProxy {  \/\/ Connect to the Networking extension if needed\n      log.log(\"already connected to network extension: \\(String(describing: networkProxy.connection))\")\n    } else {\n      let endpoint = cmd.networkEndpoint\n      log.log(\"connecting to network extension at: \\(String(describing: endpoint))\")\n      let connection = xpc_connection_create_from_endpoint(endpoint)\n      self.networkProxy = .init(connection: connection)\n      try await connection.ping()\n      log.log(\"connected to network extension: \\(String(describing: connection))\")\n    }\n  }"
    },
    {
      "code" : "    let result = try await webContentProxy.load(destination: destination)"
    },
    {
      "code" : "    let task: WebContentExtensionTask = .load(destination: destination)\n    return try await connection.sendWithReply(task, decodingReplyAs: NetworkTaskResult.self)"
    },
    {
      "code" : "    switch destination {\n    case .url(let url):\n      guard let networkProxy else {\n        throw CustomBrowserError(\"not connected to the network extension\")\n      }\n      return try await networkProxy.fetchData(from: url)\n    case .htmlString(let string):\n      guard let data = string.data(using: .utf8) else {\n        throw CustomBrowserError(\"failed to get utf8 data from string\")\n      }\n      return .init(response: nil, data: data, error: nil)\n    case .localFile(let file):\n      let data = try Data(contentsOf: file)\n      return .init(response: nil, data: data, error: nil)\n    }"
    },
    {
      "code" : "    render(result)"
    }
  ],
  "contentHash" : "218ecf6729b0254d4327e3d6edd55839b18ade47192987da54aa2e1d6163be7f",
  "crawledAt" : "2025-12-02T15:54:59Z",
  "id" : "1452EC52-C092-4422-B4F9-0D942B160F33",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "BrowserEngineKit",
  "overview" : "## Overview\n\nThis sample code project demonstrates how a web browser app uses [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit] and [doc:\/\/com.apple.documentation\/documentation\/XPC] to communicate with its alternative browser engine over XPC, and implement a browser UI. The workspace contains four targets that define components of the browser app:\n\nFor more information on how these targets work together to support a custom web browser engine, see [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit\/designing-your-browser-architecture].\n\n### Configure the sample code project\n\nTo build a web browser that uses an alternative browser engine, including the one in this sample project, you need to apply for certain entitlements from WWDR. For more information on how to use these entitlements, see [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit\/creating-browser-extensions-in-xcode]. For information on applying for the entitlements, see [https:\/\/developer.apple.com\/support\/alternative-browser-engines].\n\nTo build the sample code project for a device, you must target an iPhone that supports the `arm64e` instruction set. `BrowserEngineKit` doesn’t support iPadOS, so this project won’t build for iPad.\n\n### Open a new tab\n\nWhen someone using the browser app opens a new tab, the browser app’s `BrowserPage` creates a `TabContentView` to display the tab’s contents, which gets its data from the tab’s `TabViewModel`.\n\nThe `TabViewModel`‘s `webView` property is a `WebView` that displays the tab’s contents, which the `TabContentView` wraps in a `WebViewRepresentable` to display using SwiftUI.\n\nThe `WebView`’s initializer creates a `WebContentView`, which is the view that renders the HTML document in the tab. `WebContentView` calls `launchProcesses(id: PageID)`, which does the following:\n\nThe web content process responds to the bootstrap message by retrieving the anonymous XPC connections for the other extensions from the endpoints it was sent by the host app, and sends them each “ping” messages to ensure the connections are valid.\n\nFor more information on this process, see the section “Pass anonymous connection endpoints between extensions” in [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit\/using-xpc-to-communicate-with-browser-extensions].\n\n### Load web content\n\nWhen someone using the browser app navigates to a new location, the `WebContentView` asks the proxy object that represents the web-content process to load the data at the location’s URL:\n\nThis method sends a network load message to the web-content process:\n\nThe web-content process checks what kind of data it’s trying to load. If it’s a URL, it asks the networking extension to load the content. Otherwise, it prepares the data itself, either by decoding a string, or loading the contents of a file.\n\nIn your browser app, you need to handle any networking errors at this point. If the networking extension loads the content, parse it using your alternative browser engine to create rendering commands, that you send to the rendering process. In the rendering process, update the layer that the browser app is hosting.\n\nFinally, the web-content process replies to the browser app, telling the `WebContentView` to update its view.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/BrowserEngineKit\/developing-a-browser-app-that-uses-an-alternative-browser-engine\ncrawled: 2025-12-02T15:54:59Z\n---\n\n# Developing a browser app that uses an alternative browser engine\n\n**Sample Code**\n\nCreate a web browser app and associated extensions.\n\n## Overview\n\nThis sample code project demonstrates how a web browser app uses [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit] and [doc:\/\/com.apple.documentation\/documentation\/XPC] to communicate with its alternative browser engine over XPC, and implement a browser UI. The workspace contains four targets that define components of the browser app:\n\n- `BrowserExample` contains the main app that presents the UI.\n- `RenderingExtension` contains the rendering extension that the app uses to play media and render complex views.\n- `NetworkingExtension` contains the networking extension that the app uses to fetch data from remote websites.\n- `WebContentExtension` contains the web content extension that the app uses to parse HTML content and compile code just-in-time.\n\nFor more information on how these targets work together to support a custom web browser engine, see [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit\/designing-your-browser-architecture].\n\n### Configure the sample code project\n\nTo build a web browser that uses an alternative browser engine, including the one in this sample project, you need to apply for certain entitlements from WWDR. For more information on how to use these entitlements, see [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit\/creating-browser-extensions-in-xcode]. For information on applying for the entitlements, see [https:\/\/developer.apple.com\/support\/alternative-browser-engines].\n\nTo build the sample code project for a device, you must target an iPhone that supports the `arm64e` instruction set. `BrowserEngineKit` doesn’t support iPadOS, so this project won’t build for iPad.\n\n### Open a new tab\n\nWhen someone using the browser app opens a new tab, the browser app’s `BrowserPage` creates a `TabContentView` to display the tab’s contents, which gets its data from the tab’s `TabViewModel`.\n\n```swift\nstruct TabContentView: View {\n  \n  @ObservedObject var tab: TabViewModel\n  \n  var body: some View {\n    if let error = tab.error {\n      VStack {\n        Image(systemName: \"exclamationmark.triangle\")\n        Text(error.localizedDescription)\n      }\n    } else {\n      WebViewRepresentable(webView: tab.webView)\n    }\n  }\n}\n```\n\nThe `TabViewModel`‘s `webView` property is a `WebView` that displays the tab’s contents, which the `TabContentView` wraps in a `WebViewRepresentable` to display using SwiftUI.\n\nThe `WebView`’s initializer creates a `WebContentView`, which is the view that renders the HTML document in the tab. `WebContentView` calls `launchProcesses(id: PageID)`, which does the following:\n\n- Creates a new web content extension process to render the web content, and set up an XPC connection between the browser app and the web content process.\n\n```\n    let contentProcess = try await getOrLaunchContentProcess(pageID: id)\n    let contentConnection = try contentProcess.makeLibXPCConnection()\n    let contentProxy = WebContentExtensionProxy(connection: contentConnection)\n    try contentProxy.lockdown(version: lockdownVersion)\n```\n\n- Gets a connection to the single rendering-extension process, launching it if necessary.\n\n```\n    let renderingProcess = try await getOrLaunchRenderingProcess()\n    let renderingConnection = try renderingProcess.makeLibXPCConnection()\n    let renderingProxy = RenderingExtensionProxy(connection: renderingConnection)\n```\n\n- Asks the rendering process to create an anonymous XPC connection and sends an endpoint for the connection to the browser app.\n\n```\n    let renderingEndpoint = try await renderingProxy.getEndpoint()\n```\n\n- Repeats steps 2-3 for the single networking extension process, so that the browser app has an anonymous XPC connection endpoint for the networking process.\n\n```\n    let networkProcess = try await getOrLaunchNetworkProcess()\n    let networkConnection = try networkProcess.makeLibXPCConnection()\n    let networkProxy = NetworkingExtensionProxy(connection: networkConnection)\n    let networkEndpoint = try await networkProxy.getEndpoint()\n```\n\n- Sends a bootstrap message to the web-content process, handing it the endpoints to the other two extension processes, so that they can communicate directly.\n\n```\n    try await contentProxy.bootstrap(renderingExtension: renderingEndpoint, networkExtension: networkEndpoint)\n```\n\nThe web content process responds to the bootstrap message by retrieving the anonymous XPC connections for the other extensions from the endpoints it was sent by the host app, and sends them each “ping” messages to ensure the connections are valid.\n\n```\n  private func perform(bootstrap cmd: WebContentExtensionBootstrapCommand) async throws {\n    log.log(\"performing bootstrap\")\n    \n    if let renderingProxy = self.renderingProxy { \/\/ Connect to the Rendering extension if needed\n      log.log(\"already connected to rendering extension: \\(String(describing: renderingProxy.connection))\")\n    } else {\n      let endpoint = cmd.renderingEndpoint\n      log.log(\"connecting to rendering extension at: \\(String(describing: endpoint))\")\n      let connection = xpc_connection_create_from_endpoint(endpoint)\n      self.renderingProxy = .init(connection: connection)\n      try await connection.ping()\n      log.log(\"connected to rendering extension: \\(String(describing: connection))\")\n    }\n    \n    if let networkProxy = self.networkProxy {  \/\/ Connect to the Networking extension if needed\n      log.log(\"already connected to network extension: \\(String(describing: networkProxy.connection))\")\n    } else {\n      let endpoint = cmd.networkEndpoint\n      log.log(\"connecting to network extension at: \\(String(describing: endpoint))\")\n      let connection = xpc_connection_create_from_endpoint(endpoint)\n      self.networkProxy = .init(connection: connection)\n      try await connection.ping()\n      log.log(\"connected to network extension: \\(String(describing: connection))\")\n    }\n  }\n```\n\nFor more information on this process, see the section “Pass anonymous connection endpoints between extensions” in [doc:\/\/com.apple.documentation\/documentation\/BrowserEngineKit\/using-xpc-to-communicate-with-browser-extensions].\n\n### Load web content\n\nWhen someone using the browser app navigates to a new location, the `WebContentView` asks the proxy object that represents the web-content process to load the data at the location’s URL:\n\n```\n    let result = try await webContentProxy.load(destination: destination)\n```\n\nThis method sends a network load message to the web-content process:\n\n```\n    let task: WebContentExtensionTask = .load(destination: destination)\n    return try await connection.sendWithReply(task, decodingReplyAs: NetworkTaskResult.self)\n```\n\nThe web-content process checks what kind of data it’s trying to load. If it’s a URL, it asks the networking extension to load the content. Otherwise, it prepares the data itself, either by decoding a string, or loading the contents of a file.\n\n```\n    switch destination {\n    case .url(let url):\n      guard let networkProxy else {\n        throw CustomBrowserError(\"not connected to the network extension\")\n      }\n      return try await networkProxy.fetchData(from: url)\n    case .htmlString(let string):\n      guard let data = string.data(using: .utf8) else {\n        throw CustomBrowserError(\"failed to get utf8 data from string\")\n      }\n      return .init(response: nil, data: data, error: nil)\n    case .localFile(let file):\n      let data = try Data(contentsOf: file)\n      return .init(response: nil, data: data, error: nil)\n    }\n```\n\n\n\nIn your browser app, you need to handle any networking errors at this point. If the networking extension loads the content, parse it using your alternative browser engine to create rendering commands, that you send to the rendering process. In the rendering process, update the layer that the browser app is hosting.\n\nFinally, the web-content process replies to the browser app, telling the `WebContentView` to update its view.\n\n```\n    render(result)\n```\n\n## Essentials\n\n- **Designing your browser architecture**: Isolate privileged access to operating system resources and private data from untrusted code.\n- **Preparing your app to be the default web browser**: Configure your browser app so users can set it as the default on their device instead of Safari.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Isolate privileged access to operating system resources and private data from untrusted code.",
          "name" : "Designing your browser architecture",
          "url" : "https:\/\/developer.apple.com\/documentation\/BrowserEngineKit\/designing-your-browser-architecture"
        },
        {
          "description" : "Configure your browser app so users can set it as the default on their device instead of Safari.",
          "name" : "Preparing your app to be the default web browser",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/preparing-your-app-to-be-the-default-browser"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Developing a browser app that uses an alternative browser engine",
  "url" : "https:\/\/developer.apple.com\/documentation\/BrowserEngineKit\/developing-a-browser-app-that-uses-an-alternative-browser-engine"
}