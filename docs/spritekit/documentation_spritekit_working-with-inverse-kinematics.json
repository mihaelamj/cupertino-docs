{
  "abstract" : "Gain fine-tuned control of objects that are connected by joints.",
  "codeExamples" : [
    {
      "code" : "let sectionLength: CGFloat = 100\nlet sectionRect = CGRect(x: -10, y: -sectionLength,\n                         width: 20, height: sectionLength)\n   \nlet upperArm = SKShapeNode(rect: sectionRect)\nlet midArm = SKShapeNode(rect: sectionRect)\nlet lowerArm = SKShapeNode(rect: sectionRect)\nlet shoulder = SKShapeNode(circleOfRadius: 5)\nlet elbow = SKShapeNode(circleOfRadius: 5)\nlet wrist = SKShapeNode(circleOfRadius: 5)\nlet endEffector = SKShapeNode(circleOfRadius: 5)\n   \nscene.addChild(shoulder)\nshoulder.addChild(upperArm)\nupperArm.addChild(elbow)\nelbow.addChild(midArm)\nmidArm.addChild(wrist)\nwrist.addChild(lowerArm)\nlowerArm.addChild(endEffector)\n    \nshoulder.constraints = [SKConstraint.positionX(SKRange(constantValue: 320),\n                                               y: SKRange(constantValue: 320))]\n    \nlet positionConstraint = SKConstraint.positionY(SKRange(constantValue: -sectionLength))\nelbow.constraints =  [ positionConstraint ]\nwrist.constraints = [ positionConstraint ]\nendEffector.constraints = [ positionConstraint ]",
      "language" : "swift"
    },
    {
      "code" : "let reachAction = SKAction.reach(to: location,\n                                 rootNode: shoulder,\n                                 duration: 1.0)\n     \nendEffector.run(reachAction)",
      "language" : "swift"
    }
  ],
  "contentHash" : "df2127b27bf8815fb4e25fd286ee447f9893c23a9c78574dc5d335a4a5c7d952",
  "crawledAt" : "2025-12-05T22:33:21Z",
  "id" : "6C6305DD-CE98-4CAC-BEA4-173DC71B82EC",
  "kind" : "article",
  "language" : "swift",
  "module" : "SpriteKit",
  "overview" : "## Overview\n\nInverse kinematics (IK) is the use of equations to drive a system of connected components so that an *end effector* can reach a desired position. Imagine a robot arm formed of a series of sections hinged together. With traditional animation techniques, if you wanted the hand of the arm to reach to a specified position, you would have to code the rotations for each of the joints, which is a complex and time-consuming task. With IK, you simply need to specify the required position of the hand (which would be the end effector), and each individual joint is rotated to achieve the final position. In SpriteKit, complex IK animations can be generated with very little code.\n\n### Set Up the Joints and Constraints\n\nSpriteKit’s IK relies on two classes:\n\nThe following code creates a simple robot arm consisting of a fixed `shoulder` node and `upperArm`, `midArm`, and `lowerArm` sections that are joined by `elbow` and `wrist` nodes. At the end of the `wrist` is an `endEffector` node. The nodes are progressively children of each other.\n\nThe `shoulder` node is fixed to the scene with a constraint, and the other joints are offset in the `y` direction by the length of each section.\n\nIn its default position, the code above creates a node tree that looks like this (the shoulder is at the top, in blue, and the end effector is at the bottom, in yellow).\n\n\n\n### Run the Solver\n\nTo run the IK solver, you create an action passing it the desired location.\n\nGiven a location to the left of and slightly below the shoulder, the action finishes with the node tree looking like the following:\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SpriteKit\/working-with-inverse-kinematics\ncrawled: 2025-12-05T22:33:21Z\n---\n\n# Working with Inverse Kinematics\n\n**Article**\n\nGain fine-tuned control of objects that are connected by joints.\n\n## Overview\n\nInverse kinematics (IK) is the use of equations to drive a system of connected components so that an *end effector* can reach a desired position. Imagine a robot arm formed of a series of sections hinged together. With traditional animation techniques, if you wanted the hand of the arm to reach to a specified position, you would have to code the rotations for each of the joints, which is a complex and time-consuming task. With IK, you simply need to specify the required position of the hand (which would be the end effector), and each individual joint is rotated to achieve the final position. In SpriteKit, complex IK animations can be generated with very little code.\n\n### Set Up the Joints and Constraints\n\nSpriteKit’s IK relies on two classes:\n\n- [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKAction] object `reach` methods that solve an IK system (that run the system to make the end effector reach a specified position).\n- [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKConstraint] objects that constrain the position or orientation of nodes.\n\nThe following code creates a simple robot arm consisting of a fixed `shoulder` node and `upperArm`, `midArm`, and `lowerArm` sections that are joined by `elbow` and `wrist` nodes. At the end of the `wrist` is an `endEffector` node. The nodes are progressively children of each other.\n\nThe `shoulder` node is fixed to the scene with a constraint, and the other joints are offset in the `y` direction by the length of each section.\n\n```swift\nlet sectionLength: CGFloat = 100\nlet sectionRect = CGRect(x: -10, y: -sectionLength,\n                         width: 20, height: sectionLength)\n   \nlet upperArm = SKShapeNode(rect: sectionRect)\nlet midArm = SKShapeNode(rect: sectionRect)\nlet lowerArm = SKShapeNode(rect: sectionRect)\nlet shoulder = SKShapeNode(circleOfRadius: 5)\nlet elbow = SKShapeNode(circleOfRadius: 5)\nlet wrist = SKShapeNode(circleOfRadius: 5)\nlet endEffector = SKShapeNode(circleOfRadius: 5)\n   \nscene.addChild(shoulder)\nshoulder.addChild(upperArm)\nupperArm.addChild(elbow)\nelbow.addChild(midArm)\nmidArm.addChild(wrist)\nwrist.addChild(lowerArm)\nlowerArm.addChild(endEffector)\n    \nshoulder.constraints = [SKConstraint.positionX(SKRange(constantValue: 320),\n                                               y: SKRange(constantValue: 320))]\n    \nlet positionConstraint = SKConstraint.positionY(SKRange(constantValue: -sectionLength))\nelbow.constraints =  [ positionConstraint ]\nwrist.constraints = [ positionConstraint ]\nendEffector.constraints = [ positionConstraint ]\n```\n\nIn its default position, the code above creates a node tree that looks like this (the shoulder is at the top, in blue, and the end effector is at the bottom, in yellow).\n\n\n\n### Run the Solver\n\nTo run the IK solver, you create an action passing it the desired location.\n\n```swift\nlet reachAction = SKAction.reach(to: location,\n                                 rootNode: shoulder,\n                                 duration: 1.0)\n     \nendEffector.run(reachAction)\n```\n\nGiven a location to the left of and slightly below the shoulder, the action finishes with the node tree looking like the following:\n\n\n\n## Physics Joints\n\n- **SKPhysicsJoint**: The abstract superclass for objects that connect physics bodies.\n- **SKPhysicsJointFixed**: A joint that fuses two physics bodies together at a reference point.\n- **SKPhysicsJointLimit**: A joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.\n- **SKPhysicsJointPin**: A joint that pins together two physics bodies, allowing independent rotation.\n- **SKPhysicsJointSliding**: A joint that allows two physics bodies to slide along an axis.\n- **SKPhysicsJointSpring**: A joint that simulates a spring connecting two physics bodies.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The abstract superclass for objects that connect physics bodies.",
          "name" : "SKPhysicsJoint",
          "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/SKPhysicsJoint"
        },
        {
          "description" : "A joint that fuses two physics bodies together at a reference point.",
          "name" : "SKPhysicsJointFixed",
          "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/SKPhysicsJointFixed"
        },
        {
          "description" : "A joint that imposes a maximum distance between two physics bodies, as if they were connected by a rope.",
          "name" : "SKPhysicsJointLimit",
          "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/SKPhysicsJointLimit"
        },
        {
          "description" : "A joint that pins together two physics bodies, allowing independent rotation.",
          "name" : "SKPhysicsJointPin",
          "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/SKPhysicsJointPin"
        },
        {
          "description" : "A joint that allows two physics bodies to slide along an axis.",
          "name" : "SKPhysicsJointSliding",
          "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/SKPhysicsJointSliding"
        },
        {
          "description" : "A joint that simulates a spring connecting two physics bodies.",
          "name" : "SKPhysicsJointSpring",
          "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/SKPhysicsJointSpring"
        }
      ],
      "title" : "Physics Joints"
    }
  ],
  "source" : "appleJSON",
  "title" : "Working with Inverse Kinematics",
  "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/working-with-inverse-kinematics"
}