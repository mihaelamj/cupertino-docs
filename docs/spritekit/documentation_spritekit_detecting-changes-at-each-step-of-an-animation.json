{
  "abstract" : "Get notified of a property change on your node subclass and retrieve the amount of change.",
  "codeExamples" : [
    {
      "code" : "class MovingNode: SKSpriteNode {\n    override var position: CGPoint {\n        didSet {\n            \/\/ code to react to position change\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let node = SKNode()\nvar nodePosition = CGPoint()\n     \nfunc update(_ currentTime: TimeInterval, for scene: SKScene) {\n    nodePosition = node.position\n}\n     \nfunc didEvaluateActions(for scene: SKScene) {\n    let distance = hypot(node.position.x - nodePosition.x,\n                         node.position.y - nodePosition.y)\n    \n    if distance > 0 {\n        \/\/ code to react to position change\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "6e6927f7a24872ea1d20fe1223575c97236c1e14d70eecd4c51246da40131d0f",
  "crawledAt" : "2025-12-08T01:04:16Z",
  "id" : "7697EA11-78F9-47C2-A30E-5B0F117AA098",
  "kind" : "article",
  "language" : "swift",
  "module" : "SpriteKit",
  "overview" : "## Overview\n\nGenerally, actions do not call public methods on nodes. For example, if you want to subclass [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKNode] to respond to a [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKAction\/move(to:duration:)] action, you might consider overriding its [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKNode\/position] property to add a `didSet` observer (see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Swift\/Conceptual\/Swift_Programming_Language\/Inheritance.html#\/\/apple_ref\/doc\/uid\/TP40014097-CH17-ID201]).\n\nHowever, because a move action that’s running on an instance of `MovingNode` (defined in the code listing above) doesn’t set its position, the observer isn’t invoked and thus, your code is never executed.\n\nIn this case, the solution is to use [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKSceneDelegate] and compare the node’s position across two of its callbacks. You save the node’s initial position in [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKSceneDelegate\/update(_:for:)], which is called at the beginning of each frame, then calculate any change in position in [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKSceneDelegate\/didEvaluateActions(for:)], which is called after actions have been evaluated.\n\nThe following code demonstrates an example of this strategy:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SpriteKit\/detecting-changes-at-each-step-of-an-animation\ncrawled: 2025-12-08T01:04:16Z\n---\n\n# Detecting Changes at Each Step of an Animation\n\n**Article**\n\nGet notified of a property change on your node subclass and retrieve the amount of change.\n\n## Overview\n\nGenerally, actions do not call public methods on nodes. For example, if you want to subclass [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKNode] to respond to a [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKAction\/move(to:duration:)] action, you might consider overriding its [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKNode\/position] property to add a `didSet` observer (see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Swift\/Conceptual\/Swift_Programming_Language\/Inheritance.html#\/\/apple_ref\/doc\/uid\/TP40014097-CH17-ID201]).\n\n```swift\nclass MovingNode: SKSpriteNode {\n    override var position: CGPoint {\n        didSet {\n            \/\/ code to react to position change\n        }\n    }\n}\n```\n\nHowever, because a move action that’s running on an instance of `MovingNode` (defined in the code listing above) doesn’t set its position, the observer isn’t invoked and thus, your code is never executed.\n\nIn this case, the solution is to use [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKSceneDelegate] and compare the node’s position across two of its callbacks. You save the node’s initial position in [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKSceneDelegate\/update(_:for:)], which is called at the beginning of each frame, then calculate any change in position in [doc:\/\/com.apple.spritekit\/documentation\/SpriteKit\/SKSceneDelegate\/didEvaluateActions(for:)], which is called after actions have been evaluated.\n\nThe following code demonstrates an example of this strategy:\n\n```swift\nlet node = SKNode()\nvar nodePosition = CGPoint()\n     \nfunc update(_ currentTime: TimeInterval, for scene: SKScene) {\n    nodePosition = node.position\n}\n     \nfunc didEvaluateActions(for scene: SKScene) {\n    let distance = hypot(node.position.x - nodePosition.x,\n                         node.position.y - nodePosition.y)\n    \n    if distance > 0 {\n        \/\/ code to react to position change\n    }\n}\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Detecting Changes at Each Step of an Animation",
  "url" : "https:\/\/developer.apple.com\/documentation\/SpriteKit\/detecting-changes-at-each-step-of-an-animation"
}