{
  "abstract" : "Use App Intents to register actions for your app.",
  "codeExamples" : [
    {
      "code" : "enum WorkoutEnum: String, AppEnum {\n    \n    \/\/ List the types of workout your app supports.\n    case running\n\n    static var typeDisplayRepresentation: TypeDisplayRepresentation = \"Workout\"\n\n    \/\/ Define the display representation for each of the workouts your app supports.\n    static var caseDisplayRepresentations: [WorkoutEnum: DisplayRepresentation] =\n        [.running: DisplayRepresentation(title: \"Running\", subtitle: \"outside run\")]\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyStartWorkoutIntent: StartWorkoutIntent {\n\n    \/\/ Define the intent's title.\n    static var title: LocalizedStringResource = \"Start Workout\"\n    \n    \/\/ Define a list of start workout intents that appear below the First Press settings when someone sets your app as the workout app in Settings > Action Button.\n\n    static var suggestedWorkouts: [MyStartWorkoutIntent] = [MyStartWorkoutIntent()]\n\n    \/\/ Define a parameter that specifies the type of workout that this intent starts.\n    @Parameter(title: \"Type of Workout\")\n    var workoutStyle: WorkoutEnum\n\n    \/\/ Define an init method that sets the default workout type.\n    init() {\n        workoutStyle = .running\n    }\n\n    \/\/ Add the display representation, and the perform method here.\n}",
      "language" : "swift"
    },
    {
      "code" : "var displayRepresentation: DisplayRepresentation {\n    WorkoutEnum.caseDisplayRepresentations[workoutStyle] ??\n    DisplayRepresentation(title: \"Unknown\")\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Define the method that the system calls when it performs the intent.\nfunc perform() async throws -> some IntentResult {\n    logger.debug(\"*** Performing a Start Intent. ***\")\n    \n    \/\/ Start a workout session inside the perform method.\n    let workoutManager = MyWorkoutManager.shared\n    try await workoutManager.startWorkout(type: workoutStyle)\n    \n    \/\/ Schedule a task to request authorization and then set up the data source and start collecting data from the workout.\n    Task {\n        await workoutManager.requestAuthorization()\n        \n        do {\n            try await workoutManager.startCollectingData()\n        } catch {\n            fatalError(\"*** An error occurred while setting up the data source: \\(error.localizedDescription) ***\")\n        }\n    }\n    \n    \/\/ Return a successful result.\n    return .result()\n}",
      "language" : "swift"
    },
    {
      "code" : "func startWorkout(type: WorkoutEnum) throws {\n    logger.debug(\"*** Start a workout of type \\(type.rawValue) ***\")\n    \n    logger.debug(\"==> Creating the workout configuration.\")\n    let configuration = HKWorkoutConfiguration()\n    configuration.activityType = .running\n    configuration.locationType = .outdoor\n    \n    self.configuration = configuration\n    \n    logger.debug(\"==> Creating the workout session.\")\n    let session = try HKWorkoutSession(healthStore: store, configuration: configuration)\n    \n    session.delegate = self\n    self.session = session\n    workoutType = type\n    \n    logger.debug(\"==> Starting the session.\")\n    session.startActivity(with: Date())\n}",
      "language" : "swift"
    },
    {
      "code" : "func requestAuthorization() async {\n    logger.debug(\"*** Requesting Authorization ***\")\n    \n    \/\/ The quantity type to write to the health store.\n    let typesToShare: Set = [\n        HKQuantityType.workoutType()\n    ]\n\n    \/\/ The quantity types to read from the health store.\n    let typesToRead: Set = [\n        HKQuantityType(.heartRate),\n        HKQuantityType(.activeEnergyBurned),\n        HKQuantityType(.distanceWalkingRunning)\n    ]\n    \n    guard HKHealthStore.isHealthDataAvailable() else {\n        logger.debug(\"*** HealthKit is not supported on this device. ***\")\n        return\n    }\n    \n    do {\n        try await store.requestAuthorization(toShare: typesToShare, read: typesToRead)\n    } catch {\n        fatalError(\"*** An error occurred while requesting authorization to read and save data: \\(error.localizedDescription) ***\")\n    }\n\n    enabled = true\n}",
      "language" : "swift"
    },
    {
      "code" : "func startCollectingData() async throws {\n    precondition(enabled == true)\n    guard let configuration else { fatalError(\"*** You need to create a workout configuration before calling this method. ***\") }\n    guard let session else { fatalError(\"*** You need to create a session before calling this method. ***\") }\n    \n    logger.debug(\"==> Setting the session's data source.\")\n    let builder = session.associatedWorkoutBuilder()\n    builder.dataSource = HKLiveWorkoutDataSource(healthStore: store,\n                                                 workoutConfiguration: configuration)\n    \n    builder.delegate = self\n    \n    logger.debug(\"==> Begin collecting data.\")\n    try await builder.beginCollection(at: Date())\n    \n    self.builder = builder\n\n    logger.debug(\"==> Donate the mark lap intent as the Action button's next action.\")\n    try await MyStartWorkoutIntent().donate(result: .result(actionButtonIntent: MyMarkLapIntent()))\n}",
      "language" : "swift"
    },
    {
      "code" : "enum WorkoutEnum: String, AppEnum {\n\n    \/\/ List the types of workout your app supports.\n    case walking\n    case running\n    case swimming\n    case cycling\n\n    static var typeDisplayRepresentation: TypeDisplayRepresentation = \"Workout\"\n\n    \/\/ Set the display representation here.\n}",
      "language" : "swift"
    },
    {
      "code" : "static var caseDisplayRepresentations: [WorkoutEnum: DisplayRepresentation] =\n[.walking: DisplayRepresentation(title: \"Walking\", subtitle: \"outside walk\"),\n .running: DisplayRepresentation(title: \"Running\", subtitle: \"outside run\"),\n .swimming: DisplayRepresentation(title: \"Swimming\", subtitle: \"lap swim\"),\n .cycling: DisplayRepresentation(title: \"Cycling\", subtitle: \"outside cycling\")\n]",
      "language" : "swift"
    },
    {
      "code" : "static var suggestedWorkouts: [MyStartWorkoutIntent] =\n[MyStartWorkoutIntent(style: .walking),\n MyStartWorkoutIntent(style: .running),\n MyStartWorkoutIntent(style: .swimming),\n MyStartWorkoutIntent(style: .cycling)]",
      "language" : "swift"
    },
    {
      "code" : "func perform() async throws -> some IntentResult {\n\n    let workoutManager = MyWorkoutManager.shared\n    await workoutManager.requestAuthorization()\n    await workoutManager.startWorkout(type: workoutStyle)\n    return .result()\n}",
      "language" : "swift"
    },
    {
      "code" : "func startWorkout(type: WorkoutEnum) throws {\n    logger.debug(\"*** Should be starting a workout of type \\(type.rawValue) ***\")\n    \n    logger.debug(\"==> Creating the workout configuration.\")\n    let configuration = HKWorkoutConfiguration()\n    \n    switch type {\n    case .walking:\n        configuration.activityType = .walking\n    case .running:\n        configuration.activityType = .running\n    case .swimming:\n        configuration.activityType = .swimming\n    case .cycling:\n        configuration.activityType = .cycling\n    }\n    configuration.activityType = type.activityType()\n    \n    if type == .swimming {\n        configuration.locationType = .indoor\n        configuration.swimmingLocationType = .pool\n        configuration.lapLength = HKQuantity(unit: HKUnit.yard(), doubleValue: 25.0)\n    } else {\n        configuration.locationType = .outdoor\n    }\n    \n    self.configuration = configuration\n    \n    logger.debug(\"==> Creating the workout session.\")\n    let session = try HKWorkoutSession(healthStore: store, configuration: configuration)\n    \n    session.delegate = self\n    self.session = session\n    workoutType = type\n    \n    logger.debug(\"==> Starting the session.\")\n    session.startActivity(with: Date())\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ The quantity types to read from the health store.\nlet typesToRead: Set = [\n    HKQuantityType(.heartRate),\n    HKQuantityType(.activeEnergyBurned),\n    HKQuantityType(.distanceCycling),\n    HKQuantityType(.distanceSwimming),\n    HKQuantityType(.distanceWalkingRunning)\n]",
      "language" : "swift"
    },
    {
      "code" : "struct MarkLapIntent: AppIntent {\n    static var title: LocalizedStringResource = \"Mark Lap\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Perform a mark lap intent. ***\")\n        await MyWorkoutManager.shared.markLap(at: Date())\n        return .result()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "logger.debug(\"==> Donate the mark lap intent as the Action button's next action.\")\ntry await MyStartWorkoutIntent().donate(result: .result(actionButtonIntent: MyMarkLapIntent()))",
      "language" : "swift"
    },
    {
      "code" : "struct MyPauseWorkoutIntent: PauseWorkoutIntent {\n    static var title: LocalizedStringResource = \"Pause Workout\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Performing a pause intent. ***\")\n        await MyWorkoutManager.shared.pauseWorkout()\n        return .result()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyResumeWorkoutIntent: ResumeWorkoutIntent {\n    static var title: LocalizedStringResource = \"Resume Workout\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Performing a resume intent. ***\")\n        await MyWorkoutManager.shared.resumeWorkout()\n        return .result()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyStartDiveSessionIntent: StartDiveIntent {\n\n    static var title: LocalizedStringResource = \"Starting a dive session.\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Starting a dive session. ***\")\n\n        await DiveManager.shared.start()\n        return .result(actionButtonIntent: MyCollectSubmergedDataIntent())\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyStartWorkoutIntent: StartWorkoutIntent {\n  @Dependency var workoutManager: MyWorkoutManager\n\n  \/\/ Add remaining code here.\n}",
      "language" : "swift"
    },
    {
      "code" : "AppDependencyManager.shared.add { MyWorkoutManager() }",
      "language" : "swift"
    }
  ],
  "contentHash" : "c86e8f76d6958cee9fec297c89364d06699bb70392cf581c214f667d3388045c",
  "crawledAt" : "2025-12-04T09:39:02Z",
  "id" : "9189ECD6-2E10-4447-99D2-FF6222DCE6CF",
  "kind" : "article",
  "language" : "swift",
  "module" : "App Intents",
  "overview" : "## Overview\n\nOn Apple Watch Ultra, people can specify the action that the system performs when they press the Action button. By default, the watch provides actions for starting workouts, starting dives, starting a backtrack navigation session, setting a waypoint, turning on the flashlight, and running a shortcut from the Shortcuts app. To add your dive or workout app to the list of apps that appear when someone chooses Settings > Action Button, use App Intents to register actions for your app.\n\nFor workout apps, you can implement the following protocols:\n\nFor dive apps, you can implement the following protocols:\n\n### Start a new workout session\n\nStart by creating either an [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEnum] or an [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] that defines the types of workouts that your app supports. If your app supports only a single workout, you can create an enumeration with a single case. Also define the display representation for each type of workout that your app supports. Apple Watch Ultra shows the case description’s title and subtitle below the First Press settings when someone sets your app as the workout app in Settings > Action Button.\n\nNext, create a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent] protocol. Your implementation needs to define the intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title], a list of [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/suggestedWorkouts], and a parameter that contains the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/workoutStyle-swift.property].\n\nYou can dynamically change the list of suggested workouts by changing the value of the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/suggestedWorkouts] property and then calling [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/invalidateSuggestedWorkouts()], which tells the system to reread the suggested workouts.\n\nNext, set the display strings for the intent by defining the `displayRepresentation` just after the intent’s initializer.\n\nThen, implement your intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method. The system calls this method when anything starts the intent. In your implementation, you have 30 seconds to start a workout session and return a successful value. If you don’t start a workout session in that time, the system displays an error message, but the app remains in the foreground. People can start a workout session directly from the app, but without a session, the app goes to the background the next time they drop their wrist.\n\nThe start workout intent becomes available as soon as someone downloads your app. This means they can set up the Action button and run your start workout intent without ever launching your app.\n\nSimilarly, if you update your app and change the data types that the workout session uses, someone can launch the updated workout from the Action button without launching your app.\n\nTo ensure that your app requests authorization for the current set of HealthKit data types it intends to use during its workout sessions, you need to schedule an authorization request from within your intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method. Because someone using your app doesn’t have access to its user interface until after the `perform()` method returns, you need to schedule the request authorization using a [doc:\/\/com.apple.documentation\/documentation\/Swift\/Task].\n\nBefore authorizing the HealthKit data, create and start your workout session.\n\nThe code example above creates a workout configuration for an outdoor run. It then uses the configuration to create the workout session, assigns a workout session delegate to receive state change and errors from the workout, and starts the session.\n\nBecause the app hasn’t created a data source for the workout session, the session doesn’t generate any data.\n\nNext, request authorization for all the HealthKit data types that your workout sessions use.\n\nThis authorization request can take an arbitrarily long amount of time. Any time you request authorization for new data, the system displays an authorization sheet, and waits until someone either authorizes the data or dismisses the sheet. However, if someone has already authorized the requested data types, the system returns immediately.\n\nAfter the authorization request finishes, set up the data source, assign a delegate to receive data from the workout builder, and begin collecting data from the workout.\n\nIn the code example above, the last line donates the `MyMarkLapIntent()` as the next action for the Action button. Donating the next action is described in more detail below.\n\nAfter implementing your [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent], build and run your app to load it onto the test device or Simulator. Then, on the test device, choose Settings > Action Button. Tap Action and choose Workout, then tap App and choose your app.\n\n\n\nThe device starts a new workout session when you press the Action button.\n\n### Support multiple workout types\n\nYour app can provide a list of suggested workout types, letting people associate a particular workout type with the Action button.\n\nTo suggest multiple workout types, start by defining the different types of workouts that your app supports in your [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEnum] implementation.\n\nThen set a display representation for each case.\n\nNext, in your [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent] implementation, define the set of suggested workouts.\n\nThen, in the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, check the intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/workoutStyle-swift.property] and create the corresponding workout session.\n\nCreate a configuration for the specified type of workout.\n\nAnd, finally, request authorization for all the data types that your workout sessions use.\n\nBuild and run your app again. When you open the Action button settings, you can specify a particular workout for the First Press > Workout setting.\n\n\n\nAnd pressing the Action button launches the selected type of workout.\n\n### Donate the next action\n\nApple Watch Ultra runs the next action when someone presses the Action button while a workout or dive session is already running. This means the first time someone presses the Action button, the system starts your session. If they press the Action button any other time during the session, it performs the next action.\n\nTo set the next action, implement a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent] protocol.\n\nThis intent needs a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title] property that provides a localized description of the action, and a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, which the system calls when it performs the intent.\n\nNext, donate the app intent as the current session’s next action. For example, in your start workout intent’s `perform()` method, you can donate the next action for the new session by returning [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/IntentResult\/result(actionButtonIntent:)].\n\nHowever, in most cases you want to donate a next action regardless of whether the user presses the Action button or launches the session from within your app. To ensure that your app donates the correct intent, simply return `.result()` from your start intent, and then donate the next intent as soon as the session starts.\n\nPrevious code examples show how to donate the `MyMarkLapIntent` in its `startCollectingData()` method. The app then calls this method when starting a workout from the Action button or from the app’s user interface.\n\nYou can donate as many action intents as you need; however, your app can use only the most recently donated intent as the next action. Donating a new intent changes the next action.\n\n### Pause and resume a workout\n\nApple Watch Ultra supports pausing and resuming a current workout session by simultaneously pressing both the Action button and the side button.\n\nTo implement the pause action, create a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/PauseWorkoutIntent] protocol.\n\nThis intent needs a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title] property that provides a localized description of the action, and a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, which the system calls when it performs the intent.\n\nSimilarly, to implement the resume action, create a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/ResumeWorkoutIntent] protocol.\n\nIf your app doesn’t implement structures that adopt these protocols, the system ignores simultaneous presses.\n\n### Start a new dive session\n\nDive sessions work similarly to workout sessions. To start a dive session, implement a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartDiveIntent] protocol. Typically, people start the dive session just before entering the water. Your app can then donate App Intents that help them use your app while in the water. For example, while in the water they can’t use the touch screen, but the Action button and Digital Crown function normally.\n\nThis intent needs a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title] property that provides a localized description of the action, and a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, which the system calls when it performs the intent.\n\nTo read live depth, water pressure, and water temperature data, see [doc:\/\/com.apple.documentation\/documentation\/CoreMotion\/accessing-submersion-data].\n\nUnlike workout sessions, the start dive intent supports only a single type of session. You can donate next actions for your dive session; however, you can’t create intents to pause or resume the session.\n\n### Passing data to the intents\n\nThe previous examples use singleton objects to share data between the different parts of your app; however, App Intents support dependency injection, letting you define the data in your main app, and access it in your intents.\n\nIn your intents, create a property that uses the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppDependency] property wrapper.\n\nThen, as early as possible when your app launches, use the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppDependencyManager] to define the dependency.\n\nYou can set the dependency in your app’s [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/applicationDidFinishLaunching()] method. Or, if your app uses SwiftUI life cycles, add an `init()` method to your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App] structure, and set it there.\n\nOne of the main advantages of dependency injection is that you can easily replace your main data object with a mock object during testing.\n\n### Debug intents\n\nTo see console output and respond to breakpoints in Xcode, use the following steps to debug your intents:\n\nAny logging from your intents appears in Xcode’s console. The system also pauses execution for any breakpoints you set in Xcode.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/appintents\/actionbuttonarticle\ncrawled: 2025-12-04T09:39:02Z\n---\n\n# Responding to the Action button on Apple Watch Ultra\n\n**Article**\n\nUse App Intents to register actions for your app.\n\n## Overview\n\nOn Apple Watch Ultra, people can specify the action that the system performs when they press the Action button. By default, the watch provides actions for starting workouts, starting dives, starting a backtrack navigation session, setting a waypoint, turning on the flashlight, and running a shortcut from the Shortcuts app. To add your dive or workout app to the list of apps that appear when someone chooses Settings > Action Button, use App Intents to register actions for your app.\n\nFor workout apps, you can implement the following protocols:\n\n\n\nFor dive apps, you can implement the following protocols:\n\n\n\n\n\n### Start a new workout session\n\nStart by creating either an [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEnum] or an [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] that defines the types of workouts that your app supports. If your app supports only a single workout, you can create an enumeration with a single case. Also define the display representation for each type of workout that your app supports. Apple Watch Ultra shows the case description’s title and subtitle below the First Press settings when someone sets your app as the workout app in Settings > Action Button.\n\n```swift\nenum WorkoutEnum: String, AppEnum {\n    \n    \/\/ List the types of workout your app supports.\n    case running\n\n    static var typeDisplayRepresentation: TypeDisplayRepresentation = \"Workout\"\n\n    \/\/ Define the display representation for each of the workouts your app supports.\n    static var caseDisplayRepresentations: [WorkoutEnum: DisplayRepresentation] =\n        [.running: DisplayRepresentation(title: \"Running\", subtitle: \"outside run\")]\n}\n```\n\nNext, create a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent] protocol. Your implementation needs to define the intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title], a list of [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/suggestedWorkouts], and a parameter that contains the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/workoutStyle-swift.property].\n\n```swift\nstruct MyStartWorkoutIntent: StartWorkoutIntent {\n\n    \/\/ Define the intent's title.\n    static var title: LocalizedStringResource = \"Start Workout\"\n    \n    \/\/ Define a list of start workout intents that appear below the First Press settings when someone sets your app as the workout app in Settings > Action Button.\n\n    static var suggestedWorkouts: [MyStartWorkoutIntent] = [MyStartWorkoutIntent()]\n\n    \/\/ Define a parameter that specifies the type of workout that this intent starts.\n    @Parameter(title: \"Type of Workout\")\n    var workoutStyle: WorkoutEnum\n\n    \/\/ Define an init method that sets the default workout type.\n    init() {\n        workoutStyle = .running\n    }\n\n    \/\/ Add the display representation, and the perform method here.\n}\n```\n\n\n\nYou can dynamically change the list of suggested workouts by changing the value of the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/suggestedWorkouts] property and then calling [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/invalidateSuggestedWorkouts()], which tells the system to reread the suggested workouts.\n\nNext, set the display strings for the intent by defining the `displayRepresentation` just after the intent’s initializer.\n\n```swift\nvar displayRepresentation: DisplayRepresentation {\n    WorkoutEnum.caseDisplayRepresentations[workoutStyle] ??\n    DisplayRepresentation(title: \"Unknown\")\n}\n```\n\nThen, implement your intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method. The system calls this method when anything starts the intent. In your implementation, you have 30 seconds to start a workout session and return a successful value. If you don’t start a workout session in that time, the system displays an error message, but the app remains in the foreground. People can start a workout session directly from the app, but without a session, the app goes to the background the next time they drop their wrist.\n\n```swift\n\/\/ Define the method that the system calls when it performs the intent.\nfunc perform() async throws -> some IntentResult {\n    logger.debug(\"*** Performing a Start Intent. ***\")\n    \n    \/\/ Start a workout session inside the perform method.\n    let workoutManager = MyWorkoutManager.shared\n    try await workoutManager.startWorkout(type: workoutStyle)\n    \n    \/\/ Schedule a task to request authorization and then set up the data source and start collecting data from the workout.\n    Task {\n        await workoutManager.requestAuthorization()\n        \n        do {\n            try await workoutManager.startCollectingData()\n        } catch {\n            fatalError(\"*** An error occurred while setting up the data source: \\(error.localizedDescription) ***\")\n        }\n    }\n    \n    \/\/ Return a successful result.\n    return .result()\n}\n```\n\nThe start workout intent becomes available as soon as someone downloads your app. This means they can set up the Action button and run your start workout intent without ever launching your app.\n\nSimilarly, if you update your app and change the data types that the workout session uses, someone can launch the updated workout from the Action button without launching your app.\n\nTo ensure that your app requests authorization for the current set of HealthKit data types it intends to use during its workout sessions, you need to schedule an authorization request from within your intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method. Because someone using your app doesn’t have access to its user interface until after the `perform()` method returns, you need to schedule the request authorization using a [doc:\/\/com.apple.documentation\/documentation\/Swift\/Task].\n\n\n\nBefore authorizing the HealthKit data, create and start your workout session.\n\n```swift\nfunc startWorkout(type: WorkoutEnum) throws {\n    logger.debug(\"*** Start a workout of type \\(type.rawValue) ***\")\n    \n    logger.debug(\"==> Creating the workout configuration.\")\n    let configuration = HKWorkoutConfiguration()\n    configuration.activityType = .running\n    configuration.locationType = .outdoor\n    \n    self.configuration = configuration\n    \n    logger.debug(\"==> Creating the workout session.\")\n    let session = try HKWorkoutSession(healthStore: store, configuration: configuration)\n    \n    session.delegate = self\n    self.session = session\n    workoutType = type\n    \n    logger.debug(\"==> Starting the session.\")\n    session.startActivity(with: Date())\n}\n```\n\nThe code example above creates a workout configuration for an outdoor run. It then uses the configuration to create the workout session, assigns a workout session delegate to receive state change and errors from the workout, and starts the session.\n\nBecause the app hasn’t created a data source for the workout session, the session doesn’t generate any data.\n\nNext, request authorization for all the HealthKit data types that your workout sessions use.\n\n```swift\nfunc requestAuthorization() async {\n    logger.debug(\"*** Requesting Authorization ***\")\n    \n    \/\/ The quantity type to write to the health store.\n    let typesToShare: Set = [\n        HKQuantityType.workoutType()\n    ]\n\n    \/\/ The quantity types to read from the health store.\n    let typesToRead: Set = [\n        HKQuantityType(.heartRate),\n        HKQuantityType(.activeEnergyBurned),\n        HKQuantityType(.distanceWalkingRunning)\n    ]\n    \n    guard HKHealthStore.isHealthDataAvailable() else {\n        logger.debug(\"*** HealthKit is not supported on this device. ***\")\n        return\n    }\n    \n    do {\n        try await store.requestAuthorization(toShare: typesToShare, read: typesToRead)\n    } catch {\n        fatalError(\"*** An error occurred while requesting authorization to read and save data: \\(error.localizedDescription) ***\")\n    }\n\n    enabled = true\n}\n```\n\nThis authorization request can take an arbitrarily long amount of time. Any time you request authorization for new data, the system displays an authorization sheet, and waits until someone either authorizes the data or dismisses the sheet. However, if someone has already authorized the requested data types, the system returns immediately.\n\nAfter the authorization request finishes, set up the data source, assign a delegate to receive data from the workout builder, and begin collecting data from the workout.\n\n```swift\nfunc startCollectingData() async throws {\n    precondition(enabled == true)\n    guard let configuration else { fatalError(\"*** You need to create a workout configuration before calling this method. ***\") }\n    guard let session else { fatalError(\"*** You need to create a session before calling this method. ***\") }\n    \n    logger.debug(\"==> Setting the session's data source.\")\n    let builder = session.associatedWorkoutBuilder()\n    builder.dataSource = HKLiveWorkoutDataSource(healthStore: store,\n                                                 workoutConfiguration: configuration)\n    \n    builder.delegate = self\n    \n    logger.debug(\"==> Begin collecting data.\")\n    try await builder.beginCollection(at: Date())\n    \n    self.builder = builder\n\n    logger.debug(\"==> Donate the mark lap intent as the Action button's next action.\")\n    try await MyStartWorkoutIntent().donate(result: .result(actionButtonIntent: MyMarkLapIntent()))\n}\n```\n\nIn the code example above, the last line donates the `MyMarkLapIntent()` as the next action for the Action button. Donating the next action is described in more detail below.\n\nAfter implementing your [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent], build and run your app to load it onto the test device or Simulator. Then, on the test device, choose Settings > Action Button. Tap Action and choose Workout, then tap App and choose your app.\n\n\n\nThe device starts a new workout session when you press the Action button.\n\n\n\n### Support multiple workout types\n\nYour app can provide a list of suggested workout types, letting people associate a particular workout type with the Action button.\n\nTo suggest multiple workout types, start by defining the different types of workouts that your app supports in your [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEnum] implementation.\n\n```swift\nenum WorkoutEnum: String, AppEnum {\n\n    \/\/ List the types of workout your app supports.\n    case walking\n    case running\n    case swimming\n    case cycling\n\n    static var typeDisplayRepresentation: TypeDisplayRepresentation = \"Workout\"\n\n    \/\/ Set the display representation here.\n}\n```\n\nThen set a display representation for each case.\n\n```swift\nstatic var caseDisplayRepresentations: [WorkoutEnum: DisplayRepresentation] =\n[.walking: DisplayRepresentation(title: \"Walking\", subtitle: \"outside walk\"),\n .running: DisplayRepresentation(title: \"Running\", subtitle: \"outside run\"),\n .swimming: DisplayRepresentation(title: \"Swimming\", subtitle: \"lap swim\"),\n .cycling: DisplayRepresentation(title: \"Cycling\", subtitle: \"outside cycling\")\n]\n```\n\nNext, in your [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent] implementation, define the set of suggested workouts.\n\n```swift\nstatic var suggestedWorkouts: [MyStartWorkoutIntent] =\n[MyStartWorkoutIntent(style: .walking),\n MyStartWorkoutIntent(style: .running),\n MyStartWorkoutIntent(style: .swimming),\n MyStartWorkoutIntent(style: .cycling)]\n```\n\nThen, in the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, check the intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartWorkoutIntent\/workoutStyle-swift.property] and create the corresponding workout session.\n\n```swift\nfunc perform() async throws -> some IntentResult {\n\n    let workoutManager = MyWorkoutManager.shared\n    await workoutManager.requestAuthorization()\n    await workoutManager.startWorkout(type: workoutStyle)\n    return .result()\n}\n```\n\nCreate a configuration for the specified type of workout.\n\n```swift\nfunc startWorkout(type: WorkoutEnum) throws {\n    logger.debug(\"*** Should be starting a workout of type \\(type.rawValue) ***\")\n    \n    logger.debug(\"==> Creating the workout configuration.\")\n    let configuration = HKWorkoutConfiguration()\n    \n    switch type {\n    case .walking:\n        configuration.activityType = .walking\n    case .running:\n        configuration.activityType = .running\n    case .swimming:\n        configuration.activityType = .swimming\n    case .cycling:\n        configuration.activityType = .cycling\n    }\n    configuration.activityType = type.activityType()\n    \n    if type == .swimming {\n        configuration.locationType = .indoor\n        configuration.swimmingLocationType = .pool\n        configuration.lapLength = HKQuantity(unit: HKUnit.yard(), doubleValue: 25.0)\n    } else {\n        configuration.locationType = .outdoor\n    }\n    \n    self.configuration = configuration\n    \n    logger.debug(\"==> Creating the workout session.\")\n    let session = try HKWorkoutSession(healthStore: store, configuration: configuration)\n    \n    session.delegate = self\n    self.session = session\n    workoutType = type\n    \n    logger.debug(\"==> Starting the session.\")\n    session.startActivity(with: Date())\n}\n```\n\nAnd, finally, request authorization for all the data types that your workout sessions use.\n\n```swift\n\/\/ The quantity types to read from the health store.\nlet typesToRead: Set = [\n    HKQuantityType(.heartRate),\n    HKQuantityType(.activeEnergyBurned),\n    HKQuantityType(.distanceCycling),\n    HKQuantityType(.distanceSwimming),\n    HKQuantityType(.distanceWalkingRunning)\n]\n```\n\nBuild and run your app again. When you open the Action button settings, you can specify a particular workout for the First Press > Workout setting.\n\n\n\nAnd pressing the Action button launches the selected type of workout.\n\n### Donate the next action\n\nApple Watch Ultra runs the next action when someone presses the Action button while a workout or dive session is already running. This means the first time someone presses the Action button, the system starts your session. If they press the Action button any other time during the session, it performs the next action.\n\nTo set the next action, implement a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent] protocol.\n\n```swift\nstruct MarkLapIntent: AppIntent {\n    static var title: LocalizedStringResource = \"Mark Lap\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Perform a mark lap intent. ***\")\n        await MyWorkoutManager.shared.markLap(at: Date())\n        return .result()\n    }\n}\n```\n\nThis intent needs a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title] property that provides a localized description of the action, and a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, which the system calls when it performs the intent.\n\nNext, donate the app intent as the current session’s next action. For example, in your start workout intent’s `perform()` method, you can donate the next action for the new session by returning [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/IntentResult\/result(actionButtonIntent:)].\n\nHowever, in most cases you want to donate a next action regardless of whether the user presses the Action button or launches the session from within your app. To ensure that your app donates the correct intent, simply return `.result()` from your start intent, and then donate the next intent as soon as the session starts.\n\nPrevious code examples show how to donate the `MyMarkLapIntent` in its `startCollectingData()` method. The app then calls this method when starting a workout from the Action button or from the app’s user interface.\n\n```swift\nlogger.debug(\"==> Donate the mark lap intent as the Action button's next action.\")\ntry await MyStartWorkoutIntent().donate(result: .result(actionButtonIntent: MyMarkLapIntent()))\n```\n\nYou can donate as many action intents as you need; however, your app can use only the most recently donated intent as the next action. Donating a new intent changes the next action.\n\n### Pause and resume a workout\n\nApple Watch Ultra supports pausing and resuming a current workout session by simultaneously pressing both the Action button and the side button.\n\nTo implement the pause action, create a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/PauseWorkoutIntent] protocol.\n\n```swift\nstruct MyPauseWorkoutIntent: PauseWorkoutIntent {\n    static var title: LocalizedStringResource = \"Pause Workout\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Performing a pause intent. ***\")\n        await MyWorkoutManager.shared.pauseWorkout()\n        return .result()\n    }\n}\n```\n\nThis intent needs a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title] property that provides a localized description of the action, and a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, which the system calls when it performs the intent.\n\nSimilarly, to implement the resume action, create a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/ResumeWorkoutIntent] protocol.\n\n```swift\nstruct MyResumeWorkoutIntent: ResumeWorkoutIntent {\n    static var title: LocalizedStringResource = \"Resume Workout\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Performing a resume intent. ***\")\n        await MyWorkoutManager.shared.resumeWorkout()\n        return .result()\n    }\n}\n```\n\nIf your app doesn’t implement structures that adopt these protocols, the system ignores simultaneous presses.\n\n### Start a new dive session\n\nDive sessions work similarly to workout sessions. To start a dive session, implement a structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/StartDiveIntent] protocol. Typically, people start the dive session just before entering the water. Your app can then donate App Intents that help them use your app while in the water. For example, while in the water they can’t use the touch screen, but the Action button and Digital Crown function normally.\n\n```swift\nstruct MyStartDiveSessionIntent: StartDiveIntent {\n\n    static var title: LocalizedStringResource = \"Starting a dive session.\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Starting a dive session. ***\")\n\n        await DiveManager.shared.start()\n        return .result(actionButtonIntent: MyCollectSubmergedDataIntent())\n    }\n}\n```\n\nThis intent needs a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/title] property that provides a localized description of the action, and a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] method, which the system calls when it performs the intent.\n\nTo read live depth, water pressure, and water temperature data, see [doc:\/\/com.apple.documentation\/documentation\/CoreMotion\/accessing-submersion-data].\n\n\n\nUnlike workout sessions, the start dive intent supports only a single type of session. You can donate next actions for your dive session; however, you can’t create intents to pause or resume the session.\n\n### Passing data to the intents\n\nThe previous examples use singleton objects to share data between the different parts of your app; however, App Intents support dependency injection, letting you define the data in your main app, and access it in your intents.\n\nIn your intents, create a property that uses the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppDependency] property wrapper.\n\n```swift\nstruct MyStartWorkoutIntent: StartWorkoutIntent {\n  @Dependency var workoutManager: MyWorkoutManager\n\n  \/\/ Add remaining code here.\n}\n```\n\nThen, as early as possible when your app launches, use the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppDependencyManager] to define the dependency.\n\n```swift\nAppDependencyManager.shared.add { MyWorkoutManager() }\n```\n\nYou can set the dependency in your app’s [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/applicationDidFinishLaunching()] method. Or, if your app uses SwiftUI life cycles, add an `init()` method to your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App] structure, and set it there.\n\nOne of the main advantages of dependency injection is that you can easily replace your main data object with a mock object during testing.\n\n\n\n### Debug intents\n\nTo see console output and respond to breakpoints in Xcode, use the following steps to debug your intents:\n\n1. Build and run your app in Xcode.\n2. On the test device or Simulator, send your app to the background. For example, press Shift-Command-H in Simulator to send your app to the background.\n3. Make sure you set the actions you want to test by choosing Settings > Action Button.\n4. Press the Action button to test the primary and next actions. On a test device, you can also test the pause and resume actions for workout sessions by pressing the Action button and the side button simultaneously.\n\nAny logging from your intents appears in Xcode’s console. The system also pauses execution for any breakpoints you set in Xcode.\n\n## Responding to the Action button\n\n- **StartWorkoutIntent**: An App Intent for starting a workout.\n- **PauseWorkoutIntent**: An App Intent that lets someone pause your app’s current workout session.\n- **ResumeWorkoutIntent**: An App Intent that lets someone resume your app’s paused workout session.\n- **StartDiveIntent**: An App Intent that lets people start a dive session when they press the Action button on Apple Watch Ultra.\n- **ConfirmationActionName**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An App Intent for starting a workout.",
          "name" : "StartWorkoutIntent",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/StartWorkoutIntent"
        },
        {
          "description" : "An App Intent that lets someone pause your app’s current workout session.",
          "name" : "PauseWorkoutIntent",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/PauseWorkoutIntent"
        },
        {
          "description" : "An App Intent that lets someone resume your app’s paused workout session.",
          "name" : "ResumeWorkoutIntent",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/ResumeWorkoutIntent"
        },
        {
          "description" : "An App Intent that lets people start a dive session when they press the Action button on Apple Watch Ultra.",
          "name" : "StartDiveIntent",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/StartDiveIntent"
        },
        {
          "description" : "",
          "name" : "ConfirmationActionName",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/ConfirmationActionName"
        }
      ],
      "title" : "Responding to the Action button"
    }
  ],
  "source" : "appleJSON",
  "title" : "Responding to the Action button on Apple Watch Ultra",
  "url" : "https:\/\/developer.apple.com\/documentation\/appintents\/actionbuttonarticle"
}