{
  "abstract" : "Provide the system with information about the types your app uses to model its data so that your intents can use those types as parameters.",
  "codeExamples" : [
    {
      "code" : "struct TrailEntity: AppEntity {\n    \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "var id: UUID",
      "language" : "swift"
    },
    {
      "code" : "static var typeDisplayRepresentation: TypeDisplayRepresentation {\n    TypeDisplayRepresentation(\n        name: LocalizedStringResource(\"Trail\", table: \"AppIntents\"),\n        numericFormat: LocalizedStringResource(\"\\(placeholder: .int) trails\", table: \"AppIntents\")\n    )\n}",
      "language" : "swift"
    },
    {
      "code" : "var displayRepresentation: DisplayRepresentation {\n    DisplayRepresentation(title: \"\\(name)\",\n                          subtitle: \"\\(regionDescription)\",\n                          image: DisplayRepresentation.Image(named: imageName))\n}",
      "language" : "swift"
    },
    {
      "code" : "struct TrailEntityQuery: EntityQuery {\n    \n    @Dependency\n    var trailManager: TrailDataManager\n\n    func entities(for identifiers: [TrailEntity.ID]) async throws -> [TrailEntity] {\n        Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Query for IDs \\(identifiers)\")\n        \n        return trailManager.trails(with: identifiers)\n                .map { TrailEntity(trail: $0) }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func suggestedEntities() async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Request for suggested entities\")\n    \n    return trailManager.trails(with: trailManager.favoritesCollection.members)\n            .map { TrailEntity(trail: $0) }\n}",
      "language" : "swift"
    },
    {
      "code" : "func entities(matching string: String) async throws -> [TrailEntity] {\n    return trailManager.trails { trail in\n        trail.name.localizedCaseInsensitiveContains(string)\n    }.map { TrailEntity(trail: $0) }\n}",
      "language" : "swift"
    },
    {
      "code" : "static var defaultQuery = TrailEntityQuery()",
      "language" : "swift"
    },
    {
      "code" : "enum ActivityStyle: String, Codable, Sendable {\n    case biking\n    case equestrian\n    case hiking\n    case jogging\n    case crossCountrySkiing\n    case snowshoeing\n\n    \/\/ ...\n}\n\nextension ActivityStyle: AppEnum {\n\n    static var typeDisplayRepresentation: TypeDisplayRepresentation {\n        TypeDisplayRepresentation(\n            name: LocalizedStringResource(\"Activity\", table: \"AppIntents\"),\n            numericFormat: LocalizedStringResource(\"\\(placeholder: .int) activities\", table: \"AppIntents\")\n        )\n    }",
      "language" : "swift"
    },
    {
      "code" : "static var caseDisplayRepresentations: [ActivityStyle: DisplayRepresentation] = [\n    .biking: DisplayRepresentation(title: \"Biking\",\n                                   subtitle: \"Mountain bike ride\",\n                                   image: imageRepresentation[.biking]),\n    \n    .equestrian: DisplayRepresentation(title: \"Equestrian\",\n                                       subtitle: \"Equestrian sports\",\n                                       image: imageRepresentation[.equestrian]),\n    \n    .hiking: DisplayRepresentation(title: \"Hiking\",\n                                   subtitle: \"A lengthy outdoor walk\",\n                                   image: imageRepresentation[.hiking]),\n    \n    .jogging: DisplayRepresentation(title: \"Jogging\",\n                                    subtitle: \"A gentle run\",\n                                    image: imageRepresentation[.jogging]),\n    \n    .crossCountrySkiing: DisplayRepresentation(title: \"Skiing\",\n                                               subtitle: \"Cross-country skiing\",\n                                               image: imageRepresentation[.crossCountrySkiing]),\n    \n    .snowshoeing: DisplayRepresentation(title: \"Snowshoeing\",\n                                        subtitle: \"Walking in the snow\",\n                                        image: imageRepresentation[.snowshoeing])\n]",
      "language" : "swift"
    }
  ],
  "contentHash" : "d1f98450c7ce0daa7443f088d271b29f0eac1476eeabd4de9ebb9b80c4494911",
  "crawledAt" : "2025-12-06T02:44:43Z",
  "id" : "B65C40F9-281B-4962-A78B-83208A723198",
  "kind" : "article",
  "language" : "swift",
  "module" : "App Intents",
  "overview" : "## Overview\n\nYour app likely defines a number of custom types that model the data the app creates or consumes. For example, an app that enables people to view information about hiking trails might define types that describe trail information. Because those types are unique to your app, the framework can’t interpret them until you expose them to system experiences like the Shortcuts app. *Entities* are lightweight types that provide information to the system about your app’s data or concepts relating to that data. An entity identifies and queries the data it represents and describes how the system displays that data onscreen. Create an entity for each of the core types or concepts you want to use as an input parameter for your intents.\n\nFor more information on creating app intents and specifying their input parameters, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/Creating-your-first-app-intent] and [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/Adding-parameters-to-an-app-intent].\n\n### Define an entity that represents your data\n\nTo let an intent use one of your app’s custom data types as a parameter, define a new structure in your app’s target to represent that type. Then update the structure’s definition to adopt the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] protocol. Although custom types can directly conform to the protocol, prefer using distinct entity types that are lightweight and provide only the information the system requires. Distinct types let you separate your entities from the rest of your app’s model and domain code. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project uses a `Trail` type and defines a corresponding `TrailEntity` type.\n\nIf your app’s model code is lightweight and the amount of data is small enough to fit into device memory, you can make your models conform to [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] to keep your code simple. However, models can contain larger data like images or your app could operate on large amounts of data. For those cases, use separate types for your entities so you can load only the data the entities need, and make the mechanism that provides the entities’ data more performant. For example, if your app uses [doc:\/\/com.apple.documentation\/documentation\/CloudKit] to manage its data, set the [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKFetchRecordsOperation\/desiredKeys-31bbq] property on your fetch operations to return only the data the entities need instead of fetching entire records.\n\n### Specify a unique identifier for your entity\n\nEvery entity must have a stable, unique identifier. The framework uses that identifier as a concrete reference to your entity while mediating between your app and other parts of the system. For example, when someone selects the value for an entity-based parameter in the shortcut editor, the system asks your app to resolve that parameter using the entity’s identifier. The [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] protocol inherits the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable] protocol to enforce this prerequisite.\n\nTo add a unique identifier to your entity type, implement the protocol’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity\/id] requirement and set its type to one of the three data types optimized for the framework: [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UUID].\n\n### Provide a visual representation for your entity\n\nAn entity represents a type and the data for that type. In your entity, describe how to display both elements onscreen. For example, the Shortcuts app uses this information to show type details in the Actions Library and to present entity data in the shortcut editor.\n\nAdd the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/TypeDisplayRepresentable\/typeDisplayRepresentation] variable to your entity’s structure and return a human-readable, localized string that describes the entity. For example, the hiking app from the previous example displays the number of trails. The system displays this string whenever it needs to present your entity’s type onscreen.\n\nThe required [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/InstanceDisplayRepresentable\/displayRepresentation] variable describes how to display an entity’s represented data at runtime. Update your structure to include this variable and return an instance of [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation]. Specify a localized [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/title] that lets people recognize the data.\n\nCreate a visually rich display of your entity by setting the representation’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/subtitle] and [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/image-swift.property] variables. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project displays the name of the trail, a region description, and an image.\n\nFor more information, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation].\n\n### Make your entity searchable\n\nThe framework requires entity types to be searchable so the system can resolve identifiers at runtime and request a list of suggested entities to display onscreen. For example, when a person sets a parameter to a specific entity in the shortcut editor, the system retains that entity’s identifier. Later, when the intent runs, the framework asks your type to materialize the entity from its identifier. The framework then updates the relevant parameter with the materialized entity before invoking the intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] function.\n\nTo make your entity searchable, define a new structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityQuery] protocol. Place this structure in the app’s target alongside your entity. Add the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityQuery\/entities(for:)] function, and update the declaration so the element type of the `identifiers` array matches your entity’s `id` variable. Use the provided identifiers to materialize and return the relevant entities.\n\nTo offer a better user experience, provide a list of suggested entities that the system displays, at appropriate times, to let people quickly make a selection. To provide those entities, add the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityQuery\/suggestedEntities()] method to your query structure. If your data generates a small number of entities, return them all; otherwise, return a subset of those entities relevant to the current context. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project suggests a person’s favorite hiking trails.\n\nTo let people use arbitrary text to find specific entities, adopt the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityStringQuery] protocol instead. Queries that adopt this protocol cause the system to display a search field above the list of suggested entities. Implement the required [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityStringQuery\/entities(matching:)] function, and use the provided string to match against your data. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project allows people to search for a specific trail. The following code snippet from the sample code project matches a person’s search input to the app’s trail information using the `name` property:\n\nAfter you implement your query, update the related entity’s definition to include the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity\/defaultQuery-4khg7] variable, and specify an instance of your query type as the value. The system uses this variable at runtime to determine which type it can query on behalf of the related entity.\n\nThere are several subprotocols to `EntityQuery`, each of which enables different types of functionality. The [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project  implements all of them for demonstration purposes, but for a real app, you can choose the ones that meet your needs.\n\n### Enable Find intents\n\nApps implementing either the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EnumerableEntityQuery] or [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityPropertyQuery] protocols automatically add a Find intent in the Shortcuts app. These intents enable people to build powerful new features for themselves in Shortcuts, powered by the app’s data — without requiring the app to implement that feature itself. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project focuses its UI on providing trail information, but people could also use its data to plan activities for a vacation. The app doesn’t need to build vacation-planning features because it implements these entity query protocols to provide an interface to the data through an App Shortcut.\n\nFor more information about enabling Find intents, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents#Enable-Find-intents].\n\n### Enumerate your data type’s static values\n\nIf a type has known fixed values at build time, such as a Swift enumeration, expose those types to the system by converting them to *app enums*, the static equivalent of entities. Because app enum values are constant, the compiler introspects them at build time and optimizes their use. The framework provides both an identity and a query by default, and the system can get type information at runtime without launching the app. For example, a music app might use an app enum to associate an album with an album type such as studio, live, or compilation.\n\nTo convert a common type to an app enum, update its declaration to adopt the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEnum] protocol. There’s no need to create a separate type because the existing type is inherently lightweight and doesn’t store additional data. The framework requires that app enums also conform to [doc:\/\/com.apple.documentation\/documentation\/Swift\/RawRepresentable] and use [doc:\/\/com.apple.documentation\/documentation\/Swift\/String] as their storage type, so modify your type to satisfy those requirements. Like with entities, specify a localized description of the type that the system can display onscreen.\n\nTo provide descriptions for each of your app enum’s values, add the protocol’s required [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/CaseDisplayRepresentable\/caseDisplayRepresentations] variable. Return a dictionary that maps the values to their display representations.\n\nThe example above initializes each representation with a string literal. To help people quickly understand the values, it also specifies a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/subtitle] and an [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/image-swift.property].\n\nFor more information, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/appintents\/integrating-custom-types-into-your-intents\ncrawled: 2025-12-06T02:44:43Z\n---\n\n# Integrating custom data types into your intents\n\n**Article**\n\nProvide the system with information about the types your app uses to model its data so that your intents can use those types as parameters.\n\n## Overview\n\nYour app likely defines a number of custom types that model the data the app creates or consumes. For example, an app that enables people to view information about hiking trails might define types that describe trail information. Because those types are unique to your app, the framework can’t interpret them until you expose them to system experiences like the Shortcuts app. *Entities* are lightweight types that provide information to the system about your app’s data or concepts relating to that data. An entity identifies and queries the data it represents and describes how the system displays that data onscreen. Create an entity for each of the core types or concepts you want to use as an input parameter for your intents.\n\nFor more information on creating app intents and specifying their input parameters, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/Creating-your-first-app-intent] and [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/Adding-parameters-to-an-app-intent].\n\n### Define an entity that represents your data\n\nTo let an intent use one of your app’s custom data types as a parameter, define a new structure in your app’s target to represent that type. Then update the structure’s definition to adopt the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] protocol. Although custom types can directly conform to the protocol, prefer using distinct entity types that are lightweight and provide only the information the system requires. Distinct types let you separate your entities from the rest of your app’s model and domain code. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project uses a `Trail` type and defines a corresponding `TrailEntity` type.\n\n```swift\nstruct TrailEntity: AppEntity {\n    \/\/ ...\n}\n```\n\nIf your app’s model code is lightweight and the amount of data is small enough to fit into device memory, you can make your models conform to [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] to keep your code simple. However, models can contain larger data like images or your app could operate on large amounts of data. For those cases, use separate types for your entities so you can load only the data the entities need, and make the mechanism that provides the entities’ data more performant. For example, if your app uses [doc:\/\/com.apple.documentation\/documentation\/CloudKit] to manage its data, set the [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKFetchRecordsOperation\/desiredKeys-31bbq] property on your fetch operations to return only the data the entities need instead of fetching entire records.\n\n### Specify a unique identifier for your entity\n\nEvery entity must have a stable, unique identifier. The framework uses that identifier as a concrete reference to your entity while mediating between your app and other parts of the system. For example, when someone selects the value for an entity-based parameter in the shortcut editor, the system asks your app to resolve that parameter using the entity’s identifier. The [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity] protocol inherits the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable] protocol to enforce this prerequisite.\n\nTo add a unique identifier to your entity type, implement the protocol’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity\/id] requirement and set its type to one of the three data types optimized for the framework: [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UUID].\n\n```swift\nvar id: UUID\n```\n\n\n\n### Provide a visual representation for your entity\n\nAn entity represents a type and the data for that type. In your entity, describe how to display both elements onscreen. For example, the Shortcuts app uses this information to show type details in the Actions Library and to present entity data in the shortcut editor.\n\nAdd the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/TypeDisplayRepresentable\/typeDisplayRepresentation] variable to your entity’s structure and return a human-readable, localized string that describes the entity. For example, the hiking app from the previous example displays the number of trails. The system displays this string whenever it needs to present your entity’s type onscreen.\n\n```swift\nstatic var typeDisplayRepresentation: TypeDisplayRepresentation {\n    TypeDisplayRepresentation(\n        name: LocalizedStringResource(\"Trail\", table: \"AppIntents\"),\n        numericFormat: LocalizedStringResource(\"\\(placeholder: .int) trails\", table: \"AppIntents\")\n    )\n}\n```\n\nThe required [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/InstanceDisplayRepresentable\/displayRepresentation] variable describes how to display an entity’s represented data at runtime. Update your structure to include this variable and return an instance of [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation]. Specify a localized [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/title] that lets people recognize the data.\n\nCreate a visually rich display of your entity by setting the representation’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/subtitle] and [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/image-swift.property] variables. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project displays the name of the trail, a region description, and an image.\n\n```swift\nvar displayRepresentation: DisplayRepresentation {\n    DisplayRepresentation(title: \"\\(name)\",\n                          subtitle: \"\\(regionDescription)\",\n                          image: DisplayRepresentation.Image(named: imageName))\n}\n```\n\nFor more information, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation].\n\n### Make your entity searchable\n\nThe framework requires entity types to be searchable so the system can resolve identifiers at runtime and request a list of suggested entities to display onscreen. For example, when a person sets a parameter to a specific entity in the shortcut editor, the system retains that entity’s identifier. Later, when the intent runs, the framework asks your type to materialize the entity from its identifier. The framework then updates the relevant parameter with the materialized entity before invoking the intent’s [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppIntent\/perform()] function.\n\nTo make your entity searchable, define a new structure that adopts the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityQuery] protocol. Place this structure in the app’s target alongside your entity. Add the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityQuery\/entities(for:)] function, and update the declaration so the element type of the `identifiers` array matches your entity’s `id` variable. Use the provided identifiers to materialize and return the relevant entities.\n\n```swift\nstruct TrailEntityQuery: EntityQuery {\n    \n    @Dependency\n    var trailManager: TrailDataManager\n\n    func entities(for identifiers: [TrailEntity.ID]) async throws -> [TrailEntity] {\n        Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Query for IDs \\(identifiers)\")\n        \n        return trailManager.trails(with: identifiers)\n                .map { TrailEntity(trail: $0) }\n    }\n}\n```\n\nTo offer a better user experience, provide a list of suggested entities that the system displays, at appropriate times, to let people quickly make a selection. To provide those entities, add the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityQuery\/suggestedEntities()] method to your query structure. If your data generates a small number of entities, return them all; otherwise, return a subset of those entities relevant to the current context. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project suggests a person’s favorite hiking trails.\n\n```swift\nfunc suggestedEntities() async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Request for suggested entities\")\n    \n    return trailManager.trails(with: trailManager.favoritesCollection.members)\n            .map { TrailEntity(trail: $0) }\n}\n```\n\nTo let people use arbitrary text to find specific entities, adopt the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityStringQuery] protocol instead. Queries that adopt this protocol cause the system to display a search field above the list of suggested entities. Implement the required [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityStringQuery\/entities(matching:)] function, and use the provided string to match against your data. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project allows people to search for a specific trail. The following code snippet from the sample code project matches a person’s search input to the app’s trail information using the `name` property:\n\n```swift\nfunc entities(matching string: String) async throws -> [TrailEntity] {\n    return trailManager.trails { trail in\n        trail.name.localizedCaseInsensitiveContains(string)\n    }.map { TrailEntity(trail: $0) }\n}\n```\n\nAfter you implement your query, update the related entity’s definition to include the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEntity\/defaultQuery-4khg7] variable, and specify an instance of your query type as the value. The system uses this variable at runtime to determine which type it can query on behalf of the related entity.\n\n```swift\nstatic var defaultQuery = TrailEntityQuery()\n```\n\nThere are several subprotocols to `EntityQuery`, each of which enables different types of functionality. The [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project  implements all of them for demonstration purposes, but for a real app, you can choose the ones that meet your needs.\n\n### Enable Find intents\n\nApps implementing either the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EnumerableEntityQuery] or [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/EntityPropertyQuery] protocols automatically add a Find intent in the Shortcuts app. These intents enable people to build powerful new features for themselves in Shortcuts, powered by the app’s data — without requiring the app to implement that feature itself. For example, the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents] sample code project focuses its UI on providing trail information, but people could also use its data to plan activities for a vacation. The app doesn’t need to build vacation-planning features because it implements these entity query protocols to provide an interface to the data through an App Shortcut.\n\nFor more information about enabling Find intents, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AcceleratingAppInteractionsWithAppIntents#Enable-Find-intents].\n\n### Enumerate your data type’s static values\n\nIf a type has known fixed values at build time, such as a Swift enumeration, expose those types to the system by converting them to *app enums*, the static equivalent of entities. Because app enum values are constant, the compiler introspects them at build time and optimizes their use. The framework provides both an identity and a query by default, and the system can get type information at runtime without launching the app. For example, a music app might use an app enum to associate an album with an album type such as studio, live, or compilation.\n\nTo convert a common type to an app enum, update its declaration to adopt the [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/AppEnum] protocol. There’s no need to create a separate type because the existing type is inherently lightweight and doesn’t store additional data. The framework requires that app enums also conform to [doc:\/\/com.apple.documentation\/documentation\/Swift\/RawRepresentable] and use [doc:\/\/com.apple.documentation\/documentation\/Swift\/String] as their storage type, so modify your type to satisfy those requirements. Like with entities, specify a localized description of the type that the system can display onscreen.\n\n```swift\nenum ActivityStyle: String, Codable, Sendable {\n    case biking\n    case equestrian\n    case hiking\n    case jogging\n    case crossCountrySkiing\n    case snowshoeing\n\n    \/\/ ...\n}\n\nextension ActivityStyle: AppEnum {\n\n    static var typeDisplayRepresentation: TypeDisplayRepresentation {\n        TypeDisplayRepresentation(\n            name: LocalizedStringResource(\"Activity\", table: \"AppIntents\"),\n            numericFormat: LocalizedStringResource(\"\\(placeholder: .int) activities\", table: \"AppIntents\")\n        )\n    }\n```\n\n\n\nTo provide descriptions for each of your app enum’s values, add the protocol’s required [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/CaseDisplayRepresentable\/caseDisplayRepresentations] variable. Return a dictionary that maps the values to their display representations.\n\n```swift\nstatic var caseDisplayRepresentations: [ActivityStyle: DisplayRepresentation] = [\n    .biking: DisplayRepresentation(title: \"Biking\",\n                                   subtitle: \"Mountain bike ride\",\n                                   image: imageRepresentation[.biking]),\n    \n    .equestrian: DisplayRepresentation(title: \"Equestrian\",\n                                       subtitle: \"Equestrian sports\",\n                                       image: imageRepresentation[.equestrian]),\n    \n    .hiking: DisplayRepresentation(title: \"Hiking\",\n                                   subtitle: \"A lengthy outdoor walk\",\n                                   image: imageRepresentation[.hiking]),\n    \n    .jogging: DisplayRepresentation(title: \"Jogging\",\n                                    subtitle: \"A gentle run\",\n                                    image: imageRepresentation[.jogging]),\n    \n    .crossCountrySkiing: DisplayRepresentation(title: \"Skiing\",\n                                               subtitle: \"Cross-country skiing\",\n                                               image: imageRepresentation[.crossCountrySkiing]),\n    \n    .snowshoeing: DisplayRepresentation(title: \"Snowshoeing\",\n                                        subtitle: \"Walking in the snow\",\n                                        image: imageRepresentation[.snowshoeing])\n]\n```\n\nThe example above initializes each representation with a string literal. To help people quickly understand the values, it also specifies a [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/subtitle] and an [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation\/image-swift.property].\n\nFor more information, see [doc:\/\/com.apple.AppIntents\/documentation\/AppIntents\/DisplayRepresentation].\n\n## Parameters, custom data types, and queries\n\n- **Adding parameters to an app intent**: Enable people to configure app intents with their custom input values.\n- **Parameter resolution**: Define the required parameters for your app intents and specify how to resolve those parameters at runtime.\n- **App entities**: Make core types or concepts discoverable to the system by declaring them as app entities.\n- **Entity queries**: Help the system find the entities your app defines and use them to resolve parameters.\n- **Resolvers**: Resolve the parameters of your app intents, and extend the standard resolution types to include your app’s custom types.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Enable people to configure app intents with their custom input values.",
          "name" : "Adding parameters to an app intent",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/Adding-parameters-to-an-app-intent"
        },
        {
          "description" : "Define the required parameters for your app intents and specify how to resolve those parameters at runtime.",
          "name" : "Parameter resolution",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/parameter-resolution"
        },
        {
          "description" : "Make core types or concepts discoverable to the system by declaring them as app entities.",
          "name" : "App entities",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/app-entities"
        },
        {
          "description" : "Help the system find the entities your app defines and use them to resolve parameters.",
          "name" : "Entity queries",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/entity-queries"
        },
        {
          "description" : "Resolve the parameters of your app intents, and extend the standard resolution types to include your app’s custom types.",
          "name" : "Resolvers",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/resolvers"
        }
      ],
      "title" : "Parameters, custom data types, and queries"
    }
  ],
  "source" : "appleJSON",
  "title" : "Integrating custom data types into your intents",
  "url" : "https:\/\/developer.apple.com\/documentation\/appintents\/integrating-custom-types-into-your-intents"
}