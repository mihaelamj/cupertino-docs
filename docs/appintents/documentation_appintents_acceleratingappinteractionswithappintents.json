{
  "abstract" : "Enable people to use your app’s features quickly through Siri, Spotlight, and Shortcuts.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Each intent needs to include metadata, such as a localized title. The title of the intent displays throughout the system.\nstatic let title: LocalizedStringResource = \"Open Favorite Trails\"\n\n\/\/\/ An intent can optionally provide a localized description that the Shortcuts app displays.\nstatic let description = IntentDescription(\"Opens the app and goes to your favorite trails.\")\n\n\/\/\/ Tell the system to bring the app to the foreground when the intent runs.\nstatic let openAppWhenRun: Bool = true\n\n\/**\n When the system runs the intent, it calls `perform()`.\n \n Intents run on an arbitrary queue. Intents that manipulate UI need to annotate `perform()` with `@MainActor`\n so that the UI operations run on the main actor.\n *\/\n@MainActor\nfunc perform() async throws -> some IntentResult {\n    navigationModel.selectedCollection = trailManager.favoritesCollection\n    \n    \/\/\/ Return an empty result, indicating that the intent is complete.\n    return .result()\n}",
      "language" : "swift"
    },
    {
      "code" : "AppShortcut(intent: OpenFavorites(), phrases: [\n    \"Open Favorites in \\(.applicationName)\",\n    \"Show my favorite \\(.applicationName)\"\n],\nshortTitle: \"Open Favorites\",\nsystemImageName: \"star.circle\")",
      "language" : "swift"
    },
    {
      "code" : "SiriTipView(intent: OpenFavorites(), isVisible: $displaySiriTip)",
      "language" : "swift"
    },
    {
      "code" : "func perform() async throws -> some IntentResult & ReturnsValue<TrailEntity> & ProvidesDialog & ShowsSnippetView {",
      "language" : "swift"
    },
    {
      "code" : "let snippet = TrailInfoView(trail: trailData, includeConditions: true)\n\n\/**\n This intent displays a custom view that includes the trail conditions as part of the view. The dialog includes the trail conditions when\n the system can only read the response, but not display it. When the system can display the response, the dialog omits the trail\n conditions.\n *\/\nlet dialog = IntentDialog(full: \"The latest reported conditions for \\(trail.name) indicate: \\(trail.currentConditions).\",\n                          supporting: \"Here's the latest information on trail conditions.\")\n\nreturn .result(value: trail, dialog: dialog, view: snippet)",
      "language" : "swift"
    },
    {
      "code" : "let dialog = IntentDialog(\"Multiple locations match \\(location). Did you mean one of these locations?\")\nlet disambiguationList = suggestedMatches.sorted(using: KeyPathComparator(\\.self, comparator: .localizedStandard))\nthrow $location.needsDisambiguationError(among: disambiguationList, dialog: dialog)",
      "language" : "swift"
    },
    {
      "code" : "@Parameter(title: \"Trail\", description: \"The trail to get information for.\")\nvar trail: TrailEntity",
      "language" : "swift"
    },
    {
      "code" : "static let defaultQuery = TrailEntityQuery()",
      "language" : "swift"
    },
    {
      "code" : "\/**\n The trail's name. The `EntityProperty` property wrapper makes this property's data available to the system as part of the intent,\n such as when an intent returns a trail in a shortcut.\n \n The system automatically generates the title for this property from the variable name when it displays it in a system UI, like Shortcuts.\n Generated titles are available for both `EntityProperty` and `IntentIntentParameter` property wrappers.\n *\/\n@Property var name: String\n\n\/**\n A description of the trail's location, such as a nearby city name, or the national park encompassing it.\n \n If you want the displayed title for the property to be different from the variable name, use a `title` parameter with the\n `EntityProperty` property wrapper.\n *\/\n@Property(title: \"Region\")\nvar regionDescription: String\n",
      "language" : "swift"
    },
    {
      "code" : "func entities(for identifiers: [TrailEntity.ID]) async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Query for IDs \\(identifiers)\")\n    \n    return trailManager.trails(with: identifiers)\n            .map { TrailEntity(trail: $0) }\n}",
      "language" : "swift"
    },
    {
      "code" : "func suggestedEntities() async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Request for suggested entities\")\n    \n    return trailManager.trails(with: trailManager.favoritesCollection.members)\n            .map { TrailEntity(trail: $0) }\n}",
      "language" : "swift"
    },
    {
      "code" : "func entities(matching string: String) async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] String query for term \\(string)\")\n    \n    return trailManager.trails { trail in\n        trail.name.localizedCaseInsensitiveContains(string)\n    }.map { TrailEntity(trail: $0) }\n}",
      "language" : "swift"
    },
    {
      "code" : "func allEntities() async throws -> [TrailCollection] {\n    Logger.entityQueryLogging.debug(\"[FeaturedCollectionEntityQuery] Request for all entities\")\n    return trailManager.featuredTrailCollections\n}",
      "language" : "swift"
    },
    {
      "code" : "var searchableAttributes: CSSearchableItemAttributeSet {\n    let attributes = CSSearchableItemAttributeSet()\n    \n    attributes.title = name\n    attributes.namedLocation = regionDescription\n    attributes.keywords = activities.localizedElements\n    \n    attributes.latitude = NSNumber(value: coordinate.latitude)\n    attributes.longitude = NSNumber(value: coordinate.longitude)\n    attributes.supportsNavigation = true\n    \n    return attributes\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create an array of the searchable information for each `Trail`.\nlet searchableItems = trails.map { trail in\n    let item = CSSearchableItem(uniqueIdentifier: String(trail.id),\n                                domainIdentifier: nil,\n                                attributeSet: trail.searchableAttributes)\n    \n    let isFavorite = favoritesCollection.members.contains(trail.id)\n    let weight = isFavorite ? 10 : 1\n    let intent = TrailEntity(trail: trail)\n    \n    \/**\n     Associate `TrailEntity` with the data that the `Trail` structure provides so the system recognizes that\n     both types represent the same data. You need to create this association before adding the `CSSearchableItem`\n     to a `CSSearchableIndex`.\n     *\/\n    item.associateAppEntity(intent, priority: weight)\n    return item\n}\n\ndo {\n    \/\/ Add the trails to the search index so people can find them through Spotlight.\n    \/\/ You need to do this as part of the app's initial setup on launch.\n    let index = CSSearchableIndex.default()\n    try await index.indexSearchableItems(searchableItems)\n    Logger.spotlightLogging.info(\"[Spotlight] Trails indexed by Spotlight\")\n} catch let error {\n    Logger.spotlightLogging.error(\"[Spotlight] Trails were not indexed by Spotlight. Reason: \\(error.localizedDescription)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "extension TrailEntity: URLRepresentableEntity {\n    static var urlRepresentation: URLRepresentation {\n        \/\/ Use string interpolation to fill values from your entity necessary for constructing the universal link URL.\n        \/\/ This example URL uses the unique and persistant identifier for the `TrailEntity` in the URL.\n        \"https:\/\/example.com\/trail\/\\(.id)\/details\"\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "035f14b22aef48c9cbcd9a52208e4b65af8a79fc05a2784a37f5b3a5be7f3431",
  "crawledAt" : "2025-12-03T08:30:58Z",
  "id" : "6F3A1B0E-1183-4ADE-9B29-3944B8E9E552",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "App Intents",
  "overview" : "## Overview\n\nThe app in this sample code project provides information on trails, allowing people to check on conditions, search for trails that allow activities like skiing, and record which trails they visit. Expressing these features as intents allows people to use them through Siri, Spotlight search, and Shortcuts. Additionally, the project integrates workout tracking on Apple Watch, and shows how to implement Action button support on Apple Watch Ultra. The intents also appear as actions in the Shortcuts app. People can combine these actions to build entirely new features in Shortcuts because the intents provide custom data types that match each other’s inputs.\n\n### Identify common actions\n\nThe sample app includes two key features that people are likely to use frequently: looking up information on a trail, and recording activity on a trail. To make it easy for people to use these features without even opening the app, the sample code creates intents for them to use with Siri, Spotlight search, and Shortcuts. For example, if someone saves their favorite trails in the app and wants to get the current conditions for those trails, the app implements the `OpenFavorites` structure, which conforms to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppIntent]. When someone runs this intent, the app opens and navigates to the Favorites view.\n\n### Create App Shortcuts\n\nPeople may ask Siri to show their favorite trails, or they may find this suggested action through a Spotlight search. To support both of these options, the app implements an [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppShortcut] using `OpenFavorites`. An App Shortcut combines an intent with phrases people may use with Siri to perform the action, and additional metadata, such as an icon, and then uses this information in a Spotlight search. People can invoke the App Shortcut with a suggested phrase, or other similiar words, because the system uses a semantic similarity index to help identify people’s requests — automatically matching phrases that are similar, but not identical.\n\nTo register the App Shortcut with the system, the app calls [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppShortcutsProvider\/updateAppShortcutParameters()]  on its [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppShortcutsProvider] during the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App\/init()] of the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App] structure.\n\nTo aid the system’s presentation of the App Shortcut, the sample app includes a short title and an SF Symbols name that represent the App Shortcut. Further, the sample app’s `Info.plist` file declares `NSAppIconActionTintColorName` with the app’s primary color and two contrasting colors in an array for the `NSAppIconComplementingColorNames` key. The system uses these colors when displaying the App Shortcuts, such as in Spotlight or the Shortcuts app. The specified values of the color names for these keys come from the app’s asset catalog.\n\nAfter registering an App Shortcut with the system, people can begin using the intent through Siri without any further configuration. To teach people a phrase to use the intent, the app provides a [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/SiriTipView] in the associated view.\n\nThe `SiriTipView` takes a binding to a visibility Boolean so that the app hides the view if an individual chooses to dismiss it.\n\nAside from intents for people to quickly view their favorite trails and track their workouts, the sample app provides extensive search capabilities through intents. The app doesn’t provide App Shortcuts for intents that people use less commonly. Best practice is to provide App Shortcuts for only the most common actions in an app — usually between two and five intents, and not more than ten.\n\n### Design custom responses\n\nEven though the app doesn’t provide `GetTrailInfo` as an App Shortcut, people may still interact with it through Siri, such as including the intent in a shortcut they create in the Shortcuts app. For a good user experience, this intent provides its result with a visual response using a custom UI snippet, and as a dialog for Siri to communicate the same information. It does so by conforming the return type of the intent’s [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppIntent\/perform()] function to both [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/ProvidesDialog] and [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/ShowsSnippetView].\n\nThe app provides both visual experiences and voice-only experiences because people may be in a context where they can’t see information in a custom UI (such as when the intent runs on HomePod), or when displaying the custom UI may be inappropriate (such as when the intent runs through CarPlay). This implementation provides a custom UI with a shorter supporting dialog to use when the custom UI is visible, and a different dialog containing additional information if the system can’t show the snippet. The sample uses a transparent background for the custom UI because the system displays it over a translucent background material. Avoiding opaque backgrounds provides the best results.\n\nThis sample app provides custom dialog throughout its intents. `SuggestTrails` validates the parameters that people provide and uses the custom dialog to prompt them for additional information. For example, if the provided location parameter isn’t specific enough, the intent prompts the individual to choose from a list of locations related to their input. The app does this by throwing [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/IntentParameter\/needsDisambiguationError(among:dialog:)] with a value for the dialog parameter.\n\n### Add parameters to an intent\n\nAn app intent can optionally require certain parameters to complete its action. For example, the `GetTrailInfo` intent declares a `trail` parameter by decorating the property with the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/IntentParameter] property wrapper.\n\nThe system supports parameters using common Foundation types, such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], and those for custom data types in an app. The app makes its trail data available in an app intent through the `TrailEntity` type, which is a structure conforming to the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEntity] protocol.\n\nTo allow the system to query the app for `TrailEntity` data, the entity implements the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable] protocol with values that are stable and persistent. `TrailEntity` declares [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEntity\/defaultQuery-4khg7], which the system uses to perform queries to receive `TrailEntity` structures.\n\nAn `AppEntity` makes its properties available to the system by decorating it with the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityProperty] property wrapper.\n\n### Provide the app’s data through queries\n\nThe system queries the app for its trail data through `TrailEntityQuery`, a type conforming to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery]. For example, if someone saves a specific value as the `trail` parameter for `GetTrailInfo`, the system locates the `TrailEntity` by using the `defaultQuery` and requesting the entity by its ID from the `Identifable` protocol. All types conforming to `EntityQuery` need to implement this method.\n\nThe app also provides a list of common trail suggestions by implementing the optional [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery\/suggestedEntities()] function.\n\nThere are several subprotocols to `EntityQuery`, each of which enables different types of functionality. The sample app implements all of them for demonstration purposes, but a real app can use only the ones that meet its needs.\n\nThe app implements [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityStringQuery] to help people configure `GetTrailInfo`. When people configure this intent in the Shortcuts app, they first see the list of trails from `suggestedEntities`. The Shortcuts app provides a search field, enabling people to search for results that appear in the list of suggested trails. The app provides results for the search term by implementing [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityStringQuery\/entities(matching:)].\n\n### Enable Find intents\n\nApps implementing either the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EnumerableEntityQuery] or the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityPropertyQuery] protocol automatically add a Find intent in the Shortcuts app. These intents enable people to build powerful new features for themselves in Shortcuts, powered by the app’s data — without requiring the app to implement that feature itself. For example, the sample app focuses its UI on providing trail information, but people can also use its data to plan activities for a vacation. The app doesn’t need to build vacation-planning features because it implements these entity query protocols to provide an interface to the data through a Shortcut.\n\nThe sample app groups trails into collections based on geographic region, and implements the collections as a type called `TrailCollection` that conforms to `AppEntity`. The list of geographic regions is small, and a `TrailCollection` is a simple structure with the collection name and a list of trail IDs that require little memory. To make this information available through a Find intent, the app implements `FeaturedCollectionEntityQuery` with conformance to `EnumerableEntityQuery`. The app uses `EnumerableEntityQuery` here because the data for the featured trail collections is a small and fixed set of values, and doesn’t require a large amount of memory. The app implements [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EnumerableEntityQuery\/allEntities()] to return all of the values, which people can filter by name in the Shortcuts app.\n\nThe app also implements `EntityPropertyQuery` for `TrailEntity`. This query type is ideal for large data sets that may have large numbers of entities, or entities that have higher memory consumption. Implementing this query adds a Find intent to the Shortcuts app, enabling people to run predicate searches on entity properties. For example, someone planning a vacation around seeing waterfalls that are easily accessible can configure the Find intent with criteria for trails containing *fall* in the trail name, and a trail distance of less than 1 kilometer. An implementation of `EntityPropertyQuery` includes several required functions and properties. `TrailEntityQuery+PropertyQuery.swift` contains the complete implementation.\n\nDesigning great intents for integration with the system means that the intents work as standalone intents with their parameters, and also work with other intents the app provides, or with other apps that may be installed. People can create shortcuts that use the output of one intent the app provides and use it as input to another intent the app provides, like the following examples:\n\n### Contribute entities to Spotlight\n\nThe sample app provides its trail data to Spotlight when the app first runs. The app declares a `Trail` structure for this data, containing the app’s internal representation of that data. The app maps its data from the structure to searchable attributes in a [doc:\/\/com.apple.documentation\/documentation\/CoreSpotlight\/CSSearchableItemAttributeSet].\n\nThe app also declares a `TrailEntity` structure to make the trail data available to the rest of the system as part of its App Intents integration. To integrate `TrailEntity` with Spotlight, `TrailEntity` conforms to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/IndexedEntity]. The app associates the searchable attributes from the `Trail` structure with the `TrailEntity` by calling [doc:\/\/com.apple.documentation\/documentation\/CoreSpotlight\/CSSearchableItem\/associateAppEntity(_:priority:)] before contributing the data to the Spotlight index.\n\n### Integrate universal links\n\nThe sample app offers an `OpenTrail` intent so that people can open the app to a specific trail’s information from a shortcut. Rather than adding code to configure the app’s UI for displaying a trail’s information just for this intent, the app uses the same URL scheme it uses to implement universal links. The app declares the URL for a trail’s details through conformance to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/URLRepresentableEntity].\n\nTo leverage the app’s existing code for handling a universal link, the app conforms the `OpenTrail` intent to both [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/OpenIntent] and [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/URLRepresentableIntent]. These conformances allow the app to skip implementing a `perform()` method on `OpenTrail`. When the intent runs, the system automatically passes the URL to the app using the standard mechanisms required for handling universal links.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/appintents\/acceleratingappinteractionswithappintents\ncrawled: 2025-12-03T08:30:58Z\n---\n\n# Accelerating app interactions with App Intents\n\n**Sample Code**\n\nEnable people to use your app’s features quickly through Siri, Spotlight, and Shortcuts.\n\n## Overview\n\nThe app in this sample code project provides information on trails, allowing people to check on conditions, search for trails that allow activities like skiing, and record which trails they visit. Expressing these features as intents allows people to use them through Siri, Spotlight search, and Shortcuts. Additionally, the project integrates workout tracking on Apple Watch, and shows how to implement Action button support on Apple Watch Ultra. The intents also appear as actions in the Shortcuts app. People can combine these actions to build entirely new features in Shortcuts because the intents provide custom data types that match each other’s inputs.\n\n### Identify common actions\n\nThe sample app includes two key features that people are likely to use frequently: looking up information on a trail, and recording activity on a trail. To make it easy for people to use these features without even opening the app, the sample code creates intents for them to use with Siri, Spotlight search, and Shortcuts. For example, if someone saves their favorite trails in the app and wants to get the current conditions for those trails, the app implements the `OpenFavorites` structure, which conforms to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppIntent]. When someone runs this intent, the app opens and navigates to the Favorites view.\n\n```swift\n\/\/\/ Each intent needs to include metadata, such as a localized title. The title of the intent displays throughout the system.\nstatic let title: LocalizedStringResource = \"Open Favorite Trails\"\n\n\/\/\/ An intent can optionally provide a localized description that the Shortcuts app displays.\nstatic let description = IntentDescription(\"Opens the app and goes to your favorite trails.\")\n\n\/\/\/ Tell the system to bring the app to the foreground when the intent runs.\nstatic let openAppWhenRun: Bool = true\n\n\/**\n When the system runs the intent, it calls `perform()`.\n \n Intents run on an arbitrary queue. Intents that manipulate UI need to annotate `perform()` with `@MainActor`\n so that the UI operations run on the main actor.\n *\/\n@MainActor\nfunc perform() async throws -> some IntentResult {\n    navigationModel.selectedCollection = trailManager.favoritesCollection\n    \n    \/\/\/ Return an empty result, indicating that the intent is complete.\n    return .result()\n}\n```\n\n### Create App Shortcuts\n\nPeople may ask Siri to show their favorite trails, or they may find this suggested action through a Spotlight search. To support both of these options, the app implements an [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppShortcut] using `OpenFavorites`. An App Shortcut combines an intent with phrases people may use with Siri to perform the action, and additional metadata, such as an icon, and then uses this information in a Spotlight search. People can invoke the App Shortcut with a suggested phrase, or other similiar words, because the system uses a semantic similarity index to help identify people’s requests — automatically matching phrases that are similar, but not identical.\n\n```swift\nAppShortcut(intent: OpenFavorites(), phrases: [\n    \"Open Favorites in \\(.applicationName)\",\n    \"Show my favorite \\(.applicationName)\"\n],\nshortTitle: \"Open Favorites\",\nsystemImageName: \"star.circle\")\n```\n\nTo register the App Shortcut with the system, the app calls [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppShortcutsProvider\/updateAppShortcutParameters()]  on its [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppShortcutsProvider] during the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App\/init()] of the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App] structure.\n\nTo aid the system’s presentation of the App Shortcut, the sample app includes a short title and an SF Symbols name that represent the App Shortcut. Further, the sample app’s `Info.plist` file declares `NSAppIconActionTintColorName` with the app’s primary color and two contrasting colors in an array for the `NSAppIconComplementingColorNames` key. The system uses these colors when displaying the App Shortcuts, such as in Spotlight or the Shortcuts app. The specified values of the color names for these keys come from the app’s asset catalog.\n\nAfter registering an App Shortcut with the system, people can begin using the intent through Siri without any further configuration. To teach people a phrase to use the intent, the app provides a [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/SiriTipView] in the associated view.\n\n```swift\nSiriTipView(intent: OpenFavorites(), isVisible: $displaySiriTip)\n```\n\nThe `SiriTipView` takes a binding to a visibility Boolean so that the app hides the view if an individual chooses to dismiss it.\n\nAside from intents for people to quickly view their favorite trails and track their workouts, the sample app provides extensive search capabilities through intents. The app doesn’t provide App Shortcuts for intents that people use less commonly. Best practice is to provide App Shortcuts for only the most common actions in an app — usually between two and five intents, and not more than ten.\n\n### Design custom responses\n\nEven though the app doesn’t provide `GetTrailInfo` as an App Shortcut, people may still interact with it through Siri, such as including the intent in a shortcut they create in the Shortcuts app. For a good user experience, this intent provides its result with a visual response using a custom UI snippet, and as a dialog for Siri to communicate the same information. It does so by conforming the return type of the intent’s [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppIntent\/perform()] function to both [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/ProvidesDialog] and [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/ShowsSnippetView].\n\n```swift\nfunc perform() async throws -> some IntentResult & ReturnsValue<TrailEntity> & ProvidesDialog & ShowsSnippetView {\n```\n\nThe app provides both visual experiences and voice-only experiences because people may be in a context where they can’t see information in a custom UI (such as when the intent runs on HomePod), or when displaying the custom UI may be inappropriate (such as when the intent runs through CarPlay). This implementation provides a custom UI with a shorter supporting dialog to use when the custom UI is visible, and a different dialog containing additional information if the system can’t show the snippet. The sample uses a transparent background for the custom UI because the system displays it over a translucent background material. Avoiding opaque backgrounds provides the best results.\n\n```swift\nlet snippet = TrailInfoView(trail: trailData, includeConditions: true)\n\n\/**\n This intent displays a custom view that includes the trail conditions as part of the view. The dialog includes the trail conditions when\n the system can only read the response, but not display it. When the system can display the response, the dialog omits the trail\n conditions.\n *\/\nlet dialog = IntentDialog(full: \"The latest reported conditions for \\(trail.name) indicate: \\(trail.currentConditions).\",\n                          supporting: \"Here's the latest information on trail conditions.\")\n\nreturn .result(value: trail, dialog: dialog, view: snippet)\n```\n\nThis sample app provides custom dialog throughout its intents. `SuggestTrails` validates the parameters that people provide and uses the custom dialog to prompt them for additional information. For example, if the provided location parameter isn’t specific enough, the intent prompts the individual to choose from a list of locations related to their input. The app does this by throwing [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/IntentParameter\/needsDisambiguationError(among:dialog:)] with a value for the dialog parameter.\n\n```swift\nlet dialog = IntentDialog(\"Multiple locations match \\(location). Did you mean one of these locations?\")\nlet disambiguationList = suggestedMatches.sorted(using: KeyPathComparator(\\.self, comparator: .localizedStandard))\nthrow $location.needsDisambiguationError(among: disambiguationList, dialog: dialog)\n```\n\n### Add parameters to an intent\n\nAn app intent can optionally require certain parameters to complete its action. For example, the `GetTrailInfo` intent declares a `trail` parameter by decorating the property with the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/IntentParameter] property wrapper.\n\n```swift\n@Parameter(title: \"Trail\", description: \"The trail to get information for.\")\nvar trail: TrailEntity\n```\n\nThe system supports parameters using common Foundation types, such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], and those for custom data types in an app. The app makes its trail data available in an app intent through the `TrailEntity` type, which is a structure conforming to the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEntity] protocol.\n\nTo allow the system to query the app for `TrailEntity` data, the entity implements the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable] protocol with values that are stable and persistent. `TrailEntity` declares [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppEntity\/defaultQuery-4khg7], which the system uses to perform queries to receive `TrailEntity` structures.\n\n```swift\nstatic let defaultQuery = TrailEntityQuery()\n```\n\nAn `AppEntity` makes its properties available to the system by decorating it with the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityProperty] property wrapper.\n\n```swift\n\/**\n The trail's name. The `EntityProperty` property wrapper makes this property's data available to the system as part of the intent,\n such as when an intent returns a trail in a shortcut.\n \n The system automatically generates the title for this property from the variable name when it displays it in a system UI, like Shortcuts.\n Generated titles are available for both `EntityProperty` and `IntentIntentParameter` property wrappers.\n *\/\n@Property var name: String\n\n\/**\n A description of the trail's location, such as a nearby city name, or the national park encompassing it.\n \n If you want the displayed title for the property to be different from the variable name, use a `title` parameter with the\n `EntityProperty` property wrapper.\n *\/\n@Property(title: \"Region\")\nvar regionDescription: String\n\n```\n\n### Provide the app’s data through queries\n\nThe system queries the app for its trail data through `TrailEntityQuery`, a type conforming to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery]. For example, if someone saves a specific value as the `trail` parameter for `GetTrailInfo`, the system locates the `TrailEntity` by using the `defaultQuery` and requesting the entity by its ID from the `Identifable` protocol. All types conforming to `EntityQuery` need to implement this method.\n\n```swift\nfunc entities(for identifiers: [TrailEntity.ID]) async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Query for IDs \\(identifiers)\")\n    \n    return trailManager.trails(with: identifiers)\n            .map { TrailEntity(trail: $0) }\n}\n```\n\nThe app also provides a list of common trail suggestions by implementing the optional [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityQuery\/suggestedEntities()] function.\n\n```swift\nfunc suggestedEntities() async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] Request for suggested entities\")\n    \n    return trailManager.trails(with: trailManager.favoritesCollection.members)\n            .map { TrailEntity(trail: $0) }\n}\n```\n\nThere are several subprotocols to `EntityQuery`, each of which enables different types of functionality. The sample app implements all of them for demonstration purposes, but a real app can use only the ones that meet its needs.\n\nThe app implements [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityStringQuery] to help people configure `GetTrailInfo`. When people configure this intent in the Shortcuts app, they first see the list of trails from `suggestedEntities`. The Shortcuts app provides a search field, enabling people to search for results that appear in the list of suggested trails. The app provides results for the search term by implementing [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityStringQuery\/entities(matching:)].\n\n```swift\nfunc entities(matching string: String) async throws -> [TrailEntity] {\n    Logger.entityQueryLogging.debug(\"[TrailEntityQuery] String query for term \\(string)\")\n    \n    return trailManager.trails { trail in\n        trail.name.localizedCaseInsensitiveContains(string)\n    }.map { TrailEntity(trail: $0) }\n}\n```\n\n### Enable Find intents\n\nApps implementing either the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EnumerableEntityQuery] or the [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EntityPropertyQuery] protocol automatically add a Find intent in the Shortcuts app. These intents enable people to build powerful new features for themselves in Shortcuts, powered by the app’s data — without requiring the app to implement that feature itself. For example, the sample app focuses its UI on providing trail information, but people can also use its data to plan activities for a vacation. The app doesn’t need to build vacation-planning features because it implements these entity query protocols to provide an interface to the data through a Shortcut.\n\nThe sample app groups trails into collections based on geographic region, and implements the collections as a type called `TrailCollection` that conforms to `AppEntity`. The list of geographic regions is small, and a `TrailCollection` is a simple structure with the collection name and a list of trail IDs that require little memory. To make this information available through a Find intent, the app implements `FeaturedCollectionEntityQuery` with conformance to `EnumerableEntityQuery`. The app uses `EnumerableEntityQuery` here because the data for the featured trail collections is a small and fixed set of values, and doesn’t require a large amount of memory. The app implements [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/EnumerableEntityQuery\/allEntities()] to return all of the values, which people can filter by name in the Shortcuts app.\n\n```swift\nfunc allEntities() async throws -> [TrailCollection] {\n    Logger.entityQueryLogging.debug(\"[FeaturedCollectionEntityQuery] Request for all entities\")\n    return trailManager.featuredTrailCollections\n}\n```\n\nThe app also implements `EntityPropertyQuery` for `TrailEntity`. This query type is ideal for large data sets that may have large numbers of entities, or entities that have higher memory consumption. Implementing this query adds a Find intent to the Shortcuts app, enabling people to run predicate searches on entity properties. For example, someone planning a vacation around seeing waterfalls that are easily accessible can configure the Find intent with criteria for trails containing *fall* in the trail name, and a trail distance of less than 1 kilometer. An implementation of `EntityPropertyQuery` includes several required functions and properties. `TrailEntityQuery+PropertyQuery.swift` contains the complete implementation.\n\nDesigning great intents for integration with the system means that the intents work as standalone intents with their parameters, and also work with other intents the app provides, or with other apps that may be installed. People can create shortcuts that use the output of one intent the app provides and use it as input to another intent the app provides, like the following examples:\n\n- `SuggestTrails` can use the output of the Find intent for trail collections as input.\n- The Find intent for trails can use the output of `SuggestTrails` to further refine the results.\n- The Find intent for trails can also work alone, searching for matching trail properties from all of the trail data the app provides.\n\n### Contribute entities to Spotlight\n\nThe sample app provides its trail data to Spotlight when the app first runs. The app declares a `Trail` structure for this data, containing the app’s internal representation of that data. The app maps its data from the structure to searchable attributes in a [doc:\/\/com.apple.documentation\/documentation\/CoreSpotlight\/CSSearchableItemAttributeSet].\n\n```swift\nvar searchableAttributes: CSSearchableItemAttributeSet {\n    let attributes = CSSearchableItemAttributeSet()\n    \n    attributes.title = name\n    attributes.namedLocation = regionDescription\n    attributes.keywords = activities.localizedElements\n    \n    attributes.latitude = NSNumber(value: coordinate.latitude)\n    attributes.longitude = NSNumber(value: coordinate.longitude)\n    attributes.supportsNavigation = true\n    \n    return attributes\n}\n```\n\nThe app also declares a `TrailEntity` structure to make the trail data available to the rest of the system as part of its App Intents integration. To integrate `TrailEntity` with Spotlight, `TrailEntity` conforms to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/IndexedEntity]. The app associates the searchable attributes from the `Trail` structure with the `TrailEntity` by calling [doc:\/\/com.apple.documentation\/documentation\/CoreSpotlight\/CSSearchableItem\/associateAppEntity(_:priority:)] before contributing the data to the Spotlight index.\n\n```swift\n\/\/ Create an array of the searchable information for each `Trail`.\nlet searchableItems = trails.map { trail in\n    let item = CSSearchableItem(uniqueIdentifier: String(trail.id),\n                                domainIdentifier: nil,\n                                attributeSet: trail.searchableAttributes)\n    \n    let isFavorite = favoritesCollection.members.contains(trail.id)\n    let weight = isFavorite ? 10 : 1\n    let intent = TrailEntity(trail: trail)\n    \n    \/**\n     Associate `TrailEntity` with the data that the `Trail` structure provides so the system recognizes that\n     both types represent the same data. You need to create this association before adding the `CSSearchableItem`\n     to a `CSSearchableIndex`.\n     *\/\n    item.associateAppEntity(intent, priority: weight)\n    return item\n}\n\ndo {\n    \/\/ Add the trails to the search index so people can find them through Spotlight.\n    \/\/ You need to do this as part of the app's initial setup on launch.\n    let index = CSSearchableIndex.default()\n    try await index.indexSearchableItems(searchableItems)\n    Logger.spotlightLogging.info(\"[Spotlight] Trails indexed by Spotlight\")\n} catch let error {\n    Logger.spotlightLogging.error(\"[Spotlight] Trails were not indexed by Spotlight. Reason: \\(error.localizedDescription)\")\n}\n```\n\n### Integrate universal links\n\nThe sample app offers an `OpenTrail` intent so that people can open the app to a specific trail’s information from a shortcut. Rather than adding code to configure the app’s UI for displaying a trail’s information just for this intent, the app uses the same URL scheme it uses to implement universal links. The app declares the URL for a trail’s details through conformance to [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/URLRepresentableEntity].\n\n```swift\nextension TrailEntity: URLRepresentableEntity {\n    static var urlRepresentation: URLRepresentation {\n        \/\/ Use string interpolation to fill values from your entity necessary for constructing the universal link URL.\n        \/\/ This example URL uses the unique and persistant identifier for the `TrailEntity` in the URL.\n        \"https:\/\/example.com\/trail\/\\(.id)\/details\"\n    }\n}\n```\n\nTo leverage the app’s existing code for handling a universal link, the app conforms the `OpenTrail` intent to both [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/OpenIntent] and [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/URLRepresentableIntent]. These conformances allow the app to skip implementing a `perform()` method on `OpenTrail`. When the intent runs, the system automatically passes the URL to the app using the standard mechanisms required for handling universal links.\n\n## Essentials\n\n- **App Intents updates**: Learn about important changes in App Intents.\n- **Making actions and content discoverable and widely available**: Adopt App Intents to make your app discoverable with Spotlight, controls, widgets, and the Action button.\n- **Creating your first app intent**: Create your first app intent that makes your app available in system experiences like Spotlight or the Shortcuts app.\n- **Adopting App Intents to support system experiences**: Create app intents and entities to incorporate system experiences such as Spotlight, visual intelligence, and Shortcuts.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn about important changes in App Intents.",
          "name" : "App Intents updates",
          "url" : "https:\/\/developer.apple.com\/documentation\/Updates\/AppIntents"
        },
        {
          "description" : "Adopt App Intents to make your app discoverable with Spotlight, controls, widgets, and the Action button.",
          "name" : "Making actions and content discoverable and widely available",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/Making-actions-and-content-discoverable-and-widely-available"
        },
        {
          "description" : "Create your first app intent that makes your app available in system experiences like Spotlight or the Shortcuts app.",
          "name" : "Creating your first app intent",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/Creating-your-first-app-intent"
        },
        {
          "description" : "Create app intents and entities to incorporate system experiences such as Spotlight, visual intelligence, and Shortcuts.",
          "name" : "Adopting App Intents to support system experiences",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppIntents\/adopting-app-intents-to-support-system-experiences"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Accelerating app interactions with App Intents",
  "url" : "https:\/\/developer.apple.com\/documentation\/appintents\/acceleratingappinteractionswithappintents"
}