{
  "abstract" : "Encrypt the contents of a string and save the result to the file system, then decrypt and recreate the string from the archive file using Apple Encrypted Archive.",
  "codeExamples" : [
    {
      "code" : "let key = SymmetricKey(size: SymmetricKeySize.bits256)",
      "language" : "swift"
    },
    {
      "code" : "let context = ArchiveEncryptionContext(profile: .hkdf_sha256_aesctr_hmac__symmetric__none,\n                                       compressionAlgorithm: .lzfse)\ntry context.setSymmetricKey(key)",
      "language" : "swift"
    },
    {
      "code" : "guard let destinationFileStream = ArchiveByteStream.fileStream(\n        path: destinationFilePath,\n        mode: .writeOnly,\n        options: [ .create, .truncate ],\n        permissions: FilePermissions(rawValue: 0o644)) else {\n    return\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let encryptionStream = ArchiveByteStream.encryptionStream(\n        writingTo: destinationFileStream,\n        encryptionContext: context) else {\n    throw Error.unableToCreateEncryptionStream\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let encodeStream = ArchiveStream.encodeStream(writingTo: encryptionStream) else {\n    return\n}",
      "language" : "swift"
    },
    {
      "code" : "let header = ArchiveHeader()\n\n\/\/ The PAT field contains the file path. Specify the unarchived file name\n\/\/ for the PAT field.\nheader.append(.string(key: ArchiveHeader.FieldKey(\"PAT\"),\n                      value: unarchivedFileName))\n\n\/\/ The TYP field contains the compressed file type. Specify `regularFile`\n\/\/ for the TYP field.\nheader.append(.uint(key: ArchiveHeader.FieldKey(\"TYP\"),\n                    value: UInt64(ArchiveHeader.EntryType.regularFile.rawValue)))\n\n\/\/ The DAT field contains the compressed file payload. Specify the size\n\/\/ of the uncompressed data, in bytes, for the DAT field.\nheader.append(.blob(key: ArchiveHeader.FieldKey(\"DAT\"),\n                    size: UInt64(string.utf8.count)))\n\n\/\/  Write the header to the encode stream.\ntry encodeStream.writeHeader(header)",
      "language" : "swift"
    },
    {
      "code" : "var mutableString = string\ntry mutableString.withUTF8 { textPtr in\n    let rawBufferPointer = UnsafeRawBufferPointer(textPtr)\n\n    try encodeStream.writeBlob(key: ArchiveHeader.FieldKey(\"DAT\"),\n                               from: rawBufferPointer)\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let sourceFileStream = ArchiveByteStream.fileStream(\n        path: sourceFilePath,\n        mode: .readOnly,\n        options: [ ],\n        permissions: FilePermissions(rawValue: 0o644)) else {\n    throw Error.unableToCreateFileStream\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let decryptionContext = ArchiveEncryptionContext(from: sourceFileStream) else {\n    throw Error.unableToCreateDecryptionContext\n}\n\n\/\/ Set the key on the context.\ntry decryptionContext.setSymmetricKey(key)",
      "language" : "swift"
    },
    {
      "code" : "guard let decryptionStream = ArchiveByteStream.decryptionStream(\n    readingFrom: sourceFileStream,\n    encryptionContext: decryptionContext) else {\n    throw Error.unableToCreateFileStream\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let decodeStream = ArchiveStream.decodeStream(\n        readingFrom: decryptionStream) else {\n    throw Error.unableToCreateFileStream\n}",
      "language" : "swift"
    },
    {
      "code" : "let byteCount: Int = try {\n    let header = try decodeStream.readHeader()\n    guard\n        let datField = header?.field(forKey: ArchiveHeader.FieldKey(\"DAT\")) else {\n            throw Error.unableToGetHeaderField\n    }\n\n    switch datField {\n        case .blob(_, let size, _):\n            return Int(size)\n        default:\n            return 0\n    }\n}()\n\nguard byteCount != 0 else {\n    throw Error.zeroDataSize\n}",
      "language" : "swift"
    },
    {
      "code" : "let rawBufferPtr = UnsafeMutableRawBufferPointer.allocate(\n        byteCount: byteCount,\n        alignment: MemoryLayout<UTF8>.alignment)\ndefer {\n    rawBufferPtr.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "try decodeStream.readBlob(key: ArchiveHeader.FieldKey(\"DAT\"),\n                          into: rawBufferPtr)",
      "language" : "swift"
    },
    {
      "code" : "let typedPtr = rawBufferPtr.bindMemory(to: CChar.self)\nlet decryptedString = String(cString: typedPtr.baseAddress!)",
      "language" : "swift"
    }
  ],
  "contentHash" : "110bd917de8373e6ee800d71ba257a09eea5ef68b6e442e0a32b647da6d82de8",
  "crawledAt" : "2025-12-02T15:51:33Z",
  "id" : "64335CA1-EEF3-415B-8FA7-07A8F07FAD60",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Apple Archive",
  "overview" : "## Overview\n\nThis sample code project implements the Apple Encrypted Archive library to compress and encrypt the contents of a [doc:\/\/com.apple.documentation\/documentation\/Swift\/String] structure using a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/SymmetricKey]. The sample saves the encrypted string to the user’s temporary directory and then calls a second function that decrypts the contents of the file and recreates the string.\n\n### Generate a Symmetric Key\n\nThe sample imports the [doc:\/\/com.apple.documentation\/documentation\/CryptoKit] framework to create the symmetric cryptographic key.\n\nThe sample uses the same key for encryption and decryption.\n\n### Create a Context for Encryption\n\nAn `ArchiveEncryptionContext` object contains the parameters, keys, and other data that the Apple Encrypted Archive library requires to open an encrypted archive for encryption and decryption streams. The sample initializes the context with a profile and compression algorithm, and its symmetric key set for encryption.\n\n### Open the Destination File Stream\n\nThe destination file stream writes the encrypted file to the file system. In this case, the file stream’s mode is [doc:\/\/com.apple.documentation\/documentation\/System\/FileDescriptor\/AccessMode\/writeOnly].  The options specify that the stream creates the file if it doesn’t exist, and if the file does exist, it should be truncated to zero bytes before the stream performs any operations.\n\n### Create the Encryption Stream\n\nThe encryption stream uses the encryption context and the destination file stream to write the encrypted string to the file system.\n\n### Open the Encode Stream\n\nThe encoding stream encodes its data as a byte stream and sends the encoded data to the encryption stream.\n\n### Define the Archive Header\n\nThe archive headers contains three fields that specify the unarchived file name, the compressed file type, and the compressed file payload.\n\n### Write the String to the Encode Stream\n\nThe sample calls `ArchiveStream\/writeBlob(key:from:)` to write the contents of the string as a data buffer to the encode stream. In turn, the encode stream writes to the compression stream, and then the encryption stream writes to the file stream. Finally, the file stream writes the archive file to the file system:\n\nOn return, the file at `encryptedFilePath` exists as an AppleArchive file in the user’s temporary directory and contains a single encrypted text file, specified by `unarchivedFileName`. The content of this text file is the specified string.\n\n### Open the Source File Stream\n\nThe sample creates a source file stream to open the encrypted file.\n\n### Create a Context for Decryption\n\nThe `ArchiveEncryptionContext` object for decryption derives its parameters, keys, and other data from the encrypted source file, and the sample sets the decryption context with the same symmetric key that the sample used for encryption.\n\n### Create the Decryption Stream\n\nThe decryption stream uses the encryption context and the source file stream to read the encrypted string from the file system.\n\n### Open the Decode Stream\n\nThe decoding stream provides archive elements from the raw, decompressed data.\n\n### Allocate a Buffer for the Decoded Data\n\nThe sample derives the size of the decompressed and decrypted string from the `DAT` field of the decode stream’s header.\n\nThe sample uses this size to alllocate the memory that receives the decoded string.\n\n### Populate the Buffer with Decoded Data\n\nThe `ArchiveStream\/readBlob(key:into:)` function reads the decompressed data from the `DAT` field and writes it to the raw buffer pointer. The decode stream parses its input from the decryption stream that, in turn, decrypts its input from the AppleArchive file supplied by the file stream.\n\n### Initialize a String from the Raw Buffer Pointer\n\nThe sample creates a string from the raw buffer pointer by creating a typed pointer that’s bound to [doc:\/\/com.apple.documentation\/documentation\/Swift\/CChar], and calls [doc:\/\/com.apple.documentation\/documentation\/Swift\/String\/init(cString:)-2p84k] to initialize the new string.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AppleArchive\/encrypting-and-decrypting-a-string\ncrawled: 2025-12-02T15:51:33Z\n---\n\n# Encrypting and Decrypting a String\n\n**Sample Code**\n\nEncrypt the contents of a string and save the result to the file system, then decrypt and recreate the string from the archive file using Apple Encrypted Archive.\n\n## Overview\n\nThis sample code project implements the Apple Encrypted Archive library to compress and encrypt the contents of a [doc:\/\/com.apple.documentation\/documentation\/Swift\/String] structure using a [doc:\/\/com.apple.documentation\/documentation\/CryptoKit\/SymmetricKey]. The sample saves the encrypted string to the user’s temporary directory and then calls a second function that decrypts the contents of the file and recreates the string.\n\n### Generate a Symmetric Key\n\nThe sample imports the [doc:\/\/com.apple.documentation\/documentation\/CryptoKit] framework to create the symmetric cryptographic key.\n\n```swift\nlet key = SymmetricKey(size: SymmetricKeySize.bits256)\n```\n\nThe sample uses the same key for encryption and decryption.\n\n### Create a Context for Encryption\n\nAn `ArchiveEncryptionContext` object contains the parameters, keys, and other data that the Apple Encrypted Archive library requires to open an encrypted archive for encryption and decryption streams. The sample initializes the context with a profile and compression algorithm, and its symmetric key set for encryption.\n\n```swift\nlet context = ArchiveEncryptionContext(profile: .hkdf_sha256_aesctr_hmac__symmetric__none,\n                                       compressionAlgorithm: .lzfse)\ntry context.setSymmetricKey(key)\n```\n\n### Open the Destination File Stream\n\nThe destination file stream writes the encrypted file to the file system. In this case, the file stream’s mode is [doc:\/\/com.apple.documentation\/documentation\/System\/FileDescriptor\/AccessMode\/writeOnly].  The options specify that the stream creates the file if it doesn’t exist, and if the file does exist, it should be truncated to zero bytes before the stream performs any operations.\n\n```swift\nguard let destinationFileStream = ArchiveByteStream.fileStream(\n        path: destinationFilePath,\n        mode: .writeOnly,\n        options: [ .create, .truncate ],\n        permissions: FilePermissions(rawValue: 0o644)) else {\n    return\n}\n```\n\n### Create the Encryption Stream\n\nThe encryption stream uses the encryption context and the destination file stream to write the encrypted string to the file system.\n\n```swift\nguard let encryptionStream = ArchiveByteStream.encryptionStream(\n        writingTo: destinationFileStream,\n        encryptionContext: context) else {\n    throw Error.unableToCreateEncryptionStream\n}\n```\n\n### Open the Encode Stream\n\nThe encoding stream encodes its data as a byte stream and sends the encoded data to the encryption stream.\n\n```swift\nguard let encodeStream = ArchiveStream.encodeStream(writingTo: encryptionStream) else {\n    return\n}\n```\n\n### Define the Archive Header\n\nThe archive headers contains three fields that specify the unarchived file name, the compressed file type, and the compressed file payload.\n\n```swift\nlet header = ArchiveHeader()\n\n\/\/ The PAT field contains the file path. Specify the unarchived file name\n\/\/ for the PAT field.\nheader.append(.string(key: ArchiveHeader.FieldKey(\"PAT\"),\n                      value: unarchivedFileName))\n\n\/\/ The TYP field contains the compressed file type. Specify `regularFile`\n\/\/ for the TYP field.\nheader.append(.uint(key: ArchiveHeader.FieldKey(\"TYP\"),\n                    value: UInt64(ArchiveHeader.EntryType.regularFile.rawValue)))\n\n\/\/ The DAT field contains the compressed file payload. Specify the size\n\/\/ of the uncompressed data, in bytes, for the DAT field.\nheader.append(.blob(key: ArchiveHeader.FieldKey(\"DAT\"),\n                    size: UInt64(string.utf8.count)))\n\n\/\/  Write the header to the encode stream.\ntry encodeStream.writeHeader(header)\n```\n\n### Write the String to the Encode Stream\n\nThe sample calls `ArchiveStream\/writeBlob(key:from:)` to write the contents of the string as a data buffer to the encode stream. In turn, the encode stream writes to the compression stream, and then the encryption stream writes to the file stream. Finally, the file stream writes the archive file to the file system:\n\n```swift\nvar mutableString = string\ntry mutableString.withUTF8 { textPtr in\n    let rawBufferPointer = UnsafeRawBufferPointer(textPtr)\n\n    try encodeStream.writeBlob(key: ArchiveHeader.FieldKey(\"DAT\"),\n                               from: rawBufferPointer)\n}\n```\n\nOn return, the file at `encryptedFilePath` exists as an AppleArchive file in the user’s temporary directory and contains a single encrypted text file, specified by `unarchivedFileName`. The content of this text file is the specified string.\n\n### Open the Source File Stream\n\nThe sample creates a source file stream to open the encrypted file.\n\n```swift\nguard let sourceFileStream = ArchiveByteStream.fileStream(\n        path: sourceFilePath,\n        mode: .readOnly,\n        options: [ ],\n        permissions: FilePermissions(rawValue: 0o644)) else {\n    throw Error.unableToCreateFileStream\n}\n```\n\n### Create a Context for Decryption\n\nThe `ArchiveEncryptionContext` object for decryption derives its parameters, keys, and other data from the encrypted source file, and the sample sets the decryption context with the same symmetric key that the sample used for encryption.\n\n```swift\nguard let decryptionContext = ArchiveEncryptionContext(from: sourceFileStream) else {\n    throw Error.unableToCreateDecryptionContext\n}\n\n\/\/ Set the key on the context.\ntry decryptionContext.setSymmetricKey(key)\n```\n\n### Create the Decryption Stream\n\nThe decryption stream uses the encryption context and the source file stream to read the encrypted string from the file system.\n\n```swift\nguard let decryptionStream = ArchiveByteStream.decryptionStream(\n    readingFrom: sourceFileStream,\n    encryptionContext: decryptionContext) else {\n    throw Error.unableToCreateFileStream\n}\n```\n\n### Open the Decode Stream\n\nThe decoding stream provides archive elements from the raw, decompressed data.\n\n```swift\nguard let decodeStream = ArchiveStream.decodeStream(\n        readingFrom: decryptionStream) else {\n    throw Error.unableToCreateFileStream\n}\n```\n\n### Allocate a Buffer for the Decoded Data\n\nThe sample derives the size of the decompressed and decrypted string from the `DAT` field of the decode stream’s header.\n\n```swift\nlet byteCount: Int = try {\n    let header = try decodeStream.readHeader()\n    guard\n        let datField = header?.field(forKey: ArchiveHeader.FieldKey(\"DAT\")) else {\n            throw Error.unableToGetHeaderField\n    }\n\n    switch datField {\n        case .blob(_, let size, _):\n            return Int(size)\n        default:\n            return 0\n    }\n}()\n\nguard byteCount != 0 else {\n    throw Error.zeroDataSize\n}\n```\n\nThe sample uses this size to alllocate the memory that receives the decoded string.\n\n```swift\nlet rawBufferPtr = UnsafeMutableRawBufferPointer.allocate(\n        byteCount: byteCount,\n        alignment: MemoryLayout<UTF8>.alignment)\ndefer {\n    rawBufferPtr.deallocate()\n}\n```\n\n### Populate the Buffer with Decoded Data\n\nThe `ArchiveStream\/readBlob(key:into:)` function reads the decompressed data from the `DAT` field and writes it to the raw buffer pointer. The decode stream parses its input from the decryption stream that, in turn, decrypts its input from the AppleArchive file supplied by the file stream.\n\n```swift\ntry decodeStream.readBlob(key: ArchiveHeader.FieldKey(\"DAT\"),\n                          into: rawBufferPtr)\n```\n\n### Initialize a String from the Raw Buffer Pointer\n\nThe sample creates a string from the raw buffer pointer by creating a typed pointer that’s bound to [doc:\/\/com.apple.documentation\/documentation\/Swift\/CChar], and calls [doc:\/\/com.apple.documentation\/documentation\/Swift\/String\/init(cString:)-2p84k] to initialize the new string.\n\n```swift\nlet typedPtr = rawBufferPtr.bindMemory(to: CChar.self)\nlet decryptedString = String(cString: typedPtr.baseAddress!)\n```\n\n## Apple Encrypted Archive essentials\n\n- **Encrypting and Decrypting a Single File**: Encrypt a single file and save the result to the file system, then decrypt and recreate the original file from the archive file using Apple Encrypted Archive.\n- **Encrypting and Decrypting Directories**: Compress and encrypt the contents of an entire directory or decompress and decrypt an archived directory  using Apple Encrypted Archive.\n- **ArchiveEncryptionContext**: An object that encapsulates all parameters, keys, and data necessary to open an encrypted archive for both encryption and decryption streams.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Encrypt a single file and save the result to the file system, then decrypt and recreate the original file from the archive file using Apple Encrypted Archive.",
          "name" : "Encrypting and Decrypting a Single File",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppleArchive\/encrypting-and-decrypting-a-single-file"
        },
        {
          "description" : "Compress and encrypt the contents of an entire directory or decompress and decrypt an archived directory  using Apple Encrypted Archive.",
          "name" : "Encrypting and Decrypting Directories",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppleArchive\/encrypting-and-decrypting-directories"
        },
        {
          "description" : "An object that encapsulates all parameters, keys, and data necessary to open an encrypted archive for both encryption and decryption streams.",
          "name" : "ArchiveEncryptionContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/AppleArchive\/ArchiveEncryptionContext"
        }
      ],
      "title" : "Apple Encrypted Archive essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Encrypting and Decrypting a String",
  "url" : "https:\/\/developer.apple.com\/documentation\/AppleArchive\/encrypting-and-decrypting-a-string"
}