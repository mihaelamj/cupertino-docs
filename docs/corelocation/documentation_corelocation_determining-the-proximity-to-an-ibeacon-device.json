{
  "abstract" : "Detect beacons and determine the relative distance to them.",
  "codeExamples" : [
    {
      "code" : "func monitorBeacons() {\n    if CLLocationManager.isMonitoringAvailable(for: \n                  CLBeaconRegion.self) {\n        \/\/ Match all beacons with the specified UUID\n        let proximityUUID = UUID(uuidString: \n               \"39ED98FF-2900-441A-802F-9C398FC199D2\")\n        let beaconID = \"com.example.myBeaconRegion\"\n            \n        \/\/ Create the region and begin monitoring it.\n        let region = CLBeaconRegion(proximityUUID: proximityUUID!,\n               identifier: beaconID)\n        self.locationManager.startMonitoring(for: region)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func locationManager(_ manager: CLLocationManager, \n            didEnterRegion region: CLRegion) {\n    if region is CLBeaconRegion {\n        \/\/ Start ranging only if the devices supports this service.\n        if CLLocationManager.isRangingAvailable() {\n            manager.startRangingBeacons(in: region as! CLBeaconRegion)\n\n            \/\/ Store the beacon so that ranging can be stopped on demand.\n            beaconsToRange.append(region as! CLBeaconRegion)        \n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func locationManager(_ manager: CLLocationManager, \n            didRangeBeacons beacons: [CLBeacon], \n            in region: CLBeaconRegion) {\n    if beacons.count > 0 {\n        let nearestBeacon = beacons.first!\n        let major = CLBeaconMajorValue(nearestBeacon.major)\n        let minor = CLBeaconMinorValue(nearestBeacon.minor)\n            \n        switch nearestBeacon.proximity {\n        case .near, .immediate:\n            \/\/ Display information about the relevant exhibit.\n            displayInformationAboutExhibit(major: major, minor: minor)\n            break\n                \n        default:\n           \/\/ Dismiss exhibit information, if it is displayed.\n           dismissExhibit(major: major, minor: minor)\n           break\n           }\n        }\n    }",
      "language" : "swift"
    }
  ],
  "contentHash" : "28d9c314513f51f799ad6ae49308719fd666631e27268fcfd32b29121f98aa1a",
  "crawledAt" : "2025-12-02T15:53:40Z",
  "id" : "3EAF4E6F-AB61-469F-8BED-ED9F80DF4262",
  "kind" : "article",
  "language" : "swift",
  "module" : "Core Location",
  "overview" : "## Overview\n\nAn iBeacon is a device that emits a Bluetooth signal that can be detected by your devices. Companies can deploy iBeacon devices in environments where proximity detection is a benefit to users, and apps can use the proximity of beacons to determine an appropriate course of action. You decide what actions to take based on the proximity of nearby beacons. For example, a department store might deploy beacons identifying each section of the store, and the corresponding app might point out sale items when the user is near each section.\n\nAdding iBeacon support to your app involves detecting beacons in two different stages:\n\nUsing a two-step process for detecting beacons significantly reduces power consumption. Ranging requires taking frequent measurements of the strength of Bluetooth signals and computing the distance to the associated beacons. By contrast, region monitoring involves only passive listening for nearby beacons, which consumes far less power.\n\n### Deploy your iBeacon hardware\n\nWhen deploying your iBeacon hardware, you must program each iBeacon with an appropriate proximity UUID, major value, and minor value. These values identify each of your beacons uniquely and make it possible for your app to differentiate between those beacons later.\n\nOnly the UUID is required, but it is recommended that you program all three values into your iBeacon hardware. In your app, you can look for related groups of beacons by specifying only a subset of values.\n\n### Detect the presence of beacons using region monitoring\n\nUse region monitoring to alert your app when an iBeacon is nearby. To monitor for beacons, create a [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLBeaconRegion] object and register it with the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager\/startMonitoring(for:)] method of your [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager] object. The beacon region contains the proximity UUID, major value, and minor value of the beacons that you want to detect. Only beacons with matching values trigger a call to your delegate object.\n\nListing 1 shows an example of how to set up region monitoring for a company’s beacons. Because you typically define a UUID for your company once and do not change it later, the example includes a hard-coded version of that value. Prior to calling this method, you must have created a [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager] object and assigned a delegate to it.\n\nListing 1. Setting up region monitoring for beacons\n\nWhen a matching iBeacon is detected, the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager] object notifies its delegate by calling the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didEnterRegion:)] method. Similarly, when a detected beacon moves out of range, the location manager calls the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didExitRegion:)] method. Use your delegate methods to start and stop beacon ranging.\n\nIf your app is not running when a beacon is detected, the system tries to launch your app.\n\n### Determine the proximity to beacons using ranging\n\nAfter detecting an iBeacon, use ranging to determine the relative distance between the beacon and the user’s device. Ranging reports when the two devices are far apart, near to each other, or in the immediate vicinity of each other; it does not offer a precise distance, nor should you rely on the strength of a beacon’s signal to compute that information yourself. Use the relative values to determine an appropriate course of action. For example, an app for an art museum might wait until the user is in the immediate vicinity of an iBeacon before offering information about the corresponding artwork.\n\n\n\nThe most logical place to start ranging is in your location manager delegate’s [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didEnterRegion:)] method when a beacon is first detected. (The place to stop ranging is in your delegate’s [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didExitRegion:)] method.) To begin ranging, pass the same [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLBeaconRegion] object you used for region monitoring to your location manager’s [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager\/startRangingBeacons(in:)] method.\n\nListing 2 shows an implementation of this delegate method that turns on ranging for a detected beacon. The method also adds the beacon to an internal array so that the app can stop and restart ranging at any time. For example, you might stop ranging when your app is in the background to save power.\n\nListing 2. Ranging for beacons\n\nWhen ranging is active, the location manager object calls the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didRangeBeacons:in:)] method of its delegate whenever there is a change to report. Use this method to take action based on the proximity of nearby beacons. Listing 3 shows how a museum app might use the proximity value to display information about the closest exhibit. In this example, the museum uses the major and minor values to identify each exhibit.\n\nListing 3. Acting on the nearest beacon",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreLocation\/determining-the-proximity-to-an-ibeacon-device\ncrawled: 2025-12-02T15:53:40Z\n---\n\n# Determining the proximity to an iBeacon device\n\n**Article**\n\nDetect beacons and determine the relative distance to them.\n\n## Overview\n\nAn iBeacon is a device that emits a Bluetooth signal that can be detected by your devices. Companies can deploy iBeacon devices in environments where proximity detection is a benefit to users, and apps can use the proximity of beacons to determine an appropriate course of action. You decide what actions to take based on the proximity of nearby beacons. For example, a department store might deploy beacons identifying each section of the store, and the corresponding app might point out sale items when the user is near each section.\n\nAdding iBeacon support to your app involves detecting beacons in two different stages:\n\n1. Use region monitoring to detect the presence of an iBeacon.\n2. Use beacon ranging to determine the proximity to a detected iBeacon.\n\nUsing a two-step process for detecting beacons significantly reduces power consumption. Ranging requires taking frequent measurements of the strength of Bluetooth signals and computing the distance to the associated beacons. By contrast, region monitoring involves only passive listening for nearby beacons, which consumes far less power.\n\n### Deploy your iBeacon hardware\n\nWhen deploying your iBeacon hardware, you must program each iBeacon with an appropriate proximity UUID, major value, and minor value. These values identify each of your beacons uniquely and make it possible for your app to differentiate between those beacons later.\n\n- The [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLBeacon\/uuid] (universally unique identifier) is a 128-bit value that uniquely identifies your app’s beacons.\n- The [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLBeacon\/major] value is a 16-bit unsigned integer that you use to differentiate groups of beacons with the same UUID.\n- The [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLBeacon\/minor] value is a 16-bit unsigned integer that you use to differentiate groups of beacons with the same UUID and major value.\n\nOnly the UUID is required, but it is recommended that you program all three values into your iBeacon hardware. In your app, you can look for related groups of beacons by specifying only a subset of values.\n\n### Detect the presence of beacons using region monitoring\n\nUse region monitoring to alert your app when an iBeacon is nearby. To monitor for beacons, create a [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLBeaconRegion] object and register it with the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager\/startMonitoring(for:)] method of your [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager] object. The beacon region contains the proximity UUID, major value, and minor value of the beacons that you want to detect. Only beacons with matching values trigger a call to your delegate object.\n\nListing 1 shows an example of how to set up region monitoring for a company’s beacons. Because you typically define a UUID for your company once and do not change it later, the example includes a hard-coded version of that value. Prior to calling this method, you must have created a [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager] object and assigned a delegate to it.\n\nListing 1. Setting up region monitoring for beacons\n\n```swift\nfunc monitorBeacons() {\n    if CLLocationManager.isMonitoringAvailable(for: \n                  CLBeaconRegion.self) {\n        \/\/ Match all beacons with the specified UUID\n        let proximityUUID = UUID(uuidString: \n               \"39ED98FF-2900-441A-802F-9C398FC199D2\")\n        let beaconID = \"com.example.myBeaconRegion\"\n            \n        \/\/ Create the region and begin monitoring it.\n        let region = CLBeaconRegion(proximityUUID: proximityUUID!,\n               identifier: beaconID)\n        self.locationManager.startMonitoring(for: region)\n    }\n}\n```\n\nWhen a matching iBeacon is detected, the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager] object notifies its delegate by calling the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didEnterRegion:)] method. Similarly, when a detected beacon moves out of range, the location manager calls the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didExitRegion:)] method. Use your delegate methods to start and stop beacon ranging.\n\nIf your app is not running when a beacon is detected, the system tries to launch your app.\n\n\n\n### Determine the proximity to beacons using ranging\n\nAfter detecting an iBeacon, use ranging to determine the relative distance between the beacon and the user’s device. Ranging reports when the two devices are far apart, near to each other, or in the immediate vicinity of each other; it does not offer a precise distance, nor should you rely on the strength of a beacon’s signal to compute that information yourself. Use the relative values to determine an appropriate course of action. For example, an app for an art museum might wait until the user is in the immediate vicinity of an iBeacon before offering information about the corresponding artwork.\n\n\n\nThe most logical place to start ranging is in your location manager delegate’s [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didEnterRegion:)] method when a beacon is first detected. (The place to stop ranging is in your delegate’s [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didExitRegion:)] method.) To begin ranging, pass the same [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLBeaconRegion] object you used for region monitoring to your location manager’s [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManager\/startRangingBeacons(in:)] method.\n\nListing 2 shows an implementation of this delegate method that turns on ranging for a detected beacon. The method also adds the beacon to an internal array so that the app can stop and restart ranging at any time. For example, you might stop ranging when your app is in the background to save power.\n\nListing 2. Ranging for beacons\n\n```swift\nfunc locationManager(_ manager: CLLocationManager, \n            didEnterRegion region: CLRegion) {\n    if region is CLBeaconRegion {\n        \/\/ Start ranging only if the devices supports this service.\n        if CLLocationManager.isRangingAvailable() {\n            manager.startRangingBeacons(in: region as! CLBeaconRegion)\n\n            \/\/ Store the beacon so that ranging can be stopped on demand.\n            beaconsToRange.append(region as! CLBeaconRegion)        \n        }\n    }\n}\n```\n\nWhen ranging is active, the location manager object calls the [doc:\/\/com.apple.corelocation\/documentation\/CoreLocation\/CLLocationManagerDelegate\/locationManager(_:didRangeBeacons:in:)] method of its delegate whenever there is a change to report. Use this method to take action based on the proximity of nearby beacons. Listing 3 shows how a museum app might use the proximity value to display information about the closest exhibit. In this example, the museum uses the major and minor values to identify each exhibit.\n\nListing 3. Acting on the nearest beacon\n\n```swift\nfunc locationManager(_ manager: CLLocationManager, \n            didRangeBeacons beacons: [CLBeacon], \n            in region: CLBeaconRegion) {\n    if beacons.count > 0 {\n        let nearestBeacon = beacons.first!\n        let major = CLBeaconMajorValue(nearestBeacon.major)\n        let minor = CLBeaconMinorValue(nearestBeacon.minor)\n            \n        switch nearestBeacon.proximity {\n        case .near, .immediate:\n            \/\/ Display information about the relevant exhibit.\n            displayInformationAboutExhibit(major: major, minor: minor)\n            break\n                \n        default:\n           \/\/ Dismiss exhibit information, if it is displayed.\n           dismissExhibit(major: major, minor: minor)\n           break\n           }\n        }\n    }\n```\n\n\n\n## iBeacon\n\n- **Ranging for Beacons**: Configure a device to act as a beacon and to detect surrounding beacons.\n- **Turning an iOS device into an iBeacon device**: Broadcast iBeacon signals from an iOS device.\n- **CLBeacon**: Information about an observed iBeacon device and its relative distance to a person’s device.\n- **CLCondition**: The abstract base class for all other monitor conditions.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Configure a device to act as a beacon and to detect surrounding beacons.",
          "name" : "Ranging for Beacons",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreLocation\/ranging-for-beacons"
        },
        {
          "description" : "Broadcast iBeacon signals from an iOS device.",
          "name" : "Turning an iOS device into an iBeacon device",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreLocation\/turning-an-ios-device-into-an-ibeacon-device"
        },
        {
          "description" : "Information about an observed iBeacon device and its relative distance to a person’s device.",
          "name" : "CLBeacon",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreLocation\/CLBeacon"
        },
        {
          "description" : "The abstract base class for all other monitor conditions.",
          "name" : "CLCondition",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreLocation\/CLCondition-swift.protocol"
        }
      ],
      "title" : "iBeacon"
    }
  ],
  "source" : "appleJSON",
  "title" : "Determining the proximity to an iBeacon device",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreLocation\/determining-the-proximity-to-an-ibeacon-device"
}