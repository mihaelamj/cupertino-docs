{
  "abstract" : "Provide a secure and convenient alternative to passwords.",
  "codeExamples" : [
    {
      "code" : "class BrowserAuthorizationController {\n  func authenticatePerson(for relyingParty: String) throws {\n    \/\/ Check the authorization state.\n    let credentialManager = ASAuthorizationWebBrowserPublicKeyCredentialManager()\n    switch(credentialManager.authorizationStateForPlatformCredentials) {\n    case .authorized:\n      \/\/ Use the credentials.\n      let credentials = credentialManager.platformCredentials(forRelyingParty: relyingParty)\n      self.respondToChallenge(for: relyingParty, using: credentials)\n    case .denied:\n      \/\/ Your app doesn't have access to the credentials.\n      throw BrowserError(\"Unable to access passkeys to authenticate with \\(relyingParty)\")\n    case .notDetermined:\n      \/\/ Request access to the credentials.\n      credentialManager.requestAuthorizationForPublicKeyCredentials() { authorizationState in\n        \/\/ Check the updated authorizationState, and use the credentials if possible.\n      }\n    }\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension BrowserAuthorizationController {\n  func startAuthenticationChallenge(for relyingParty: String,\n    selectedCredential: ASAuthorizationWebBrowserPlatformPublicKeyCredential?,\n    challengeData: Data) async {\n    let clientData = ASPublicKeyCredentialClientData(challenge: challengeData,\n      origin: self.requestOrigin)\n    let request = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: relyingParty)\n      .createCredentialAssertionRequest(clientData: clientData)\n    if let selectedCredential {\n      request.allowedCredentials = [ASAuthorizationPlatformPublicKeyCredentialDescriptor(credentialID: selectedCredential.credentialID)]\n    }\n    let controller = ASAuthorizationController(authorizationRequests: [request])\n    controller.delegate = self\n    controller.presentationContextProvider = self\n    controller.performRequests()\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension BrowserAuthorizationController : ASAuthorizationControllerPresentationContextProviding {\n  func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {\n    guard let window = self.view.window else {\n      fatalError(\"Started a credential request when the browser view isn't presented in a window.\")\n    }\n    return window\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension BrowserAuthorizationController : ASAuthorizationControllerDelegate {\n  func authorizationController(controller: ASAuthorizationController,\n    didCompleteWithAuthorization authorization: ASAuthorization) {\n    \/\/ The authorization was successful.\n    \/\/ Use the authorization parameter to retrieve the credential, and send that to the relying party website.\n  }\n\n  func authorizationController(controller: ASAuthorizationController,\n    didCompleteWithError error: Error) {\n    \/\/ The authorization failed.\n    \/\/ Use the error to find out what happened, and retry or notify someone.\n  }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "d37f7fb2a67158c1de4527ce8f74e986bcfb589b8436c628d90274ae0960213b",
  "crawledAt" : "2025-12-02T18:13:05Z",
  "id" : "BE9BAC79-0A30-40D6-B994-D447998BECB9",
  "kind" : "article",
  "language" : "swift",
  "module" : "Authentication Services",
  "overview" : "## Overview\n\nYour browser app on macOS or iOS can authenticate people to websites by using passkeys stored in the keychain, and managed by third-party credential providers. It can also create passkeys that the operating system stores in the keychain, or that third-party credential providers store. Optionally, when someone authenticates with a website, present your own UI to list the passkeys available for the website so they can choose which passkey to use; otherwise, delegate to the operating system’s UI to choose passkeys or, on iOS, use AutoFill.\n\nUse [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController] when performing requests defined in the WebAuthentication standard. If you present your own passkey-selection UI, you can specify [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationPlatformPublicKeyCredentialAssertionRequest\/allowedCredentials] to restrict the system UI to only show the selected passkey. Implement the authorization controller’s delegate callback to receive passkey request responses, which you return to the website that makes the request.\n\n### Request access to passkeys\n\nWhen someone wants to use a passkey to authenticate with a website, create an instance of [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager] and follow these steps:\n\n### Create an assertion request\n\nThe credentials you get from the credential manager don’t contain the key data; instead, they contain metadata that identifies the credentials to the operating system and to the authenticating person. If the array of credentials contains more than one credential, present them to the person so they can select which credential to use.\n\nCreate a credential assertion request, using the challenge data sent by the requesting website. If the person chose a credential to use, restrict the request to allow only that credential. Pass the request to an [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController] instance to complete the challenge.\n\nTo start an authorization request using AutoFill presentation on iOS, call [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController\/performAutoFillAssistedRequests()] on the authorization controller instead of [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController\/performRequests()].\n\n### Supply a presentation context provider\n\n[doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController] might need to present UI to complete the authentication challenge. Conform to [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationControllerPresentationContextProviding] to provide a window in which the controller can display its UI.\n\n### Implement authorization controller delegate callbacks\n\nConform to [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationControllerDelegate] to react to authorization completion. Implement methods to respond to successful authorization, and to get notified when errors occur.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AuthenticationServices\/authenticating-people-by-using-passkeys-in-browser-apps\ncrawled: 2025-12-02T18:13:05Z\n---\n\n# Authenticating people by using passkeys in browser apps\n\n**Article**\n\nProvide a secure and convenient alternative to passwords.\n\n## Overview\n\nYour browser app on macOS or iOS can authenticate people to websites by using passkeys stored in the keychain, and managed by third-party credential providers. It can also create passkeys that the operating system stores in the keychain, or that third-party credential providers store. Optionally, when someone authenticates with a website, present your own UI to list the passkeys available for the website so they can choose which passkey to use; otherwise, delegate to the operating system’s UI to choose passkeys or, on iOS, use AutoFill.\n\nUse [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController] when performing requests defined in the WebAuthentication standard. If you present your own passkey-selection UI, you can specify [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationPlatformPublicKeyCredentialAssertionRequest\/allowedCredentials] to restrict the system UI to only show the selected passkey. Implement the authorization controller’s delegate callback to receive passkey request responses, which you return to the website that makes the request.\n\n### Request access to passkeys\n\nWhen someone wants to use a passkey to authenticate with a website, create an instance of [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager] and follow these steps:\n\n- Get the credential manager’s [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager\/authorizationStateForPlatformCredentials] property to check whether your app can use passkeys stored in the keychain or in third-party credential managers.\n- If the state is [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager\/AuthorizationState\/authorized], then get the credentials associated with the relying party from the credential manager.\n- If the state is [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager\/AuthorizationState\/notDetermined], call [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager\/requestAuthorizationForPublicKeyCredentials(_:)], passing a completion handler that the operating system calls when someone grants or denies the request.\n- If the state is [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager\/AuthorizationState\/denied], the person doesn’t allow your app to use their passkeys.\n\n```swift\nclass BrowserAuthorizationController {\n  func authenticatePerson(for relyingParty: String) throws {\n    \/\/ Check the authorization state.\n    let credentialManager = ASAuthorizationWebBrowserPublicKeyCredentialManager()\n    switch(credentialManager.authorizationStateForPlatformCredentials) {\n    case .authorized:\n      \/\/ Use the credentials.\n      let credentials = credentialManager.platformCredentials(forRelyingParty: relyingParty)\n      self.respondToChallenge(for: relyingParty, using: credentials)\n    case .denied:\n      \/\/ Your app doesn't have access to the credentials.\n      throw BrowserError(\"Unable to access passkeys to authenticate with \\(relyingParty)\")\n    case .notDetermined:\n      \/\/ Request access to the credentials.\n      credentialManager.requestAuthorizationForPublicKeyCredentials() { authorizationState in\n        \/\/ Check the updated authorizationState, and use the credentials if possible.\n      }\n    }\n  }\n}\n```\n\n### Create an assertion request\n\nThe credentials you get from the credential manager don’t contain the key data; instead, they contain metadata that identifies the credentials to the operating system and to the authenticating person. If the array of credentials contains more than one credential, present them to the person so they can select which credential to use.\n\nCreate a credential assertion request, using the challenge data sent by the requesting website. If the person chose a credential to use, restrict the request to allow only that credential. Pass the request to an [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController] instance to complete the challenge.\n\n```swift\nextension BrowserAuthorizationController {\n  func startAuthenticationChallenge(for relyingParty: String,\n    selectedCredential: ASAuthorizationWebBrowserPlatformPublicKeyCredential?,\n    challengeData: Data) async {\n    let clientData = ASPublicKeyCredentialClientData(challenge: challengeData,\n      origin: self.requestOrigin)\n    let request = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: relyingParty)\n      .createCredentialAssertionRequest(clientData: clientData)\n    if let selectedCredential {\n      request.allowedCredentials = [ASAuthorizationPlatformPublicKeyCredentialDescriptor(credentialID: selectedCredential.credentialID)]\n    }\n    let controller = ASAuthorizationController(authorizationRequests: [request])\n    controller.delegate = self\n    controller.presentationContextProvider = self\n    controller.performRequests()\n  }\n}\n```\n\nTo start an authorization request using AutoFill presentation on iOS, call [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController\/performAutoFillAssistedRequests()] on the authorization controller instead of [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController\/performRequests()].\n\n### Supply a presentation context provider\n\n[doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationController] might need to present UI to complete the authentication challenge. Conform to [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationControllerPresentationContextProviding] to provide a window in which the controller can display its UI.\n\n```swift\nextension BrowserAuthorizationController : ASAuthorizationControllerPresentationContextProviding {\n  func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {\n    guard let window = self.view.window else {\n      fatalError(\"Started a credential request when the browser view isn't presented in a window.\")\n    }\n    return window\n  }\n}\n```\n\n### Implement authorization controller delegate callbacks\n\nConform to [doc:\/\/com.apple.authenticationservices\/documentation\/AuthenticationServices\/ASAuthorizationControllerDelegate] to react to authorization completion. Implement methods to respond to successful authorization, and to get notified when errors occur.\n\n```swift\nextension BrowserAuthorizationController : ASAuthorizationControllerDelegate {\n  func authorizationController(controller: ASAuthorizationController,\n    didCompleteWithAuthorization authorization: ASAuthorization) {\n    \/\/ The authorization was successful.\n    \/\/ Use the authorization parameter to retrieve the credential, and send that to the relying party website.\n  }\n\n  func authorizationController(controller: ASAuthorizationController,\n    didCompleteWithError error: Error) {\n    \/\/ The authorization failed.\n    \/\/ Use the error to find out what happened, and retry or notify someone.\n  }\n}\n```\n\n## Website authorization\n\n- **ASAuthorizationWebBrowserPublicKeyCredentialManager**: A class that you use to request access to a person’s passkeys in a web browser, and that reports on the access status.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A class that you use to request access to a person’s passkeys in a web browser, and that reports on the access status.",
          "name" : "ASAuthorizationWebBrowserPublicKeyCredentialManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/AuthenticationServices\/ASAuthorizationWebBrowserPublicKeyCredentialManager"
        }
      ],
      "title" : "Website authorization"
    }
  ],
  "source" : "appleJSON",
  "title" : "Authenticating people by using passkeys in browser apps",
  "url" : "https:\/\/developer.apple.com\/documentation\/AuthenticationServices\/authenticating-people-by-using-passkeys-in-browser-apps"
}