{
  "abstract" : "Create a signature from an audio file or the microphone for a reference track in a custom catalog, or for matching tracks in a catalog.",
  "codeExamples" : [
    {
      "code" : "\/\/ Return the signature of an audio file.\nfunc generateSignature(from audioURL: URL) -> SHSignature? {\n    \/\/ Step 1.\n    \/\/ Create an audio format that's compatible with ShazamKit.\n    guard let audioFormat = AVAudioFormat(standardFormatWithSampleRate: 44100, channels: 1) else {\n        \/\/ Handle an error in creating the audio format.\n        return nil\n    }\n\n    \/\/ Create a signature generator to generate the final signature.\n    let signatureGenerator = SHSignatureGenerator()\n    \n    do {\n        \/\/ Create an object for reading the audio file.\n        let audioFile = try AVAudioFile(forReading: audioURL)\n\n        \/\/ Step 2.\n        \/\/ Convert the audio to a supported format.\n        CustomCatalog.convert(audioFile: audioFile, outputFormat: audioFormat) { buffer in\n            do {\n                \/\/ Step 3.\n                \/\/ Append portions of the converted audio to the signature generator.\n                try signatureGenerator.append(buffer, at: nil)\n            } catch {\n                \/\/ Handle an error generating the signature.\n                return\n            }\n        }\n    } catch {\n        \/\/ Handle an error reading the audio file.\n        return nil\n    }\n\n    \/\/ Step 4.\n    \/\/ Generate the signature.\n    return signatureGenerator.signature()\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Convert an audio file to a new format one chunk at a time.\nstatic func convert(audioFile: AVAudioFile,\n                    outputFormat: AVAudioFormat,\n                    processConvertedBlock: (AVAudioPCMBuffer) -> Void) {\n    \/\/ Set the size of the conversion buffer.\n    let frameCount = AVAudioFrameCount(\n        (1024 * 64) \/ (audioFile.processingFormat.streamDescription.pointee.mBytesPerFrame)\n    )\n    \/\/ Calculate the number of frames for the output buffer.\n    let outputFrameCapacity = AVAudioFrameCount(\n         round(Double(frameCount) * (outputFormat.sampleRate \/ audioFile.processingFormat.sampleRate))\n    )\n\n    \/\/ Create the input and output buffers for converting the file.\n    guard let inputBuffer = AVAudioPCMBuffer(pcmFormat: audioFile.processingFormat, frameCapacity: frameCount),\n          let outputBuffer = AVAudioPCMBuffer(pcmFormat: outputFormat, frameCapacity: outputFrameCapacity) else {\n        return\n    }\n\n    \/\/ Create the format for the converter.\n    guard let converter = AVAudioConverter(from: audioFile.processingFormat, to: outputFormat) else {\n        return\n    }\n    \n   \/\/ Code to convert the file goes here. See the next listing.\n}",
      "language" : "swift"
    },
    {
      "code" : "    \/\/ Convert the audio file.\n    while true {\n    \/\/ Convert frames in the input buffer, writing them to the output buffer.\n        let status = converter.convert(to: outputBuffer,\n                                       error: nil) { inNumPackets, outStatus in\n            do {\n                \/\/ Read a frame from the audio file into the input buffer.\n                try audioFile.read(into: inputBuffer)\n                outStatus.pointee = .haveData\n                return inputBuffer\n            } catch {\n                \/\/ Check if it's the end of the file or if an error occurred.\n                if audioFile.framePosition >= audioFile.length {\n                    outStatus.pointee = .endOfStream\n                    return nil\n                } else {\n                    outStatus.pointee = .noDataNow\n                    return nil\n                }\n            }\n        }\n\n        switch status {\n        case .error:\n            \/\/ An error occurred during conversion; handle the error.\n            return\n\n        case .endOfStream:\n            \/\/ All of the input is converted.\n            return\n\n        case .inputRanDry:\n            \/\/ Some data was converted, but no more is available.\n            processConvertedBlock(outputBuffer)\n            return\n\n        default:\n            processConvertedBlock(outputBuffer)\n        }\n\n        \/\/ Reset the size of the buffers.\n        inputBuffer.frameLength = 0\n        outputBuffer.frameLength = 0\n    }\n",
      "language" : "swift"
    },
    {
      "code" : "func addAudio(buffer: AVAudioPCMBuffer, audioTime: AVAudioTime) {\n    do {\n        \/\/ Add the audio to the signature generator.\n        try signatureGenerator.append(buffer, at: audioTime)\n    } catch {\n        \/\/ Handle an error in appending audio to the generator.\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ccdd4416f2cce5c9bb86ba7b2b0c8d836f87e41d2aa66deea0a5742e4ef7f016",
  "crawledAt" : "2025-12-02T07:53:59Z",
  "id" : "BDFF5EE6-26DF-4399-9E85-A7ECB0B201EF",
  "kind" : "article",
  "module" : "ShazamKit",
  "overview" : "## Overview\n\nGenerate a signature by adding an audio buffer in a supported format to an [doc:\/\/com.apple.shazamkit\/documentation\/ShazamKit\/SHSignatureGenerator] object. You can add the audio buffer in one call or incrementally.\n\nThe most common sources for audio are files in the app or the microphone.\n\n### Create a signature from an audio file\n\nCreating a signature from an audio file takes four steps:\n\nThe following demonstrates how to generate the signature from the audio file:\n\nThe convert function has two main parts. First it configures the buffers used for the conversion and the format for the converted audio:\n\nThen the convert function reads chunks of audio from the input file and calls the block passed by `generateSignature`. That block appends the converted audio to the signature.\n\n### Create a signature from the microphone\n\nUsing the microphone as the source for generating a signature is very similar to using it for matching.\n\nConfigure a mixer as described in [doc:\/\/com.apple.shazamkit\/documentation\/ShazamKit\/matching-audio-using-the-built-in-microphone]. Change the `addAudio` function to append the audio to the signature generator:\n\nStart and stop the audio engine as needed using the `startListening` and `stopListening` functions shown in [doc:\/\/com.apple.shazamkit\/documentation\/ShazamKit\/matching-audio-using-the-built-in-microphone].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ShazamKit\/generating-a-signature-from-an-audio-buffer\ncrawled: 2025-12-02T07:53:59Z\n---\n\n# Generating a signature from an audio buffer\n\n**Article**\n\nCreate a signature from an audio file or the microphone for a reference track in a custom catalog, or for matching tracks in a catalog.\n\n## Overview\n\nGenerate a signature by adding an audio buffer in a supported format to an [doc:\/\/com.apple.shazamkit\/documentation\/ShazamKit\/SHSignatureGenerator] object. You can add the audio buffer in one call or incrementally.\n\nThe most common sources for audio are files in the app or the microphone.\n\n### Create a signature from an audio file\n\nCreating a signature from an audio file takes four steps:\n\n1. Create an object for reading the audio file.\n2. Convert the audio to a supported format. For a list of supported formats, see [doc:\/\/com.apple.shazamkit\/documentation\/ShazamKit\/SHSignatureGenerator\/append(_:at:)].\n3. Append the converted audio to a signature generator.\n4. Generate the signature.\n\nThe following demonstrates how to generate the signature from the audio file:\n\n```swift\n\/\/ Return the signature of an audio file.\nfunc generateSignature(from audioURL: URL) -> SHSignature? {\n    \/\/ Step 1.\n    \/\/ Create an audio format that's compatible with ShazamKit.\n    guard let audioFormat = AVAudioFormat(standardFormatWithSampleRate: 44100, channels: 1) else {\n        \/\/ Handle an error in creating the audio format.\n        return nil\n    }\n\n    \/\/ Create a signature generator to generate the final signature.\n    let signatureGenerator = SHSignatureGenerator()\n    \n    do {\n        \/\/ Create an object for reading the audio file.\n        let audioFile = try AVAudioFile(forReading: audioURL)\n\n        \/\/ Step 2.\n        \/\/ Convert the audio to a supported format.\n        CustomCatalog.convert(audioFile: audioFile, outputFormat: audioFormat) { buffer in\n            do {\n                \/\/ Step 3.\n                \/\/ Append portions of the converted audio to the signature generator.\n                try signatureGenerator.append(buffer, at: nil)\n            } catch {\n                \/\/ Handle an error generating the signature.\n                return\n            }\n        }\n    } catch {\n        \/\/ Handle an error reading the audio file.\n        return nil\n    }\n\n    \/\/ Step 4.\n    \/\/ Generate the signature.\n    return signatureGenerator.signature()\n}\n```\n\nThe convert function has two main parts. First it configures the buffers used for the conversion and the format for the converted audio:\n\n```swift\n\/\/ Convert an audio file to a new format one chunk at a time.\nstatic func convert(audioFile: AVAudioFile,\n                    outputFormat: AVAudioFormat,\n                    processConvertedBlock: (AVAudioPCMBuffer) -> Void) {\n    \/\/ Set the size of the conversion buffer.\n    let frameCount = AVAudioFrameCount(\n        (1024 * 64) \/ (audioFile.processingFormat.streamDescription.pointee.mBytesPerFrame)\n    )\n    \/\/ Calculate the number of frames for the output buffer.\n    let outputFrameCapacity = AVAudioFrameCount(\n         round(Double(frameCount) * (outputFormat.sampleRate \/ audioFile.processingFormat.sampleRate))\n    )\n\n    \/\/ Create the input and output buffers for converting the file.\n    guard let inputBuffer = AVAudioPCMBuffer(pcmFormat: audioFile.processingFormat, frameCapacity: frameCount),\n          let outputBuffer = AVAudioPCMBuffer(pcmFormat: outputFormat, frameCapacity: outputFrameCapacity) else {\n        return\n    }\n\n    \/\/ Create the format for the converter.\n    guard let converter = AVAudioConverter(from: audioFile.processingFormat, to: outputFormat) else {\n        return\n    }\n    \n   \/\/ Code to convert the file goes here. See the next listing.\n}\n```\n\nThen the convert function reads chunks of audio from the input file and calls the block passed by `generateSignature`. That block appends the converted audio to the signature.\n\n```swift\n    \/\/ Convert the audio file.\n    while true {\n    \/\/ Convert frames in the input buffer, writing them to the output buffer.\n        let status = converter.convert(to: outputBuffer,\n                                       error: nil) { inNumPackets, outStatus in\n            do {\n                \/\/ Read a frame from the audio file into the input buffer.\n                try audioFile.read(into: inputBuffer)\n                outStatus.pointee = .haveData\n                return inputBuffer\n            } catch {\n                \/\/ Check if it's the end of the file or if an error occurred.\n                if audioFile.framePosition >= audioFile.length {\n                    outStatus.pointee = .endOfStream\n                    return nil\n                } else {\n                    outStatus.pointee = .noDataNow\n                    return nil\n                }\n            }\n        }\n\n        switch status {\n        case .error:\n            \/\/ An error occurred during conversion; handle the error.\n            return\n\n        case .endOfStream:\n            \/\/ All of the input is converted.\n            return\n\n        case .inputRanDry:\n            \/\/ Some data was converted, but no more is available.\n            processConvertedBlock(outputBuffer)\n            return\n\n        default:\n            processConvertedBlock(outputBuffer)\n        }\n\n        \/\/ Reset the size of the buffers.\n        inputBuffer.frameLength = 0\n        outputBuffer.frameLength = 0\n    }\n\n```\n\n### Create a signature from the microphone\n\nUsing the microphone as the source for generating a signature is very similar to using it for matching.\n\nConfigure a mixer as described in [doc:\/\/com.apple.shazamkit\/documentation\/ShazamKit\/matching-audio-using-the-built-in-microphone]. Change the `addAudio` function to append the audio to the signature generator:\n\n```swift\nfunc addAudio(buffer: AVAudioPCMBuffer, audioTime: AVAudioTime) {\n    do {\n        \/\/ Add the audio to the signature generator.\n        try signatureGenerator.append(buffer, at: audioTime)\n    } catch {\n        \/\/ Handle an error in appending audio to the generator.\n    }\n}\n```\n\nStart and stop the audio engine as needed using the `startListening` and `stopListening` functions shown in [doc:\/\/com.apple.shazamkit\/documentation\/ShazamKit\/matching-audio-using-the-built-in-microphone].\n\n## Generating a signature from audio\n\n- **append(_:at:)**: Adds audio to the generator.\n- **signature()**: Converts the audio buffer into a signature.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Adds audio to the generator.",
          "name" : "append(_:at:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/ShazamKit\/SHSignatureGenerator\/append(_:at:)"
        },
        {
          "description" : "Converts the audio buffer into a signature.",
          "name" : "signature()",
          "url" : "https:\/\/developer.apple.com\/documentation\/ShazamKit\/SHSignatureGenerator\/signature()"
        }
      ],
      "title" : "Generating a signature from audio"
    }
  ],
  "source" : "appleJSON",
  "title" : "Generating a signature from an audio buffer",
  "url" : "https:\/\/developer.apple.com\/documentation\/ShazamKit\/generating-a-signature-from-an-audio-buffer"
}