{
  "abstract" : "Estimate the shape of the physical environment using a polygonal mesh.",
  "codeExamples" : [
    {
      "code" : "arView.automaticallyConfigureSession = false\nlet configuration = ARWorldTrackingConfiguration()\nconfiguration.sceneReconstruction = .meshWithClassification",
      "language" : "swift"
    },
    {
      "code" : "arView.debugOptions.insert(.showSceneUnderstanding)",
      "language" : "swift"
    },
    {
      "code" : "arView.session.run(configuration)",
      "language" : "swift"
    },
    {
      "code" : "@IBAction func togglePlaneDetectionButtonPressed(_ button: UIButton) {\n    guard let configuration = arView.session.configuration as? ARWorldTrackingConfiguration else {\n        return\n    }\n    if configuration.planeDetection == [] {\n        configuration.planeDetection = [.horizontal, .vertical]\n        button.setTitle(\"Stop Plane Detection\", for: [])\n    } else {\n        configuration.planeDetection = []\n        button.setTitle(\"Start Plane Detection\", for: [])\n    }\n    arView.session.run(configuration)\n}",
      "language" : "swift"
    },
    {
      "code" : "if let result = arView.raycast(from: tapLocation, allowing: .estimatedPlane, alignment: .any).first {\n    \/\/ ...",
      "language" : "swift"
    },
    {
      "code" : "let resultAnchor = AnchorEntity(world: result.worldTransform)\nresultAnchor.addChild(sphere(radius: 0.01, color: .lightGray))\narView.scene.addAnchor(resultAnchor, removeAfter: 3)",
      "language" : "swift"
    },
    {
      "code" : "arView.automaticallyConfigureSession = false\nlet configuration = ARWorldTrackingConfiguration()\nconfiguration.sceneReconstruction = .meshWithClassification",
      "language" : "swift"
    },
    {
      "code" : "nearbyFaceWithClassification(to: result.worldTransform.position) { (centerOfFace, classification) in\n    \/\/ ...",
      "language" : "swift"
    },
    {
      "code" : "DispatchQueue.global().async {\n    for anchor in meshAnchors {\n        for index in 0..<anchor.geometry.faces.count {\n            \/\/ Get the center of the face so that we can compare it to the given location.\n            let geometricCenterOfFace = anchor.geometry.centerOf(faceWithIndex: index)\n            \n            \/\/ Convert the face's center to world coordinates.\n            var centerLocalTransform = matrix_identity_float4x4\n            centerLocalTransform.columns.3 = SIMD4<Float>(geometricCenterOfFace.0, geometricCenterOfFace.1, geometricCenterOfFace.2, 1)\n            let centerWorldPosition = (anchor.transform * centerLocalTransform).position\n             \n            \/\/ We're interested in a classification that is sufficiently close to the given location––within 5 cm.\n            let distanceToFace = distance(centerWorldPosition, location)\n            if distanceToFace <= 0.05 {\n                \/\/ Get the semantic classification of the face and finish the search.\n                let classification: ARMeshClassification = anchor.geometry.classificationOf(faceWithIndex: index)\n                completionBlock(centerWorldPosition, classification)\n                return\n            }\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "let textEntity = self.model(for: classification)",
      "language" : "swift"
    },
    {
      "code" : "let rayDirection = normalize(result.worldTransform.position - self.arView.cameraTransform.translation)\nlet textPositionInWorldCoordinates = result.worldTransform.position - (rayDirection * 0.1)",
      "language" : "swift"
    },
    {
      "code" : "let raycastDistance = distance(result.worldTransform.position, self.arView.cameraTransform.translation)\ntextEntity.scale = .one * raycastDistance",
      "language" : "swift"
    },
    {
      "code" : "var resultWithCameraOrientation = self.arView.cameraTransform\nresultWithCameraOrientation.translation = textPositionInWorldCoordinates\nlet textAnchor = AnchorEntity(world: resultWithCameraOrientation.matrix)\ntextAnchor.addChild(textEntity)\nself.arView.scene.addAnchor(textAnchor, removeAfter: 3)",
      "language" : "swift"
    },
    {
      "code" : "if let centerOfFace = centerOfFace {\n    let faceAnchor = AnchorEntity(world: centerOfFace)\n    faceAnchor.addChild(self.sphere(radius: 0.01, color: classification.color))\n    self.arView.scene.addAnchor(faceAnchor, removeAfter: 3)\n    \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "arView.environment.sceneUnderstanding.options.insert(.occlusion)",
      "language" : "swift"
    },
    {
      "code" : "arView.environment.sceneUnderstanding.options.insert(.physics)",
      "language" : "swift"
    },
    {
      "code" : "if model.collision == nil {\n    model.generateCollisionShapes(recursive: true)\n    model.physicsBody = .init()\n}",
      "language" : "swift"
    },
    {
      "code" : "Timer.scheduledTimer(withTimeInterval: seconds, repeats: false) { (timer) in\n    model.physicsBody?.mode = .dynamic\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "933a6ec17ea81a904eabe0a3f4377f2684f7c00eb91171fb9c573db69a8dfa7c",
  "crawledAt" : "2025-12-02T15:29:27Z",
  "id" : "C52E5C50-F008-4B7B-9D93-75799DED7C2A",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nOn a fourth-generation iPad Pro running iPadOS 13.4 or later, ARKit uses the LiDAR Scanner to create a polygonal model of the physical environment. The LiDAR Scanner quickly retrieves depth information in front of the person for ARKit to estimate and reconstruct the shape of the real world. ARKit converts the depth information into a series of vertices that connect to form a mesh. To partition the information, ARKit makes multiple anchors, each assigned a unique portion of the mesh. Collectively, the mesh anchors represent the real-world scene around the person.\n\nWith these meshes, you can:\n\nThis sample app presents an AR experience using RealityKit. The figure below illustrates how RealityKit leverages real-world information from ARKit, and creates a debug visualization when you run this app and point the device at a chair in the real world.\n\n\n\n## Visualize the shape of the physical environment\n\nTo enable scene meshes, the sample sets a world-configuration’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/sceneReconstruction] property to one of the mesh options.\n\nThe sample uses RealityKit’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView] to render its graphics. To visualize meshes at runtime, [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView] offers the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/sceneUnderstanding-swift.property] debugging option.\n\nTo begin the AR experience, the sample configures and runs the session when the app first starts, in the main view controller’s `viewDidLoad` callback.\n\n### Add plane detection\n\nWhen an app enables plane detection with scene reconstruction, ARKit considers that information when making the mesh. Where the LiDAR scanner may produce a slightly uneven mesh on a real-world surface, ARKit flattens the mesh where it detects a plane on that surface.\n\nTo demonstrate the difference that plane detection makes on meshes, this app displays a toggle button. In the button handler, the sample adjusts the plane-detection configuration and restarts the session to effect the change.\n\n## Locate a Point on an Object’s Surface\n\nApps that retrieve surface locations using meshes can achieve unprecedented accuracy. By considering the mesh, raycasts can intersect with nonplanar surfaces, or surfaces with little or no features, like white walls.\n\nTo demonstrate accurate raycast results, this app casts a ray when the user taps the screen. The sample specifies the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARRaycastQuery\/Target-swift.enum\/estimatedPlane] allowable-target, and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARRaycastQuery\/TargetAlignment-swift.enum\/any] alignment option, as required to retrieve a point on a meshed, real-world object.\n\n\n\nWhen the user’s raycast returns a result, this app gives visual feedback by placing a small sphere at the intersection point.\n\n\n\n## Classify Real-World Objects\n\nARKit has a classification feature that analyzes its meshed model of the world to recognize specific, real-world objects. Within the mesh, ARKit can classify floors, tables, seats, windows, and ceilings. See [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARMeshClassification] for the full list.\n\nIf the user taps the screen and the raycast intersects with a meshed, real-world object, this app displays text of the mesh’s classification.\n\n\n\nWhen the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/automaticallyConfigureSession] property of [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView] is `true`, RealityKit disables classification by default because it isn’t required for occlusion and physics. To enable mesh classification, the sample overrides the default by setting the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/sceneReconstruction] property to [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/SceneReconstruction\/meshWithClassification].\n\nThis app attempts to retrieve a classification for the intersection point from the mesh.\n\nThe mesh consists of triangles, called *faces*. ARKit assigns a classification for each face, and the app searches through the mesh for a face near the intersection point. If the face has a classification, the app displays it onscreen. Because this routine involves extensive processing, the sample processes the mesh faces asynchronously, so the renderer doesn’t stall.\n\nWith the classification in-hand, the sample creates 3D text to display it.\n\nTo prevent the mesh from partially occluding the text, the sample offsets the text slightly to help readability. The sample calculates the offset in the negative direction of the ray, which effectively moves the text slightly toward the camera, which is away from the surface.\n\nTo make the text always appear the same size on screen, the sample applies a scale based on text’s distance from the camera.\n\nTo display the text, the sample puts it in an anchored entity at the adjusted intersection-point, which is oriented to face the camera.\n\nTo visualize the location of the face’s vertex from which the classification was retrieved, the sample creates a small sphere at the vertex’s real-world position.\n\n\n\n### Occlude virtual content with a mesh\n\n*Occlusion* is a feature where parts of the real world cover an app’s virtual content, from the camera’s perspective. To achieve this illusion, RealityKit checks for any meshes in front of virtual content, viewed by the user, and omits drawing any part of the virtual content obscured by those meshes. The sample enables occlusion by adding the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/SceneUnderstanding-swift.struct\/Options-swift.struct] option to the environment’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/sceneUnderstanding-swift.property] property.\n\nAt runtime, this app omits drawing portions of the virtual text that are behind any part of the meshed, real world.\n\n\n\n### Interact with real-world objects using physics\n\nWith scene meshes, virtual content can interact with the physical environment realistically because the meshes give RealityKit’s physics engine an accurate model of the world. The sample enables physics by adding the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/SceneUnderstanding-swift.struct\/Options-swift.struct\/physics] option to the environment’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/sceneUnderstanding-swift.property] property.\n\nTo detect when virtual content comes in contact with a meshed, real-world object, the sample defines the text’s proportions using a collision shape in the `addAnchor(_:,removeAfter:)` [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/Scene] extension.\n\nWhen this app classifies an object and displays some text, it waits three seconds before dropping the virtual text. When the sample sets the text’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/HasPhysicsBody\/physicsBody]’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/PhysicsBodyComponent\/mode] to [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/PhysicsBodyMode\/dynamic], the text reacts to gravity by falling.\n\nAs the text falls, it reacts when colliding with a meshed, real-world object, such as landing on the floor.\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/visualizing-and-interacting-with-a-reconstructed-scene\ncrawled: 2025-12-02T15:29:27Z\n---\n\n# Visualizing and interacting with a reconstructed scene\n\n**Sample Code**\n\nEstimate the shape of the physical environment using a polygonal mesh.\n\n## Overview\n\nOn a fourth-generation iPad Pro running iPadOS 13.4 or later, ARKit uses the LiDAR Scanner to create a polygonal model of the physical environment. The LiDAR Scanner quickly retrieves depth information in front of the person for ARKit to estimate and reconstruct the shape of the real world. ARKit converts the depth information into a series of vertices that connect to form a mesh. To partition the information, ARKit makes multiple anchors, each assigned a unique portion of the mesh. Collectively, the mesh anchors represent the real-world scene around the person.\n\nWith these meshes, you can:\n\n- Locate points on real-world surfaces more accurately.\n- Classify real-world objects that ARKit can recognize.\n- Occlude your app’s virtual content with real-world objects that are in front of it.\n- Enable virtual content to interact with the physical environment realistically. For example, by bouncing a virtual ball off a real-world wall or having the ball follow the laws of physics.\n- Render shadows or re-light the real-world scene.\n\nThis sample app presents an AR experience using RealityKit. The figure below illustrates how RealityKit leverages real-world information from ARKit, and creates a debug visualization when you run this app and point the device at a chair in the real world.\n\n\n\n## Visualize the shape of the physical environment\n\nTo enable scene meshes, the sample sets a world-configuration’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/sceneReconstruction] property to one of the mesh options.\n\n```swift\narView.automaticallyConfigureSession = false\nlet configuration = ARWorldTrackingConfiguration()\nconfiguration.sceneReconstruction = .meshWithClassification\n```\n\nThe sample uses RealityKit’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView] to render its graphics. To visualize meshes at runtime, [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView] offers the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/sceneUnderstanding-swift.property] debugging option.\n\n```swift\narView.debugOptions.insert(.showSceneUnderstanding)\n```\n\n\n\nTo begin the AR experience, the sample configures and runs the session when the app first starts, in the main view controller’s `viewDidLoad` callback.\n\n```swift\narView.session.run(configuration)\n```\n\n### Add plane detection\n\nWhen an app enables plane detection with scene reconstruction, ARKit considers that information when making the mesh. Where the LiDAR scanner may produce a slightly uneven mesh on a real-world surface, ARKit flattens the mesh where it detects a plane on that surface.\n\nTo demonstrate the difference that plane detection makes on meshes, this app displays a toggle button. In the button handler, the sample adjusts the plane-detection configuration and restarts the session to effect the change.\n\n```swift\n@IBAction func togglePlaneDetectionButtonPressed(_ button: UIButton) {\n    guard let configuration = arView.session.configuration as? ARWorldTrackingConfiguration else {\n        return\n    }\n    if configuration.planeDetection == [] {\n        configuration.planeDetection = [.horizontal, .vertical]\n        button.setTitle(\"Stop Plane Detection\", for: [])\n    } else {\n        configuration.planeDetection = []\n        button.setTitle(\"Start Plane Detection\", for: [])\n    }\n    arView.session.run(configuration)\n}\n```\n\n## Locate a Point on an Object’s Surface\n\nApps that retrieve surface locations using meshes can achieve unprecedented accuracy. By considering the mesh, raycasts can intersect with nonplanar surfaces, or surfaces with little or no features, like white walls.\n\nTo demonstrate accurate raycast results, this app casts a ray when the user taps the screen. The sample specifies the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARRaycastQuery\/Target-swift.enum\/estimatedPlane] allowable-target, and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARRaycastQuery\/TargetAlignment-swift.enum\/any] alignment option, as required to retrieve a point on a meshed, real-world object.\n\n```swift\nif let result = arView.raycast(from: tapLocation, allowing: .estimatedPlane, alignment: .any).first {\n    \/\/ ...\n```\n\n\n\nWhen the user’s raycast returns a result, this app gives visual feedback by placing a small sphere at the intersection point.\n\n```swift\nlet resultAnchor = AnchorEntity(world: result.worldTransform)\nresultAnchor.addChild(sphere(radius: 0.01, color: .lightGray))\narView.scene.addAnchor(resultAnchor, removeAfter: 3)\n```\n\n\n\n## Classify Real-World Objects\n\nARKit has a classification feature that analyzes its meshed model of the world to recognize specific, real-world objects. Within the mesh, ARKit can classify floors, tables, seats, windows, and ceilings. See [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARMeshClassification] for the full list.\n\nIf the user taps the screen and the raycast intersects with a meshed, real-world object, this app displays text of the mesh’s classification.\n\n\n\nWhen the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/automaticallyConfigureSession] property of [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView] is `true`, RealityKit disables classification by default because it isn’t required for occlusion and physics. To enable mesh classification, the sample overrides the default by setting the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/sceneReconstruction] property to [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/SceneReconstruction\/meshWithClassification].\n\n```swift\narView.automaticallyConfigureSession = false\nlet configuration = ARWorldTrackingConfiguration()\nconfiguration.sceneReconstruction = .meshWithClassification\n```\n\nThis app attempts to retrieve a classification for the intersection point from the mesh.\n\n```swift\nnearbyFaceWithClassification(to: result.worldTransform.position) { (centerOfFace, classification) in\n    \/\/ ...\n```\n\nThe mesh consists of triangles, called *faces*. ARKit assigns a classification for each face, and the app searches through the mesh for a face near the intersection point. If the face has a classification, the app displays it onscreen. Because this routine involves extensive processing, the sample processes the mesh faces asynchronously, so the renderer doesn’t stall.\n\n```swift\nDispatchQueue.global().async {\n    for anchor in meshAnchors {\n        for index in 0..<anchor.geometry.faces.count {\n            \/\/ Get the center of the face so that we can compare it to the given location.\n            let geometricCenterOfFace = anchor.geometry.centerOf(faceWithIndex: index)\n            \n            \/\/ Convert the face's center to world coordinates.\n            var centerLocalTransform = matrix_identity_float4x4\n            centerLocalTransform.columns.3 = SIMD4<Float>(geometricCenterOfFace.0, geometricCenterOfFace.1, geometricCenterOfFace.2, 1)\n            let centerWorldPosition = (anchor.transform * centerLocalTransform).position\n             \n            \/\/ We're interested in a classification that is sufficiently close to the given location––within 5 cm.\n            let distanceToFace = distance(centerWorldPosition, location)\n            if distanceToFace <= 0.05 {\n                \/\/ Get the semantic classification of the face and finish the search.\n                let classification: ARMeshClassification = anchor.geometry.classificationOf(faceWithIndex: index)\n                completionBlock(centerWorldPosition, classification)\n                return\n            }\n        }\n    }\n```\n\nWith the classification in-hand, the sample creates 3D text to display it.\n\n```swift\nlet textEntity = self.model(for: classification)\n```\n\nTo prevent the mesh from partially occluding the text, the sample offsets the text slightly to help readability. The sample calculates the offset in the negative direction of the ray, which effectively moves the text slightly toward the camera, which is away from the surface.\n\n```swift\nlet rayDirection = normalize(result.worldTransform.position - self.arView.cameraTransform.translation)\nlet textPositionInWorldCoordinates = result.worldTransform.position - (rayDirection * 0.1)\n```\n\nTo make the text always appear the same size on screen, the sample applies a scale based on text’s distance from the camera.\n\n```swift\nlet raycastDistance = distance(result.worldTransform.position, self.arView.cameraTransform.translation)\ntextEntity.scale = .one * raycastDistance\n```\n\nTo display the text, the sample puts it in an anchored entity at the adjusted intersection-point, which is oriented to face the camera.\n\n```swift\nvar resultWithCameraOrientation = self.arView.cameraTransform\nresultWithCameraOrientation.translation = textPositionInWorldCoordinates\nlet textAnchor = AnchorEntity(world: resultWithCameraOrientation.matrix)\ntextAnchor.addChild(textEntity)\nself.arView.scene.addAnchor(textAnchor, removeAfter: 3)\n```\n\nTo visualize the location of the face’s vertex from which the classification was retrieved, the sample creates a small sphere at the vertex’s real-world position.\n\n```swift\nif let centerOfFace = centerOfFace {\n    let faceAnchor = AnchorEntity(world: centerOfFace)\n    faceAnchor.addChild(self.sphere(radius: 0.01, color: classification.color))\n    self.arView.scene.addAnchor(faceAnchor, removeAfter: 3)\n    \/\/ ...\n}\n```\n\n\n\n### Occlude virtual content with a mesh\n\n*Occlusion* is a feature where parts of the real world cover an app’s virtual content, from the camera’s perspective. To achieve this illusion, RealityKit checks for any meshes in front of virtual content, viewed by the user, and omits drawing any part of the virtual content obscured by those meshes. The sample enables occlusion by adding the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/SceneUnderstanding-swift.struct\/Options-swift.struct] option to the environment’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/sceneUnderstanding-swift.property] property.\n\n```swift\narView.environment.sceneUnderstanding.options.insert(.occlusion)\n```\n\nAt runtime, this app omits drawing portions of the virtual text that are behind any part of the meshed, real world.\n\n\n\n### Interact with real-world objects using physics\n\nWith scene meshes, virtual content can interact with the physical environment realistically because the meshes give RealityKit’s physics engine an accurate model of the world. The sample enables physics by adding the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/SceneUnderstanding-swift.struct\/Options-swift.struct\/physics] option to the environment’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/ARView\/Environment-swift.struct\/sceneUnderstanding-swift.property] property.\n\n```swift\narView.environment.sceneUnderstanding.options.insert(.physics)\n```\n\nTo detect when virtual content comes in contact with a meshed, real-world object, the sample defines the text’s proportions using a collision shape in the `addAnchor(_:,removeAfter:)` [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/Scene] extension.\n\n```swift\nif model.collision == nil {\n    model.generateCollisionShapes(recursive: true)\n    model.physicsBody = .init()\n}\n```\n\nWhen this app classifies an object and displays some text, it waits three seconds before dropping the virtual text. When the sample sets the text’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/HasPhysicsBody\/physicsBody]’s [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/PhysicsBodyComponent\/mode] to [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/PhysicsBodyMode\/dynamic], the text reacts to gravity by falling.\n\n```swift\nTimer.scheduledTimer(withTimeInterval: seconds, repeats: false) { (timer) in\n    model.physicsBody?.mode = .dynamic\n}\n```\n\nAs the text falls, it reacts when colliding with a meshed, real-world object, such as landing on the floor.\n\n\n\n## Occlusion\n\n- **Occluding virtual content with people**: Cover your app’s virtual content with people that ARKit perceives in the camera feed.\n- **Effecting People Occlusion in Custom Renderers**: Occlude your app’s virtual content where ARKit recognizes people in the camera feed by using matte generator.\n- **ARMatteGenerator**: An object that creates matte textures you use to occlude your app’s virtual content with people, that ARKit recognizes in the camera feed.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Cover your app’s virtual content with people that ARKit perceives in the camera feed.",
          "name" : "Occluding virtual content with people",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/occluding-virtual-content-with-people"
        },
        {
          "description" : "Occlude your app’s virtual content where ARKit recognizes people in the camera feed by using matte generator.",
          "name" : "Effecting People Occlusion in Custom Renderers",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/effecting-people-occlusion-in-custom-renderers"
        },
        {
          "description" : "An object that creates matte textures you use to occlude your app’s virtual content with people, that ARKit recognizes in the camera feed.",
          "name" : "ARMatteGenerator",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARMatteGenerator"
        }
      ],
      "title" : "Occlusion"
    }
  ],
  "source" : "appleJSON",
  "title" : "Visualizing and interacting with a reconstructed scene",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/visualizing-and-interacting-with-a-reconstructed-scene"
}