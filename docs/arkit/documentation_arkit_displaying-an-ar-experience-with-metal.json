{
  "abstract" : "Control rendering of your app’s virtual content on top of a camera feed.",
  "codeExamples" : [
    {
      "code" : "func updateGameState() {        \n    guard let currentFrame = session.currentFrame else {\n        return\n    }    \n    updateSharedUniforms(frame: currentFrame)\n    updateAnchors(frame: currentFrame)\n    updateCapturedImageTextures(frame: currentFrame)\n    \n    if viewportSizeDidChange {\n        viewportSizeDidChange = false\n        \n        updateImagePlane(frame: currentFrame)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func updateCapturedImageTextures(frame: ARFrame) {\n    \/\/ Create two textures (Y and CbCr) from the provided frame's captured image.\n    let pixelBuffer = frame.capturedImage\n    if (CVPixelBufferGetPlaneCount(pixelBuffer) < 2) {\n        return\n    }\n    capturedImageTextureY = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat:.r8Unorm, planeIndex:0)!\n    capturedImageTextureCbCr = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat:.rg8Unorm, planeIndex:1)!\n}\n\nfunc createTexture(fromPixelBuffer pixelBuffer: CVPixelBuffer, pixelFormat: MTLPixelFormat, planeIndex: Int) -> MTLTexture? {\n    var mtlTexture: MTLTexture? = nil\n    let width = CVPixelBufferGetWidthOfPlane(pixelBuffer, planeIndex)\n    let height = CVPixelBufferGetHeightOfPlane(pixelBuffer, planeIndex)\n    \n    var texture: CVMetalTexture? = nil\n    let status = CVMetalTextureCacheCreateTextureFromImage(nil, capturedImageTextureCache, pixelBuffer, nil, pixelFormat, width, height, planeIndex, &texture)\n    if status == kCVReturnSuccess {\n        mtlTexture = CVMetalTextureGetTexture(texture!)\n    }\n    \n    return mtlTexture\n}",
      "language" : "swift"
    },
    {
      "code" : "fragment float4 capturedImageFragmentShader(ImageColorInOut in [[stage_in]],\n                                            texture2d<float, access::sample> capturedImageTextureY [[ texture(kTextureIndexY) ]],\n                                            texture2d<float, access::sample> capturedImageTextureCbCr [[ texture(kTextureIndexCbCr) ]]) {\n    \n    constexpr sampler colorSampler(mip_filter::linear,\n                                   mag_filter::linear,\n                                   min_filter::linear);\n    \n    const float4x4 ycbcrToRGBTransform = float4x4(\n        float4(+1.0000f, +1.0000f, +1.0000f, +0.0000f),\n        float4(+0.0000f, -0.3441f, +1.7720f, +0.0000f),\n        float4(+1.4020f, -0.7141f, +0.0000f, +0.0000f),\n        float4(-0.7010f, +0.5291f, -0.8860f, +1.0000f)\n    );\n    \n    \/\/ Sample Y and CbCr textures to get the YCbCr color at the given texture coordinate.\n    float4 ycbcr = float4(capturedImageTextureY.sample(colorSampler, in.texCoord).r,\n                          capturedImageTextureCbCr.sample(colorSampler, in.texCoord).rg, 1.0);\n    \n    \/\/ Return the converted RGB color.\n    return ycbcrToRGBTransform * ycbcr;\n}",
      "language" : "cpp"
    },
    {
      "code" : "func handleTap(gestureRecognize: UITapGestureRecognizer) {\n    \/\/ Create an anchor using the camera's current position.\n    if let currentFrame = session.currentFrame {\n        \n        \/\/ Create a transform with a translation of 0.2 meters in front of the camera.\n        var translation = matrix_identity_float4x4\n        translation.columns.3.z = -0.2\n        let transform = simd_mul(currentFrame.camera.transform, translation)\n        \n        \/\/ Add a new anchor to the session.\n        let anchor = ARAnchor(transform: transform)\n        session.add(anchor: anchor)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func updateAnchors(frame: ARFrame) {\n    \/\/ Update the anchor's uniform buffer with transforms of the current frame's anchors.\n    anchorInstanceCount = min(frame.anchors.count, kMaxAnchorInstanceCount)\n    \n    var anchorOffset: Int = 0\n    if anchorInstanceCount == kMaxAnchorInstanceCount {\n        anchorOffset = max(frame.anchors.count - kMaxAnchorInstanceCount, 0)\n    }\n    \n    for index in 0..<anchorInstanceCount {\n        let anchor = frame.anchors[index + anchorOffset]\n        \n        \/\/ Flip the Z axis to convert geometry from right handed to left handed.\n        var coordinateSpaceTransform = matrix_identity_float4x4\n        coordinateSpaceTransform.columns.2.z = -1.0\n        \n        let modelMatrix = simd_mul(anchor.transform, coordinateSpaceTransform)\n        \n        let anchorUniforms = anchorUniformBufferAddress.assumingMemoryBound(to: InstanceUniforms.self).advanced(by: index)\n        anchorUniforms.pointee.modelMatrix = modelMatrix\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Set up the scene's lighting with the ambient intensity, if available.\nvar ambientIntensity: Float = 1.0\nif let lightEstimate = frame.lightEstimate {\n    ambientIntensity = Float(lightEstimate.ambientIntensity) \/ 1000.0\n}\nlet ambientLightColor: vector_float3 = vector3(0.5, 0.5, 0.5)\nuniforms.pointee.ambientLightColor = ambientLightColor * ambientIntensity",
      "language" : "swift"
    }
  ],
  "contentHash" : "410b0a97c68ebeb74f06c38f9804df363bcd715f60798be46701aaab78cc303b",
  "crawledAt" : "2025-12-03T15:48:10Z",
  "id" : "93E69476-8BC9-4109-90E7-8601D42EA2FD",
  "kind" : "article",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nARKit includes view classes for easily displaying AR experiences with SceneKit or SpriteKit. However, if instead you build your own rendering engine using [doc:\/\/com.apple.documentation\/documentation\/Metal], ARKit also provides all the support necessary to display an AR experience with your custom view.\n\n\n\nIn any AR experience, the first step is to configure an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] object to manage camera capture and motion processing. A session defines and maintains a correspondence between the real-world space the device inhabits and a virtual space where you model AR content. To display your AR experience in a custom view, you’ll need to:\n\n### Get Video Frames and Tracking Data from the Session\n\nCreate and maintain your own [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] instance, and run it with a session configuration appropriate for the kind of AR experience you want to support. The session captures video from the camera, tracks the device’s position and orientation in a modeled 3D space, and provides [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] objects. Each such object contains both an individual video frame image and position tracking information from the moment that frame was captured.\n\nThere are two ways to access [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] objects produced by an AR session, depending on whether your app favors a pull or a push design pattern.\n\nIf you prefer to control frame timing (the pull design pattern), use the session’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/currentFrame] property to get the current frame image and tracking information each time you redraw your view’s contents. For example, see the following function that a custom renderer calls as part of its regular update process:\n\nAlternatively, if your app design favors a push pattern, implement the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didUpdate:)-9v2kw] delegate method, and the session will call it once for each video frame it captures (at 60 frames per second by default).\n\nUpon obtaining a frame, you’ll need to draw the camera image, and update and render any overlay content your AR experience includes.\n\n### Draw the Camera Image\n\nEach [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] object’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame\/capturedImage] property contains a pixel buffer captured from the device camera. To draw this image as the backdrop for your custom view, you’ll need to create textures from the image content and submit GPU rendering commands that use those textures.\n\nThe pixel buffer’s contents are encoded in a biplanar YCbCr (also called YUV) data format; to render the image you’ll need to convert this pixel data to a drawable RGB format. For rendering with Metal, you can perform this conversion most efficiently in GPU shader code. Use [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvmetaltexturecache-q3j] APIs to create two Metal textures from the pixel buffer—one each for the buffer’s luma (Y) and chroma (CbCr) planes:\n\nNext, encode render commands that draw those two textures using a fragment function that performs YCbCr to RGB conversion with a color transform matrix:\n\n### Track and Render Overlay Content\n\nAR experiences typically focus on rendering 3D overlay content so that the content appears to be part of the real world seen in the camera image. To achieve this illusion, use the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] class to model the position and orientation of your own 3D content relative to real-world space. Anchors provide transforms that you can reference during rendering.\n\nFor example, the Xcode template creates an anchor located about 20 cm in front of the device whenever a user taps on the screen:\n\nIn your rendering engine, use the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor\/transform] property of each [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] object to place visual content. The Xcode template uses each of the anchors added to the session in its `handleTap` method to position a simple cube mesh:\n\n### Render with Realistic Lighting\n\nWhen you configure shaders for drawing 3D content in your scene, use the estimated lighting information in each [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] object to produce more realistic shading. See the following code that an app’s custom renderer performs while updating its shared uniforms:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/displaying-an-ar-experience-with-metal\ncrawled: 2025-12-03T15:48:10Z\n---\n\n# Displaying an AR Experience with Metal\n\n**Article**\n\nControl rendering of your app’s virtual content on top of a camera feed.\n\n## Overview\n\nARKit includes view classes for easily displaying AR experiences with SceneKit or SpriteKit. However, if instead you build your own rendering engine using [doc:\/\/com.apple.documentation\/documentation\/Metal], ARKit also provides all the support necessary to display an AR experience with your custom view.\n\n\n\nIn any AR experience, the first step is to configure an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] object to manage camera capture and motion processing. A session defines and maintains a correspondence between the real-world space the device inhabits and a virtual space where you model AR content. To display your AR experience in a custom view, you’ll need to:\n\n1. Retrieve video  frames and tracking information from the session.\n2. Render those frame images as the backdrop for your view.\n3. Use the tracking information to position and draw AR content atop the camera image.\n\n\n\n### Get Video Frames and Tracking Data from the Session\n\nCreate and maintain your own [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] instance, and run it with a session configuration appropriate for the kind of AR experience you want to support. The session captures video from the camera, tracks the device’s position and orientation in a modeled 3D space, and provides [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] objects. Each such object contains both an individual video frame image and position tracking information from the moment that frame was captured.\n\nThere are two ways to access [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] objects produced by an AR session, depending on whether your app favors a pull or a push design pattern.\n\nIf you prefer to control frame timing (the pull design pattern), use the session’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/currentFrame] property to get the current frame image and tracking information each time you redraw your view’s contents. For example, see the following function that a custom renderer calls as part of its regular update process:\n\n```swift\nfunc updateGameState() {        \n    guard let currentFrame = session.currentFrame else {\n        return\n    }    \n    updateSharedUniforms(frame: currentFrame)\n    updateAnchors(frame: currentFrame)\n    updateCapturedImageTextures(frame: currentFrame)\n    \n    if viewportSizeDidChange {\n        viewportSizeDidChange = false\n        \n        updateImagePlane(frame: currentFrame)\n    }\n}\n```\n\nAlternatively, if your app design favors a push pattern, implement the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didUpdate:)-9v2kw] delegate method, and the session will call it once for each video frame it captures (at 60 frames per second by default).\n\nUpon obtaining a frame, you’ll need to draw the camera image, and update and render any overlay content your AR experience includes.\n\n### Draw the Camera Image\n\nEach [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] object’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame\/capturedImage] property contains a pixel buffer captured from the device camera. To draw this image as the backdrop for your custom view, you’ll need to create textures from the image content and submit GPU rendering commands that use those textures.\n\nThe pixel buffer’s contents are encoded in a biplanar YCbCr (also called YUV) data format; to render the image you’ll need to convert this pixel data to a drawable RGB format. For rendering with Metal, you can perform this conversion most efficiently in GPU shader code. Use [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvmetaltexturecache-q3j] APIs to create two Metal textures from the pixel buffer—one each for the buffer’s luma (Y) and chroma (CbCr) planes:\n\n```swift\nfunc updateCapturedImageTextures(frame: ARFrame) {\n    \/\/ Create two textures (Y and CbCr) from the provided frame's captured image.\n    let pixelBuffer = frame.capturedImage\n    if (CVPixelBufferGetPlaneCount(pixelBuffer) < 2) {\n        return\n    }\n    capturedImageTextureY = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat:.r8Unorm, planeIndex:0)!\n    capturedImageTextureCbCr = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat:.rg8Unorm, planeIndex:1)!\n}\n\nfunc createTexture(fromPixelBuffer pixelBuffer: CVPixelBuffer, pixelFormat: MTLPixelFormat, planeIndex: Int) -> MTLTexture? {\n    var mtlTexture: MTLTexture? = nil\n    let width = CVPixelBufferGetWidthOfPlane(pixelBuffer, planeIndex)\n    let height = CVPixelBufferGetHeightOfPlane(pixelBuffer, planeIndex)\n    \n    var texture: CVMetalTexture? = nil\n    let status = CVMetalTextureCacheCreateTextureFromImage(nil, capturedImageTextureCache, pixelBuffer, nil, pixelFormat, width, height, planeIndex, &texture)\n    if status == kCVReturnSuccess {\n        mtlTexture = CVMetalTextureGetTexture(texture!)\n    }\n    \n    return mtlTexture\n}\n```\n\nNext, encode render commands that draw those two textures using a fragment function that performs YCbCr to RGB conversion with a color transform matrix:\n\n```cpp\nfragment float4 capturedImageFragmentShader(ImageColorInOut in [[stage_in]],\n                                            texture2d<float, access::sample> capturedImageTextureY [[ texture(kTextureIndexY) ]],\n                                            texture2d<float, access::sample> capturedImageTextureCbCr [[ texture(kTextureIndexCbCr) ]]) {\n    \n    constexpr sampler colorSampler(mip_filter::linear,\n                                   mag_filter::linear,\n                                   min_filter::linear);\n    \n    const float4x4 ycbcrToRGBTransform = float4x4(\n        float4(+1.0000f, +1.0000f, +1.0000f, +0.0000f),\n        float4(+0.0000f, -0.3441f, +1.7720f, +0.0000f),\n        float4(+1.4020f, -0.7141f, +0.0000f, +0.0000f),\n        float4(-0.7010f, +0.5291f, -0.8860f, +1.0000f)\n    );\n    \n    \/\/ Sample Y and CbCr textures to get the YCbCr color at the given texture coordinate.\n    float4 ycbcr = float4(capturedImageTextureY.sample(colorSampler, in.texCoord).r,\n                          capturedImageTextureCbCr.sample(colorSampler, in.texCoord).rg, 1.0);\n    \n    \/\/ Return the converted RGB color.\n    return ycbcrToRGBTransform * ycbcr;\n}\n```\n\n\n\n### Track and Render Overlay Content\n\nAR experiences typically focus on rendering 3D overlay content so that the content appears to be part of the real world seen in the camera image. To achieve this illusion, use the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] class to model the position and orientation of your own 3D content relative to real-world space. Anchors provide transforms that you can reference during rendering.\n\nFor example, the Xcode template creates an anchor located about 20 cm in front of the device whenever a user taps on the screen:\n\n```swift\nfunc handleTap(gestureRecognize: UITapGestureRecognizer) {\n    \/\/ Create an anchor using the camera's current position.\n    if let currentFrame = session.currentFrame {\n        \n        \/\/ Create a transform with a translation of 0.2 meters in front of the camera.\n        var translation = matrix_identity_float4x4\n        translation.columns.3.z = -0.2\n        let transform = simd_mul(currentFrame.camera.transform, translation)\n        \n        \/\/ Add a new anchor to the session.\n        let anchor = ARAnchor(transform: transform)\n        session.add(anchor: anchor)\n    }\n}\n```\n\nIn your rendering engine, use the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor\/transform] property of each [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] object to place visual content. The Xcode template uses each of the anchors added to the session in its `handleTap` method to position a simple cube mesh:\n\n```swift\nfunc updateAnchors(frame: ARFrame) {\n    \/\/ Update the anchor's uniform buffer with transforms of the current frame's anchors.\n    anchorInstanceCount = min(frame.anchors.count, kMaxAnchorInstanceCount)\n    \n    var anchorOffset: Int = 0\n    if anchorInstanceCount == kMaxAnchorInstanceCount {\n        anchorOffset = max(frame.anchors.count - kMaxAnchorInstanceCount, 0)\n    }\n    \n    for index in 0..<anchorInstanceCount {\n        let anchor = frame.anchors[index + anchorOffset]\n        \n        \/\/ Flip the Z axis to convert geometry from right handed to left handed.\n        var coordinateSpaceTransform = matrix_identity_float4x4\n        coordinateSpaceTransform.columns.2.z = -1.0\n        \n        let modelMatrix = simd_mul(anchor.transform, coordinateSpaceTransform)\n        \n        let anchorUniforms = anchorUniformBufferAddress.assumingMemoryBound(to: InstanceUniforms.self).advanced(by: index)\n        anchorUniforms.pointee.modelMatrix = modelMatrix\n    }\n}\n```\n\n\n\n### Render with Realistic Lighting\n\nWhen you configure shaders for drawing 3D content in your scene, use the estimated lighting information in each [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame] object to produce more realistic shading. See the following code that an app’s custom renderer performs while updating its shared uniforms:\n\n```swift\n\/\/ Set up the scene's lighting with the ambient intensity, if available.\nvar ambientIntensity: Float = 1.0\nif let lightEstimate = frame.lightEstimate {\n    ambientIntensity = Float(lightEstimate.ambientIntensity) \/ 1000.0\n}\nlet ambientLightColor: vector_float3 = vector3(0.5, 0.5, 0.5)\nuniforms.pointee.ambientLightColor = ambientLightColor * ambientIntensity\n```\n\n\n\n## Setup\n\n- **Choosing Which Camera Feed to Augment**: Add visual effects to the user’s environment in an AR experience through the front or rear camera.\n- **Managing Session Life Cycle and Tracking Quality**: Keep the user informed on the current session state and recover from interruptions.\n- **ARSession**: The object that manages the major tasks associated with every AR experience, such as motion tracking, camera passthrough, and image analysis.\n- **Configuration Objects**: Configure your augmented reality session to detect and track specific types of content.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Add visual effects to the user’s environment in an AR experience through the front or rear camera.",
          "name" : "Choosing Which Camera Feed to Augment",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/choosing-which-camera-feed-to-augment"
        },
        {
          "description" : "Keep the user informed on the current session state and recover from interruptions.",
          "name" : "Managing Session Life Cycle and Tracking Quality",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/managing-session-life-cycle-and-tracking-quality"
        },
        {
          "description" : "The object that manages the major tasks associated with every AR experience, such as motion tracking, camera passthrough, and image analysis.",
          "name" : "ARSession",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARSession"
        },
        {
          "description" : "Configure your augmented reality session to detect and track specific types of content.",
          "name" : "Configuration Objects",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/configuration-objects"
        }
      ],
      "title" : "Setup"
    }
  ],
  "source" : "appleJSON",
  "title" : "Displaying an AR Experience with Metal",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/displaying-an-ar-experience-with-metal"
}