{
  "abstract" : "Apply virtual fog to the physical environment.",
  "codeExamples" : [
    {
      "code" : "if !ARWorldTrackingConfiguration.supportsFrameSemantics(.sceneDepth) ||\n    !ARWorldTrackingConfiguration.supportsFrameSemantics(.smoothedSceneDepth) {\n    \/\/ Ensure that the device supports scene depth and present\n    \/\/  an error-message view controller, if not.\n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    window?.rootViewController = storyboard.instantiateViewController(withIdentifier: \"unsupportedDeviceMessage\")\n}",
      "language" : "swift"
    },
    {
      "code" : "configuration.frameSemantics = .smoothedSceneDepth",
      "language" : "swift"
    },
    {
      "code" : "session.run(configuration)",
      "language" : "swift"
    },
    {
      "code" : "guard let sceneDepth = frame.smoothedSceneDepth ?? frame.sceneDepth else {\n    print(\"Failed to acquire scene depth.\")\n    return\n}\nvar pixelBuffer: CVPixelBuffer!\npixelBuffer = sceneDepth.depthMap",
      "language" : "swift"
    },
    {
      "code" : "var texturePixelFormat: MTLPixelFormat!\nsetMTLPixelFormat(&texturePixelFormat, basedOn: pixelBuffer)\ndepthTexture = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat: texturePixelFormat, planeIndex: 0)",
      "language" : "swift"
    },
    {
      "code" : "fileprivate func setMTLPixelFormat(_ texturePixelFormat: inout MTLPixelFormat?, basedOn pixelBuffer: CVPixelBuffer!) {\n    if CVPixelBufferGetPixelFormatType(pixelBuffer) == kCVPixelFormatType_DepthFloat32 {\n        texturePixelFormat = .r32Float\n    } else if CVPixelBufferGetPixelFormatType(pixelBuffer) == kCVPixelFormatType_OneComponent8 {\n        texturePixelFormat = .r8Uint\n    } else {\n        fatalError(\"Unsupported ARDepthData pixel-buffer format.\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "blurFilter = MPSImageGaussianBlur(device: device, sigma: 5)",
      "language" : "swift"
    },
    {
      "code" : "let inputImage = MPSImage(texture: depthTexture, featureChannels: 1)\nlet outputImage = MPSImage(texture: filteredDepthTexture, featureChannels: 1)",
      "language" : "swift"
    },
    {
      "code" : "blur.encode(commandBuffer: commandBuffer, sourceImage: inputImage, destinationImage: outputImage)",
      "language" : "swift"
    },
    {
      "code" : "renderEncoder.setFragmentTexture(CVMetalTextureGetTexture(cameraImageY), index: 0)\nrenderEncoder.setFragmentTexture(CVMetalTextureGetTexture(cameraImageCbCr), index: 1)",
      "language" : "swift"
    },
    {
      "code" : "renderEncoder.setFragmentTexture(filteredDepthTexture, index: 2)",
      "language" : "swift"
    },
    {
      "code" : "fragment half4 fogFragmentShader(FogColorInOut in [[ stage_in ]],\ntexture2d<float, access::sample> cameraImageTextureY [[ texture(0) ]],\ntexture2d<float, access::sample> cameraImageTextureCbCr [[ texture(1) ]],\ndepth2d<float, access::sample> arDepthTexture [[ texture(2) ]],",
      "language" : "cpp"
    },
    {
      "code" : "constexpr sampler s(address::clamp_to_edge, filter::linear);\n\n\/\/ Sample this pixel's camera image color.\nfloat4 rgb = ycbcrToRGBTransform(\n    cameraImageTextureY.sample(s, in.texCoordCamera),\n    cameraImageTextureCbCr.sample(s, in.texCoordCamera)\n);\nhalf4 cameraColor = half4(rgb);",
      "language" : "cpp"
    },
    {
      "code" : "float depth = arDepthTexture.sample(s, in.texCoordCamera);",
      "language" : "cpp"
    },
    {
      "code" : "float fogPercentage = depth \/ fogMax;",
      "language" : "cpp"
    },
    {
      "code" : "half4 foggedColor = mix(cameraColor, fogColor, fogPercentage);",
      "language" : "cpp"
    },
    {
      "code" : "\/\/ Set to `true` to visualize confidence.\nbool confidenceDebugVisualizationEnabled = false;",
      "language" : "swift"
    },
    {
      "code" : "pixelBuffer = sceneDepth.confidenceMap\nsetMTLPixelFormat(&texturePixelFormat, basedOn: pixelBuffer)\nconfidenceTexture = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat: texturePixelFormat, planeIndex: 0)",
      "language" : "swift"
    },
    {
      "code" : "renderEncoder.setFragmentTexture(CVMetalTextureGetTexture(confidenceTexture), index: 3)",
      "language" : "swift"
    },
    {
      "code" : "texture2d<uint> arDepthConfidence [[ texture(3) ]])",
      "language" : "cpp"
    },
    {
      "code" : "uint confidence = arDepthConfidence.sample(s, in.texCoordCamera).x;",
      "language" : "cpp"
    },
    {
      "code" : "float confidencePercentage = (float)confidence \/ (float)maxConfidence;",
      "language" : "cpp"
    },
    {
      "code" : "return mix(confidenceColor, foggedColor, confidencePercentage);",
      "language" : "cpp"
    }
  ],
  "contentHash" : "5913504d68d2b87b741a3e57589def7eed97656dbf667180cac9f3db652c67fc",
  "crawledAt" : "2025-12-02T15:29:14Z",
  "id" : "F1DCF476-56FA-4613-9527-694604D6394E",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nDevices such as the second-generation iPad Pro 11-inch and fourth-generation iPad Pro 12.9-inch can use the LiDAR Scanner to calculate the distance of real-world objects from the user. In world-tracking experiences on iOS 14, ARKit provides a buffer that describes the objects’ distance from the device in meters.\n\nThis sample app uses the depth buffer to create a virtual fog effect in real time. To draw its graphics, the sample app uses a small Metal renderer. ARKit provides precise depth values for objects in the camera feed, so the sample app applies a Gaussian blur using [doc:\/\/com.apple.documentation\/documentation\/MetalPerformanceShaders] to soften the fog effect. While drawing the camera image to the screen, the renderer checks the depth texture at every pixel, and overlays a fog color based on that pixel’s distance from the device. For more information on sampling textures and drawing with Metal, see [doc:\/\/com.apple.documentation\/documentation\/Metal\/creating-and-sampling-textures].\n\n\n\n## Enable scene depth and run a session\n\nIn order to avoid running an unsupported configuration, the sample app first checks whether the device supports scene depth.\n\nIf the device running the app doesn’t support scene depth, the sample project will stop. Optionally, the app could present the user with an error message and continue the experience without scene depth.\n\nIf the device supports scene depth, the sample app creates a world-tracking configuration and enables the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] option on the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct]uct`` property.\n\nThen, the sample project begins the AR experience by running the session.\n\n## Access the scene’s depth\n\nARKit exposes the depth buffer documentation\/arkit\/ardepthdata\/depthmap) as a [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvpixelbuffer-q2e] on the current frame’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] or [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] property, depending on the enabled frame semantics. This sample app visualizes [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] by default. The raw depth values in [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] can create a flicker whereas smoothing the depth differences across frames visualizes a more realistic fog effect. For debug purposes, the sample allows switching between [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] with an onscreen toggle.\n\nEvery pixel in the depth buffer maps to a region of the visible scene, which defines that region’s distance from the device in meters. Because the sample project draws to the screen using Metal, it converts the pixel buffer to a Metal texture as required to transfer the depth data to the GPU for rendering.\n\nTo set the depth texture’s Metal pixel format, the sample project calls [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/CVPixelBufferGetPixelFormatType(_:)] with the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap] and chooses an appropriate mapping based on the result.\n\n## Apply a blur to the depth buffer\n\nAs a benefit of rendering its graphics with Metal, this app has at its disposal the display conveniences of MPS. The sample project uses the MPS Gaussian Blur filter to make realistic fog. When instantiating the filter, the sample project passes a `sigma` of `5` to specify a 5-pixel radius blur.\n\nMPS requires input and output images that define the source and destination pixel data for the filter operation.\n\nThe sample app passes the input and output images to the blur’s `encode` function, which schedules the blur to happen on the GPU.\n\n## Visualize the blurred depth to create fog\n\nMetal renders by providing to the GPU a fragment shader that draws the app’s graphics. Since the sample project renders a camera image, it packages up the camera image for the fragment shader by calling `setFragmentTexture`.\n\nNext, the sample app packages up the filtered depth texture.\n\nThe sample project’s GPU-side code fields the texture arguments in the order of the `index` argument. For example, the fragment shader fields the texture with index `0` above as the argument containing the suffix `texture(0)`, as shown in the example below.\n\nTo output a rendering, Metal calls the fragment shader once for every pixel it draws to the destination. The sample project’s fragment shader begins by reading the RGB value of the current pixel in the camera image. The object “`s`” is a `sampler`, which enables the shader to inspect a texture at a specific location. The value `in.texCoordCamera` refers to this pixel’s relative location within the camera image.\n\nBy sampling the depth texture at `in.texCoordCamera`, the shader queries for depth at the same relative location that it did for the camera image, and obtains the current pixel’s distance in meters from the device.\n\nTo determine the amount of fog that covers this pixel, the sample app calculates a fraction using the current pixel’s distance divided by the distance at which the fog effect fully saturates the scene.\n\nThe `mix` function mixes two colors based on a percentage. The sample project passes in the RGB values, fog color, and fog percentage to create the right amount of fog for the current pixel.\n\nAfter Metal calls the fragment shader for every pixel, the view presents the final, fogged image of the physical environment to the screen.\n\n## Visualize confidence data\n\nARKit provides the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/confidenceMap] property within [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData] to measure the accuracy of the corresponding depth data [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap]. Although this sample project doesn’t factor depth confidence into its fog effect, confidence data could filter out lower-accuracy depth values if the app’s algorithm required it.\n\nTo provide a sense for depth confidence, this sample app visualizes confidence data at runtime using the `confidenceDebugVisualizationEnabled` in the `Shaders.metal` file.\n\nWhen the renderer accesses the current frame’s scene depth, the sample project creates a Metal texture of the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/confidenceMap] to draw it on the GPU.\n\nWhile the renderer schedules its drawing, the sample project packages up the confidence texture for the GPU by calling `setFragmentTexture`.\n\nThe GPU-side code fields confidence data as the fragment shader’s third texture argument.\n\nTo access the confidence value of the current pixel’s depth, the fragment shader samples the confidence texture at `in.texCoordCamera`. Each confidence value in this texture is a `uint` equivalent of its corresponding case in the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfidenceLevel] enum.\n\nBased on the confidence value at the current pixel, the fragment shader creates a normalized percentage of the confidence color to overlay.\n\nThe sample project calls the `mix` function to blend the confidence color into the processed pixel based on the confidence percentage.\n\nAfter Metal calls the fragment shader for every pixel, the view presents the camera image augmented with the confidence visualization.\n\n\n\nThis sample uses the color red to identify parts of the scene in which depth confidence is less than [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfidenceLevel\/high]. At low confidence depth values with a normalized percentage of `0`, the visualization renders solid red (`confidenceColor`). For high confidence depth values with a value of one, the `mix` call returns the unfiltered, fogged camera-image color (`foggedColor`). At medium-confidence areas of the scene, the `mix` call returns a blend of both colors that applies a reddish tint to the fogged camera-image.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/creating-a-fog-effect-using-scene-depth\ncrawled: 2025-12-02T15:29:14Z\n---\n\n# Creating a fog effect using scene depth\n\n**Sample Code**\n\nApply virtual fog to the physical environment.\n\n## Overview\n\nDevices such as the second-generation iPad Pro 11-inch and fourth-generation iPad Pro 12.9-inch can use the LiDAR Scanner to calculate the distance of real-world objects from the user. In world-tracking experiences on iOS 14, ARKit provides a buffer that describes the objects’ distance from the device in meters.\n\nThis sample app uses the depth buffer to create a virtual fog effect in real time. To draw its graphics, the sample app uses a small Metal renderer. ARKit provides precise depth values for objects in the camera feed, so the sample app applies a Gaussian blur using [doc:\/\/com.apple.documentation\/documentation\/MetalPerformanceShaders] to soften the fog effect. While drawing the camera image to the screen, the renderer checks the depth texture at every pixel, and overlays a fog color based on that pixel’s distance from the device. For more information on sampling textures and drawing with Metal, see [doc:\/\/com.apple.documentation\/documentation\/Metal\/creating-and-sampling-textures].\n\n\n\n## Enable scene depth and run a session\n\nIn order to avoid running an unsupported configuration, the sample app first checks whether the device supports scene depth.\n\n```swift\nif !ARWorldTrackingConfiguration.supportsFrameSemantics(.sceneDepth) ||\n    !ARWorldTrackingConfiguration.supportsFrameSemantics(.smoothedSceneDepth) {\n    \/\/ Ensure that the device supports scene depth and present\n    \/\/  an error-message view controller, if not.\n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    window?.rootViewController = storyboard.instantiateViewController(withIdentifier: \"unsupportedDeviceMessage\")\n}\n```\n\nIf the device running the app doesn’t support scene depth, the sample project will stop. Optionally, the app could present the user with an error message and continue the experience without scene depth.\n\nIf the device supports scene depth, the sample app creates a world-tracking configuration and enables the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] option on the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct]uct`` property.\n\n```swift\nconfiguration.frameSemantics = .smoothedSceneDepth\n```\n\nThen, the sample project begins the AR experience by running the session.\n\n```swift\nsession.run(configuration)\n```\n\n## Access the scene’s depth\n\nARKit exposes the depth buffer documentation\/arkit\/ardepthdata\/depthmap) as a [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvpixelbuffer-q2e] on the current frame’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] or [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] property, depending on the enabled frame semantics. This sample app visualizes [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] by default. The raw depth values in [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] can create a flicker whereas smoothing the depth differences across frames visualizes a more realistic fog effect. For debug purposes, the sample allows switching between [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth] and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] with an onscreen toggle.\n\n```swift\nguard let sceneDepth = frame.smoothedSceneDepth ?? frame.sceneDepth else {\n    print(\"Failed to acquire scene depth.\")\n    return\n}\nvar pixelBuffer: CVPixelBuffer!\npixelBuffer = sceneDepth.depthMap\n```\n\nEvery pixel in the depth buffer maps to a region of the visible scene, which defines that region’s distance from the device in meters. Because the sample project draws to the screen using Metal, it converts the pixel buffer to a Metal texture as required to transfer the depth data to the GPU for rendering.\n\n```swift\nvar texturePixelFormat: MTLPixelFormat!\nsetMTLPixelFormat(&texturePixelFormat, basedOn: pixelBuffer)\ndepthTexture = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat: texturePixelFormat, planeIndex: 0)\n```\n\nTo set the depth texture’s Metal pixel format, the sample project calls [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/CVPixelBufferGetPixelFormatType(_:)] with the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap] and chooses an appropriate mapping based on the result.\n\n```swift\nfileprivate func setMTLPixelFormat(_ texturePixelFormat: inout MTLPixelFormat?, basedOn pixelBuffer: CVPixelBuffer!) {\n    if CVPixelBufferGetPixelFormatType(pixelBuffer) == kCVPixelFormatType_DepthFloat32 {\n        texturePixelFormat = .r32Float\n    } else if CVPixelBufferGetPixelFormatType(pixelBuffer) == kCVPixelFormatType_OneComponent8 {\n        texturePixelFormat = .r8Uint\n    } else {\n        fatalError(\"Unsupported ARDepthData pixel-buffer format.\")\n    }\n}\n```\n\n## Apply a blur to the depth buffer\n\nAs a benefit of rendering its graphics with Metal, this app has at its disposal the display conveniences of MPS. The sample project uses the MPS Gaussian Blur filter to make realistic fog. When instantiating the filter, the sample project passes a `sigma` of `5` to specify a 5-pixel radius blur.\n\n```swift\nblurFilter = MPSImageGaussianBlur(device: device, sigma: 5)\n```\n\n\n\nMPS requires input and output images that define the source and destination pixel data for the filter operation.\n\n```swift\nlet inputImage = MPSImage(texture: depthTexture, featureChannels: 1)\nlet outputImage = MPSImage(texture: filteredDepthTexture, featureChannels: 1)\n```\n\nThe sample app passes the input and output images to the blur’s `encode` function, which schedules the blur to happen on the GPU.\n\n```swift\nblur.encode(commandBuffer: commandBuffer, sourceImage: inputImage, destinationImage: outputImage)\n```\n\n\n\n## Visualize the blurred depth to create fog\n\nMetal renders by providing to the GPU a fragment shader that draws the app’s graphics. Since the sample project renders a camera image, it packages up the camera image for the fragment shader by calling `setFragmentTexture`.\n\n```swift\nrenderEncoder.setFragmentTexture(CVMetalTextureGetTexture(cameraImageY), index: 0)\nrenderEncoder.setFragmentTexture(CVMetalTextureGetTexture(cameraImageCbCr), index: 1)\n```\n\nNext, the sample app packages up the filtered depth texture.\n\n```swift\nrenderEncoder.setFragmentTexture(filteredDepthTexture, index: 2)\n```\n\nThe sample project’s GPU-side code fields the texture arguments in the order of the `index` argument. For example, the fragment shader fields the texture with index `0` above as the argument containing the suffix `texture(0)`, as shown in the example below.\n\n```cpp\nfragment half4 fogFragmentShader(FogColorInOut in [[ stage_in ]],\ntexture2d<float, access::sample> cameraImageTextureY [[ texture(0) ]],\ntexture2d<float, access::sample> cameraImageTextureCbCr [[ texture(1) ]],\ndepth2d<float, access::sample> arDepthTexture [[ texture(2) ]],\n```\n\nTo output a rendering, Metal calls the fragment shader once for every pixel it draws to the destination. The sample project’s fragment shader begins by reading the RGB value of the current pixel in the camera image. The object “`s`” is a `sampler`, which enables the shader to inspect a texture at a specific location. The value `in.texCoordCamera` refers to this pixel’s relative location within the camera image.\n\n```cpp\nconstexpr sampler s(address::clamp_to_edge, filter::linear);\n\n\/\/ Sample this pixel's camera image color.\nfloat4 rgb = ycbcrToRGBTransform(\n    cameraImageTextureY.sample(s, in.texCoordCamera),\n    cameraImageTextureCbCr.sample(s, in.texCoordCamera)\n);\nhalf4 cameraColor = half4(rgb);\n```\n\nBy sampling the depth texture at `in.texCoordCamera`, the shader queries for depth at the same relative location that it did for the camera image, and obtains the current pixel’s distance in meters from the device.\n\n```cpp\nfloat depth = arDepthTexture.sample(s, in.texCoordCamera);\n```\n\nTo determine the amount of fog that covers this pixel, the sample app calculates a fraction using the current pixel’s distance divided by the distance at which the fog effect fully saturates the scene.\n\n```cpp\nfloat fogPercentage = depth \/ fogMax;\n```\n\nThe `mix` function mixes two colors based on a percentage. The sample project passes in the RGB values, fog color, and fog percentage to create the right amount of fog for the current pixel.\n\n```cpp\nhalf4 foggedColor = mix(cameraColor, fogColor, fogPercentage);\n```\n\nAfter Metal calls the fragment shader for every pixel, the view presents the final, fogged image of the physical environment to the screen.\n\n## Visualize confidence data\n\nARKit provides the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/confidenceMap] property within [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData] to measure the accuracy of the corresponding depth data [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap]. Although this sample project doesn’t factor depth confidence into its fog effect, confidence data could filter out lower-accuracy depth values if the app’s algorithm required it.\n\nTo provide a sense for depth confidence, this sample app visualizes confidence data at runtime using the `confidenceDebugVisualizationEnabled` in the `Shaders.metal` file.\n\n```swift\n\/\/ Set to `true` to visualize confidence.\nbool confidenceDebugVisualizationEnabled = false;\n```\n\nWhen the renderer accesses the current frame’s scene depth, the sample project creates a Metal texture of the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/confidenceMap] to draw it on the GPU.\n\n```swift\npixelBuffer = sceneDepth.confidenceMap\nsetMTLPixelFormat(&texturePixelFormat, basedOn: pixelBuffer)\nconfidenceTexture = createTexture(fromPixelBuffer: pixelBuffer, pixelFormat: texturePixelFormat, planeIndex: 0)\n```\n\nWhile the renderer schedules its drawing, the sample project packages up the confidence texture for the GPU by calling `setFragmentTexture`.\n\n```swift\nrenderEncoder.setFragmentTexture(CVMetalTextureGetTexture(confidenceTexture), index: 3)\n```\n\nThe GPU-side code fields confidence data as the fragment shader’s third texture argument.\n\n```cpp\ntexture2d<uint> arDepthConfidence [[ texture(3) ]])\n```\n\nTo access the confidence value of the current pixel’s depth, the fragment shader samples the confidence texture at `in.texCoordCamera`. Each confidence value in this texture is a `uint` equivalent of its corresponding case in the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfidenceLevel] enum.\n\n```cpp\nuint confidence = arDepthConfidence.sample(s, in.texCoordCamera).x;\n```\n\nBased on the confidence value at the current pixel, the fragment shader creates a normalized percentage of the confidence color to overlay.\n\n```cpp\nfloat confidencePercentage = (float)confidence \/ (float)maxConfidence;\n```\n\nThe sample project calls the `mix` function to blend the confidence color into the processed pixel based on the confidence percentage.\n\n```cpp\nreturn mix(confidenceColor, foggedColor, confidencePercentage);\n```\n\nAfter Metal calls the fragment shader for every pixel, the view presents the camera image augmented with the confidence visualization.\n\n\n\nThis sample uses the color red to identify parts of the scene in which depth confidence is less than [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfidenceLevel\/high]. At low confidence depth values with a normalized percentage of `0`, the visualization renders solid red (`confidenceColor`). For high confidence depth values with a value of one, the `mix` call returns the unfiltered, fogged camera-image color (`foggedColor`). At medium-confidence areas of the scene, the `mix` call returns a blend of both colors that applies a reddish tint to the fogged camera-image.\n\n## Video Frame Analysis\n\n- **Displaying a point cloud using scene depth**: Present a visualization of the physical environment by placing points based a scene’s depth data.\n- **ARFrame**: A video image captured as part of a session with position-tracking information.\n- **ARPointCloud**: A collection of points in the world coordinate space of the AR session.\n- **ARDepthData**: An object that describes the distance to regions of the real world from the plane of the camera.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Present a visualization of the physical environment by placing points based a scene’s depth data.",
          "name" : "Displaying a point cloud using scene depth",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/displaying-a-point-cloud-using-scene-depth"
        },
        {
          "description" : "A video image captured as part of a session with position-tracking information.",
          "name" : "ARFrame",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARFrame"
        },
        {
          "description" : "A collection of points in the world coordinate space of the AR session.",
          "name" : "ARPointCloud",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARPointCloud"
        },
        {
          "description" : "An object that describes the distance to regions of the real world from the plane of the camera.",
          "name" : "ARDepthData",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARDepthData"
        }
      ],
      "title" : "Video Frame Analysis"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a fog effect using scene depth",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/creating-a-fog-effect-using-scene-depth"
}