{
  "abstract" : "Present a visualization of the physical environment by placing points based a scene’s depth data.",
  "codeExamples" : [
    {
      "code" : "@main\nstruct PointCloudDepthSample: App {\n    var body: some Scene {\n        WindowGroup {\n            MetalDepthView()",
      "language" : "swift"
    },
    {
      "code" : "arData.colorImage = frame.capturedImage",
      "language" : "swift"
    },
    {
      "code" : "if !ARWorldTrackingConfiguration.supportsFrameSemantics([.sceneDepth, .smoothedSceneDepth]) {\n    Text(\"Unsupported Device: This app requires the LiDAR Scanner to access the scene's depth.\")",
      "language" : "swift"
    },
    {
      "code" : "var arProvider: ARProvider = ARProvider()",
      "language" : "swift"
    },
    {
      "code" : "let config = ARWorldTrackingConfiguration()\nconfig.frameSemantics = [.sceneDepth, .smoothedSceneDepth]\narSession.run(config)",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: ARSession, didUpdate frame: ARFrame) {\n    if(frame.sceneDepth != nil) && (frame.smoothedSceneDepth != nil) {\n        arData.depthImage = frame.sceneDepth?.depthMap\n        arData.depthSmoothImage = frame.smoothedSceneDepth?.depthMap",
      "language" : "swift"
    },
    {
      "code" : "depthContent.texture = lastArData?.depthImage?.texture(withFormat: .r32Float, planeIndex: 0, addToCache: textureCache!)!",
      "language" : "swift"
    },
    {
      "code" : "colorYContent.texture = lastArData?.colorImage?.texture(withFormat: .r8Unorm,\n                                                        planeIndex: 0,\n                                                        addToCache: textureCache!)!\ncolorCbCrContent.texture = lastArData?.colorImage?.texture(withFormat: .rg8Unorm,\n                                                           planeIndex: 1,\n                                                           addToCache: textureCache!)!",
      "language" : "swift"
    },
    {
      "code" : "uint2 pos;\n\/\/ Count the rows that are depth-texture-width wide to determine the y-value.\npos.y = vertexID \/ depthTexture.get_width();\n\n\/\/ The x-position is the remainder of the y-value division.\npos.x = vertexID % depthTexture.get_width();",
      "language" : "swift"
    },
    {
      "code" : "constexpr sampler textureSampler (mag_filter::linear,\n                                  min_filter::linear);\nout.coor = { pos.x \/ (depthTexture.get_width() - 1.0f), pos.y \/ (depthTexture.get_height() - 1.0f) };\nhalf y = colorYtexture.sample(textureSampler, out.coor).r;\nhalf2 uv = colorCbCrtexture.sample(textureSampler, out.coor).rg - half2(0.5h, 0.5h);\n\/\/ Convert YUV to RGB inline.\nhalf4 rgbaResult = half4(y + 1.402h * uv.y, y - 0.7141h * uv.y - 0.3441h * uv.x, y + 1.772h * uv.x, 1.0h);",
      "language" : "swift"
    },
    {
      "code" : "struct MetalPointCloud: UIViewRepresentable {",
      "language" : "swift"
    },
    {
      "code" : "HStack() {\n    Spacer()\n    MetalPointCloud(arData: arProvider,\n                    confSelection: $selectedConfidence,\n                    scaleMovement: $scaleMovement).zoomOnTapModifier(\n                        height: geometry.size.width \/ 2 \/ sizeW * sizeH,\n                        width: geometry.size.width \/ 2, title: \"\")",
      "language" : "swift"
    },
    {
      "code" : "func makeCoordinator() -> CoordinatorPointCloud {\n    return CoordinatorPointCloud(arData: arData, confSelection: $confSelection, scaleMovement: $scaleMovement)\n}",
      "language" : "swift"
    },
    {
      "code" : "final class CoordinatorPointCloud: MTKCoordinator {",
      "language" : "swift"
    },
    {
      "code" : "class MTKCoordinator: NSObject, MTKViewDelegate {",
      "language" : "swift"
    },
    {
      "code" : "func makeUIView(context: UIViewRepresentableContext<MetalPointCloud>) -> MTKView {\n    let mtkView = MTKView()\n    mtkView.delegate = context.coordinator",
      "language" : "swift"
    },
    {
      "code" : "override func draw(in view: MTKView) {\n    content = arData.depthContent\n    let confidence = (arData.isToUpsampleDepth) ? arData.upscaledConfidence:arData.confidenceContent\n    guard arData.lastArData != nil else {",
      "language" : "swift"
    },
    {
      "code" : "encoder.setVertexTexture(content.texture, index: 0)\nencoder.setVertexTexture(confidence.texture, index: 1)\nencoder.setVertexTexture(arData.colorYContent.texture, index: 2)\nencoder.setVertexTexture(arData.colorCbCrContent.texture, index: 3)",
      "language" : "swift"
    },
    {
      "code" : "encoder.setVertexBytes(&pmv, length: MemoryLayout<matrix_float4x4>.stride, index: 0)\nencoder.setVertexBytes(&cameraIntrinsics, length: MemoryLayout<matrix_float3x3>.stride, index: 1)\nencoder.setVertexBytes(&confSelection, length: MemoryLayout<Int>.stride, index: 2)",
      "language" : "swift"
    },
    {
      "code" : "pipelineDescriptor.vertexFunction = library.makeFunction(name: \"pointCloudVertexShader\")\npipelineDescriptor.fragmentFunction = library.makeFunction(name: \"pointCloudFragmentShader\")",
      "language" : "swift"
    },
    {
      "code" : "vertex ParticleVertexInOut pointCloudVertexShader(\n    uint vertexID [[ vertex_id ]],\n    texture2d<float, access::read> depthTexture [[ texture(0) ]],\n    texture2d<float, access::read> confTexture [[ texture(1) ]],\n    constant float4x4& viewMatrix [[ buffer(0) ]],\n    constant float3x3& cameraIntrinsics [[ buffer(1) ]],\n    constant int &confFilterMode [[ buffer(2) ]],\n    texture2d<half> colorYtexture [[ texture(2) ]],\n    texture2d<half> colorCbCrtexture [[ texture(3) ]]\n    )\n{ \/\/ ...",
      "language" : "cpp"
    },
    {
      "code" : "float xrw = ((int)pos.x - cameraIntrinsics[2][0]) * depth \/ cameraIntrinsics[0][0];\nfloat yrw = ((int)pos.y - cameraIntrinsics[2][1]) * depth \/ cameraIntrinsics[1][1];\nfloat4 xyzw = { xrw, yrw, depth, 1.f };",
      "language" : "cpp"
    },
    {
      "code" : "float4 vecout = viewMatrix * xyzw;",
      "language" : "cpp"
    },
    {
      "code" : "out.color = rgbaResult;\nout.clipSpacePosition = vecout;",
      "language" : "cpp"
    },
    {
      "code" : "fragment half4 pointCloudFragmentShader(\n    ParticleVertexInOut in [[stage_in]])",
      "language" : "cpp"
    },
    {
      "code" : "if (in.depth < 1.0f)\n    discard_fragment();\nelse\n{\n    return in.color;",
      "language" : "cpp"
    },
    {
      "code" : "func calcCurrentPMVMatrix(viewSize: CGSize) -> matrix_float4x4 {\n    let projection: matrix_float4x4 = makePerspectiveMatrixProjection(fovyRadians: Float.pi \/ 2.0,\n                                                                      aspect: Float(viewSize.width) \/ Float(viewSize.height),\n                                                                      nearZ: 10.0, farZ: 8000.0)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Randomize the camera scale.\ntranslationCamera.columns.3 = [150 * sinf, -150 * cossqr, -150 * scaleMovement * sinsqr, 1]\n\/\/ Randomize the camera movement.\ncameraRotation = simd_quatf(angle: staticAngle, axis: SIMD3(x: -sinsqr \/ 3, y: -cossqr \/ 3, z: 0))",
      "language" : "swift"
    },
    {
      "code" : "let rotationMatrix: matrix_float4x4 = matrix_float4x4(cameraRotation)\nlet pmv = projection * rotationMatrix * translationCamera * translationOrig * orientationOrig\nreturn pmv\n\/\/#-end-code-li",
      "language" : "swift"
    },
    {
      "code" : "guidedFilter = MPSImageGuidedFilter(device: metalDevice, kernelDiameter: guidedFilterKernelDiameter)",
      "language" : "swift"
    },
    {
      "code" : "mpsScaleFilter = MPSImageBilinearScale(device: metalDevice)",
      "language" : "swift"
    },
    {
      "code" : "if isToUpsampleDepth {",
      "language" : "swift"
    },
    {
      "code" : "let convertYUV2RGBFunc = lib.makeFunction(name: \"convertYCbCrToRGBA\")\npipelineStateCompute = try metalDevice.makeComputePipelineState(function: convertYUV2RGBFunc!)",
      "language" : "swift"
    },
    {
      "code" : "depthContent.texture = destDepthTexture",
      "language" : "swift"
    },
    {
      "code" : "encoder.setFragmentTexture(content.texture, index: 0)",
      "language" : "swift"
    },
    {
      "code" : "ScrollView(.horizontal) {\n    HStack() {\n        MetalTextureViewDepth(content: arProvider.depthContent, confSelection: $selectedConfidence)\n            .zoomOnTapModifier(height: sizeH, width: sizeW, title: isToUpsampleDepth ? \"Upscaled Depth\" : \"Depth\")",
      "language" : "swift"
    },
    {
      "code" : "depthContent.texture = lastArData?.depthImage?.texture(withFormat: .r32Float, planeIndex: 0, addToCache: textureCache!)!",
      "language" : "swift"
    },
    {
      "code" : "pipelineDescriptor.fragmentFunction = library.makeFunction(name: \"planeFragmentShaderDepth\")",
      "language" : "swift"
    },
    {
      "code" : "fragment half4 planeFragmentShaderDepth(ColorInOut in [[stage_in]], texture2d<float, access::sample> textureDepth [[ texture(0) ]])\n{\n    constexpr sampler colorSampler(address::clamp_to_edge, filter::nearest);\n    float4 s = textureDepth.sample(colorSampler, in.texCoord);\n    \n    \/\/ Size the color gradient to a maximum distance of 2.5 meters.\n    \/\/ The LiDAR Scanner supports a value no larger than 5.0; the\n    \/\/ sample app uses a value of 2.5 to better distinguish depth\n    \/\/ in smaller environments.\n    half val = s.r \/ 2.5h;\n    half4 res = getJetColorsFromNormalizedVal(val);\n    return res;",
      "language" : "cpp"
    },
    {
      "code" : "MetalTextureViewConfidence(content: arProvider.confidenceContent)\n    .zoomOnTapModifier(height: sizeH, width: sizeW, title: \"Confidence\")",
      "language" : "swift"
    },
    {
      "code" : "confidenceContent.texture = lastArData?.confidenceImage?.texture(withFormat: .r8Unorm, planeIndex: 0, addToCache: textureCache!)!",
      "language" : "swift"
    },
    {
      "code" : "pipelineDescriptor.fragmentFunction = library.makeFunction(name: \"planeFragmentShaderConfidence\")",
      "language" : "swift"
    },
    {
      "code" : "fragment half4 planeFragmentShaderConfidence(ColorInOut in [[stage_in]], texture2d<float, access::sample> textureIn [[ texture(0) ]])\n{\n    constexpr sampler colorSampler(address::clamp_to_edge, filter::nearest);\n    float4 s = textureIn.sample(colorSampler, in.texCoord);\n    float res = round( 255.0f*(s.r) ) ;\n    int resI = int(res);\n    half4 color = half4(0.0h, 0.0h, 0.0h, 0.0h);\n    if (resI == 0)\n        color = half4(1.0h, 0.0h, 0.0h, 1.0h);\n    else if (resI == 1)\n        color = half4(0.0h, 1.0h, 0.0h, 1.0h);\n    else if (resI == 2)\n        color = half4(0.0h, 0.0h, 1.0h, 1.0h);\n    return color;\n}",
      "language" : "cpp"
    }
  ],
  "contentHash" : "3ffac2b6cb10dd3986dd73a5826f9eeabf40d824880e4b2d9cda52d314b18fc1",
  "crawledAt" : "2025-12-02T15:29:18Z",
  "id" : "CEECC1CE-F80B-4779-AA01-AFCE63B0D612",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nDepth Cloud is an app that uses [doc:\/\/com.apple.documentation\/documentation\/Metal] to display a camera feed by placing a collection of points in the physical environment, according to depth information from the device’s LiDAR Scanner. For every distance sample in the session’s periodic depth reading [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap], the app places a virtual dot at that location in the physical environment, with the final result resembling a *point cloud*. Depth Cloud colors the cloud according to ARKit’s camera image [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame\/capturedImage].\n\nFor every entry in the depth map — and therefore, for every dot in the cloud — the sample app checks the corresponding pixel in the camera image and assigns the pixel’s color to the dot. When the user views the point cloud straight on, the app’s display appears nearly identical to a camera feed. To demonstrate the cloud’s 3D shape, the sample app continuously rotates the cloud to change its viewing angle with respect to the user.\n\nThe following figure illustrates a point cloud from a single frame of data, rotated on the y-axis to reveal a dark area behind the apple where the current sensor readings lack color and depth information.\n\n\n\nThe app cycles through depth *confidence* values (see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/confidenceMap], enlarges the depth buffer, and toggles ARKit’s smooth depth option [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth]. By applying the user’s selections to the point cloud live, the user can see the difference that the settings make throughout the experience.\n\nFor a practical application of ARKit’s depth data, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/creating-a-fog-effect-using-scene-depth].\n\n## Set up a camera feed\n\nTo display a camera feed, the sample project defines a SwiftUI [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene] whose [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/body-swift.property] contains a single window. To abstract view code from window code, the sample project wraps all of its display in a single [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View] called `MetalDepthView`.\n\nBecause Depth Cloud draws graphics using Metal, the sample project displays the camera feed by defining custom GPU code. The sample project accesses ARKit’s camera feed in its `ARReceiver.swift` file and wraps it in a custom `ARData` object for eventual transfer to the GPU.\n\n## Ensure device support and start a session\n\nDevices require the LiDAR Scanner to access the scene’s depth. In the depth-visualization view’s [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/body-swift.property] definition, the app prevents running an unsupported configuration by checking if the device supports scene depth.\n\nTo separate data acquisition from its display, the sample app wraps ARKit calls in its `ARProvider` class.\n\nThe AR provider runs a world-tracking configuration and requests information about the scene’s depth by configuring the scene-depth frame semantics (see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth]. and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth]).\n\n## Access the scene’s depth\n\nIn response to the configuration’s scene-depth frame semantics, the framework defines the frame’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap] properties of [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth]. on the session’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/currentFrame].\n\nBecause the sample project draws its graphics using Metal, the app’s CPU code bundles up data that its GPU code needs to display the experience. To model the physical environment with a point cloud, the app needs camera capture data to color each point and depth data to position them.\n\nThe sample project positions each point in GPU code, so the CPU side packages the depth data in a Metal texture for use on the GPU.\n\nThe sample project colors each point in GPU code, so the CPU side packages the camera data for use on the GPU.\n\n## Convert camera data\n\nIn the `pointCloudVertexShader` function (see the sample project’s `shaders.metal` file), the sample project creates a point for every value in the depth texture and determines the point’s color by sampling that depth-texture value’s position in the camera image. Each vertex calculates its `x` and `y` location in the camera image by converting its position in the one-dimensional vertex array, to a 2D position in the depth texture.\n\nThe system’s camera-capture pipeline represents data in YUV format, which the sample project models using a luminance map (`colorYtexture`) and a blue versus red chromaticity map (`colorCbCrtexture`). The GPU color format is RGBA, which requires the sample project to convert the camera data to display it. The shader samples the luminance and chromaticity textures at the vertex’s `x,` `y` position and applies a static conversion factor.\n\n## Set up the point cloud view\n\nTo display a camera feed by using a point cloud, the project defines a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewRepresentable] object, `MetalPointCloud`, which contains an [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] that displays Metal content.\n\nThe project inserts the point cloud view into the view hierarchy by embedding it within the `MetalDepthView` layout.\n\nAs representable of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView], the Metal texture view defines a coordinator, `CoordinatorPointCloud`.\n\nThe point cloud coordinator extends `MTKCoordinator`, which the sample shares across its other views that display Metal content.\n\nAs an [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate], `MTKCoordinator` handles relevant events that occur throughout the Metal view life cycle.\n\nIn the `UIView` representable’s `makeUIView` implementation, the sample project assigns the coordinator as the view’s delegate.\n\nAt runtime, the display link then calls the Metal coordinator’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] implementation to issue CPU-side rendering commands.\n\n## Display the point cloud with gpu code\n\nThe sample project draws the point cloud on the GPU. The point cloud view packages up several textures that its corresponding GPU code requires as input.\n\nSimilarly, the point cloud view packages up several calculated properties that its corresponding GPU code requires as input.\n\nTo call into the GPU functions that draw the point cloud, the sample defines a pipeline state that queues up its `pointCloudVertexShader` and `pointCloudFragmentShader` Metal functions (see the project’s `shaders.metal` file).\n\nOn the GPU, the point cloud vertex shader determines each point’s color and position on the screen. In the function signature, the vertex shader receives the input textures and properties sent by the CPU code.\n\nThe code bases the point’s world position on its location and depth in the camera feed.\n\nThe point’s screen position is a product of its world position and the argument projection matrix.\n\nThe vertex function outputs the point’s screen position, along with the point’s color as a converted RGB result.\n\nThe fragment shader receives the vertex function output in its function signature.\n\nAfter filtering any points that are too close to the device’s camera, the fragment shader queues the remaining points for display by returning the color of each vertex.\n\n## Change the cloud’s orientation to convey depth\n\nAs the user views the point cloud straight on, it appears visually equivalent to the 2D camera image. But, when the sample app rotates the point cloud slightly, the 3D shape of the point cloud becomes apparent to the user.\n\n\n\nThe point cloud’s screen position is a factor of its projection matrix. In the sample project’s `calcCurrentPMVMatrix` function (see `MetalPointCloud.swift`), the function sets up a basic matrix.\n\nTo adjust the point cloud’s orientation with respect to the user, the sample app conversely sets up translation and rotation offsets for the camera’s pose.\n\nThe sample project applies the camera pose offset to the original projection matrix before returning the adjusted result.\n\n## Enlarge the depth buffer\n\nARKit’s depth map contains precise, low-resolution depth values for objects in the camera feed. To create the illusion of a high-resolution depth map, the sample app offers UI to enlarge the depth map using Metal Performance Shaders (MPS). By filling in gaps in the framework’s depth information, the enlarged depth buffer creates the illusion of more depth information in the scene.\n\n\n\nThe sample project uses MPS to enlarge the depth buffer; see the `ARDataProvider.swift` file. The `ARProvider` class initializer creates a guided filter to enlarge the depth buffer.\n\nTo align the sizes of the related visuals — the camera image and confidence texture \u001f\u001f\u001f\u001f— the AR provider uses an MPS bilinear scale filter.\n\nIn the `processLastARData` routine, the AR provider creates an additional Metal command buffer for a compute pass that enlarges the depth buffer.\n\nThe AR provider converts the input depth data to RGB format, as required by the guided filter.\n\nAfter encoding the bilinear scale and guided filters, the AR provider sets the enlarged depth buffer.\n\n## Display depth and confidence\n\nIn addition to the point cloud visualization, the sample app adds simultaneous depth distance and confidence visualizations. The user refers to either visualization at any time during the experience to better grasp the accuracy of the LiDAR Scanner’s reading of the physical environment.\n\n\n\nTo display the depth and confidence visualizations, Depth Cloud defines a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewRepresentable] object, `MetalTextureView`, which contains an [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] that displays Metal content (see the project’s `MetalTextureView.swift` file). This setup is similar to `MetalDepthView`, except that the sample app stores the view’s displayable content in a single texture.\n\nThe project inserts the depth visualization view into the view hierarchy by embedding it within the `MetalDepthView` layout in the project’s `MetalViewSample.swift` file.\n\nThe depth visualization view’s contents consist of a texture that contains depth data from the AR session’s current frame.\n\nThe depth-texture view’s coordinator, `CoordinatorDepth`, assigns a shader that fills the texture.\n\nThe `planeFragmentShaderDepth` shader (see `shaders.metal`) converts the depth values into RGB, as required to display them.\n\nSimilarly, the project inserts the confidence visualization view into the view hierarchy by embedding it within the `MetalDepthView` layout in the project’s `MetalViewSample.swift` file.\n\nThe confidence visualization view’s contents consist of a texture that contains confidence data from the AR session’s current frame.\n\nThe confidence-texture view’s coordinator, `CoordinatorConfidence`, assigns a shader that fills the texture.\n\nThe `planeFragmentShaderConfidence` shader (see `shaders.metal`) converts the depth values into RGB, as required to display them.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/displaying-a-point-cloud-using-scene-depth\ncrawled: 2025-12-02T15:29:18Z\n---\n\n# Displaying a point cloud using scene depth\n\n**Sample Code**\n\nPresent a visualization of the physical environment by placing points based a scene’s depth data.\n\n## Overview\n\nDepth Cloud is an app that uses [doc:\/\/com.apple.documentation\/documentation\/Metal] to display a camera feed by placing a collection of points in the physical environment, according to depth information from the device’s LiDAR Scanner. For every distance sample in the session’s periodic depth reading [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap], the app places a virtual dot at that location in the physical environment, with the final result resembling a *point cloud*. Depth Cloud colors the cloud according to ARKit’s camera image [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame\/capturedImage].\n\nFor every entry in the depth map — and therefore, for every dot in the cloud — the sample app checks the corresponding pixel in the camera image and assigns the pixel’s color to the dot. When the user views the point cloud straight on, the app’s display appears nearly identical to a camera feed. To demonstrate the cloud’s 3D shape, the sample app continuously rotates the cloud to change its viewing angle with respect to the user.\n\nThe following figure illustrates a point cloud from a single frame of data, rotated on the y-axis to reveal a dark area behind the apple where the current sensor readings lack color and depth information.\n\n\n\nThe app cycles through depth *confidence* values (see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/confidenceMap], enlarges the depth buffer, and toggles ARKit’s smooth depth option [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth]. By applying the user’s selections to the point cloud live, the user can see the difference that the settings make throughout the experience.\n\n\n\nFor a practical application of ARKit’s depth data, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/creating-a-fog-effect-using-scene-depth].\n\n## Set up a camera feed\n\nTo display a camera feed, the sample project defines a SwiftUI [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene] whose [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/body-swift.property] contains a single window. To abstract view code from window code, the sample project wraps all of its display in a single [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View] called `MetalDepthView`.\n\n```swift\n@main\nstruct PointCloudDepthSample: App {\n    var body: some Scene {\n        WindowGroup {\n            MetalDepthView()\n```\n\nBecause Depth Cloud draws graphics using Metal, the sample project displays the camera feed by defining custom GPU code. The sample project accesses ARKit’s camera feed in its `ARReceiver.swift` file and wraps it in a custom `ARData` object for eventual transfer to the GPU.\n\n```swift\narData.colorImage = frame.capturedImage\n```\n\n## Ensure device support and start a session\n\nDevices require the LiDAR Scanner to access the scene’s depth. In the depth-visualization view’s [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/body-swift.property] definition, the app prevents running an unsupported configuration by checking if the device supports scene depth.\n\n```swift\nif !ARWorldTrackingConfiguration.supportsFrameSemantics([.sceneDepth, .smoothedSceneDepth]) {\n    Text(\"Unsupported Device: This app requires the LiDAR Scanner to access the scene's depth.\")\n```\n\nTo separate data acquisition from its display, the sample app wraps ARKit calls in its `ARProvider` class.\n\n```swift\nvar arProvider: ARProvider = ARProvider()\n```\n\nThe AR provider runs a world-tracking configuration and requests information about the scene’s depth by configuring the scene-depth frame semantics (see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth]. and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth]).\n\n```swift\nlet config = ARWorldTrackingConfiguration()\nconfig.frameSemantics = [.sceneDepth, .smoothedSceneDepth]\narSession.run(config)\n```\n\n## Access the scene’s depth\n\nIn response to the configuration’s scene-depth frame semantics, the framework defines the frame’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARDepthData\/depthMap] properties of [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/sceneDepth] and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARConfiguration\/FrameSemantics-swift.struct\/smoothedSceneDepth]. on the session’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/currentFrame].\n\n```swift\nfunc session(_ session: ARSession, didUpdate frame: ARFrame) {\n    if(frame.sceneDepth != nil) && (frame.smoothedSceneDepth != nil) {\n        arData.depthImage = frame.sceneDepth?.depthMap\n        arData.depthSmoothImage = frame.smoothedSceneDepth?.depthMap\n```\n\nBecause the sample project draws its graphics using Metal, the app’s CPU code bundles up data that its GPU code needs to display the experience. To model the physical environment with a point cloud, the app needs camera capture data to color each point and depth data to position them.\n\nThe sample project positions each point in GPU code, so the CPU side packages the depth data in a Metal texture for use on the GPU.\n\n```swift\ndepthContent.texture = lastArData?.depthImage?.texture(withFormat: .r32Float, planeIndex: 0, addToCache: textureCache!)!\n```\n\nThe sample project colors each point in GPU code, so the CPU side packages the camera data for use on the GPU.\n\n```swift\ncolorYContent.texture = lastArData?.colorImage?.texture(withFormat: .r8Unorm,\n                                                        planeIndex: 0,\n                                                        addToCache: textureCache!)!\ncolorCbCrContent.texture = lastArData?.colorImage?.texture(withFormat: .rg8Unorm,\n                                                           planeIndex: 1,\n                                                           addToCache: textureCache!)!\n```\n\n## Convert camera data\n\nIn the `pointCloudVertexShader` function (see the sample project’s `shaders.metal` file), the sample project creates a point for every value in the depth texture and determines the point’s color by sampling that depth-texture value’s position in the camera image. Each vertex calculates its `x` and `y` location in the camera image by converting its position in the one-dimensional vertex array, to a 2D position in the depth texture.\n\n```swift\nuint2 pos;\n\/\/ Count the rows that are depth-texture-width wide to determine the y-value.\npos.y = vertexID \/ depthTexture.get_width();\n\n\/\/ The x-position is the remainder of the y-value division.\npos.x = vertexID % depthTexture.get_width();\n```\n\nThe system’s camera-capture pipeline represents data in YUV format, which the sample project models using a luminance map (`colorYtexture`) and a blue versus red chromaticity map (`colorCbCrtexture`). The GPU color format is RGBA, which requires the sample project to convert the camera data to display it. The shader samples the luminance and chromaticity textures at the vertex’s `x,` `y` position and applies a static conversion factor.\n\n```swift\nconstexpr sampler textureSampler (mag_filter::linear,\n                                  min_filter::linear);\nout.coor = { pos.x \/ (depthTexture.get_width() - 1.0f), pos.y \/ (depthTexture.get_height() - 1.0f) };\nhalf y = colorYtexture.sample(textureSampler, out.coor).r;\nhalf2 uv = colorCbCrtexture.sample(textureSampler, out.coor).rg - half2(0.5h, 0.5h);\n\/\/ Convert YUV to RGB inline.\nhalf4 rgbaResult = half4(y + 1.402h * uv.y, y - 0.7141h * uv.y - 0.3441h * uv.x, y + 1.772h * uv.x, 1.0h);\n```\n\n\n\n## Set up the point cloud view\n\nTo display a camera feed by using a point cloud, the project defines a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewRepresentable] object, `MetalPointCloud`, which contains an [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] that displays Metal content.\n\n```swift\nstruct MetalPointCloud: UIViewRepresentable {\n```\n\nThe project inserts the point cloud view into the view hierarchy by embedding it within the `MetalDepthView` layout.\n\n```swift\nHStack() {\n    Spacer()\n    MetalPointCloud(arData: arProvider,\n                    confSelection: $selectedConfidence,\n                    scaleMovement: $scaleMovement).zoomOnTapModifier(\n                        height: geometry.size.width \/ 2 \/ sizeW * sizeH,\n                        width: geometry.size.width \/ 2, title: \"\")\n```\n\nAs representable of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView], the Metal texture view defines a coordinator, `CoordinatorPointCloud`.\n\n```swift\nfunc makeCoordinator() -> CoordinatorPointCloud {\n    return CoordinatorPointCloud(arData: arData, confSelection: $confSelection, scaleMovement: $scaleMovement)\n}\n```\n\nThe point cloud coordinator extends `MTKCoordinator`, which the sample shares across its other views that display Metal content.\n\n```swift\nfinal class CoordinatorPointCloud: MTKCoordinator {\n```\n\nAs an [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate], `MTKCoordinator` handles relevant events that occur throughout the Metal view life cycle.\n\n```swift\nclass MTKCoordinator: NSObject, MTKViewDelegate {\n```\n\nIn the `UIView` representable’s `makeUIView` implementation, the sample project assigns the coordinator as the view’s delegate.\n\n```swift\nfunc makeUIView(context: UIViewRepresentableContext<MetalPointCloud>) -> MTKView {\n    let mtkView = MTKView()\n    mtkView.delegate = context.coordinator\n```\n\nAt runtime, the display link then calls the Metal coordinator’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] implementation to issue CPU-side rendering commands.\n\n```swift\noverride func draw(in view: MTKView) {\n    content = arData.depthContent\n    let confidence = (arData.isToUpsampleDepth) ? arData.upscaledConfidence:arData.confidenceContent\n    guard arData.lastArData != nil else {\n```\n\n## Display the point cloud with gpu code\n\nThe sample project draws the point cloud on the GPU. The point cloud view packages up several textures that its corresponding GPU code requires as input.\n\n```swift\nencoder.setVertexTexture(content.texture, index: 0)\nencoder.setVertexTexture(confidence.texture, index: 1)\nencoder.setVertexTexture(arData.colorYContent.texture, index: 2)\nencoder.setVertexTexture(arData.colorCbCrContent.texture, index: 3)\n```\n\nSimilarly, the point cloud view packages up several calculated properties that its corresponding GPU code requires as input.\n\n```swift\nencoder.setVertexBytes(&pmv, length: MemoryLayout<matrix_float4x4>.stride, index: 0)\nencoder.setVertexBytes(&cameraIntrinsics, length: MemoryLayout<matrix_float3x3>.stride, index: 1)\nencoder.setVertexBytes(&confSelection, length: MemoryLayout<Int>.stride, index: 2)\n```\n\nTo call into the GPU functions that draw the point cloud, the sample defines a pipeline state that queues up its `pointCloudVertexShader` and `pointCloudFragmentShader` Metal functions (see the project’s `shaders.metal` file).\n\n```swift\npipelineDescriptor.vertexFunction = library.makeFunction(name: \"pointCloudVertexShader\")\npipelineDescriptor.fragmentFunction = library.makeFunction(name: \"pointCloudFragmentShader\")\n```\n\nOn the GPU, the point cloud vertex shader determines each point’s color and position on the screen. In the function signature, the vertex shader receives the input textures and properties sent by the CPU code.\n\n```cpp\nvertex ParticleVertexInOut pointCloudVertexShader(\n    uint vertexID [[ vertex_id ]],\n    texture2d<float, access::read> depthTexture [[ texture(0) ]],\n    texture2d<float, access::read> confTexture [[ texture(1) ]],\n    constant float4x4& viewMatrix [[ buffer(0) ]],\n    constant float3x3& cameraIntrinsics [[ buffer(1) ]],\n    constant int &confFilterMode [[ buffer(2) ]],\n    texture2d<half> colorYtexture [[ texture(2) ]],\n    texture2d<half> colorCbCrtexture [[ texture(3) ]]\n    )\n{ \/\/ ...\n```\n\nThe code bases the point’s world position on its location and depth in the camera feed.\n\n```cpp\nfloat xrw = ((int)pos.x - cameraIntrinsics[2][0]) * depth \/ cameraIntrinsics[0][0];\nfloat yrw = ((int)pos.y - cameraIntrinsics[2][1]) * depth \/ cameraIntrinsics[1][1];\nfloat4 xyzw = { xrw, yrw, depth, 1.f };\n```\n\nThe point’s screen position is a product of its world position and the argument projection matrix.\n\n```cpp\nfloat4 vecout = viewMatrix * xyzw;\n```\n\nThe vertex function outputs the point’s screen position, along with the point’s color as a converted RGB result.\n\n```cpp\nout.color = rgbaResult;\nout.clipSpacePosition = vecout;\n```\n\nThe fragment shader receives the vertex function output in its function signature.\n\n```cpp\nfragment half4 pointCloudFragmentShader(\n    ParticleVertexInOut in [[stage_in]])\n```\n\nAfter filtering any points that are too close to the device’s camera, the fragment shader queues the remaining points for display by returning the color of each vertex.\n\n```cpp\nif (in.depth < 1.0f)\n    discard_fragment();\nelse\n{\n    return in.color;\n```\n\n## Change the cloud’s orientation to convey depth\n\nAs the user views the point cloud straight on, it appears visually equivalent to the 2D camera image. But, when the sample app rotates the point cloud slightly, the 3D shape of the point cloud becomes apparent to the user.\n\n\n\nThe point cloud’s screen position is a factor of its projection matrix. In the sample project’s `calcCurrentPMVMatrix` function (see `MetalPointCloud.swift`), the function sets up a basic matrix.\n\n```swift\nfunc calcCurrentPMVMatrix(viewSize: CGSize) -> matrix_float4x4 {\n    let projection: matrix_float4x4 = makePerspectiveMatrixProjection(fovyRadians: Float.pi \/ 2.0,\n                                                                      aspect: Float(viewSize.width) \/ Float(viewSize.height),\n                                                                      nearZ: 10.0, farZ: 8000.0)\n```\n\nTo adjust the point cloud’s orientation with respect to the user, the sample app conversely sets up translation and rotation offsets for the camera’s pose.\n\n```swift\n\/\/ Randomize the camera scale.\ntranslationCamera.columns.3 = [150 * sinf, -150 * cossqr, -150 * scaleMovement * sinsqr, 1]\n\/\/ Randomize the camera movement.\ncameraRotation = simd_quatf(angle: staticAngle, axis: SIMD3(x: -sinsqr \/ 3, y: -cossqr \/ 3, z: 0))\n```\n\nThe sample project applies the camera pose offset to the original projection matrix before returning the adjusted result.\n\n```swift\nlet rotationMatrix: matrix_float4x4 = matrix_float4x4(cameraRotation)\nlet pmv = projection * rotationMatrix * translationCamera * translationOrig * orientationOrig\nreturn pmv\n\/\/#-end-code-li\n```\n\n## Enlarge the depth buffer\n\nARKit’s depth map contains precise, low-resolution depth values for objects in the camera feed. To create the illusion of a high-resolution depth map, the sample app offers UI to enlarge the depth map using Metal Performance Shaders (MPS). By filling in gaps in the framework’s depth information, the enlarged depth buffer creates the illusion of more depth information in the scene.\n\n\n\nThe sample project uses MPS to enlarge the depth buffer; see the `ARDataProvider.swift` file. The `ARProvider` class initializer creates a guided filter to enlarge the depth buffer.\n\n```swift\nguidedFilter = MPSImageGuidedFilter(device: metalDevice, kernelDiameter: guidedFilterKernelDiameter)\n```\n\nTo align the sizes of the related visuals — the camera image and confidence texture \u001f\u001f\u001f\u001f— the AR provider uses an MPS bilinear scale filter.\n\n```swift\nmpsScaleFilter = MPSImageBilinearScale(device: metalDevice)\n```\n\nIn the `processLastARData` routine, the AR provider creates an additional Metal command buffer for a compute pass that enlarges the depth buffer.\n\n```swift\nif isToUpsampleDepth {\n```\n\nThe AR provider converts the input depth data to RGB format, as required by the guided filter.\n\n```swift\nlet convertYUV2RGBFunc = lib.makeFunction(name: \"convertYCbCrToRGBA\")\npipelineStateCompute = try metalDevice.makeComputePipelineState(function: convertYUV2RGBFunc!)\n```\n\nAfter encoding the bilinear scale and guided filters, the AR provider sets the enlarged depth buffer.\n\n```swift\ndepthContent.texture = destDepthTexture\n```\n\n## Display depth and confidence\n\nIn addition to the point cloud visualization, the sample app adds simultaneous depth distance and confidence visualizations. The user refers to either visualization at any time during the experience to better grasp the accuracy of the LiDAR Scanner’s reading of the physical environment.\n\n\n\nTo display the depth and confidence visualizations, Depth Cloud defines a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/UIViewRepresentable] object, `MetalTextureView`, which contains an [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] that displays Metal content (see the project’s `MetalTextureView.swift` file). This setup is similar to `MetalDepthView`, except that the sample app stores the view’s displayable content in a single texture.\n\n```swift\nencoder.setFragmentTexture(content.texture, index: 0)\n```\n\nThe project inserts the depth visualization view into the view hierarchy by embedding it within the `MetalDepthView` layout in the project’s `MetalViewSample.swift` file.\n\n```swift\nScrollView(.horizontal) {\n    HStack() {\n        MetalTextureViewDepth(content: arProvider.depthContent, confSelection: $selectedConfidence)\n            .zoomOnTapModifier(height: sizeH, width: sizeW, title: isToUpsampleDepth ? \"Upscaled Depth\" : \"Depth\")\n```\n\nThe depth visualization view’s contents consist of a texture that contains depth data from the AR session’s current frame.\n\n```swift\ndepthContent.texture = lastArData?.depthImage?.texture(withFormat: .r32Float, planeIndex: 0, addToCache: textureCache!)!\n```\n\nThe depth-texture view’s coordinator, `CoordinatorDepth`, assigns a shader that fills the texture.\n\n```swift\npipelineDescriptor.fragmentFunction = library.makeFunction(name: \"planeFragmentShaderDepth\")\n```\n\nThe `planeFragmentShaderDepth` shader (see `shaders.metal`) converts the depth values into RGB, as required to display them.\n\n```cpp\nfragment half4 planeFragmentShaderDepth(ColorInOut in [[stage_in]], texture2d<float, access::sample> textureDepth [[ texture(0) ]])\n{\n    constexpr sampler colorSampler(address::clamp_to_edge, filter::nearest);\n    float4 s = textureDepth.sample(colorSampler, in.texCoord);\n    \n    \/\/ Size the color gradient to a maximum distance of 2.5 meters.\n    \/\/ The LiDAR Scanner supports a value no larger than 5.0; the\n    \/\/ sample app uses a value of 2.5 to better distinguish depth\n    \/\/ in smaller environments.\n    half val = s.r \/ 2.5h;\n    half4 res = getJetColorsFromNormalizedVal(val);\n    return res;\n```\n\nSimilarly, the project inserts the confidence visualization view into the view hierarchy by embedding it within the `MetalDepthView` layout in the project’s `MetalViewSample.swift` file.\n\n```swift\nMetalTextureViewConfidence(content: arProvider.confidenceContent)\n    .zoomOnTapModifier(height: sizeH, width: sizeW, title: \"Confidence\")\n```\n\nThe confidence visualization view’s contents consist of a texture that contains confidence data from the AR session’s current frame.\n\n```swift\nconfidenceContent.texture = lastArData?.confidenceImage?.texture(withFormat: .r8Unorm, planeIndex: 0, addToCache: textureCache!)!\n```\n\nThe confidence-texture view’s coordinator, `CoordinatorConfidence`, assigns a shader that fills the texture.\n\n```swift\npipelineDescriptor.fragmentFunction = library.makeFunction(name: \"planeFragmentShaderConfidence\")\n```\n\nThe `planeFragmentShaderConfidence` shader (see `shaders.metal`) converts the depth values into RGB, as required to display them.\n\n```cpp\nfragment half4 planeFragmentShaderConfidence(ColorInOut in [[stage_in]], texture2d<float, access::sample> textureIn [[ texture(0) ]])\n{\n    constexpr sampler colorSampler(address::clamp_to_edge, filter::nearest);\n    float4 s = textureIn.sample(colorSampler, in.texCoord);\n    float res = round( 255.0f*(s.r) ) ;\n    int resI = int(res);\n    half4 color = half4(0.0h, 0.0h, 0.0h, 0.0h);\n    if (resI == 0)\n        color = half4(1.0h, 0.0h, 0.0h, 1.0h);\n    else if (resI == 1)\n        color = half4(0.0h, 1.0h, 0.0h, 1.0h);\n    else if (resI == 2)\n        color = half4(0.0h, 0.0h, 1.0h, 1.0h);\n    return color;\n}\n```\n\n## Video Frame Analysis\n\n- **Creating a fog effect using scene depth**: Apply virtual fog to the physical environment.\n- **ARFrame**: A video image captured as part of a session with position-tracking information.\n- **ARPointCloud**: A collection of points in the world coordinate space of the AR session.\n- **ARDepthData**: An object that describes the distance to regions of the real world from the plane of the camera.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Apply virtual fog to the physical environment.",
          "name" : "Creating a fog effect using scene depth",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/creating-a-fog-effect-using-scene-depth"
        },
        {
          "description" : "A video image captured as part of a session with position-tracking information.",
          "name" : "ARFrame",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARFrame"
        },
        {
          "description" : "A collection of points in the world coordinate space of the AR session.",
          "name" : "ARPointCloud",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARPointCloud"
        },
        {
          "description" : "An object that describes the distance to regions of the real world from the plane of the camera.",
          "name" : "ARDepthData",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARDepthData"
        }
      ],
      "title" : "Video Frame Analysis"
    }
  ],
  "source" : "appleJSON",
  "title" : "Displaying a point cloud using scene depth",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/displaying-a-point-cloud-using-scene-depth"
}