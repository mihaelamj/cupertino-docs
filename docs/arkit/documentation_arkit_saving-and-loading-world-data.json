{
  "abstract" : "Serialize a world-tracking session to resume it later on.",
  "codeExamples" : [
    {
      "code" : "\/\/ Enable Save button only when the mapping status is good and an object has been placed\nswitch frame.worldMappingStatus {\ncase .extending, .mapped:\n    saveExperienceButton.isEnabled =\n        virtualObjectAnchor != nil && frame.anchors.contains(virtualObjectAnchor!)\ndefault:\n    saveExperienceButton.isEnabled = false\n}\nstatusLabel.text = \"\"\"\nMapping: \\(frame.worldMappingStatus.description)\nTracking: \\(frame.camera.trackingState.description)\n\"\"\"",
      "language" : "swift"
    },
    {
      "code" : "sceneView.session.getCurrentWorldMap { worldMap, error in\n    guard let map = worldMap\n        else { self.showAlert(title: \"Can't get current world map\", message: error!.localizedDescription); return }\n    \n    \/\/ Add a snapshot image indicating where the map was captured.\n    guard let snapshotAnchor = SnapshotAnchor(capturing: self.sceneView)\n        else { fatalError(\"Can't take snapshot\") }\n    map.anchors.append(snapshotAnchor)\n    \n    do {\n        let data = try NSKeyedArchiver.archivedData(withRootObject: map, requiringSecureCoding: true)\n        try data.write(to: self.mapSaveURL, options: [.atomic])\n        DispatchQueue.main.async {\n            self.loadExperienceButton.isHidden = false\n            self.loadExperienceButton.isEnabled = true\n        }\n    } catch {\n        fatalError(\"Can't save map: \\(error.localizedDescription)\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "do {\n    guard let worldMap = try NSKeyedUnarchiver.unarchivedObject(ofClass: ARWorldMap.self, from: data)\n        else { fatalError(\"No ARWorldMap in archive.\") }\n    return worldMap\n} catch {\n    fatalError(\"Can't unarchive ARWorldMap from file data: \\(error)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "let configuration = self.defaultConfiguration \/\/ this app's standard world tracking settings\nconfiguration.initialWorldMap = worldMap\nsceneView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])",
      "language" : "swift"
    },
    {
      "code" : "func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) {\n    guard anchor.name == virtualObjectAnchorName\n        else { return }\n    \n    \/\/ save the reference to the virtual object anchor when the anchor is added from relocalizing\n    if virtualObjectAnchor == nil {\n        virtualObjectAnchor = anchor\n    }\n    node.addChildNode(virtualObject)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "57fd988759fb9d9b845365734f6b125fb38f1f9ef5682e2cbfbb2d67a00aa7ca",
  "crawledAt" : "2025-12-02T15:29:22Z",
  "id" : "5BF3D446-FBFD-492E-BCF2-F5C20C20069E",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nThis sample app demonstrates a simple AR experience for iOS 12 devices. Before exploring the code, try building and running the app to familiarize yourself with the user experience it demonstrates:\n\nFollow the steps below to see how this app uses the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldMap] class to save and restore ARKit’s spatial mapping state.\n\n## Getting started\n\nRequires Xcode 10.0, iOS 12.0 and an iOS device with A9 or later processor.\n\n## Run the AR session and place AR content\n\nThis app extends the basic workflow for building an ARKit app. (For details, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/tracking-and-visualizing-planes].) It defines an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration] with plane detection enabled, then runs that configuration in the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] attached to the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNView] that displays the AR experience.\n\nWhen [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITapGestureRecognizer] detects a tap on the screen, the `handleSceneTap` method uses ARKit hit-testing to find a 3D point on a real-world surface, then places an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] marking that position. When ARKit calls the delegate method [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNViewDelegate\/renderer(_:didAdd:for:)], the app loads a 3D model for [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNView] to display at the anchor’s position.\n\n## Capture and save the AR world map\n\nAn [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldMap] object contains a snapshot of all the spatial mapping information that ARKit uses to locate the user’s device in real-world space. To save a map that can reliably be used for restoring your AR session later, you’ll first need to find a good time to capture the map.\n\nARKit provides a [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame\/worldMappingStatus-swift.property] value that indicates whether it’s currently a good time to capture a world map (or if it’s better to wait until ARKit has mapped more of the local environment). This app uses that value to provide visual feedback and choose when to make the Save Experience button available:\n\nWhen the user taps the Save Experience button, the app calls [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/getCurrentWorldMap(completionHandler:)] to capture the map from the running ARSession, then serializes it to a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] object with [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedArchiver] and writes it to local storage:\n\nTo help a user resume the AR experience from this map later, the app also captures a snapshot of the camera view with the example `SnapshotAnchor` class and stores it in the world map.\n\n## Load and relocalize to a saved map\n\nWhen the app launches, it checks local storage for a world map file it may have saved in an earlier session:\n\nIf that file exists and can be deserialized as an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldMap] object, the app makes its Load Experience button available. When you tap the button, the app tells ARKit to attempt resuming the session captured in that world map, by creating and running an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration] using that map as the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/initialWorldMap]:\n\nARKit then attempts to *relocalize* to the new world map—that is, to reconcile the received spatial-mapping information with what it senses of the local environment. This process is more likely to succeed if the user moves to areas of the local environment that they visited during the previous session. To help the user successfully resume the saved experience, this app uses the example `SnapshotAnchor` class to save a camera image in the world map, then displays that image while ARKit is relocalizing.\n\n## Restore AR content after relocalization\n\nSaving a world map also archives all anchors currently associated with the AR session. After you successfully run a session from a saved world map, the session contains all anchors previously saved in the map. You can use saved anchors to restore virtual content from a previous session.\n\nIn this app, after relocalizing to a previously saved world map, the virtual object placed in the previous session automatically appears at its saved position. The same [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNView] delegate method [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNViewDelegate\/renderer(_:didAdd:for:)] fires both when you directly add an anchor to the session and when the session restores anchors from a world map. To determine which saved anchor represents the virtual object, this app uses the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor\/name] property.\n\nIn your own AR experience, you can choose among various techniques for restoring virtual content associated with saved anchors. For example:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/saving-and-loading-world-data\ncrawled: 2025-12-02T15:29:22Z\n---\n\n# Saving and loading world data\n\n**Sample Code**\n\nSerialize a world-tracking session to resume it later on.\n\n## Overview\n\nThis sample app demonstrates a simple AR experience for iOS 12 devices. Before exploring the code, try building and running the app to familiarize yourself with the user experience it demonstrates:\n\n1. Run the app. You can look around and tap to place a virtual 3D object on real-world surfaces. (Tap again to relocate the object.)\n2. After you’ve explored the environment, the Save Experience button becomes available. Tap it to save ARKit’s world-mapping data to local storage.\n3. Tap the Load Experience button. (You can do this immediately, or after quitting and relaunching the app, even if the app has been terminated in the background.)\n4. While ARKit attempts to resume an AR session from the saved world-mapping data, the app displays a snapshot of the camera view from the time that data was saved. For best results, move the device so that the camera view matches the screenshot.\n\nFollow the steps below to see how this app uses the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldMap] class to save and restore ARKit’s spatial mapping state.\n\n## Getting started\n\nRequires Xcode 10.0, iOS 12.0 and an iOS device with A9 or later processor.\n\n## Run the AR session and place AR content\n\nThis app extends the basic workflow for building an ARKit app. (For details, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/tracking-and-visualizing-planes].) It defines an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration] with plane detection enabled, then runs that configuration in the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] attached to the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNView] that displays the AR experience.\n\nWhen [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITapGestureRecognizer] detects a tap on the screen, the `handleSceneTap` method uses ARKit hit-testing to find a 3D point on a real-world surface, then places an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] marking that position. When ARKit calls the delegate method [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNViewDelegate\/renderer(_:didAdd:for:)], the app loads a 3D model for [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNView] to display at the anchor’s position.\n\n## Capture and save the AR world map\n\nAn [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldMap] object contains a snapshot of all the spatial mapping information that ARKit uses to locate the user’s device in real-world space. To save a map that can reliably be used for restoring your AR session later, you’ll first need to find a good time to capture the map.\n\nARKit provides a [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFrame\/worldMappingStatus-swift.property] value that indicates whether it’s currently a good time to capture a world map (or if it’s better to wait until ARKit has mapped more of the local environment). This app uses that value to provide visual feedback and choose when to make the Save Experience button available:\n\n```swift\n\/\/ Enable Save button only when the mapping status is good and an object has been placed\nswitch frame.worldMappingStatus {\ncase .extending, .mapped:\n    saveExperienceButton.isEnabled =\n        virtualObjectAnchor != nil && frame.anchors.contains(virtualObjectAnchor!)\ndefault:\n    saveExperienceButton.isEnabled = false\n}\nstatusLabel.text = \"\"\"\nMapping: \\(frame.worldMappingStatus.description)\nTracking: \\(frame.camera.trackingState.description)\n\"\"\"\n```\n\nWhen the user taps the Save Experience button, the app calls [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/getCurrentWorldMap(completionHandler:)] to capture the map from the running ARSession, then serializes it to a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] object with [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedArchiver] and writes it to local storage:\n\n```swift\nsceneView.session.getCurrentWorldMap { worldMap, error in\n    guard let map = worldMap\n        else { self.showAlert(title: \"Can't get current world map\", message: error!.localizedDescription); return }\n    \n    \/\/ Add a snapshot image indicating where the map was captured.\n    guard let snapshotAnchor = SnapshotAnchor(capturing: self.sceneView)\n        else { fatalError(\"Can't take snapshot\") }\n    map.anchors.append(snapshotAnchor)\n    \n    do {\n        let data = try NSKeyedArchiver.archivedData(withRootObject: map, requiringSecureCoding: true)\n        try data.write(to: self.mapSaveURL, options: [.atomic])\n        DispatchQueue.main.async {\n            self.loadExperienceButton.isHidden = false\n            self.loadExperienceButton.isEnabled = true\n        }\n    } catch {\n        fatalError(\"Can't save map: \\(error.localizedDescription)\")\n    }\n}\n```\n\nTo help a user resume the AR experience from this map later, the app also captures a snapshot of the camera view with the example `SnapshotAnchor` class and stores it in the world map.\n\n## Load and relocalize to a saved map\n\nWhen the app launches, it checks local storage for a world map file it may have saved in an earlier session:\n\n```swift\ndo {\n    guard let worldMap = try NSKeyedUnarchiver.unarchivedObject(ofClass: ARWorldMap.self, from: data)\n        else { fatalError(\"No ARWorldMap in archive.\") }\n    return worldMap\n} catch {\n    fatalError(\"Can't unarchive ARWorldMap from file data: \\(error)\")\n}\n```\n\nIf that file exists and can be deserialized as an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldMap] object, the app makes its Load Experience button available. When you tap the button, the app tells ARKit to attempt resuming the session captured in that world map, by creating and running an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration] using that map as the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/initialWorldMap]:\n\n```swift\nlet configuration = self.defaultConfiguration \/\/ this app's standard world tracking settings\nconfiguration.initialWorldMap = worldMap\nsceneView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])\n```\n\nARKit then attempts to *relocalize* to the new world map—that is, to reconcile the received spatial-mapping information with what it senses of the local environment. This process is more likely to succeed if the user moves to areas of the local environment that they visited during the previous session. To help the user successfully resume the saved experience, this app uses the example `SnapshotAnchor` class to save a camera image in the world map, then displays that image while ARKit is relocalizing.\n\n## Restore AR content after relocalization\n\nSaving a world map also archives all anchors currently associated with the AR session. After you successfully run a session from a saved world map, the session contains all anchors previously saved in the map. You can use saved anchors to restore virtual content from a previous session.\n\nIn this app, after relocalizing to a previously saved world map, the virtual object placed in the previous session automatically appears at its saved position. The same [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNView] delegate method [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSCNViewDelegate\/renderer(_:didAdd:for:)] fires both when you directly add an anchor to the session and when the session restores anchors from a world map. To determine which saved anchor represents the virtual object, this app uses the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor\/name] property.\n\n```swift\nfunc renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) {\n    guard anchor.name == virtualObjectAnchorName\n        else { return }\n    \n    \/\/ save the reference to the virtual object anchor when the anchor is added from relocalizing\n    if virtualObjectAnchor == nil {\n        virtualObjectAnchor = anchor\n    }\n    node.addChildNode(virtualObject)\n}\n```\n\nIn your own AR experience, you can choose among various techniques for restoring virtual content associated with saved anchors. For example:\n\n- An app for visualizing furniture from a fixed catalog might save an identifier for each placed object in the corresponding anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor\/name], then use that identifier to determine which 3D model to display when resuming a session from a saved map.\n- A game that places virtual characters to play in the user’s environment might create various custom [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] subclasses to store gameplay data specific to each character, so that resuming a session from a saved map also restores the state of the game. (See [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor] Subclassing Notes and [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchorCopying].)\n\n## World Data\n\n- **ARWorldMap**: The state in a world-tracking AR session during which a device maps the user’s position in physical space and proximity to anchor objects.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The state in a world-tracking AR session during which a device maps the user’s position in physical space and proximity to anchor objects.",
          "name" : "ARWorldMap",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARWorldMap"
        }
      ],
      "title" : "World Data"
    }
  ],
  "source" : "appleJSON",
  "title" : "Saving and loading world data",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/saving-and-loading-world-data"
}