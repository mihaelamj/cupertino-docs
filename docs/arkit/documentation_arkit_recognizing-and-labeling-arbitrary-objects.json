{
  "abstract" : "Create anchors that track objects you recognize in the camera feed, using a custom optical-recognition algorithm.",
  "codeExamples" : [
    {
      "code" : "func session(_ session: ARSession, didUpdate frame: ARFrame) {\n    \/\/ Do not enqueue other buffers for processing while another Vision task is still running.\n    \/\/ The camera stream has only a finite amount of buffers available; holding too many buffers for analysis would starve the camera.\n    guard currentBuffer == nil, case .normal = frame.camera.trackingState else {\n        return\n    }\n    \n    \/\/ Retain the image buffer for Vision processing.\n    self.currentBuffer = frame.capturedImage\n    classifyCurrentImage()\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Most computer vision tasks are not rotation agnostic so it is important to pass in the orientation of the image with respect to device.\nlet orientation = CGImagePropertyOrientation(UIDevice.current.orientation)\n\nlet requestHandler = VNImageRequestHandler(cvPixelBuffer: currentBuffer!, orientation: orientation)\nvisionQueue.async {\n    do {\n        \/\/ Release the pixel buffer when done, allowing the next buffer to be processed.\n        defer { self.currentBuffer = nil }\n        try requestHandler.perform([self.classificationRequest])\n    } catch {\n        print(\"Error: Vision request failed with error \\\"\\(error)\\\"\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@IBAction func placeLabelAtLocation(sender: UITapGestureRecognizer) {\n    let hitLocationInView = sender.location(in: sceneView)\n    let hitTestResults = sceneView.hitTest(hitLocationInView, types: [.featurePoint, .estimatedHorizontalPlane])\n    if let result = hitTestResults.first {\n        \n        \/\/ Add a new anchor at the tap location.\n        let anchor = ARAnchor(transform: result.worldTransform)\n        sceneView.session.add(anchor: anchor)\n        \n        \/\/ Track anchor ID to associate text with the anchor after ARKit creates a corresponding SKNode.\n        anchorLabels[anchor.identifier] = identifierString\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func view(_ view: ARSKView, didAdd node: SKNode, for anchor: ARAnchor) {\n    guard let labelText = anchorLabels[anchor.identifier] else {\n        fatalError(\"missing expected associated label for anchor\")\n    }\n    let label = TemplateLabelNode(text: labelText)\n    node.addChild(label)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "158b6dcf6a63924e9157a97ccd2c1ff4566332bfcb44971a9f387b11fb25725b",
  "crawledAt" : "2025-12-02T15:47:28Z",
  "id" : "761C433B-41F8-4D92-90E9-E147BF3422EA",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nThis sample app parses the camera feed, using the [doc:\/\/com.apple.documentation\/documentation\/Vision] framework with a [doc:\/\/com.apple.documentation\/documentation\/CoreML] model that recognizes regular desktop items. The app displays a label onscreen that indicates when it recognizes an item. You then tap the screen to place a textual annotation in the physical environment that’s labeled with the name of the recognized object. Because the Core ML model used by this app doesn’t tell you where the object lies within an image, label placement relative to the object depends on where you tap.\n\n## Implement the vision\/core ML image classifier\n\nThe sample code’s `classificationRequest` property, `classifyCurrentImage() method, and `processClassifications(for:error:)` method manage:\n\nFor more details on using [doc:\/\/com.apple.documentation\/documentation\/Vision\/VNImageRequestHandler],[doc:\/\/com.apple.documentation\/documentation\/Vision\/VNCoreMLRequest], and image classifier models, see the [doc:\/\/com.apple.documentation\/documentation\/CoreML\/classifying-images-with-vision-and-core-ml] sample-code project.\n\n## Run the AR session and process camera images\n\nThe sample `ViewController` class manages the AR session and displays AR overlay content in a SpriteKit view. ARKit captures video frames from the camera and provides them to the view controller in the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didUpdate:)-9v2kw] method, which then calls the `classifyCurrentImage()` method to run the Vision image classifier.\n\n## Serialize image processing for real-time performance\n\nThe `classifyCurrentImage()` method uses the view controller’s `currentBuffer` property to track whether Vision is currently processing an image before starting another Vision task.\n\nIn addition, the sample app enables the [doc:\/\/com.apple.documentation\/documentation\/Vision\/VNRequest\/usesCPUOnly] setting for its Vision request, freeing the GPU for use in rendering.\n\n## Visualize results in AR\n\nThe `processClassifications(for:error:) method stores the best-match result label produced by the image classifier and displays it in the corner of the screen. The user can then tap in the AR scene to place that label at a real-world position. Placing a label requires two main steps.\n\nFirst, a tap gesture recognizer fires the `placeLabelAtLocation(sender:)` action. This method uses the ARKit [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSKView\/hitTest(_:types:)] method to estimate the 3D real-world position corresponding to the tap, and adds an anchor to the AR session at that position.\n\nNext, after ARKit automatically creates a SpriteKit node for the newly added anchor, the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSKViewDelegate\/view(_:didAdd:for:)] delegate method provides content for that node. In this case, the sample `TemplateLabelNode` class creates a styled text label using the string provided by the image classifier.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/recognizing-and-labeling-arbitrary-objects\ncrawled: 2025-12-02T15:47:28Z\n---\n\n# Recognizing and Labeling Arbitrary Objects\n\n**Sample Code**\n\nCreate anchors that track objects you recognize in the camera feed, using a custom optical-recognition algorithm.\n\n## Overview\n\nThis sample app parses the camera feed, using the [doc:\/\/com.apple.documentation\/documentation\/Vision] framework with a [doc:\/\/com.apple.documentation\/documentation\/CoreML] model that recognizes regular desktop items. The app displays a label onscreen that indicates when it recognizes an item. You then tap the screen to place a textual annotation in the physical environment that’s labeled with the name of the recognized object. Because the Core ML model used by this app doesn’t tell you where the object lies within an image, label placement relative to the object depends on where you tap.\n\n\n\n## Implement the vision\/core ML image classifier\n\nThe sample code’s `classificationRequest` property, `classifyCurrentImage() method, and `processClassifications(for:error:)` method manage:\n\n- A Core ML image-classifier model, loaded from an `mlmodel` file bundled with the app using the Swift API that Core ML generates for the model\n- [doc:\/\/com.apple.documentation\/documentation\/Vision\/VNCoreMLRequest] and [doc:\/\/com.apple.documentation\/documentation\/Vision\/VNImageRequestHandler] objects for passing image data to the model for evaluation\n\nFor more details on using [doc:\/\/com.apple.documentation\/documentation\/Vision\/VNImageRequestHandler],[doc:\/\/com.apple.documentation\/documentation\/Vision\/VNCoreMLRequest], and image classifier models, see the [doc:\/\/com.apple.documentation\/documentation\/CoreML\/classifying-images-with-vision-and-core-ml] sample-code project.\n\n## Run the AR session and process camera images\n\nThe sample `ViewController` class manages the AR session and displays AR overlay content in a SpriteKit view. ARKit captures video frames from the camera and provides them to the view controller in the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didUpdate:)-9v2kw] method, which then calls the `classifyCurrentImage()` method to run the Vision image classifier.\n\n```swift\nfunc session(_ session: ARSession, didUpdate frame: ARFrame) {\n    \/\/ Do not enqueue other buffers for processing while another Vision task is still running.\n    \/\/ The camera stream has only a finite amount of buffers available; holding too many buffers for analysis would starve the camera.\n    guard currentBuffer == nil, case .normal = frame.camera.trackingState else {\n        return\n    }\n    \n    \/\/ Retain the image buffer for Vision processing.\n    self.currentBuffer = frame.capturedImage\n    classifyCurrentImage()\n}\n```\n\n## Serialize image processing for real-time performance\n\nThe `classifyCurrentImage()` method uses the view controller’s `currentBuffer` property to track whether Vision is currently processing an image before starting another Vision task.\n\n```swift\n\/\/ Most computer vision tasks are not rotation agnostic so it is important to pass in the orientation of the image with respect to device.\nlet orientation = CGImagePropertyOrientation(UIDevice.current.orientation)\n\nlet requestHandler = VNImageRequestHandler(cvPixelBuffer: currentBuffer!, orientation: orientation)\nvisionQueue.async {\n    do {\n        \/\/ Release the pixel buffer when done, allowing the next buffer to be processed.\n        defer { self.currentBuffer = nil }\n        try requestHandler.perform([self.classificationRequest])\n    } catch {\n        print(\"Error: Vision request failed with error \\\"\\(error)\\\"\")\n    }\n}\n```\n\n\n\nIn addition, the sample app enables the [doc:\/\/com.apple.documentation\/documentation\/Vision\/VNRequest\/usesCPUOnly] setting for its Vision request, freeing the GPU for use in rendering.\n\n## Visualize results in AR\n\nThe `processClassifications(for:error:) method stores the best-match result label produced by the image classifier and displays it in the corner of the screen. The user can then tap in the AR scene to place that label at a real-world position. Placing a label requires two main steps.\n\nFirst, a tap gesture recognizer fires the `placeLabelAtLocation(sender:)` action. This method uses the ARKit [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSKView\/hitTest(_:types:)] method to estimate the 3D real-world position corresponding to the tap, and adds an anchor to the AR session at that position.\n\n```swift\n@IBAction func placeLabelAtLocation(sender: UITapGestureRecognizer) {\n    let hitLocationInView = sender.location(in: sceneView)\n    let hitTestResults = sceneView.hitTest(hitLocationInView, types: [.featurePoint, .estimatedHorizontalPlane])\n    if let result = hitTestResults.first {\n        \n        \/\/ Add a new anchor at the tap location.\n        let anchor = ARAnchor(transform: result.worldTransform)\n        sceneView.session.add(anchor: anchor)\n        \n        \/\/ Track anchor ID to associate text with the anchor after ARKit creates a corresponding SKNode.\n        anchorLabels[anchor.identifier] = identifierString\n    }\n}\n```\n\nNext, after ARKit automatically creates a SpriteKit node for the newly added anchor, the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSKViewDelegate\/view(_:didAdd:for:)] delegate method provides content for that node. In this case, the sample `TemplateLabelNode` class creates a styled text label using the string provided by the image classifier.\n\n```swift\nfunc view(_ view: ARSKView, didAdd node: SKNode, for anchor: ARAnchor) {\n    guard let labelText = anchorLabels[anchor.identifier] else {\n        fatalError(\"missing expected associated label for anchor\")\n    }\n    let label = TemplateLabelNode(text: labelText)\n    node.addChild(label)\n}\n```\n\n## Text Annotations\n\n- **Creating screen annotations for objects in an AR experience**: Annotate an AR experience with virtual sticky notes that you display onscreen over real and virtual objects.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Annotate an AR experience with virtual sticky notes that you display onscreen over real and virtual objects.",
          "name" : "Creating screen annotations for objects in an AR experience",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/creating-screen-annotations-for-objects-in-an-ar-experience"
        }
      ],
      "title" : "Text Annotations"
    }
  ],
  "source" : "appleJSON",
  "title" : "Recognizing and Labeling Arbitrary Objects",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/recognizing-and-labeling-arbitrary-objects"
}