{
  "abstract" : "Enable nearby devices to share an AR experience by using a peer-to-peer multiuser strategy.",
  "codeExamples" : [
    {
      "code" : "configuration = ARWorldTrackingConfiguration()\n\n\/\/ Enable a collaborative session.\nconfiguration?.isCollaborationEnabled = true\n\n\/\/ Enable realistic reflections.\nconfiguration?.environmentTexturing = .automatic\n\n\/\/ Begin the session.\narView.session.run(configuration!)",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: ARSession, didOutputCollaborationData data: ARSession.CollaborationData) {\n    guard let multipeerSession = multipeerSession else { return }\n    if !multipeerSession.connectedPeers.isEmpty {\n        guard let encodedData = try? NSKeyedArchiver.archivedData(withRootObject: data, requiringSecureCoding: true)\n        else { fatalError(\"Unexpectedly failed to encode collaboration data.\") }\n        \/\/ Use reliable mode if the data is critical, and unreliable mode if the data is optional.\n        let dataIsCritical = data.priority == .critical\n        multipeerSession.sendToAllPeers(encodedData, reliably: dataIsCritical)\n    } else {\n        print(\"Deferred sending collaboration to later because there are no peers.\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func sendToPeers(_ data: Data, reliably: Bool, peers: [MCPeerID]) {\n    guard !peers.isEmpty else { return }\n    do {\n        try session.send(data, toPeers: peers, with: reliably ? .reliable : .unreliable)\n    } catch {\n        print(\"error sending data to peers \\(peers): \\(error.localizedDescription)\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func receivedData(_ data: Data, from peer: MCPeerID) {\n    if let collaborationData = try? NSKeyedUnarchiver.unarchivedObject(ofClass: ARSession.CollaborationData.self, from: data) {\n        arView.session.update(with: collaborationData)\n        return\n    }\n    \/\/ ...",
      "language" : "swift"
    },
    {
      "code" : "messageLabel.displayMessage(\"\"\"\n    A peer wants to join the experience.\n    Hold the phones next to each other.\n    \"\"\", duration: 6.0)",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: ARSession, didAdd anchors: [ARAnchor]) {\n    for anchor in anchors {\n        if let participantAnchor = anchor as? ARParticipantAnchor {\n            messageLabel.displayMessage(\"Established joint experience with a peer.\")\n            \/\/ ...",
      "language" : "swift"
    },
    {
      "code" : "let anchorEntity = AnchorEntity(anchor: participantAnchor)\n\nlet coordinateSystem = MeshResource.generateCoordinateSystemAxes()\nanchorEntity.addChild(coordinateSystem)\n\nlet color = participantAnchor.sessionIdentifier?.toRandomColor() ?? .white\nlet coloredSphere = ModelEntity(mesh: MeshResource.generateSphere(radius: 0.03),\n                                materials: [SimpleMaterial(color: color, isMetallic: true)])\nanchorEntity.addChild(coloredSphere)\n\narView.scene.addAnchor(anchorEntity)",
      "language" : "swift"
    },
    {
      "code" : "let color = anchor.sessionIdentifier?.toRandomColor() ?? .white",
      "language" : "swift"
    },
    {
      "code" : "func toRandomColor() -> UIColor {\n    var firstFourUUIDBytesAsUInt32: UInt32 = 0\n    let data = withUnsafePointer(to: self) {\n        return Data(bytes: $0, count: MemoryLayout.size(ofValue: self))\n    }\n    _ = withUnsafeMutableBytes(of: &firstFourUUIDBytesAsUInt32, { data.copyBytes(to: $0) })\n\n    let colors: [UIColor] = [.red, .green, .blue, .yellow, .magenta, .cyan, .purple,\n    .orange, .brown, .lightGray, .gray, .darkGray, .black, .white]\n    \n    let randomNumber = Int(firstFourUUIDBytesAsUInt32) % colors.count\n    return colors[randomNumber]\n}",
      "language" : "swift"
    },
    {
      "code" : "let coloredCube = ModelEntity(mesh: MeshResource.generateBox(size: boxLength),\n                              materials: [SimpleMaterial(color: color, isMetallic: true)])\n\/\/ Offset the cube by half its length to align its bottom with the real-world surface.\ncoloredCube.position = [0, boxLength \/ 2, 0]\n\n\/\/ Attach the cube to the ARAnchor via an AnchorEntity.\n\/\/   World origin -> ARAnchor -> AnchorEntity -> ModelEntity\nlet anchorEntity = AnchorEntity(anchor: anchor)\nanchorEntity.addChild(coloredCube)\narView.scene.addAnchor(anchorEntity)",
      "language" : "swift"
    }
  ],
  "contentHash" : "9bdcd540ca09501b7aa70228b525fcf4e1efd7b2ba6fccdcd33f99f07b241255",
  "crawledAt" : "2025-12-02T15:47:20Z",
  "id" : "B969256B-33CA-4448-8D70-7BC94C0C1148",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nAs an AR app runs, ARKit gathers information about a userʼs physical environment by processing the camera feed from the user’s device. To effect a multiuser AR experience in which users learn more about the environment by sharing the information from their device’s camera feed with other users, you enable *collaboration*.\n\nThroughout a collaborative session, ARKit periodically provides data for you to share with peer users, and you choose a network protocol to send that data. In addition to information about the layout of the physical environment––the *world data*––collaboration data includes an anchor for each participant. These anchors indicate each peer’s approximate location, which you can use, for example, to place virtual content that represents the peer user. ARKit also provides you with any anchors that the peer users create themselves.\n\nThis sample app allows multiple users to view a common horizontal surface and place blocks on top of the surface, with a unique color for each user.\n\n\n\nAlthough this sample draws its graphics using RealityKit, it doesn’t use RealityKit’s mechanism for over-the-network entity synchronization. Instead, it uses RealityKit as a renderer only as necessary to demonstrate ARKit’s collaborative session.\n\nTo create a shared AR experience using a host-guest approach, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/creating-a-multiuser-ar-experience].\n\n## Enable Collaboration\n\nCollaborative sessions are available when your session uses [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration]. To enable collaboration, set [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/isCollaborationEnabled] to `true`.\n\n## Gather collaboration data\n\nWhen collaboration is enabled, ARKit periodically invokes [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionObserver\/session(_:didOutputCollaborationData:)], which provides collaboration data that you can share with nearby users. You are responsible for sending collaboration data over the network, including choosing the network framework and implementing the code. The data you send is a serialized version of the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/CollaborationData] object provided by your session. Before you send collaboration data over the network, first serialize it using [[doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedArchiver].\n\nIt’s safe to ignore the collaboration data if no peers have joined the session. In that case, ARKit outputs the collaboration data later to try again. The alternative approach of enabling collaboration only after peers have joined is not supported, because doing so restarts the session.\n\n## Send collaboration data to others\n\nYou choose the network protocol with which to share collaboration data. This sample app sends collaboration data using [doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity].\n\n## Update your session with collaboration data\n\nWhen you receive collaboration data from peer users, you instantiate an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/CollaborationData] object with it, and pass the object to your session via [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/update(with:)].\n\n## Facilitate world map merging\n\nFor ARKit to know where two users are with respect to each other, it has to recognize overlap across their respective world maps. When ARKit succeeds in fitting the two world maps together, it can begin sharing those users’ respective locations and any anchors they created with each other.\n\nTo aid ARKit with world map merging, a user must point their device near an area that another user has viewed. The sample app accomplishes this by asking the users to hold their devices side by side.\n\n## Identify when ARKit merges world data\n\nThe first time ARKit successfully merges world data from another user, it calls your app’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didAdd:)], passing in an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate] that identifies the other user. This action notifies you of the merging event.\n\n## Visualize users by displaying virtual content\n\nWhen ARKit successfully merges two users’ world data, you can then initiate actions to begin the multiuser experience. The sample adds virtual content in the real-world location of newly joined peer users to visualize them in AR.\n\nThe multicolored coordinate system shown in the following illustration represents the real-world pose of a peer user. ARKit periodically refreshes participant anchors to reflect any updates in the real-world location and orientation of the user it tracks. This process is a part of the collaboration data your app shares and uses to update its session.\n\n\n\n## Check an anchor’s owner\n\nWhen ARKit merges two users’ world data, it collects all the anchors created by both users and calls [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didAdd:)] to notify each user of the collection. To check which user created an anchor, you compare the anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor\/sessionIdentifier] with the active session’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/identifier]. If the anchor’s session ID is different from the active session’s ID, the other user created the anchor.\n\n## Color Virtual Content Based on the User\n\nTo distinguish virtual content by user, you choose a different color for each user. The sample app uses the `toRandomColor` function to assign user colors.\n\nThe random color function works by applying a modulo operation to the anchor’s session ID, and interpreting the result as an index into a color array.\n\n## Place virtual content\n\nWhen ARKit notifies you of a new nonparticipant anchor in [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didAdd:)], place a block geometry tinted with the color calculated in the previous section.\n\n\n\nThe sample app uses common ARKit techniques to place virtual objects. For more information about mapping screen touches to real-world locations, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/detecting-images-in-an-ar-experience].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/creating-a-collaborative-session\ncrawled: 2025-12-02T15:47:20Z\n---\n\n# Creating a collaborative session\n\n**Sample Code**\n\nEnable nearby devices to share an AR experience by using a peer-to-peer multiuser strategy.\n\n## Overview\n\nAs an AR app runs, ARKit gathers information about a userʼs physical environment by processing the camera feed from the user’s device. To effect a multiuser AR experience in which users learn more about the environment by sharing the information from their device’s camera feed with other users, you enable *collaboration*.\n\nThroughout a collaborative session, ARKit periodically provides data for you to share with peer users, and you choose a network protocol to send that data. In addition to information about the layout of the physical environment––the *world data*––collaboration data includes an anchor for each participant. These anchors indicate each peer’s approximate location, which you can use, for example, to place virtual content that represents the peer user. ARKit also provides you with any anchors that the peer users create themselves.\n\nThis sample app allows multiple users to view a common horizontal surface and place blocks on top of the surface, with a unique color for each user.\n\n\n\nAlthough this sample draws its graphics using RealityKit, it doesn’t use RealityKit’s mechanism for over-the-network entity synchronization. Instead, it uses RealityKit as a renderer only as necessary to demonstrate ARKit’s collaborative session.\n\nTo create a shared AR experience using a host-guest approach, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/creating-a-multiuser-ar-experience].\n\n## Enable Collaboration\n\nCollaborative sessions are available when your session uses [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration]. To enable collaboration, set [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/isCollaborationEnabled] to `true`.\n\n```swift\nconfiguration = ARWorldTrackingConfiguration()\n\n\/\/ Enable a collaborative session.\nconfiguration?.isCollaborationEnabled = true\n\n\/\/ Enable realistic reflections.\nconfiguration?.environmentTexturing = .automatic\n\n\/\/ Begin the session.\narView.session.run(configuration!)\n```\n\n## Gather collaboration data\n\nWhen collaboration is enabled, ARKit periodically invokes [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionObserver\/session(_:didOutputCollaborationData:)], which provides collaboration data that you can share with nearby users. You are responsible for sending collaboration data over the network, including choosing the network framework and implementing the code. The data you send is a serialized version of the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/CollaborationData] object provided by your session. Before you send collaboration data over the network, first serialize it using [[doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedArchiver].\n\n```swift\nfunc session(_ session: ARSession, didOutputCollaborationData data: ARSession.CollaborationData) {\n    guard let multipeerSession = multipeerSession else { return }\n    if !multipeerSession.connectedPeers.isEmpty {\n        guard let encodedData = try? NSKeyedArchiver.archivedData(withRootObject: data, requiringSecureCoding: true)\n        else { fatalError(\"Unexpectedly failed to encode collaboration data.\") }\n        \/\/ Use reliable mode if the data is critical, and unreliable mode if the data is optional.\n        let dataIsCritical = data.priority == .critical\n        multipeerSession.sendToAllPeers(encodedData, reliably: dataIsCritical)\n    } else {\n        print(\"Deferred sending collaboration to later because there are no peers.\")\n    }\n}\n```\n\nIt’s safe to ignore the collaboration data if no peers have joined the session. In that case, ARKit outputs the collaboration data later to try again. The alternative approach of enabling collaboration only after peers have joined is not supported, because doing so restarts the session.\n\n## Send collaboration data to others\n\nYou choose the network protocol with which to share collaboration data. This sample app sends collaboration data using [doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity].\n\n```swift\nfunc sendToPeers(_ data: Data, reliably: Bool, peers: [MCPeerID]) {\n    guard !peers.isEmpty else { return }\n    do {\n        try session.send(data, toPeers: peers, with: reliably ? .reliable : .unreliable)\n    } catch {\n        print(\"error sending data to peers \\(peers): \\(error.localizedDescription)\")\n    }\n}\n```\n\n## Update your session with collaboration data\n\nWhen you receive collaboration data from peer users, you instantiate an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/CollaborationData] object with it, and pass the object to your session via [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/update(with:)].\n\n```swift\nfunc receivedData(_ data: Data, from peer: MCPeerID) {\n    if let collaborationData = try? NSKeyedUnarchiver.unarchivedObject(ofClass: ARSession.CollaborationData.self, from: data) {\n        arView.session.update(with: collaborationData)\n        return\n    }\n    \/\/ ...\n```\n\n## Facilitate world map merging\n\nFor ARKit to know where two users are with respect to each other, it has to recognize overlap across their respective world maps. When ARKit succeeds in fitting the two world maps together, it can begin sharing those users’ respective locations and any anchors they created with each other.\n\nTo aid ARKit with world map merging, a user must point their device near an area that another user has viewed. The sample app accomplishes this by asking the users to hold their devices side by side.\n\n```swift\nmessageLabel.displayMessage(\"\"\"\n    A peer wants to join the experience.\n    Hold the phones next to each other.\n    \"\"\", duration: 6.0)\n```\n\n## Identify when ARKit merges world data\n\nThe first time ARKit successfully merges world data from another user, it calls your app’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didAdd:)], passing in an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate] that identifies the other user. This action notifies you of the merging event.\n\n```swift\nfunc session(_ session: ARSession, didAdd anchors: [ARAnchor]) {\n    for anchor in anchors {\n        if let participantAnchor = anchor as? ARParticipantAnchor {\n            messageLabel.displayMessage(\"Established joint experience with a peer.\")\n            \/\/ ...\n```\n\n## Visualize users by displaying virtual content\n\nWhen ARKit successfully merges two users’ world data, you can then initiate actions to begin the multiuser experience. The sample adds virtual content in the real-world location of newly joined peer users to visualize them in AR.\n\n```swift\nlet anchorEntity = AnchorEntity(anchor: participantAnchor)\n\nlet coordinateSystem = MeshResource.generateCoordinateSystemAxes()\nanchorEntity.addChild(coordinateSystem)\n\nlet color = participantAnchor.sessionIdentifier?.toRandomColor() ?? .white\nlet coloredSphere = ModelEntity(mesh: MeshResource.generateSphere(radius: 0.03),\n                                materials: [SimpleMaterial(color: color, isMetallic: true)])\nanchorEntity.addChild(coloredSphere)\n\narView.scene.addAnchor(anchorEntity)\n```\n\nThe multicolored coordinate system shown in the following illustration represents the real-world pose of a peer user. ARKit periodically refreshes participant anchors to reflect any updates in the real-world location and orientation of the user it tracks. This process is a part of the collaboration data your app shares and uses to update its session.\n\n\n\n## Check an anchor’s owner\n\nWhen ARKit merges two users’ world data, it collects all the anchors created by both users and calls [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didAdd:)] to notify each user of the collection. To check which user created an anchor, you compare the anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARAnchor\/sessionIdentifier] with the active session’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession\/identifier]. If the anchor’s session ID is different from the active session’s ID, the other user created the anchor.\n\n## Color Virtual Content Based on the User\n\nTo distinguish virtual content by user, you choose a different color for each user. The sample app uses the `toRandomColor` function to assign user colors.\n\n```swift\nlet color = anchor.sessionIdentifier?.toRandomColor() ?? .white\n```\n\nThe random color function works by applying a modulo operation to the anchor’s session ID, and interpreting the result as an index into a color array.\n\n```swift\nfunc toRandomColor() -> UIColor {\n    var firstFourUUIDBytesAsUInt32: UInt32 = 0\n    let data = withUnsafePointer(to: self) {\n        return Data(bytes: $0, count: MemoryLayout.size(ofValue: self))\n    }\n    _ = withUnsafeMutableBytes(of: &firstFourUUIDBytesAsUInt32, { data.copyBytes(to: $0) })\n\n    let colors: [UIColor] = [.red, .green, .blue, .yellow, .magenta, .cyan, .purple,\n    .orange, .brown, .lightGray, .gray, .darkGray, .black, .white]\n    \n    let randomNumber = Int(firstFourUUIDBytesAsUInt32) % colors.count\n    return colors[randomNumber]\n}\n```\n\n## Place virtual content\n\nWhen ARKit notifies you of a new nonparticipant anchor in [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didAdd:)], place a block geometry tinted with the color calculated in the previous section.\n\n```swift\nlet coloredCube = ModelEntity(mesh: MeshResource.generateBox(size: boxLength),\n                              materials: [SimpleMaterial(color: color, isMetallic: true)])\n\/\/ Offset the cube by half its length to align its bottom with the real-world surface.\ncoloredCube.position = [0, boxLength \/ 2, 0]\n\n\/\/ Attach the cube to the ARAnchor via an AnchorEntity.\n\/\/   World origin -> ARAnchor -> AnchorEntity -> ModelEntity\nlet anchorEntity = AnchorEntity(anchor: anchor)\nanchorEntity.addChild(coloredCube)\narView.scene.addAnchor(anchorEntity)\n```\n\n\n\nThe sample app uses common ARKit techniques to place virtual objects. For more information about mapping screen touches to real-world locations, see [doc:\/\/com.apple.arkit\/documentation\/ARKit\/detecting-images-in-an-ar-experience].\n\n## Shared Experiences\n\n- **Streaming an AR experience**: Control an AR experience remotely by transferring sensor and user input over the network.\n- **Creating a multiuser AR experience**: Enable nearby devices to share an AR experience by using a host-guest multiuser strategy.\n- **ARParticipantAnchor**: An anchor for another user in multiuser augmented reality experiences.\n- **ARSession.CollaborationData**: An object that holds information that a user has collected about the physical environment.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Control an AR experience remotely by transferring sensor and user input over the network.",
          "name" : "Streaming an AR experience",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/streaming-an-ar-experience"
        },
        {
          "description" : "Enable nearby devices to share an AR experience by using a host-guest multiuser strategy.",
          "name" : "Creating a multiuser AR experience",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/creating-a-multiuser-ar-experience"
        },
        {
          "description" : "An anchor for another user in multiuser augmented reality experiences.",
          "name" : "ARParticipantAnchor",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARParticipantAnchor"
        },
        {
          "description" : "An object that holds information that a user has collected about the physical environment.",
          "name" : "ARSession.CollaborationData",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARSession\/CollaborationData"
        }
      ],
      "title" : "Shared Experiences"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a collaborative session",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/creating-a-collaborative-session"
}