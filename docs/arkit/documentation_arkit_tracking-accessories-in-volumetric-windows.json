{
  "abstract" : "Translate the position and velocity of tracked handheld accessories to throw virtual balls at a stack of cans.",
  "codeExamples" : [
    {
      "code" : "    if !AccessoryTrackingProvider.isSupported {\n        state = .accessoryTrackingNotSupported\n        return\n    }\n    \n    \/\/ Listen for connected and disconnected controllers.\n    NotificationCenter.default.addObserver(forName: NSNotification.Name.GCControllerDidConnect,\n                                           object: nil,\n                                           queue: nil) { notification in\n        if let controller = notification.object as? GCController {\n            guard controller.productCategory == GCProductCategorySpatialController else {\n                return\n            }\n            \n            \/\/...\n        }\n    }\n    \n    NotificationCenter.default.addObserver(forName: NSNotification.Name.GCControllerDidDisconnect,\n                                           object: nil,\n                                           queue: nil) { notification in\n        if let controller = notification.object as? GCController {\n            if controller.productCategory == GCProductCategorySpatialController {\n                \/\/...\n            }\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "private func monitorARKitSessionEvents() async {\n    for await event in arkitSession.events {\n        switch event {\n            case .dataProviderStateChanged(_, let newState, let error):\n                if newState == .stopped {\n                    if let error {\n                        print(\"An error occurred: \\(error)\")\n                        state = .arkitSessionError\n                    }\n                }\n        case .authorizationChanged(let type, let authorizationStatus):\n            if type == .accessoryTracking {\n                if authorizationStatus == .denied {\n                    state = .accessoryTrackingNotAuthorized\n                } else if authorizationStatus == .allowed {\n                    state = .startingUp\n                    \/\/ ...\n                }\n            }\n        default:\n            break\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let accessoryTracking = AccessoryTrackingProvider(accessories: accessories)\n\ndo {\n    try await arkitSession.run([accessoryTracking])\n    state = .inGame\n    gameState = .startNewGame\n} catch {\n    return\n}\n\nfor await update in accessoryTracking.anchorUpdates {\n    process(update)\n}",
      "language" : "swift"
    },
    {
      "code" : "let aimPoint = controllerAnchor.coordinateSpace(for: .aim, correction: .rendered)\n\nif let realityViewFromAimPointTransform = try? realityViewOrigin.transform(from: aimPoint) {\n    let aimPointPosition = realityViewFromAimPointTransform.matrix.columns.3.xyz\n    isInsideRealityView = realityViewEdges.contains(aimPointPosition)\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let anchor = controller.anchor else { return }\n\nlet controllerSpeed = length(anchor.velocity)\ncontroller.pendingThrow.peakSpeed = max(controller.pendingThrow.peakSpeed, controllerSpeed)\n\nif controller.pendingThrow.peakSpeed > 1.2 &&\n    controllerSpeed < controller.pendingThrow.peakSpeed - 0.6 {\n    \/\/ Trigger a throw if:\n    \/\/ The controller's peak speed is more than 1.2 m\/s.\n    \/\/ The controller's speed drops more than 0.6 m\/s below the peak.\n    if controller.triggeredThrow == nil {\n        controller.pendingThrow.anchor = anchor\n        \n        controller.triggeredThrow = controller.pendingThrow\n        controller.pendingThrow = Throw()\n        \n        Task {\n            \/\/ Allow the next throw after 1 second.\n            try? await Task.sleep(for: .milliseconds(1000))\n            controller.triggeredThrow = nil\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let anchor = controller.anchor else { return }\n\nlet controllerZAngularVelocity = anchor.angularVelocity[2]\ncontroller.pendingShake.peakAngularVelocity = max(controller.pendingShake.peakAngularVelocity, controllerZAngularVelocity)",
      "language" : "swift"
    },
    {
      "code" : "let halfPi: Float = .pi \/ 2\n\nif controllerZAngularVelocity < controller.pendingShake.peakAngularVelocity - halfPi &&\n    abs(anchor.angularVelocity[0]) < halfPi && abs(anchor.angularVelocity[1]) < halfPi {\n    \/\/ Detect a controller oscillation on the z-axis if:\n    \/\/ The controller's angular velocity on the z-axis drops more than 90 deg\/s below the peak angular velocity.\n    \/\/ The controller's angular velocity on the other axes is less than 90 deg\/s.\n    let controllerPosition: SIMD3<Float> = anchor.originFromAnchorTransform.columns.3.xyz\n    \n    \/\/ Reset the shake if the user moves too much.\n    if let shakePrevPos = controller.pendingShake.initialPosition {\n        guard length(controllerPosition - shakePrevPos) < 0.2 else {\n            controller.pendingShake = Shake()\n            return\n        }\n    }\n    \n    if controllerZAngularVelocity < -halfPi {\n        if controller.pendingShake.currentDirection == .counterClockwise {\n            controller.pendingShake.oscillationCount += 1\n        }\n        controller.pendingShake.currentDirection = .clockwise\n    } else if controllerZAngularVelocity > halfPi {\n        if controller.pendingShake.currentDirection == .clockwise {\n            controller.pendingShake.oscillationCount += 1\n        }\n        controller.pendingShake.currentDirection = .counterClockwise\n    }\n    \n    if controller.pendingShake.oscillationCount == 1 {\n        controller.pendingShake.initialPosition = controllerPosition\n    }",
      "language" : "swift"
    },
    {
      "code" : "    if controller.triggeredShake == nil && controller.pendingShake.oscillationCount >= 6 {\n        controller.triggeredShake = controller.pendingShake\n        controller.pendingShake = Shake()\n        \n        gameState = .startNewGame\n        \n        Task {\n            \/\/ Reset the triggered shake after 0.5 seconds.\n            try? await Task.sleep(for: .milliseconds(500))\n            controller.triggeredShake = nil\n        }\n    }",
      "language" : "swift"
    }
  ],
  "contentHash" : "1bde0d2e1ffffed48a5ab86cef5901976cfd49fa3a67afc3c8ad80a0e48de05e",
  "crawledAt" : "2025-12-02T15:27:10Z",
  "id" : "B9B92125-06C7-4941-8592-B18EED358A18",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nAccessories enhance the experience of Apple Vision Pro, and offer added functionality and flexibility by supporting fine control, novel input methods, and custom experiences. You can use ARKit to locate and track accessories, converting their real-world motion into app-accessible data. Specifically, ARKit supports high-frequency tracking of an accessory’s position and orientation, which it derives velocity and angular velocity information from. Additionally, ARKit provides methods to convert the real-world tracking information to the relevant coordinate spaces in your app.\n\nSome experiences may require accessories, but most let people perform tasks with both controllers and hands.\n\nThis sample code project creates a carnival-like experience with a set of stacked cans in a crate. The cans have physics bodies and are subject to gravity, causing them to fall when a thrown tennis ball strikes them. The crate fills the volume that contains it, and the app tracks accessories when it locates them within the volume. The sample uses tracking information to place a virtual tennis ball model over an onscreen accessory. A quick, tossing motion throws the ball, knocking down the cans, and a rapid set of clockwise and counterclockwise rotations sets them up again.\n\n### Set up the sample\n\nThe sample adds an [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSAccessoryTrackingUsageDescription] to the information property list file with a description of how the app uses the tracking information. Additionally, a [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/GCSupportedGameControllers] entry with a `SpatialGamepad` type is required for the  [doc:\/\/com.apple.documentation\/documentation\/GameController] framework to return controllers when requested. To track the controllers, the app needs to listen for accessories the system adds and removes by observing the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/GCControllerDidConnect] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/GCControllerDidDisconnect] notifications of the GameController framework.\n\nThe notification object is the `GCController` that’s changing connection state. The sample first checks [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider\/isSupported] to determine if accessory tracking is available. If so, the app monitors session events to update the internal state based on the data provider state.\n\nAn [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARKitSession] running [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider] implicitly requests authorization. Your app can handle this with an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARKitSession\/Event\/authorizationChanged(type:status:)] session event. If the player authorizes the tracking, the code in the `authorizationChanged` handler starts controller tracking.\n\n### Track accessories\n\nWithin its tracking code, the sample requests all available controllers with [doc:\/\/com.apple.documentation\/documentation\/GameController\/GCController\/controllers()]. Create a trackable ARKit [doc:\/\/com.apple.arkit\/documentation\/ARKit\/Accessory] object from the returned [doc:\/\/com.apple.documentation\/documentation\/GameController\/GCController] device. Passing the available accessories to the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider] allows the sample to access [doc:\/\/com.apple.documentation\/documentation\/ARKit\/Anchor] updates when running in an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] object. Accessory events are available asynchronously from [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider\/anchorUpdates]. During tracking, the sample performs several operations — verifying the controllers presence within the volume, syncing the tennis ball position with the controllers, and checking for the player performing a throw or shake action.\n\nThe system uses the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView] update closure to verify that the controllers are located within the volume, and the sample generates a bounding box that the volume determines. If at least one controller is connected and located within the volume bounds, the app state updates accordingly. If all controllers exist outside the bounds, an Out of Bounds message displays on the volume’s toolbar.\n\nFor each tracked accessory, the app generates a tennis ball entity, and repositions it while handling accessory-tracking anchor updates. The transform of [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryAnchor] is relative to [doc:\/\/com.apple.documentation\/documentation\/Spatial\/WorldReferenceCoordinateSpace]. The app contains the tennis ball model within a `RealityView`, in a volume, unaligned with the world reference coordinate space. It’s a complex process to convert the tracked accessory position to the placement of the tennis ball. The sample determines whether the accessory is inside the volume using the anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryAnchor\/coordinateSpace(for:correction:)] method to eliminate the complexity. The tennis ball entity doesn’t render when the accessories move outside the volume.\n\n### Create throw and reset gestures\n\nDuring anchor update processing, the sample handles the tennis ball throw and shake to reset action checking. The app triggers a throw by tracking the peak velocity of the accessory, and determining when the current velocity decreases by 0.6 m\/s. The app provides the accessory’s velocity as a 3D vector in the accessory anchor’s local coordinate space. To obtain the correct velocity, the app transforms the vector relative to the `gameRoot` coordinate space with the `convert(value:, to:)` method. To strike the cans, the ball associated with the tossing accessory anchor sustains a velocity matching that of the anchor. If the system doesn’t register a throw within 1 second, it resets the throw tracking.\n\nThe app triggers a reset by rotating the accessory quickly clockwise and counterclockwise around the z-axis. The anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryAnchor\/angularVelocity] property provides the current rate of rotation.\n\nChecking for positive and negative angular velocities of 90 deg\/s, the sample increases the shake count on each change of direction.\n\nIf the shake direction changes six times, the app performs the action and resets the cans into a stack, ready for the next game.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/tracking-accessories-in-volumetric-windows\ncrawled: 2025-12-02T15:27:10Z\n---\n\n# Tracking accessories in volumetric windows\n\n**Sample Code**\n\nTranslate the position and velocity of tracked handheld accessories to throw virtual balls at a stack of cans.\n\n## Overview\n\nAccessories enhance the experience of Apple Vision Pro, and offer added functionality and flexibility by supporting fine control, novel input methods, and custom experiences. You can use ARKit to locate and track accessories, converting their real-world motion into app-accessible data. Specifically, ARKit supports high-frequency tracking of an accessory’s position and orientation, which it derives velocity and angular velocity information from. Additionally, ARKit provides methods to convert the real-world tracking information to the relevant coordinate spaces in your app.\n\n\n\n\n\nSome experiences may require accessories, but most let people perform tasks with both controllers and hands.\n\nThis sample code project creates a carnival-like experience with a set of stacked cans in a crate. The cans have physics bodies and are subject to gravity, causing them to fall when a thrown tennis ball strikes them. The crate fills the volume that contains it, and the app tracks accessories when it locates them within the volume. The sample uses tracking information to place a virtual tennis ball model over an onscreen accessory. A quick, tossing motion throws the ball, knocking down the cans, and a rapid set of clockwise and counterclockwise rotations sets them up again.\n\n### Set up the sample\n\nThe sample adds an [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSAccessoryTrackingUsageDescription] to the information property list file with a description of how the app uses the tracking information. Additionally, a [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/GCSupportedGameControllers] entry with a `SpatialGamepad` type is required for the  [doc:\/\/com.apple.documentation\/documentation\/GameController] framework to return controllers when requested. To track the controllers, the app needs to listen for accessories the system adds and removes by observing the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/GCControllerDidConnect] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/GCControllerDidDisconnect] notifications of the GameController framework.\n\nThe notification object is the `GCController` that’s changing connection state. The sample first checks [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider\/isSupported] to determine if accessory tracking is available. If so, the app monitors session events to update the internal state based on the data provider state.\n\n\n\n```swift\n    if !AccessoryTrackingProvider.isSupported {\n        state = .accessoryTrackingNotSupported\n        return\n    }\n    \n    \/\/ Listen for connected and disconnected controllers.\n    NotificationCenter.default.addObserver(forName: NSNotification.Name.GCControllerDidConnect,\n                                           object: nil,\n                                           queue: nil) { notification in\n        if let controller = notification.object as? GCController {\n            guard controller.productCategory == GCProductCategorySpatialController else {\n                return\n            }\n            \n            \/\/...\n        }\n    }\n    \n    NotificationCenter.default.addObserver(forName: NSNotification.Name.GCControllerDidDisconnect,\n                                           object: nil,\n                                           queue: nil) { notification in\n        if let controller = notification.object as? GCController {\n            if controller.productCategory == GCProductCategorySpatialController {\n                \/\/...\n            }\n        }\n    }\n```\n\nAn [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARKitSession] running [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider] implicitly requests authorization. Your app can handle this with an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARKitSession\/Event\/authorizationChanged(type:status:)] session event. If the player authorizes the tracking, the code in the `authorizationChanged` handler starts controller tracking.\n\n```swift\nprivate func monitorARKitSessionEvents() async {\n    for await event in arkitSession.events {\n        switch event {\n            case .dataProviderStateChanged(_, let newState, let error):\n                if newState == .stopped {\n                    if let error {\n                        print(\"An error occurred: \\(error)\")\n                        state = .arkitSessionError\n                    }\n                }\n        case .authorizationChanged(let type, let authorizationStatus):\n            if type == .accessoryTracking {\n                if authorizationStatus == .denied {\n                    state = .accessoryTrackingNotAuthorized\n                } else if authorizationStatus == .allowed {\n                    state = .startingUp\n                    \/\/ ...\n                }\n            }\n        default:\n            break\n        }\n    }\n}\n```\n\n### Track accessories\n\nWithin its tracking code, the sample requests all available controllers with [doc:\/\/com.apple.documentation\/documentation\/GameController\/GCController\/controllers()]. Create a trackable ARKit [doc:\/\/com.apple.arkit\/documentation\/ARKit\/Accessory] object from the returned [doc:\/\/com.apple.documentation\/documentation\/GameController\/GCController] device. Passing the available accessories to the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider] allows the sample to access [doc:\/\/com.apple.documentation\/documentation\/ARKit\/Anchor] updates when running in an [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSession] object. Accessory events are available asynchronously from [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryTrackingProvider\/anchorUpdates]. During tracking, the sample performs several operations — verifying the controllers presence within the volume, syncing the tennis ball position with the controllers, and checking for the player performing a throw or shake action.\n\n```swift\nlet accessoryTracking = AccessoryTrackingProvider(accessories: accessories)\n\ndo {\n    try await arkitSession.run([accessoryTracking])\n    state = .inGame\n    gameState = .startNewGame\n} catch {\n    return\n}\n\nfor await update in accessoryTracking.anchorUpdates {\n    process(update)\n}\n```\n\nThe system uses the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView] update closure to verify that the controllers are located within the volume, and the sample generates a bounding box that the volume determines. If at least one controller is connected and located within the volume bounds, the app state updates accordingly. If all controllers exist outside the bounds, an Out of Bounds message displays on the volume’s toolbar.\n\nFor each tracked accessory, the app generates a tennis ball entity, and repositions it while handling accessory-tracking anchor updates. The transform of [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryAnchor] is relative to [doc:\/\/com.apple.documentation\/documentation\/Spatial\/WorldReferenceCoordinateSpace]. The app contains the tennis ball model within a `RealityView`, in a volume, unaligned with the world reference coordinate space. It’s a complex process to convert the tracked accessory position to the placement of the tennis ball. The sample determines whether the accessory is inside the volume using the anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryAnchor\/coordinateSpace(for:correction:)] method to eliminate the complexity. The tennis ball entity doesn’t render when the accessories move outside the volume.\n\n```swift\nlet aimPoint = controllerAnchor.coordinateSpace(for: .aim, correction: .rendered)\n\nif let realityViewFromAimPointTransform = try? realityViewOrigin.transform(from: aimPoint) {\n    let aimPointPosition = realityViewFromAimPointTransform.matrix.columns.3.xyz\n    isInsideRealityView = realityViewEdges.contains(aimPointPosition)\n}\n```\n\n### Create throw and reset gestures\n\nDuring anchor update processing, the sample handles the tennis ball throw and shake to reset action checking. The app triggers a throw by tracking the peak velocity of the accessory, and determining when the current velocity decreases by 0.6 m\/s. The app provides the accessory’s velocity as a 3D vector in the accessory anchor’s local coordinate space. To obtain the correct velocity, the app transforms the vector relative to the `gameRoot` coordinate space with the `convert(value:, to:)` method. To strike the cans, the ball associated with the tossing accessory anchor sustains a velocity matching that of the anchor. If the system doesn’t register a throw within 1 second, it resets the throw tracking.\n\n```swift\nguard let anchor = controller.anchor else { return }\n\nlet controllerSpeed = length(anchor.velocity)\ncontroller.pendingThrow.peakSpeed = max(controller.pendingThrow.peakSpeed, controllerSpeed)\n\nif controller.pendingThrow.peakSpeed > 1.2 &&\n    controllerSpeed < controller.pendingThrow.peakSpeed - 0.6 {\n    \/\/ Trigger a throw if:\n    \/\/ The controller's peak speed is more than 1.2 m\/s.\n    \/\/ The controller's speed drops more than 0.6 m\/s below the peak.\n    if controller.triggeredThrow == nil {\n        controller.pendingThrow.anchor = anchor\n        \n        controller.triggeredThrow = controller.pendingThrow\n        controller.pendingThrow = Throw()\n        \n        Task {\n            \/\/ Allow the next throw after 1 second.\n            try? await Task.sleep(for: .milliseconds(1000))\n            controller.triggeredThrow = nil\n        }\n    }\n}\n```\n\nThe app triggers a reset by rotating the accessory quickly clockwise and counterclockwise around the z-axis. The anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/AccessoryAnchor\/angularVelocity] property provides the current rate of rotation.\n\n```swift\nguard let anchor = controller.anchor else { return }\n\nlet controllerZAngularVelocity = anchor.angularVelocity[2]\ncontroller.pendingShake.peakAngularVelocity = max(controller.pendingShake.peakAngularVelocity, controllerZAngularVelocity)\n```\n\nChecking for positive and negative angular velocities of 90 deg\/s, the sample increases the shake count on each change of direction.\n\n```swift\nlet halfPi: Float = .pi \/ 2\n\nif controllerZAngularVelocity < controller.pendingShake.peakAngularVelocity - halfPi &&\n    abs(anchor.angularVelocity[0]) < halfPi && abs(anchor.angularVelocity[1]) < halfPi {\n    \/\/ Detect a controller oscillation on the z-axis if:\n    \/\/ The controller's angular velocity on the z-axis drops more than 90 deg\/s below the peak angular velocity.\n    \/\/ The controller's angular velocity on the other axes is less than 90 deg\/s.\n    let controllerPosition: SIMD3<Float> = anchor.originFromAnchorTransform.columns.3.xyz\n    \n    \/\/ Reset the shake if the user moves too much.\n    if let shakePrevPos = controller.pendingShake.initialPosition {\n        guard length(controllerPosition - shakePrevPos) < 0.2 else {\n            controller.pendingShake = Shake()\n            return\n        }\n    }\n    \n    if controllerZAngularVelocity < -halfPi {\n        if controller.pendingShake.currentDirection == .counterClockwise {\n            controller.pendingShake.oscillationCount += 1\n        }\n        controller.pendingShake.currentDirection = .clockwise\n    } else if controllerZAngularVelocity > halfPi {\n        if controller.pendingShake.currentDirection == .clockwise {\n            controller.pendingShake.oscillationCount += 1\n        }\n        controller.pendingShake.currentDirection = .counterClockwise\n    }\n    \n    if controller.pendingShake.oscillationCount == 1 {\n        controller.pendingShake.initialPosition = controllerPosition\n    }\n```\n\nIf the shake direction changes six times, the app performs the action and resets the cans into a stack, ready for the next game.\n\n```swift\n    if controller.triggeredShake == nil && controller.pendingShake.oscillationCount >= 6 {\n        controller.triggeredShake = controller.pendingShake\n        controller.pendingShake = Shake()\n        \n        gameState = .startNewGame\n        \n        Task {\n            \/\/ Reset the triggered shake after 0.5 seconds.\n            try? await Task.sleep(for: .milliseconds(500))\n            controller.triggeredShake = nil\n        }\n    }\n```\n\n## Accessory tracking\n\n- **AccessoryTrackingProvider**: Provides the real time position of accessories in the user’s environment.\n- **Accessory**: Represents an accessory to be tracked.\n- **AccessoryAnchor**: Represents a tracked accessory.\n- **Tracking a handheld accessory as a virtual sculpting tool**: Use a tracked accessory with Apple Vision Pro to create a virtual sculpture.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Provides the real time position of accessories in the user’s environment.",
          "name" : "AccessoryTrackingProvider",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/AccessoryTrackingProvider"
        },
        {
          "description" : "Represents an accessory to be tracked.",
          "name" : "Accessory",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/Accessory"
        },
        {
          "description" : "Represents a tracked accessory.",
          "name" : "AccessoryAnchor",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/AccessoryAnchor"
        },
        {
          "description" : "Use a tracked accessory with Apple Vision Pro to create a virtual sculpture.",
          "name" : "Tracking a handheld accessory as a virtual sculpting tool",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/tracking-a-handheld-accessory-as-a-virtual-sculpting-tool"
        }
      ],
      "title" : "Accessory tracking"
    }
  ],
  "source" : "appleJSON",
  "title" : "Tracking accessories in volumetric windows",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/tracking-accessories-in-volumetric-windows"
}