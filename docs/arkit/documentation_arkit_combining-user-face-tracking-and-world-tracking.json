{
  "abstract" : "Track the user’s face in an app that displays an AR experience with the rear camera.",
  "codeExamples" : [
    {
      "code" : "guard ARWorldTrackingConfiguration.supportsUserFaceTracking else {\n    \/\/swiftlint:disable:next line_length\n    fatalError(\"This sample code requires iOS 13 \/ iPad OS 13, and an iOS device with a front TrueDepth camera. Note: 2020 iPads do not support user face-tracking while world tracking.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "configuration.userFaceTrackingEnabled = true",
      "language" : "swift"
    },
    {
      "code" : "override func viewWillAppear(_ animated: Bool) {\n    super.viewWillAppear(animated)\n    arView.session.run(configuration)\n}",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: ARSession, didUpdate frame: ARFrame) {\n    if headPreview == nil, case .normal = frame.camera.trackingState {\n        addHeadPreview()\n    }\n    \/\/...",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: ARSession, didUpdate anchors: [ARAnchor]) {\n    anchors.compactMap { $0 as? ARFaceAnchor }.forEach { headPreview?.update(with: $0) }\n}",
      "language" : "swift"
    },
    {
      "code" : "let blendShapes = faceAnchor.blendShapes",
      "language" : "swift"
    },
    {
      "code" : "guard let eyeBlinkLeft = blendShapes[.eyeBlinkLeft] as? Float,\n    let eyeBlinkRight = blendShapes[.eyeBlinkRight] as? Float,\n    let eyeBrowLeft = blendShapes[.browOuterUpLeft] as? Float,\n    let eyeBrowRight = blendShapes[.browOuterUpRight] as? Float,\n    let jawOpen = blendShapes[.jawOpen] as? Float,\n    let upperLip = blendShapes[.mouthUpperUpLeft] as? Float,\n    let tongueOut = blendShapes[.tongueOut] as? Float\n    else { return }",
      "language" : "swift"
    },
    {
      "code" : "eyebrowLeftEntity.position.y = originalEyebrowY + 0.03 * eyeBrowLeft\neyebrowRightEntity.position.y = originalEyebrowY + 0.03 * eyeBrowRight\ntongueEntity.position.z = 0.1 * tongueOut\njawEntity.position.y = originalJawY - jawHeight * jawOpen\nupperLipEntity.position.y = originalUpperLipY + 0.05 * upperLip",
      "language" : "swift"
    },
    {
      "code" : "eyeLeftEntity.scale.z = 1 - eyeBlinkLeft\neyeRightEntity.scale.z = 1 - eyeBlinkRight",
      "language" : "swift"
    },
    {
      "code" : "let camera = AnchorEntity(.camera)\narView.scene.addAnchor(camera)\n\n\/\/ Attach a robot head to the camera anchor.\nlet robotHead = RobotHead()\ncamera.addChild(robotHead)",
      "language" : "swift"
    },
    {
      "code" : "let cameraTransform = parent.transformMatrix(relativeTo: nil)\nlet faceTransformFromCamera = simd_mul(simd_inverse(cameraTransform), faceAnchor.transform)\nself.position.z = -faceTransformFromCamera.columns.3.z",
      "language" : "swift"
    },
    {
      "code" : "let rotationEulers = faceTransformFromCamera.eulerAngles",
      "language" : "swift"
    },
    {
      "code" : "let mirroredRotation = Transform(pitch: rotationEulers.x, yaw: -rotationEulers.y + .pi, roll: rotationEulers.z)",
      "language" : "swift"
    },
    {
      "code" : "self.orientation = mirroredRotation.rotation",
      "language" : "swift"
    },
    {
      "code" : "@objc\nfunc handleTap(recognizer: UITapGestureRecognizer) {\n    guard let robotHeadPreview = headPreview, robotHeadPreview.isEnabled, robotHeadPreview.appearance == .tracked else {\n        return\n    }\n    let headWorldTransform = robotHeadPreview.transformMatrix(relativeTo: nil)\n    robotHeadPreview.anchor?.reanchor(.world(transform: headWorldTransform))\n    robotHeadPreview.appearance = .anchored\n    \/\/ ...",
      "language" : "swift"
    },
    {
      "code" : "self.headPreview = nil",
      "language" : "swift"
    },
    {
      "code" : "func session(_ session: ARSession, didUpdate frame: ARFrame) {\n    if headPreview == nil, case .normal = frame.camera.trackingState {\n        addHeadPreview()\n    }",
      "language" : "swift"
    }
  ],
  "contentHash" : "9e89f70fc9287adfe302bbb66eace6d531092e8ff7ce24fffd73b91320b14f82",
  "crawledAt" : "2025-12-02T15:47:19Z",
  "id" : "3DCD5859-3C85-4622-97DE-56B766AD7E1D",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ARKit",
  "overview" : "## Overview\n\nWhen tracking users’ faces in a world-tracking session, ARKit incorporates information from both the front and rear camera feeds in the AR experience. In addition to tracking the physical environment using the rear camera, ARKit uses the front camera to deliver an anchor that provides the position and expression of the user’s face.\n\nTo demonstrate applying the user’s face while world-tracking, this sample app lets the user place robot heads that reflect the user’s facial expression.\n\n\n\n## Configure and start the session\n\nThis app tracks the user’s face in a world-tracking session on iOS 13 and iPad OS 13 or later, on devices with a front TrueDepth camera that return `true` to [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/supportsUserFaceTracking]. To prevent the app from running an unsupported configuration, check whether the iOS device supports simultaneous world and user face-tracking.\n\nIf the device running the app doesn’t support user face-tracking in a world-tracking session, the sample project will stop. In your app, consider gracefully degrading the AR experience in this case, such as by presenting the user with an error message and continuing the experience without it.\n\nThe sample app sets the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/userFaceTrackingEnabled] property to `true` on the world-tracking configuration when app loads the view controller.\n\nThe sample app then starts the session by running the configuration when the view controller is about to appear onscreen.\n\n## Preview virtual content in the physical environment\n\nThe app checks whether a robot head preview exists and creates one if not. ARKit calls the implementation of [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didUpdate:)-9v2kw] every frame, which makes it a good location for a periodic check.\n\n## Detect changes in the user’s expression\n\nARKit provides the app with an updated anchor when the user changes their expression, position, or orientation with respect to the world. If there’s an active robot head preview, the app applies these changes to the head.\n\n## Inspect expression information\n\nIn the robot head’s `update(with faceAnchor:)` function, the app reads the user’s current expression by interpreting the anchor’s *blend shapes*.\n\nBlend shapes are `Float` values normalized within the range `[0..1]`, with `0` representing the facial feature’s rest position, and `1` representing the opposite––the feature in its most pronounced state. To begin processing the values, the app stores them locally by accessing the anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFaceAnchor\/blendShapes] array.\n\n## React to the user’s expression\n\nBlend shape values can apply in unique ways depending on an app’s requirements. The sample app uses blend shapes to make the robot head appear to mimic the user’s expression, such as applying the brow and lip values to offset the robot’s brow and lip positions.\n\nThe entity for the robot’s eye opens or closes when the sample app applies the corresponding blend shape value as a scale factor.\n\n## Position the robot head\n\nIn addition to capturing the user’s expression using the front camera, ARKit records the position of the user’s face with respect to the world. By design, the user’s face anchor is always located behind the rear camera. To serve the goal of mimicking the user with the robot head, the sample app applies the face anchor’s position to make the robot head always visible. First, it sets the robot head’s initial position equal to that of the camera.\n\nThen the app offsets its z-position in the same amount as the camera’s distance from the user’s face.\n\n## Orient the robot head\n\nThe sample app also uses the anchor’s orientation to direct the front of the robot’s head continually toward the camera. It starts by accessing the anchor’s orientation.\n\nThen it adds `pi` to the `y`-Euler angle to turn it on the y-axis.\n\nTo effect the change, the app applies the updated Euler angles to the robot head’s orientation.\n\n## Capture the expression by placing the head\n\nTo demonstrate the variety of expressions tracked during the session, the sample app places the robot head in the physical environment when the user taps the screen. When the app initially previews the expressions, it positions the robot head at a fixed offset from the camera. When the user taps the screen, the app reanchors the robot head by updating its position to its current world location.\n\nSetting the `headPreview` to `nil` prevents the app from updating the facial expression `session(didUpdate anchors:)`, which freezes that expression on the placed robot head.\n\nWhen ARKit calls `session(didUpdate frame:)` again, the app checks whether a robot head preview exists, and creates one if not.\n\nWhen the app sets `headPreview` to `nil`, it creates another robot head preview, continuing the user’s ability to place objects and archive additional facial expressions.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ARKit\/combining-user-face-tracking-and-world-tracking\ncrawled: 2025-12-02T15:47:19Z\n---\n\n# Combining user face-tracking and world tracking\n\n**Sample Code**\n\nTrack the user’s face in an app that displays an AR experience with the rear camera.\n\n## Overview\n\nWhen tracking users’ faces in a world-tracking session, ARKit incorporates information from both the front and rear camera feeds in the AR experience. In addition to tracking the physical environment using the rear camera, ARKit uses the front camera to deliver an anchor that provides the position and expression of the user’s face.\n\nTo demonstrate applying the user’s face while world-tracking, this sample app lets the user place robot heads that reflect the user’s facial expression.\n\n\n\n## Configure and start the session\n\nThis app tracks the user’s face in a world-tracking session on iOS 13 and iPad OS 13 or later, on devices with a front TrueDepth camera that return `true` to [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/supportsUserFaceTracking]. To prevent the app from running an unsupported configuration, check whether the iOS device supports simultaneous world and user face-tracking.\n\n```swift\nguard ARWorldTrackingConfiguration.supportsUserFaceTracking else {\n    \/\/swiftlint:disable:next line_length\n    fatalError(\"This sample code requires iOS 13 \/ iPad OS 13, and an iOS device with a front TrueDepth camera. Note: 2020 iPads do not support user face-tracking while world tracking.\")\n}\n```\n\nIf the device running the app doesn’t support user face-tracking in a world-tracking session, the sample project will stop. In your app, consider gracefully degrading the AR experience in this case, such as by presenting the user with an error message and continuing the experience without it.\n\nThe sample app sets the [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARWorldTrackingConfiguration\/userFaceTrackingEnabled] property to `true` on the world-tracking configuration when app loads the view controller.\n\n```swift\nconfiguration.userFaceTrackingEnabled = true\n```\n\nThe sample app then starts the session by running the configuration when the view controller is about to appear onscreen.\n\n```swift\noverride func viewWillAppear(_ animated: Bool) {\n    super.viewWillAppear(animated)\n    arView.session.run(configuration)\n}\n```\n\n## Preview virtual content in the physical environment\n\nThe app checks whether a robot head preview exists and creates one if not. ARKit calls the implementation of [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARSessionDelegate\/session(_:didUpdate:)-9v2kw] every frame, which makes it a good location for a periodic check.\n\n```swift\nfunc session(_ session: ARSession, didUpdate frame: ARFrame) {\n    if headPreview == nil, case .normal = frame.camera.trackingState {\n        addHeadPreview()\n    }\n    \/\/...\n```\n\n## Detect changes in the user’s expression\n\nARKit provides the app with an updated anchor when the user changes their expression, position, or orientation with respect to the world. If there’s an active robot head preview, the app applies these changes to the head.\n\n```swift\nfunc session(_ session: ARSession, didUpdate anchors: [ARAnchor]) {\n    anchors.compactMap { $0 as? ARFaceAnchor }.forEach { headPreview?.update(with: $0) }\n}\n```\n\n## Inspect expression information\n\nIn the robot head’s `update(with faceAnchor:)` function, the app reads the user’s current expression by interpreting the anchor’s *blend shapes*.\n\n```swift\nlet blendShapes = faceAnchor.blendShapes\n```\n\nBlend shapes are `Float` values normalized within the range `[0..1]`, with `0` representing the facial feature’s rest position, and `1` representing the opposite––the feature in its most pronounced state. To begin processing the values, the app stores them locally by accessing the anchor’s [doc:\/\/com.apple.arkit\/documentation\/ARKit\/ARFaceAnchor\/blendShapes] array.\n\n```swift\nguard let eyeBlinkLeft = blendShapes[.eyeBlinkLeft] as? Float,\n    let eyeBlinkRight = blendShapes[.eyeBlinkRight] as? Float,\n    let eyeBrowLeft = blendShapes[.browOuterUpLeft] as? Float,\n    let eyeBrowRight = blendShapes[.browOuterUpRight] as? Float,\n    let jawOpen = blendShapes[.jawOpen] as? Float,\n    let upperLip = blendShapes[.mouthUpperUpLeft] as? Float,\n    let tongueOut = blendShapes[.tongueOut] as? Float\n    else { return }\n```\n\n## React to the user’s expression\n\nBlend shape values can apply in unique ways depending on an app’s requirements. The sample app uses blend shapes to make the robot head appear to mimic the user’s expression, such as applying the brow and lip values to offset the robot’s brow and lip positions.\n\n```swift\neyebrowLeftEntity.position.y = originalEyebrowY + 0.03 * eyeBrowLeft\neyebrowRightEntity.position.y = originalEyebrowY + 0.03 * eyeBrowRight\ntongueEntity.position.z = 0.1 * tongueOut\njawEntity.position.y = originalJawY - jawHeight * jawOpen\nupperLipEntity.position.y = originalUpperLipY + 0.05 * upperLip\n```\n\nThe entity for the robot’s eye opens or closes when the sample app applies the corresponding blend shape value as a scale factor.\n\n```swift\neyeLeftEntity.scale.z = 1 - eyeBlinkLeft\neyeRightEntity.scale.z = 1 - eyeBlinkRight\n```\n\n## Position the robot head\n\nIn addition to capturing the user’s expression using the front camera, ARKit records the position of the user’s face with respect to the world. By design, the user’s face anchor is always located behind the rear camera. To serve the goal of mimicking the user with the robot head, the sample app applies the face anchor’s position to make the robot head always visible. First, it sets the robot head’s initial position equal to that of the camera.\n\n```swift\nlet camera = AnchorEntity(.camera)\narView.scene.addAnchor(camera)\n\n\/\/ Attach a robot head to the camera anchor.\nlet robotHead = RobotHead()\ncamera.addChild(robotHead)\n```\n\nThen the app offsets its z-position in the same amount as the camera’s distance from the user’s face.\n\n```swift\nlet cameraTransform = parent.transformMatrix(relativeTo: nil)\nlet faceTransformFromCamera = simd_mul(simd_inverse(cameraTransform), faceAnchor.transform)\nself.position.z = -faceTransformFromCamera.columns.3.z\n```\n\n## Orient the robot head\n\nThe sample app also uses the anchor’s orientation to direct the front of the robot’s head continually toward the camera. It starts by accessing the anchor’s orientation.\n\n```swift\nlet rotationEulers = faceTransformFromCamera.eulerAngles\n```\n\nThen it adds `pi` to the `y`-Euler angle to turn it on the y-axis.\n\n```swift\nlet mirroredRotation = Transform(pitch: rotationEulers.x, yaw: -rotationEulers.y + .pi, roll: rotationEulers.z)\n```\n\nTo effect the change, the app applies the updated Euler angles to the robot head’s orientation.\n\n```swift\nself.orientation = mirroredRotation.rotation\n```\n\n## Capture the expression by placing the head\n\nTo demonstrate the variety of expressions tracked during the session, the sample app places the robot head in the physical environment when the user taps the screen. When the app initially previews the expressions, it positions the robot head at a fixed offset from the camera. When the user taps the screen, the app reanchors the robot head by updating its position to its current world location.\n\n```swift\n@objc\nfunc handleTap(recognizer: UITapGestureRecognizer) {\n    guard let robotHeadPreview = headPreview, robotHeadPreview.isEnabled, robotHeadPreview.appearance == .tracked else {\n        return\n    }\n    let headWorldTransform = robotHeadPreview.transformMatrix(relativeTo: nil)\n    robotHeadPreview.anchor?.reanchor(.world(transform: headWorldTransform))\n    robotHeadPreview.appearance = .anchored\n    \/\/ ...\n```\n\nSetting the `headPreview` to `nil` prevents the app from updating the facial expression `session(didUpdate anchors:)`, which freezes that expression on the placed robot head.\n\n```swift\nself.headPreview = nil\n```\n\nWhen ARKit calls `session(didUpdate frame:)` again, the app checks whether a robot head preview exists, and creates one if not.\n\n```swift\nfunc session(_ session: ARSession, didUpdate frame: ARFrame) {\n    if headPreview == nil, case .normal = frame.camera.trackingState {\n        addHeadPreview()\n    }\n```\n\nWhen the app sets `headPreview` to `nil`, it creates another robot head preview, continuing the user’s ability to place objects and archive additional facial expressions.\n\n\n\n## Face Tracking\n\n- **Tracking and visualizing faces**: Detect faces in a front-camera AR experience, overlay virtual content, and animate facial expressions in real-time.\n- **ARFaceAnchor**: An anchor for a unique face that is visible in the front-facing camera.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Detect faces in a front-camera AR experience, overlay virtual content, and animate facial expressions in real-time.",
          "name" : "Tracking and visualizing faces",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/tracking-and-visualizing-faces"
        },
        {
          "description" : "An anchor for a unique face that is visible in the front-facing camera.",
          "name" : "ARFaceAnchor",
          "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/ARFaceAnchor"
        }
      ],
      "title" : "Face Tracking"
    }
  ],
  "source" : "appleJSON",
  "title" : "Combining user face-tracking and world tracking",
  "url" : "https:\/\/developer.apple.com\/documentation\/ARKit\/combining-user-face-tracking-and-world-tracking"
}