{
  "abstract" : "Switch dynamically between multiple GPUs to efficiently render to a display.",
  "codeExamples" : [
    {
      "code" : "\/\/ Get the display ID of the display in which the view appears\nCGDirectDisplayID viewDisplayID = (CGDirectDisplayID) [_view.window.screen.deviceDescription[@\"NSScreenNumber\"] unsignedIntegerValue];\n\n\/\/ Get the Metal device that drives the display\nid<MTLDevice> newPreferredDevice = CGDirectDisplayCopyCurrentMetalDevice(viewDisplayID);",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Register for the NSApplicationDidChangeScreenParametersNotification, which triggers\n\/\/ when the system's display configuration changes\n[[NSNotificationCenter defaultCenter] addObserver:self\n                                         selector:@selector(handleScreenChanges:)\n                                             name:NSApplicationDidChangeScreenParametersNotification\n                                           object:nil];\n\n\/\/ Register for the NSWindowDidChangeScreenNotification, which triggers when the window\n\/\/ changes screens\n[[NSNotificationCenter defaultCenter] addObserver:self\n                                         selector:@selector(handleScreenChanges:)\n                                             name:NSWindowDidChangeScreenNotification\n                                           object:nil];",
      "language" : "objective-c"
    },
    {
      "code" : "MTLDeviceNotificationHandler notificationHandler;\n\nAAPLViewController * __weak controller = self;\nnotificationHandler = ^(id<MTLDevice> device, MTLDeviceNotificationName name)\n{\n    [controller markHotPlugNotificationForDevice:device name:name];\n};\n\n\/\/ Query all supported metal devices with an observer, so the app can receive notifications\n\/\/ when external GPUs are added to or removed from the system\nid<NSObject> metalDeviceObserver = nil;\nNSArray<id<MTLDevice>> * availableDevices =\n    MTLCopyAllDevicesWithObserver(&metalDeviceObserver,\n                                  notificationHandler);",
      "language" : "objective-c"
    },
    {
      "code" : "- (void)markHotPlugNotificationForDevice:(nonnull id<MTLDevice>)device\n                                    name:(nonnull MTLDeviceNotificationName)name\n{\n    @synchronized(self)\n    {\n        if ([name isEqualToString:MTLDeviceWasAddedNotification])\n        {\n            _hotPlugEvent = AAPLHotPlugEventDeviceAdded;\n        }\n        else if ([name isEqualToString:MTLDeviceRemovalRequestedNotification])\n        {\n            _hotPlugEvent = AAPLHotPlugEventDeviceEjected;\n        }\n        else if ([name isEqualToString:MTLDeviceWasRemovedNotification])\n        {\n            _hotPlugEvent = AAPLHotPlugEventDevicePulled;\n        }\n\n        _hotPlugDevice = device;\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "- (void)handlePossibleHotPlugEvent\n{\n    AAPLHotPlugEvent hotPlugEvent;\n    id<MTLDevice> hotPlugDevice;\n\n    @synchronized(self)\n    {\n        hotPlugEvent = _hotPlugEvent;\n        hotPlugDevice = _hotPlugDevice;\n        _hotPlugDevice = nil;\n    }\n\n    if(hotPlugDevice)\n    {\n        switch (hotPlugEvent)\n        {\n            case AAPLHotPlugEventDeviceAdded:\n                [self handleMTLDeviceAddedNotification:hotPlugDevice];\n                break;\n            case AAPLHotPlugEventDeviceEjected:\n            case AAPLHotPlugEventDevicePulled:\n                [self handleMTLDeviceRemovalNotification:hotPlugDevice];\n                break;\n        }\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "- (void)viewDidDisappear\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self\n                                                    name:NSApplicationDidChangeScreenParametersNotification\n                                                  object:nil];\n\n    [[NSNotificationCenter defaultCenter] removeObserver:self\n                                                    name:NSWindowDidChangeScreenNotification\n                                                  object:nil];\n\n    MTLRemoveDeviceObserver(_metalDeviceObserver);\n}",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "19149290be1eea4bafa19be684b5ed9232e748a2278fc322b66c96ac56a20dda",
  "crawledAt" : "2025-12-02T15:49:42Z",
  "id" : "D162126D-77E5-4513-8810-FB891B4CA268",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nmacOS supports systems that have multiple GPUs and displays. An example is a MacBook Pro with a low-power integrated GPU, a high-performance discrete GPU, a powerful external GPU, and additional displays. Metal apps need to carefully select a GPU that maximizes efficiency and performance for a given display. They should also gracefully respond to any GPU or display changes, such as when the user disconnects an external GPU or moves a window between displays.\n\n### Getting started\n\nNot all Mac computers have both an integrated GPU and a discrete GPU. To check the GPUs in your Mac, choose Apple menu > About this Mac, press the System Report button, and select Graphics\/Displays on the left. The GPUs are listed under Video Card. MacBook Pro computers with two GPUs have an Automatic Graphics Switching option, turned on by default, that allows the system to automatically switch between the two GPUs. To toggle the Automatic Graphics Switching state, choose Apple menu > System Preferences and click Energy Saver. The Automatic Graphics Switching checkbox is shown at the top.\n\nOptionally, you may connect an external GPU to your Mac via Thunderbolt 3, and you may also connect an external display to your external GPU. For this system setup, your Mac needs to be running macOS 10.13.4 or later. Connecting an external GPU allows the sample to run the code described in Handle External GPU Notifications.\n\nThe sample provides these interactive UI controls:\n\nFurthermore, the Device Driving Display label indicates which device is currently driving the display.\n\n### Drawables, displays, and GPUs\n\nEach view in your app is shown on a single display, and each display is driven by a single GPU. To show graphics content in your view, the view’s display presents a rendered drawable from the display’s driving GPU.\n\nIf your app renders with a GPU that isn’t driving your view’s display, the system needs to copy the drawable from the rendering GPU to the displaying GPU before presenting it. This transfer can be expensive because the bandwidth between GPUs is limited by the bus that connects them. This expense is more severe with external GPUs because their Thunderbolt 3 bus has much less bandwidth than an internal PCI Express bus.\n\nThe fastest path to present a drawable is to render that drawable with the GPU that drives your view’s display. An example is a MacBook Pro with a discrete GPU and an integrated GPU, where the integrated GPU can drive the built-in display under certain conditions, such as thermal state, battery life, or an app’s needs.\n\n\n\nAnother example is a Mac connected to an external GPU, where the external GPU drives an external display.\n\n\n\n### Transition smoothly between devices\n\nThe sample’s view controller manages all Metal devices, with each device representing a different GPU. When the sample runs the `viewDidLoad` method, the view controller initializes a new `AAPLRenderer` for each device available to the system. The sample uses only one device at a time, but it initializes a renderer for each device in order to preload and mirror the app’s Metal resources across all devices. Therefore, when the app switches between GPUs at runtime, the sample  transitions smoothly between devices because equivalent resources are already available and loaded on each device. This preloading and mirroring strategy avoids significant delays that would otherwise exist if the sample needed to load resources at the time of the switch.\n\n### Set the optimal device for the view’s display\n\nAfter the view appears, the sample gets the `CGDirectDisplayID` value of the display in which the view appears. The sample uses this identifier to get the Metal device that drives the display.\n\nThe sample sets this device for the view controller’s `MTKView`, and chooses the `AAPLRenderer` associated with that same device to perform the app’s rendering.  This setup ensures that the system renders with the device that drives the display, and it avoids copying any drawables from one GPU to another.\n\n### Handle display change notifications\n\nTo keep up to date with the optimal device for the view’s display, the sample registers for two system notifications:\n\nIn both cases, the system calls the sample’s `handleScreenChanges:` method to handle the notification. The sample then chooses the optimal device for the view’s display by selecting the `AAPLRenderer` object that corresponds to the device driving the display.\n\n### Set a GPU eject policy\n\nBy default, macOS fully relaunches an app when an external GPU being used by the app is removed from the system. An app typically handles a relaunch by:\n\nThe sample avoids this app relaunch routine by instead opting in to handling the external GPU removal itself, without macOS needing to quit and relaunch the app. The sample’s `Info.plist` file has a `GPUEjectPolicy` key with a `wait` value, which indicates that the app explicitly handles the removal of an external GPU by responding to the corresponding notification posted by Metal.\n\n### Register for external GPU notifications\n\nThe sample calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCopyAllDevicesWithObserver] function to obtain all Metal devices available to the system. This method allows the sample to supply an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDeviceNotificationHandler] block that’s executed when an external GPU is added or removed from the system. This handler provides two arguments:\n\n### Respond to external GPU notifications\n\nThe notification handler can execute on any thread. However, all UI updates need to occur on the main thread and the app’s state changes need to be explicitly made thread-safe. To comply with these thread requirements, the view controller protects access to the `_hotPlugEvent` and `_hotPlugDevice` instance variables with a `@synchronized` directive. (The `@synchronized` directive is a convenient way to create mutex locks in Objective-C code.)\n\nThe sample sets these instance variables in the `markHotPlugNotificationForDevice:name:` method when a notification occurs.\n\nThe sample reads these instance variables on the main thread and handles the notification in the `handlePossibleHotPlugEvent` method.\n\nWhen a device that represents an external GPU is added to the system, the `handlePossibleHotPlugEvent` method adds the device to the `_supportedDevices` array and initializes a new `AAPLRenderer` for the device. When such a device is removed from the system, the same method removes the device from the `_supportedDevices` array and destroys its associated `AAPLRenderer`. If the removed device was being used for rendering, the sample switches to another device and renderer.\n\n### Update per-frame state and data\n\nMetalKit calls the [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] method for the sample to render each frame. Within this method, the sample calls the `handlePossibleHotPlugEvent` method to handle device additions or removals on the main thread. Such actions include updating UI related to these device events and completing any additional state changes that need to be executed atomically on a single thread.\n\nThe sample then calls the `drawFrameNumber:toView:` to begin rendering a new frame for the current renderer. To ensure continuous rendering that enables seamless switching between different renderers, the sample stores any nonrendering state separate from the renderers themselves. Then, for each frame, the sample passes any necessary nonrendering state to a specific `AAPLRenderer` instance. In this case, the sample passes the current frame number, `_frameNumber`, to the renderer so it can calculate the position and rotation of the sample’s 3D model.\n\n### Deregister from notifications\n\nAfter the view disappears, the sample explicitly deregisters itself from any previous display or device notifications. Otherwise, the system’s notification center and Metal can’t release the sample’s view controller.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-graphics-rendering\ncrawled: 2025-12-02T15:49:42Z\n---\n\n# Selecting device objects for graphics rendering\n\n**Sample Code**\n\nSwitch dynamically between multiple GPUs to efficiently render to a display.\n\n## Overview\n\nmacOS supports systems that have multiple GPUs and displays. An example is a MacBook Pro with a low-power integrated GPU, a high-performance discrete GPU, a powerful external GPU, and additional displays. Metal apps need to carefully select a GPU that maximizes efficiency and performance for a given display. They should also gracefully respond to any GPU or display changes, such as when the user disconnects an external GPU or moves a window between displays.\n\n### Getting started\n\nNot all Mac computers have both an integrated GPU and a discrete GPU. To check the GPUs in your Mac, choose Apple menu > About this Mac, press the System Report button, and select Graphics\/Displays on the left. The GPUs are listed under Video Card. MacBook Pro computers with two GPUs have an Automatic Graphics Switching option, turned on by default, that allows the system to automatically switch between the two GPUs. To toggle the Automatic Graphics Switching state, choose Apple menu > System Preferences and click Energy Saver. The Automatic Graphics Switching checkbox is shown at the top.\n\nOptionally, you may connect an external GPU to your Mac via Thunderbolt 3, and you may also connect an external display to your external GPU. For this system setup, your Mac needs to be running macOS 10.13.4 or later. Connecting an external GPU allows the sample to run the code described in Handle External GPU Notifications.\n\nThe sample provides these interactive UI controls:\n\n- **Device Selection Mode.** Allow the sample to automatically select the best device for the display, or indicate that you want to manually select a device.\n- **Manual Device Selection.** Manually select a device from a list of available devices.\n\nFurthermore, the Device Driving Display label indicates which device is currently driving the display.\n\n### Drawables, displays, and GPUs\n\nEach view in your app is shown on a single display, and each display is driven by a single GPU. To show graphics content in your view, the view’s display presents a rendered drawable from the display’s driving GPU.\n\nIf your app renders with a GPU that isn’t driving your view’s display, the system needs to copy the drawable from the rendering GPU to the displaying GPU before presenting it. This transfer can be expensive because the bandwidth between GPUs is limited by the bus that connects them. This expense is more severe with external GPUs because their Thunderbolt 3 bus has much less bandwidth than an internal PCI Express bus.\n\nThe fastest path to present a drawable is to render that drawable with the GPU that drives your view’s display. An example is a MacBook Pro with a discrete GPU and an integrated GPU, where the integrated GPU can drive the built-in display under certain conditions, such as thermal state, battery life, or an app’s needs.\n\n\n\nAnother example is a Mac connected to an external GPU, where the external GPU drives an external display.\n\n\n\n### Transition smoothly between devices\n\nThe sample’s view controller manages all Metal devices, with each device representing a different GPU. When the sample runs the `viewDidLoad` method, the view controller initializes a new `AAPLRenderer` for each device available to the system. The sample uses only one device at a time, but it initializes a renderer for each device in order to preload and mirror the app’s Metal resources across all devices. Therefore, when the app switches between GPUs at runtime, the sample  transitions smoothly between devices because equivalent resources are already available and loaded on each device. This preloading and mirroring strategy avoids significant delays that would otherwise exist if the sample needed to load resources at the time of the switch.\n\n\n\n### Set the optimal device for the view’s display\n\nAfter the view appears, the sample gets the `CGDirectDisplayID` value of the display in which the view appears. The sample uses this identifier to get the Metal device that drives the display.\n\n```objective-c\n\/\/ Get the display ID of the display in which the view appears\nCGDirectDisplayID viewDisplayID = (CGDirectDisplayID) [_view.window.screen.deviceDescription[@\"NSScreenNumber\"] unsignedIntegerValue];\n\n\/\/ Get the Metal device that drives the display\nid<MTLDevice> newPreferredDevice = CGDirectDisplayCopyCurrentMetalDevice(viewDisplayID);\n```\n\nThe sample sets this device for the view controller’s `MTKView`, and chooses the `AAPLRenderer` associated with that same device to perform the app’s rendering.  This setup ensures that the system renders with the device that drives the display, and it avoids copying any drawables from one GPU to another.\n\n### Handle display change notifications\n\nTo keep up to date with the optimal device for the view’s display, the sample registers for two system notifications:\n\n- `NSApplicationDidChangeScreenParametersNotification`. macOS posts this notification when a display configuration changes. An example is when the user connects or disconnects an external display from the system. Another example is when the GPU driving the display changes, such as when Automatic Graphics Switching is enabled and the system switches between discrete and integrated GPUs to drive the display.\n- `NSWindowDidChangeScreenNotification`. The system posts this notification when any window, including the window containing the app’s view, moves to a different display.\n\n```objective-c\n\/\/ Register for the NSApplicationDidChangeScreenParametersNotification, which triggers\n\/\/ when the system's display configuration changes\n[[NSNotificationCenter defaultCenter] addObserver:self\n                                         selector:@selector(handleScreenChanges:)\n                                             name:NSApplicationDidChangeScreenParametersNotification\n                                           object:nil];\n\n\/\/ Register for the NSWindowDidChangeScreenNotification, which triggers when the window\n\/\/ changes screens\n[[NSNotificationCenter defaultCenter] addObserver:self\n                                         selector:@selector(handleScreenChanges:)\n                                             name:NSWindowDidChangeScreenNotification\n                                           object:nil];\n```\n\nIn both cases, the system calls the sample’s `handleScreenChanges:` method to handle the notification. The sample then chooses the optimal device for the view’s display by selecting the `AAPLRenderer` object that corresponds to the device driving the display.\n\n### Set a GPU eject policy\n\nBy default, macOS fully relaunches an app when an external GPU being used by the app is removed from the system. An app typically handles a relaunch by:\n\n1. Saving as much state as possible when the system calls the app’s `application:willEncodeRestorableState:` method, before macOS quits the app.\n2. Restoring any saved state when the system calls the app’s `application:didDecodeRestorableState:` method, after macOS relaunches the app.\n\nThe sample avoids this app relaunch routine by instead opting in to handling the external GPU removal itself, without macOS needing to quit and relaunch the app. The sample’s `Info.plist` file has a `GPUEjectPolicy` key with a `wait` value, which indicates that the app explicitly handles the removal of an external GPU by responding to the corresponding notification posted by Metal.\n\n### Register for external GPU notifications\n\nThe sample calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCopyAllDevicesWithObserver] function to obtain all Metal devices available to the system. This method allows the sample to supply an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDeviceNotificationHandler] block that’s executed when an external GPU is added or removed from the system. This handler provides two arguments:\n\n- `device`. The device that was added or removed.\n- `notifyName`. A value that describes the event that triggered the notification.\n\n```objective-c\nMTLDeviceNotificationHandler notificationHandler;\n\nAAPLViewController * __weak controller = self;\nnotificationHandler = ^(id<MTLDevice> device, MTLDeviceNotificationName name)\n{\n    [controller markHotPlugNotificationForDevice:device name:name];\n};\n\n\/\/ Query all supported metal devices with an observer, so the app can receive notifications\n\/\/ when external GPUs are added to or removed from the system\nid<NSObject> metalDeviceObserver = nil;\nNSArray<id<MTLDevice>> * availableDevices =\n    MTLCopyAllDevicesWithObserver(&metalDeviceObserver,\n                                  notificationHandler);\n```\n\n### Respond to external GPU notifications\n\nThe notification handler can execute on any thread. However, all UI updates need to occur on the main thread and the app’s state changes need to be explicitly made thread-safe. To comply with these thread requirements, the view controller protects access to the `_hotPlugEvent` and `_hotPlugDevice` instance variables with a `@synchronized` directive. (The `@synchronized` directive is a convenient way to create mutex locks in Objective-C code.)\n\nThe sample sets these instance variables in the `markHotPlugNotificationForDevice:name:` method when a notification occurs.\n\n```objective-c\n- (void)markHotPlugNotificationForDevice:(nonnull id<MTLDevice>)device\n                                    name:(nonnull MTLDeviceNotificationName)name\n{\n    @synchronized(self)\n    {\n        if ([name isEqualToString:MTLDeviceWasAddedNotification])\n        {\n            _hotPlugEvent = AAPLHotPlugEventDeviceAdded;\n        }\n        else if ([name isEqualToString:MTLDeviceRemovalRequestedNotification])\n        {\n            _hotPlugEvent = AAPLHotPlugEventDeviceEjected;\n        }\n        else if ([name isEqualToString:MTLDeviceWasRemovedNotification])\n        {\n            _hotPlugEvent = AAPLHotPlugEventDevicePulled;\n        }\n\n        _hotPlugDevice = device;\n    }\n}\n```\n\nThe sample reads these instance variables on the main thread and handles the notification in the `handlePossibleHotPlugEvent` method.\n\n```objective-c\n- (void)handlePossibleHotPlugEvent\n{\n    AAPLHotPlugEvent hotPlugEvent;\n    id<MTLDevice> hotPlugDevice;\n\n    @synchronized(self)\n    {\n        hotPlugEvent = _hotPlugEvent;\n        hotPlugDevice = _hotPlugDevice;\n        _hotPlugDevice = nil;\n    }\n\n    if(hotPlugDevice)\n    {\n        switch (hotPlugEvent)\n        {\n            case AAPLHotPlugEventDeviceAdded:\n                [self handleMTLDeviceAddedNotification:hotPlugDevice];\n                break;\n            case AAPLHotPlugEventDeviceEjected:\n            case AAPLHotPlugEventDevicePulled:\n                [self handleMTLDeviceRemovalNotification:hotPlugDevice];\n                break;\n        }\n    }\n}\n```\n\nWhen a device that represents an external GPU is added to the system, the `handlePossibleHotPlugEvent` method adds the device to the `_supportedDevices` array and initializes a new `AAPLRenderer` for the device. When such a device is removed from the system, the same method removes the device from the `_supportedDevices` array and destroys its associated `AAPLRenderer`. If the removed device was being used for rendering, the sample switches to another device and renderer.\n\n### Update per-frame state and data\n\nMetalKit calls the [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] method for the sample to render each frame. Within this method, the sample calls the `handlePossibleHotPlugEvent` method to handle device additions or removals on the main thread. Such actions include updating UI related to these device events and completing any additional state changes that need to be executed atomically on a single thread.\n\nThe sample then calls the `drawFrameNumber:toView:` to begin rendering a new frame for the current renderer. To ensure continuous rendering that enables seamless switching between different renderers, the sample stores any nonrendering state separate from the renderers themselves. Then, for each frame, the sample passes any necessary nonrendering state to a specific `AAPLRenderer` instance. In this case, the sample passes the current frame number, `_frameNumber`, to the renderer so it can calculate the position and rotation of the sample’s 3D model.\n\n### Deregister from notifications\n\nAfter the view disappears, the sample explicitly deregisters itself from any previous display or device notifications. Otherwise, the system’s notification center and Metal can’t release the sample’s view controller.\n\n```objective-c\n- (void)viewDidDisappear\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self\n                                                    name:NSApplicationDidChangeScreenParametersNotification\n                                                  object:nil];\n\n    [[NSNotificationCenter defaultCenter] removeObserver:self\n                                                    name:NSWindowDidChangeScreenNotification\n                                                  object:nil];\n\n    MTLRemoveDeviceObserver(_metalDeviceObserver);\n}\n```\n\n\n\n## Render workflows\n\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Customizing render pass setup**: Render into an offscreen texture by creating a custom render pass.\n- **Creating a custom Metal view**: Implement a lightweight view for Metal rendering that’s customized to your app’s needs.\n- **Calculating primitive visibility using depth testing**: Determine which pixels are visible in a scene by using a depth texture.\n- **Encoding indirect command buffers on the CPU**: Reduce CPU overhead and simplify your command execution by reusing commands.\n- **Implementing order-independent transparency with image blocks**: Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.\n- **Loading textures and models using Metal fast resource loading**: Stream texture and buffer data directly from disk into Metal resources using fast resource loading.\n- **Adjusting the level of detail using Metal mesh shaders**: Choose and render meshes with several levels of detail using object and mesh shaders.\n- **Creating a 3D application with hydra rendering**: Build a 3D application that integrates with Hydra and USD.\n- **Culling occluded geometry using the visibility result buffer**: Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.\n- **Improving edge-rendering quality with multisample antialiasing (MSAA)**: Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.\n- **Achieving smooth frame rates with a Metal display link**: Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        },
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Render into an offscreen texture by creating a custom render pass.",
          "name" : "Customizing render pass setup",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup"
        },
        {
          "description" : "Implement a lightweight view for Metal rendering that’s customized to your app’s needs.",
          "name" : "Creating a custom Metal view",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-custom-metal-view"
        },
        {
          "description" : "Determine which pixels are visible in a scene by using a depth texture.",
          "name" : "Calculating primitive visibility using depth testing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/calculating-primitive-visibility-using-depth-testing"
        },
        {
          "description" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "name" : "Encoding indirect command buffers on the CPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
        },
        {
          "description" : "Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.",
          "name" : "Implementing order-independent transparency with image blocks",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-order-independent-transparency-with-image-blocks"
        },
        {
          "description" : "Stream texture and buffer data directly from disk into Metal resources using fast resource loading.",
          "name" : "Loading textures and models using Metal fast resource loading",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/loading-textures-and-models-using-metal-fast-resource-loading"
        },
        {
          "description" : "Choose and render meshes with several levels of detail using object and mesh shaders.",
          "name" : "Adjusting the level of detail using Metal mesh shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/adjusting-the-level-of-detail-using-metal-mesh-shaders"
        },
        {
          "description" : "Build a 3D application that integrates with Hydra and USD.",
          "name" : "Creating a 3D application with hydra rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-3d-application-with-hydra-rendering"
        },
        {
          "description" : "Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.",
          "name" : "Culling occluded geometry using the visibility result buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/culling-occluded-geometry-using-the-visibility-result-buffer"
        },
        {
          "description" : "Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.",
          "name" : "Improving edge-rendering quality with multisample antialiasing (MSAA)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-edge-rendering-quality-with-multisample-antialiasing-msaa"
        },
        {
          "description" : "Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.",
          "name" : "Achieving smooth frame rates with a Metal display link",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/achieving-smooth-frame-rates-with-a-metal-display-link"
        }
      ],
      "title" : "Render workflows"
    }
  ],
  "source" : "appleJSON",
  "title" : "Selecting device objects for graphics rendering",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-graphics-rendering"
}