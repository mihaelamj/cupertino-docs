{
  "abstract" : "Explore the complete set of Metal samples.",
  "codeExamples" : [

  ],
  "contentHash" : "c62471e107042d8fbbef24108198bd6dd0c041925ffc01d972b6b98d3109707b",
  "crawledAt" : "2025-12-03T04:58:29Z",
  "id" : "75D98C67-56D0-49D8-832C-3E4A83EFF339",
  "kind" : "collection",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nBrowse the topics below to find samples relevant to a concept you want to learn more about, starting with the basic computation and render workflows. The samples in the lighting and multiple technique sections demonstrate how to take advantage of the unique GPU architecture of Apple silicon.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/metal-sample-code-library\ncrawled: 2025-12-03T04:58:29Z\n---\n\n# Metal sample code library\n\nExplore the complete set of Metal samples.\n\n## Overview\n\nBrowse the topics below to find samples relevant to a concept you want to learn more about, starting with the basic computation and render workflows. The samples in the lighting and multiple technique sections demonstrate how to take advantage of the unique GPU architecture of Apple silicon.\n\n## Compute workflows\n\n- **Performing calculations on a GPU**: Use Metal to find GPUs and perform calculations on them.\n- **Selecting device objects for compute processing**: Switch dynamically between multiple GPUs to efficiently execute a compute-intensive simulation.\n- **Customizing a TensorFlow operation**: Implement a custom operation that uses Metal kernels to accelerate neural-network training performance.\n- **Customizing a PyTorch operation**: Implement a custom operation in PyTorch that uses Metal kernels to improve performance.\n\n## Render workflows\n\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Selecting device objects for graphics rendering**: Switch dynamically between multiple GPUs to efficiently render to a display.\n- **Customizing render pass setup**: Render into an offscreen texture by creating a custom render pass.\n- **Creating a custom Metal view**: Implement a lightweight view for Metal rendering that’s customized to your app’s needs.\n- **Calculating primitive visibility using depth testing**: Determine which pixels are visible in a scene by using a depth texture.\n- **Encoding indirect command buffers on the CPU**: Reduce CPU overhead and simplify your command execution by reusing commands.\n- **Implementing order-independent transparency with image blocks**: Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.\n- **Loading textures and models using Metal fast resource loading**: Stream texture and buffer data directly from disk into Metal resources using fast resource loading.\n- **Adjusting the level of detail using Metal mesh shaders**: Choose and render meshes with several levels of detail using object and mesh shaders.\n- **Creating a 3D application with hydra rendering**: Build a 3D application that integrates with Hydra and USD.\n- **Culling occluded geometry using the visibility result buffer**: Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.\n- **Improving edge-rendering quality with multisample antialiasing (MSAA)**: Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.\n- **Achieving smooth frame rates with a Metal display link**: Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.\n\n## Textures\n\n- **Processing a texture in a compute function**: Create textures by running copy and dispatch commands in a compute pass on a GPU.\n- **Reading pixel data from a drawable texture**: Access texture data from the CPU by copying it to a buffer.\n- **Creating and sampling textures**: Load image data into a texture and apply it to a quadrangle.\n- **Streaming large images with Metal sparse textures**: Limit texture memory usage for large textures by loading or unloading image detail on the basis of MIP and tile region.\n\n## Argument buffers\n\n- **Managing groups of resources with argument buffers**: Create argument buffers to organize related resources.\n- **Using argument buffers with resource heaps**: Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.\n- **Encoding argument buffers on the GPU**: Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.\n- **Rendering terrain dynamically with argument buffers**: Use argument buffers to render terrain in real time with a GPU-driven pipeline.\n\n## Shaders\n\n- **Creating a Metal dynamic library**: Compile a library of shaders and write it to a file as a dynamically linked library.\n- **Using function specialization to build pipeline variants**: Create pipelines for different levels of detail from a common shader source.\n\n## Synchronization\n\n- **Synchronizing CPU and GPU work**: Avoid stalls between CPU and GPU work by using multiple instances of a resource.\n- **Implementing a multistage image filter using heaps and events**: Use events to synchronize access to resources allocated on a heap.\n- **Implementing a multistage image filter using heaps and fences**: Use fences to synchronize access to resources allocated on a heap.\n\n## Lighting techniques\n\n- **Rendering a scene with forward plus lighting using tile shaders**: Implement a forward plus renderer using the latest features on Apple GPUs.\n- **Rendering a scene with deferred lighting in Objective-C**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n- **Rendering a scene with deferred lighting in Swift**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n- **Rendering a scene with deferred lighting in C++**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n- **Rendering reflections with fewer render passes**: Use layer selection to reduce the number of render passes needed to generate an environment map.\n\n## Multiple techniques\n\n- **Modern rendering with Metal**: Use advanced Metal features such as indirect command buffers, sparse textures, and variable rate rasterization to implement complex rendering techniques.\n- **Encoding indirect command buffers on the GPU**: Maximize CPU to GPU parallelization by generating render commands on the GPU.\n\n## Ray tracing\n\n- **Rendering reflections in real time using ray tracing**: Implement realistic real-time lighting by dynamically generating reflection maps by encoding a ray-tracing compute pass.\n- **Accelerating ray tracing using Metal**: Implement ray-traced rendering using GPU-based parallel processing.\n- **Control the ray tracing process using intersection queries**: Explicitly enumerate a ray’s intersections with acceleration structures by creating an intersection query object.\n- **Accelerating ray tracing and motion blur using Metal**: Generate ray-traced images with motion blur using GPU-based parallel processing.\n- **Rendering a curve primitive in a ray tracing scene**: Implement ray traced rendering using GPU-based parallel processing.\n\n## HDR\n\n- **Processing HDR images with Metal**: Implement a post-processing pipeline using the latest features on Apple GPUs.\n\n## OpenGL\n\n- **Migrating OpenGL code to Metal**: Replace your app’s deprecated OpenGL code with Metal.\n- **Mixing Metal and OpenGL rendering in a view**: Draw with Metal and OpenGL in the same view using an interoperable texture.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use Metal to find GPUs and perform calculations on them.",
          "name" : "Performing calculations on a GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/performing-calculations-on-a-gpu"
        },
        {
          "description" : "Switch dynamically between multiple GPUs to efficiently execute a compute-intensive simulation.",
          "name" : "Selecting device objects for compute processing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-compute-processing"
        },
        {
          "description" : "Implement a custom operation that uses Metal kernels to accelerate neural-network training performance.",
          "name" : "Customizing a TensorFlow operation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-a-tensorflow-operation"
        },
        {
          "description" : "Implement a custom operation in PyTorch that uses Metal kernels to improve performance.",
          "name" : "Customizing a PyTorch operation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-a-pytorch-operation"
        }
      ],
      "title" : "Compute workflows"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        },
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Switch dynamically between multiple GPUs to efficiently render to a display.",
          "name" : "Selecting device objects for graphics rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-graphics-rendering"
        },
        {
          "description" : "Render into an offscreen texture by creating a custom render pass.",
          "name" : "Customizing render pass setup",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup"
        },
        {
          "description" : "Implement a lightweight view for Metal rendering that’s customized to your app’s needs.",
          "name" : "Creating a custom Metal view",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-custom-metal-view"
        },
        {
          "description" : "Determine which pixels are visible in a scene by using a depth texture.",
          "name" : "Calculating primitive visibility using depth testing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/calculating-primitive-visibility-using-depth-testing"
        },
        {
          "description" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "name" : "Encoding indirect command buffers on the CPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
        },
        {
          "description" : "Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.",
          "name" : "Implementing order-independent transparency with image blocks",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-order-independent-transparency-with-image-blocks"
        },
        {
          "description" : "Stream texture and buffer data directly from disk into Metal resources using fast resource loading.",
          "name" : "Loading textures and models using Metal fast resource loading",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/loading-textures-and-models-using-metal-fast-resource-loading"
        },
        {
          "description" : "Choose and render meshes with several levels of detail using object and mesh shaders.",
          "name" : "Adjusting the level of detail using Metal mesh shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/adjusting-the-level-of-detail-using-metal-mesh-shaders"
        },
        {
          "description" : "Build a 3D application that integrates with Hydra and USD.",
          "name" : "Creating a 3D application with hydra rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-3d-application-with-hydra-rendering"
        },
        {
          "description" : "Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.",
          "name" : "Culling occluded geometry using the visibility result buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/culling-occluded-geometry-using-the-visibility-result-buffer"
        },
        {
          "description" : "Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.",
          "name" : "Improving edge-rendering quality with multisample antialiasing (MSAA)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-edge-rendering-quality-with-multisample-antialiasing-msaa"
        },
        {
          "description" : "Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.",
          "name" : "Achieving smooth frame rates with a Metal display link",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/achieving-smooth-frame-rates-with-a-metal-display-link"
        }
      ],
      "title" : "Render workflows"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create textures by running copy and dispatch commands in a compute pass on a GPU.",
          "name" : "Processing a texture in a compute function",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/processing-a-texture-in-a-compute-function"
        },
        {
          "description" : "Access texture data from the CPU by copying it to a buffer.",
          "name" : "Reading pixel data from a drawable texture",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/reading-pixel-data-from-a-drawable-texture"
        },
        {
          "description" : "Load image data into a texture and apply it to a quadrangle.",
          "name" : "Creating and sampling textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-and-sampling-textures"
        },
        {
          "description" : "Limit texture memory usage for large textures by loading or unloading image detail on the basis of MIP and tile region.",
          "name" : "Streaming large images with Metal sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/streaming-large-images-with-metal-sparse-textures"
        }
      ],
      "title" : "Textures"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create argument buffers to organize related resources.",
          "name" : "Managing groups of resources with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-groups-of-resources-with-argument-buffers"
        },
        {
          "description" : "Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.",
          "name" : "Using argument buffers with resource heaps",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-argument-buffers-with-resource-heaps"
        },
        {
          "description" : "Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.",
          "name" : "Encoding argument buffers on the GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-argument-buffers-on-the-gpu"
        },
        {
          "description" : "Use argument buffers to render terrain in real time with a GPU-driven pipeline.",
          "name" : "Rendering terrain dynamically with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-terrain-dynamically-with-argument-buffers"
        }
      ],
      "title" : "Argument buffers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Compile a library of shaders and write it to a file as a dynamically linked library.",
          "name" : "Creating a Metal dynamic library",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-metal-dynamic-library"
        },
        {
          "description" : "Create pipelines for different levels of detail from a common shader source.",
          "name" : "Using function specialization to build pipeline variants",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-function-specialization-to-build-pipeline-variants"
        }
      ],
      "title" : "Shaders"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Avoid stalls between CPU and GPU work by using multiple instances of a resource.",
          "name" : "Synchronizing CPU and GPU work",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-cpu-and-gpu-work"
        },
        {
          "description" : "Use events to synchronize access to resources allocated on a heap.",
          "name" : "Implementing a multistage image filter using heaps and events",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-a-multistage-image-filter-using-heaps-and-events"
        },
        {
          "description" : "Use fences to synchronize access to resources allocated on a heap.",
          "name" : "Implementing a multistage image filter using heaps and fences",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-a-multistage-image-filter-using-heaps-and-fences"
        }
      ],
      "title" : "Synchronization"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Implement a forward plus renderer using the latest features on Apple GPUs.",
          "name" : "Rendering a scene with forward plus lighting using tile shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-forward-plus-lighting-using-tile-shaders"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in Objective-C",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-objective-c"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-swift"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in C++",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-c++"
        },
        {
          "description" : "Use layer selection to reduce the number of render passes needed to generate an environment map.",
          "name" : "Rendering reflections with fewer render passes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-reflections-with-fewer-render-passes"
        }
      ],
      "title" : "Lighting techniques"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use advanced Metal features such as indirect command buffers, sparse textures, and variable rate rasterization to implement complex rendering techniques.",
          "name" : "Modern rendering with Metal",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/modern-rendering-with-metal"
        },
        {
          "description" : "Maximize CPU to GPU parallelization by generating render commands on the GPU.",
          "name" : "Encoding indirect command buffers on the GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-gpu"
        }
      ],
      "title" : "Multiple techniques"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Implement realistic real-time lighting by dynamically generating reflection maps by encoding a ray-tracing compute pass.",
          "name" : "Rendering reflections in real time using ray tracing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-reflections-in-real-time-using-ray-tracing"
        },
        {
          "description" : "Implement ray-traced rendering using GPU-based parallel processing.",
          "name" : "Accelerating ray tracing using Metal",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/accelerating-ray-tracing-using-metal"
        },
        {
          "description" : "Explicitly enumerate a ray’s intersections with acceleration structures by creating an intersection query object.",
          "name" : "Control the ray tracing process using intersection queries",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/control-the-ray-tracing-process-using-intersection-queries"
        },
        {
          "description" : "Generate ray-traced images with motion blur using GPU-based parallel processing.",
          "name" : "Accelerating ray tracing and motion blur using Metal",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/accelerating-ray-tracing-and-motion-blur-using-metal"
        },
        {
          "description" : "Implement ray traced rendering using GPU-based parallel processing.",
          "name" : "Rendering a curve primitive in a ray tracing scene",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-curve-primitive-in-a-ray-tracing-scene"
        }
      ],
      "title" : "Ray tracing"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Implement a post-processing pipeline using the latest features on Apple GPUs.",
          "name" : "Processing HDR images with Metal",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/processing-hdr-images-with-metal"
        }
      ],
      "title" : "HDR"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Replace your app’s deprecated OpenGL code with Metal.",
          "name" : "Migrating OpenGL code to Metal",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/migrating-opengl-code-to-metal"
        },
        {
          "description" : "Draw with Metal and OpenGL in the same view using an interoperable texture.",
          "name" : "Mixing Metal and OpenGL rendering in a view",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/mixing-metal-and-opengl-rendering-in-a-view"
        }
      ],
      "title" : "OpenGL"
    }
  ],
  "source" : "appleJSON",
  "title" : "Metal sample code library",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/metal-sample-code-library"
}