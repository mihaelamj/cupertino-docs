{
  "abstract" : "Set up a window and view for optimally displaying your Metal content.",
  "codeExamples" : [
    {
      "code" : "NSScreen *screen = [NSScreen mainScreen];",
      "language" : "objective-c"
    },
    {
      "code" : "NSWindowStyleMask style= NSWindowStyleMaskClosable\n                       | NSWindowStyleMaskTitled\n                       | NSWindowStyleMaskMiniaturizable\n                       | NSWindowStyleMaskResizable;",
      "language" : "objective-c"
    },
    {
      "code" : "NSRect contentRect = NSMakeRect(0, 0, 1280, 720);",
      "language" : "objective-c"
    },
    {
      "code" : "contentRect.origin.x = (screen.frame.size.width - contentRect.size.width) \/ 2;\ncontentRect.origin.y = (screen.frame.size.height - contentRect.size.height) \/ 2;",
      "language" : "objective-c"
    },
    {
      "code" : "@interface GameWindow: NSWindow\n@end\n\n@implementation GameWindow\n@end",
      "language" : "objective-c"
    },
    {
      "code" : "GameWindow *window = [[GameWindow alloc] initWithContentRect:contentRect\n                                                   styleMask:style\n                                                     backing:NSBackingStoreBuffered\n                                                       defer:NO\n                                                      screen:screen];",
      "language" : "objective-c"
    },
    {
      "code" : "CAMetalLayer *metalLayer = [[CAMetalLayer alloc] init]",
      "language" : "objective-c"
    },
    {
      "code" : "view.layer = metalLayer;",
      "language" : "objective-c"
    },
    {
      "code" : "[window setIsVisible:true];\n[window makeKeyAndOrderFront:nil];",
      "language" : "objective-c"
    },
    {
      "code" : "[window toggleFullScreen:nil];",
      "language" : "objective-c"
    },
    {
      "code" : "@interface GameWindowDelegate: NSObject<NSWindowDelegate>\n@end\n\n@implementation GameWindowDelegate {\n}\n\n-(void)windowDidResize:(NSNotification *)notification {\n\/\/ Automatically resize the view.\n\/\/ Resize the Metal layer using the view\n\/\/ size here. You can use any other size if necessary.\n    NSWindow window = notification.object; \/\/ 1\n    NSView *view = window.contentView; \/\/ 2\n    CAMetalLayer *metalLayer = (CAMetalLayer *)view.layer; \/\/ 3\n    metalLayer.drawableSize = [view convertSizeToBacking:view.frame.size]; \/\/ 4\n}\n\n@end",
      "language" : "objective-c"
    },
    {
      "code" : "GameWindowDelegate *windowDelegate = [[GameWindowDelegate alloc] init];\nif (windowDelegate != NULL) {\n    window.delegate = windowDelegate;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "@interface GameWindow : NSWindow\n@end\n\n@implementation GameWindow\n\n- (void)keyDown:(NSEvent *)event\n{\n}\n\n@end",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "6cb6dbd5dcc3b451390230c60de3b5f5ac96ea0d5b6e8d9343f5390570586bf3",
  "crawledAt" : "2025-12-03T04:14:27Z",
  "id" : "E26EFC6E-785B-4321-AAA0-6ABF720AE840",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nWith Metal, apps can leverage a GPU to quickly render complex scenes and run computational tasks in parallel. Your results accumulate into a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] that you can display onscreen using a window. By configuring your window correctly, your app can achieve optimal results by engaging direct-to-display for its Metal drawable. And, when not in full-screen mode, your game’s content displays as expected in a window that works in familiar ways for people using macOS.\n\nWhen a Metal drawable is direct-to-display, the hardware composites it directly to the display at a very low performance cost with a high-quality upscaling or downscaling algorithm. This means your app can present the drawable to the display at high speed with all the details taken care of.\n\nTo enable direct-to-display, your app needs to run in full-screen mode, displaying an opaque [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] layer and RGB content, and run on a Mac with Apple silicon. There may be other edge case conditions depending on the hardware and system software, but if you set up your window in this way, the drawable is direct-to-display in most situations. All of the RGB formats supported by Metal layers are capable of drawing direct-to-display content. You can enable the Metal HUD or use instruments to verify that your drawable goes direct-to-display.\n\n### Choose the screen for displaying your window\n\nTo set up a window for displaying your game in macOS, begin by selecting a screen where you want to display your game. The computer running your game may be equipped with more than one monitor. You can use the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen] class to discover what [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen\/screens] are connected to a computer running macOS and what screen the user designated as the main screen. The [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen\/main] is optimal for displaying a game. You can get a reference to the main screen like so:\n\nThe [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen] object includes detailed information such as the resolution, bit depth, dimensions and location of the screen, its color space, and other details. If you need more information about a screen or want to interact with the screen beyond the functionality offered by the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen] AppKit API, see the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/quartz-display-services] API. [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/quartz-display-services] is a lower-level API that provides direct access to features in the macOS window server for configuring and controlling display hardware.\n\n### Pick a style for your window\n\nAppKit in macOS has a concept called *window style* that you store as a set of flags describing the layout of the frame and controls decorating the outside edges of a window. Use the following value for windows displaying Metal game content:\n\nHere are the parts of the style above and the functionality each adds to your window:\n\n### Choose the content size of your window and Metal view\n\nWhen you create a new window, you specify its coordinates in points relative to the coordinates of a screen. *Points* are an abstract measurement quantity that don’t correspond to any actual pixel sizes. There are roughly 72 points per inch. For more information on points, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/GraphicsAnimation\/Conceptual\/HighResolutionOSX\/Explained\/Explained.html#\/\/apple_ref\/doc\/uid\/TP40012302-CH4-SW1].\n\nThe system manages most issues related to pixel sizes and display resolution for you, and optimizes a person’s experience depending on the device hardware they’re using. Your app need only be concerned with setting up its window as described here.\n\nFor your initial window size, you can use any point size that you think looks suitable on displays where you expect people to use your app:\n\nThe size you choose when creating your window isn’t important, but center your window in the screen:\n\nAfter you create your window, you can get more information about the actual resolution AppKit uses to render your view by using the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/convertPointToBacking(_:)] method. For example, if you call [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/convertPointToBacking(_:)] with the size of your window, it returns the actual pixel dimensions of the window’s content onscreen. This can be useful to know when converting locations in your window to actual screen pixel positions, but you don’t need to be concerned about these details when creating your window.\n\nLeave all of the AppKit settings for managing a window and the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] instance it depends on at their defaults so your app looks consistent on the rest of the system.\n\n### Create the window\n\nIn macOS, the AppKit framework represents windows using the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] class, so you can easily add additional functionality to your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow]. Subclass [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] like so:\n\nThen you can allocate and initialize your window as follows:\n\nYou already set up the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSTabView\/contentRect], mask, and screen parameters in the previous sections. The [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/BackingStoreType\/buffered] parameter tells AppKit that you want a window that has a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] backing store. Later, you replace the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] with the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] so the window displays your content.\n\n### Add the window\n\nFor a better user experience, after creating your new window, set the following properties on your window:\n\n### Display your Metal content in your new view\n\nWhen you want Metal to render a layer’s contents, use a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]. You set up a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] and use it to replace the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] in the view you set up previously. Begin by creating a new [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]:\n\nThen, configure the following settings:\n\nSupport resizing dynamically whenever possible and keep in mind the following considerations when deciding on a pixel resolution for your [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]:\n\nAfter you set up your [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer], you can activate it by replacing the layer’s [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] with your new [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]:\n\nAt this point, your window is ready to start rendering Metal content.\n\n### Make the window visible and present in front\n\nUp until now, everything you’ve done is offscreen. To present your new window and Metal view onscreen, call the following APIs:\n\nIf someone happens to close your window and you previously set `window.releasedWhenClosed = NO;` when creating your window, you can use these APIs to present your window onscreen again.\n\n### Use the entire window\n\nLastly, set your window to full-screen mode by calling the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)] method:\n\nYou can call this same method again to switch out of full-screen mode. For more information about AppKit and full-screen mode, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/MOSXAppProgrammingGuide\/FullScreenApp\/FullScreenApp.html].\n\nNote that when using the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)] method, you don’t specify what full screen means, and you let the system decide what it means in a way that’s most familiar to the user. When you call [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)], the system adjusts your window’s size to what it considers to be full screen.\n\n### Add code so your window can handle resizing\n\nTo keep the size of your `CAMetalLayer` instance’s [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer\/drawableSize] in sync with the part of the screen the window is drawing to, set up a [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] method on the window’s delegate as described below. Call this method every time your window is resized, including times when your app calls [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)].\n\nBy adding a [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate] to your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] subclass (`GameWindow`), you can respond to resizing events for the window. These can occur in response to user actions, when properties of the display change, or when your application resizes the window. Use the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate] protocol to define your own delegate class capable of responding to [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] events as follows:\n\nHere’s what’s going on in the above statements:\n\nThe net result is that whenever you resize the window, the system resets the `CAMetalLayer` instance’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/drawableSize] property to the actual pixel resolution of the display your window is drawing to.\n\nSet the delegate for your `GameWindow` to an instance of your class that conforms to the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate] protocol by assigning it to the window’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/delegate] property.\n\nAfter you set up your window delegate, it begins receiving method calls to your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] method whenever the size of your window changes. When your app calls [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)], AppKit recomputes the size of your window and calls your delegate’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] method.\n\n### Add code to prevent exposing your window class to unintentionally consuming key events\n\nInteractions between the AppKit framework and the Game Controller framework can, under some conditions, expose the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] APIs to unintentionally consuming key events that need to go to [doc:\/\/com.apple.documentation\/documentation\/GameController\/GCController]. To avoid this possibility, add a key down handler that does nothing on your `GameWindow` class:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/managing-your-game-window-for-metal-in-macos\ncrawled: 2025-12-03T04:14:27Z\n---\n\n# Managing your game window for Metal in macOS\n\n**Article**\n\nSet up a window and view for optimally displaying your Metal content.\n\n## Overview\n\nWith Metal, apps can leverage a GPU to quickly render complex scenes and run computational tasks in parallel. Your results accumulate into a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] that you can display onscreen using a window. By configuring your window correctly, your app can achieve optimal results by engaging direct-to-display for its Metal drawable. And, when not in full-screen mode, your game’s content displays as expected in a window that works in familiar ways for people using macOS.\n\nWhen a Metal drawable is direct-to-display, the hardware composites it directly to the display at a very low performance cost with a high-quality upscaling or downscaling algorithm. This means your app can present the drawable to the display at high speed with all the details taken care of.\n\nTo enable direct-to-display, your app needs to run in full-screen mode, displaying an opaque [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] layer and RGB content, and run on a Mac with Apple silicon. There may be other edge case conditions depending on the hardware and system software, but if you set up your window in this way, the drawable is direct-to-display in most situations. All of the RGB formats supported by Metal layers are capable of drawing direct-to-display content. You can enable the Metal HUD or use instruments to verify that your drawable goes direct-to-display.\n\n### Choose the screen for displaying your window\n\nTo set up a window for displaying your game in macOS, begin by selecting a screen where you want to display your game. The computer running your game may be equipped with more than one monitor. You can use the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen] class to discover what [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen\/screens] are connected to a computer running macOS and what screen the user designated as the main screen. The [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen\/main] is optimal for displaying a game. You can get a reference to the main screen like so:\n\n```objective-c\nNSScreen *screen = [NSScreen mainScreen];\n```\n\nThe [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen] object includes detailed information such as the resolution, bit depth, dimensions and location of the screen, its color space, and other details. If you need more information about a screen or want to interact with the screen beyond the functionality offered by the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSScreen] AppKit API, see the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/quartz-display-services] API. [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/quartz-display-services] is a lower-level API that provides direct access to features in the macOS window server for configuring and controlling display hardware.\n\n### Pick a style for your window\n\nAppKit in macOS has a concept called *window style* that you store as a set of flags describing the layout of the frame and controls decorating the outside edges of a window. Use the following value for windows displaying Metal game content:\n\n```objective-c\nNSWindowStyleMask style= NSWindowStyleMaskClosable\n                       | NSWindowStyleMaskTitled\n                       | NSWindowStyleMaskMiniaturizable\n                       | NSWindowStyleMaskResizable;\n```\n\nHere are the parts of the style above and the functionality each adds to your window:\n\n\n\n### Choose the content size of your window and Metal view\n\nWhen you create a new window, you specify its coordinates in points relative to the coordinates of a screen. *Points* are an abstract measurement quantity that don’t correspond to any actual pixel sizes. There are roughly 72 points per inch. For more information on points, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/GraphicsAnimation\/Conceptual\/HighResolutionOSX\/Explained\/Explained.html#\/\/apple_ref\/doc\/uid\/TP40012302-CH4-SW1].\n\nThe system manages most issues related to pixel sizes and display resolution for you, and optimizes a person’s experience depending on the device hardware they’re using. Your app need only be concerned with setting up its window as described here.\n\nFor your initial window size, you can use any point size that you think looks suitable on displays where you expect people to use your app:\n\n```objective-c\nNSRect contentRect = NSMakeRect(0, 0, 1280, 720);\n```\n\nThe size you choose when creating your window isn’t important, but center your window in the screen:\n\n```objective-c\ncontentRect.origin.x = (screen.frame.size.width - contentRect.size.width) \/ 2;\ncontentRect.origin.y = (screen.frame.size.height - contentRect.size.height) \/ 2;\n```\n\nAfter you create your window, you can get more information about the actual resolution AppKit uses to render your view by using the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/convertPointToBacking(_:)] method. For example, if you call [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/convertPointToBacking(_:)] with the size of your window, it returns the actual pixel dimensions of the window’s content onscreen. This can be useful to know when converting locations in your window to actual screen pixel positions, but you don’t need to be concerned about these details when creating your window.\n\nLeave all of the AppKit settings for managing a window and the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] instance it depends on at their defaults so your app looks consistent on the rest of the system.\n\n### Create the window\n\nIn macOS, the AppKit framework represents windows using the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] class, so you can easily add additional functionality to your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow]. Subclass [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] like so:\n\n```objective-c\n@interface GameWindow: NSWindow\n@end\n\n@implementation GameWindow\n@end\n```\n\nThen you can allocate and initialize your window as follows:\n\n```objective-c\nGameWindow *window = [[GameWindow alloc] initWithContentRect:contentRect\n                                                   styleMask:style\n                                                     backing:NSBackingStoreBuffered\n                                                       defer:NO\n                                                      screen:screen];\n```\n\nYou already set up the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSTabView\/contentRect], mask, and screen parameters in the previous sections. The [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/BackingStoreType\/buffered] parameter tells AppKit that you want a window that has a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] backing store. Later, you replace the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] with the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] so the window displays your content.\n\n### Add the window\n\nFor a better user experience, after creating your new window, set the following properties on your window:\n\n- Set the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/minSize] to prevent the user from accidentally resizing the window too small:\n\n```objective-c\nwindow.minSize = NSMakeSize(640, 360);\n```\n- If your game retains a reference to a window, set the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/isReleasedWhenClosed] property to `NO`. This prevents the system from releasing your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] object when someone closes the window: `window.releasedWhenClosed = NO`;.\n\n\n\n### Display your Metal content in your new view\n\nWhen you want Metal to render a layer’s contents, use a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]. You set up a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] and use it to replace the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] in the view you set up previously. Begin by creating a new [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]:\n\n```objective-c\nCAMetalLayer *metalLayer = [[CAMetalLayer alloc] init]\n```\n\nThen, configure the following settings:\n\n1. Associate your [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] with a metal device using the default `metalLayer.device = MTLCreateSystemDefaultDevice();`.\n2. Make the layer opaque. An opaque layer can provide direct-to-display contents under the right conditions:\n\n```objective-c\nmetalLayer.opaque = YES;\n```\n3. Choose a resolution for your [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] layer. The pixel resolution of your [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] determines the size of the drawable produced to fill the layer.\n\nSupport resizing dynamically whenever possible and keep in mind the following considerations when deciding on a pixel resolution for your [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]:\n\n- The pixel resolution of the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] doesn’t have to match the view’s backing size (the screen’s resolution).\n- Render 2D UI that matches the view’s backing size and render 3D in a different render target with a size appropriate for the device. Then upscale it to the final drawable using a custom render pass or MetalFX: `metalLayer.drawableSize = [view convertSizeToBacking:view.frame.size];`.\n- However, for some games, it might be more convenient to render the drawable at an arbitrary size: `metalLayer.drawableSize = NSMakeSize(3840, 2160);`.\n- Depending on your situation, the drawable aspect ratio might not always match the view aspect ratio. In that case, you can ask Core Animation to preserve the aspect ratio for you using `metalLayer.contentsGravity = kCAGravityResizeAspect` and `metalLayer.backgroundColor = CGColorGetConstantColor(kCGColorBlack);`.\n- Regardless, the macOS compositor efficiently sends the drawable directly to the display, even if the drawable size doesn’t match the monitor size.\n\nAfter you set up your [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer], you can activate it by replacing the layer’s [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CALayer] with your new [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer]:\n\n```objective-c\nview.layer = metalLayer;\n```\n\nAt this point, your window is ready to start rendering Metal content.\n\n### Make the window visible and present in front\n\nUp until now, everything you’ve done is offscreen. To present your new window and Metal view onscreen, call the following APIs:\n\n```objective-c\n[window setIsVisible:true];\n[window makeKeyAndOrderFront:nil];\n```\n\nIf someone happens to close your window and you previously set `window.releasedWhenClosed = NO;` when creating your window, you can use these APIs to present your window onscreen again.\n\n### Use the entire window\n\nLastly, set your window to full-screen mode by calling the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)] method:\n\n```objective-c\n[window toggleFullScreen:nil];\n```\n\nYou can call this same method again to switch out of full-screen mode. For more information about AppKit and full-screen mode, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/MOSXAppProgrammingGuide\/FullScreenApp\/FullScreenApp.html].\n\nNote that when using the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)] method, you don’t specify what full screen means, and you let the system decide what it means in a way that’s most familiar to the user. When you call [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)], the system adjusts your window’s size to what it considers to be full screen.\n\n\n\n### Add code so your window can handle resizing\n\nTo keep the size of your `CAMetalLayer` instance’s [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer\/drawableSize] in sync with the part of the screen the window is drawing to, set up a [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] method on the window’s delegate as described below. Call this method every time your window is resized, including times when your app calls [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)].\n\nBy adding a [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate] to your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] subclass (`GameWindow`), you can respond to resizing events for the window. These can occur in response to user actions, when properties of the display change, or when your application resizes the window. Use the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate] protocol to define your own delegate class capable of responding to [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] events as follows:\n\n```objective-c\n@interface GameWindowDelegate: NSObject<NSWindowDelegate>\n@end\n\n@implementation GameWindowDelegate {\n}\n\n-(void)windowDidResize:(NSNotification *)notification {\n\/\/ Automatically resize the view.\n\/\/ Resize the Metal layer using the view\n\/\/ size here. You can use any other size if necessary.\n    NSWindow window = notification.object; \/\/ 1\n    NSView *view = window.contentView; \/\/ 2\n    CAMetalLayer *metalLayer = (CAMetalLayer *)view.layer; \/\/ 3\n    metalLayer.drawableSize = [view convertSizeToBacking:view.frame.size]; \/\/ 4\n}\n\n@end\n```\n\nHere’s what’s going on in the above statements:\n\n- Receive the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] object as the object property of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification] object.\n- Get a reference to the view you created in the “Create the window” section.\n- Retrieve a reference to the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] you created in the “Display your Metal content in your new view” section.\n- Reset the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] instance’s [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer\/drawableSize] property to the actual pixel size of the screen you intend to draw to by calling your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSView] instance’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSView\/convertToBacking(_:)-4ra9y] method, which the “Choose the content size of your window and Metal view” section covers. Note these directions set the drawable to match the size and resolution of the display, but it’s not necessary. If the drawable doesn’t match the size and resolution of the display, it scales automatically as it presents on the display.\n\nThe net result is that whenever you resize the window, the system resets the `CAMetalLayer` instance’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/drawableSize] property to the actual pixel resolution of the display your window is drawing to.\n\nSet the delegate for your `GameWindow` to an instance of your class that conforms to the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate] protocol by assigning it to the window’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/delegate] property.\n\n```objective-c\nGameWindowDelegate *windowDelegate = [[GameWindowDelegate alloc] init];\nif (windowDelegate != NULL) {\n    window.delegate = windowDelegate;\n}\n```\n\nAfter you set up your window delegate, it begins receiving method calls to your [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] method whenever the size of your window changes. When your app calls [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow\/toggleFullScreen(_:)], AppKit recomputes the size of your window and calls your delegate’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindowDelegate\/windowDidResize(_:)] method.\n\n### Add code to prevent exposing your window class to unintentionally consuming key events\n\nInteractions between the AppKit framework and the Game Controller framework can, under some conditions, expose the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSWindow] APIs to unintentionally consuming key events that need to go to [doc:\/\/com.apple.documentation\/documentation\/GameController\/GCController]. To avoid this possibility, add a key down handler that does nothing on your `GameWindow` class:\n\n```objective-c\n@interface GameWindow : NSWindow\n@end\n\n@implementation GameWindow\n\n- (void)keyDown:(NSEvent *)event\n{\n}\n\n@end\n```\n\n## Presentation\n\n- **Managing your Metal app window in iPadOS**: Set up a window that handles dynamically resizing your Metal content.\n- **Adapting your game interface for smaller screens**: Make text legible on all devices the player chooses to run your game on.\n- **Onscreen presentation**: Show the output from a GPU’s rendering pass to the user in your app.\n- **HDR content**: Take advantage of high dynamic range to present more vibrant colors in your apps and games.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Set up a window that handles dynamically resizing your Metal content.",
          "name" : "Managing your Metal app window in iPadOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-your-metal-app-window-in-ipados"
        },
        {
          "description" : "Make text legible on all devices the player chooses to run your game on.",
          "name" : "Adapting your game interface for smaller screens",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/adapting-your-game-interface-for-smaller-screens"
        },
        {
          "description" : "Show the output from a GPU’s rendering pass to the user in your app.",
          "name" : "Onscreen presentation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/onscreen-presentation"
        },
        {
          "description" : "Take advantage of high dynamic range to present more vibrant colors in your apps and games.",
          "name" : "HDR content",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/hdr-content"
        }
      ],
      "title" : "Presentation"
    }
  ],
  "source" : "appleJSON",
  "title" : "Managing your game window for Metal in macOS",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-your-game-window-for-metal-in-macos"
}