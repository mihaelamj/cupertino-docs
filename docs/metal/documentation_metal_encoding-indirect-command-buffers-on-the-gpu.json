{
  "abstract" : "Maximize CPU to GPU parallelization by generating render commands on the GPU.",
  "codeExamples" : [
    {
      "code" : "for(int objectIdx = 0; objectIdx < AAPLNumObjects; objectIdx++)\n{\n    \/\/ Choose the parameters to generate a mesh so that each one is unique.\n    uint32_t numTeeth = random() % 50 + 3;\n    float innerRatio = 0.2 + (random() \/ (1.0 * RAND_MAX)) * 0.7;\n    float toothWidth = 0.1 + (random() \/ (1.0 * RAND_MAX)) * 0.4;\n    float toothSlope = (random() \/ (1.0 * RAND_MAX)) * 0.2;\n\n    \/\/ Create a vertex buffer and initialize it with a unique 2D gear mesh.\n    tempMeshes[objectIdx] = [self newGearMeshWithNumTeeth:numTeeth\n                                               innerRatio:innerRatio\n                                               toothWidth:toothWidth\n                                               toothSlope:toothSlope];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "size_t bufferSize = 0;\n\nfor(int objectIdx = 0; objectIdx < AAPLNumObjects; objectIdx++)\n{\n    size_t meshSize = sizeof(AAPLVertex) * tempMeshes[objectIdx].numVerts;\n    bufferSize += meshSize;\n}\n\n_vertexBuffer = [_device newBufferWithLength:bufferSize options:0];",
      "language" : "objective-c"
    },
    {
      "code" : "for(int objectIdx = 0; objectIdx < AAPLNumObjects; objectIdx++)\n{\n    \/\/ Store the mesh metadata in the `params` buffer.\n\n    params[objectIdx].numVertices = tempMeshes[objectIdx].numVerts;\n\n    size_t meshSize = sizeof(AAPLVertex) * tempMeshes[objectIdx].numVerts;\n\n    params[objectIdx].startVertex = currentStartVertex;\n\n    \/\/ Pack the current mesh data in the combined vertex buffer.\n\n    AAPLVertex* meshStartAddress = ((AAPLVertex*)_vertexBuffer.contents) + currentStartVertex;\n\n    memcpy(meshStartAddress, tempMeshes[objectIdx].vertices, meshSize);\n\n    currentStartVertex += tempMeshes[objectIdx].numVerts;\n\n    free(tempMeshes[objectIdx].vertices);\n\n    \/\/ Set the other culling and mesh rendering parameters.\n\n    \/\/ Set the position of each object to a unique space in a grid.\n    vector_float2 gridPos = (vector_float2){objectIdx % AAPLGridWidth, objectIdx \/ AAPLGridWidth};\n    params[objectIdx].position = gridPos * AAPLObjecDistance;\n\n    params[objectIdx].boundingRadius = AAPLObjectSize \/ 2.0;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Check whether the object at 'objectIndex' is visible and set draw parameters if so.\n\/\/ Otherwise, reset the command.\nkernel void\ncullMeshesAndEncodeCommands(uint                         objectIndex   [[ thread_position_in_grid ]],\n                            constant AAPLFrameState     *frame_state   [[ buffer(AAPLKernelBufferIndexFrameState) ]],\n                            device AAPLObjectPerameters *object_params [[ buffer(AAPLKernelBufferIndexObjectParams)]],\n                            device AAPLVertex           *vertices      [[ buffer(AAPLKernelBufferIndexVertices) ]],\n                            device ICBContainer         *icb_container [[ buffer(AAPLKernelBufferIndexCommandBufferContainer) ]])\n{\n    float2 worldObjectPostion  = frame_state->translation + object_params[objectIndex].position;\n    float2 clipObjectPosition  = frame_state->aspectScale * AAPLViewScale * worldObjectPostion;\n\n    const float rightBounds =  1.0;\n    const float leftBounds  = -1.0;\n    const float upperBounds =  1.0;\n    const float lowerBounds = -1.0;\n\n    bool visible = true;\n\n    \/\/ Set the bounding radius in the view space.\n    const float2 boundingRadius = frame_state->aspectScale * AAPLViewScale * object_params[objectIndex].boundingRadius;\n\n    \/\/ Check if the object's bounding circle has moved outside of the view bounds.\n    if(clipObjectPosition.x + boundingRadius.x < leftBounds  ||\n       clipObjectPosition.x - boundingRadius.x > rightBounds ||\n       clipObjectPosition.y + boundingRadius.y < lowerBounds ||\n       clipObjectPosition.y - boundingRadius.y > upperBounds)\n    {\n        visible = false;\n    }\n    \/\/ Get indirect render commnd object from the indirect command buffer given the object's unique\n    \/\/ index to set parameters for drawing (or not drawing) the object.\n    render_command cmd(icb_container->commandBuffer, objectIndex);\n\n    if(visible)\n    {\n        \/\/ Set the buffers and add a draw command.\n        cmd.set_vertex_buffer(frame_state, AAPLVertexBufferIndexFrameState);\n        cmd.set_vertex_buffer(object_params, AAPLVertexBufferIndexObjectParams);\n        cmd.set_vertex_buffer(vertices, AAPLVertexBufferIndexVertices);\n\n        cmd.draw_primitives(primitive_type::triangle,\n                            object_params[objectIndex].startVertex,\n                            object_params[objectIndex].numVertices, 1,\n                            objectIndex);\n    }\n    \n    \/\/ If the object isn't visible, Metal doesn't set a draw command as long as the app resets\n    \/\/ the indirect command buffer commands with a blit encoder before encoding the draw.\n}",
      "language" : "metal"
    },
    {
      "code" : "\/\/ This is the argument buffer that contains the ICB.\nstruct ICBContainer\n{\n    command_buffer commandBuffer [[ id(AAPLArgumentBufferIDCommandBuffer) ]];\n};",
      "language" : "metal"
    },
    {
      "code" : "id<MTLArgumentEncoder> argumentEncoder =\n    [GPUCommandEncodingKernel newArgumentEncoderWithBufferIndex:AAPLKernelBufferIndexCommandBufferContainer];\n\n_icbArgumentBuffer = [_device newBufferWithLength:argumentEncoder.encodedLength\n                                       options:MTLResourceStorageModeShared];\n_icbArgumentBuffer.label = @\"ICB Argument Buffer\";\n\n[argumentEncoder setArgumentBuffer:_icbArgumentBuffer offset:0];\n\n[argumentEncoder setIndirectCommandBuffer:_indirectCommandBuffer\n                                  atIndex:AAPLArgumentBufferIDCommandBuffer];",
      "language" : "objective-c"
    },
    {
      "code" : "[computeEncoder setBuffer:_icbArgumentBuffer offset:0 atIndex:AAPLKernelBufferIndexCommandBufferContainer];",
      "language" : "objective-c"
    },
    {
      "code" : "[computeEncoder useResource:_indirectCommandBuffer usage:MTLResourceUsageWrite];",
      "language" : "objective-c"
    },
    {
      "code" : "[resetBlitEncoder resetCommandsInBuffer:_indirectCommandBuffer\n                              withRange:NSMakeRange(0, AAPLNumObjects)];",
      "language" : "objective-c"
    },
    {
      "code" : "[computeEncoder dispatchThreads:MTLSizeMake(AAPLNumObjects, 1, 1)\n          threadsPerThreadgroup:MTLSizeMake(threadExecutionWidth, 1, 1)];",
      "language" : "objective-c"
    },
    {
      "code" : "[optimizeBlitEncoder optimizeIndirectCommandBuffer:_indirectCommandBuffer\n                                         withRange:NSMakeRange(0, AAPLNumObjects)];",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder executeCommandsInBuffer:_indirectCommandBuffer withRange:NSMakeRange(0, AAPLNumObjects)];",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "05620b5fa6da9381bd8dacd7f042a506bfc1a2edf948843c699ce9498ff644d8",
  "crawledAt" : "2025-12-02T15:49:25Z",
  "id" : "F6DB3CEE-2776-423D-9775-8EF31BDECB5F",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nThis sample app demonstrates how to use *indirect command buffers* (ICB) to issue rendering instructions from the GPU. When you have a rendering algorithm that runs in a compute kernel, use ICBs to generate draw calls based on your algorithm’s results. The sample app uses a compute kernel to remove invisible objects submitted for rendering, and generates draw commands only for the objects currently visible in the scene.\n\n\n\nWithout ICBs, you can’t submit rendering commands on the GPU. Instead, the CPU waits for your compute kernel’s results before generating the render commands. Then, the GPU waits for the rendering commands to make it across the CPU to GPU bridge. The following diagram shows how this creates a slower round trip:\n\n\n\nThe sample code project, [doc:\/\/com.apple.documentation\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu] introduces ICBs by creating a single ICB to reuse its commands every frame. While the former sample saved expensive command-encoding time by reusing commands, this sample uses ICBs to effect a GPU-driven rendering pipeline.\n\nThe techniques shown by this sample include issuing draw calls from the GPU, and the process of executing a select set of draws.\n\n### Getting started\n\nThis project contains targets for macOS and iOS. Run the iOS scheme on a physical device because Metal isn’t supported in the simulator.\n\nThe sample calls an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder] instances’s\n[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder\/dispatchThreads(_:threadsPerThreadgroup:)] method, which is available to a GPU that supports the following feature sets and later:\n\n### Define the data read by the ICB\n\nIn an ideal scenario, you store each mesh in its own buffer. However, on iOS, kernels running on the GPU can only access a limited number of data buffers per execution. To reduce the number of buffers needed during the ICBs execution, you pack all meshes into a single buffer at varying offsets. Then, use another buffer to store the offset and size of each mesh. The process to do this follows.\n\nAt initialization, create the data for each mesh:\n\nCount the individual and accumulated mesh sizes and create the container buffer:\n\nFinally, insert each mesh into the container buffer while noting its offset and size in the second buffer:\n\n### Update the data read by the ICB dynamically\n\nBy culling non-visible vertices from the data fed to the rendering pipeline, you save significant rendering time and effort. To do that, use the same compute kernel that encodes the ICB’s commands to continually update the ICB’s data buffers:\n\nThe parallel nature of the GPU partitions the compute task for you, resulting in multiple offscreen meshes getting culled concurrently.\n\n### Pass an ICB to a compute kernel using an argument buffer\n\nTo get an ICB on the GPU and make it accessible to a compute kernel, you pass it through an argument buffer, as follows:\n\nDefine the container argument buffer as a structure that contains one member, the ICB:\n\nEncode the ICB into the argument buffer:\n\nPass the ICB (`_indirectCommandBuffer`) to the kernel by setting the argument buffer on the kernel’s compute command encoder:\n\nBecause you pass the ICB through an argument buffer, standard argument buffer rules apply. Call `useResource` on the ICB to tell Metal to prepare its use:\n\n### Encode and optimize ICB commands\n\nReset the ICB’s commands to their initial before beginning encoding:\n\nEncode the ICB’s commands by dispatching the compute kernel:\n\nOptimize your ICB commands to remove empty commands or redundant state by calling `optimizeIndirectCommandBuffer:withRange:`:\n\nThis sample optimizes ICB commands because redundant state results from the kernel setting a buffer for each draw, and encoding empty commands for each invisible object. By removing the empty commands, you can free up a significant number of blank spaces in the command buffer that Metal otherwise spends time skipping at runtime.\n\n### Execute the ICB\n\nDraw the onscreen meshes by calling `executeCommandsInBuffer` on your render command encoder:\n\nWhile you can encode an ICB’s commands in a compute kernel, you call `executeCommandsInBuffer` from your host app to encode a single command that contains all of the commands encoded by the compute kernel. By doing this, you choose the queue and buffer that the ICB’s commands go into. When you call `executeIndirectCommandBuffer` determines the placement of the ICB’s commands among any other commands you may also encode in the same buffer.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-gpu\ncrawled: 2025-12-02T15:49:25Z\n---\n\n# Encoding indirect command buffers on the GPU\n\n**Sample Code**\n\nMaximize CPU to GPU parallelization by generating render commands on the GPU.\n\n## Overview\n\nThis sample app demonstrates how to use *indirect command buffers* (ICB) to issue rendering instructions from the GPU. When you have a rendering algorithm that runs in a compute kernel, use ICBs to generate draw calls based on your algorithm’s results. The sample app uses a compute kernel to remove invisible objects submitted for rendering, and generates draw commands only for the objects currently visible in the scene.\n\n\n\nWithout ICBs, you can’t submit rendering commands on the GPU. Instead, the CPU waits for your compute kernel’s results before generating the render commands. Then, the GPU waits for the rendering commands to make it across the CPU to GPU bridge. The following diagram shows how this creates a slower round trip:\n\n\n\nThe sample code project, [doc:\/\/com.apple.documentation\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu] introduces ICBs by creating a single ICB to reuse its commands every frame. While the former sample saved expensive command-encoding time by reusing commands, this sample uses ICBs to effect a GPU-driven rendering pipeline.\n\nThe techniques shown by this sample include issuing draw calls from the GPU, and the process of executing a select set of draws.\n\n### Getting started\n\nThis project contains targets for macOS and iOS. Run the iOS scheme on a physical device because Metal isn’t supported in the simulator.\n\nThe sample calls an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder] instances’s\n[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder\/dispatchThreads(_:threadsPerThreadgroup:)] method, which is available to a GPU that supports the following feature sets and later:\n\n- MTLFeatureSet_iOS_GPUFamily4_v2\n- MTLFeatureSet_macOS_GPUFamily2_v1\n\n### Define the data read by the ICB\n\nIn an ideal scenario, you store each mesh in its own buffer. However, on iOS, kernels running on the GPU can only access a limited number of data buffers per execution. To reduce the number of buffers needed during the ICBs execution, you pack all meshes into a single buffer at varying offsets. Then, use another buffer to store the offset and size of each mesh. The process to do this follows.\n\nAt initialization, create the data for each mesh:\n\n```objective-c\nfor(int objectIdx = 0; objectIdx < AAPLNumObjects; objectIdx++)\n{\n    \/\/ Choose the parameters to generate a mesh so that each one is unique.\n    uint32_t numTeeth = random() % 50 + 3;\n    float innerRatio = 0.2 + (random() \/ (1.0 * RAND_MAX)) * 0.7;\n    float toothWidth = 0.1 + (random() \/ (1.0 * RAND_MAX)) * 0.4;\n    float toothSlope = (random() \/ (1.0 * RAND_MAX)) * 0.2;\n\n    \/\/ Create a vertex buffer and initialize it with a unique 2D gear mesh.\n    tempMeshes[objectIdx] = [self newGearMeshWithNumTeeth:numTeeth\n                                               innerRatio:innerRatio\n                                               toothWidth:toothWidth\n                                               toothSlope:toothSlope];\n}\n```\n\nCount the individual and accumulated mesh sizes and create the container buffer:\n\n```objective-c\nsize_t bufferSize = 0;\n\nfor(int objectIdx = 0; objectIdx < AAPLNumObjects; objectIdx++)\n{\n    size_t meshSize = sizeof(AAPLVertex) * tempMeshes[objectIdx].numVerts;\n    bufferSize += meshSize;\n}\n\n_vertexBuffer = [_device newBufferWithLength:bufferSize options:0];\n```\n\nFinally, insert each mesh into the container buffer while noting its offset and size in the second buffer:\n\n```objective-c\nfor(int objectIdx = 0; objectIdx < AAPLNumObjects; objectIdx++)\n{\n    \/\/ Store the mesh metadata in the `params` buffer.\n\n    params[objectIdx].numVertices = tempMeshes[objectIdx].numVerts;\n\n    size_t meshSize = sizeof(AAPLVertex) * tempMeshes[objectIdx].numVerts;\n\n    params[objectIdx].startVertex = currentStartVertex;\n\n    \/\/ Pack the current mesh data in the combined vertex buffer.\n\n    AAPLVertex* meshStartAddress = ((AAPLVertex*)_vertexBuffer.contents) + currentStartVertex;\n\n    memcpy(meshStartAddress, tempMeshes[objectIdx].vertices, meshSize);\n\n    currentStartVertex += tempMeshes[objectIdx].numVerts;\n\n    free(tempMeshes[objectIdx].vertices);\n\n    \/\/ Set the other culling and mesh rendering parameters.\n\n    \/\/ Set the position of each object to a unique space in a grid.\n    vector_float2 gridPos = (vector_float2){objectIdx % AAPLGridWidth, objectIdx \/ AAPLGridWidth};\n    params[objectIdx].position = gridPos * AAPLObjecDistance;\n\n    params[objectIdx].boundingRadius = AAPLObjectSize \/ 2.0;\n}\n```\n\n### Update the data read by the ICB dynamically\n\nBy culling non-visible vertices from the data fed to the rendering pipeline, you save significant rendering time and effort. To do that, use the same compute kernel that encodes the ICB’s commands to continually update the ICB’s data buffers:\n\n```metal\n\/\/ Check whether the object at 'objectIndex' is visible and set draw parameters if so.\n\/\/ Otherwise, reset the command.\nkernel void\ncullMeshesAndEncodeCommands(uint                         objectIndex   [[ thread_position_in_grid ]],\n                            constant AAPLFrameState     *frame_state   [[ buffer(AAPLKernelBufferIndexFrameState) ]],\n                            device AAPLObjectPerameters *object_params [[ buffer(AAPLKernelBufferIndexObjectParams)]],\n                            device AAPLVertex           *vertices      [[ buffer(AAPLKernelBufferIndexVertices) ]],\n                            device ICBContainer         *icb_container [[ buffer(AAPLKernelBufferIndexCommandBufferContainer) ]])\n{\n    float2 worldObjectPostion  = frame_state->translation + object_params[objectIndex].position;\n    float2 clipObjectPosition  = frame_state->aspectScale * AAPLViewScale * worldObjectPostion;\n\n    const float rightBounds =  1.0;\n    const float leftBounds  = -1.0;\n    const float upperBounds =  1.0;\n    const float lowerBounds = -1.0;\n\n    bool visible = true;\n\n    \/\/ Set the bounding radius in the view space.\n    const float2 boundingRadius = frame_state->aspectScale * AAPLViewScale * object_params[objectIndex].boundingRadius;\n\n    \/\/ Check if the object's bounding circle has moved outside of the view bounds.\n    if(clipObjectPosition.x + boundingRadius.x < leftBounds  ||\n       clipObjectPosition.x - boundingRadius.x > rightBounds ||\n       clipObjectPosition.y + boundingRadius.y < lowerBounds ||\n       clipObjectPosition.y - boundingRadius.y > upperBounds)\n    {\n        visible = false;\n    }\n    \/\/ Get indirect render commnd object from the indirect command buffer given the object's unique\n    \/\/ index to set parameters for drawing (or not drawing) the object.\n    render_command cmd(icb_container->commandBuffer, objectIndex);\n\n    if(visible)\n    {\n        \/\/ Set the buffers and add a draw command.\n        cmd.set_vertex_buffer(frame_state, AAPLVertexBufferIndexFrameState);\n        cmd.set_vertex_buffer(object_params, AAPLVertexBufferIndexObjectParams);\n        cmd.set_vertex_buffer(vertices, AAPLVertexBufferIndexVertices);\n\n        cmd.draw_primitives(primitive_type::triangle,\n                            object_params[objectIndex].startVertex,\n                            object_params[objectIndex].numVertices, 1,\n                            objectIndex);\n    }\n    \n    \/\/ If the object isn't visible, Metal doesn't set a draw command as long as the app resets\n    \/\/ the indirect command buffer commands with a blit encoder before encoding the draw.\n}\n```\n\nThe parallel nature of the GPU partitions the compute task for you, resulting in multiple offscreen meshes getting culled concurrently.\n\n### Pass an ICB to a compute kernel using an argument buffer\n\nTo get an ICB on the GPU and make it accessible to a compute kernel, you pass it through an argument buffer, as follows:\n\nDefine the container argument buffer as a structure that contains one member, the ICB:\n\n```metal\n\/\/ This is the argument buffer that contains the ICB.\nstruct ICBContainer\n{\n    command_buffer commandBuffer [[ id(AAPLArgumentBufferIDCommandBuffer) ]];\n};\n```\n\nEncode the ICB into the argument buffer:\n\n```objective-c\nid<MTLArgumentEncoder> argumentEncoder =\n    [GPUCommandEncodingKernel newArgumentEncoderWithBufferIndex:AAPLKernelBufferIndexCommandBufferContainer];\n\n_icbArgumentBuffer = [_device newBufferWithLength:argumentEncoder.encodedLength\n                                       options:MTLResourceStorageModeShared];\n_icbArgumentBuffer.label = @\"ICB Argument Buffer\";\n\n[argumentEncoder setArgumentBuffer:_icbArgumentBuffer offset:0];\n\n[argumentEncoder setIndirectCommandBuffer:_indirectCommandBuffer\n                                  atIndex:AAPLArgumentBufferIDCommandBuffer];\n```\n\nPass the ICB (`_indirectCommandBuffer`) to the kernel by setting the argument buffer on the kernel’s compute command encoder:\n\n```objective-c\n[computeEncoder setBuffer:_icbArgumentBuffer offset:0 atIndex:AAPLKernelBufferIndexCommandBufferContainer];\n```\n\nBecause you pass the ICB through an argument buffer, standard argument buffer rules apply. Call `useResource` on the ICB to tell Metal to prepare its use:\n\n```objective-c\n[computeEncoder useResource:_indirectCommandBuffer usage:MTLResourceUsageWrite];\n```\n\n### Encode and optimize ICB commands\n\nReset the ICB’s commands to their initial before beginning encoding:\n\n```objective-c\n[resetBlitEncoder resetCommandsInBuffer:_indirectCommandBuffer\n                              withRange:NSMakeRange(0, AAPLNumObjects)];\n```\n\nEncode the ICB’s commands by dispatching the compute kernel:\n\n```objective-c\n[computeEncoder dispatchThreads:MTLSizeMake(AAPLNumObjects, 1, 1)\n          threadsPerThreadgroup:MTLSizeMake(threadExecutionWidth, 1, 1)];\n```\n\nOptimize your ICB commands to remove empty commands or redundant state by calling `optimizeIndirectCommandBuffer:withRange:`:\n\n```objective-c\n[optimizeBlitEncoder optimizeIndirectCommandBuffer:_indirectCommandBuffer\n                                         withRange:NSMakeRange(0, AAPLNumObjects)];\n```\n\nThis sample optimizes ICB commands because redundant state results from the kernel setting a buffer for each draw, and encoding empty commands for each invisible object. By removing the empty commands, you can free up a significant number of blank spaces in the command buffer that Metal otherwise spends time skipping at runtime.\n\n\n\n### Execute the ICB\n\nDraw the onscreen meshes by calling `executeCommandsInBuffer` on your render command encoder:\n\n```objective-c\n[renderEncoder executeCommandsInBuffer:_indirectCommandBuffer withRange:NSMakeRange(0, AAPLNumObjects)];\n```\n\nWhile you can encode an ICB’s commands in a compute kernel, you call `executeCommandsInBuffer` from your host app to encode a single command that contains all of the commands encoded by the compute kernel. By doing this, you choose the queue and buffer that the ICB’s commands go into. When you call `executeIndirectCommandBuffer` determines the placement of the ICB’s commands among any other commands you may also encode in the same buffer.\n\n## Indirect command buffers\n\n- **Creating an indirect command buffer**: Configure a descriptor to specify the properties of an indirect command buffer.\n- **Specifying drawing and dispatch arguments indirectly**: Use indirect commands if you don’t know your draw or dispatch call arguments when you encode the command.\n- **Encoding indirect command buffers on the CPU**: Reduce CPU overhead and simplify your command execution by reusing commands.\n- **MTLIndirectCommandBuffer**: A command buffer containing reusable commands, encoded either on the CPU or GPU.\n- **MTLIndirectCommandBufferDescriptor**: A configuration you create to customize an indirect command buffer.\n- **MTLIndirectCommandType**: The types of commands that you can encode into the indirect command buffer.\n- **MTLIndirectCommandBufferExecutionRange**: A range of commands in an indirect command buffer.\n- **MTLIndirectCommandBufferExecutionRangeMake(_:_:)**: Creates a command execution range.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Configure a descriptor to specify the properties of an indirect command buffer.",
          "name" : "Creating an indirect command buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-an-indirect-command-buffer"
        },
        {
          "description" : "Use indirect commands if you don’t know your draw or dispatch call arguments when you encode the command.",
          "name" : "Specifying drawing and dispatch arguments indirectly",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/specifying-drawing-and-dispatch-arguments-indirectly"
        },
        {
          "description" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "name" : "Encoding indirect command buffers on the CPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
        },
        {
          "description" : "A command buffer containing reusable commands, encoded either on the CPU or GPU.",
          "name" : "MTLIndirectCommandBuffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBuffer"
        },
        {
          "description" : "A configuration you create to customize an indirect command buffer.",
          "name" : "MTLIndirectCommandBufferDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBufferDescriptor"
        },
        {
          "description" : "The types of commands that you can encode into the indirect command buffer.",
          "name" : "MTLIndirectCommandType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandType"
        },
        {
          "description" : "A range of commands in an indirect command buffer.",
          "name" : "MTLIndirectCommandBufferExecutionRange",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBufferExecutionRange"
        },
        {
          "description" : "Creates a command execution range.",
          "name" : "MTLIndirectCommandBufferExecutionRangeMake(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBufferExecutionRangeMake(_:_:)"
        }
      ],
      "title" : "Indirect command buffers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Encoding indirect command buffers on the GPU",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-gpu"
}