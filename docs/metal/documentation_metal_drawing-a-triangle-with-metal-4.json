{
  "abstract" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
  "codeExamples" : [
    {
      "code" : "if ([view.device supportsFamily:MTLGPUFamilyMetal4]) {\n    \/\/ Create a Metal 4 renderer instance for the app's lifetime.\n    renderer = [[Metal4Renderer alloc] initWithMetalKitView:view];\n\n    return self;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Create a Metal renderer instance for the app's lifetime.\nrenderer = [[MetalRenderer alloc] initWithMetalKitView:view];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Retrieve the Metal device instance from the view.\n_device = view.device;\n\n\/\/ Create a command queue from the device.\ncommandQueue = [self.device newMTL4CommandQueue];\n\n\/\/ Create the command buffer from the device.\ncommandBuffer = [self.device newCommandBuffer];\n\n\/\/ Create a default library instance, which contains the project's shaders.\n_defaultLibrary = [self.device newDefaultLibrary];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Create the essential resources.\ntriangleVertexBuffers = [self makeTriangleDataBuffers:kMaxFramesInFlight];\nargumentTable = [self makeArgumentTable];\nresidencySet = [self makeResidencySet];\ncommandAllocators = [self makeCommandAllocators:kMaxFramesInFlight];\n\nviewportSizeBuffer = [self.device newBufferWithLength:sizeof(viewportSize)\n                                              options:MTLResourceStorageModeShared];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ The number of frames the renderer works with at the same time.\n#define kMaxFramesInFlight 3",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ An array of buffers, each of which stores the geometric position and color\n\/\/\/ data of a triangle's three vertices for one frame.\n\/\/\/\n\/\/\/ The renderer sends one of these buffers, per frame, as an input to the vertex shader.\nNSArray<id<MTLBuffer>> *triangleVertexBuffers;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Creates new buffer instances for triangle data from the renderer's device\n\/\/\/ and returns them in a new array.\n\/\/\/ - Parameter count: The number of buffers the method creates.\n- (nonnull NSArray<id<MTLBuffer>> *) makeTriangleDataBuffers:(NSUInteger) count\n{\n    NSMutableArray<id<MTLBuffer>> *bufferArray;\n    bufferArray = [[NSMutableArray alloc] initWithCapacity:count];\n    for (uint bufferNumber = 0; bufferNumber < count; bufferNumber += 1) {\n        id<MTLBuffer> buffer;\n        \/\/ Create the buffer that stores the triangle's vertex data.\n        buffer = [self.device newBufferWithLength:sizeof(TriangleData)\n                                          options:MTLResourceStorageModeShared];\n\n        [self check:buffer name:@\"buffer\" number:bufferArray.count error:nil];\n        [bufferArray addObject:buffer];\n    }\n\n    return bufferArray;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Creates a new argument table from the renderer's device that stores two arguments.\n- (id<MTL4ArgumentTable>) makeArgumentTable\n{\n    NSError *error = nil;\n\n    \/\/ Configure the settings for a new argument table with two buffer bindings.\n    MTL4ArgumentTableDescriptor *argumentTableDescriptor;\n    argumentTableDescriptor = [MTL4ArgumentTableDescriptor new];\n    argumentTableDescriptor.maxBufferBindCount = 2;\n\n    \/\/ Create the argument table.\n    id<MTL4ArgumentTable> argumentTable;\n    argumentTable = [self.device newArgumentTableWithDescriptor:argumentTableDescriptor\n                                                          error:&error];\n\n    [self check:argumentTable name:@\"argument table\" number:-1 error:error];\n    return argumentTable;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Set the frame number to `0`, which sets up the first frame to get the number `1`.\nframeNumber = 0;\n\n\/\/ Create a shared event that starts at zero.\nsharedEvent = [self.device newSharedEvent];\nsharedEvent.signaledValue = frameNumber;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Add the viewport size buffer to the residency set.\n[residencySet addAllocation:viewportSizeBuffer];\n\n\/\/ Add the buffers that store the triangle vertex data to the residency set.\nfor (id<MTLBuffer> triangleVertexBuffer in triangleVertexBuffers) {\n    [residencySet addAllocation:triangleVertexBuffer];\n}\n\n\/\/ Apply the updates to the residency set.\n[residencySet commit];\n\n\/\/ Make the resources in the long-term residency set accessible to the GPU\n\/\/ when it runs any command buffer the app submits to the command queue.\n[commandQueue addResidencySet:residencySet];\n\n\/\/ Make the resources in the view's residency set accessible to the GPU\n\/\/ when it runs any command buffer the app submits to the command queue.\n[commandQueue addResidencySet:((CAMetalLayer *)view.layer).residencySet];\n\n\/\/ Initialize the renderer with the view's drawable size.\n[self updateViewportSize:view.drawableSize];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Creates the renderer's pipeline state that works with a specific pixel format.\n\/\/\/\n\/\/\/ - Parameter colorPixelFormat: A pixel size and layout configuration the\n\/\/\/ method applies to the render pipeline it compiles.\n- (id<MTLRenderPipelineState>) compileRenderPipeline:(MTLPixelFormat) colorPixelFormat\n{\n    \/\/\/ A Metal 4 compiler instance with a default configuration.\n    id<MTL4Compiler> compiler = [self createDefaultMetalCompiler];\n\n    \/\/\/ A configuration for the render pipeline the method compiles.\n    MTL4RenderPipelineDescriptor* descriptor;\n    descriptor = [self configureRenderPipeline: colorPixelFormat];\n\n    \/\/\/ An optional configuration that stores references to binary archives.\n    MTL4CompilerTaskOptions *compilerTaskOptions;\n    compilerTaskOptions = [self configureCompilerTaskOptions];\n\n    \/\/\/ A reference to an error instance the compiler assigns\n    \/\/\/ if it can't compile the render pipeline.\n    NSError *error = nil;\n\n    \/\/ Compile a render pipeline state.\n\n    id<MTLRenderPipelineState> renderPipelineState;\n    renderPipelineState = [compiler newRenderPipelineStateWithDescriptor:descriptor\n                                                     compilerTaskOptions:compilerTaskOptions\n                                                                   error:&error];\n\n    \/\/ Verify the compiler creates the pipeline state successfully.\n    \/\/ Xcode turns on Metal API Validation by default for debug builds.\n    NSAssert(nil != renderPipelineState,\n             @\"The compiler can't create a pipeline state due to: %@\\n%@\", error,\n             @\"Check the descriptor's configuration and turn on Metal API validation for more information.\"\n             );\n\n    return renderPipelineState;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Creates and configures the renderer's only render pipeline.\n\/\/\/\n\/\/\/ - Parameter colorPixelFormat: An output data format that the new render pipeline produces.\n- (MTL4RenderPipelineDescriptor*) configureRenderPipeline:(MTLPixelFormat) colorPixelFormat\n{\n    MTL4RenderPipelineDescriptor *renderPipelineDescriptor;\n    renderPipelineDescriptor = [MTL4RenderPipelineDescriptor new];\n    renderPipelineDescriptor.label = @\"Basic Metal 4 render pipeline\";\n\n    \/\/ Set the pixel format, the vertex shader, and fragment shader for the configuration.\n    renderPipelineDescriptor.colorAttachments[0].pixelFormat = colorPixelFormat;\n    renderPipelineDescriptor.vertexFunctionDescriptor = [self makeVertexShaderConfiguration];\n    renderPipelineDescriptor.fragmentFunctionDescriptor = [self makeFragmentShaderConfiguration];\n\n    return renderPipelineDescriptor;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Creates a library function descriptor for the app's vertex shader.\n\/\/\/\n\/\/\/ Xcode compiles the `vertexShader` GPU function in the `Shaders.metal` source\n\/\/\/ code file into the app's default library.\n- (MTL4LibraryFunctionDescriptor*) makeVertexShaderConfiguration\n{\n    MTL4LibraryFunctionDescriptor *vertexFunction;\n    vertexFunction = [MTL4LibraryFunctionDescriptor new];\n    vertexFunction.library = self.defaultLibrary;\n    vertexFunction.name = @\"vertexShader\";\n\n    return vertexFunction;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Creates a library function descriptor for the app's fragment shader.\n\/\/\/\n\/\/\/ Xcode compiles the `fragmentShader` GPU function in the `Shaders.metal` source\n\/\/\/ code file into the app's default library.\n- (MTL4LibraryFunctionDescriptor*) makeFragmentShaderConfiguration\n{\n    MTL4LibraryFunctionDescriptor *fragmentFunction;\n    fragmentFunction = [MTL4LibraryFunctionDescriptor new];\n    fragmentFunction.library = self.defaultLibrary;\n    fragmentFunction.name = @\"fragmentShader\";\n\n    return fragmentFunction;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Increment the frame number for this frame.\nframeNumber += 1;\n\nconst uint32_t frameIndex = frameNumber % kMaxFramesInFlight;\nNSString *label = [NSString stringWithFormat:@\"Frame: %llu\", frameNumber];\n\n\nif (frameNumber >= kMaxFramesInFlight) {\n    [self waitOnSharedEvent:sharedEvent\n             forEarlierFrame:frameNumber - kMaxFramesInFlight];\n}\n\n\/\/ Prepare to use or reuse the allocator by resetting it.\nid<MTL4CommandAllocator> frameAllocator = commandAllocators[frameIndex];\n[frameAllocator reset];\n\n\/\/ Prepare to use or reuse the command buffer for the frame's commands.\n[commandBuffer beginCommandBufferWithAllocator:frameAllocator];\ncommandBuffer.label = label;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Pauses the CPU when the device is rendering a previous frame that needs the resources\n\/\/\/ that the renderer is about to reuse for a frame.\n\/\/\/\n\/\/\/ The method adds a command that waits for a signal from the command queue that\n\/\/\/ indicates when the Metal device is done rendering an earlier frame.\n\/\/\/ This signal means the renderer can safely reuse the resources for that prior frame.\n- (void) waitOnSharedEvent:(id<MTLSharedEvent>) sharedEvent\n            forEarlierFrame:(uint64_t) earlierFrameNumber\n{\n    const uint64_t tenMilliseconds = 10;\n\n    \/\/ Wait for the GPU to finish rendering the frame that's\n    \/\/ `kMaxFramesInFlight` before this one, and then proceed to the next step.\n    BOOL beforeTimeout = [sharedEvent waitUntilSignaledValue:earlierFrameNumber\n                                                   timeoutMS:tenMilliseconds];\n\n    if (false == beforeTimeout) {\n        NSLog(@\"No signal from frame %llu to shared event after %llums\",\n              earlierFrameNumber, tenMilliseconds);\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Create a render pass encoder from the command buffer with the view's configuration.\nid<MTL4RenderCommandEncoder> renderPassEncoder;\nMTL4RenderPassDescriptor *configuration = view.currentMTL4RenderPassDescriptor;\nrenderPassEncoder = [commandBuffer renderCommandEncoderWithDescriptor:configuration];\nrenderPassEncoder.label = label;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Configures the viewport for a render pass.\n\/\/\/\n\/\/\/ The method sets the size to the same dimensions as the view's drawable region.\n\/\/\/ - Parameter renderPassEncoder: An encoder for a render pass.\n- (void) setViewportSize:(simd_uint2) size\n        forRenderEncoder:(id<MTL4RenderCommandEncoder>) renderPassEncoder\n{\n    \/\/ Configure the viewport with the size of the drawable region.\n    MTLViewport viewPort;\n    viewPort.originX = 0.0;\n    viewPort.originY = 0.0;\n    viewPort.znear = 0.0;\n    viewPort.zfar = 1.0;\n    viewPort.width = (double)size.x;\n    viewPort.height = (double)size.y;\n\n    [renderPassEncoder setViewport:viewPort];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Configures the arguments for a render pass.\n\/\/\/\n\/\/\/ - Parameter renderPassEncoder: An encoder for a render pass.\n\/\/\/\n\/\/\/ The draw command in every render pass this app creates needs two arguments:\n\/\/\/ - The vertex position and color data for a triangle\n\/\/\/ - The size of the app's current viewport\n\/\/\/\n\/\/\/ The triangle data changes every frame.\n\/\/\/ The size of the viewport can change, but typically remains the same until a\n\/\/\/ person changes the size of the app or its window.\n- (void) setRenderPassArguments:(id<MTL4RenderCommandEncoder>) renderPassEncoder\n                       forFrame:(NSUInteger) frameNumber\n                           with:(id<MTL4ArgumentTable>) argumentTable\n                   vertexBuffer:(id<MTLBuffer>) vertexBuffer\n                   viewPortSize:(id<MTLBuffer>) viewportSizeBuffer\n{\n    configureVertexDataForBuffer(frameNumber, vertexBuffer.contents);\n\n    \/\/ Add the buffer with the triangle data to the argument table.\n    [argumentTable setAddress:vertexBuffer.gpuAddress\n                      atIndex:InputBufferIndexForVertexData];\n\n    \/\/ Add the buffer with the viewport's size to the argument table.\n    [argumentTable setAddress:viewportSizeBuffer.gpuAddress\n                      atIndex:InputBufferIndexForViewportSize];\n\n    \/\/ Assign the argument table to the encoder.\n    [renderPassEncoder setArgumentTable:argumentTable\n                               atStages:MTLRenderStageVertex];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Configures an equilateral triangle's vertex data\n\/\/\/ and copies the bytes into a Metal buffer's pointer.\n\/\/\/\n\/\/\/ - Parameters:\n\/\/\/   - rotationInDegrees: An angle of rotation for the triangle, in degrees.\n\/\/\/   - bufferContents: A pointer from an `MTLBuffer` instance's `contents` property.\nvoid configureVertexDataForBuffer(long rotationInDegrees,\n                                  void *bufferContents)\n{\n    const short radius = 350;\n    const short angle = rotationInDegrees % 360;\n\n    TriangleData triangleData;\n    triangleRedGreenBlue(radius, (float)angle, &triangleData);\n\n    \/\/ Update the buffer that stores the triangle data.\n    memcpy(bufferContents, &triangleData, sizeof(TriangleData));\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Draw the triangle.\n[renderPassEncoder drawPrimitives:MTLPrimitiveTypeTriangle\n                      vertexStart:0\n                      vertexCount:3];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Finalize the render pass.\n[renderPassEncoder endEncoding];\n\n\/\/ Submit the command buffer to the GPU.\n[commandBuffer endCommandBuffer];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Sends a command buffer to run on a Metal device by committing it to a\n\/\/\/ command queue.\n\/\/\/\n\/\/\/ - Parameters:\n\/\/\/   - commandBuffer: A command buffer with work for `view` that's ready to submit.\n\/\/\/   - commandQueue: A command queue the method submits the command buffer to.\n\/\/\/   - view: A MetalKit view instance, which provides a render target\n\/\/\/ with its `currentDrawable` property.\n- (void) submitCommandBuffer:(id<MTL4CommandBuffer>) commandBuffer\n              toCommandQueue:(id<MTL4CommandQueue>) commandQueue\n                     forView:(nonnull MTKView *) view\n{\n    \/\/\/ A drawable from the view that the method renders the frame to.\n    id<CAMetalDrawable> currentDrawable = view.currentDrawable;\n\n    \/\/ Instruct the queue to wait until the drawable is ready to receive output from the render pass.\n    [commandQueue waitForDrawable:currentDrawable];\n\n    \/\/ Run the command buffer on the GPU by submitting it the Metal device's queue.\n    [commandQueue commit:&commandBuffer count:1];\n\n    \/\/ Notify the drawable that the GPU is done running the render pass.\n    [commandQueue signalDrawable:currentDrawable];\n\n    \/\/ Instruct the drawable to show itself on the device's display when the render pass completes.\n    [currentDrawable present];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Signal when the GPU finishes rendering this frame with a shared event.\n[commandQueue signalEvent:sharedEvent value:frameNumber];",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "7dcfbd45f13bf08253e0540b5a08c07a1cb90fdafbb62d9158dcab1b8d4796c3",
  "crawledAt" : "2025-12-02T19:37:28Z",
  "id" : "45B96F8F-A797-4ECD-88B1-7AE6DD223E0C",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nThis sample demonstrates how to render imagery by sending commands to the GPU with the Metal 4 API, and relates to WWDC25 session 205: [https:\/\/developer.apple.com\/wwdc25\/205].\n\nMultiple times a second, the sample’s app displays a colorful triangle by:\n\nApps can give a person the impression of motion by rendering and displaying frames at a sufficient frequency, typically at 60 frames or more per second.\n\nThe renderer encodes one frame at a time, and has three frames of content in flight at the same time. Starting when the first frame is visible on the display, the renderer is continually managing three frames at once:\n\nThe renderer manages the frames as each progresses through its three lifetime phases. The diagram below illustrates how the first frames move through time, where each column represents a snapshot of the app’s current frames and their states:\n\n\n\n### Create a renderer\n\nThe sample implements two separate renderer classes and the app creates a new instance of the one that’s appropriate for the system it’s running on. The two classes are:\n\nThe app checks whether the system supports Metal 4 by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsFamily(_:)] in the `MetalKitViewDelegate` class.\n\nThe app creates a Metal 4 renderer if the operating system supports [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLGPUFamily\/metal4]; otherwise it creates an instance of the other renderer, which supports previous versions of Metal.\n\nThe two renderers are identical in their behavior, but they use different Metal API generations to submit the same render commands to the GPU.\n\n### Create long-term resources\n\nThe Metal 4 renderer’s initializer starts by creating an instance of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue], [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer], and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLLibrary] with the view’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice].\n\nGenerally, you send work to the GPU by encoding commands into a command buffer, and then submitting one or more command buffers to a queue. Your app can have multiple command buffers and queues, but the sample’s `Metal4Renderer` class needs only one of each.\n\nThe initializer creates other resources the renderer needs by calling helper methods.\n\nThe renderer defines `kMaxFramesInFlight` near the top of its primary source file.\n\nThe sample applies this constant when it creates separate instances of the resources the renderer needs for each in-flight frame, which includes the buffers that store a triangle’s geometry and color information.\n\nMost of the helper methods that create the renderer’s long-term resources at launch are relatively short. For example, the `makeTriangleDataBuffers:` method creates `kMaxFramesInFlight` instances of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] because each in-flight frame needs a separate buffer to store its triangle vertex data.\n\nCreating a separate buffer instance for each in-flight frame eliminates the possibility of modifying a buffer for a later frame before or as the GPU reads from the same buffer to render an earlier frame.\n\nThe `makeArgumentTable` method creates just a single argument table that the renderer can reuse each time it encodes render commands into a render pass the GPU eventually runs. You set the resource bindings for any pass you encode with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer], including compute and render passes, by configuring an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTable] instance.\n\nEach argument table can store bindings to instances of various resource types, including:\n\nFor this sample, the argument table only needs to store two buffer bindings, one for the buffer that stores vertex triangle data, and another buffer that stores the viewport’s width and height.\n\nThe `makeResidencySet` and `makeCommandAllocators:` methods create a single [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLResidencySet] instance, and an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator] instance for each in-flight frame, respectively.\n\nThe end of the initializer configures the renderer’s initial state so that it’s ready to render the first frame when the system requests it.\n\nThe initializer adds two residency sets to the renderer’s command queue:\n\nSee [doc:\/\/com.apple.metal\/documentation\/Metal\/simplifying-gpu-resource-management-with-residency-sets] for more information about working with residency sets.\n\n### Create a render pipeline\n\nThe renderer’s `compileRenderPipeline:` method creates a render pipeline by configuring an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderPipelineDescriptor] instance and passing it to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4Compiler] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4Compiler\/newRenderPipelineStateWithDescriptor:compilerTaskOptions:error:] method.\n\nThe renderer’s `configureRenderPipeline:` method sets the various properties the compiler needs to create a render pipeline state.\n\nThe `makeVertexShaderConfiguration` helper method creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4LibraryFunctionDescriptor] instance that refers to the renderer’s vertex shader.\n\nSimilarly, the `makeFragmentShaderConfiguration` helper method creates another function descriptor instance that refers to the renderer’s fragment shader.\n\n### Draw a frame by encoding a render pass\n\nThe app is ready to render frames after its renderer creates and sets up all its resources at launch, including data buffers and a render pipeline state. Each time the system calls the app’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] method, its [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate] implementation calls the renderer’s `renderFrameToView:` method, which encodes and runs the commands that render the frame with the following steps:\n\nThe remaining sections explain the important details of these steps.\n\n### Prepare a command buffer\n\nThe renderer uses the same [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer] instance to render every frame. You can reuse a Metal 4 command buffer instance immediately after submitting it to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue]. This is because a command allocator stores a record of the command buffer’s contents when you submit it to a queue.\n\nThe renderer prepares the command buffer for a new set of commands by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method.\n\nThe renderer reuses an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator] instance the GPU no longer needs by rotating through the `kMaxFramesInFlight` allocators it creates at launch.\n\nThe renderer ensures the next allocator in the rotation is available by calling the `waitOnSharedEvent:forEarlierFrame:` method. That method calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent\/wait(untilSignaledValue:timeoutMS:)] method of the renderer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] instance, which can potentially block the caller for 10 milliseconds before it returns.\n\nThe command queue updates the shared event after the Metal device finishes rendering the previous frame that uses the same allocator, which indicates to this method that it’s now available to reuse. Ideally, the shared event’s method returns immediately because the earlier frame using the allocator is done rendering and no longer needs it.\n\n### Create an encoder for a render pass\n\nThe `renderFrameToView:` method creates a render command encoder by retrieving an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderPassDescriptor] instance from the view’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/currentMTL4RenderPassDescriptor] property and passing it to the command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/makeRenderCommandEncoder(descriptor:options:)] method. The view’s property represents a valid configuration for a render pass to render a frame in a format that’s compatible with that view.\n\nThe command buffer’s factory method returns an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder] instance, which provides methods that configure a render pass and encode the commands for that pass.\n\nThe method also gives the render encoder a unique name that can help you identify its render pass from other passes in Metal debugger. For more information about Metal debugger and inspecting passes, see:\n\n### Configure the viewport for the render pass\n\nThe renderer’s `setViewport` method configures an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLViewport] and passes it to the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder\/setViewport(_:)]method.\n\nThe method configures the viewport’s 2D size by setting the `x` and `y` members to the dimensions of the app’s view, in pixels.\n\n### Configure any arguments for the render pass\n\nThe renderer’s `setRenderPassArguments:` method configures two arguments for the render pass, both of which are [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instances.\n\nThe method retrieves the next triangle vertex buffer in the rotation. Each render pass needs its own copy of triangle vertex data because the data for each frame is unique, and the GPU needs access to each frame’s input data until it finishes rendering that frame. The renderer tracks and rotates through `kMaxFramesInFlight` buffers of triangle vertex data in an array, similar to the command allocators because each frame has slightly different coordinates for the triangle as it rotates.\n\nThe method calls the renderer’s `configureVertexDataForBuffer:` method, which calculates the positions of the triangle’s vertices by applying a rotation angle and then copies the vertex data into the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer].\n\n### Encode draw commands\n\nThe renderer draws exactly one triangle with a single call to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder\/drawPrimitives(primitiveType:vertexStart:vertexCount:)]:\n\nThis renderer only needs one draw command, but yours can encode multiple drawing commands in a single render pass.\n\n### End the render pass\n\nThe `renderFrameToView:` method marks the conclusion of the render pass by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/endEncoding()] method.\n\nIt then marks the end of the command buffer by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/endCommandBuffer()] method because it only needs to encode a single render pass. However, your app can encode multiple passes of different types in a single command buffer with a series of encoder types, including the following:\n\n### Run the render pass by submitting the command buffer\n\nThe renderer sends the command buffer to run on the GPU in its `submitCommandBufferForView:` method. The method starts by retrieving the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalDrawable] instance the view stores in its [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/currentDrawable] property.\n\nThe method adds the following actions to the renderer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instance, which run on the GPU timeline:\n\nThe Metal device needs to wait until the view’s drawable is available because it stores the output from the render pass and provides the mechanism that updates the content on the display. When the drawable is ready, the GPU runs the single render pass in the command buffer, which saves the results to the drawable’s texture.\n\nThe method concludes by calling the drawable’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDrawable\/present()] method, which instructs the drawable to show its content on the device’s display shortly after it gets the notification from the command queue. The [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDrawable] protocol defines this method, which the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalDrawable] protocol inherits.\n\n### Notify the renderer when a frame’s resources are ready for reuse\n\nThe last command the `renderFrameToView:` method adds to the command queue notifies the renderer when it can reuse this frame’s triangle vertex buffer and command allocator, by signaling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] instance with the current frame number.\n\nFor example, if the `frameNumber` equals `4` and `kMaxFramesInFlight` equals `3`, this signal informs the renderer when its okay to reuse the fourth frame’s resources and apply them for frame seven.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/metal\/drawing-a-triangle-with-metal-4\ncrawled: 2025-12-02T19:37:28Z\n---\n\n# Drawing a triangle with Metal 4\n\n**Sample Code**\n\nRender a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n\n## Overview\n\nThis sample demonstrates how to render imagery by sending commands to the GPU with the Metal 4 API, and relates to WWDC25 session 205: [https:\/\/developer.apple.com\/wwdc25\/205].\n\n\n\nMultiple times a second, the sample’s app displays a colorful triangle by:\n\n1. Updating the vertex data for the triangle\n2. Encoding draw commands as a *frame* of visual content\n3. Running the draw commands on a Metal device that represents an Apple silicon GPU\n4. Updating the display after the GPU finishes rendering that frame\n\nApps can give a person the impression of motion by rendering and displaying frames at a sufficient frequency, typically at 60 frames or more per second.\n\nThe renderer encodes one frame at a time, and has three frames of content in flight at the same time. Starting when the first frame is visible on the display, the renderer is continually managing three frames at once:\n\n- The first frame is in its final lifetime phase as the frame that’s visible to a person on the device’s display.\n- The second frame is in its second lifetime phase where the GPU renders it in a *render pass*, which is the collection of render commands that draw the triangle.\n- The third frame is in its first lifetime phase where the renderer encodes the draw commands for the next render pass by using the Metal API on the CPU.\n\nThe renderer manages the frames as each progresses through its three lifetime phases. The diagram below illustrates how the first frames move through time, where each column represents a snapshot of the app’s current frames and their states:\n\n\n\n### Create a renderer\n\nThe sample implements two separate renderer classes and the app creates a new instance of the one that’s appropriate for the system it’s running on. The two classes are:\n\n- `Metal4Renderer`, a renderer class that works with the Metal 4 API\n- `MetalRenderer`, a renderer class that works with previous Metal API versions\n\nThe app checks whether the system supports Metal 4 by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsFamily(_:)] in the `MetalKitViewDelegate` class.\n\n```objective-c\nif ([view.device supportsFamily:MTLGPUFamilyMetal4]) {\n    \/\/ Create a Metal 4 renderer instance for the app's lifetime.\n    renderer = [[Metal4Renderer alloc] initWithMetalKitView:view];\n\n    return self;\n}\n```\n\nThe app creates a Metal 4 renderer if the operating system supports [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLGPUFamily\/metal4]; otherwise it creates an instance of the other renderer, which supports previous versions of Metal.\n\n```objective-c\n\/\/ Create a Metal renderer instance for the app's lifetime.\nrenderer = [[MetalRenderer alloc] initWithMetalKitView:view];\n```\n\nThe two renderers are identical in their behavior, but they use different Metal API generations to submit the same render commands to the GPU.\n\n\n\n### Create long-term resources\n\nThe Metal 4 renderer’s initializer starts by creating an instance of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue], [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer], and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLLibrary] with the view’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice].\n\n```objective-c\n\/\/ Retrieve the Metal device instance from the view.\n_device = view.device;\n\n\/\/ Create a command queue from the device.\ncommandQueue = [self.device newMTL4CommandQueue];\n\n\/\/ Create the command buffer from the device.\ncommandBuffer = [self.device newCommandBuffer];\n\n\/\/ Create a default library instance, which contains the project's shaders.\n_defaultLibrary = [self.device newDefaultLibrary];\n```\n\nGenerally, you send work to the GPU by encoding commands into a command buffer, and then submitting one or more command buffers to a queue. Your app can have multiple command buffers and queues, but the sample’s `Metal4Renderer` class needs only one of each.\n\nThe initializer creates other resources the renderer needs by calling helper methods.\n\n```objective-c\n\/\/ Create the essential resources.\ntriangleVertexBuffers = [self makeTriangleDataBuffers:kMaxFramesInFlight];\nargumentTable = [self makeArgumentTable];\nresidencySet = [self makeResidencySet];\ncommandAllocators = [self makeCommandAllocators:kMaxFramesInFlight];\n\nviewportSizeBuffer = [self.device newBufferWithLength:sizeof(viewportSize)\n                                              options:MTLResourceStorageModeShared];\n```\n\nThe renderer defines `kMaxFramesInFlight` near the top of its primary source file.\n\n```objective-c\n\/\/\/ The number of frames the renderer works with at the same time.\n#define kMaxFramesInFlight 3\n```\n\nThe sample applies this constant when it creates separate instances of the resources the renderer needs for each in-flight frame, which includes the buffers that store a triangle’s geometry and color information.\n\n```objective-c\n\/\/\/ An array of buffers, each of which stores the geometric position and color\n\/\/\/ data of a triangle's three vertices for one frame.\n\/\/\/\n\/\/\/ The renderer sends one of these buffers, per frame, as an input to the vertex shader.\nNSArray<id<MTLBuffer>> *triangleVertexBuffers;\n```\n\nMost of the helper methods that create the renderer’s long-term resources at launch are relatively short. For example, the `makeTriangleDataBuffers:` method creates `kMaxFramesInFlight` instances of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] because each in-flight frame needs a separate buffer to store its triangle vertex data.\n\n```objective-c\n\/\/\/ Creates new buffer instances for triangle data from the renderer's device\n\/\/\/ and returns them in a new array.\n\/\/\/ - Parameter count: The number of buffers the method creates.\n- (nonnull NSArray<id<MTLBuffer>> *) makeTriangleDataBuffers:(NSUInteger) count\n{\n    NSMutableArray<id<MTLBuffer>> *bufferArray;\n    bufferArray = [[NSMutableArray alloc] initWithCapacity:count];\n    for (uint bufferNumber = 0; bufferNumber < count; bufferNumber += 1) {\n        id<MTLBuffer> buffer;\n        \/\/ Create the buffer that stores the triangle's vertex data.\n        buffer = [self.device newBufferWithLength:sizeof(TriangleData)\n                                          options:MTLResourceStorageModeShared];\n\n        [self check:buffer name:@\"buffer\" number:bufferArray.count error:nil];\n        [bufferArray addObject:buffer];\n    }\n\n    return bufferArray;\n}\n```\n\nCreating a separate buffer instance for each in-flight frame eliminates the possibility of modifying a buffer for a later frame before or as the GPU reads from the same buffer to render an earlier frame.\n\nThe `makeArgumentTable` method creates just a single argument table that the renderer can reuse each time it encodes render commands into a render pass the GPU eventually runs. You set the resource bindings for any pass you encode with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer], including compute and render passes, by configuring an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTable] instance.\n\n```objective-c\n\/\/\/ Creates a new argument table from the renderer's device that stores two arguments.\n- (id<MTL4ArgumentTable>) makeArgumentTable\n{\n    NSError *error = nil;\n\n    \/\/ Configure the settings for a new argument table with two buffer bindings.\n    MTL4ArgumentTableDescriptor *argumentTableDescriptor;\n    argumentTableDescriptor = [MTL4ArgumentTableDescriptor new];\n    argumentTableDescriptor.maxBufferBindCount = 2;\n\n    \/\/ Create the argument table.\n    id<MTL4ArgumentTable> argumentTable;\n    argumentTable = [self.device newArgumentTableWithDescriptor:argumentTableDescriptor\n                                                          error:&error];\n\n    [self check:argumentTable name:@\"argument table\" number:-1 error:error];\n    return argumentTable;\n}\n```\n\nEach argument table can store bindings to instances of various resource types, including:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTensor]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerState]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructure]\n\nFor this sample, the argument table only needs to store two buffer bindings, one for the buffer that stores vertex triangle data, and another buffer that stores the viewport’s width and height.\n\n\n\nThe `makeResidencySet` and `makeCommandAllocators:` methods create a single [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLResidencySet] instance, and an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator] instance for each in-flight frame, respectively.\n\nThe end of the initializer configures the renderer’s initial state so that it’s ready to render the first frame when the system requests it.\n\n```objective-c\n\/\/ Set the frame number to `0`, which sets up the first frame to get the number `1`.\nframeNumber = 0;\n\n\/\/ Create a shared event that starts at zero.\nsharedEvent = [self.device newSharedEvent];\nsharedEvent.signaledValue = frameNumber;\n```\n\nThe initializer adds two residency sets to the renderer’s command queue:\n\n- The long-term residency set, which the renderer configures to track all of its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instances\n- The view’s residency set, which MetalKit configures\n\n```objective-c\n\/\/ Add the viewport size buffer to the residency set.\n[residencySet addAllocation:viewportSizeBuffer];\n\n\/\/ Add the buffers that store the triangle vertex data to the residency set.\nfor (id<MTLBuffer> triangleVertexBuffer in triangleVertexBuffers) {\n    [residencySet addAllocation:triangleVertexBuffer];\n}\n\n\/\/ Apply the updates to the residency set.\n[residencySet commit];\n\n\/\/ Make the resources in the long-term residency set accessible to the GPU\n\/\/ when it runs any command buffer the app submits to the command queue.\n[commandQueue addResidencySet:residencySet];\n\n\/\/ Make the resources in the view's residency set accessible to the GPU\n\/\/ when it runs any command buffer the app submits to the command queue.\n[commandQueue addResidencySet:((CAMetalLayer *)view.layer).residencySet];\n\n\/\/ Initialize the renderer with the view's drawable size.\n[self updateViewportSize:view.drawableSize];\n```\n\nSee [doc:\/\/com.apple.metal\/documentation\/Metal\/simplifying-gpu-resource-management-with-residency-sets] for more information about working with residency sets.\n\n### Create a render pipeline\n\nThe renderer’s `compileRenderPipeline:` method creates a render pipeline by configuring an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderPipelineDescriptor] instance and passing it to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4Compiler] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4Compiler\/newRenderPipelineStateWithDescriptor:compilerTaskOptions:error:] method.\n\n```objective-c\n\/\/\/ Creates the renderer's pipeline state that works with a specific pixel format.\n\/\/\/\n\/\/\/ - Parameter colorPixelFormat: A pixel size and layout configuration the\n\/\/\/ method applies to the render pipeline it compiles.\n- (id<MTLRenderPipelineState>) compileRenderPipeline:(MTLPixelFormat) colorPixelFormat\n{\n    \/\/\/ A Metal 4 compiler instance with a default configuration.\n    id<MTL4Compiler> compiler = [self createDefaultMetalCompiler];\n\n    \/\/\/ A configuration for the render pipeline the method compiles.\n    MTL4RenderPipelineDescriptor* descriptor;\n    descriptor = [self configureRenderPipeline: colorPixelFormat];\n\n    \/\/\/ An optional configuration that stores references to binary archives.\n    MTL4CompilerTaskOptions *compilerTaskOptions;\n    compilerTaskOptions = [self configureCompilerTaskOptions];\n\n    \/\/\/ A reference to an error instance the compiler assigns\n    \/\/\/ if it can't compile the render pipeline.\n    NSError *error = nil;\n\n    \/\/ Compile a render pipeline state.\n\n    id<MTLRenderPipelineState> renderPipelineState;\n    renderPipelineState = [compiler newRenderPipelineStateWithDescriptor:descriptor\n                                                     compilerTaskOptions:compilerTaskOptions\n                                                                   error:&error];\n\n    \/\/ Verify the compiler creates the pipeline state successfully.\n    \/\/ Xcode turns on Metal API Validation by default for debug builds.\n    NSAssert(nil != renderPipelineState,\n             @\"The compiler can't create a pipeline state due to: %@\\n%@\", error,\n             @\"Check the descriptor's configuration and turn on Metal API validation for more information.\"\n             );\n\n    return renderPipelineState;\n}\n```\n\nThe renderer’s `configureRenderPipeline:` method sets the various properties the compiler needs to create a render pipeline state.\n\n```objective-c\n\/\/\/ Creates and configures the renderer's only render pipeline.\n\/\/\/\n\/\/\/ - Parameter colorPixelFormat: An output data format that the new render pipeline produces.\n- (MTL4RenderPipelineDescriptor*) configureRenderPipeline:(MTLPixelFormat) colorPixelFormat\n{\n    MTL4RenderPipelineDescriptor *renderPipelineDescriptor;\n    renderPipelineDescriptor = [MTL4RenderPipelineDescriptor new];\n    renderPipelineDescriptor.label = @\"Basic Metal 4 render pipeline\";\n\n    \/\/ Set the pixel format, the vertex shader, and fragment shader for the configuration.\n    renderPipelineDescriptor.colorAttachments[0].pixelFormat = colorPixelFormat;\n    renderPipelineDescriptor.vertexFunctionDescriptor = [self makeVertexShaderConfiguration];\n    renderPipelineDescriptor.fragmentFunctionDescriptor = [self makeFragmentShaderConfiguration];\n\n    return renderPipelineDescriptor;\n}\n```\n\nThe `makeVertexShaderConfiguration` helper method creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4LibraryFunctionDescriptor] instance that refers to the renderer’s vertex shader.\n\n```objective-c\n\/\/\/ Creates a library function descriptor for the app's vertex shader.\n\/\/\/\n\/\/\/ Xcode compiles the `vertexShader` GPU function in the `Shaders.metal` source\n\/\/\/ code file into the app's default library.\n- (MTL4LibraryFunctionDescriptor*) makeVertexShaderConfiguration\n{\n    MTL4LibraryFunctionDescriptor *vertexFunction;\n    vertexFunction = [MTL4LibraryFunctionDescriptor new];\n    vertexFunction.library = self.defaultLibrary;\n    vertexFunction.name = @\"vertexShader\";\n\n    return vertexFunction;\n}\n```\n\nSimilarly, the `makeFragmentShaderConfiguration` helper method creates another function descriptor instance that refers to the renderer’s fragment shader.\n\n```objective-c\n\/\/\/ Creates a library function descriptor for the app's fragment shader.\n\/\/\/\n\/\/\/ Xcode compiles the `fragmentShader` GPU function in the `Shaders.metal` source\n\/\/\/ code file into the app's default library.\n- (MTL4LibraryFunctionDescriptor*) makeFragmentShaderConfiguration\n{\n    MTL4LibraryFunctionDescriptor *fragmentFunction;\n    fragmentFunction = [MTL4LibraryFunctionDescriptor new];\n    fragmentFunction.library = self.defaultLibrary;\n    fragmentFunction.name = @\"fragmentShader\";\n\n    return fragmentFunction;\n}\n```\n\n### Draw a frame by encoding a render pass\n\nThe app is ready to render frames after its renderer creates and sets up all its resources at launch, including data buffers and a render pipeline state. Each time the system calls the app’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] method, its [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate] implementation calls the renderer’s `renderFrameToView:` method, which encodes and runs the commands that render the frame with the following steps:\n\n1. Check that the [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] parameter has valid [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/currentDrawable] and [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/currentMTL4RenderPassDescriptor] properties.\n2. Increment the frame number, which tracks the resources it can reuse from previous frames that don’t need them any longer.\n3. Prepare a command buffer.\n4. Create and configure a render pass encoder.\n5. Set the viewport to the size of the app’s view.\n6. Configure the arguments for the render pass, which in this case are two data buffers.\n7. Encode a draw command for the triangle.\n8. Mark the end of the render pass and the command buffer that contains it.\n9. Run the render pass by submitting the command buffer to the Metal device’s command queue, and display the result when it finishes.\n10. Notify the renderer when it’s safe to reuse this frame’s resources for a new frame by signaling its shared event.\n\nThe remaining sections explain the important details of these steps.\n\n### Prepare a command buffer\n\nThe renderer uses the same [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer] instance to render every frame. You can reuse a Metal 4 command buffer instance immediately after submitting it to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue]. This is because a command allocator stores a record of the command buffer’s contents when you submit it to a queue.\n\nThe renderer prepares the command buffer for a new set of commands by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method.\n\n```objective-c\n\/\/ Increment the frame number for this frame.\nframeNumber += 1;\n\nconst uint32_t frameIndex = frameNumber % kMaxFramesInFlight;\nNSString *label = [NSString stringWithFormat:@\"Frame: %llu\", frameNumber];\n\n\nif (frameNumber >= kMaxFramesInFlight) {\n    [self waitOnSharedEvent:sharedEvent\n             forEarlierFrame:frameNumber - kMaxFramesInFlight];\n}\n\n\/\/ Prepare to use or reuse the allocator by resetting it.\nid<MTL4CommandAllocator> frameAllocator = commandAllocators[frameIndex];\n[frameAllocator reset];\n\n\/\/ Prepare to use or reuse the command buffer for the frame's commands.\n[commandBuffer beginCommandBufferWithAllocator:frameAllocator];\ncommandBuffer.label = label;\n```\n\nThe renderer reuses an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator] instance the GPU no longer needs by rotating through the `kMaxFramesInFlight` allocators it creates at launch.\n\n\n\nThe renderer ensures the next allocator in the rotation is available by calling the `waitOnSharedEvent:forEarlierFrame:` method. That method calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent\/wait(untilSignaledValue:timeoutMS:)] method of the renderer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] instance, which can potentially block the caller for 10 milliseconds before it returns.\n\n```objective-c\n\/\/\/ Pauses the CPU when the device is rendering a previous frame that needs the resources\n\/\/\/ that the renderer is about to reuse for a frame.\n\/\/\/\n\/\/\/ The method adds a command that waits for a signal from the command queue that\n\/\/\/ indicates when the Metal device is done rendering an earlier frame.\n\/\/\/ This signal means the renderer can safely reuse the resources for that prior frame.\n- (void) waitOnSharedEvent:(id<MTLSharedEvent>) sharedEvent\n            forEarlierFrame:(uint64_t) earlierFrameNumber\n{\n    const uint64_t tenMilliseconds = 10;\n\n    \/\/ Wait for the GPU to finish rendering the frame that's\n    \/\/ `kMaxFramesInFlight` before this one, and then proceed to the next step.\n    BOOL beforeTimeout = [sharedEvent waitUntilSignaledValue:earlierFrameNumber\n                                                   timeoutMS:tenMilliseconds];\n\n    if (false == beforeTimeout) {\n        NSLog(@\"No signal from frame %llu to shared event after %llums\",\n              earlierFrameNumber, tenMilliseconds);\n    }\n}\n```\n\nThe command queue updates the shared event after the Metal device finishes rendering the previous frame that uses the same allocator, which indicates to this method that it’s now available to reuse. Ideally, the shared event’s method returns immediately because the earlier frame using the allocator is done rendering and no longer needs it.\n\n### Create an encoder for a render pass\n\nThe `renderFrameToView:` method creates a render command encoder by retrieving an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderPassDescriptor] instance from the view’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/currentMTL4RenderPassDescriptor] property and passing it to the command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/makeRenderCommandEncoder(descriptor:options:)] method. The view’s property represents a valid configuration for a render pass to render a frame in a format that’s compatible with that view.\n\n```objective-c\n\/\/ Create a render pass encoder from the command buffer with the view's configuration.\nid<MTL4RenderCommandEncoder> renderPassEncoder;\nMTL4RenderPassDescriptor *configuration = view.currentMTL4RenderPassDescriptor;\nrenderPassEncoder = [commandBuffer renderCommandEncoderWithDescriptor:configuration];\nrenderPassEncoder.label = label;\n```\n\nThe command buffer’s factory method returns an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder] instance, which provides methods that configure a render pass and encode the commands for that pass.\n\nThe method also gives the render encoder a unique name that can help you identify its render pass from other passes in Metal debugger. For more information about Metal debugger and inspecting passes, see:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Xcode\/Metal-debugger]\n- [doc:\/\/com.apple.documentation\/documentation\/Xcode\/Analyzing-your-Metal-workload]\n\n### Configure the viewport for the render pass\n\nThe renderer’s `setViewport` method configures an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLViewport] and passes it to the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder\/setViewport(_:)]method.\n\n```objective-c\n\/\/\/ Configures the viewport for a render pass.\n\/\/\/\n\/\/\/ The method sets the size to the same dimensions as the view's drawable region.\n\/\/\/ - Parameter renderPassEncoder: An encoder for a render pass.\n- (void) setViewportSize:(simd_uint2) size\n        forRenderEncoder:(id<MTL4RenderCommandEncoder>) renderPassEncoder\n{\n    \/\/ Configure the viewport with the size of the drawable region.\n    MTLViewport viewPort;\n    viewPort.originX = 0.0;\n    viewPort.originY = 0.0;\n    viewPort.znear = 0.0;\n    viewPort.zfar = 1.0;\n    viewPort.width = (double)size.x;\n    viewPort.height = (double)size.y;\n\n    [renderPassEncoder setViewport:viewPort];\n}\n```\n\nThe method configures the viewport’s 2D size by setting the `x` and `y` members to the dimensions of the app’s view, in pixels.\n\n### Configure any arguments for the render pass\n\nThe renderer’s `setRenderPassArguments:` method configures two arguments for the render pass, both of which are [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instances.\n\n```objective-c\n\/\/\/ Configures the arguments for a render pass.\n\/\/\/\n\/\/\/ - Parameter renderPassEncoder: An encoder for a render pass.\n\/\/\/\n\/\/\/ The draw command in every render pass this app creates needs two arguments:\n\/\/\/ - The vertex position and color data for a triangle\n\/\/\/ - The size of the app's current viewport\n\/\/\/\n\/\/\/ The triangle data changes every frame.\n\/\/\/ The size of the viewport can change, but typically remains the same until a\n\/\/\/ person changes the size of the app or its window.\n- (void) setRenderPassArguments:(id<MTL4RenderCommandEncoder>) renderPassEncoder\n                       forFrame:(NSUInteger) frameNumber\n                           with:(id<MTL4ArgumentTable>) argumentTable\n                   vertexBuffer:(id<MTLBuffer>) vertexBuffer\n                   viewPortSize:(id<MTLBuffer>) viewportSizeBuffer\n{\n    configureVertexDataForBuffer(frameNumber, vertexBuffer.contents);\n\n    \/\/ Add the buffer with the triangle data to the argument table.\n    [argumentTable setAddress:vertexBuffer.gpuAddress\n                      atIndex:InputBufferIndexForVertexData];\n\n    \/\/ Add the buffer with the viewport's size to the argument table.\n    [argumentTable setAddress:viewportSizeBuffer.gpuAddress\n                      atIndex:InputBufferIndexForViewportSize];\n\n    \/\/ Assign the argument table to the encoder.\n    [renderPassEncoder setArgumentTable:argumentTable\n                               atStages:MTLRenderStageVertex];\n}\n```\n\nThe method retrieves the next triangle vertex buffer in the rotation. Each render pass needs its own copy of triangle vertex data because the data for each frame is unique, and the GPU needs access to each frame’s input data until it finishes rendering that frame. The renderer tracks and rotates through `kMaxFramesInFlight` buffers of triangle vertex data in an array, similar to the command allocators because each frame has slightly different coordinates for the triangle as it rotates.\n\nThe method calls the renderer’s `configureVertexDataForBuffer:` method, which calculates the positions of the triangle’s vertices by applying a rotation angle and then copies the vertex data into the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer].\n\n```objective-c\n\/\/\/ Configures an equilateral triangle's vertex data\n\/\/\/ and copies the bytes into a Metal buffer's pointer.\n\/\/\/\n\/\/\/ - Parameters:\n\/\/\/   - rotationInDegrees: An angle of rotation for the triangle, in degrees.\n\/\/\/   - bufferContents: A pointer from an `MTLBuffer` instance's `contents` property.\nvoid configureVertexDataForBuffer(long rotationInDegrees,\n                                  void *bufferContents)\n{\n    const short radius = 350;\n    const short angle = rotationInDegrees % 360;\n\n    TriangleData triangleData;\n    triangleRedGreenBlue(radius, (float)angle, &triangleData);\n\n    \/\/ Update the buffer that stores the triangle data.\n    memcpy(bufferContents, &triangleData, sizeof(TriangleData));\n}\n```\n\n### Encode draw commands\n\nThe renderer draws exactly one triangle with a single call to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder\/drawPrimitives(primitiveType:vertexStart:vertexCount:)]:\n\n```objective-c\n\/\/ Draw the triangle.\n[renderPassEncoder drawPrimitives:MTLPrimitiveTypeTriangle\n                      vertexStart:0\n                      vertexCount:3];\n```\n\nThis renderer only needs one draw command, but yours can encode multiple drawing commands in a single render pass.\n\n### End the render pass\n\nThe `renderFrameToView:` method marks the conclusion of the render pass by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/endEncoding()] method.\n\n```objective-c\n\/\/ Finalize the render pass.\n[renderPassEncoder endEncoding];\n\n\/\/ Submit the command buffer to the GPU.\n[commandBuffer endCommandBuffer];\n```\n\nIt then marks the end of the command buffer by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/endCommandBuffer()] method because it only needs to encode a single render pass. However, your app can encode multiple passes of different types in a single command buffer with a series of encoder types, including the following:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ComputeCommandEncoder]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4MachineLearningCommandEncoder]\n\n### Run the render pass by submitting the command buffer\n\nThe renderer sends the command buffer to run on the GPU in its `submitCommandBufferForView:` method. The method starts by retrieving the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalDrawable] instance the view stores in its [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView\/currentDrawable] property.\n\n\n\nThe method adds the following actions to the renderer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instance, which run on the GPU timeline:\n\n1. Wait for the view’s drawable with the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue\/waitForDrawable(_:)] method.\n2. Submit the command buffer to run on the GPU with the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue\/commit:count:] method.\n3. Notify the drawable that the GPU is finished running the render pass with the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue\/signalDrawable(_:)] method.\n\n```objective-c\n\/\/\/ Sends a command buffer to run on a Metal device by committing it to a\n\/\/\/ command queue.\n\/\/\/\n\/\/\/ - Parameters:\n\/\/\/   - commandBuffer: A command buffer with work for `view` that's ready to submit.\n\/\/\/   - commandQueue: A command queue the method submits the command buffer to.\n\/\/\/   - view: A MetalKit view instance, which provides a render target\n\/\/\/ with its `currentDrawable` property.\n- (void) submitCommandBuffer:(id<MTL4CommandBuffer>) commandBuffer\n              toCommandQueue:(id<MTL4CommandQueue>) commandQueue\n                     forView:(nonnull MTKView *) view\n{\n    \/\/\/ A drawable from the view that the method renders the frame to.\n    id<CAMetalDrawable> currentDrawable = view.currentDrawable;\n\n    \/\/ Instruct the queue to wait until the drawable is ready to receive output from the render pass.\n    [commandQueue waitForDrawable:currentDrawable];\n\n    \/\/ Run the command buffer on the GPU by submitting it the Metal device's queue.\n    [commandQueue commit:&commandBuffer count:1];\n\n    \/\/ Notify the drawable that the GPU is done running the render pass.\n    [commandQueue signalDrawable:currentDrawable];\n\n    \/\/ Instruct the drawable to show itself on the device's display when the render pass completes.\n    [currentDrawable present];\n}\n```\n\nThe Metal device needs to wait until the view’s drawable is available because it stores the output from the render pass and provides the mechanism that updates the content on the display. When the drawable is ready, the GPU runs the single render pass in the command buffer, which saves the results to the drawable’s texture.\n\n\n\nThe method concludes by calling the drawable’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDrawable\/present()] method, which instructs the drawable to show its content on the device’s display shortly after it gets the notification from the command queue. The [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDrawable] protocol defines this method, which the [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalDrawable] protocol inherits.\n\n### Notify the renderer when a frame’s resources are ready for reuse\n\nThe last command the `renderFrameToView:` method adds to the command queue notifies the renderer when it can reuse this frame’s triangle vertex buffer and command allocator, by signaling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] instance with the current frame number.\n\n```objective-c\n\/\/ Signal when the GPU finishes rendering this frame with a shared event.\n[commandQueue signalEvent:sharedEvent value:frameNumber];\n```\n\nFor example, if the `frameNumber` equals `4` and `kMaxFramesInFlight` equals `3`, this signal informs the renderer when its okay to reuse the fourth frame’s resources and apply them for frame seven.\n\n## Essentials\n\n- **Understanding the Metal 4 core API**: Discover the features and functionality in the Metal 4 foundational APIs.\n- **Performing calculations on a GPU**: Use Metal to find GPUs and perform calculations on them.\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Discover the features and functionality in the Metal 4 foundational APIs.",
          "name" : "Understanding the Metal 4 core API",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/understanding-the-metal-4-core-api"
        },
        {
          "description" : "Use Metal to find GPUs and perform calculations on them.",
          "name" : "Performing calculations on a GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/performing-calculations-on-a-gpu"
        },
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Drawing a triangle with Metal 4",
  "url" : "https:\/\/developer.apple.com\/documentation\/metal\/drawing-a-triangle-with-metal-4"
}