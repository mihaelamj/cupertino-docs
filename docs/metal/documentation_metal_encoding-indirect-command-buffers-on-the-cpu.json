{
  "abstract" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
  "codeExamples" : [
    {
      "code" : "#if TARGET_IOS\n    supportICB = [_view.device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily3_v4];\n#else\n    supportICB = [_view.device supportsFeatureSet:MTLFeatureSet_macOS_GPUFamily2_v1];\n#endif",
      "language" : "objective-c"
    },
    {
      "code" : "        MTLIndirectCommandBufferDescriptor* icbDescriptor = [MTLIndirectCommandBufferDescriptor new];\n\n        \/\/ Indicate that the only draw commands will be standard (non-indexed) draw commands.\n        icbDescriptor.commandTypes = MTLIndirectCommandTypeDraw;\n\n        \/\/ Indicate that buffers will be set for each command IN the indirect command buffer.\n        icbDescriptor.inheritBuffers = NO;\n\n        \/\/ Indicate that a max of 3 buffers will be set for each command.\n        icbDescriptor.maxVertexBufferBindCount = 3;\n        icbDescriptor.maxFragmentBufferBindCount = 0;\n\n#if defined TARGET_MACOS || defined(__IPHONE_13_0)\n        \/\/ Indicate that the render pipeline state object will be set in the render command encoder\n        \/\/ (not by the indirect command buffer).\n        \/\/ On iOS, this property only exists on iOS 13 and later.  It defaults to YES in earlier\n        \/\/ versions\n        if (@available(iOS 13.0, *)) {\n            icbDescriptor.inheritPipelineState = YES;\n        }\n#endif\n\n        _indirectCommandBuffer = [_device newIndirectCommandBufferWithDescriptor:icbDescriptor\n                                                                 maxCommandCount:AAPLNumObjects\n                                                                         options:0];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/  Encode a draw command for each object drawn in the indirect command buffer.\nfor (int objIndex = 0; objIndex < AAPLNumObjects; objIndex++)\n{\n    id<MTLIndirectRenderCommand> ICBCommand =\n        [_indirectCommandBuffer indirectRenderCommandAtIndex:objIndex];\n\n    [ICBCommand setVertexBuffer:_vertexBuffer[objIndex]\n                         offset:0\n                        atIndex:AAPLVertexBufferIndexVertices];\n\n    [ICBCommand setVertexBuffer:_indirectFrameStateBuffer\n                         offset:0\n                        atIndex:AAPLVertexBufferIndexFrameState];\n\n    [ICBCommand setVertexBuffer:_objectParameters\n                         offset:0\n                        atIndex:AAPLVertexBufferIndexObjectParams];\n\n    const NSUInteger vertexCount = _vertexBuffer[objIndex].length\/sizeof(AAPLVertex);\n\n    [ICBCommand drawPrimitives:MTLPrimitiveTypeTriangle\n                   vertexStart:0\n                   vertexCount:vertexCount\n                 instanceCount:1\n                  baseInstance:objIndex];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "_frameNumber++;\n\n_inFlightIndex = _frameNumber % AAPLMaxFramesInFlight;\n\nAAPLFrameState * frameState = _frameStateBuffer[_inFlightIndex].contents;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Encode blit commands to update the buffer holding the frame state.\nid<MTLBlitCommandEncoder> blitEncoder = [commandBuffer blitCommandEncoder];\n\n[blitEncoder copyFromBuffer:_frameStateBuffer[_inFlightIndex] sourceOffset:0\n                   toBuffer:_indirectFrameStateBuffer destinationOffset:0\n                       size:_indirectFrameStateBuffer.length];\n\n[blitEncoder endEncoding];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Draw everything in the indirect command buffer.\n[renderEncoder executeCommandsInBuffer:_indirectCommandBuffer withRange:NSMakeRange(0, AAPLNumObjects)];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Make a useResource call for each buffer needed by the indirect command buffer.\nfor (int i = 0; i < AAPLNumObjects; i++)\n{\n    [renderEncoder useResource:_vertexBuffer[i] usage:MTLResourceUsageRead];\n}\n\n[renderEncoder useResource:_objectParameters usage:MTLResourceUsageRead];\n\n[renderEncoder useResource:_indirectFrameStateBuffer usage:MTLResourceUsageRead];",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "32217f22946ab9429552f08cb53774048d5bcea7df1e60accb2ab59057699b56",
  "crawledAt" : "2025-12-02T15:31:15Z",
  "id" : "095C61EB-15F1-437D-A4F1-02D85FD79355",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nThis sample app provides an introduction to *indirect command buffers* (ICB), which enable you to store repeated commands for later use. Because Metal discards a normal command buffer and its commands after Metal executes them, use ICBs to save expensive allocation, deallocation, and encoding time for your app’s common instructions. Additionally, you benefit when using ICBs with:\n\nAn example of where ICBs are effective is with a game’s head-up display (HUD), because:\n\nICBs are also useful to render static objects in typical 3D scenes. Because encoded commands typically result in lightweight data structures, ICBs are suitable for saving complex draws, too.\n\nThis sample demonstrates how to set up an ICB to repeatedly render a series of shapes. While it’s possible to gain even more instruction-parallelism by encoding the ICB on the GPU, this sample encodes an ICB on the CPU for simplicity. See [doc:\/\/com.apple.metal\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-gpu] for the more advanced usage.\n\n### Getting started\n\nThis sample contains macOS and iOS targets. Run the iOS scheme on a physical device because Metal isn’t supported in the simulator.\n\nICBs are supported by GPUs of family greater than or equal to:\n\nYou check the GPU that you choose at runtime if it supports ICBs using the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] method [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsFeatureSet(_:)]:\n\nThis sample calls ‘supportsFeatureSet:’ for this purpose within its view controller’s `viewDidLoad:` callback.\n\n### Individual commands versus indirect command buffers\n\nMetal apps, particularly games, typically contain multiple render commands, each associated with a set of render states, buffers, and draw calls. To execute these commands for a render pass, apps first encode them into a render command encoder within a command buffer.\n\nYou encode individual commands into a render command encoder by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/drawPrimitives(type:vertexStart:vertexCount:instanceCount:baseInstance:)].\n\n\n\nRecreating draws that were equivalent to ones you did in a previous queue can be tedious from a coding perspective and non-performant at runtime. Instead, move your repeated draws and their data buffers into an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectCommandBuffer] instance using an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand], thereby filling the ICB with commands. When you’re ready to use the ICB, encode individual executions of it by calling an `MTLRenderCommandEncoder` instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/executeCommandsInBuffer:withRange:] method.\n\n\n\n### Define render commands and inherited render state\n\nFor the indirect command buffer, `_indirectCommandBuffer`, the sample defines render commands that:\n\nThe sample encodes these commands differently for the CPU or the GPU. However, these commands are still encoded into both versions of the indirect command buffer.\n\nThe sample also allows `_indirectCommandBuffer` to inherit the render pipeline state from its parent encoder, `renderEncoder`. Furthermore, `_indirectCommandBuffer` implicitly inherits any render state that can’t be encoded into it, such as the cull mode and depth or stencil state for the render pass.\n\n### Create an indirect command buffer\n\nThe sample creates `_indirectCommandBuffer` from an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectCommandBufferDescriptor], which defines the features and limits of an indirect command buffer.\n\nThe sample specifies the types of commands, `commandTypes`, and the maximum number of commands, `maxCount`, so that Metal reserves enough space in memory for the sample to encode `_indirectCommandBuffer` successfully (with the CPU or GPU).\n\n### Encode an indirect command buffer with the CPU\n\nFrom the CPU, the sample encodes commands into `_indirectCommandBuffer` with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand] instance. For each shape to be rendered, the sample encodes two [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand\/setVertexBuffer(_:offset:at:)] commands and one [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand\/drawPrimitives(_:vertexStart:vertexCount:instanceCount:baseInstance:)] command.\n\nThe sample performs this encoding only once, before encoding any subsequent render commands. `_indirectCommandBuffer` contains a total of 16 draw calls, one for each shape to be rendered. Each draw call references the same transformation data, `_uniformBuffers`, but different vertex data, `_vertexBuffers[indx]`. Although the CPU encodes data only once, the sample issues 16 draw calls per frame.\n\n\n\n### Update the data used by an ICB\n\nTo update data that’s fed to the GPU, you typically cycle through a set of buffers such that the CPU updates one while the GPU reads another (see [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-events-between-a-gpu-and-the-cpu]). You can’t apply that pattern literally with ICBs, however, because you can’t update an ICB’s buffer set after you encode its commands, but you follow a two-step process to blit data updates from the CPU. First, update a single buffer in your dynamic buffer array on the CPU:\n\nThen, blit the CPU-side buffer set to the location that’s accessible to the ICB (see `_indirectFrameStateBuffer`):\n\n### Execute an indirect command buffer\n\nThe sample calls the `executeCommandsInBuffer:withRange:` method to execute the commands in `_indirectCommandBuffer`.\n\nSimilar to the arguments in an argument buffer, the sample calls the `useResource:usage:` method to indicate that the GPU can access the resources within an indirect command buffer.\n\nThe sample continues to execute `_indirectCommandBuffer` each frame.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu\ncrawled: 2025-12-02T15:31:15Z\n---\n\n# Encoding indirect command buffers on the CPU\n\n**Sample Code**\n\nReduce CPU overhead and simplify your command execution by reusing commands.\n\n## Overview\n\nThis sample app provides an introduction to *indirect command buffers* (ICB), which enable you to store repeated commands for later use. Because Metal discards a normal command buffer and its commands after Metal executes them, use ICBs to save expensive allocation, deallocation, and encoding time for your app’s common instructions. Additionally, you benefit when using ICBs with:\n\n- A reduction in rendering tasks because you execute an ICB with a single call.\n- By creating ICBs at initialization, it moves expensive command management out of your app’s critical path at rendering or compute-time.\n\nAn example of where ICBs are effective is with a game’s head-up display (HUD), because:\n\n- You render HUDs every frame.\n- The appearance of the HUD is usually static across frames.\n\nICBs are also useful to render static objects in typical 3D scenes. Because encoded commands typically result in lightweight data structures, ICBs are suitable for saving complex draws, too.\n\nThis sample demonstrates how to set up an ICB to repeatedly render a series of shapes. While it’s possible to gain even more instruction-parallelism by encoding the ICB on the GPU, this sample encodes an ICB on the CPU for simplicity. See [doc:\/\/com.apple.metal\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-gpu] for the more advanced usage.\n\n### Getting started\n\nThis sample contains macOS and iOS targets. Run the iOS scheme on a physical device because Metal isn’t supported in the simulator.\n\nICBs are supported by GPUs of family greater than or equal to:\n\n- `MTLFeatureSet_iOS_GPUFamily3_v4`\n- `MTLFeatureSet_macOS_GPUFamily2_v1`\n\nYou check the GPU that you choose at runtime if it supports ICBs using the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] method [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsFeatureSet(_:)]:\n\n```objective-c\n#if TARGET_IOS\n    supportICB = [_view.device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily3_v4];\n#else\n    supportICB = [_view.device supportsFeatureSet:MTLFeatureSet_macOS_GPUFamily2_v1];\n#endif\n```\n\nThis sample calls ‘supportsFeatureSet:’ for this purpose within its view controller’s `viewDidLoad:` callback.\n\n### Individual commands versus indirect command buffers\n\nMetal apps, particularly games, typically contain multiple render commands, each associated with a set of render states, buffers, and draw calls. To execute these commands for a render pass, apps first encode them into a render command encoder within a command buffer.\n\nYou encode individual commands into a render command encoder by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/drawPrimitives(type:vertexStart:vertexCount:instanceCount:baseInstance:)].\n\n\n\nRecreating draws that were equivalent to ones you did in a previous queue can be tedious from a coding perspective and non-performant at runtime. Instead, move your repeated draws and their data buffers into an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectCommandBuffer] instance using an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand], thereby filling the ICB with commands. When you’re ready to use the ICB, encode individual executions of it by calling an `MTLRenderCommandEncoder` instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/executeCommandsInBuffer:withRange:] method.\n\n\n\n\n\n### Define render commands and inherited render state\n\nFor the indirect command buffer, `_indirectCommandBuffer`, the sample defines render commands that:\n\n1. Set a vertex buffer using unique vertex data for each mesh\n2. Set another vertex buffer using common transformation data for all meshes\n3. Set another vertex buffer containing an array of parameters for each mesh\n4. Draw the mesh’s triangles\n\nThe sample encodes these commands differently for the CPU or the GPU. However, these commands are still encoded into both versions of the indirect command buffer.\n\nThe sample also allows `_indirectCommandBuffer` to inherit the render pipeline state from its parent encoder, `renderEncoder`. Furthermore, `_indirectCommandBuffer` implicitly inherits any render state that can’t be encoded into it, such as the cull mode and depth or stencil state for the render pass.\n\n### Create an indirect command buffer\n\nThe sample creates `_indirectCommandBuffer` from an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectCommandBufferDescriptor], which defines the features and limits of an indirect command buffer.\n\n```objective-c\n        MTLIndirectCommandBufferDescriptor* icbDescriptor = [MTLIndirectCommandBufferDescriptor new];\n\n        \/\/ Indicate that the only draw commands will be standard (non-indexed) draw commands.\n        icbDescriptor.commandTypes = MTLIndirectCommandTypeDraw;\n\n        \/\/ Indicate that buffers will be set for each command IN the indirect command buffer.\n        icbDescriptor.inheritBuffers = NO;\n\n        \/\/ Indicate that a max of 3 buffers will be set for each command.\n        icbDescriptor.maxVertexBufferBindCount = 3;\n        icbDescriptor.maxFragmentBufferBindCount = 0;\n\n#if defined TARGET_MACOS || defined(__IPHONE_13_0)\n        \/\/ Indicate that the render pipeline state object will be set in the render command encoder\n        \/\/ (not by the indirect command buffer).\n        \/\/ On iOS, this property only exists on iOS 13 and later.  It defaults to YES in earlier\n        \/\/ versions\n        if (@available(iOS 13.0, *)) {\n            icbDescriptor.inheritPipelineState = YES;\n        }\n#endif\n\n        _indirectCommandBuffer = [_device newIndirectCommandBufferWithDescriptor:icbDescriptor\n                                                                 maxCommandCount:AAPLNumObjects\n                                                                         options:0];\n```\n\nThe sample specifies the types of commands, `commandTypes`, and the maximum number of commands, `maxCount`, so that Metal reserves enough space in memory for the sample to encode `_indirectCommandBuffer` successfully (with the CPU or GPU).\n\n### Encode an indirect command buffer with the CPU\n\nFrom the CPU, the sample encodes commands into `_indirectCommandBuffer` with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand] instance. For each shape to be rendered, the sample encodes two [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand\/setVertexBuffer(_:offset:at:)] commands and one [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectRenderCommand\/drawPrimitives(_:vertexStart:vertexCount:instanceCount:baseInstance:)] command.\n\n```objective-c\n\/\/  Encode a draw command for each object drawn in the indirect command buffer.\nfor (int objIndex = 0; objIndex < AAPLNumObjects; objIndex++)\n{\n    id<MTLIndirectRenderCommand> ICBCommand =\n        [_indirectCommandBuffer indirectRenderCommandAtIndex:objIndex];\n\n    [ICBCommand setVertexBuffer:_vertexBuffer[objIndex]\n                         offset:0\n                        atIndex:AAPLVertexBufferIndexVertices];\n\n    [ICBCommand setVertexBuffer:_indirectFrameStateBuffer\n                         offset:0\n                        atIndex:AAPLVertexBufferIndexFrameState];\n\n    [ICBCommand setVertexBuffer:_objectParameters\n                         offset:0\n                        atIndex:AAPLVertexBufferIndexObjectParams];\n\n    const NSUInteger vertexCount = _vertexBuffer[objIndex].length\/sizeof(AAPLVertex);\n\n    [ICBCommand drawPrimitives:MTLPrimitiveTypeTriangle\n                   vertexStart:0\n                   vertexCount:vertexCount\n                 instanceCount:1\n                  baseInstance:objIndex];\n}\n```\n\nThe sample performs this encoding only once, before encoding any subsequent render commands. `_indirectCommandBuffer` contains a total of 16 draw calls, one for each shape to be rendered. Each draw call references the same transformation data, `_uniformBuffers`, but different vertex data, `_vertexBuffers[indx]`. Although the CPU encodes data only once, the sample issues 16 draw calls per frame.\n\n\n\n### Update the data used by an ICB\n\nTo update data that’s fed to the GPU, you typically cycle through a set of buffers such that the CPU updates one while the GPU reads another (see [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-events-between-a-gpu-and-the-cpu]). You can’t apply that pattern literally with ICBs, however, because you can’t update an ICB’s buffer set after you encode its commands, but you follow a two-step process to blit data updates from the CPU. First, update a single buffer in your dynamic buffer array on the CPU:\n\n```objective-c\n_frameNumber++;\n\n_inFlightIndex = _frameNumber % AAPLMaxFramesInFlight;\n\nAAPLFrameState * frameState = _frameStateBuffer[_inFlightIndex].contents;\n```\n\nThen, blit the CPU-side buffer set to the location that’s accessible to the ICB (see `_indirectFrameStateBuffer`):\n\n```objective-c\n\/\/\/ Encode blit commands to update the buffer holding the frame state.\nid<MTLBlitCommandEncoder> blitEncoder = [commandBuffer blitCommandEncoder];\n\n[blitEncoder copyFromBuffer:_frameStateBuffer[_inFlightIndex] sourceOffset:0\n                   toBuffer:_indirectFrameStateBuffer destinationOffset:0\n                       size:_indirectFrameStateBuffer.length];\n\n[blitEncoder endEncoding];\n```\n\n### Execute an indirect command buffer\n\nThe sample calls the `executeCommandsInBuffer:withRange:` method to execute the commands in `_indirectCommandBuffer`.\n\n```objective-c\n\/\/ Draw everything in the indirect command buffer.\n[renderEncoder executeCommandsInBuffer:_indirectCommandBuffer withRange:NSMakeRange(0, AAPLNumObjects)];\n```\n\nSimilar to the arguments in an argument buffer, the sample calls the `useResource:usage:` method to indicate that the GPU can access the resources within an indirect command buffer.\n\n```objective-c\n\/\/ Make a useResource call for each buffer needed by the indirect command buffer.\nfor (int i = 0; i < AAPLNumObjects; i++)\n{\n    [renderEncoder useResource:_vertexBuffer[i] usage:MTLResourceUsageRead];\n}\n\n[renderEncoder useResource:_objectParameters usage:MTLResourceUsageRead];\n\n[renderEncoder useResource:_indirectFrameStateBuffer usage:MTLResourceUsageRead];\n```\n\nThe sample continues to execute `_indirectCommandBuffer` each frame.\n\n## Indirect command buffers\n\n- **Creating an indirect command buffer**: Configure a descriptor to specify the properties of an indirect command buffer.\n- **Specifying drawing and dispatch arguments indirectly**: Use indirect commands if you don’t know your draw or dispatch call arguments when you encode the command.\n- **Encoding indirect command buffers on the GPU**: Maximize CPU to GPU parallelization by generating render commands on the GPU.\n- **MTLIndirectCommandBuffer**: A command buffer containing reusable commands, encoded either on the CPU or GPU.\n- **MTLIndirectCommandBufferDescriptor**: A configuration you create to customize an indirect command buffer.\n- **MTLIndirectCommandType**: The types of commands that you can encode into the indirect command buffer.\n- **MTLIndirectCommandBufferExecutionRange**: A range of commands in an indirect command buffer.\n- **MTLIndirectCommandBufferExecutionRangeMake(_:_:)**: Creates a command execution range.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Configure a descriptor to specify the properties of an indirect command buffer.",
          "name" : "Creating an indirect command buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-an-indirect-command-buffer"
        },
        {
          "description" : "Use indirect commands if you don’t know your draw or dispatch call arguments when you encode the command.",
          "name" : "Specifying drawing and dispatch arguments indirectly",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/specifying-drawing-and-dispatch-arguments-indirectly"
        },
        {
          "description" : "Maximize CPU to GPU parallelization by generating render commands on the GPU.",
          "name" : "Encoding indirect command buffers on the GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-gpu"
        },
        {
          "description" : "A command buffer containing reusable commands, encoded either on the CPU or GPU.",
          "name" : "MTLIndirectCommandBuffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBuffer"
        },
        {
          "description" : "A configuration you create to customize an indirect command buffer.",
          "name" : "MTLIndirectCommandBufferDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBufferDescriptor"
        },
        {
          "description" : "The types of commands that you can encode into the indirect command buffer.",
          "name" : "MTLIndirectCommandType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandType"
        },
        {
          "description" : "A range of commands in an indirect command buffer.",
          "name" : "MTLIndirectCommandBufferExecutionRange",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBufferExecutionRange"
        },
        {
          "description" : "Creates a command execution range.",
          "name" : "MTLIndirectCommandBufferExecutionRangeMake(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLIndirectCommandBufferExecutionRangeMake(_:_:)"
        }
      ],
      "title" : "Indirect command buffers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Encoding indirect command buffers on the CPU",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
}