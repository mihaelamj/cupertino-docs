{
  "abstract" : "Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.",
  "codeExamples" : [
    {
      "code" : "if(_view.device.argumentBuffersSupport != MTLArgumentBuffersTier2)\n{\n    NSAssert(0, @\"This sample requires a Metal device that supports Tier 2 argument buffers.\");\n}",
      "language" : "objective-c"
    },
    {
      "code" : "struct SourceTextureArguments {\n    texture2d<float>    texture [[ id(AAPLArgumentBufferIDTexture) ]];\n};",
      "language" : "metal"
    },
    {
      "code" : "struct InstanceArguments {\n    vector_float2    position;\n    texture2d<float> left_texture;\n    texture2d<float> right_texture;\n};",
      "language" : "metal"
    },
    {
      "code" : "struct InstanceArguments {\n    vector_float2    position;\n    texture2d<float> left_texture;\n    texture2d<float> right_texture;\n};",
      "language" : "metal"
    },
    {
      "code" : "NSUInteger instanceParameterLength = instanceParameterEncoder.encodedLength * AAPLNumInstances;\n\n_instanceParameters = [_device newBufferWithLength:instanceParameterLength options:0];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Select the element in the instance_params array which stores the parameter for the quad.\ndevice InstanceArguments & quad_params = instance_params[instanceID];\n\n\/\/ Store the position of the quad.\nquad_params.position = position;\n\n\/\/ Select and store the textures to apply to this quad.\nquad_params.left_texture = source_textures[left_texture_index].texture;\nquad_params.right_texture = source_textures[right_texture_index].texture;",
      "language" : "metal"
    },
    {
      "code" : "vertex RasterizerData\nvertexShader(uint                            vertexID        [[ vertex_id ]],\n             uint                            instanceID      [[ instance_id ]],\n             const device AAPLVertex        *vertices        [[ buffer(AAPLVertexBufferIndexVertices) ]],\n             const device InstanceArguments *instance_params [[ buffer(AAPLVertexBufferIndexInstanceParams) ]],\n             constant AAPLFrameState        &frame_state     [[ buffer(AAPLVertexBufferIndexFrameState) ]])",
      "language" : "metal"
    },
    {
      "code" : "float2 quad_position = instance_params[instanceID].position;",
      "language" : "metal"
    },
    {
      "code" : "fragment float4\nfragmentShader(RasterizerData            in              [[ stage_in ]],\n               device InstanceArguments *instance_params [[ buffer(AAPLFragmentBufferIndexInstanceParams) ]],\n               constant AAPLFrameState  &frame_state     [[ buffer(AAPLFragmentBufferIndexFrameState) ]])",
      "language" : "metal"
    },
    {
      "code" : "texture2d<float> left_texture = instance_params[instanceID].left_texture;\ntexture2d<float> right_texture = instance_params[instanceID].right_texture;\n\nfloat4 left_sample = left_texture.sample(texture_sampler, in.tex_coord);\nfloat4 right_sample = right_texture.sample(texture_sampler, in.tex_coord);\n\nif(frame_state.slideFactor < in.tex_coord.x)\n{\n    output_color = left_sample;\n}\nelse\n{\n    output_color = right_sample;\n}",
      "language" : "metal"
    }
  ],
  "contentHash" : "91057dc2b139cc215a05e2a368a4f73985d500ec74913179e4e9cc5c3659fe07",
  "crawledAt" : "2025-12-02T19:56:18Z",
  "id" : "81311AA7-04F4-4C94-8828-EC77801C8B42",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nIn [doc:\/\/com.apple.metal\/documentation\/Metal\/using-argument-buffers-with-resource-heaps], you learned how to combine argument buffers with arrays of resources and resource heaps.\n\nIn this sample, you’ll learn how to encode resources into argument buffers with a graphics or compute function. In particular, you’ll learn how to write data into an argument buffer from a compute pass and then read that data in a render pass. The sample renders a grid of multiple quad instances with two textures applied to each, where the textures slide from left to right within the quad and move from left to right between quads.\n\n### Getting started\n\nThe sample can run only on devices that support Tier 2 argument buffers. Tier 2 devices allow graphics or compute functions to encode data into an argument buffer, whereas Tier 1 devices only allow these functions to read data from an argument buffer. Additionally, Tier 2 devices can access more textures in an instanced draw call than Tier 1 devices. See [doc:\/\/com.apple.metal\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers] for more information about argument buffer tiers, limits, and capabilities.\n\nThis sample checks for Tier 2 argument buffer support when the renderer is initialized.\n\n### Encode data into argument buffers\n\nDuring initialization, the sample encodes data with the CPU into an argument buffer defined by the `SourceTextureArguments` structure.\n\nThis argument buffer is backed by the `_sourceTextures` buffer and is accessed via the `source_textures` variable in the `updateInstances` function.  `source_textures` is a pointer to an unbounded array of structures, each of which contains a reference to a texture.\n\n\n\nAfter initialization, for each frame, the sample encodes data with the GPU into a separate argument buffer defined by the `InstanceArguments` structure.\n\nThis argument buffer is backed by the `_instanceParameters` buffer and is accessed via the `instance_params` variable in the `updateInstances`, `vertexShader`, and `fragmentShader` functions. `instance_params` is an array of structures whose data is populated in a compute pass and then accessed in a render pass via an instanced draw call.\n\n\n\n### Create an array of argument buffer structures\n\nThe sample defines an `InstanceArguments` structure into which a compute function, `updateInstances`, encodes a vector and two textures.\n\nPrevious argument buffer samples used the `encodedLength` property to directly determine the required size for the `MTLBuffer` that backs an argument buffer structure. However, this sample needs one instance of this structure for each quad rendered by a subsequent render pass. Therefore, the sample multiplies the value of `encodedLength` by the total number of instances, which is defined by the value of the `AAPLNumInstances` constant.\n\n### Encode an argument buffer with a compute function\n\nFor each quad to be rendered, the sample executes the `updateInstances` compute function to determine the quad’s position and textures. The compute pass executed by the sample iterates through the `instance_params` array and encodes the correct data for each quad. The sample encodes data into `instance_params` by setting `InstanceArguments` values in the array element at the `instanceID` index value.\n\n### Render instances with an argument buffer\n\nThe sample issues an instanced draw call to render all the quads while incurring a minimal amount of CPU overhead. Combining this technique with an argument buffer allows the sample to use a unique set of resources for each quad within the same draw call, where each instance draws a single quad.\n\nThe sample declares an `instanceID` variable in both the vertex and fragment function’s signatures. The render pipeline uses `instanceID` to index into the `instance_params` array that was previously encoded by the `updateInstances` compute function.\n\nIn the vertex function, `instanceID` is defined as an argument with the `[[instance_id]]` attribute qualifier.\n\nThe vertex function reads position data from the argument buffer to render the quad in the right place in the drawable.\n\nThe vertex function then passes the `instanceID` variable to the fragment function, via the `RasterizerData` structure and the `[[stage_in]]` attribute qualifier. (In the fragment function, `instanceID` is accessed via the `in` argument.)\n\nThe fragment function samples from the two textures specified in the argument buffer and then chooses an output sample based on the value of `slideFactor`.\n\nThe fragment function outputs the selected sample. The left texture slides in from the left and the right texture slides out to the right. After the right texture has completely slid off the quad, the sample assigns this texture as the left texture in the next compute pass. Thus, each texture moves from left to right across the grid of quads.\n\n### Next steps\n\nIn this sample, you learned how to encode resources into argument buffers with a graphics or compute function. In [doc:\/\/com.apple.metal\/documentation\/Metal\/rendering-terrain-dynamically-with-argument-buffers], you’ll learn how to combine several argument buffer techniques to render a dynamic terrain in real time.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/metal\/encoding-argument-buffers-on-the-gpu\ncrawled: 2025-12-02T19:56:18Z\n---\n\n# Encoding argument buffers on the GPU\n\n**Sample Code**\n\nUse a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.\n\n## Overview\n\nIn [doc:\/\/com.apple.metal\/documentation\/Metal\/using-argument-buffers-with-resource-heaps], you learned how to combine argument buffers with arrays of resources and resource heaps.\n\nIn this sample, you’ll learn how to encode resources into argument buffers with a graphics or compute function. In particular, you’ll learn how to write data into an argument buffer from a compute pass and then read that data in a render pass. The sample renders a grid of multiple quad instances with two textures applied to each, where the textures slide from left to right within the quad and move from left to right between quads.\n\n### Getting started\n\nThe sample can run only on devices that support Tier 2 argument buffers. Tier 2 devices allow graphics or compute functions to encode data into an argument buffer, whereas Tier 1 devices only allow these functions to read data from an argument buffer. Additionally, Tier 2 devices can access more textures in an instanced draw call than Tier 1 devices. See [doc:\/\/com.apple.metal\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers] for more information about argument buffer tiers, limits, and capabilities.\n\nThis sample checks for Tier 2 argument buffer support when the renderer is initialized.\n\n```objective-c\nif(_view.device.argumentBuffersSupport != MTLArgumentBuffersTier2)\n{\n    NSAssert(0, @\"This sample requires a Metal device that supports Tier 2 argument buffers.\");\n}\n```\n\n### Encode data into argument buffers\n\nDuring initialization, the sample encodes data with the CPU into an argument buffer defined by the `SourceTextureArguments` structure.\n\n```metal\nstruct SourceTextureArguments {\n    texture2d<float>    texture [[ id(AAPLArgumentBufferIDTexture) ]];\n};\n```\n\nThis argument buffer is backed by the `_sourceTextures` buffer and is accessed via the `source_textures` variable in the `updateInstances` function.  `source_textures` is a pointer to an unbounded array of structures, each of which contains a reference to a texture.\n\n\n\nAfter initialization, for each frame, the sample encodes data with the GPU into a separate argument buffer defined by the `InstanceArguments` structure.\n\n```metal\nstruct InstanceArguments {\n    vector_float2    position;\n    texture2d<float> left_texture;\n    texture2d<float> right_texture;\n};\n```\n\nThis argument buffer is backed by the `_instanceParameters` buffer and is accessed via the `instance_params` variable in the `updateInstances`, `vertexShader`, and `fragmentShader` functions. `instance_params` is an array of structures whose data is populated in a compute pass and then accessed in a render pass via an instanced draw call.\n\n\n\n### Create an array of argument buffer structures\n\nThe sample defines an `InstanceArguments` structure into which a compute function, `updateInstances`, encodes a vector and two textures.\n\n```metal\nstruct InstanceArguments {\n    vector_float2    position;\n    texture2d<float> left_texture;\n    texture2d<float> right_texture;\n};\n```\n\nPrevious argument buffer samples used the `encodedLength` property to directly determine the required size for the `MTLBuffer` that backs an argument buffer structure. However, this sample needs one instance of this structure for each quad rendered by a subsequent render pass. Therefore, the sample multiplies the value of `encodedLength` by the total number of instances, which is defined by the value of the `AAPLNumInstances` constant.\n\n```objective-c\nNSUInteger instanceParameterLength = instanceParameterEncoder.encodedLength * AAPLNumInstances;\n\n_instanceParameters = [_device newBufferWithLength:instanceParameterLength options:0];\n```\n\n\n\n### Encode an argument buffer with a compute function\n\nFor each quad to be rendered, the sample executes the `updateInstances` compute function to determine the quad’s position and textures. The compute pass executed by the sample iterates through the `instance_params` array and encodes the correct data for each quad. The sample encodes data into `instance_params` by setting `InstanceArguments` values in the array element at the `instanceID` index value.\n\n```metal\n\/\/ Select the element in the instance_params array which stores the parameter for the quad.\ndevice InstanceArguments & quad_params = instance_params[instanceID];\n\n\/\/ Store the position of the quad.\nquad_params.position = position;\n\n\/\/ Select and store the textures to apply to this quad.\nquad_params.left_texture = source_textures[left_texture_index].texture;\nquad_params.right_texture = source_textures[right_texture_index].texture;\n```\n\n### Render instances with an argument buffer\n\nThe sample issues an instanced draw call to render all the quads while incurring a minimal amount of CPU overhead. Combining this technique with an argument buffer allows the sample to use a unique set of resources for each quad within the same draw call, where each instance draws a single quad.\n\nThe sample declares an `instanceID` variable in both the vertex and fragment function’s signatures. The render pipeline uses `instanceID` to index into the `instance_params` array that was previously encoded by the `updateInstances` compute function.\n\nIn the vertex function, `instanceID` is defined as an argument with the `[[instance_id]]` attribute qualifier.\n\n```metal\nvertex RasterizerData\nvertexShader(uint                            vertexID        [[ vertex_id ]],\n             uint                            instanceID      [[ instance_id ]],\n             const device AAPLVertex        *vertices        [[ buffer(AAPLVertexBufferIndexVertices) ]],\n             const device InstanceArguments *instance_params [[ buffer(AAPLVertexBufferIndexInstanceParams) ]],\n             constant AAPLFrameState        &frame_state     [[ buffer(AAPLVertexBufferIndexFrameState) ]])\n```\n\nThe vertex function reads position data from the argument buffer to render the quad in the right place in the drawable.\n\n```metal\nfloat2 quad_position = instance_params[instanceID].position;\n```\n\nThe vertex function then passes the `instanceID` variable to the fragment function, via the `RasterizerData` structure and the `[[stage_in]]` attribute qualifier. (In the fragment function, `instanceID` is accessed via the `in` argument.)\n\n```metal\nfragment float4\nfragmentShader(RasterizerData            in              [[ stage_in ]],\n               device InstanceArguments *instance_params [[ buffer(AAPLFragmentBufferIndexInstanceParams) ]],\n               constant AAPLFrameState  &frame_state     [[ buffer(AAPLFragmentBufferIndexFrameState) ]])\n```\n\nThe fragment function samples from the two textures specified in the argument buffer and then chooses an output sample based on the value of `slideFactor`.\n\n```metal\ntexture2d<float> left_texture = instance_params[instanceID].left_texture;\ntexture2d<float> right_texture = instance_params[instanceID].right_texture;\n\nfloat4 left_sample = left_texture.sample(texture_sampler, in.tex_coord);\nfloat4 right_sample = right_texture.sample(texture_sampler, in.tex_coord);\n\nif(frame_state.slideFactor < in.tex_coord.x)\n{\n    output_color = left_sample;\n}\nelse\n{\n    output_color = right_sample;\n}\n```\n\nThe fragment function outputs the selected sample. The left texture slides in from the left and the right texture slides out to the right. After the right texture has completely slid off the quad, the sample assigns this texture as the left texture in the next compute pass. Thus, each texture moves from left to right across the grid of quads.\n\n### Next steps\n\nIn this sample, you learned how to encode resources into argument buffers with a graphics or compute function. In [doc:\/\/com.apple.metal\/documentation\/Metal\/rendering-terrain-dynamically-with-argument-buffers], you’ll learn how to combine several argument buffer techniques to render a dynamic terrain in real time.\n\n## Argument buffers\n\n- **Improving CPU performance by using argument buffers**: Optimize your app’s performance by grouping your resources into argument buffers.\n- **Managing groups of resources with argument buffers**: Create argument buffers to organize related resources.\n- **Tracking the resource residency of argument buffers**: Optimize resource performance within an argument buffer.\n- **Indexing argument buffers**: Assign resource indices within an argument buffer.\n- **Rendering terrain dynamically with argument buffers**: Use argument buffers to render terrain in real time with a GPU-driven pipeline.\n- **Using argument buffers with resource heaps**: Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.\n- **MTLArgumentDescriptor**: A representation of an argument within an argument buffer.\n- **MTLArgumentEncoder**: An interface you can use to encode argument data into an argument buffer.\n- **MTLAttributeStrideStatic**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Optimize your app’s performance by grouping your resources into argument buffers.",
          "name" : "Improving CPU performance by using argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers"
        },
        {
          "description" : "Create argument buffers to organize related resources.",
          "name" : "Managing groups of resources with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-groups-of-resources-with-argument-buffers"
        },
        {
          "description" : "Optimize resource performance within an argument buffer.",
          "name" : "Tracking the resource residency of argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/tracking-the-resource-residency-of-argument-buffers"
        },
        {
          "description" : "Assign resource indices within an argument buffer.",
          "name" : "Indexing argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/indexing-argument-buffers"
        },
        {
          "description" : "Use argument buffers to render terrain in real time with a GPU-driven pipeline.",
          "name" : "Rendering terrain dynamically with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-terrain-dynamically-with-argument-buffers"
        },
        {
          "description" : "Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.",
          "name" : "Using argument buffers with resource heaps",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-argument-buffers-with-resource-heaps"
        },
        {
          "description" : "A representation of an argument within an argument buffer.",
          "name" : "MTLArgumentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentDescriptor"
        },
        {
          "description" : "An interface you can use to encode argument data into an argument buffer.",
          "name" : "MTLArgumentEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentEncoder"
        },
        {
          "description" : "",
          "name" : "MTLAttributeStrideStatic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAttributeStrideStatic"
        }
      ],
      "title" : "Argument buffers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Encoding argument buffers on the GPU",
  "url" : "https:\/\/developer.apple.com\/documentation\/metal\/encoding-argument-buffers-on-the-gpu"
}