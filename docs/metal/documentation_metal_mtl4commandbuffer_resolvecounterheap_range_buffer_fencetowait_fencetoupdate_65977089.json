{
  "abstract" : "Encodes a command that resolves an opaque counter heap into a buffer.",
  "codeExamples" : [

  ],
  "contentHash" : "2ce8a998810f11ea97f598edc5681e4e2c3d6110a6d903471ee1ea20d5f3a1cc",
  "crawledAt" : "2025-12-04T22:04:50Z",
  "declaration" : {
    "code" : "func resolveCounterHeap(_ counterHeap: any MTL4CounterHeap, range: Range<Int>, buffer: MTL4BufferRange, fenceToWait: (any MTLFence)? = nil, fenceToUpdate: (any MTLFence)? = nil)",
    "language" : "swift"
  },
  "id" : "FCCD4CF1-1A72-42E8-8A43-4A59088BA2FA",
  "kind" : "method",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Discussion\n\nThe command this method encodes converts the data within a counter heap into a common format and stores it into the `buffer` parameter.\n\nThe command places each entry in the counter heap within `range` sequentially, starting at `offset`. Each entry needs to be a fixed size that you can query by calling the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/size(ofCounterHeapEntry:)] method.\n\nThis command runs during the `MTLStageBlit` stage of the GPU timeline. Barrier against this stage to ensure the data is present in the resolve buffer parameter before you access it.\n\nSimilarly, your app needs to synchronize any GPU accesses to `buffer` after the command completes with barrier.\n\nIf your app needs to access `buffer` from the CPU, signal an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] to notify the CPU when it’s ready. Alternatively, you can resolve the heap’s data from the CPU by calling the heap’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CounterHeap\/resolveCounterRange:] method.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/MTL4CommandBuffer\/resolveCounterHeap(_:range:buffer:fenceToWait:fenceToUpdate:)\ncrawled: 2025-12-04T22:04:50Z\n---\n\n# resolveCounterHeap(_:range:buffer:fenceToWait:fenceToUpdate:)\n\n**Instance Method**\n\nEncodes a command that resolves an opaque counter heap into a buffer.\n\n## Declaration\n\n```swift\nfunc resolveCounterHeap(_ counterHeap: any MTL4CounterHeap, range: Range<Int>, buffer: MTL4BufferRange, fenceToWait: (any MTLFence)? = nil, fenceToUpdate: (any MTLFence)? = nil)\n```\n\n## Parameters\n\n- **counterHeap**: A heap the command resolves.\n- **range**: A range of index values within the heap the command resolves.\n- **buffer**: A buffer the command saves the data it resolves into.\n- **fenceToWait**: A fence the GPU waits for before starting, if applicable; otherwise `nil`.\n- **fenceToUpdate**: A fence the system updates after the command finishes resolving the data; otherwise `nil`.\n\n## Discussion\n\nThe command this method encodes converts the data within a counter heap into a common format and stores it into the `buffer` parameter.\n\nThe command places each entry in the counter heap within `range` sequentially, starting at `offset`. Each entry needs to be a fixed size that you can query by calling the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/size(ofCounterHeapEntry:)] method.\n\nThis command runs during the `MTLStageBlit` stage of the GPU timeline. Barrier against this stage to ensure the data is present in the resolve buffer parameter before you access it.\n\n\n\nSimilarly, your app needs to synchronize any GPU accesses to `buffer` after the command completes with barrier.\n\nIf your app needs to access `buffer` from the CPU, signal an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] to notify the CPU when it’s ready. Alternatively, you can resolve the heap’s data from the CPU by calling the heap’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CounterHeap\/resolveCounterRange:] method.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "resolveCounterHeap(_:range:buffer:fenceToWait:fenceToUpdate:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4CommandBuffer\/resolveCounterHeap(_:range:buffer:fenceToWait:fenceToUpdate:)"
}