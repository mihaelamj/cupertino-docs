{
  "abstract" : "Run draw commands that render to different outputs using the same vertex data multiple times.",
  "codeExamples" : [
    {
      "code" : "vertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    ...\n}",
      "language" : "metal"
    },
    {
      "code" : "struct VertexOut\n{\n    int data;\n    ...\n};\n\n...\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n \n    if (amp_count == 1) {\n        \/\/ The draw command isn't using vertex amplification.\n        ...\n    } else {\n        out.data = buffer[amp_id];\n        ...\n    }\n\n    ...\n    return out;\n}",
      "language" : "metal"
    },
    {
      "code" : "#define PositionAttribute            0\n#define TextureCoordinatesAttribute  1\n#define NormalAttribute              2\n\nstruct VertexIn\n{\n    float3 position         [[attribute(PositionAttribute)]];\n    float2 textureLocation  [[attribute(TextureCoordinatesAttribute)]];\n    float3 normal           [[attribute(NormalAttribute)]];\n};\n\nstruct VertexOut\n{\n    int data;\n    float4 position [[position]];\n    float3 normal;\n    float2 textureLocation [[shared]];\n};\n\n...\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a shared value because it's the same for all copies of the vertex.\n    out.normal = in.normal;\n\n    ...\n    return out;\n}",
      "language" : "metal"
    },
    {
      "code" : "struct VertexOut\n{\n    int data;\n    ...\n};\n\n...\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a nonshared value because it depends on the [[amplification_id]] parameter.\n    out.data = buffer[amp_id];\n\n    ...\n    return out;\n}",
      "language" : "metal"
    },
    {
      "code" : "#define PositionAttribute            0\n...\n\nstruct VertexIn\n{\n    float3 position         [[attribute(PositionAttribute)]];\n    ...\n };\n\n\nstruct VertexOut\n{\n    ...\n    float4 position [[position]];\n    ...\n};\n\nconstant float4x4 transform = { ... };\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a nonshared value because the assignment stores the result to the [[position]] parameter.\n    out.position = transform * float4(in.position, 1.0);\n\n    ...\n    return out;\n}",
      "language" : "metal"
    },
    {
      "code" : "struct VertexOut\n{\n    ...\n     float2 textureLocation [[shared]];\n};\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a shared value the `VertexOut` type declares with the [[shared]] attribute.\n    out.textureLocation = in.position.xy;\n\n    ...\n    return out;\n}",
      "language" : "metal"
    }
  ],
  "contentHash" : "79d3ebc40debafdc0ed7ddf292da094478e661f91b251695e96bdefddd3abd03",
  "crawledAt" : "2025-12-03T13:12:49Z",
  "id" : "BC0C4357-D6DE-4E95-BCC8-7F934278F8E7",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nWith *vertex amplification*, you can encode drawing commands that process the same vertex multiple times, one per render target. Vertex amplification generates copies of a command’s vertex data for each render pipeline. Vertex amplification is more efficient than encoding the command multiple times with the same vertex because the GPU fetches the vertex data only once. The GPU then calls your vertex function multiple times — equal to the amplification multiplier — for each vertex.\n\n\n\nFor example, you can use vertex amplification to implement cascaded shadow maps, with an amplification multiplier that’s equal to the number of cascade levels.\n\nApps typically leverage vertex amplification to render the same vertices to different texture layers or to multiple viewports. For more information about these techniques, see [doc:\/\/com.apple.metal\/documentation\/Metal\/rendering-to-multiple-texture-slices-in-a-draw-command] and [doc:\/\/com.apple.metal\/documentation\/Metal\/rendering-to-multiple-viewports-in-a-draw-command].\n\n### Check whether a GPU supports a vertex amplification multiplier\n\nConfirm whether the GPU supports a specific multiplier for vertex amplification by passing its integer value to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsVertexAmplificationCount(_:)] method. Pass an amplification multiplier value that’s `2` or greater. A value of `1` has no effect because it effectively disables vertex amplification.\n\nAfter your app confirms that the GPU supports a vertex amplification multiplier at runtime, it can safely configure a pipeline state to use that multiplier.\n\n### Set a render pipeline descriptor’s largest vertex amplification multiplier\n\nConfigure an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount] property to a multiplier value that the GPU supports. Any encoders you create with the descriptor can support any vertex amplification factor in the range `[1, `[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount]`]`.\n\nContinue configuring your pipeline descriptor and create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineState] instance with it that you can assign to a render command encoder.\n\nThe example above sets the descriptor’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount] property to `2`. Most apps typically set this property to the largest amplification factor the GPU supports. That way, an encoder that uses the pipeline state from that descriptor has the option to use any valid vertex amplification factor for that GPU.\n\n### Enable vertex amplification for a render pass\n\nConfigure an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] instance to apply vertex amplification for subsequent rendering commands by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexAmplificationCount(_:viewMappings:)] method.\n\nSet the vertex amplification count parameter to a value that’s less than or equal to the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount] property that configures the current render pipeline.\n\nYou can also provide an array of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLVertexAmplificationViewMapping] instances as you configure vertex amplification. Apps typically provide view mappings to render to multiple textures or viewports with vertex amplification.\n\nThe following example sets the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLVertexAmplificationViewMapping\/renderTargetArrayIndexOffset] values to `0` and `1` for the first and second mappings, respectively. It also sets the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLVertexAmplificationViewMapping\/viewportArrayIndexOffset] values to `1` and `2` for the first and second mappings, respectively.\n\nThe GPU adds these offsets to the vertex shader outputs with the corresponding attribute. In this example, the GPU adds `0` and `1` to the output value with the `[[render_target_array_index]]` attribute for the first and second pipeline invocations, respectively. It also adds `1` and `2` to the output value with the `[[viewport_array_index]]` attribute for the first and second pipeline invocations, respectively.\n\nSee the [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf] for information about applying an attribute to a parameter of a GPU function (shader and kernel).\n\n### Add vertex amplification to your vertex shader\n\nImplement vertex amplification in your shader code by adding parameters that represent the amplification ID and amplification factor. Designate which parameter is which by appending an attribute to each.\n\nFor example, the parameter with the `[[amplification_id]]` attribute represents the unique identifier for each copy of the vertex data. The parameter with the `[[amplification_count]]` attribute represents the total number of unique identifiers.\n\nThe GPU invokes the shader one time for each amplification ID. For each invocation, the GPU sets the parameter with the `[[amplification_id]]` to a unique value in the range `[0, amplification_count - 1]`. The GPU sets the parameter with the `[[amplification_count]]` attribute to the same amplification factor you configure the draw command to use for all invocations.\n\nYou can customize your shader’s behavior for each render pipeline instance with these parameters, which are `amp_id` and `amp_count` in these examples.\n\nYou can also invoke shaders that have these parameters with a draw call that’s not applying vertex amplification. In those scenarios, the GPU calls the shader once per vertex, and sets the parameters with `[[amplification_id]]` and `[[amplification_count]]` to `0` and `1`, respectively.\n\n### Mark values common to all vertices as shared\n\nYou can help reduce the GPU’s runtime workload by annotating values that are the same for all amplification IDs of a vertex. The Metal compiler detects values that remain consistent across all amplification IDs as *shared* values. You can also tell the compiler which values you consider shared by adding the `[[shared]]` attribute.\n\nBy default, the Metal shader compiler looks for shared values by detecting calculations that have the same value for all amplification IDs of a vertex. The compiler instructs the GPU to calculate these values once per vertex so that the GPU doesn’t calculate the same value for every amplification ID. For example, if the shader copies a value directly from an input, the compiler infers that as a shared value.\n\nThe compiler can also infer other calculations as a shared value if a vertex’s calculation result is the same for all amplification IDs.\n\nConversely, the compiler infers other calculations that vary across amplification IDs as *nonshared*. For example, a calculation that depends on the `[[amplification_id]]` parameter is a nonshared value because the amplification ID changes for each vertex copy.\n\nThe compiler also infers any calculation that depends on a `[[position]]` parameter as a nonshared value.\n\nThe compiler infers other calculations as shared values if it can prove the result is the same for all amplification IDs. However, you can explicitly designate a parameter as a shared value by adding the `[[shared]]` attribute as a hint to the shader compiler.\n\n### Combine vertex amplification with primitive instancing\n\n*Primitive instancing* is another way to generate copies of vertex data by providing additional data that modifies the original vertices for each instance. For example, you might animate a model by altering its vertex data with a sequence of pose offsets, each corresponding to a frame of animation.\n\nPrimitive instancing generates a copy of vertex data for each instance. If you encode a draw call with an instance count of `10`, the GPU invokes the render pipeline 10 times, once per instance. Unlike vertex amplification, the GPU recalculates all vertex output values each time it invokes your vertex shader.\n\nYou can apply both vertex amplification and primitive instancing in the same render pass for separate components of the scene. You can use primitive instancing to draw multiple characters for a scene and then use vertex amplification to render to different shadow maps.\n\nThe total number of render pipelines instances is equal to the product of the vertex amplification factor and the number of primitive instances. For example, if you encode a draw call with `10` primitive instances and a vertex amplification factor of `2`, the GPU calls your vertex shader 20 times per vertex. In this case, the vertex shader runs twice for each of the 10 instances. However, the GPU calculates the vertex amplification’s shared output values once per vertex for all amplification IDs.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/improving-rendering-performance-with-vertex-amplification\ncrawled: 2025-12-03T13:12:49Z\n---\n\n# Improving rendering performance with vertex amplification\n\n**Article**\n\nRun draw commands that render to different outputs using the same vertex data multiple times.\n\n## Overview\n\nWith *vertex amplification*, you can encode drawing commands that process the same vertex multiple times, one per render target. Vertex amplification generates copies of a command’s vertex data for each render pipeline. Vertex amplification is more efficient than encoding the command multiple times with the same vertex because the GPU fetches the vertex data only once. The GPU then calls your vertex function multiple times — equal to the amplification multiplier — for each vertex.\n\n\n\nFor example, you can use vertex amplification to implement cascaded shadow maps, with an amplification multiplier that’s equal to the number of cascade levels.\n\nApps typically leverage vertex amplification to render the same vertices to different texture layers or to multiple viewports. For more information about these techniques, see [doc:\/\/com.apple.metal\/documentation\/Metal\/rendering-to-multiple-texture-slices-in-a-draw-command] and [doc:\/\/com.apple.metal\/documentation\/Metal\/rendering-to-multiple-viewports-in-a-draw-command].\n\n### Check whether a GPU supports a vertex amplification multiplier\n\nConfirm whether the GPU supports a specific multiplier for vertex amplification by passing its integer value to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsVertexAmplificationCount(_:)] method. Pass an amplification multiplier value that’s `2` or greater. A value of `1` has no effect because it effectively disables vertex amplification.\n\n\n\nAfter your app confirms that the GPU supports a vertex amplification multiplier at runtime, it can safely configure a pipeline state to use that multiplier.\n\n### Set a render pipeline descriptor’s largest vertex amplification multiplier\n\nConfigure an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount] property to a multiplier value that the GPU supports. Any encoders you create with the descriptor can support any vertex amplification factor in the range `[1, `[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount]`]`.\n\n\n\nContinue configuring your pipeline descriptor and create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineState] instance with it that you can assign to a render command encoder.\n\nThe example above sets the descriptor’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount] property to `2`. Most apps typically set this property to the largest amplification factor the GPU supports. That way, an encoder that uses the pipeline state from that descriptor has the option to use any valid vertex amplification factor for that GPU.\n\n### Enable vertex amplification for a render pass\n\nConfigure an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] instance to apply vertex amplification for subsequent rendering commands by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexAmplificationCount(_:viewMappings:)] method.\n\n\n\nSet the vertex amplification count parameter to a value that’s less than or equal to the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor\/maxVertexAmplificationCount] property that configures the current render pipeline.\n\nYou can also provide an array of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLVertexAmplificationViewMapping] instances as you configure vertex amplification. Apps typically provide view mappings to render to multiple textures or viewports with vertex amplification.\n\nThe following example sets the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLVertexAmplificationViewMapping\/renderTargetArrayIndexOffset] values to `0` and `1` for the first and second mappings, respectively. It also sets the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLVertexAmplificationViewMapping\/viewportArrayIndexOffset] values to `1` and `2` for the first and second mappings, respectively.\n\nThe GPU adds these offsets to the vertex shader outputs with the corresponding attribute. In this example, the GPU adds `0` and `1` to the output value with the `[[render_target_array_index]]` attribute for the first and second pipeline invocations, respectively. It also adds `1` and `2` to the output value with the `[[viewport_array_index]]` attribute for the first and second pipeline invocations, respectively.\n\n\n\nSee the [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf] for information about applying an attribute to a parameter of a GPU function (shader and kernel).\n\n### Add vertex amplification to your vertex shader\n\nImplement vertex amplification in your shader code by adding parameters that represent the amplification ID and amplification factor. Designate which parameter is which by appending an attribute to each.\n\nFor example, the parameter with the `[[amplification_id]]` attribute represents the unique identifier for each copy of the vertex data. The parameter with the `[[amplification_count]]` attribute represents the total number of unique identifiers.\n\n```metal\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    ...\n}\n```\n\nThe GPU invokes the shader one time for each amplification ID. For each invocation, the GPU sets the parameter with the `[[amplification_id]]` to a unique value in the range `[0, amplification_count - 1]`. The GPU sets the parameter with the `[[amplification_count]]` attribute to the same amplification factor you configure the draw command to use for all invocations.\n\nYou can customize your shader’s behavior for each render pipeline instance with these parameters, which are `amp_id` and `amp_count` in these examples.\n\n```metal\nstruct VertexOut\n{\n    int data;\n    ...\n};\n\n...\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n \n    if (amp_count == 1) {\n        \/\/ The draw command isn't using vertex amplification.\n        ...\n    } else {\n        out.data = buffer[amp_id];\n        ...\n    }\n\n    ...\n    return out;\n}\n```\n\nYou can also invoke shaders that have these parameters with a draw call that’s not applying vertex amplification. In those scenarios, the GPU calls the shader once per vertex, and sets the parameters with `[[amplification_id]]` and `[[amplification_count]]` to `0` and `1`, respectively.\n\n### Mark values common to all vertices as shared\n\nYou can help reduce the GPU’s runtime workload by annotating values that are the same for all amplification IDs of a vertex. The Metal compiler detects values that remain consistent across all amplification IDs as *shared* values. You can also tell the compiler which values you consider shared by adding the `[[shared]]` attribute.\n\nBy default, the Metal shader compiler looks for shared values by detecting calculations that have the same value for all amplification IDs of a vertex. The compiler instructs the GPU to calculate these values once per vertex so that the GPU doesn’t calculate the same value for every amplification ID. For example, if the shader copies a value directly from an input, the compiler infers that as a shared value.\n\n```metal\n#define PositionAttribute            0\n#define TextureCoordinatesAttribute  1\n#define NormalAttribute              2\n\nstruct VertexIn\n{\n    float3 position         [[attribute(PositionAttribute)]];\n    float2 textureLocation  [[attribute(TextureCoordinatesAttribute)]];\n    float3 normal           [[attribute(NormalAttribute)]];\n};\n\nstruct VertexOut\n{\n    int data;\n    float4 position [[position]];\n    float3 normal;\n    float2 textureLocation [[shared]];\n};\n\n...\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a shared value because it's the same for all copies of the vertex.\n    out.normal = in.normal;\n\n    ...\n    return out;\n}\n```\n\nThe compiler can also infer other calculations as a shared value if a vertex’s calculation result is the same for all amplification IDs.\n\nConversely, the compiler infers other calculations that vary across amplification IDs as *nonshared*. For example, a calculation that depends on the `[[amplification_id]]` parameter is a nonshared value because the amplification ID changes for each vertex copy.\n\n```metal\nstruct VertexOut\n{\n    int data;\n    ...\n};\n\n...\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a nonshared value because it depends on the [[amplification_id]] parameter.\n    out.data = buffer[amp_id];\n\n    ...\n    return out;\n}\n```\n\nThe compiler also infers any calculation that depends on a `[[position]]` parameter as a nonshared value.\n\n```metal\n#define PositionAttribute            0\n...\n\nstruct VertexIn\n{\n    float3 position         [[attribute(PositionAttribute)]];\n    ...\n };\n\n\nstruct VertexOut\n{\n    ...\n    float4 position [[position]];\n    ...\n};\n\nconstant float4x4 transform = { ... };\n\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a nonshared value because the assignment stores the result to the [[position]] parameter.\n    out.position = transform * float4(in.position, 1.0);\n\n    ...\n    return out;\n}\n```\n\n\n\nThe compiler infers other calculations as shared values if it can prove the result is the same for all amplification IDs. However, you can explicitly designate a parameter as a shared value by adding the `[[shared]]` attribute as a hint to the shader compiler.\n\n```metal\nstruct VertexOut\n{\n    ...\n     float2 textureLocation [[shared]];\n};\nvertex VertexOut vs_main(VertexIn in[[stage_in]],\n                         ushort amp_id [[amplification_id]],\n                         ushort amp_count [[amplification_count]],\n                         constant int* buffer)\n{\n    VertexOut out;\n    ...\n\n    \/\/ This is a shared value the `VertexOut` type declares with the [[shared]] attribute.\n    out.textureLocation = in.position.xy;\n\n    ...\n    return out;\n}\n```\n\n### Combine vertex amplification with primitive instancing\n\n*Primitive instancing* is another way to generate copies of vertex data by providing additional data that modifies the original vertices for each instance. For example, you might animate a model by altering its vertex data with a sequence of pose offsets, each corresponding to a frame of animation.\n\nPrimitive instancing generates a copy of vertex data for each instance. If you encode a draw call with an instance count of `10`, the GPU invokes the render pipeline 10 times, once per instance. Unlike vertex amplification, the GPU recalculates all vertex output values each time it invokes your vertex shader.\n\nYou can apply both vertex amplification and primitive instancing in the same render pass for separate components of the scene. You can use primitive instancing to draw multiple characters for a scene and then use vertex amplification to render to different shadow maps.\n\nThe total number of render pipelines instances is equal to the product of the vertex amplification factor and the number of primitive instances. For example, if you encode a draw call with `10` primitive instances and a vertex amplification factor of `2`, the GPU calls your vertex shader 20 times per vertex. In this case, the vertex shader runs twice for each of the 10 instances. However, the GPU calculates the vertex amplification’s shared output values once per vertex for all amplification IDs.\n\n## Applying rendering techniques\n\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Customizing render pass setup**: Render into an offscreen texture by creating a custom render pass.\n- **Setting load and store actions**: Set actions that define how a render pass loads and stores a render target.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Render into an offscreen texture by creating a custom render pass.",
          "name" : "Customizing render pass setup",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup"
        },
        {
          "description" : "Set actions that define how a render pass loads and stores a render target.",
          "name" : "Setting load and store actions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/setting-load-and-store-actions"
        }
      ],
      "title" : "Applying rendering techniques"
    }
  ],
  "source" : "appleJSON",
  "title" : "Improving rendering performance with vertex amplification",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-rendering-performance-with-vertex-amplification"
}