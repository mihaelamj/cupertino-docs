{
  "abstract" : "Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.",
  "codeExamples" : [
    {
      "code" : "fragment float4\nexampleFragmentFunction(array<texture2d<float>, 10> textureParameters [[ texture(5) ]])",
      "language" : "metal"
    },
    {
      "code" : "struct FragmentShaderArguments {\n    array<texture2d<float>, AAPLNumTextureArguments> exampleTextures  [[ id(AAPLArgumentBufferIDExampleTextures)  ]];\n    array<device float *,  AAPLNumBufferArguments>   exampleBuffers   [[ id(AAPLArgumentBufferIDExampleBuffers)   ]];\n    array<uint32_t, AAPLNumBufferArguments>          exampleConstants [[ id(AAPLArgumentBufferIDExampleConstants) ]];\n};",
      "language" : "metal"
    },
    {
      "code" : "for(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n{\n    [argumentEncoder setTexture:_texture[i]\n                        atIndex:AAPLArgumentBufferIDExampleTextures+i];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "for(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n{\n    [argumentEncoder setBuffer:_dataBuffer[i]\n                        offset:0\n                        atIndex:AAPLArgumentBufferIDExampleBuffers+i];\n\n    uint32_t *elementCountAddress =\n        [argumentEncoder constantDataAtIndex:AAPLArgumentBufferIDExampleConstants+i];\n\n    *elementCountAddress = (uint32_t)_dataBuffer[i].length \/ 4;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "for(uint32_t textureToSample = 0; textureToSample < AAPLNumTextureArguments; textureToSample++)\n{\n    float4 textureValue = fragmentShaderArgs.exampleTextures[textureToSample].sample(textureSampler, in.texCoord);\n\n    color += textureValue;\n}",
      "language" : "metal"
    },
    {
      "code" : "\/\/ Use texCoord.x to select the buffer to read from\nuint32_t bufferToRead = (in.texCoord.x-0.5)*2.0 * (AAPLNumBufferArguments-1);\n\n\/\/ Retrieve the number of elements for the selected buffer from\n\/\/ the array of constants in the argument buffer\nuint32_t numElements = fragmentShaderArgs.exampleConstants[bufferToRead];\n\n\/\/ Determine the index used to read from the buffer\nuint32_t indexToRead = in.texCoord.y * numElements;\n\n\/\/ Retrieve the buffer to read from by accessing the array of\n\/\/ buffers in the argument buffer\ndevice float* buffer = fragmentShaderArgs.exampleBuffers[bufferToRead];\n\n\/\/ Read from the buffer and assign the value to the output color\ncolor = buffer[indexToRead];",
      "language" : "metal"
    },
    {
      "code" : "- (void) createHeap\n{\n    MTLHeapDescriptor *heapDescriptor = [MTLHeapDescriptor new];\n    heapDescriptor.storageMode = MTLStorageModePrivate;\n    heapDescriptor.size =  0;\n\n    \/\/ Build a descriptor for each texture and calculate the size required to store all textures in the heap\n    for(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n    {\n        \/\/ Create a descriptor using the texture's properties\n        MTLTextureDescriptor *descriptor = [AAPLRenderer newDescriptorFromTexture:_texture[i]\n                                                                      storageMode:heapDescriptor.storageMode];\n\n        \/\/ Determine the size required for the heap for the given descriptor\n        MTLSizeAndAlign sizeAndAlign = [_device heapTextureSizeAndAlignWithDescriptor:descriptor];\n\n        \/\/ Align the size so that more resources will fit in the heap after this texture\n        sizeAndAlign.size += (sizeAndAlign.size & (sizeAndAlign.align - 1)) + sizeAndAlign.align;\n\n        \/\/ Accumulate the size required to store this texture in the heap\n        heapDescriptor.size += sizeAndAlign.size;\n    }\n\n    \/\/ Calculate the size required to store all buffers in the heap\n    for(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n    {\n        \/\/ Determine the size required for the heap for the given buffer size\n        MTLSizeAndAlign sizeAndAlign = [_device heapBufferSizeAndAlignWithLength:_dataBuffer[i].length\n                                                                         options:MTLResourceStorageModePrivate];\n\n        \/\/ Align the size so that more resources will fit in the heap after this buffer\n        sizeAndAlign.size +=  (sizeAndAlign.size & (sizeAndAlign.align - 1)) + sizeAndAlign.align;\n\n        \/\/ Accumulate the size required to store this buffer in the heap\n        heapDescriptor.size += sizeAndAlign.size;\n    }\n\n    \/\/ Create a heap large enough to store all resources\n    _heap = [_device newHeapWithDescriptor:heapDescriptor];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "- (void)moveResourcesToHeap\n{\n    \/\/ Create a command buffer and blit encoder to copy data from the existing resources to\n    \/\/ the new resources created from the heap\n    id <MTLCommandBuffer> commandBuffer = [_commandQueue commandBuffer];\n    commandBuffer.label = @\"Heap Copy Command Buffer\";\n\n    id <MTLBlitCommandEncoder> blitEncoder = commandBuffer.blitCommandEncoder;\n    blitEncoder.label = @\"Heap Transfer Blit Encoder\";\n\n    \/\/ Create new textures from the heap and copy the contents of the existing textures to\n    \/\/ the new textures\n    for(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n    {\n        \/\/ Create a descriptor using the texture's properties\n        MTLTextureDescriptor *descriptor = [AAPLRenderer newDescriptorFromTexture:_texture[i]\n                                                                      storageMode:_heap.storageMode];\n\n        \/\/ Create a texture from the heap\n        id<MTLTexture> heapTexture = [_heap newTextureWithDescriptor:descriptor];\n\n        heapTexture.label = _texture[i].label;\n\n        [blitEncoder pushDebugGroup:[NSString stringWithFormat:@\"%@ Blits\", heapTexture.label]];\n\n        \/\/ Blit every slice of every level from the existing texture to the new texture\n        MTLRegion region = MTLRegionMake2D(0, 0, _texture[i].width, _texture[i].height);\n        for(NSUInteger level = 0; level < _texture[i].mipmapLevelCount;  level++)\n        {\n\n            [blitEncoder pushDebugGroup:[NSString stringWithFormat:@\"Level %lu Blit\", level]];\n\n            for(NSUInteger slice = 0; slice < _texture[i].arrayLength; slice++)\n            {\n                [blitEncoder copyFromTexture:_texture[i]\n                                 sourceSlice:slice\n                                 sourceLevel:level\n                                sourceOrigin:region.origin\n                                  sourceSize:region.size\n                                   toTexture:heapTexture\n                            destinationSlice:slice\n                            destinationLevel:level\n                           destinationOrigin:region.origin];\n            }\n            region.size.width \/= 2;\n            region.size.height \/= 2;\n            if(region.size.width == 0) region.size.width = 1;\n            if(region.size.height == 0) region.size.height = 1;\n\n            [blitEncoder popDebugGroup];\n        }\n\n        [blitEncoder popDebugGroup];\n\n        \/\/ Replace the existing texture with the new texture\n        _texture[i] = heapTexture;\n    }\n\n    \/\/ Create new buffers from the heap and copy the contents of existing buffers to the\n    \/\/ new buffers\n    for(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n    {\n        \/\/ Create a buffer from the heap\n        id<MTLBuffer> heapBuffer = [_heap newBufferWithLength:_dataBuffer[i].length\n                                                      options:MTLResourceStorageModePrivate];\n\n        heapBuffer.label = _dataBuffer[i].label;\n\n        \/\/ Blit contents of the original buffer to the new buffer\n        [blitEncoder copyFromBuffer:_dataBuffer[i]\n                       sourceOffset:0\n                           toBuffer:heapBuffer\n                  destinationOffset:0\n                               size:heapBuffer.length];\n\n        \/\/ Replace the existing buffer with the new buffer\n        _dataBuffer[i] = heapBuffer;\n    }\n\n    [blitEncoder endEncoding];\n    [commandBuffer commit];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "#if ENABLE_RESOURCE_HEAP\n        \/\/ Make a single `useHeap:` call for the entire heap, instead of one\n        \/\/ `useResource:usage:` call per texture and per buffer\n        [renderEncoder useHeap:_heap];\n#else\n        for(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n        {\n            \/\/ Indicate to Metal that these textures will be accessed by the GPU and\n            \/\/ therefore need to be mapped to the GPU's address space\n            [renderEncoder useResource:_texture[i] usage:MTLResourceUsageSample];\n        }\n\n        for(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n        {\n            \/\/ Indicate to Metal that these buffers will be accessed by the GPU and\n            \/\/ therefore need to be mapped to the GPU's address space\n            [renderEncoder useResource:_dataBuffer[i] usage:MTLResourceUsageRead];\n        }\n#endif",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "2b6cb06c17d7bfcced178b3ece9ae963851a4de301d8cf72b791a017b1188958",
  "crawledAt" : "2025-12-02T19:56:18Z",
  "id" : "A42846D7-4EFF-46C2-AD2C-597361E35EF1",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nIn the [doc:\/\/com.apple.documentation\/documentation\/Metal\/managing-groups-of-resources-with-argument-buffers] sample, you learned how to specify, encode, set, and access resources in an argument buffer.\n\nIn this sample, you’ll learn how to combine argument buffers with arrays of resources and resource heaps. In particular, you’ll learn how to define an argument buffer structure that contains arrays and how to allocate and use resources from a heap. The sample renders a static quad that uses multiple resources encoded into an argument buffer.\n\n### Getting started\n\nThe Xcode project contains schemes for running the sample on macOS, iOS, or tvOS. Metal is not supported in the iOS or tvOS Simulator, so the iOS and tvOS schemes require a physical device to run the sample. The default scheme is macOS, which runs the sample as is on your Mac.\n\n### Arrays of arguments in the Metal shading language\n\nArrays can be used as parameters to graphics or compute functions. When a function takes an array as a parameter, the index of the first resource in the array is equal to the base index of the array parameter itself. Thus, each subsequent resource in the array is automatically assigned a subsequent index value, counting incrementally from the base index value.\n\nFor example, the following fragment function, `exampleFragmentFunction`, has a parameter, `textureParameters`, that’s an array of 10 textures with a base index value of `5`.\n\nBecause `textureParameters` has a `[[ texture(5) ]]` attribute qualifier, the corresponding Metal framework method to set this parameter is `setFragmentTexture:atIndex:`, where the values for `index` begin at `5`. Thus, the texture at array index `0` is set at index number `5`, the texture at array index `1` is set at index number `6`, and so on. The last texture in the array, at array index `9`, is set at index number `14`.\n\n### Define argument buffers with arrays\n\nArrays can also be used as elements of an argument buffer structure. In this case, the `[[ id(n) ]]` attribute qualifier of an argument buffer behaves the same way as the `[[ texture(n) ]]` attribute qualifier of a function parameter, where `n` is the base index value of the array. However, you don’t call the `setFragmentTexture:atIndex:` method, of a `MTLRenderCommandEncoder` object, to set a texture from the array. Instead, you call the `setTexture:atIndex:` method, of a `MTLArgumentEncoder` object, to encode a texture from the array into the argument buffer, where `index` corresponds to the base index value, `n`,  plus the index of the texture within the array.\n\nThe argument buffer in this sample is declared as a `FragmentShaderArguments` structure, and this is its definition:\n\nEach element of this structure uses the `array<T, N>` template, which defines the element as an array of a certain type, `T`, and number of elements, `N`. This argument buffer contains the following resources:\n\n\n\n### Encode array elements into an argument buffer\n\nThis sample encodes array elements into an argument buffer by matching the `index` parameter of each `setTexture:atIndex:`, `setBuffer:offset:atIndex:`, and `constantDataAtIndex:` method call to the element’s corresponding index value, defined by the `[[ id(n) ]]` attribute qualifier in the argument buffer.\n\n### Access array elements in an argument buffer\n\nWithin a function, accessing elements of an array encoded in an argument buffer is the same as accessing elements of a standard array. In this sample, the `exampleTextures`, `exampleBuffers`, and `exampleConstants` arrays are accessed via the `fragmentShaderArgs` parameter of the `fragmentShader` function. Each array element is accessed with the `[n]` subscript syntax, where `n` is the index of the element within the array.\n\nThe `fragmentShader` function contains an `if-else` condition that evaluates the `x` component of `texCoord` to determine which side of the quad the fragment is on. If the fragment is on the left side of the quad, the function samples each texture in the `exampleTextures` array and adds the sampled values to determine the final output color.\n\nIf the fragment is on right side of the quad, the function reads a value from the `exampleBuffers` array. The function uses the `x` component of `texCoord` to determine which buffer to read from and then uses the `y` component of `texCoord` to determine where in the buffer to read from. The value in the buffer determines the final output color.\n\n### Combine argument buffers with resource heaps\n\nThe fragment function accesses 32 textures and 32 buffers via the argument buffer, totaling 64 different resources overall. If memory for each of these resources was allocated individually, despite residing in arrays, Metal would need to validate the memory of 64 individual resources before making these resources accessible to the GPU.\n\nInstead, this sample allocates resources from a `MTLHeap` object. A heap is a single memory region from which multiple resources can be allocated. Therefore, the sample can make the heap’s entire memory, including the memory of all the resources within the heap, accessible to the GPU by calling the `useHeap:` method once.\n\nThe sample implements a `loadResources` method that loads the resource data into temporary `MTLTexture` and `MTLBuffer` objects. Then, the sample implements a `createHeap` method that calculates the total size required to store the resource data in the heap and creates the heap itself.\n\nThe sample implements a `moveResourcesToHeap` method that creates permanent `MTLTexture` and `MTLBuffer` objects allocated from the heap. Then, the method uses a `MTLBlitCommandEncoder` to copy the resource data from the temporary objects to the permanent objects.\n\nBefore using these resources, instead of calling the `useResource:usage:` method once for each resource, the sample calls the `useHeap:` method once for the entire heap.\n\n### Next steps\n\nIn this sample, you learned how to combine argument buffers with arrays of resources and resource heaps. In the [doc:\/\/com.apple.documentation\/documentation\/Metal\/encoding-argument-buffers-on-the-gpu] sample, you’ll learn how to encode resources into argument buffers with a graphics or compute function.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/metal\/using-argument-buffers-with-resource-heaps\ncrawled: 2025-12-02T19:56:18Z\n---\n\n# Using argument buffers with resource heaps\n\n**Sample Code**\n\nReduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.\n\n## Overview\n\nIn the [doc:\/\/com.apple.documentation\/documentation\/Metal\/managing-groups-of-resources-with-argument-buffers] sample, you learned how to specify, encode, set, and access resources in an argument buffer.\n\nIn this sample, you’ll learn how to combine argument buffers with arrays of resources and resource heaps. In particular, you’ll learn how to define an argument buffer structure that contains arrays and how to allocate and use resources from a heap. The sample renders a static quad that uses multiple resources encoded into an argument buffer.\n\n### Getting started\n\nThe Xcode project contains schemes for running the sample on macOS, iOS, or tvOS. Metal is not supported in the iOS or tvOS Simulator, so the iOS and tvOS schemes require a physical device to run the sample. The default scheme is macOS, which runs the sample as is on your Mac.\n\n### Arrays of arguments in the Metal shading language\n\nArrays can be used as parameters to graphics or compute functions. When a function takes an array as a parameter, the index of the first resource in the array is equal to the base index of the array parameter itself. Thus, each subsequent resource in the array is automatically assigned a subsequent index value, counting incrementally from the base index value.\n\nFor example, the following fragment function, `exampleFragmentFunction`, has a parameter, `textureParameters`, that’s an array of 10 textures with a base index value of `5`.\n\n```metal\nfragment float4\nexampleFragmentFunction(array<texture2d<float>, 10> textureParameters [[ texture(5) ]])\n```\n\nBecause `textureParameters` has a `[[ texture(5) ]]` attribute qualifier, the corresponding Metal framework method to set this parameter is `setFragmentTexture:atIndex:`, where the values for `index` begin at `5`. Thus, the texture at array index `0` is set at index number `5`, the texture at array index `1` is set at index number `6`, and so on. The last texture in the array, at array index `9`, is set at index number `14`.\n\n### Define argument buffers with arrays\n\nArrays can also be used as elements of an argument buffer structure. In this case, the `[[ id(n) ]]` attribute qualifier of an argument buffer behaves the same way as the `[[ texture(n) ]]` attribute qualifier of a function parameter, where `n` is the base index value of the array. However, you don’t call the `setFragmentTexture:atIndex:` method, of a `MTLRenderCommandEncoder` object, to set a texture from the array. Instead, you call the `setTexture:atIndex:` method, of a `MTLArgumentEncoder` object, to encode a texture from the array into the argument buffer, where `index` corresponds to the base index value, `n`,  plus the index of the texture within the array.\n\nThe argument buffer in this sample is declared as a `FragmentShaderArguments` structure, and this is its definition:\n\n```metal\nstruct FragmentShaderArguments {\n    array<texture2d<float>, AAPLNumTextureArguments> exampleTextures  [[ id(AAPLArgumentBufferIDExampleTextures)  ]];\n    array<device float *,  AAPLNumBufferArguments>   exampleBuffers   [[ id(AAPLArgumentBufferIDExampleBuffers)   ]];\n    array<uint32_t, AAPLNumBufferArguments>          exampleConstants [[ id(AAPLArgumentBufferIDExampleConstants) ]];\n};\n```\n\nEach element of this structure uses the `array<T, N>` template, which defines the element as an array of a certain type, `T`, and number of elements, `N`. This argument buffer contains the following resources:\n\n- `exampleTextures`, an array of 32 2D textures with a base index value of `0`.\n- `exampleBuffers`, an array of 32 `float` buffers with a base index value of `100`.\n- `exampleConstants`, an array of 32 `uint32_t` constants with a base index value of `200`.\n\n\n\n### Encode array elements into an argument buffer\n\nThis sample encodes array elements into an argument buffer by matching the `index` parameter of each `setTexture:atIndex:`, `setBuffer:offset:atIndex:`, and `constantDataAtIndex:` method call to the element’s corresponding index value, defined by the `[[ id(n) ]]` attribute qualifier in the argument buffer.\n\n```objective-c\nfor(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n{\n    [argumentEncoder setTexture:_texture[i]\n                        atIndex:AAPLArgumentBufferIDExampleTextures+i];\n}\n```\n\n```objective-c\nfor(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n{\n    [argumentEncoder setBuffer:_dataBuffer[i]\n                        offset:0\n                        atIndex:AAPLArgumentBufferIDExampleBuffers+i];\n\n    uint32_t *elementCountAddress =\n        [argumentEncoder constantDataAtIndex:AAPLArgumentBufferIDExampleConstants+i];\n\n    *elementCountAddress = (uint32_t)_dataBuffer[i].length \/ 4;\n}\n```\n\n### Access array elements in an argument buffer\n\nWithin a function, accessing elements of an array encoded in an argument buffer is the same as accessing elements of a standard array. In this sample, the `exampleTextures`, `exampleBuffers`, and `exampleConstants` arrays are accessed via the `fragmentShaderArgs` parameter of the `fragmentShader` function. Each array element is accessed with the `[n]` subscript syntax, where `n` is the index of the element within the array.\n\n```metal\nfor(uint32_t textureToSample = 0; textureToSample < AAPLNumTextureArguments; textureToSample++)\n{\n    float4 textureValue = fragmentShaderArgs.exampleTextures[textureToSample].sample(textureSampler, in.texCoord);\n\n    color += textureValue;\n}\n```\n\nThe `fragmentShader` function contains an `if-else` condition that evaluates the `x` component of `texCoord` to determine which side of the quad the fragment is on. If the fragment is on the left side of the quad, the function samples each texture in the `exampleTextures` array and adds the sampled values to determine the final output color.\n\nIf the fragment is on right side of the quad, the function reads a value from the `exampleBuffers` array. The function uses the `x` component of `texCoord` to determine which buffer to read from and then uses the `y` component of `texCoord` to determine where in the buffer to read from. The value in the buffer determines the final output color.\n\n```metal\n\/\/ Use texCoord.x to select the buffer to read from\nuint32_t bufferToRead = (in.texCoord.x-0.5)*2.0 * (AAPLNumBufferArguments-1);\n\n\/\/ Retrieve the number of elements for the selected buffer from\n\/\/ the array of constants in the argument buffer\nuint32_t numElements = fragmentShaderArgs.exampleConstants[bufferToRead];\n\n\/\/ Determine the index used to read from the buffer\nuint32_t indexToRead = in.texCoord.y * numElements;\n\n\/\/ Retrieve the buffer to read from by accessing the array of\n\/\/ buffers in the argument buffer\ndevice float* buffer = fragmentShaderArgs.exampleBuffers[bufferToRead];\n\n\/\/ Read from the buffer and assign the value to the output color\ncolor = buffer[indexToRead];\n```\n\n### Combine argument buffers with resource heaps\n\nThe fragment function accesses 32 textures and 32 buffers via the argument buffer, totaling 64 different resources overall. If memory for each of these resources was allocated individually, despite residing in arrays, Metal would need to validate the memory of 64 individual resources before making these resources accessible to the GPU.\n\nInstead, this sample allocates resources from a `MTLHeap` object. A heap is a single memory region from which multiple resources can be allocated. Therefore, the sample can make the heap’s entire memory, including the memory of all the resources within the heap, accessible to the GPU by calling the `useHeap:` method once.\n\nThe sample implements a `loadResources` method that loads the resource data into temporary `MTLTexture` and `MTLBuffer` objects. Then, the sample implements a `createHeap` method that calculates the total size required to store the resource data in the heap and creates the heap itself.\n\n```objective-c\n- (void) createHeap\n{\n    MTLHeapDescriptor *heapDescriptor = [MTLHeapDescriptor new];\n    heapDescriptor.storageMode = MTLStorageModePrivate;\n    heapDescriptor.size =  0;\n\n    \/\/ Build a descriptor for each texture and calculate the size required to store all textures in the heap\n    for(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n    {\n        \/\/ Create a descriptor using the texture's properties\n        MTLTextureDescriptor *descriptor = [AAPLRenderer newDescriptorFromTexture:_texture[i]\n                                                                      storageMode:heapDescriptor.storageMode];\n\n        \/\/ Determine the size required for the heap for the given descriptor\n        MTLSizeAndAlign sizeAndAlign = [_device heapTextureSizeAndAlignWithDescriptor:descriptor];\n\n        \/\/ Align the size so that more resources will fit in the heap after this texture\n        sizeAndAlign.size += (sizeAndAlign.size & (sizeAndAlign.align - 1)) + sizeAndAlign.align;\n\n        \/\/ Accumulate the size required to store this texture in the heap\n        heapDescriptor.size += sizeAndAlign.size;\n    }\n\n    \/\/ Calculate the size required to store all buffers in the heap\n    for(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n    {\n        \/\/ Determine the size required for the heap for the given buffer size\n        MTLSizeAndAlign sizeAndAlign = [_device heapBufferSizeAndAlignWithLength:_dataBuffer[i].length\n                                                                         options:MTLResourceStorageModePrivate];\n\n        \/\/ Align the size so that more resources will fit in the heap after this buffer\n        sizeAndAlign.size +=  (sizeAndAlign.size & (sizeAndAlign.align - 1)) + sizeAndAlign.align;\n\n        \/\/ Accumulate the size required to store this buffer in the heap\n        heapDescriptor.size += sizeAndAlign.size;\n    }\n\n    \/\/ Create a heap large enough to store all resources\n    _heap = [_device newHeapWithDescriptor:heapDescriptor];\n}\n```\n\nThe sample implements a `moveResourcesToHeap` method that creates permanent `MTLTexture` and `MTLBuffer` objects allocated from the heap. Then, the method uses a `MTLBlitCommandEncoder` to copy the resource data from the temporary objects to the permanent objects.\n\n```objective-c\n- (void)moveResourcesToHeap\n{\n    \/\/ Create a command buffer and blit encoder to copy data from the existing resources to\n    \/\/ the new resources created from the heap\n    id <MTLCommandBuffer> commandBuffer = [_commandQueue commandBuffer];\n    commandBuffer.label = @\"Heap Copy Command Buffer\";\n\n    id <MTLBlitCommandEncoder> blitEncoder = commandBuffer.blitCommandEncoder;\n    blitEncoder.label = @\"Heap Transfer Blit Encoder\";\n\n    \/\/ Create new textures from the heap and copy the contents of the existing textures to\n    \/\/ the new textures\n    for(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n    {\n        \/\/ Create a descriptor using the texture's properties\n        MTLTextureDescriptor *descriptor = [AAPLRenderer newDescriptorFromTexture:_texture[i]\n                                                                      storageMode:_heap.storageMode];\n\n        \/\/ Create a texture from the heap\n        id<MTLTexture> heapTexture = [_heap newTextureWithDescriptor:descriptor];\n\n        heapTexture.label = _texture[i].label;\n\n        [blitEncoder pushDebugGroup:[NSString stringWithFormat:@\"%@ Blits\", heapTexture.label]];\n\n        \/\/ Blit every slice of every level from the existing texture to the new texture\n        MTLRegion region = MTLRegionMake2D(0, 0, _texture[i].width, _texture[i].height);\n        for(NSUInteger level = 0; level < _texture[i].mipmapLevelCount;  level++)\n        {\n\n            [blitEncoder pushDebugGroup:[NSString stringWithFormat:@\"Level %lu Blit\", level]];\n\n            for(NSUInteger slice = 0; slice < _texture[i].arrayLength; slice++)\n            {\n                [blitEncoder copyFromTexture:_texture[i]\n                                 sourceSlice:slice\n                                 sourceLevel:level\n                                sourceOrigin:region.origin\n                                  sourceSize:region.size\n                                   toTexture:heapTexture\n                            destinationSlice:slice\n                            destinationLevel:level\n                           destinationOrigin:region.origin];\n            }\n            region.size.width \/= 2;\n            region.size.height \/= 2;\n            if(region.size.width == 0) region.size.width = 1;\n            if(region.size.height == 0) region.size.height = 1;\n\n            [blitEncoder popDebugGroup];\n        }\n\n        [blitEncoder popDebugGroup];\n\n        \/\/ Replace the existing texture with the new texture\n        _texture[i] = heapTexture;\n    }\n\n    \/\/ Create new buffers from the heap and copy the contents of existing buffers to the\n    \/\/ new buffers\n    for(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n    {\n        \/\/ Create a buffer from the heap\n        id<MTLBuffer> heapBuffer = [_heap newBufferWithLength:_dataBuffer[i].length\n                                                      options:MTLResourceStorageModePrivate];\n\n        heapBuffer.label = _dataBuffer[i].label;\n\n        \/\/ Blit contents of the original buffer to the new buffer\n        [blitEncoder copyFromBuffer:_dataBuffer[i]\n                       sourceOffset:0\n                           toBuffer:heapBuffer\n                  destinationOffset:0\n                               size:heapBuffer.length];\n\n        \/\/ Replace the existing buffer with the new buffer\n        _dataBuffer[i] = heapBuffer;\n    }\n\n    [blitEncoder endEncoding];\n    [commandBuffer commit];\n}\n```\n\nBefore using these resources, instead of calling the `useResource:usage:` method once for each resource, the sample calls the `useHeap:` method once for the entire heap.\n\n```objective-c\n#if ENABLE_RESOURCE_HEAP\n        \/\/ Make a single `useHeap:` call for the entire heap, instead of one\n        \/\/ `useResource:usage:` call per texture and per buffer\n        [renderEncoder useHeap:_heap];\n#else\n        for(uint32_t i = 0; i < AAPLNumTextureArguments; i++)\n        {\n            \/\/ Indicate to Metal that these textures will be accessed by the GPU and\n            \/\/ therefore need to be mapped to the GPU's address space\n            [renderEncoder useResource:_texture[i] usage:MTLResourceUsageSample];\n        }\n\n        for(uint32_t i = 0; i < AAPLNumBufferArguments; i++)\n        {\n            \/\/ Indicate to Metal that these buffers will be accessed by the GPU and\n            \/\/ therefore need to be mapped to the GPU's address space\n            [renderEncoder useResource:_dataBuffer[i] usage:MTLResourceUsageRead];\n        }\n#endif\n```\n\n### Next steps\n\nIn this sample, you learned how to combine argument buffers with arrays of resources and resource heaps. In the [doc:\/\/com.apple.documentation\/documentation\/Metal\/encoding-argument-buffers-on-the-gpu] sample, you’ll learn how to encode resources into argument buffers with a graphics or compute function.\n\n## Argument buffers\n\n- **Improving CPU performance by using argument buffers**: Optimize your app’s performance by grouping your resources into argument buffers.\n- **Managing groups of resources with argument buffers**: Create argument buffers to organize related resources.\n- **Tracking the resource residency of argument buffers**: Optimize resource performance within an argument buffer.\n- **Indexing argument buffers**: Assign resource indices within an argument buffer.\n- **Rendering terrain dynamically with argument buffers**: Use argument buffers to render terrain in real time with a GPU-driven pipeline.\n- **Encoding argument buffers on the GPU**: Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.\n- **MTLArgumentDescriptor**: A representation of an argument within an argument buffer.\n- **MTLArgumentEncoder**: An interface you can use to encode argument data into an argument buffer.\n- **MTLAttributeStrideStatic**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Optimize your app’s performance by grouping your resources into argument buffers.",
          "name" : "Improving CPU performance by using argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers"
        },
        {
          "description" : "Create argument buffers to organize related resources.",
          "name" : "Managing groups of resources with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-groups-of-resources-with-argument-buffers"
        },
        {
          "description" : "Optimize resource performance within an argument buffer.",
          "name" : "Tracking the resource residency of argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/tracking-the-resource-residency-of-argument-buffers"
        },
        {
          "description" : "Assign resource indices within an argument buffer.",
          "name" : "Indexing argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/indexing-argument-buffers"
        },
        {
          "description" : "Use argument buffers to render terrain in real time with a GPU-driven pipeline.",
          "name" : "Rendering terrain dynamically with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-terrain-dynamically-with-argument-buffers"
        },
        {
          "description" : "Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.",
          "name" : "Encoding argument buffers on the GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-argument-buffers-on-the-gpu"
        },
        {
          "description" : "A representation of an argument within an argument buffer.",
          "name" : "MTLArgumentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentDescriptor"
        },
        {
          "description" : "An interface you can use to encode argument data into an argument buffer.",
          "name" : "MTLArgumentEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentEncoder"
        },
        {
          "description" : "",
          "name" : "MTLAttributeStrideStatic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAttributeStrideStatic"
        }
      ],
      "title" : "Argument buffers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Using argument buffers with resource heaps",
  "url" : "https:\/\/developer.apple.com\/documentation\/metal\/using-argument-buffers-with-resource-heaps"
}