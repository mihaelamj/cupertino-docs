{
  "abstract" : "A buffer where the GPU writes visibility test results when fragments pass depth and stencil tests.",
  "codeExamples" : [

  ],
  "contentHash" : "21082c9cee046a13a8bbbbbf19f4f91ace88bc0a95c31c83c313484cc0a9c476",
  "crawledAt" : "2025-12-04T22:10:12Z",
  "declaration" : {
    "code" : "var visibilityResultBuffer: (any MTLBuffer)? { get set }",
    "language" : "swift"
  },
  "id" : "30F8FF47-84B7-43E6-9AC7-A7AA4A0B9BF5",
  "kind" : "property",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Discussion\n\nWhen encoding a render pass, you can tell the GPU to record data about fragments that pass depth and stencil tests. Typically, you use visibility testing to track whether a particular piece of geometry is visible in the current frame, so you can omit drawing calls for hidden objects when encoding future frames. This technique is sometimes called *occlusion culling*. You can record separate tests for different pieces of geometry.\n\nSet this property to provide the buffer for the GPU to store visibility results when it executes the render pass. The GPU stores visibility results as 64-bit integers, so you need to reserve `8` bytes for each visibility result that you want to track. After creating the render command encoder, call [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVisibilityResultMode(_:offset:)] to start each visibility test.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/MTLRenderPassDescriptor\/visibilityResultBuffer\ncrawled: 2025-12-04T22:10:12Z\n---\n\n# visibilityResultBuffer\n\n**Instance Property**\n\nA buffer where the GPU writes visibility test results when fragments pass depth and stencil tests.\n\n## Declaration\n\n```swift\nvar visibilityResultBuffer: (any MTLBuffer)? { get set }\n```\n\n## Discussion\n\nWhen encoding a render pass, you can tell the GPU to record data about fragments that pass depth and stencil tests. Typically, you use visibility testing to track whether a particular piece of geometry is visible in the current frame, so you can omit drawing calls for hidden objects when encoding future frames. This technique is sometimes called *occlusion culling*. You can record separate tests for different pieces of geometry.\n\nSet this property to provide the buffer for the GPU to store visibility results when it executes the render pass. The GPU stores visibility results as 64-bit integers, so you need to reserve `8` bytes for each visibility result that you want to track. After creating the render command encoder, call [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVisibilityResultMode(_:offset:)] to start each visibility test.\n\n## Related Documentation\n\n- **setVisibilityResultMode(_:offset:)**: Configures which visibility test the GPU runs and the destination for any results it generates.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Configures which visibility test the GPU runs and the destination for any results it generates.",
          "name" : "setVisibilityResultMode(_:offset:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLRenderCommandEncoder\/setVisibilityResultMode(_:offset:)"
        }
      ],
      "title" : "Related Documentation"
    }
  ],
  "source" : "appleJSON",
  "title" : "visibilityResultBuffer",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLRenderPassDescriptor\/visibilityResultBuffer"
}