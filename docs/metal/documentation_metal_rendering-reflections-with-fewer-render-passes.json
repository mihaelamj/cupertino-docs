{
  "abstract" : "Use layer selection to reduce the number of render passes needed to generate an environment map.",
  "codeExamples" : [
    {
      "code" : "supportsLayerSelection = [_view.device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily5_v1];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ 1) Get the view matrix for the face given the sphere's updated position\nviewMatrix[i] = _cameraReflection.GetViewMatrixForFace_LH (i);\n\n\/\/ 2) Calculate the planes bounding the frustum using the updated view matrix\n\/\/    You use these planes later to test whether an actor's bounding sphere\n\/\/    intersects with the frustum, and is therefore visible in this face's viewport\nculler_probe[i].Reset_LH (viewMatrix [i], _cameraReflection);",
      "language" : "objective-c"
    },
    {
      "code" : "if (_actorData[actorIdx].passFlags & EPassFlags::Reflection)\n{\n    int instanceCount = 0;\n    for (int faceIdx = 0; faceIdx < 6; faceIdx++)\n    {\n        \/\/ Check if the actor is visible in the current probe face\n        if (culler_probe [faceIdx].Intersects (_actorData[actorIdx].modelPosition.xyz, _actorData[actorIdx].bSphere))\n        {\n            \/\/ Add this face index to the the list of faces for this actor\n            InstanceParams instanceParams = {(ushort)faceIdx};\n            instanceParams_reflection [MaxVisibleFaces * actorIdx + instanceCount].viewportIndex = instanceParams.viewportIndex;\n            instanceCount++;\n        }\n    }\n    _actorData[actorIdx].instanceCountInReflection = instanceCount;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "reflectionPassDesc.colorAttachments[0].texture    = _reflectionCubeMap;\nreflectionPassDesc.depthAttachment.texture        = _reflectionCubeMapDepth;\nreflectionPassDesc.renderTargetArrayLength        = 6;",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder drawIndexedPrimitives: metalKitSubmesh.primitiveType\n                          indexCount: metalKitSubmesh.indexCount\n                           indexType: metalKitSubmesh.indexType\n                         indexBuffer: metalKitSubmesh.indexBuffer.buffer\n                   indexBufferOffset: metalKitSubmesh.indexBuffer.offset\n                       instanceCount: visibleVpCount\n                          baseVertex: 0\n                        baseInstance: actorIdx * MaxVisibleFaces];",
      "language" : "objective-c"
    },
    {
      "code" : "vertex ColorInOut vertexTransform (const Vertex in                               [[ stage_in ]],\n                                   const uint   instanceId                       [[ instance_id ]],\n                                   const device InstanceParams* instanceParams   [[ buffer     (BufferIndexInstanceParams) ]],\n                                   const device ActorParams&    actorParams      [[ buffer (BufferIndexActorParams)    ]],\n                                   constant     ViewportParams* viewportParams   [[ buffer (BufferIndexViewportParams) ]] )",
      "language" : "metal"
    },
    {
      "code" : "struct ColorInOut\n{\n    float4 position [[position]];\n    float2 texCoord;\n\n    half3  worldPos;\n    half3  tangent;\n    half3  bitangent;\n    half3  normal;\n    uint   face [[render_target_array_index]];\n};",
      "language" : "metal"
    },
    {
      "code" : "out.face = instanceParams[instanceId].viewportIndex;",
      "language" : "metal"
    },
    {
      "code" : "_cameraFinal.target   = SceneCenter;\n\n_cameraFinal.rotation = fmod ((_cameraFinal.rotation + CameraRotationSpeed), M_PI*2.f);\nmatrix_float3x3 rotationMatrix = matrix3x3_rotation (_cameraFinal.rotation,  CameraRotationAxis);\n\n_cameraFinal.position = SceneCenter;\n_cameraFinal.position += matrix_multiply (rotationMatrix, CameraDistanceFromCenter);\n\nconst matrix_float4x4 viewMatrix       = _cameraFinal.GetViewMatrix();\nconst matrix_float4x4 projectionMatrix = _cameraFinal.GetProjectionMatrix_LH();\n\nculler_final.Reset_LH (viewMatrix, _cameraFinal);\n\nViewportParams *viewportBuffer = (ViewportParams *)_viewportsParamsBuffers_final[_uniformBufferIndex].contents;\nviewportBuffer[0].cameraPos            = _cameraFinal.position;\nviewportBuffer[0].viewProjectionMatrix = matrix_multiply (projectionMatrix, viewMatrix);",
      "language" : "objective-c"
    },
    {
      "code" : "if (culler_final.Intersects (_actorData[actorIdx].modelPosition.xyz, _actorData[actorIdx].bSphere))\n{\n    _actorData[actorIdx].visibleInFinal = YES;\n}\nelse\n{\n    _actorData[actorIdx].visibleInFinal = NO;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "MTLRenderPassDescriptor* finalPassDescriptor = view.currentRenderPassDescriptor;\n\nif(finalPassDescriptor != nil)\n{\n    finalPassDescriptor.renderTargetArrayLength = 1;\n    id<MTLRenderCommandEncoder> renderEncoder =\n    [commandBuffer renderCommandEncoderWithDescriptor:finalPassDescriptor];\n    renderEncoder.label = @\"FinalPass\";\n\n    [self drawActors: renderEncoder pass: EPassFlags::Final];\n\n    [renderEncoder endEncoding];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "[commandBuffer presentDrawable:view.currentDrawable];",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "0b5e6aba890aaa49b740b626bd80bfd2da2ab7465cc5972aa5ca8b78e72805e7",
  "crawledAt" : "2025-12-02T15:31:31Z",
  "id" : "D7261683-E1E2-4B18-A628-BEAC6AC46711",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nThis sample demonstrates dynamic reflections on a chrome sphere, using layer selection to render the frame in two passes. The first pass renders the environment onto the cube map. The second pass renders the environment reflections onto the sphere; it renders additional actors in the scene; and it renders the environment itself.\n\n\n\nYou can implement an object that reflects its environment by sampling its reflections from a cube map of the environment. A cube map is a single texture composed of six 2D texture layers arranged in the shape of a cube. The reflections vary based on the positions of other objects in the environment, so each of the cube map’s six faces needs to be rendered dynamically in every frame. This would normally require six separate render passes, one for each face, but Metal allows you to render an entire cube map in a single pass.\n\n\n\n### Getting started\n\nThis sample contains macOS and iOS targets. Run the iOS scheme on a physical device because Metal isn’t supported in the simulator.\n\nLayer Selection is supported on all macOS GPUs but only iOS GPUs which support the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFeatureSet\/iOS_GPUFamily5_v1] feature set.\n\nYou check the GPU that you choose at runtime supports indirect command buffers (ICBs) by calling an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsFeatureSet(_:)] method.\n\nThis sample calls ‘supportsFeatureSet:’ for this purpose within its view controller’s `viewDidLoad:` callback.\n\n### Separate the scene\n\nA cube map is represented as a render target array with six layers, one for each of its faces. The `[[render_target_array_index]]` attribute qualifier, specified for a structure member of a vertex function return value, identifies each array layer separately. This layer selection feature allows the sample to decide which part of the environment gets rendered to which cube map face.\n\nAn `AAPLActorData` object represents an actor in the scene. In this sample, each actor is a temple model with the same mesh data but a different diffuse color. These actors sit on the XZ-plane; they’re always reflected in the X or Z direction relative to the sphere and could be rendered to any of the +X, -X, +Z, or -Z faces of the cube map.\n\n### Perform culling tests for the reflection pass\n\nBefore rendering to the cube map, it’s useful to know which faces each actor should be rendered to. Determining this information involves a procedure known as a *culling test*, and it’s performed on each actor for each cube map face.\n\nAt the start of every frame, for each cube map face, a view matrix is calculated and the view’s frustum is stored in the `culler_probe` array.\n\nThese culler probes test the intersection between an actor and the viewing frustum of each cube map face. The test results determine how many faces the actor is rendered to (`instanceCount`) in the reflection pass, and which faces (`instanceParams`) it’s rendered to.\n\nThe following diagram shows the results of the culling tests performed on the temple actors, based on their positions relative to the reflective sphere. Because `_actorData[0]` and `actorData[1]` bisect two viewing frustums, their `instanceCount` property is set to 2, and there are two elements in their `instanceParams` array. (This array contains the cube map face indices of the viewing frustums that the actors intersect.)\n\n\n\n### Configure render targets for the reflection pass\n\nThe render target for the reflection pass is a cube map. The sample configures the render target by using a `MTLRenderPassDescriptor` object with a color render target, a depth render target, and six layers. The `renderTargetArrayLength` property sets the number of cube map faces and allows the render pipeline to render into any or all of them.\n\n### Issue draw calls for the reflection pass\n\nThe `drawActors:pass:` method sets up the graphics rendering state for each actor. Actors are only drawn if they are visible in any of the six cube map faces, determined by the `visibleVpCount` value (accessed through the `instanceCountInReflection` property). The value of `visibleVpCount` determines the number of instances for the instanced draw call.\n\nIn this draw call, the sample sets the `baseInstance` parameter to the value of `actorIdx * 5`. This setting is important because it tells the vertex function how to select the appropriate render target layer for each instance.\n\n### Render the reflection pass\n\nIn the `vertexTransform` vertex function, the `instanceParams` argument points to the buffer that contains the cube map faces that each actor should be rendered to. The `instanceId` value indexes into the `instanceParams` array.\n\nThe output structure of the vertex function, `ColorInOut`, contains the `face` member that uses the `[[render_target_array_index]]` attribute qualifier. The return value of `face` determines the cube map face that the render pipeline should render to.\n\nBecause the value of the draw call’s `baseInstance` parameter is set to `actorIdx * 5`, the `instanceId` value of the first instance drawn in the draw call is equal to this value. Each subsequent rendering of an instance increments the `instanceId` value by 1. The `instanceParams` array has five slots for each actor because an actor can be visible in up to five cube map faces. As a result, the `instanceParams[instanceId]` element always contains one of the face indices in which the actor is visible. Therefore, the sample uses this value to select a valid render target layer.\n\nIn summary, to render each actor to the reflective cube map, the sample issues an instanced draw call for the actor. The vertex function uses the built-in `instanceId` variable to index into the `instanceParams` array that contains the index of the cube map face that the instance should be rendered to. Therefore, the vertex function sets this face index in the `face` return value member, which uses the `[[render_target_array_index]]` attribute qualifier. This ensures that each actor is rendered to each cube map face it should appear in.\n\n\n\n### Perform culling tests for the final pass\n\nThe sample performs similar view updates for the main camera in the final pass. At the start of every frame, a view matrix is calculated and the view’s frustum is stored in the `culler_final` variable.\n\nThis final culler probe is used to test the intersection between an actor and the viewing frustum of the camera. The test result simply determines whether or not each actor is visible in the final pass.\n\n### Configure render targets for the final pass\n\nThe render target for the final pass is the view’s *drawable*, a displayable resource obtained by accessing the view’s `currentRenderPassDescriptor` property. However, don’t access this property prematurely because it implicitly retrieves a drawable. Drawables are expensive system resources created and maintained by the Core Animation framework. Hold a drawable as briefly as possible to avoid resource stalls. In this sample, a drawable is acquired just before the final render pass is encoded.\n\n### Issue draw calls for the final pass\n\nThe `drawActors:pass`: method sets up the graphics rendering state for each actor. Actors are only drawn if they are visible to the main camera, as determined by the `visibleVpCount` value (accessed through the `visibleInFinal` property).\n\nBecause each actor is drawn only once in the final pass, the `instanceCount` parameter is always set to 1 and the `baseInstance` parameter is always set to 0.\n\n### Render the final pass\n\nThe final pass renders the final frame directly to the view’s drawable, which is then presented onscreen.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/rendering-reflections-with-fewer-render-passes\ncrawled: 2025-12-02T15:31:31Z\n---\n\n# Rendering reflections with fewer render passes\n\n**Sample Code**\n\nUse layer selection to reduce the number of render passes needed to generate an environment map.\n\n## Overview\n\nThis sample demonstrates dynamic reflections on a chrome sphere, using layer selection to render the frame in two passes. The first pass renders the environment onto the cube map. The second pass renders the environment reflections onto the sphere; it renders additional actors in the scene; and it renders the environment itself.\n\n\n\nYou can implement an object that reflects its environment by sampling its reflections from a cube map of the environment. A cube map is a single texture composed of six 2D texture layers arranged in the shape of a cube. The reflections vary based on the positions of other objects in the environment, so each of the cube map’s six faces needs to be rendered dynamically in every frame. This would normally require six separate render passes, one for each face, but Metal allows you to render an entire cube map in a single pass.\n\n\n\n### Getting started\n\nThis sample contains macOS and iOS targets. Run the iOS scheme on a physical device because Metal isn’t supported in the simulator.\n\nLayer Selection is supported on all macOS GPUs but only iOS GPUs which support the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFeatureSet\/iOS_GPUFamily5_v1] feature set.\n\nYou check the GPU that you choose at runtime supports indirect command buffers (ICBs) by calling an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsFeatureSet(_:)] method.\n\n```objective-c\nsupportsLayerSelection = [_view.device supportsFeatureSet:MTLFeatureSet_iOS_GPUFamily5_v1];\n```\n\nThis sample calls ‘supportsFeatureSet:’ for this purpose within its view controller’s `viewDidLoad:` callback.\n\n### Separate the scene\n\nA cube map is represented as a render target array with six layers, one for each of its faces. The `[[render_target_array_index]]` attribute qualifier, specified for a structure member of a vertex function return value, identifies each array layer separately. This layer selection feature allows the sample to decide which part of the environment gets rendered to which cube map face.\n\nAn `AAPLActorData` object represents an actor in the scene. In this sample, each actor is a temple model with the same mesh data but a different diffuse color. These actors sit on the XZ-plane; they’re always reflected in the X or Z direction relative to the sphere and could be rendered to any of the +X, -X, +Z, or -Z faces of the cube map.\n\n### Perform culling tests for the reflection pass\n\nBefore rendering to the cube map, it’s useful to know which faces each actor should be rendered to. Determining this information involves a procedure known as a *culling test*, and it’s performed on each actor for each cube map face.\n\nAt the start of every frame, for each cube map face, a view matrix is calculated and the view’s frustum is stored in the `culler_probe` array.\n\n```objective-c\n\/\/ 1) Get the view matrix for the face given the sphere's updated position\nviewMatrix[i] = _cameraReflection.GetViewMatrixForFace_LH (i);\n\n\/\/ 2) Calculate the planes bounding the frustum using the updated view matrix\n\/\/    You use these planes later to test whether an actor's bounding sphere\n\/\/    intersects with the frustum, and is therefore visible in this face's viewport\nculler_probe[i].Reset_LH (viewMatrix [i], _cameraReflection);\n```\n\nThese culler probes test the intersection between an actor and the viewing frustum of each cube map face. The test results determine how many faces the actor is rendered to (`instanceCount`) in the reflection pass, and which faces (`instanceParams`) it’s rendered to.\n\n```objective-c\nif (_actorData[actorIdx].passFlags & EPassFlags::Reflection)\n{\n    int instanceCount = 0;\n    for (int faceIdx = 0; faceIdx < 6; faceIdx++)\n    {\n        \/\/ Check if the actor is visible in the current probe face\n        if (culler_probe [faceIdx].Intersects (_actorData[actorIdx].modelPosition.xyz, _actorData[actorIdx].bSphere))\n        {\n            \/\/ Add this face index to the the list of faces for this actor\n            InstanceParams instanceParams = {(ushort)faceIdx};\n            instanceParams_reflection [MaxVisibleFaces * actorIdx + instanceCount].viewportIndex = instanceParams.viewportIndex;\n            instanceCount++;\n        }\n    }\n    _actorData[actorIdx].instanceCountInReflection = instanceCount;\n}\n```\n\nThe following diagram shows the results of the culling tests performed on the temple actors, based on their positions relative to the reflective sphere. Because `_actorData[0]` and `actorData[1]` bisect two viewing frustums, their `instanceCount` property is set to 2, and there are two elements in their `instanceParams` array. (This array contains the cube map face indices of the viewing frustums that the actors intersect.)\n\n\n\n### Configure render targets for the reflection pass\n\nThe render target for the reflection pass is a cube map. The sample configures the render target by using a `MTLRenderPassDescriptor` object with a color render target, a depth render target, and six layers. The `renderTargetArrayLength` property sets the number of cube map faces and allows the render pipeline to render into any or all of them.\n\n```objective-c\nreflectionPassDesc.colorAttachments[0].texture    = _reflectionCubeMap;\nreflectionPassDesc.depthAttachment.texture        = _reflectionCubeMapDepth;\nreflectionPassDesc.renderTargetArrayLength        = 6;\n```\n\n### Issue draw calls for the reflection pass\n\nThe `drawActors:pass:` method sets up the graphics rendering state for each actor. Actors are only drawn if they are visible in any of the six cube map faces, determined by the `visibleVpCount` value (accessed through the `instanceCountInReflection` property). The value of `visibleVpCount` determines the number of instances for the instanced draw call.\n\n```objective-c\n[renderEncoder drawIndexedPrimitives: metalKitSubmesh.primitiveType\n                          indexCount: metalKitSubmesh.indexCount\n                           indexType: metalKitSubmesh.indexType\n                         indexBuffer: metalKitSubmesh.indexBuffer.buffer\n                   indexBufferOffset: metalKitSubmesh.indexBuffer.offset\n                       instanceCount: visibleVpCount\n                          baseVertex: 0\n                        baseInstance: actorIdx * MaxVisibleFaces];\n```\n\nIn this draw call, the sample sets the `baseInstance` parameter to the value of `actorIdx * 5`. This setting is important because it tells the vertex function how to select the appropriate render target layer for each instance.\n\n### Render the reflection pass\n\nIn the `vertexTransform` vertex function, the `instanceParams` argument points to the buffer that contains the cube map faces that each actor should be rendered to. The `instanceId` value indexes into the `instanceParams` array.\n\n```metal\nvertex ColorInOut vertexTransform (const Vertex in                               [[ stage_in ]],\n                                   const uint   instanceId                       [[ instance_id ]],\n                                   const device InstanceParams* instanceParams   [[ buffer     (BufferIndexInstanceParams) ]],\n                                   const device ActorParams&    actorParams      [[ buffer (BufferIndexActorParams)    ]],\n                                   constant     ViewportParams* viewportParams   [[ buffer (BufferIndexViewportParams) ]] )\n```\n\nThe output structure of the vertex function, `ColorInOut`, contains the `face` member that uses the `[[render_target_array_index]]` attribute qualifier. The return value of `face` determines the cube map face that the render pipeline should render to.\n\n```metal\nstruct ColorInOut\n{\n    float4 position [[position]];\n    float2 texCoord;\n\n    half3  worldPos;\n    half3  tangent;\n    half3  bitangent;\n    half3  normal;\n    uint   face [[render_target_array_index]];\n};\n```\n\nBecause the value of the draw call’s `baseInstance` parameter is set to `actorIdx * 5`, the `instanceId` value of the first instance drawn in the draw call is equal to this value. Each subsequent rendering of an instance increments the `instanceId` value by 1. The `instanceParams` array has five slots for each actor because an actor can be visible in up to five cube map faces. As a result, the `instanceParams[instanceId]` element always contains one of the face indices in which the actor is visible. Therefore, the sample uses this value to select a valid render target layer.\n\n```metal\nout.face = instanceParams[instanceId].viewportIndex;\n```\n\nIn summary, to render each actor to the reflective cube map, the sample issues an instanced draw call for the actor. The vertex function uses the built-in `instanceId` variable to index into the `instanceParams` array that contains the index of the cube map face that the instance should be rendered to. Therefore, the vertex function sets this face index in the `face` return value member, which uses the `[[render_target_array_index]]` attribute qualifier. This ensures that each actor is rendered to each cube map face it should appear in.\n\n\n\n### Perform culling tests for the final pass\n\nThe sample performs similar view updates for the main camera in the final pass. At the start of every frame, a view matrix is calculated and the view’s frustum is stored in the `culler_final` variable.\n\n```objective-c\n_cameraFinal.target   = SceneCenter;\n\n_cameraFinal.rotation = fmod ((_cameraFinal.rotation + CameraRotationSpeed), M_PI*2.f);\nmatrix_float3x3 rotationMatrix = matrix3x3_rotation (_cameraFinal.rotation,  CameraRotationAxis);\n\n_cameraFinal.position = SceneCenter;\n_cameraFinal.position += matrix_multiply (rotationMatrix, CameraDistanceFromCenter);\n\nconst matrix_float4x4 viewMatrix       = _cameraFinal.GetViewMatrix();\nconst matrix_float4x4 projectionMatrix = _cameraFinal.GetProjectionMatrix_LH();\n\nculler_final.Reset_LH (viewMatrix, _cameraFinal);\n\nViewportParams *viewportBuffer = (ViewportParams *)_viewportsParamsBuffers_final[_uniformBufferIndex].contents;\nviewportBuffer[0].cameraPos            = _cameraFinal.position;\nviewportBuffer[0].viewProjectionMatrix = matrix_multiply (projectionMatrix, viewMatrix);\n```\n\nThis final culler probe is used to test the intersection between an actor and the viewing frustum of the camera. The test result simply determines whether or not each actor is visible in the final pass.\n\n```objective-c\nif (culler_final.Intersects (_actorData[actorIdx].modelPosition.xyz, _actorData[actorIdx].bSphere))\n{\n    _actorData[actorIdx].visibleInFinal = YES;\n}\nelse\n{\n    _actorData[actorIdx].visibleInFinal = NO;\n}\n```\n\n### Configure render targets for the final pass\n\nThe render target for the final pass is the view’s *drawable*, a displayable resource obtained by accessing the view’s `currentRenderPassDescriptor` property. However, don’t access this property prematurely because it implicitly retrieves a drawable. Drawables are expensive system resources created and maintained by the Core Animation framework. Hold a drawable as briefly as possible to avoid resource stalls. In this sample, a drawable is acquired just before the final render pass is encoded.\n\n```objective-c\nMTLRenderPassDescriptor* finalPassDescriptor = view.currentRenderPassDescriptor;\n\nif(finalPassDescriptor != nil)\n{\n    finalPassDescriptor.renderTargetArrayLength = 1;\n    id<MTLRenderCommandEncoder> renderEncoder =\n    [commandBuffer renderCommandEncoderWithDescriptor:finalPassDescriptor];\n    renderEncoder.label = @\"FinalPass\";\n\n    [self drawActors: renderEncoder pass: EPassFlags::Final];\n\n    [renderEncoder endEncoding];\n}\n```\n\n### Issue draw calls for the final pass\n\nThe `drawActors:pass`: method sets up the graphics rendering state for each actor. Actors are only drawn if they are visible to the main camera, as determined by the `visibleVpCount` value (accessed through the `visibleInFinal` property).\n\nBecause each actor is drawn only once in the final pass, the `instanceCount` parameter is always set to 1 and the `baseInstance` parameter is always set to 0.\n\n### Render the final pass\n\nThe final pass renders the final frame directly to the view’s drawable, which is then presented onscreen.\n\n```objective-c\n[commandBuffer presentDrawable:view.currentDrawable];\n```\n\n## Lighting techniques\n\n- **Rendering a scene with forward plus lighting using tile shaders**: Implement a forward plus renderer using the latest features on Apple GPUs.\n- **Rendering a scene with deferred lighting in Objective-C**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n- **Rendering a scene with deferred lighting in Swift**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n- **Rendering a scene with deferred lighting in C++**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Implement a forward plus renderer using the latest features on Apple GPUs.",
          "name" : "Rendering a scene with forward plus lighting using tile shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-forward-plus-lighting-using-tile-shaders"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in Objective-C",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-objective-c"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-swift"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in C++",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-c++"
        }
      ],
      "title" : "Lighting techniques"
    }
  ],
  "source" : "appleJSON",
  "title" : "Rendering reflections with fewer render passes",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-reflections-with-fewer-render-passes"
}