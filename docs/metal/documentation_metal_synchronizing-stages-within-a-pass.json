{
  "abstract" : "Block GPU stages in the a pass from running until other stages in the same pass finish.",
  "codeExamples" : [

  ],
  "contentHash" : "51329633486115c16ddbf62562d00b5370f7d61fbed84b00aacbe875f0802e79",
  "crawledAt" : "2025-12-02T17:01:54Z",
  "id" : "C0916CFB-563A-4581-955A-04228ABD861D",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nAn intrapass barrier resolves access conflicts between commands within the same pass, without affecting any other passes. When your app encodes commands that access a resource from different passes — or different stages within a single pass — it creates an access conflict when at least one command modifies that resource. This conflict happens because the GPU can run multiple commands at the same time, including those from:\n\nFor more information about resource access conflicts and GPU stages, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages], respectively.\n\nStart by identifying which memory operations from different stages within a pass introduce a conflict. Then resolve the conflict by adding an *intrapass barrier* to pause the GPU before running the consuming stage until it finishes running the producing stage.\n\n### Identify access conflicts within a single pass\n\nThe following code example encodes a compute pass that has an access conflict between its copy and dispatch commands.\n\nThe example has at least one access conflict because the pass accesses two common resources — `bufferA` and `bufferB` — from different stages, and at least one command modifies one or more of those resources.\n\nThe copy command and the dispatch commands run during the blit and dispatch stages, respectively; both commands modify `bufferB`.\n\n\n\nWithout a barrier, the GPU can run the commands at any time relative to each other, including at the same time, which can yield inconsistent results in resources with access conflicts.\n\n\n\n### Resolve an intrapass conflict with a barrier\n\nResolve access conflicts between commands within the same pass by adding an intrapass barrier with the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/barrier(afterEncoderStages:beforeEncoderStages:visibilityOptions:)] method.\n\nThe following code example modifies the previous one adding an intrapass barrier between the blit and dispatch stages within the pass.\n\nThe code example adds a barrier between the blit and dispatch stages because they both access `bufferB` with load or store operations. The barrier forces the GPU to wait until the blit command completes before starting the dispatch stage.\n\n\n\nThe barrier makes it so that the store operations from the blit stage’s commands finish completely before the dispatch stage’s commands load from the same memory.\n\n### Encode commands that rely on fragment or tile stage outputs\n\nMetal doesn’t support intrapass barriers that wait for the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/tile] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/fragment] stages on devices that have a tile-based deferred rendering (TBDR) architecture, such as Apple silicon GPUs.\n\nYou can encode a tile dispatch that depends on the results of a previous tile dispatch because tile compute dispatches can access data from anywhere within the same tile. Similarly, you can encode a draw command that depends on the results of a previous draw command’s fragment stage because fragment shaders can only access data at their specific pixel location. However, if a tile dispatch needs results from another tile, or a fragment shader needs results from another fragment, then start a new render pass and synchronize them with a barrier.\n\nFor example, to synchronize the two passes by adding a consumer-based queue barrier in the new pass:\n\nSimilarly, to create a producer-based queue barrier in a pass:\n\nAlternatively, use an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFence]:\n\nFor more information about other synchronization mechanisms, see these articles in the series:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-stages-within-a-pass\ncrawled: 2025-12-02T17:01:54Z\n---\n\n# Synchronizing stages within a pass\n\n**Article**\n\nBlock GPU stages in the a pass from running until other stages in the same pass finish.\n\n## Overview\n\nAn intrapass barrier resolves access conflicts between commands within the same pass, without affecting any other passes. When your app encodes commands that access a resource from different passes — or different stages within a single pass — it creates an access conflict when at least one command modifies that resource. This conflict happens because the GPU can run multiple commands at the same time, including those from:\n\n- Multiple passes\n- Different stages of a pass, such as the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/blit] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/dispatch] stages of a compute pass\n- Multiple instances of a stage, such as two or more dispatch commands within a compute pass\n\nFor more information about resource access conflicts and GPU stages, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages], respectively.\n\nStart by identifying which memory operations from different stages within a pass introduce a conflict. Then resolve the conflict by adding an *intrapass barrier* to pause the GPU before running the consuming stage until it finishes running the producing stage.\n\n\n\n### Identify access conflicts within a single pass\n\nThe following code example encodes a compute pass that has an access conflict between its copy and dispatch commands.\n\n\n\nThe example has at least one access conflict because the pass accesses two common resources — `bufferA` and `bufferB` — from different stages, and at least one command modifies one or more of those resources.\n\nThe copy command and the dispatch commands run during the blit and dispatch stages, respectively; both commands modify `bufferB`.\n\n\n\nWithout a barrier, the GPU can run the commands at any time relative to each other, including at the same time, which can yield inconsistent results in resources with access conflicts.\n\n\n\n### Resolve an intrapass conflict with a barrier\n\nResolve access conflicts between commands within the same pass by adding an intrapass barrier with the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/barrier(afterEncoderStages:beforeEncoderStages:visibilityOptions:)] method.\n\nThe following code example modifies the previous one adding an intrapass barrier between the blit and dispatch stages within the pass.\n\n\n\nThe code example adds a barrier between the blit and dispatch stages because they both access `bufferB` with load or store operations. The barrier forces the GPU to wait until the blit command completes before starting the dispatch stage.\n\n\n\nThe barrier makes it so that the store operations from the blit stage’s commands finish completely before the dispatch stage’s commands load from the same memory.\n\n### Encode commands that rely on fragment or tile stage outputs\n\nMetal doesn’t support intrapass barriers that wait for the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/tile] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/fragment] stages on devices that have a tile-based deferred rendering (TBDR) architecture, such as Apple silicon GPUs.\n\n\n\nYou can encode a tile dispatch that depends on the results of a previous tile dispatch because tile compute dispatches can access data from anywhere within the same tile. Similarly, you can encode a draw command that depends on the results of a previous draw command’s fragment stage because fragment shaders can only access data at their specific pixel location. However, if a tile dispatch needs results from another tile, or a fragment shader needs results from another fragment, then start a new render pass and synchronize them with a barrier.\n\nFor example, to synchronize the two passes by adding a consumer-based queue barrier in the new pass:\n\n1. End the current render pass by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/endEncoding()] method.\n2. Start a new render pass by creating a new render encoder from the command buffer, or another bound for the queue.\n3. Add a consumer barrier by calling the new encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/barrier(afterQueueStages:beforeStages:visibilityOptions:)] method, which synchronizes the results of the previous render pass.\n\nSimilarly, to create a producer-based queue barrier in a pass:\n\n1. Add a producer barrier by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/barrier(afterStages:beforeQueueStages:visibilityOptions:)] method to synchronize the results of the current render pass.\n2. End the current render pass by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/endEncoding()] method.\n3. Start a new render pass by creating a new encoder from the command buffer, or another bound for the queue.\n\nAlternatively, use an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFence]:\n\n1. Update a fence in the current render pass by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/updateFence(_:afterEncoderStages:)] method.\n2. End the current render pass by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/endEncoding()] method.\n3. Start a new render pass by creating a new encoder from the same command buffer.\n4. Wait for the same fence instance in the new render pass by calling the new encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/waitForFence(_:beforeEncoderStages:)] method.\n\nFor more information about other synchronization mechanisms, see these articles in the series:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-passes-with-a-fence]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-passes-with-consumer-barriers]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-passes-with-producer-barriers]\n\n## Synchronizing with barriers and fences\n\n- **Synchronizing passes with a fence**: Block GPU stages in a pass until another pass unblocks it by signaling a fence.\n- **Synchronizing passes with consumer barriers**: Block GPU stages in a pass, and all subsequent passes, from running until stages from earlier passes finish.\n- **Synchronizing passes with producer barriers**: Block GPU stages in subsequent passes from running until stages in a pass, and earlier passes, finish.\n- **Synchronizing CPU and GPU work**: Avoid stalls between CPU and GPU work by using multiple instances of a resource.\n- **Implementing a multistage image filter using heaps and fences**: Use fences to synchronize access to resources allocated on a heap.\n- **MTLStages**: Describes stages of GPU work.\n- **MTLFence**: A synchronization mechanism that orders memory operations between GPU passes.\n- **MTLRenderStages**: The stages in a render pass that triggers a synchronization command.\n- **MTLBarrierScope**: Describes the types of resources that a barrier operates on.\n- **MTL4VisibilityOptions**: Memory consistency options for synchronization commands.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Block GPU stages in a pass until another pass unblocks it by signaling a fence.",
          "name" : "Synchronizing passes with a fence",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-passes-with-a-fence"
        },
        {
          "description" : "Block GPU stages in a pass, and all subsequent passes, from running until stages from earlier passes finish.",
          "name" : "Synchronizing passes with consumer barriers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-passes-with-consumer-barriers"
        },
        {
          "description" : "Block GPU stages in subsequent passes from running until stages in a pass, and earlier passes, finish.",
          "name" : "Synchronizing passes with producer barriers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-passes-with-producer-barriers"
        },
        {
          "description" : "Avoid stalls between CPU and GPU work by using multiple instances of a resource.",
          "name" : "Synchronizing CPU and GPU work",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-cpu-and-gpu-work"
        },
        {
          "description" : "Use fences to synchronize access to resources allocated on a heap.",
          "name" : "Implementing a multistage image filter using heaps and fences",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-a-multistage-image-filter-using-heaps-and-fences"
        },
        {
          "description" : "Describes stages of GPU work.",
          "name" : "MTLStages",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLStages"
        },
        {
          "description" : "A synchronization mechanism that orders memory operations between GPU passes.",
          "name" : "MTLFence",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLFence"
        },
        {
          "description" : "The stages in a render pass that triggers a synchronization command.",
          "name" : "MTLRenderStages",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLRenderStages"
        },
        {
          "description" : "Describes the types of resources that a barrier operates on.",
          "name" : "MTLBarrierScope",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLBarrierScope"
        },
        {
          "description" : "Memory consistency options for synchronization commands.",
          "name" : "MTL4VisibilityOptions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4VisibilityOptions"
        }
      ],
      "title" : "Synchronizing with barriers and fences"
    }
  ],
  "source" : "appleJSON",
  "title" : "Synchronizing stages within a pass",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-stages-within-a-pass"
}