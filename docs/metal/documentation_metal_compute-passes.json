{
  "abstract" : "Encode a compute pass that runs computations in parallel on a thread grid, processing and manipulating Metal resource data on multiple cores of a GPU.",
  "codeExamples" : [

  ],
  "contentHash" : "8b36bb8ff6c13450915a414d1751d2c3834ecdb106f48b3f0a40b9de4b239482",
  "crawledAt" : "2025-12-03T03:54:28Z",
  "id" : "757D7962-B0FD-4C31-B4E0-7CA417EAC734",
  "kind" : "collection",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nYour app can perform large-scale computation or prepare data for a subsequent GPU pass by encoding a compute pass that works on Metal resources in parallel. Compute passes are the part of your Metal pipeline meant for heavy parallelization of tasks requiring fast math, such as ray tracing.\n\nEncode commands for your compute pass by creating an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer] and using it to create a new compute command encoder, using a method like [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/makeComputeCommandEncoder()] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/makeComputeCommandEncoder(descriptor:)]. Add individual dispatches for functions and their data to the compute pass by calling the command encoder’s methods. At the end of assigning data and dispatching a function call to the encoder, create a command that runs in your compute pass with [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandEncoder\/endEncoding()].\n\nFor information on dispatching commands to encode, see the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder] reference. Compute passes also support indirect command buffers; for more information, see Dispatching from Indirect Command Buffers.\n\nThe following two samples demonstrate basic compute passes:\n\n### Kernel arguments and argument tables\n\nCompute commands that execute your code on GPU call *kernel functions* in your Metal shader, annotated with `[[kernel]]`. Each kernel has associated argument tables, such as the buffer argument table `[[buffer(n)]]`, used to access data associated with kernel arguments. In addition to annotations describing any argument table, some kernel arguments need information on their address space. For more information, see the following sections of the [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf]\n\nIn addition, kernels also use a function table to take advantage of function pointers, allowing them to call visible and intersection functions. Visible functions allow you to use function pointers in kernels, letting you use function stitching and link against Metal dynamic libraries at runtime. Ray tracers use intersection functions on [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructure] instances to perform quick intersection checks.\n\nFor more information on function stitching, dynamic libraries, and ray tracing, see:\n\nFor information on per-architecture support for function tables in compute passes and other restrictions, see the [https:\/\/developer.apple.com\/metal\/Metal-Feature-Set-Tables.pdf].\n\n### Argument buffers and memory residency\n\nCompute kernels can access argument data to populate a Metal structure, using an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] created by an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder]. For an in-depth discussion of argument buffers, see [doc:\/\/com.apple.metal\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers]. Using a resource in an argument buffer requires that it’s resident in GPU memory for the duration of the pass. For a resource to be resident, allocate it with either the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStorageMode\/shared] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStorageMode\/managed] mode.\n\nResources become resident on a per-instance basis by calling methods like [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder\/useResource(_:usage:)] and heaps become resident by calling methods like [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder\/useHeap(_:)].\n\nWhen using resident resources, avoid data corruption by using an appropriate [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLHazardTrackingMode] or by manually managing memory barriers and fences for untracked resources with the methods in Synchronizing Across Command Execution.\n\n### Using tile memory in a compute pass\n\nApple family GPUs offer fast, integrated graphics memory called *tile memory* that’s shared between subsequent passes for fast access to data. Compute passes can reserve this memory space for threadgroup memory or imageblock memory, giving your compute functions the ability to access temporary data at low latency across your shaders.\n\nFor more information see the following sections of the [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf]:\n\nBecause tile memory resides on GPU only, you reserve memory on a tile block rather than copy data to it. Use the methods in Encoding Tile Memory Usage to prepare the appropriate block of memory for your kernel.\n\nFor device support and other tile memory limitations, see [https:\/\/developer.apple.com\/metal\/Metal-Feature-Set-Tables.pdf].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/compute-passes\ncrawled: 2025-12-03T03:54:28Z\n---\n\n# Compute passes\n\n**API Collection**\n\nEncode a compute pass that runs computations in parallel on a thread grid, processing and manipulating Metal resource data on multiple cores of a GPU.\n\n## Overview\n\nYour app can perform large-scale computation or prepare data for a subsequent GPU pass by encoding a compute pass that works on Metal resources in parallel. Compute passes are the part of your Metal pipeline meant for heavy parallelization of tasks requiring fast math, such as ray tracing.\n\nEncode commands for your compute pass by creating an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer] and using it to create a new compute command encoder, using a method like [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/makeComputeCommandEncoder()] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/makeComputeCommandEncoder(descriptor:)]. Add individual dispatches for functions and their data to the compute pass by calling the command encoder’s methods. At the end of assigning data and dispatching a function call to the encoder, create a command that runs in your compute pass with [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandEncoder\/endEncoding()].\n\n\n\nFor information on dispatching commands to encode, see the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder] reference. Compute passes also support indirect command buffers; for more information, see Dispatching from Indirect Command Buffers.\n\nThe following two samples demonstrate basic compute passes:\n\n- See [doc:\/\/com.apple.metal\/documentation\/Metal\/performing-calculations-on-a-gpu] for an example of configuring and running a compute pass that performs basic parallel math.\n- See [doc:\/\/com.apple.metal\/documentation\/Metal\/processing-a-texture-in-a-compute-function] for an example of using a compute pass to modify data for a render pass.\n\n### Kernel arguments and argument tables\n\nCompute commands that execute your code on GPU call *kernel functions* in your Metal shader, annotated with `[[kernel]]`. Each kernel has associated argument tables, such as the buffer argument table `[[buffer(n)]]`, used to access data associated with kernel arguments. In addition to annotations describing any argument table, some kernel arguments need information on their address space. For more information, see the following sections of the [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf]\n\n- For compute kernels, Section 5.1.3\n- For function argument tables, Section 5.2\n- For address spaces, Section 4\n\nIn addition, kernels also use a function table to take advantage of function pointers, allowing them to call visible and intersection functions. Visible functions allow you to use function pointers in kernels, letting you use function stitching and link against Metal dynamic libraries at runtime. Ray tracers use intersection functions on [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructure] instances to perform quick intersection checks.\n\nFor more information on function stitching, dynamic libraries, and ray tracing, see:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/customizing-shaders-using-function-pointers-and-stitching]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/creating-a-metal-dynamic-library]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/ray-tracing-with-acceleration-structures]\n\nFor information on per-architecture support for function tables in compute passes and other restrictions, see the [https:\/\/developer.apple.com\/metal\/Metal-Feature-Set-Tables.pdf].\n\n### Argument buffers and memory residency\n\nCompute kernels can access argument data to populate a Metal structure, using an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] created by an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder]. For an in-depth discussion of argument buffers, see [doc:\/\/com.apple.metal\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers]. Using a resource in an argument buffer requires that it’s resident in GPU memory for the duration of the pass. For a resource to be resident, allocate it with either the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStorageMode\/shared] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStorageMode\/managed] mode.\n\nResources become resident on a per-instance basis by calling methods like [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder\/useResource(_:usage:)] and heaps become resident by calling methods like [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder\/useHeap(_:)].\n\n\n\nWhen using resident resources, avoid data corruption by using an appropriate [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLHazardTrackingMode] or by manually managing memory barriers and fences for untracked resources with the methods in Synchronizing Across Command Execution.\n\n### Using tile memory in a compute pass\n\nApple family GPUs offer fast, integrated graphics memory called *tile memory* that’s shared between subsequent passes for fast access to data. Compute passes can reserve this memory space for threadgroup memory or imageblock memory, giving your compute functions the ability to access temporary data at low latency across your shaders.\n\nFor more information see the following sections of the [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf]:\n\n- Section 4.4 for information on the `threadgroup` memory space\n- Section 4.5 for information on the `threadgroup_imageblock` memory space\n- Section 2.11 for information on imageblocks\n- Section 5.6 for information on `imageblock` attributes\n\nBecause tile memory resides on GPU only, you reserve memory on a tile block rather than copy data to it. Use the methods in Encoding Tile Memory Usage to prepare the appropriate block of memory for your kernel.\n\nFor device support and other tile memory limitations, see [https:\/\/developer.apple.com\/metal\/Metal-Feature-Set-Tables.pdf].\n\n## Essentials\n\n- **Performing calculations on a GPU**: Use Metal to find GPUs and perform calculations on them.\n- **Processing a texture in a compute function**: Create textures by running copy and dispatch commands in a compute pass on a GPU.\n\n## Encoding a compute pass\n\n- **Creating threads and threadgroups**: Learn how Metal organizes compute-processing workloads.\n- **Calculating threadgroup and grid sizes**: Calculate the optimum sizes for threadgroups and grids when dispatching compute-processing workloads.\n- **MTL4ComputeCommandEncoder**: Encodes a compute pass and other memory operations into a command buffer.\n- **MTLComputeCommandEncoder**: An interface for dispatching commands to encode in a compute pass.\n\n## Configuring a compute pipeline state\n\n- **MTL4ComputePipelineDescriptor**: Describes a compute pipeline state.\n- **MTLComputePipelineDescriptor**: An instance describing the desired GPU state for a kernel call in a compute pass.\n- **MTLComputePipelineState**: An interface that represents a GPU pipeline configuration for running kernels in a compute pass.\n- **MTLStageInputOutputDescriptor**: A description of the input and output data of a function.\n- **MTLPipelineBufferDescriptor**: The mutability options for a buffer that a render or compute pipeline uses.\n- **MTLPipelineBufferDescriptorArray**: An array of pipeline buffer descriptors.\n- **MTLPipelineOption**: Options that determine how Metal prepares the pipeline.\n\n## Configuring a compute pass\n\n- **MTLComputePassDescriptor**: A description of how to dispatch execution of pass commands and GPU performance sampling.\n- **MTLDispatchType**: The type of dispatch method to use when calling encoded functions.\n- **MTLDispatchThreadgroupsIndirectArguments**: The data layout required for arguments needed to specify the size of threadgroups.\n- **MTLComputePassSampleBufferAttachmentDescriptor**: A configuration that instructs the GPU where to store counter data from the beginning and end of a compute pass.\n- **MTLComputePassSampleBufferAttachmentDescriptorArray**: A container that stores an array of sample buffer attachments for a compute pass.\n\n## Command encoders\n\n- **Render passes**: Encode a render pass to draw graphics into an image.\n- **Machine-learning passes**: Add machine-learning model inference to your Metal app’s GPU workflow.\n- **Blit passes**: Encode a block information transfer pass to adjust and copy data to and from GPU resources, such as buffers and textures.\n- **Indirect command encoding**: Store draw commands in Metal buffers and run them at a later time on the GPU, either once or repeatedly.\n- **Ray tracing with acceleration structures**: Build a representation of your scene’s geometry using triangles and bounding volumes to quickly trace rays through the scene.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use Metal to find GPUs and perform calculations on them.",
          "name" : "Performing calculations on a GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/performing-calculations-on-a-gpu"
        },
        {
          "description" : "Create textures by running copy and dispatch commands in a compute pass on a GPU.",
          "name" : "Processing a texture in a compute function",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/processing-a-texture-in-a-compute-function"
        }
      ],
      "title" : "Essentials"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn how Metal organizes compute-processing workloads.",
          "name" : "Creating threads and threadgroups",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-threads-and-threadgroups"
        },
        {
          "description" : "Calculate the optimum sizes for threadgroups and grids when dispatching compute-processing workloads.",
          "name" : "Calculating threadgroup and grid sizes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/calculating-threadgroup-and-grid-sizes"
        },
        {
          "description" : "Encodes a compute pass and other memory operations into a command buffer.",
          "name" : "MTL4ComputeCommandEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4ComputeCommandEncoder"
        },
        {
          "description" : "An interface for dispatching commands to encode in a compute pass.",
          "name" : "MTLComputeCommandEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLComputeCommandEncoder"
        }
      ],
      "title" : "Encoding a compute pass"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Describes a compute pipeline state.",
          "name" : "MTL4ComputePipelineDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4ComputePipelineDescriptor"
        },
        {
          "description" : "An instance describing the desired GPU state for a kernel call in a compute pass.",
          "name" : "MTLComputePipelineDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLComputePipelineDescriptor"
        },
        {
          "description" : "An interface that represents a GPU pipeline configuration for running kernels in a compute pass.",
          "name" : "MTLComputePipelineState",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLComputePipelineState"
        },
        {
          "description" : "A description of the input and output data of a function.",
          "name" : "MTLStageInputOutputDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLStageInputOutputDescriptor"
        },
        {
          "description" : "The mutability options for a buffer that a render or compute pipeline uses.",
          "name" : "MTLPipelineBufferDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLPipelineBufferDescriptor"
        },
        {
          "description" : "An array of pipeline buffer descriptors.",
          "name" : "MTLPipelineBufferDescriptorArray",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLPipelineBufferDescriptorArray"
        },
        {
          "description" : "Options that determine how Metal prepares the pipeline.",
          "name" : "MTLPipelineOption",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLPipelineOption"
        }
      ],
      "title" : "Configuring a compute pipeline state"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A description of how to dispatch execution of pass commands and GPU performance sampling.",
          "name" : "MTLComputePassDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLComputePassDescriptor"
        },
        {
          "description" : "The type of dispatch method to use when calling encoded functions.",
          "name" : "MTLDispatchType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLDispatchType"
        },
        {
          "description" : "The data layout required for arguments needed to specify the size of threadgroups.",
          "name" : "MTLDispatchThreadgroupsIndirectArguments",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLDispatchThreadgroupsIndirectArguments"
        },
        {
          "description" : "A configuration that instructs the GPU where to store counter data from the beginning and end of a compute pass.",
          "name" : "MTLComputePassSampleBufferAttachmentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLComputePassSampleBufferAttachmentDescriptor"
        },
        {
          "description" : "A container that stores an array of sample buffer attachments for a compute pass.",
          "name" : "MTLComputePassSampleBufferAttachmentDescriptorArray",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLComputePassSampleBufferAttachmentDescriptorArray"
        }
      ],
      "title" : "Configuring a compute pass"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Encode a render pass to draw graphics into an image.",
          "name" : "Render passes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/render-passes"
        },
        {
          "description" : "Add machine-learning model inference to your Metal app’s GPU workflow.",
          "name" : "Machine-learning passes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/machine-learning-passes"
        },
        {
          "description" : "Encode a block information transfer pass to adjust and copy data to and from GPU resources, such as buffers and textures.",
          "name" : "Blit passes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/blit-passes"
        },
        {
          "description" : "Store draw commands in Metal buffers and run them at a later time on the GPU, either once or repeatedly.",
          "name" : "Indirect command encoding",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/indirect-command-encoding"
        },
        {
          "description" : "Build a representation of your scene’s geometry using triangles and bounding volumes to quickly trace rays through the scene.",
          "name" : "Ray tracing with acceleration structures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/ray-tracing-with-acceleration-structures"
        }
      ],
      "title" : "Command encoders"
    }
  ],
  "source" : "appleJSON",
  "title" : "Compute passes",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/compute-passes"
}