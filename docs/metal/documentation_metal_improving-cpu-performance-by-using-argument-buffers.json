{
  "abstract" : "Optimize your app’s performance by grouping your resources into argument buffers.",
  "codeExamples" : [
    {
      "code" : "struct ArgumentBufferExample{\n    texture2d<float, access::write> a;\n    depth2d<float> b;\n    sampler c;\n    texture2d<float> d;\n    device float4* e;\n    texture2d<float> f;\n    int g;\n};\n\nkernel void example(constant ArgumentBufferExample & argumentBuffer [[buffer(0)]])\n{\n    \/\/ \n    ...\n}",
      "language" : "metal"
    },
    {
      "code" : "struct ArgumentBufferTextures {\n    texture2d<float> diffuse;\n    texture2d<float> specular;\n};\n\nstruct ArgumentBufferMaterial {\n    device ArgumentBufferTextures *textures;\n};\n\nfragment float4 exampleFragment(device ArgumentBufferMaterial & material)\n{\n    return material.textures[4]->diffuse.read(uint2(0));\n}",
      "language" : "metal"
    },
    {
      "code" : "struct ArgumentBufferSampler {\n    sampler sampler0;\n};\n\nkernel void exampleKernel(device ArgumentBufferSampler *source,\n                          device ArgumentBufferSampler *destination,\n                          sampler sampler1) {\n    constexpr sampler sampler2;\n\n    \/\/ Metal allows device-to-device copies.\n    destination->sampler0 = source->sampler0;\n\n    \/\/ Metal doesn't allow thread-to-device copies.\n    destination->sampler0 = sampler1;\n    destination->sampler0 = sampler2;\n}",
      "language" : "metal"
    }
  ],
  "contentHash" : "ae8b11a22efd60171ebecb3141d3d97fcb92e914fb93690ce71768fde89e072c",
  "crawledAt" : "2025-12-02T19:37:38Z",
  "id" : "A37D9E94-8639-400B-A1CA-3C6EA99E7163",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nUse argument buffers to gather multiple resources into a single shader argument. An *argument buffer* is a Metal buffer that contains references to other Metal resources, including [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer], [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture], [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerState], and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructure] instances. Argument buffers use less overhead than assigning each resource individually. This is especially true for resources that don’t change between frames because you can assign the argument buffer once and reuse it many times.\n\nFor more information on argument buffers, watch [https:\/\/developer.apple.com\/videos\/play\/wwdc2022\/10101\/] and [https:\/\/developer.apple.com\/wwdc21\/10286].\n\n### Define argument buffer formats in Metal shading language\n\nDeclare your argument buffers in a Metal Shading Language (MSL) source file as structures.\n\nAdd the following types to the structures:\n\n### Encode resources into argument buffers\n\nStructures in regular Metal buffers define the exact layout of the data in memory. The memory layout for argument buffers depends on the GPU’s support for argument buffers and the device’s OS version. Metal divides argument buffer support into two tiers: Tier 1 and Tier 2. For Tier 2, argument buffers match the memory layout of an equivalent C structure on these OS releases:\n\nTo directly encode the argument buffer resources on these Tier 2 devices, write the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer]`.`[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer\/gpuAddress] property — and for other resource types (samplers, textures, and acceleration structures), the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputePipelineState\/gpuResourceID] property — into the corresponding structure member. To encode offsets, treat these property values as `uint64` types and add the offset to them.\n\nFor Tier 1 devices and older OS versions on Tier 2 devices, buffers have a private memory layout that can vary by GPU. For these devices, use an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder] instance to encode an argument buffer’s data into a destination [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance. Then pass the argument buffer as a parameter to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder] graphics or compute function, such as the following:\n\nYou can encode resources into argument buffers using the following types:\n\n### Use heaps to improve efficiency\n\nEncoding resources into argument buffers eliminates the need for the Metal driver to capture state and track residency when it assigns individual resources to the indices of a function’s argument table. Argument buffers provide greater control over resource residency, which you need to explicitly declare before issuing draw or dispatch calls.\n\nWhen you combine resource heaps with argument buffers, you can further reduce overhead by making all read-only resources backed by an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLHeap] with a single call to the `useHeap` method. However, you still need to call the `useResource` method for each writable resource, even when your pass only intends to read from it.\n\nFinally, argument buffers allow Metal to index resources dynamically at function execution time, which increases the limit on the number of resources that it can place inside the buffers.\n\n### Understand argument buffer tier limits and capabilities\n\nUse the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/argumentBuffersSupport] property of the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] instance to get its tier.\n\n**Common Tier 1 and Tier 2 Limits**\n\nOn iOS and tvOS, the maximum number of unique samplers per app is `96`, and for macOS, `1024` or greater, depending on the device and OS version.` `These limits are only applicable to samplers that have their [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor\/supportArgumentBuffers] property set to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. Use the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice]`.`[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/maxArgumentBufferSamplerCount] property to get the exact maximum number of unique samplers per app for a device.\n\nMetal considers an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerState] instance unique if the configuration of its originating [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor] properties is unique. For example, if two samplers have equal [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor\/minFilter] values but different [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor\/magFilter] values, Metal considers them different instances.\n\nFor the maximum number of entries in each function argument table, see [https:\/\/developer.apple.com\/metal\/Metal-Feature-Set-Tables.pdf].\n\n**Tier 1 Limits**\n\nFor Tier 1, Metal imposes resource limits on the maximum combined number of resources set within an argument buffer and set individually, per graphics or compute function. Metal counts the argument buffer entries against the maximum buffer entries in each function argument table. For example, if a kernel function uses four individual textures and one argument buffer with eight textures, the total number of textures for that kernel function is 12. Tier 1 argument buffers can’t include writable textures.\n\nOther Tier 1 limits on argument buffers are:\n\n**Tier 2 Limits**\n\nGPUs that support Tier 2 argument buffers have significantly higher limits that enable more capabilities in your app.\n\nFor Tier 2, argument buffers can be mutable so that the GPU and CPU can both modify the contents of them at any time. However, Metal may perform certain optimizations if you specify that neither the CPU nor the GPU modifies a buffer’s contents between the time Metal sets the buffer in a function’s argument table and the time Metal completes execution of the associated command buffer. Metal considers these types of argument buffers immutable. To indicate that an argument buffer is immutable and let Metal perform optimizations, set its associated [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPipelineBufferDescriptor]`.`[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPipelineBufferDescriptor\/mutability] property to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLMutability\/immutable].\n\nIn MSL, you access Tier 2 argument buffers by indexing a pointer.\n\nBecause you can’t copy samplers from the thread address space to the device address space, you only copy argument buffer samplers between argument buffers. For example, if you create `constexpr` samplers in shaders by default in the thread address space, you can’t assign them to buffers in the device address space.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/metal\/improving-cpu-performance-by-using-argument-buffers\ncrawled: 2025-12-02T19:37:38Z\n---\n\n# Improving CPU performance by using argument buffers\n\n**Article**\n\nOptimize your app’s performance by grouping your resources into argument buffers.\n\n## Overview\n\nUse argument buffers to gather multiple resources into a single shader argument. An *argument buffer* is a Metal buffer that contains references to other Metal resources, including [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer], [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture], [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerState], and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructure] instances. Argument buffers use less overhead than assigning each resource individually. This is especially true for resources that don’t change between frames because you can assign the argument buffer once and reuse it many times.\n\n\n\nFor more information on argument buffers, watch [https:\/\/developer.apple.com\/videos\/play\/wwdc2022\/10101\/] and [https:\/\/developer.apple.com\/wwdc21\/10286].\n\n### Define argument buffer formats in Metal shading language\n\nDeclare your argument buffers in a Metal Shading Language (MSL) source file as structures.\n\n```metal\nstruct ArgumentBufferExample{\n    texture2d<float, access::write> a;\n    depth2d<float> b;\n    sampler c;\n    texture2d<float> d;\n    device float4* e;\n    texture2d<float> f;\n    int g;\n};\n\nkernel void example(constant ArgumentBufferExample & argumentBuffer [[buffer(0)]])\n{\n    \/\/ \n    ...\n}\n```\n\nAdd the following types to the structures:\n\n- Basic scalar data types, such as `half` and `float`\n- Basic vector and matrix data types, such as `half4` and `float4x4`\n- Textures, such as `texture2d`\n- Samplers, such as a linear sampler\n- Acceleration structures\n- Indirect command buffers\n- Arrays and structures that store the types above\n- Other arrays and structures\n\n\n\n### Encode resources into argument buffers\n\nStructures in regular Metal buffers define the exact layout of the data in memory. The memory layout for argument buffers depends on the GPU’s support for argument buffers and the device’s OS version. Metal divides argument buffer support into two tiers: Tier 1 and Tier 2. For Tier 2, argument buffers match the memory layout of an equivalent C structure on these OS releases:\n\n- iOS 16.0 and later\n- tvOS 16.0 and later\n- macOS 13.0 and later\n\nTo directly encode the argument buffer resources on these Tier 2 devices, write the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer]`.`[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer\/gpuAddress] property — and for other resource types (samplers, textures, and acceleration structures), the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputePipelineState\/gpuResourceID] property — into the corresponding structure member. To encode offsets, treat these property values as `uint64` types and add the offset to them.\n\nFor Tier 1 devices and older OS versions on Tier 2 devices, buffers have a private memory layout that can vary by GPU. For these devices, use an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder] instance to encode an argument buffer’s data into a destination [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance. Then pass the argument buffer as a parameter to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder] graphics or compute function, such as the following:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setFragmentBuffer(_:offset:index:)]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setMeshBuffer(_:offset:index:)]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setObjectBuffer(_:offset:index:)]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setTileBuffer(_:offset:index:)]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder\/setBuffer(_:offset:index:)]\n\nYou can encode resources into argument buffers using the following types:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerState]\n- [doc:\/\/com.apple.documentation\/documentation\/simd\/simd_float1], [doc:\/\/com.apple.documentation\/documentation\/simd\/simd_float4], and other inlined constant data\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructure]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLIndirectCommandBuffer]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputePipelineState]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineState]\n\n### Use heaps to improve efficiency\n\nEncoding resources into argument buffers eliminates the need for the Metal driver to capture state and track residency when it assigns individual resources to the indices of a function’s argument table. Argument buffers provide greater control over resource residency, which you need to explicitly declare before issuing draw or dispatch calls.\n\nWhen you combine resource heaps with argument buffers, you can further reduce overhead by making all read-only resources backed by an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLHeap] with a single call to the `useHeap` method. However, you still need to call the `useResource` method for each writable resource, even when your pass only intends to read from it.\n\nFinally, argument buffers allow Metal to index resources dynamically at function execution time, which increases the limit on the number of resources that it can place inside the buffers.\n\n### Understand argument buffer tier limits and capabilities\n\nUse the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/argumentBuffersSupport] property of the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] instance to get its tier.\n\n**Common Tier 1 and Tier 2 Limits**\n\nOn iOS and tvOS, the maximum number of unique samplers per app is `96`, and for macOS, `1024` or greater, depending on the device and OS version.` `These limits are only applicable to samplers that have their [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor\/supportArgumentBuffers] property set to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. Use the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice]`.`[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/maxArgumentBufferSamplerCount] property to get the exact maximum number of unique samplers per app for a device.\n\nMetal considers an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerState] instance unique if the configuration of its originating [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor] properties is unique. For example, if two samplers have equal [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor\/minFilter] values but different [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSamplerDescriptor\/magFilter] values, Metal considers them different instances.\n\nFor the maximum number of entries in each function argument table, see [https:\/\/developer.apple.com\/metal\/Metal-Feature-Set-Tables.pdf].\n\n**Tier 1 Limits**\n\nFor Tier 1, Metal imposes resource limits on the maximum combined number of resources set within an argument buffer and set individually, per graphics or compute function. Metal counts the argument buffer entries against the maximum buffer entries in each function argument table. For example, if a kernel function uses four individual textures and one argument buffer with eight textures, the total number of textures for that kernel function is 12. Tier 1 argument buffers can’t include writable textures.\n\nOther Tier 1 limits on argument buffers are:\n\n- Need to be immutable because the GPU can’t modify the contents of an argument buffer\n- Need to be CPU-accessible, so set the buffer’s storage mode to either [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStorageMode\/shared] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStorageMode\/managed]\n- Can’t be accessible through pointer indexing, or include pointers to other argument buffers, in MSL\n\n**Tier 2 Limits**\n\nGPUs that support Tier 2 argument buffers have significantly higher limits that enable more capabilities in your app.\n\nFor Tier 2, argument buffers can be mutable so that the GPU and CPU can both modify the contents of them at any time. However, Metal may perform certain optimizations if you specify that neither the CPU nor the GPU modifies a buffer’s contents between the time Metal sets the buffer in a function’s argument table and the time Metal completes execution of the associated command buffer. Metal considers these types of argument buffers immutable. To indicate that an argument buffer is immutable and let Metal perform optimizations, set its associated [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPipelineBufferDescriptor]`.`[doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPipelineBufferDescriptor\/mutability] property to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLMutability\/immutable].\n\nIn MSL, you access Tier 2 argument buffers by indexing a pointer.\n\n```metal\nstruct ArgumentBufferTextures {\n    texture2d<float> diffuse;\n    texture2d<float> specular;\n};\n\nstruct ArgumentBufferMaterial {\n    device ArgumentBufferTextures *textures;\n};\n\nfragment float4 exampleFragment(device ArgumentBufferMaterial & material)\n{\n    return material.textures[4]->diffuse.read(uint2(0));\n}\n```\n\nBecause you can’t copy samplers from the thread address space to the device address space, you only copy argument buffer samplers between argument buffers. For example, if you create `constexpr` samplers in shaders by default in the thread address space, you can’t assign them to buffers in the device address space.\n\n```metal\nstruct ArgumentBufferSampler {\n    sampler sampler0;\n};\n\nkernel void exampleKernel(device ArgumentBufferSampler *source,\n                          device ArgumentBufferSampler *destination,\n                          sampler sampler1) {\n    constexpr sampler sampler2;\n\n    \/\/ Metal allows device-to-device copies.\n    destination->sampler0 = source->sampler0;\n\n    \/\/ Metal doesn't allow thread-to-device copies.\n    destination->sampler0 = sampler1;\n    destination->sampler0 = sampler2;\n}\n```\n\n## Argument buffers\n\n- **Managing groups of resources with argument buffers**: Create argument buffers to organize related resources.\n- **Tracking the resource residency of argument buffers**: Optimize resource performance within an argument buffer.\n- **Indexing argument buffers**: Assign resource indices within an argument buffer.\n- **Rendering terrain dynamically with argument buffers**: Use argument buffers to render terrain in real time with a GPU-driven pipeline.\n- **Encoding argument buffers on the GPU**: Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.\n- **Using argument buffers with resource heaps**: Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.\n- **MTLArgumentDescriptor**: A representation of an argument within an argument buffer.\n- **MTLArgumentEncoder**: An interface you can use to encode argument data into an argument buffer.\n- **MTLAttributeStrideStatic**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create argument buffers to organize related resources.",
          "name" : "Managing groups of resources with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-groups-of-resources-with-argument-buffers"
        },
        {
          "description" : "Optimize resource performance within an argument buffer.",
          "name" : "Tracking the resource residency of argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/tracking-the-resource-residency-of-argument-buffers"
        },
        {
          "description" : "Assign resource indices within an argument buffer.",
          "name" : "Indexing argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/indexing-argument-buffers"
        },
        {
          "description" : "Use argument buffers to render terrain in real time with a GPU-driven pipeline.",
          "name" : "Rendering terrain dynamically with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-terrain-dynamically-with-argument-buffers"
        },
        {
          "description" : "Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.",
          "name" : "Encoding argument buffers on the GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-argument-buffers-on-the-gpu"
        },
        {
          "description" : "Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.",
          "name" : "Using argument buffers with resource heaps",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-argument-buffers-with-resource-heaps"
        },
        {
          "description" : "A representation of an argument within an argument buffer.",
          "name" : "MTLArgumentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentDescriptor"
        },
        {
          "description" : "An interface you can use to encode argument data into an argument buffer.",
          "name" : "MTLArgumentEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentEncoder"
        },
        {
          "description" : "",
          "name" : "MTLAttributeStrideStatic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAttributeStrideStatic"
        }
      ],
      "title" : "Argument buffers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Improving CPU performance by using argument buffers",
  "url" : "https:\/\/developer.apple.com\/documentation\/metal\/improving-cpu-performance-by-using-argument-buffers"
}