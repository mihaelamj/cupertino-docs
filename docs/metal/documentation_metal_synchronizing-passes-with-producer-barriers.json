{
  "abstract" : "Block GPU stages in subsequent passes from running until stages in a pass, and earlier passes, finish.",
  "codeExamples" : [

  ],
  "contentHash" : "b8911b0bb963561673100aa285b3c63b9f58d810c1313e2fe7ef589c68664c96",
  "crawledAt" : "2025-12-02T16:43:09Z",
  "id" : "2E762621-D064-4119-9D7A-B7D849183179",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nProducer queue barriers are coarse synchronization primitives that resolve access conflicts between commands in different passes that you submit to the same command queue, including passes from other command buffers. Producer barriers are convenient for synchronizing passes that modify common resources that multiple, subsequent passes in the same queue load later on.\n\nWhen your app encodes commands that access a resource from different passes — or different stages within a single pass — it creates an access conflict when at least one command modifies that resource. This conflict happens because the GPU can run multiple commands at the same time, including those from:\n\nFor more information about resource access conflicts and GPU stages, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages], respectively.\n\nStart by identifying which memory operations from subsequent passes in the same queue introduce a conflict and resolve them with an intraqueue barrier in the producing pass.\n\n### Identify access conflicts with subsequent passes\n\nThe following code example encodes three compute passes. The first pass runs a single copy command:\n\nThe second pass runs a copy command and a dispatch command:\n\nThe third pass runs a single dispatch command:\n\nThe example has at least one access conflict because passes 2 and 3 both access a common resource, `bufferD`:\n\n\n\nWithout synchronization, the GPU can run all three passes and their stages in parallel, which can yield inconsistent results in resources with access conflicts.\n\n\n\n### Resolve access conflicts with a producer barrier\n\nTo resolve access conflicts between passes from the same command queue, use a producer barrier by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/barrier(afterStages:beforeQueueStages:visibilityOptions:)] method.\n\nEach producer queue barrier temporarily blocks the GPU from running the specific stage types, which you pass to the `beforeQueueStages` parameter, in all subsequent passes in the same queue. The barrier unblocks those stages when all the stage types you pass to the `afterStages` parameter finish running in the pass and all previous passes.\n\nThe following example modifies the code that encodes the second pass by adding a producer queue barrier just before the dispatch command stage in the second pass.\n\nIn this example, the barrier prevents the GPU from running the dispatch stage in the third pass until the blit stages in both the first and second pass finish storing their modifications.\n\n\n\nThe barrier unblocks the dispatch stage of the third pass when the blit stage from the first pass finishes running because it’s the last blit stage to finish of all the passes that apply to the `afterStages` parameter.\n\nFor more information about other synchronization mechanisms, see these articles in the series:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-passes-with-producer-barriers\ncrawled: 2025-12-02T16:43:09Z\n---\n\n# Synchronizing passes with producer barriers\n\n**Article**\n\nBlock GPU stages in subsequent passes from running until stages in a pass, and earlier passes, finish.\n\n## Overview\n\nProducer queue barriers are coarse synchronization primitives that resolve access conflicts between commands in different passes that you submit to the same command queue, including passes from other command buffers. Producer barriers are convenient for synchronizing passes that modify common resources that multiple, subsequent passes in the same queue load later on.\n\n\n\nWhen your app encodes commands that access a resource from different passes — or different stages within a single pass — it creates an access conflict when at least one command modifies that resource. This conflict happens because the GPU can run multiple commands at the same time, including those from:\n\n- Multiple passes\n- Different stages of a pass, such as the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/blit] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages\/dispatch] stages of a compute pass\n- Multiple instances of a stage, such as two or more dispatch commands within a compute pass\n\nFor more information about resource access conflicts and GPU stages, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLStages], respectively.\n\n\n\nStart by identifying which memory operations from subsequent passes in the same queue introduce a conflict and resolve them with an intraqueue barrier in the producing pass.\n\n### Identify access conflicts with subsequent passes\n\nThe following code example encodes three compute passes. The first pass runs a single copy command:\n\n\n\nThe second pass runs a copy command and a dispatch command:\n\n\n\nThe third pass runs a single dispatch command:\n\n\n\nThe example has at least one access conflict because passes 2 and 3 both access a common resource, `bufferD`:\n\n- The copy command from the second pass stores to `bufferD`.\n- The dispatch command from the third pass loads from `bufferD`.\n\n\n\nWithout synchronization, the GPU can run all three passes and their stages in parallel, which can yield inconsistent results in resources with access conflicts.\n\n\n\n### Resolve access conflicts with a producer barrier\n\nTo resolve access conflicts between passes from the same command queue, use a producer barrier by calling the encoder’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder\/barrier(afterStages:beforeQueueStages:visibilityOptions:)] method.\n\nEach producer queue barrier temporarily blocks the GPU from running the specific stage types, which you pass to the `beforeQueueStages` parameter, in all subsequent passes in the same queue. The barrier unblocks those stages when all the stage types you pass to the `afterStages` parameter finish running in the pass and all previous passes.\n\n\n\nThe following example modifies the code that encodes the second pass by adding a producer queue barrier just before the dispatch command stage in the second pass.\n\n\n\nIn this example, the barrier prevents the GPU from running the dispatch stage in the third pass until the blit stages in both the first and second pass finish storing their modifications.\n\n\n\nThe barrier unblocks the dispatch stage of the third pass when the blit stage from the first pass finishes running because it’s the last blit stage to finish of all the passes that apply to the `afterStages` parameter.\n\nFor more information about other synchronization mechanisms, see these articles in the series:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-stages-within-a-pass]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-passes-with-a-fence]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-passes-with-consumer-barriers]\n\n## Synchronizing with barriers and fences\n\n- **Synchronizing stages within a pass**: Block GPU stages in the a pass from running until other stages in the same pass finish.\n- **Synchronizing passes with a fence**: Block GPU stages in a pass until another pass unblocks it by signaling a fence.\n- **Synchronizing passes with consumer barriers**: Block GPU stages in a pass, and all subsequent passes, from running until stages from earlier passes finish.\n- **Synchronizing CPU and GPU work**: Avoid stalls between CPU and GPU work by using multiple instances of a resource.\n- **Implementing a multistage image filter using heaps and fences**: Use fences to synchronize access to resources allocated on a heap.\n- **MTLStages**: Describes stages of GPU work.\n- **MTLFence**: A synchronization mechanism that orders memory operations between GPU passes.\n- **MTLRenderStages**: The stages in a render pass that triggers a synchronization command.\n- **MTLBarrierScope**: Describes the types of resources that a barrier operates on.\n- **MTL4VisibilityOptions**: Memory consistency options for synchronization commands.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Block GPU stages in the a pass from running until other stages in the same pass finish.",
          "name" : "Synchronizing stages within a pass",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-stages-within-a-pass"
        },
        {
          "description" : "Block GPU stages in a pass until another pass unblocks it by signaling a fence.",
          "name" : "Synchronizing passes with a fence",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-passes-with-a-fence"
        },
        {
          "description" : "Block GPU stages in a pass, and all subsequent passes, from running until stages from earlier passes finish.",
          "name" : "Synchronizing passes with consumer barriers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-passes-with-consumer-barriers"
        },
        {
          "description" : "Avoid stalls between CPU and GPU work by using multiple instances of a resource.",
          "name" : "Synchronizing CPU and GPU work",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-cpu-and-gpu-work"
        },
        {
          "description" : "Use fences to synchronize access to resources allocated on a heap.",
          "name" : "Implementing a multistage image filter using heaps and fences",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-a-multistage-image-filter-using-heaps-and-fences"
        },
        {
          "description" : "Describes stages of GPU work.",
          "name" : "MTLStages",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLStages"
        },
        {
          "description" : "A synchronization mechanism that orders memory operations between GPU passes.",
          "name" : "MTLFence",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLFence"
        },
        {
          "description" : "The stages in a render pass that triggers a synchronization command.",
          "name" : "MTLRenderStages",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLRenderStages"
        },
        {
          "description" : "Describes the types of resources that a barrier operates on.",
          "name" : "MTLBarrierScope",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLBarrierScope"
        },
        {
          "description" : "Memory consistency options for synchronization commands.",
          "name" : "MTL4VisibilityOptions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4VisibilityOptions"
        }
      ],
      "title" : "Synchronizing with barriers and fences"
    }
  ],
  "source" : "appleJSON",
  "title" : "Synchronizing passes with producer barriers",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-passes-with-producer-barriers"
}