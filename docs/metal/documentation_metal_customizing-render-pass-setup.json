{
  "abstract" : "Render into an offscreen texture by creating a custom render pass.",
  "codeExamples" : [
    {
      "code" : "MTLTextureDescriptor *texDescriptor = [MTLTextureDescriptor new];\ntexDescriptor.textureType = MTLTextureType2D;\ntexDescriptor.width = 512;\ntexDescriptor.height = 512;\ntexDescriptor.pixelFormat = MTLPixelFormatRGBA8Unorm;\ntexDescriptor.usage = MTLTextureUsageRenderTarget |\n                      MTLTextureUsageShaderRead;",
      "language" : "objective-c"
    },
    {
      "code" : "pipelineStateDescriptor.label = @\"Offscreen Render Pipeline\";\npipelineStateDescriptor.sampleCount = 1;\npipelineStateDescriptor.vertexFunction =  [defaultLibrary newFunctionWithName:@\"simpleVertexShader\"];\npipelineStateDescriptor.fragmentFunction =  [defaultLibrary newFunctionWithName:@\"simpleFragmentShader\"];\npipelineStateDescriptor.colorAttachments[0].pixelFormat = _renderTargetTexture.pixelFormat;\n_renderToTextureRenderPipeline = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor error:&error];",
      "language" : "objective-c"
    },
    {
      "code" : "_renderToTextureRenderPassDescriptor.colorAttachments[0].texture = _renderTargetTexture;",
      "language" : "objective-c"
    },
    {
      "code" : "_renderToTextureRenderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;\n_renderToTextureRenderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(1, 1, 1, 1);\n\n_renderToTextureRenderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;",
      "language" : "objective-c"
    },
    {
      "code" : "id<MTLRenderCommandEncoder> renderEncoder =\n    [commandBuffer renderCommandEncoderWithDescriptor:_renderToTextureRenderPassDescriptor];\nrenderEncoder.label = @\"Offscreen Render Pass\";\n[renderEncoder setRenderPipelineState:_renderToTextureRenderPipeline];",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder endEncoding];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Fragment shader that samples a texture and outputs the sampled color.\nfragment float4 textureFragmentShader(TexturePipelineRasterizerData in      [[stage_in]],\n                                      texture2d<float>              texture [[texture(AAPLTextureInputIndexColor)]])\n{\n    sampler simpleSampler;\n\n    \/\/ Sample data from the texture.\n    float4 colorSample = texture.sample(simpleSampler, in.texcoord);\n\n    \/\/ Return the color sample as the final color.\n    return colorSample;\n}",
      "language" : "metal"
    },
    {
      "code" : "id<MTLRenderCommandEncoder> renderEncoder =\n    [commandBuffer renderCommandEncoderWithDescriptor:drawableRenderPassDescriptor];\nrenderEncoder.label = @\"Drawable Render Pass\";\n\n[renderEncoder setRenderPipelineState:_drawableRenderPipeline];\n\n[renderEncoder setVertexBytes:&quadVertices\n                       length:sizeof(quadVertices)\n                      atIndex:AAPLVertexInputIndexVertices];\n\n[renderEncoder setVertexBytes:&_aspectRatio\n                       length:sizeof(_aspectRatio)\n                      atIndex:AAPLVertexInputIndexAspectRatio];\n\n\/\/ Set the offscreen texture as the source texture.\n[renderEncoder setFragmentTexture:_renderTargetTexture atIndex:AAPLTextureInputIndexColor];",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "3b660bf036aaf80290c6ea6d6ed758d6810c3ef41396c9954e1f82d43f7b6928",
  "crawledAt" : "2025-12-02T15:49:22Z",
  "id" : "F7D347FB-9033-49CE-A4FE-229DCF48FA5B",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nA render pass is a sequence of rendering commands that draw into a set of textures. This sample executes a pair of render passes to render a view’s contents. For the first pass, the sample creates a custom render pass to render an image into a texture. This pass is  an *offscreen render pass*, because the sample renders to a normal texture, rather than one created by the display subsystem. The second render pass uses a render pass descriptor, provided by the [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] object, to render and display the final image. The sample uses the texture from the offscreen render pass as source data for the drawing command in the second render pass.\n\nOffscreen render passes are fundamental building blocks for larger or more complicated renderers. For example, many lighting and shadow algorithms require an offscreen render pass to render shadow information and a second pass to calculate the final scene lighting. Offscreen render passes are also useful when performing batch processing of data that doesn’t need to be displayed onscreen.\n\n### Create a texture for the offscreen render pass\n\nAn [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] object automatically creates drawable textures to render into. The sample also needs a texture to render into during the offscreen render pass.  To create that texture, it first creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor] object and configures its properties.\n\nThe sample configures the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/usage] property to state exactly how it intends to use the new texture. It needs to render data into the texture in the offscreen render pass and  read from it in the second pass. The sample specifies this usage by setting the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureUsage\/renderTarget] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureUsage\/shaderRead] flags.\n\nSetting usage flags precisely can improve performance, because Metal can configure the texture’s underlying data only for the specified uses.\n\n### Create the render pipelines\n\nA render pipeline specifies how to execute a drawing command, including the vertex and fragment functions to execute, and the pixel formats of any render targets it acts upon. Later, when the sample creates the custom render pass, it needs to use the same pixel formats.\n\nThis sample creates one render pipeline for each render pass, using the following code for the offscreen render pipeline:\n\nThe code to create the pipeline for the drawable render pass is similar to that found in [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4]. To guarantee that the two pixel formats match, the sample sets the descriptor’s pixel format to the view’s `colorPixelFormat`. Similarly, when creating the offscreen render pipeline, the sample sets the descriptor’s pixel format to the offscreen texture’s format.\n\n### Set up the offscreen render pass descriptor\n\nTo render to the offscreen texture, the sample configures a new render pass descriptor. It creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPassDescriptor] object and configures its properties. This sample renders to a single color texture, so it sets `colorAttachment[0].texture` to point to the offscreen texture:\n\nThe sample also needs to configure a *load action* and a *store action* for this render target.\n\nA load action determines the initial contents of the texture at the start of the render pass, before the GPU executes any drawing commands. Similarly, a store action runs after the render pass completes, and determines whether the GPU writes the final image back to the texture. The sample configures a load action to erase the render target’s contents, and a store action that stores the rendered data back to the texture. It needs to do the latter because the drawing commands in the second render-pass sample this data.\n\nMetal uses load and store actions to optimize how the GPU manages texture data. Large textures consume lots of memory, and working on those textures can consume lots of memory bandwidth. Setting the render target actions correctly can reduce the amount of memory bandwidth the GPU uses to access the texture, improving performance and battery life. See [doc:\/\/com.apple.metal\/documentation\/Metal\/setting-load-and-store-actions] for guidance.\n\nA render pass descriptor has other properties not used in this sample that further modify the rendering process. For information on other ways to customize the render pass descriptor, see [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPassDescriptor].\n\n### Render to the offscreen texture\n\nThe sample has everything it needs to encode both render passes. It’s important to understand how Metal schedules commands on the GPU before seeing how the sample encodes the render passes.\n\nWhen an app commits a buffer of commands to a command queue, by default, Metal needs to act as if it executes commands sequentially. To increase performance and to better utilize the GPU, Metal can run commands concurrently, as long as doing so doesn’t generate results inconsistent with sequential execution. To accomplish this, when a pass writes to a resource and a subsequent pass reads from it, as in this sample, Metal detects the dependency and automatically delays execution of the later pass until the first one completes. So, unlike [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-cpu-and-gpu-work], where the CPU and GPU needed to be explicitly synchronized, the sample doesn’t need to do anything special. It simply encodes the two passes sequentially, and Metal ensures they run in that order.\n\nThe sample encodes both render passes into one command buffer, starting with the offscreen render pass. It creates a render command encoder using the offscreen render pass descriptor it previously created.\n\nEverything else in the render pass is similar to [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4]. It configures the pipeline and any necessary arguments, then encodes the drawing command. After encoding the command, it calls [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandEncoder\/endEncoding()] to finish the encoding process.\n\nMultiple passes need to be encoded sequentially into a command buffer, so the sample needs to finish encoding the first render pass before starting the next one.\n\n### Render to the drawable texture\n\nThe second render pass needs renders the final image. The drawable render pipeline’s fragment shader samples data from a texture and returns that sample as the final color:\n\nThe code uses the view’s render pass descriptor to create the second render pass, and encodes a drawing command to render a textured quad. It specifies the offscreen texture as the texture argument for the command.\n\nWhen the sample commits the command buffer, Metal executes the two render passes sequentially. In this case, Metal detects that the first render pass writes to the offscreen texture and the second pass reads from it. When Metal detects such a dependency, it prevents the subsequent pass from executing until the GPU finishes executing the first pass.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup\ncrawled: 2025-12-02T15:49:22Z\n---\n\n# Customizing render pass setup\n\n**Sample Code**\n\nRender into an offscreen texture by creating a custom render pass.\n\n## Overview\n\nA render pass is a sequence of rendering commands that draw into a set of textures. This sample executes a pair of render passes to render a view’s contents. For the first pass, the sample creates a custom render pass to render an image into a texture. This pass is  an *offscreen render pass*, because the sample renders to a normal texture, rather than one created by the display subsystem. The second render pass uses a render pass descriptor, provided by the [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] object, to render and display the final image. The sample uses the texture from the offscreen render pass as source data for the drawing command in the second render pass.\n\nOffscreen render passes are fundamental building blocks for larger or more complicated renderers. For example, many lighting and shadow algorithms require an offscreen render pass to render shadow information and a second pass to calculate the final scene lighting. Offscreen render passes are also useful when performing batch processing of data that doesn’t need to be displayed onscreen.\n\n### Create a texture for the offscreen render pass\n\nAn [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] object automatically creates drawable textures to render into. The sample also needs a texture to render into during the offscreen render pass.  To create that texture, it first creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor] object and configures its properties.\n\n```objective-c\nMTLTextureDescriptor *texDescriptor = [MTLTextureDescriptor new];\ntexDescriptor.textureType = MTLTextureType2D;\ntexDescriptor.width = 512;\ntexDescriptor.height = 512;\ntexDescriptor.pixelFormat = MTLPixelFormatRGBA8Unorm;\ntexDescriptor.usage = MTLTextureUsageRenderTarget |\n                      MTLTextureUsageShaderRead;\n```\n\nThe sample configures the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/usage] property to state exactly how it intends to use the new texture. It needs to render data into the texture in the offscreen render pass and  read from it in the second pass. The sample specifies this usage by setting the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureUsage\/renderTarget] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureUsage\/shaderRead] flags.\n\nSetting usage flags precisely can improve performance, because Metal can configure the texture’s underlying data only for the specified uses.\n\n### Create the render pipelines\n\nA render pipeline specifies how to execute a drawing command, including the vertex and fragment functions to execute, and the pixel formats of any render targets it acts upon. Later, when the sample creates the custom render pass, it needs to use the same pixel formats.\n\nThis sample creates one render pipeline for each render pass, using the following code for the offscreen render pipeline:\n\n```objective-c\npipelineStateDescriptor.label = @\"Offscreen Render Pipeline\";\npipelineStateDescriptor.sampleCount = 1;\npipelineStateDescriptor.vertexFunction =  [defaultLibrary newFunctionWithName:@\"simpleVertexShader\"];\npipelineStateDescriptor.fragmentFunction =  [defaultLibrary newFunctionWithName:@\"simpleFragmentShader\"];\npipelineStateDescriptor.colorAttachments[0].pixelFormat = _renderTargetTexture.pixelFormat;\n_renderToTextureRenderPipeline = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor error:&error];\n```\n\nThe code to create the pipeline for the drawable render pass is similar to that found in [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4]. To guarantee that the two pixel formats match, the sample sets the descriptor’s pixel format to the view’s `colorPixelFormat`. Similarly, when creating the offscreen render pipeline, the sample sets the descriptor’s pixel format to the offscreen texture’s format.\n\n### Set up the offscreen render pass descriptor\n\nTo render to the offscreen texture, the sample configures a new render pass descriptor. It creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPassDescriptor] object and configures its properties. This sample renders to a single color texture, so it sets `colorAttachment[0].texture` to point to the offscreen texture:\n\n```objective-c\n_renderToTextureRenderPassDescriptor.colorAttachments[0].texture = _renderTargetTexture;\n```\n\nThe sample also needs to configure a *load action* and a *store action* for this render target.\n\n```objective-c\n_renderToTextureRenderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;\n_renderToTextureRenderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(1, 1, 1, 1);\n\n_renderToTextureRenderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;\n```\n\nA load action determines the initial contents of the texture at the start of the render pass, before the GPU executes any drawing commands. Similarly, a store action runs after the render pass completes, and determines whether the GPU writes the final image back to the texture. The sample configures a load action to erase the render target’s contents, and a store action that stores the rendered data back to the texture. It needs to do the latter because the drawing commands in the second render-pass sample this data.\n\nMetal uses load and store actions to optimize how the GPU manages texture data. Large textures consume lots of memory, and working on those textures can consume lots of memory bandwidth. Setting the render target actions correctly can reduce the amount of memory bandwidth the GPU uses to access the texture, improving performance and battery life. See [doc:\/\/com.apple.metal\/documentation\/Metal\/setting-load-and-store-actions] for guidance.\n\nA render pass descriptor has other properties not used in this sample that further modify the rendering process. For information on other ways to customize the render pass descriptor, see [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPassDescriptor].\n\n### Render to the offscreen texture\n\nThe sample has everything it needs to encode both render passes. It’s important to understand how Metal schedules commands on the GPU before seeing how the sample encodes the render passes.\n\nWhen an app commits a buffer of commands to a command queue, by default, Metal needs to act as if it executes commands sequentially. To increase performance and to better utilize the GPU, Metal can run commands concurrently, as long as doing so doesn’t generate results inconsistent with sequential execution. To accomplish this, when a pass writes to a resource and a subsequent pass reads from it, as in this sample, Metal detects the dependency and automatically delays execution of the later pass until the first one completes. So, unlike [doc:\/\/com.apple.metal\/documentation\/Metal\/synchronizing-cpu-and-gpu-work], where the CPU and GPU needed to be explicitly synchronized, the sample doesn’t need to do anything special. It simply encodes the two passes sequentially, and Metal ensures they run in that order.\n\nThe sample encodes both render passes into one command buffer, starting with the offscreen render pass. It creates a render command encoder using the offscreen render pass descriptor it previously created.\n\n```objective-c\nid<MTLRenderCommandEncoder> renderEncoder =\n    [commandBuffer renderCommandEncoderWithDescriptor:_renderToTextureRenderPassDescriptor];\nrenderEncoder.label = @\"Offscreen Render Pass\";\n[renderEncoder setRenderPipelineState:_renderToTextureRenderPipeline];\n```\n\nEverything else in the render pass is similar to [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4]. It configures the pipeline and any necessary arguments, then encodes the drawing command. After encoding the command, it calls [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandEncoder\/endEncoding()] to finish the encoding process.\n\n```objective-c\n[renderEncoder endEncoding];\n```\n\nMultiple passes need to be encoded sequentially into a command buffer, so the sample needs to finish encoding the first render pass before starting the next one.\n\n### Render to the drawable texture\n\nThe second render pass needs renders the final image. The drawable render pipeline’s fragment shader samples data from a texture and returns that sample as the final color:\n\n```metal\n\/\/ Fragment shader that samples a texture and outputs the sampled color.\nfragment float4 textureFragmentShader(TexturePipelineRasterizerData in      [[stage_in]],\n                                      texture2d<float>              texture [[texture(AAPLTextureInputIndexColor)]])\n{\n    sampler simpleSampler;\n\n    \/\/ Sample data from the texture.\n    float4 colorSample = texture.sample(simpleSampler, in.texcoord);\n\n    \/\/ Return the color sample as the final color.\n    return colorSample;\n}\n```\n\nThe code uses the view’s render pass descriptor to create the second render pass, and encodes a drawing command to render a textured quad. It specifies the offscreen texture as the texture argument for the command.\n\n```objective-c\nid<MTLRenderCommandEncoder> renderEncoder =\n    [commandBuffer renderCommandEncoderWithDescriptor:drawableRenderPassDescriptor];\nrenderEncoder.label = @\"Drawable Render Pass\";\n\n[renderEncoder setRenderPipelineState:_drawableRenderPipeline];\n\n[renderEncoder setVertexBytes:&quadVertices\n                       length:sizeof(quadVertices)\n                      atIndex:AAPLVertexInputIndexVertices];\n\n[renderEncoder setVertexBytes:&_aspectRatio\n                       length:sizeof(_aspectRatio)\n                      atIndex:AAPLVertexInputIndexAspectRatio];\n\n\/\/ Set the offscreen texture as the source texture.\n[renderEncoder setFragmentTexture:_renderTargetTexture atIndex:AAPLTextureInputIndexColor];\n```\n\nWhen the sample commits the command buffer, Metal executes the two render passes sequentially. In this case, Metal detects that the first render pass writes to the offscreen texture and the second pass reads from it. When Metal detects such a dependency, it prevents the subsequent pass from executing until the GPU finishes executing the first pass.\n\n## Render workflows\n\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Selecting device objects for graphics rendering**: Switch dynamically between multiple GPUs to efficiently render to a display.\n- **Creating a custom Metal view**: Implement a lightweight view for Metal rendering that’s customized to your app’s needs.\n- **Calculating primitive visibility using depth testing**: Determine which pixels are visible in a scene by using a depth texture.\n- **Encoding indirect command buffers on the CPU**: Reduce CPU overhead and simplify your command execution by reusing commands.\n- **Implementing order-independent transparency with image blocks**: Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.\n- **Loading textures and models using Metal fast resource loading**: Stream texture and buffer data directly from disk into Metal resources using fast resource loading.\n- **Adjusting the level of detail using Metal mesh shaders**: Choose and render meshes with several levels of detail using object and mesh shaders.\n- **Creating a 3D application with hydra rendering**: Build a 3D application that integrates with Hydra and USD.\n- **Culling occluded geometry using the visibility result buffer**: Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.\n- **Improving edge-rendering quality with multisample antialiasing (MSAA)**: Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.\n- **Achieving smooth frame rates with a Metal display link**: Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        },
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Switch dynamically between multiple GPUs to efficiently render to a display.",
          "name" : "Selecting device objects for graphics rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-graphics-rendering"
        },
        {
          "description" : "Implement a lightweight view for Metal rendering that’s customized to your app’s needs.",
          "name" : "Creating a custom Metal view",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-custom-metal-view"
        },
        {
          "description" : "Determine which pixels are visible in a scene by using a depth texture.",
          "name" : "Calculating primitive visibility using depth testing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/calculating-primitive-visibility-using-depth-testing"
        },
        {
          "description" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "name" : "Encoding indirect command buffers on the CPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
        },
        {
          "description" : "Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.",
          "name" : "Implementing order-independent transparency with image blocks",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-order-independent-transparency-with-image-blocks"
        },
        {
          "description" : "Stream texture and buffer data directly from disk into Metal resources using fast resource loading.",
          "name" : "Loading textures and models using Metal fast resource loading",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/loading-textures-and-models-using-metal-fast-resource-loading"
        },
        {
          "description" : "Choose and render meshes with several levels of detail using object and mesh shaders.",
          "name" : "Adjusting the level of detail using Metal mesh shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/adjusting-the-level-of-detail-using-metal-mesh-shaders"
        },
        {
          "description" : "Build a 3D application that integrates with Hydra and USD.",
          "name" : "Creating a 3D application with hydra rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-3d-application-with-hydra-rendering"
        },
        {
          "description" : "Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.",
          "name" : "Culling occluded geometry using the visibility result buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/culling-occluded-geometry-using-the-visibility-result-buffer"
        },
        {
          "description" : "Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.",
          "name" : "Improving edge-rendering quality with multisample antialiasing (MSAA)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-edge-rendering-quality-with-multisample-antialiasing-msaa"
        },
        {
          "description" : "Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.",
          "name" : "Achieving smooth frame rates with a Metal display link",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/achieving-smooth-frame-rates-with-a-metal-display-link"
        }
      ],
      "title" : "Render workflows"
    }
  ],
  "source" : "appleJSON",
  "title" : "Customizing render pass setup",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup"
}