{
  "abstract" : "Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.",
  "codeExamples" : [
    {
      "code" : "\/\/ Check that this GPU supports raster order groups.\n_supportsOrderIndependentTransparency = [_device supportsFamily:MTLGPUFamilyApple4];",
      "language" : "objective-c"
    },
    {
      "code" : "struct TransparentFragmentStore\n{\n    TransparentFragmentValues values [[imageblock_data]];\n};",
      "language" : "metal"
    },
    {
      "code" : "struct TransparentFragmentValues\n{\n    \/\/ Store the color of the transparent fragment.\n    \/\/ Use a packed data type to reduce the size of the explicit ImageBlock.\n    rgba8unorm<half4> colors [[raster_order_group(0)]] [kNumLayers];\n\n    \/\/ An array of transparent fragment distances from the camera.\n    half depths              [[raster_order_group(0)]] [kNumLayers];\n};",
      "language" : "metal"
    },
    {
      "code" : "\/\/\/ The number of transparent geometry layers that the app stores in image block memory.\n\/\/\/ Each layer consumes tile memory and increases the value of the pipeline's `imageBlockSampleLength` property.\nstatic constexpr constant short kNumLayers = 4;",
      "language" : "metal"
    },
    {
      "code" : "\/\/ Set the image block's memory size.\n_forwardRenderPassDescriptor.imageblockSampleLength = _transparencyPipeline.imageblockSampleLength;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Set the tile size for the fragment shader.\n_forwardRenderPassDescriptor.tileWidth  = _optimalTileSize.width;\n_forwardRenderPassDescriptor.tileHeight = _optimalTileSize.height;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Initialize the image block's memory before rendering.\n[renderEncoder pushDebugGroup:@\"Init Image Block\"];\n[renderEncoder setRenderPipelineState:_initImageBlockPipeline];\n[renderEncoder dispatchThreadsPerTile:_optimalTileSize];\n[renderEncoder popDebugGroup];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Initializes an image block structure to sentinel values.\nkernel void initTransparentFragmentStore\n(\n    imageblock<TransparentFragmentValues, imageblock_layout_explicit> blockData,\n    ushort2 localThreadID[[thread_position_in_threadgroup]]\n)\n{\n    threadgroup_imageblock TransparentFragmentValues* fragmentValues = blockData.data(localThreadID);\n    for (short i = 0; i < kNumLayers; ++i)\n    {\n        fragmentValues->colors[i] = half4(0.0h);\n        fragmentValues->depths[i] = half(INFINITY);\n    }\n}",
      "language" : "metal"
    },
    {
      "code" : "renderPipelineDesc.colorAttachments[AAPLRenderTargetColor].writeMask = MTLColorWriteMaskNone;",
      "language" : "objective-c"
    },
    {
      "code" : "for (short i = 0; i < kNumLayers; ++i)\n{\n    half layerDepth = fragmentValues.depths[i];\n    half4 layerColor = fragmentValues.colors[i];\n\n    bool insert = (depth <= layerDepth);\n    fragmentValues.colors[i] = insert ? finalColor : layerColor;\n    fragmentValues.depths[i] = insert ? depth : layerDepth;\n\n    finalColor = insert ? layerColor : finalColor;\n    depth = insert ? layerDepth : depth;\n}\nout.values = fragmentValues;",
      "language" : "metal"
    },
    {
      "code" : "TransparentFragmentValues fragmentValues     [[imageblock_data]],\nhalf4                     forwardOpaqueColor [[color(AAPLRenderTargetColor), raster_order_group(0)]]",
      "language" : "metal"
    },
    {
      "code" : "out.xyz = forwardOpaqueColor.xyz;",
      "language" : "metal"
    },
    {
      "code" : "for (short i = kNumLayers - 1; i >= 0; --i)\n{\n    half4 layerColor = fragmentValues.colors[i];\n    out.xyz = layerColor.xyz + (1.0h - layerColor.w) * out.xyz;\n}",
      "language" : "metal"
    }
  ],
  "contentHash" : "f3c4147c14110f81acf937d17f9208aa62c42e477d5f4f938217566f1c03bc62",
  "crawledAt" : "2025-12-02T15:31:19Z",
  "id" : "1553DCCF-5FF0-4E5B-A930-2E60B0F7B36C",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\n\n\nIn order to draw a convincing transparency effect, apps typically draw a scene’s transparent, 3D geometry in depth order, from farthest to nearest, relative to the camera. These apps use the CPU to sort the geometry by depth before drawing, but this approach has some drawbacks in that it:\n\nOrder-independent transparency solves these issues by:\n\nThe sample takes advantage of *tile memory* available on Apple silicon GPUs to quickly evaluate the depth and color of each fragment. Tile memory is a fast, temporary storage that shaders can use to store and retrieve information to and from other shaders.\n\n### Configure the sample code project\n\nTo run this sample, you need Xcode 12 and a physical device including:\n\nThis sample can only run on a physical device because it uses the image block and tile shader features, which Simulator doesn’t support.\n\n### Check for support\n\nThe app checks that the device supports the features required to implement this order-independent transparency algorithm.\n\nThe techniques implemented by this sample require the image block and tile shader features, which are a part of the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLGPUFamily\/apple4] feature set. Although this app does run on devices that don’t support these features, it incorrectly blends transparent geometries.\n\n### Set up storage for transparent fragments\n\nThe sample uses tile memory to store data for multiple transparent layers. The `processTransparentFragment` shader draws the transparent geometry and populates the `TransparentFragmentStore` structure. This structure contains a single member, `fragmentValues`, which uses the `[[imageblock_data]]` attribute to specify that data for this element resides in tile memory.\n\nThe `TransparentFragmentValues` structure stores the color and depth values for each fragment generated by transparent triangles. Because the fragment shader writes this data to tile memory, each member needs to be part of a raster order group. Raster order groups allow precise control of the order of parallel fragment shader threads accessing the same pixel coordinates. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/tailor-your-apps-for-apple-gpus-and-tile-based-deferred-rendering].\n\nThe `kNumLayers` constant defines the maximum number of transparent layers the image block can store.\n\nIf the number of transparent layers for any pixel exceeds `kNumLayers`, the `processTransparentFragment` shader drops the excess values. The subsequent blending shader ignores those color values that yield a technically incorrect result. Despite this, even if `kNumLayers` isn’t large enough, this algorithm still produces a convincing result.\n\n### Reserve tile memory\n\nWhen the sample sets up a render pass, it partitions the tile memory between storage for the `TransparentFragmentValues` structure and render targets.\n\nOnce the sample builds a render pipeline using the `TransparentFragmentValues` structure, the pipeline’s `imageblockSampleLength` property specifies the amount of tile memory the pipeline requires. As the value of `kNumLayers` increases and the structure side increases, the value of `imageblockSampleLength` also increases.\n\nThe sample reserves memory in the render pass by setting the `imageblockSampleLength` property of `_forwardRenderPassDescriptor` to the pipeline’s `imageblockSampleLength `property. Once the sample builds a render pipeline using the `TransparentFragmentStore` structure, the pipeline’s `imageblockSampleLength` property specifies the amount of tile memory the pipeline requires. As the value of `kNumLayers` increases, the value of `imageblockSampleLength` also increases.\n\nThe sample chooses the tile size for the rasterized color and depth targets by setting the `tileWidth` and `tileHeight` properties of `_forwardRenderPassDescriptor`.\n\nIn general, a larger tile size yields better performance because the GPU incurs less overhead to render fewer tiles. However, the GPU uses tile memory for both rasterization data and image block data. You need to balance the dimensions chosen for the tile size with that of the value for `kNumLayers`. If these values exceed the amount of tile memory, the GPU can’t execute the tile shader in the render pass. In that case, creation of the render pass fails.\n\n### Initialize the image block\n\nThe sample begins each render pass by initializing the image block structure.\n\nThe `initTransparentFragmentStore` kernel writes zeros to each color value in the image block and `INFINITY` to each depth value.\n\n### Layer transparent geometry\n\nAfter the sample initializes the image block and renders opaque objects, it uses the `processTransparentFragments` shader to populate the layers of the `TransparentFragmentValues` structure. This fragment shader doesn’t actually render to any of the render pass attachments and only writes to the structure in the image block. Because it doesn’t write to an attachment, the pipeline disables writes to color attachments.\n\nThe shader inserts transparent fragment values in order of depth. It also discards fragment values with the farthest depth value when fragment values occupy all layers.\n\nEach index in the array represents a layer. The shader tests the depth value of the incoming fragment against the depth value of the fragment in the current layer. If the depth value is less than the fragment in the current layer, the shader sets `insert` to `true`. When `insert` is `true`, the shader swaps the fragment values in the current layer with the tested fragment’s values. The values replaced become the new fragment values, which the shader tests in the next iteration of the loop. When the array fills, the shader discards the fragments with the farthest depth.\n\nThe following diagram shows an example of a shader populating layers of the image block as the app renders three transparent triangles.\n\n\n\nIn this example, the app first renders a green triangle whose fragments populate the first layer in the image block. It then renders an orange triangle with depth values less than the green triangle. The shader replaces any fragments covering the green triangle with the orange color and moves the fragments from the green triangle to the next layer. Finally, the app renders a blue triangle whose depth is in between the orange triangle and the green triangle. The shader replaces all the values of the green triangle in the second layer and moves them to the third. This results in an image block with fragments ordered by their depth values.\n\n### Blend fragments for transparency\n\nAfter the app layers all transparent geometry, the image block contains a list of fragment colors ordered by depth for every transparent fragment.\n\nThe app executes the `blendFragments` shader by drawing a full screen quad. This shader takes the current values in the color buffer populated by the `processOpaqueFragments` shader. It also takes the image block data populated by the `processTransparentFragments` shader.\n\nThe shader calculates the output color starting with the opaque value in the color attachment.\n\nIt iterates through each layer in the image block structure, accumulating their color values.\n\nThe resulting value is a mix of the transparent and opaque colors blended in order of their depth values.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/implementing-order-independent-transparency-with-image-blocks\ncrawled: 2025-12-02T15:31:19Z\n---\n\n# Implementing order-independent transparency with image blocks\n\n**Sample Code**\n\nDraw overlapping, transparent surfaces in any order by using tile shaders and image blocks.\n\n## Overview\n\n\n\nIn order to draw a convincing transparency effect, apps typically draw a scene’s transparent, 3D geometry in depth order, from farthest to nearest, relative to the camera. These apps use the CPU to sort the geometry by depth before drawing, but this approach has some drawbacks in that it:\n\n- Can produce incorrect results when two meshes intersect\n- Requires the app to recalculate the depth of each mesh with the CPU each time the camera or objects move within the scene\n\nOrder-independent transparency solves these issues by:\n\n- Eliminating the need to sort meshes\n- Moving the computation workload to the GPU\n- Evaluating the geometry’s depth on a per-fragment basis\n\nThe sample takes advantage of *tile memory* available on Apple silicon GPUs to quickly evaluate the depth and color of each fragment. Tile memory is a fast, temporary storage that shaders can use to store and retrieve information to and from other shaders.\n\n### Configure the sample code project\n\nTo run this sample, you need Xcode 12 and a physical device including:\n\n- A Mac with Apple silicon running macOS 12 or later\n- An iOS device with an A11 Bionic chip or later running iOS 15 or later\n\nThis sample can only run on a physical device because it uses the image block and tile shader features, which Simulator doesn’t support.\n\n### Check for support\n\nThe app checks that the device supports the features required to implement this order-independent transparency algorithm.\n\n```objective-c\n\/\/ Check that this GPU supports raster order groups.\n_supportsOrderIndependentTransparency = [_device supportsFamily:MTLGPUFamilyApple4];\n```\n\nThe techniques implemented by this sample require the image block and tile shader features, which are a part of the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLGPUFamily\/apple4] feature set. Although this app does run on devices that don’t support these features, it incorrectly blends transparent geometries.\n\n### Set up storage for transparent fragments\n\nThe sample uses tile memory to store data for multiple transparent layers. The `processTransparentFragment` shader draws the transparent geometry and populates the `TransparentFragmentStore` structure. This structure contains a single member, `fragmentValues`, which uses the `[[imageblock_data]]` attribute to specify that data for this element resides in tile memory.\n\n```metal\nstruct TransparentFragmentStore\n{\n    TransparentFragmentValues values [[imageblock_data]];\n};\n```\n\nThe `TransparentFragmentValues` structure stores the color and depth values for each fragment generated by transparent triangles. Because the fragment shader writes this data to tile memory, each member needs to be part of a raster order group. Raster order groups allow precise control of the order of parallel fragment shader threads accessing the same pixel coordinates. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/tailor-your-apps-for-apple-gpus-and-tile-based-deferred-rendering].\n\n```metal\nstruct TransparentFragmentValues\n{\n    \/\/ Store the color of the transparent fragment.\n    \/\/ Use a packed data type to reduce the size of the explicit ImageBlock.\n    rgba8unorm<half4> colors [[raster_order_group(0)]] [kNumLayers];\n\n    \/\/ An array of transparent fragment distances from the camera.\n    half depths              [[raster_order_group(0)]] [kNumLayers];\n};\n```\n\nThe `kNumLayers` constant defines the maximum number of transparent layers the image block can store.\n\n```metal\n\/\/\/ The number of transparent geometry layers that the app stores in image block memory.\n\/\/\/ Each layer consumes tile memory and increases the value of the pipeline's `imageBlockSampleLength` property.\nstatic constexpr constant short kNumLayers = 4;\n```\n\nIf the number of transparent layers for any pixel exceeds `kNumLayers`, the `processTransparentFragment` shader drops the excess values. The subsequent blending shader ignores those color values that yield a technically incorrect result. Despite this, even if `kNumLayers` isn’t large enough, this algorithm still produces a convincing result.\n\n### Reserve tile memory\n\nWhen the sample sets up a render pass, it partitions the tile memory between storage for the `TransparentFragmentValues` structure and render targets.\n\nOnce the sample builds a render pipeline using the `TransparentFragmentValues` structure, the pipeline’s `imageblockSampleLength` property specifies the amount of tile memory the pipeline requires. As the value of `kNumLayers` increases and the structure side increases, the value of `imageblockSampleLength` also increases.\n\nThe sample reserves memory in the render pass by setting the `imageblockSampleLength` property of `_forwardRenderPassDescriptor` to the pipeline’s `imageblockSampleLength `property. Once the sample builds a render pipeline using the `TransparentFragmentStore` structure, the pipeline’s `imageblockSampleLength` property specifies the amount of tile memory the pipeline requires. As the value of `kNumLayers` increases, the value of `imageblockSampleLength` also increases.\n\n```objective-c\n\/\/ Set the image block's memory size.\n_forwardRenderPassDescriptor.imageblockSampleLength = _transparencyPipeline.imageblockSampleLength;\n```\n\nThe sample chooses the tile size for the rasterized color and depth targets by setting the `tileWidth` and `tileHeight` properties of `_forwardRenderPassDescriptor`.\n\n```objective-c\n\/\/ Set the tile size for the fragment shader.\n_forwardRenderPassDescriptor.tileWidth  = _optimalTileSize.width;\n_forwardRenderPassDescriptor.tileHeight = _optimalTileSize.height;\n```\n\nIn general, a larger tile size yields better performance because the GPU incurs less overhead to render fewer tiles. However, the GPU uses tile memory for both rasterization data and image block data. You need to balance the dimensions chosen for the tile size with that of the value for `kNumLayers`. If these values exceed the amount of tile memory, the GPU can’t execute the tile shader in the render pass. In that case, creation of the render pass fails.\n\n### Initialize the image block\n\nThe sample begins each render pass by initializing the image block structure.\n\n```objective-c\n\/\/ Initialize the image block's memory before rendering.\n[renderEncoder pushDebugGroup:@\"Init Image Block\"];\n[renderEncoder setRenderPipelineState:_initImageBlockPipeline];\n[renderEncoder dispatchThreadsPerTile:_optimalTileSize];\n[renderEncoder popDebugGroup];\n```\n\nThe `initTransparentFragmentStore` kernel writes zeros to each color value in the image block and `INFINITY` to each depth value.\n\n```metal\n\/\/\/ Initializes an image block structure to sentinel values.\nkernel void initTransparentFragmentStore\n(\n    imageblock<TransparentFragmentValues, imageblock_layout_explicit> blockData,\n    ushort2 localThreadID[[thread_position_in_threadgroup]]\n)\n{\n    threadgroup_imageblock TransparentFragmentValues* fragmentValues = blockData.data(localThreadID);\n    for (short i = 0; i < kNumLayers; ++i)\n    {\n        fragmentValues->colors[i] = half4(0.0h);\n        fragmentValues->depths[i] = half(INFINITY);\n    }\n}\n```\n\n### Layer transparent geometry\n\nAfter the sample initializes the image block and renders opaque objects, it uses the `processTransparentFragments` shader to populate the layers of the `TransparentFragmentValues` structure. This fragment shader doesn’t actually render to any of the render pass attachments and only writes to the structure in the image block. Because it doesn’t write to an attachment, the pipeline disables writes to color attachments.\n\n```objective-c\nrenderPipelineDesc.colorAttachments[AAPLRenderTargetColor].writeMask = MTLColorWriteMaskNone;\n```\n\nThe shader inserts transparent fragment values in order of depth. It also discards fragment values with the farthest depth value when fragment values occupy all layers.\n\n```metal\nfor (short i = 0; i < kNumLayers; ++i)\n{\n    half layerDepth = fragmentValues.depths[i];\n    half4 layerColor = fragmentValues.colors[i];\n\n    bool insert = (depth <= layerDepth);\n    fragmentValues.colors[i] = insert ? finalColor : layerColor;\n    fragmentValues.depths[i] = insert ? depth : layerDepth;\n\n    finalColor = insert ? layerColor : finalColor;\n    depth = insert ? layerDepth : depth;\n}\nout.values = fragmentValues;\n```\n\nEach index in the array represents a layer. The shader tests the depth value of the incoming fragment against the depth value of the fragment in the current layer. If the depth value is less than the fragment in the current layer, the shader sets `insert` to `true`. When `insert` is `true`, the shader swaps the fragment values in the current layer with the tested fragment’s values. The values replaced become the new fragment values, which the shader tests in the next iteration of the loop. When the array fills, the shader discards the fragments with the farthest depth.\n\nThe following diagram shows an example of a shader populating layers of the image block as the app renders three transparent triangles.\n\n\n\nIn this example, the app first renders a green triangle whose fragments populate the first layer in the image block. It then renders an orange triangle with depth values less than the green triangle. The shader replaces any fragments covering the green triangle with the orange color and moves the fragments from the green triangle to the next layer. Finally, the app renders a blue triangle whose depth is in between the orange triangle and the green triangle. The shader replaces all the values of the green triangle in the second layer and moves them to the third. This results in an image block with fragments ordered by their depth values.\n\n### Blend fragments for transparency\n\nAfter the app layers all transparent geometry, the image block contains a list of fragment colors ordered by depth for every transparent fragment.\n\nThe app executes the `blendFragments` shader by drawing a full screen quad. This shader takes the current values in the color buffer populated by the `processOpaqueFragments` shader. It also takes the image block data populated by the `processTransparentFragments` shader.\n\n```metal\nTransparentFragmentValues fragmentValues     [[imageblock_data]],\nhalf4                     forwardOpaqueColor [[color(AAPLRenderTargetColor), raster_order_group(0)]]\n```\n\nThe shader calculates the output color starting with the opaque value in the color attachment.\n\n```metal\nout.xyz = forwardOpaqueColor.xyz;\n```\n\nIt iterates through each layer in the image block structure, accumulating their color values.\n\n```metal\nfor (short i = kNumLayers - 1; i >= 0; --i)\n{\n    half4 layerColor = fragmentValues.colors[i];\n    out.xyz = layerColor.xyz + (1.0h - layerColor.w) * out.xyz;\n}\n```\n\nThe resulting value is a mix of the transparent and opaque colors blended in order of their depth values.\n\n## Render workflows\n\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Selecting device objects for graphics rendering**: Switch dynamically between multiple GPUs to efficiently render to a display.\n- **Customizing render pass setup**: Render into an offscreen texture by creating a custom render pass.\n- **Creating a custom Metal view**: Implement a lightweight view for Metal rendering that’s customized to your app’s needs.\n- **Calculating primitive visibility using depth testing**: Determine which pixels are visible in a scene by using a depth texture.\n- **Encoding indirect command buffers on the CPU**: Reduce CPU overhead and simplify your command execution by reusing commands.\n- **Loading textures and models using Metal fast resource loading**: Stream texture and buffer data directly from disk into Metal resources using fast resource loading.\n- **Adjusting the level of detail using Metal mesh shaders**: Choose and render meshes with several levels of detail using object and mesh shaders.\n- **Creating a 3D application with hydra rendering**: Build a 3D application that integrates with Hydra and USD.\n- **Culling occluded geometry using the visibility result buffer**: Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.\n- **Improving edge-rendering quality with multisample antialiasing (MSAA)**: Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.\n- **Achieving smooth frame rates with a Metal display link**: Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        },
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Switch dynamically between multiple GPUs to efficiently render to a display.",
          "name" : "Selecting device objects for graphics rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-graphics-rendering"
        },
        {
          "description" : "Render into an offscreen texture by creating a custom render pass.",
          "name" : "Customizing render pass setup",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup"
        },
        {
          "description" : "Implement a lightweight view for Metal rendering that’s customized to your app’s needs.",
          "name" : "Creating a custom Metal view",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-custom-metal-view"
        },
        {
          "description" : "Determine which pixels are visible in a scene by using a depth texture.",
          "name" : "Calculating primitive visibility using depth testing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/calculating-primitive-visibility-using-depth-testing"
        },
        {
          "description" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "name" : "Encoding indirect command buffers on the CPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
        },
        {
          "description" : "Stream texture and buffer data directly from disk into Metal resources using fast resource loading.",
          "name" : "Loading textures and models using Metal fast resource loading",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/loading-textures-and-models-using-metal-fast-resource-loading"
        },
        {
          "description" : "Choose and render meshes with several levels of detail using object and mesh shaders.",
          "name" : "Adjusting the level of detail using Metal mesh shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/adjusting-the-level-of-detail-using-metal-mesh-shaders"
        },
        {
          "description" : "Build a 3D application that integrates with Hydra and USD.",
          "name" : "Creating a 3D application with hydra rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-3d-application-with-hydra-rendering"
        },
        {
          "description" : "Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.",
          "name" : "Culling occluded geometry using the visibility result buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/culling-occluded-geometry-using-the-visibility-result-buffer"
        },
        {
          "description" : "Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.",
          "name" : "Improving edge-rendering quality with multisample antialiasing (MSAA)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-edge-rendering-quality-with-multisample-antialiasing-msaa"
        },
        {
          "description" : "Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.",
          "name" : "Achieving smooth frame rates with a Metal display link",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/achieving-smooth-frame-rates-with-a-metal-display-link"
        }
      ],
      "title" : "Render workflows"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing order-independent transparency with image blocks",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-order-independent-transparency-with-image-blocks"
}