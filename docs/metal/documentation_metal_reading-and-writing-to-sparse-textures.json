{
  "abstract" : "Decide how to handle access to unmapped texture regions.",
  "codeExamples" : [
    {
      "code" : "fragment float4 fragmentShader(\n    ColorInOut in [[stage_in]],\n    constant Uniforms & uniforms  [[ buffer(BufferIndexUniforms) ]],\n    texture2d<float> colorMap  [[ texture(TextureIndexColor) ]],\n    constant float & firstTailMip  [[ buffer(BufferIndexMipmap) ]])\n{\n    constexpr sampler colorSampler(mip_filter::linear,\n                                   mag_filter::linear,\n                                   min_filter::linear);\n\n    sparse_color<float4> sparseSample = colorMap.sparse_sample(colorSampler, in.texCoord.xy);\n\n    if (sparseSample.resident())\n    {\n        return sparseSample.value();\n    }\n    else\n    {\n        return colorMap.sample(colorSampler,\n                               in.texCoord.xy,\n                               min_lod_clamp(firstTailMip));\n    }\n}",
      "language" : "metal"
    }
  ],
  "contentHash" : "029e7bea4306545fe2853f4a046b89eb1e86e26d2ef02c0d4456ee5c92900b52",
  "crawledAt" : "2025-12-04T02:20:13Z",
  "id" : "127B5599-6574-439A-8E18-1F5365E67F50",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nYou don’t need to rewrite your shaders to work with sparse textures. You can treat sparse textures just like any other textures. However, they work differently if you access an unmapped region in the texture:\n\nIf this default behavior is insufficient for your app, update your shaders to handle memory operations to unmapped regions.\n\n### Test for unmapped regions in your shader\n\nWhen you sample a texture, you can explicitly test to see whether that action accessed an unmapped region. Instead of calling the `sample` method, call `sparse_sample`. The `sparse_sample` methods return a `sparse_color<T>` object, which provides methods you can call to determine whether you sampled a mapped region in the texture, and to get the sampled data.\n\nThe following example code uses the `sparse_sample` method to implement a fallback mechanism. The texture being sampled always has the mipmap tail mapped into memory. One of the shader arguments specifies the first mipmap in the tail. The fragment shader performs the following steps:\n\nFor more information about the other methods for sampling or reading from sparse textures, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Metal\/Reference\/MetalShadingLanguageGuide\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40014364] and [doc:\/\/com.apple.metal\/documentation\/Metal\/restricting-access-to-specific-mipmaps].\n\n### Track residency information\n\nA more advanced way to create fallback behavior is to track residency information in a *residency map*. A residency map is another texture with a pixel for every tile region in your main texture. You use a residency map to maintain per-tile information about your texture.\n\nFor example, you might use a residency map to determine whether a region is currently mapped. Remember that the GPU maps and unmaps sparse tiles, and this happens asynchronously. Further, if the heap runs out of memory, the GPU doesn’t return an error. If you need to know whether a region was successfully mapped, use a residency map to store this information. Execute a shader that samples one pixel (using `sparse_sample`) from each region. Determine whether the sample was resident and write the result into the residency map. Once the map data is complete, you can sample the texture or copy it to a buffer that your app can access.\n\nAnother way to use a residency map is to store the best level of detail that you’ve mapped for each region in your texture. If you attempt to sample the texture and the requested region isn’t mapped, instead of sampling the tail mipmaps, you can look up the best level of detail that is mapped and sample the texture again.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/reading-and-writing-to-sparse-textures\ncrawled: 2025-12-04T02:20:13Z\n---\n\n# Reading and writing to sparse textures\n\n**Article**\n\nDecide how to handle access to unmapped texture regions.\n\n## Overview\n\nYou don’t need to rewrite your shaders to work with sparse textures. You can treat sparse textures just like any other textures. However, they work differently if you access an unmapped region in the texture:\n\n- If you read or sample from an unmapped region, Metal returns a vector of zero values to your shader.\n- If you write to an unmapped region, Metal discards the write value.\n\nIf this default behavior is insufficient for your app, update your shaders to handle memory operations to unmapped regions.\n\n### Test for unmapped regions in your shader\n\nWhen you sample a texture, you can explicitly test to see whether that action accessed an unmapped region. Instead of calling the `sample` method, call `sparse_sample`. The `sparse_sample` methods return a `sparse_color<T>` object, which provides methods you can call to determine whether you sampled a mapped region in the texture, and to get the sampled data.\n\nThe following example code uses the `sparse_sample` method to implement a fallback mechanism. The texture being sampled always has the mipmap tail mapped into memory. One of the shader arguments specifies the first mipmap in the tail. The fragment shader performs the following steps:\n\n1. It samples the texture by calling the `sparse_sample` method.\n2. If the sampler read data from a mapped region, the fragment shader returns the sampled value.\n3. If the sampler accessed an unmapped region, the shader samples the texture again using the `min_lod_clamp` modifier to restrict access to the mapped part of the texture. Because this part of the mipmap chain is always mapped, the second request uses the regular `sample` method.\n\n```metal\nfragment float4 fragmentShader(\n    ColorInOut in [[stage_in]],\n    constant Uniforms & uniforms  [[ buffer(BufferIndexUniforms) ]],\n    texture2d<float> colorMap  [[ texture(TextureIndexColor) ]],\n    constant float & firstTailMip  [[ buffer(BufferIndexMipmap) ]])\n{\n    constexpr sampler colorSampler(mip_filter::linear,\n                                   mag_filter::linear,\n                                   min_filter::linear);\n\n    sparse_color<float4> sparseSample = colorMap.sparse_sample(colorSampler, in.texCoord.xy);\n\n    if (sparseSample.resident())\n    {\n        return sparseSample.value();\n    }\n    else\n    {\n        return colorMap.sample(colorSampler,\n                               in.texCoord.xy,\n                               min_lod_clamp(firstTailMip));\n    }\n}\n```\n\nFor more information about the other methods for sampling or reading from sparse textures, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Metal\/Reference\/MetalShadingLanguageGuide\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40014364] and [doc:\/\/com.apple.metal\/documentation\/Metal\/restricting-access-to-specific-mipmaps].\n\n### Track residency information\n\nA more advanced way to create fallback behavior is to track residency information in a *residency map*. A residency map is another texture with a pixel for every tile region in your main texture. You use a residency map to maintain per-tile information about your texture.\n\nFor example, you might use a residency map to determine whether a region is currently mapped. Remember that the GPU maps and unmaps sparse tiles, and this happens asynchronously. Further, if the heap runs out of memory, the GPU doesn’t return an error. If you need to know whether a region was successfully mapped, use a residency map to store this information. Execute a shader that samples one pixel (using `sparse_sample`) from each region. Determine whether the sample was resident and write the result into the residency map. Once the map data is complete, you can sample the texture or copy it to a buffer that your app can access.\n\nAnother way to use a residency map is to store the best level of detail that you’ve mapped for each region in your texture. If you attempt to sample the texture and the requested region isn’t mapped, instead of sampling the tail mipmaps, you can look up the best level of detail that is mapped and sample the texture again.\n\n## Sparse textures\n\n- **Managing sparse texture memory**: Take direct control of memory allocation for texture data by using sparse textures.\n- **Creating sparse heaps and sparse textures**: Allocate memory for sparse textures by creating a sparse heap.\n- **Converting between pixel regions and sparse tile regions**: Learn how a sparse texture’s contents are organized in memory.\n- **Assigning memory to sparse textures**: Use a resource state encoder to allocate and deallocate sparse tiles for a sparse texture.\n- **Estimating how often a texture region is accessed**: Use texture access patterns to determine when you need to map a texture region.\n- **MTLResourceStatePassDescriptor**: A configuration for a resource state pass, used to create a resource state command encoder.\n- **MTLResourceStatePassSampleBufferAttachmentDescriptor**: A description of where to store GPU counter information at the start and end of a resource state pass.\n- **MTLResourceStatePassSampleBufferAttachmentDescriptorArray**: An array of sample buffer attachments for a resource state pass.\n- **MTLResourceStateCommandEncoder**: An encoder that encodes commands that modify resource configurations.\n- **MTLMapIndirectArguments**: The data layout for mapping sparse texture regions when using indirect commands.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Take direct control of memory allocation for texture data by using sparse textures.",
          "name" : "Managing sparse texture memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-sparse-texture-memory"
        },
        {
          "description" : "Allocate memory for sparse textures by creating a sparse heap.",
          "name" : "Creating sparse heaps and sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-sparse-heaps-and-sparse-textures"
        },
        {
          "description" : "Learn how a sparse texture’s contents are organized in memory.",
          "name" : "Converting between pixel regions and sparse tile regions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/converting-between-pixel-regions-and-sparse-tile-regions"
        },
        {
          "description" : "Use a resource state encoder to allocate and deallocate sparse tiles for a sparse texture.",
          "name" : "Assigning memory to sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/assigning-memory-to-sparse-textures"
        },
        {
          "description" : "Use texture access patterns to determine when you need to map a texture region.",
          "name" : "Estimating how often a texture region is accessed",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/estimating-how-often-a-texture-region-is-accessed"
        },
        {
          "description" : "A configuration for a resource state pass, used to create a resource state command encoder.",
          "name" : "MTLResourceStatePassDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassDescriptor"
        },
        {
          "description" : "A description of where to store GPU counter information at the start and end of a resource state pass.",
          "name" : "MTLResourceStatePassSampleBufferAttachmentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassSampleBufferAttachmentDescriptor"
        },
        {
          "description" : "An array of sample buffer attachments for a resource state pass.",
          "name" : "MTLResourceStatePassSampleBufferAttachmentDescriptorArray",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassSampleBufferAttachmentDescriptorArray"
        },
        {
          "description" : "An encoder that encodes commands that modify resource configurations.",
          "name" : "MTLResourceStateCommandEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStateCommandEncoder"
        },
        {
          "description" : "The data layout for mapping sparse texture regions when using indirect commands.",
          "name" : "MTLMapIndirectArguments",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLMapIndirectArguments"
        }
      ],
      "title" : "Sparse textures"
    }
  ],
  "source" : "appleJSON",
  "title" : "Reading and writing to sparse textures",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/reading-and-writing-to-sparse-textures"
}