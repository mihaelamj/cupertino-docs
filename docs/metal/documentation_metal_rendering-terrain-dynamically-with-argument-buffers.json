{
  "abstract" : "Use argument buffers to render terrain in real time with a GPU-driven pipeline.",
  "codeExamples" : [
    {
      "code" : "_targetHeightmap = CreateTextureWithDevice (device, @\"Textures\/TerrainHeightMap.png\", false, false);",
      "language" : "objective-c"
    },
    {
      "code" : "static void EvaluateTerrainAtLocation(float2 uv,\n                                      float3 worldPosition,\n                                      texture2d<float> heightMap,\n                                      texture2d<float> normalMap,\n                                      texture2d<float> propertiesMap,\n                                      constant const TerrainParams& terrainParams,\n                                      thread float outHabitat[TerrainHabitatTypeCOUNT],\n                                      thread float3 &outNormal)",
      "language" : "metal"
    },
    {
      "code" : "struct TerrainHabitat\n{\n#ifndef __METAL_VERSION__\n    \/\/ This struct should not be instantiated in C++ because it contains textures that aren't visible on the CPU\nprivate:\n    TerrainHabitat ();\npublic:\n#endif\n\n    float slopeStrength      IAB_INDEX(TerrainHabitat_MemberIds::slopeStrength);\n    float slopeThreshold     IAB_INDEX(TerrainHabitat_MemberIds::slopeThreshold);\n    float elevationStrength  IAB_INDEX(TerrainHabitat_MemberIds::elevationStrength);\n    float elevationThreshold IAB_INDEX(TerrainHabitat_MemberIds::elevationThreshold);\n    float specularPower      IAB_INDEX(TerrainHabitat_MemberIds::specularPower);\n    float textureScale       IAB_INDEX(TerrainHabitat_MemberIds::textureScale);\n    bool  flipNormal         IAB_INDEX(TerrainHabitat_MemberIds::flipNormal);\n\n    struct ParticleProperties\n    {\n        \/\/ The fields of this struct need to be reflected in TerrainHabitat_MemberIds\n        simd::float4    keyTimePoints;\n        simd::float4    scaleFactors;\n        simd::float4    alphaFactors;\n        simd::float4    gravity;\n        simd::float4    lightingCoefficients;\n        int             doesCollide;\n        int             doesRotate;\n        int             castShadows;\n        int             distanceDependent;\n    } particleProperties;\n\n#ifdef __METAL_VERSION__\n    texture2d_array <float,access::sample> diffSpecTextureArray IAB_INDEX(TerrainHabitat_MemberIds::diffSpecTextureArray);\n    texture2d_array <float,access::sample> normalTextureArray   IAB_INDEX(TerrainHabitat_MemberIds::normalTextureArray);\n#endif\n};",
      "language" : "objective-c"
    },
    {
      "code" : "struct TerrainParams\n{\n    TerrainHabitat habitats [TerrainHabitatTypeCOUNT];\n    float ambientOcclusionScale    IAB_INDEX(TerrainParams_MemberIds::ambientOcclusionScale);\n    float ambientOcclusionContrast IAB_INDEX(TerrainParams_MemberIds::ambientOcclusionContrast);\n    float ambientLightScale        IAB_INDEX(TerrainParams_MemberIds::ambientLightScale);\n    float atmosphereScale          IAB_INDEX(TerrainParams_MemberIds::atmosphereScale);\n};",
      "language" : "objective-c"
    },
    {
      "code" : "for (int i = 0; i < _terrainTextures.size(); i++)\n{\n    [renderEncoder useResource: _terrainTextures[i].diffSpecTextureArray\n                         usage: MTLResourceUsageSample | MTLResourceUsageRead];\n    [renderEncoder useResource: _terrainTextures[i].normalTextureArray\n                         usage: MTLResourceUsageSample | MTLResourceUsageRead];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder setFragmentBuffer:_terrainParamsBuffer offset:0 atIndex:_iabBufferIndex_PplTerrainMainView];",
      "language" : "objective-c"
    },
    {
      "code" : "fragment GBufferFragOut terrain_fragment(const TerrainVertexOut in [[stage_in]],\n                                         constant TerrainParams & mat [[buffer(1)]],\n                                         constant AAPLUniforms& globalUniforms [[buffer(2)]],\n                                         texture2d<float> heightMap [[texture(0)]],\n                                         texture2d<float> normalMap [[texture(1)]],\n                                         texture2d<float> propertiesMap [[texture(2)]])",
      "language" : "metal"
    },
    {
      "code" : "BrdfProperties curSubLayerBrdf = sample_brdf(\n                                             mat.habitats [curLayerIdx].diffSpecTextureArray,\n                                             mat.habitats [curLayerIdx].normalTextureArray,\n                                             curSubLayerIdx,\n                                             mat.habitats [curLayerIdx].textureScale,\n                                             mat.habitats [curLayerIdx].specularPower,\n                                             mat.habitats [curLayerIdx].flipNormal,\n                                             in.worldPosition,\n                                             normal,\n                                             tangent,\n                                             bitangent);",
      "language" : "metal"
    },
    {
      "code" : "[computeEncoder setBuffer:terrain.terrainParamsBuffer offset:0 atIndex:3];",
      "language" : "objective-c"
    },
    {
      "code" : "EvaluateTerrainAtLocation(uv_pos, world_pos, heightMap,\n                          normalMap, propertiesMap, terrainParams,\n                          habitatPercentages,\n                          worldNormal);",
      "language" : "metal"
    },
    {
      "code" : "pop_idx = rules[rule_index].populationStartIndex + uint((s \/ rules[rule_index].densityInHabitat * float(rules[rule_index].populationIndexCount)));",
      "language" : "metal"
    },
    {
      "code" : "vegetationSpawnInstance(pop_idx, world_matrix, float4(world_pos, radius), globalUniforms, instances, indirect);",
      "language" : "metal"
    },
    {
      "code" : "[enc setBuffer:[terrain terrainParamsBuffer] offset:0 atIndex:14];",
      "language" : "objective-c"
    },
    {
      "code" : "EvaluateTerrainAtLocation(mouseUvPos, mouseWorldPos, heightMap,\n                          normalMap, propsMap, terrainParams,\n                          habitatPercentages,\n                          worldNormal);",
      "language" : "metal"
    },
    {
      "code" : "float highestLevel = 0.f;\nfor (uint i = 0; i < TerrainHabitatTypeCOUNT; i++)\n{\n    if (habitatPercentages [i] > highestLevel)\n    {\n        highestLevel = habitatPercentages [i];\n        habitatIndex = i;\n    }\n}",
      "language" : "metal"
    },
    {
      "code" : "ParticleData data;\ndata.habitatIndex = habitatIndex;\ndata.texture = terrainParams.habitats [habitatIndex].diffSpecTextureArray;",
      "language" : "metal"
    }
  ],
  "contentHash" : "fe201524a768ee383fa2ea6212c009046e9f2ed529061a4766974111d5f97e40",
  "crawledAt" : "2025-12-02T19:37:42Z",
  "id" : "F169EB59-35BC-489E-BCB5-8C46AC7790BB",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nThis sample demonstrates dynamic terrain generation on an outdoor landscape, using argument buffers to select terrain materials, vegetation geometry, and particle effects within a GPU-driven pipeline. The sample creates a landscape with visually distinct areas, called habitats, that differ based on the land’s elevation. These are the habitats in the sample, ordered from highest to lowest elevation:\n\n\n\n### Getting started\n\nThe Xcode project contains schemes for running the sample in macOS and iOS. Metal isn’t supported in the iOS Simulator, so the iOS scheme requires a physical device that supports GPU family 4 to run the sample. The default scheme is macOS, which runs the sample as is on your Mac.\n\nIn macOS, use these controls to navigate the scene:\n\nIn iOS, use these controls to navigate the scene:\n\n### Respond to landscape alterations\n\nThe app determines the landscape’s initial topology from a static height map, `TerrainHeightMap.png`.\n\nAt runtime, as you alter the landscape with the provided controls, the sample evaluates the latest topology to determine whether it should apply a new habitat to the land based on its new elevation. If so, the sample updates the argument buffer corresponding to the land with the correct materials and vegetation geometry for the new habitat. The sample renders this new habitat by passing the land elevation value to the `EvaluateTerrainAtLocation` function.\n\n### Define an argument buffer for terrain habitats\n\nThe sample defines a custom argument buffer structure, `TerrainHabitat`, that defines the elements of a terrain habitat.\n\nAmong these elements, `elevationStrength` and `elevationThreshold` determine the elevation range in which the habitat is active. Additionally, `diffSpecTextureArray` and `normalTextureArray` determine the textures used to render the habitat.\n\nThe app nests `TerrainHabitat` within another argument buffer, `TerrainParams`, that provides many slight visual variations for added realism.\n\n`TerrainHabitat` is the specific argument buffer definition for a terrain habitat. However, because the app nests its definition within `TerrainParams`, the app sends the `TerrainParams` objects to the GPU pipeline.\n\n### Render terrain\n\nThe sample provides the GPU with the textures corresponding to various habitats. First, the sample calls the `useResource:usage:` method to indicate which textures the GPU uses.\n\nThen, the sample calls the `setFragmentBuffer:offset:atIndex:` method to set the argument buffer, `terrainParamsBuffer`, that contains those textures.\n\nThe sample accesses the argument buffer in the fragment function, `terrain_fragment`, to output the correct material for the terrain. First, the sample passes the `mat` parameter into the fragment function.\n\nThen, the sample passes the current land elevation into the `EvaluateTerrainAtLocation` function, where the fragment samples the texture corresponding to that elevation.\n\n### Render vegetation\n\nThe sample passes the `terrainParamsBuffer` argument buffer to the vegetation render pass through an instance of `AAPLTerrainRenderer`. This data determines which type of vegetation to render at a given location. First, the sample calls the `setBuffer:offset:atIndex:` method to set the argument buffer for the vegetation render pass.\n\nThen, the sample passes the argument buffer into the `EvaluateTerrainAtLocation` function, which produces a `habitatPercentages` value.\n\nThe habitat percentages are processed to select a specific index into the vegetation geometries, determined by the value of `pop_idx`.\n\nFinally, the sample uses this population index to render an instance of a particular vegetation geometry onto the landscape.\n\n### Render particles\n\nThe sample passes the `terrainParamsBuffer` argument buffer to the particle render pass through an instance of `AAPLTerrainRenderer`. This data determines which type of particles to render at a given location. First, the sample calls the `setBuffer:offset:atIndex:` method to set the argument buffer for the particle render pass.\n\nThen, the sample checks the relative percentages of habitat coverage in the altered landscape with the `EvaluateTerrainAtLocation` function, where the sample passes the 3D position of the particle.\n\nThe sample chooses the appropriate habitat by selecting the terrain with the highest percentage of habitat coverage.\n\nFinally, the app retrieves the particle’s corresponding habitat material from the argument buffer and sets it to the new particle.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/metal\/rendering-terrain-dynamically-with-argument-buffers\ncrawled: 2025-12-02T19:37:42Z\n---\n\n# Rendering terrain dynamically with argument buffers\n\n**Sample Code**\n\nUse argument buffers to render terrain in real time with a GPU-driven pipeline.\n\n## Overview\n\nThis sample demonstrates dynamic terrain generation on an outdoor landscape, using argument buffers to select terrain materials, vegetation geometry, and particle effects within a GPU-driven pipeline. The sample creates a landscape with visually distinct areas, called habitats, that differ based on the land’s elevation. These are the habitats in the sample, ordered from highest to lowest elevation:\n\n- Snow\n- Rock\n- Grass\n- Sand\n\n\n\n\n\n### Getting started\n\nThe Xcode project contains schemes for running the sample in macOS and iOS. Metal isn’t supported in the iOS Simulator, so the iOS scheme requires a physical device that supports GPU family 4 to run the sample. The default scheme is macOS, which runs the sample as is on your Mac.\n\nIn macOS, use these controls to navigate the scene:\n\n- **W, S, A, and D keys.** Move the camera body.\n- **Arrow keys.** Move the camera view.\n- **Mouse or trackpad drag.** Move the camera view.\n- **Mouse or trackpad primary click.** Raise the terrain.\n- **Mouse or trackpad secondary click.** Lower the terrain.\n\nIn iOS, use these controls to navigate the scene:\n\n- **Pan gesture.** Move the camera view.\n- **`modify terrain` button.** Cycle through a predefined terrain manipulation sequence.\n\n\n\n### Respond to landscape alterations\n\nThe app determines the landscape’s initial topology from a static height map, `TerrainHeightMap.png`.\n\n```objective-c\n_targetHeightmap = CreateTextureWithDevice (device, @\"Textures\/TerrainHeightMap.png\", false, false);\n```\n\nAt runtime, as you alter the landscape with the provided controls, the sample evaluates the latest topology to determine whether it should apply a new habitat to the land based on its new elevation. If so, the sample updates the argument buffer corresponding to the land with the correct materials and vegetation geometry for the new habitat. The sample renders this new habitat by passing the land elevation value to the `EvaluateTerrainAtLocation` function.\n\n```metal\nstatic void EvaluateTerrainAtLocation(float2 uv,\n                                      float3 worldPosition,\n                                      texture2d<float> heightMap,\n                                      texture2d<float> normalMap,\n                                      texture2d<float> propertiesMap,\n                                      constant const TerrainParams& terrainParams,\n                                      thread float outHabitat[TerrainHabitatTypeCOUNT],\n                                      thread float3 &outNormal)\n```\n\n### Define an argument buffer for terrain habitats\n\nThe sample defines a custom argument buffer structure, `TerrainHabitat`, that defines the elements of a terrain habitat.\n\n```objective-c\nstruct TerrainHabitat\n{\n#ifndef __METAL_VERSION__\n    \/\/ This struct should not be instantiated in C++ because it contains textures that aren't visible on the CPU\nprivate:\n    TerrainHabitat ();\npublic:\n#endif\n\n    float slopeStrength      IAB_INDEX(TerrainHabitat_MemberIds::slopeStrength);\n    float slopeThreshold     IAB_INDEX(TerrainHabitat_MemberIds::slopeThreshold);\n    float elevationStrength  IAB_INDEX(TerrainHabitat_MemberIds::elevationStrength);\n    float elevationThreshold IAB_INDEX(TerrainHabitat_MemberIds::elevationThreshold);\n    float specularPower      IAB_INDEX(TerrainHabitat_MemberIds::specularPower);\n    float textureScale       IAB_INDEX(TerrainHabitat_MemberIds::textureScale);\n    bool  flipNormal         IAB_INDEX(TerrainHabitat_MemberIds::flipNormal);\n\n    struct ParticleProperties\n    {\n        \/\/ The fields of this struct need to be reflected in TerrainHabitat_MemberIds\n        simd::float4    keyTimePoints;\n        simd::float4    scaleFactors;\n        simd::float4    alphaFactors;\n        simd::float4    gravity;\n        simd::float4    lightingCoefficients;\n        int             doesCollide;\n        int             doesRotate;\n        int             castShadows;\n        int             distanceDependent;\n    } particleProperties;\n\n#ifdef __METAL_VERSION__\n    texture2d_array <float,access::sample> diffSpecTextureArray IAB_INDEX(TerrainHabitat_MemberIds::diffSpecTextureArray);\n    texture2d_array <float,access::sample> normalTextureArray   IAB_INDEX(TerrainHabitat_MemberIds::normalTextureArray);\n#endif\n};\n```\n\nAmong these elements, `elevationStrength` and `elevationThreshold` determine the elevation range in which the habitat is active. Additionally, `diffSpecTextureArray` and `normalTextureArray` determine the textures used to render the habitat.\n\nThe app nests `TerrainHabitat` within another argument buffer, `TerrainParams`, that provides many slight visual variations for added realism.\n\n```objective-c\nstruct TerrainParams\n{\n    TerrainHabitat habitats [TerrainHabitatTypeCOUNT];\n    float ambientOcclusionScale    IAB_INDEX(TerrainParams_MemberIds::ambientOcclusionScale);\n    float ambientOcclusionContrast IAB_INDEX(TerrainParams_MemberIds::ambientOcclusionContrast);\n    float ambientLightScale        IAB_INDEX(TerrainParams_MemberIds::ambientLightScale);\n    float atmosphereScale          IAB_INDEX(TerrainParams_MemberIds::atmosphereScale);\n};\n```\n\n`TerrainHabitat` is the specific argument buffer definition for a terrain habitat. However, because the app nests its definition within `TerrainParams`, the app sends the `TerrainParams` objects to the GPU pipeline.\n\n### Render terrain\n\nThe sample provides the GPU with the textures corresponding to various habitats. First, the sample calls the `useResource:usage:` method to indicate which textures the GPU uses.\n\n```objective-c\nfor (int i = 0; i < _terrainTextures.size(); i++)\n{\n    [renderEncoder useResource: _terrainTextures[i].diffSpecTextureArray\n                         usage: MTLResourceUsageSample | MTLResourceUsageRead];\n    [renderEncoder useResource: _terrainTextures[i].normalTextureArray\n                         usage: MTLResourceUsageSample | MTLResourceUsageRead];\n}\n```\n\nThen, the sample calls the `setFragmentBuffer:offset:atIndex:` method to set the argument buffer, `terrainParamsBuffer`, that contains those textures.\n\n```objective-c\n[renderEncoder setFragmentBuffer:_terrainParamsBuffer offset:0 atIndex:_iabBufferIndex_PplTerrainMainView];\n```\n\nThe sample accesses the argument buffer in the fragment function, `terrain_fragment`, to output the correct material for the terrain. First, the sample passes the `mat` parameter into the fragment function.\n\n```metal\nfragment GBufferFragOut terrain_fragment(const TerrainVertexOut in [[stage_in]],\n                                         constant TerrainParams & mat [[buffer(1)]],\n                                         constant AAPLUniforms& globalUniforms [[buffer(2)]],\n                                         texture2d<float> heightMap [[texture(0)]],\n                                         texture2d<float> normalMap [[texture(1)]],\n                                         texture2d<float> propertiesMap [[texture(2)]])\n```\n\nThen, the sample passes the current land elevation into the `EvaluateTerrainAtLocation` function, where the fragment samples the texture corresponding to that elevation.\n\n```metal\nBrdfProperties curSubLayerBrdf = sample_brdf(\n                                             mat.habitats [curLayerIdx].diffSpecTextureArray,\n                                             mat.habitats [curLayerIdx].normalTextureArray,\n                                             curSubLayerIdx,\n                                             mat.habitats [curLayerIdx].textureScale,\n                                             mat.habitats [curLayerIdx].specularPower,\n                                             mat.habitats [curLayerIdx].flipNormal,\n                                             in.worldPosition,\n                                             normal,\n                                             tangent,\n                                             bitangent);\n```\n\n### Render vegetation\n\nThe sample passes the `terrainParamsBuffer` argument buffer to the vegetation render pass through an instance of `AAPLTerrainRenderer`. This data determines which type of vegetation to render at a given location. First, the sample calls the `setBuffer:offset:atIndex:` method to set the argument buffer for the vegetation render pass.\n\n```objective-c\n[computeEncoder setBuffer:terrain.terrainParamsBuffer offset:0 atIndex:3];\n```\n\nThen, the sample passes the argument buffer into the `EvaluateTerrainAtLocation` function, which produces a `habitatPercentages` value.\n\n```metal\nEvaluateTerrainAtLocation(uv_pos, world_pos, heightMap,\n                          normalMap, propertiesMap, terrainParams,\n                          habitatPercentages,\n                          worldNormal);\n```\n\nThe habitat percentages are processed to select a specific index into the vegetation geometries, determined by the value of `pop_idx`.\n\n```metal\npop_idx = rules[rule_index].populationStartIndex + uint((s \/ rules[rule_index].densityInHabitat * float(rules[rule_index].populationIndexCount)));\n```\n\nFinally, the sample uses this population index to render an instance of a particular vegetation geometry onto the landscape.\n\n```metal\nvegetationSpawnInstance(pop_idx, world_matrix, float4(world_pos, radius), globalUniforms, instances, indirect);\n```\n\n### Render particles\n\nThe sample passes the `terrainParamsBuffer` argument buffer to the particle render pass through an instance of `AAPLTerrainRenderer`. This data determines which type of particles to render at a given location. First, the sample calls the `setBuffer:offset:atIndex:` method to set the argument buffer for the particle render pass.\n\n```objective-c\n[enc setBuffer:[terrain terrainParamsBuffer] offset:0 atIndex:14];\n```\n\nThen, the sample checks the relative percentages of habitat coverage in the altered landscape with the `EvaluateTerrainAtLocation` function, where the sample passes the 3D position of the particle.\n\n```metal\nEvaluateTerrainAtLocation(mouseUvPos, mouseWorldPos, heightMap,\n                          normalMap, propsMap, terrainParams,\n                          habitatPercentages,\n                          worldNormal);\n```\n\nThe sample chooses the appropriate habitat by selecting the terrain with the highest percentage of habitat coverage.\n\n```metal\nfloat highestLevel = 0.f;\nfor (uint i = 0; i < TerrainHabitatTypeCOUNT; i++)\n{\n    if (habitatPercentages [i] > highestLevel)\n    {\n        highestLevel = habitatPercentages [i];\n        habitatIndex = i;\n    }\n}\n```\n\nFinally, the app retrieves the particle’s corresponding habitat material from the argument buffer and sets it to the new particle.\n\n```metal\nParticleData data;\ndata.habitatIndex = habitatIndex;\ndata.texture = terrainParams.habitats [habitatIndex].diffSpecTextureArray;\n```\n\n## Argument buffers\n\n- **Improving CPU performance by using argument buffers**: Optimize your app’s performance by grouping your resources into argument buffers.\n- **Managing groups of resources with argument buffers**: Create argument buffers to organize related resources.\n- **Tracking the resource residency of argument buffers**: Optimize resource performance within an argument buffer.\n- **Indexing argument buffers**: Assign resource indices within an argument buffer.\n- **Encoding argument buffers on the GPU**: Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.\n- **Using argument buffers with resource heaps**: Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.\n- **MTLArgumentDescriptor**: A representation of an argument within an argument buffer.\n- **MTLArgumentEncoder**: An interface you can use to encode argument data into an argument buffer.\n- **MTLAttributeStrideStatic**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Optimize your app’s performance by grouping your resources into argument buffers.",
          "name" : "Improving CPU performance by using argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers"
        },
        {
          "description" : "Create argument buffers to organize related resources.",
          "name" : "Managing groups of resources with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-groups-of-resources-with-argument-buffers"
        },
        {
          "description" : "Optimize resource performance within an argument buffer.",
          "name" : "Tracking the resource residency of argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/tracking-the-resource-residency-of-argument-buffers"
        },
        {
          "description" : "Assign resource indices within an argument buffer.",
          "name" : "Indexing argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/indexing-argument-buffers"
        },
        {
          "description" : "Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.",
          "name" : "Encoding argument buffers on the GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-argument-buffers-on-the-gpu"
        },
        {
          "description" : "Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.",
          "name" : "Using argument buffers with resource heaps",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-argument-buffers-with-resource-heaps"
        },
        {
          "description" : "A representation of an argument within an argument buffer.",
          "name" : "MTLArgumentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentDescriptor"
        },
        {
          "description" : "An interface you can use to encode argument data into an argument buffer.",
          "name" : "MTLArgumentEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentEncoder"
        },
        {
          "description" : "",
          "name" : "MTLAttributeStrideStatic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAttributeStrideStatic"
        }
      ],
      "title" : "Argument buffers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Rendering terrain dynamically with argument buffers",
  "url" : "https:\/\/developer.apple.com\/documentation\/metal\/rendering-terrain-dynamically-with-argument-buffers"
}