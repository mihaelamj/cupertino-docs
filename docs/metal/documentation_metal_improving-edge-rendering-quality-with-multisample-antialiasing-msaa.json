{
  "abstract" : "Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.",
  "codeExamples" : [
    {
      "code" : "NSUInteger sampleCounts[AAPLSampleCountOptionsCount] = { 2, 4, 8 };\nfor (int i = 0; i < AAPLSampleCountOptionsCount; i++)\n{\n    sampleCountSupported[i] = [_view.device supportsTextureSampleCount:sampleCounts[i]];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "id<MTLTexture> _multisampleTexture;",
      "language" : "objective-c"
    },
    {
      "code" : "_multisampleTextureDescriptor.textureType = MTLTextureType2DMultisample;\n_multisampleTextureDescriptor.sampleCount = _antialiasingSampleCount;",
      "language" : "objective-c"
    },
    {
      "code" : "if (_resolvingOnTileShaders)\n{\n    _multisampleTextureDescriptor.usage = MTLTextureUsageRenderTarget;\n    _multisampleTextureDescriptor.storageMode = MTLStorageModeMemoryless;\n}\nelse\n{\n    _multisampleTextureDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead;\n    _multisampleTextureDescriptor.storageMode = MTLStorageModePrivate;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "_multisampleTextureDescriptor.width = _viewportSize.x;\n_multisampleTextureDescriptor.height = _viewportSize.y;\n\n_multisampleTexture = [_device newTextureWithDescriptor:_multisampleTextureDescriptor];\n\n_multisampleTexture.label = @\"Multisampled Texture\";\n\n_resolveTextureDescriptor.width = _viewportSize.x;\n_resolveTextureDescriptor.height = _viewportSize.y;\n\n_resolveResultTexture = [_device newTextureWithDescriptor:_resolveTextureDescriptor];\n\n_resolveResultTexture.label = @\"Resolved Texture\";",
      "language" : "objective-c"
    },
    {
      "code" : "if (_antialiasingEnabled)\n{\n    _renderPipelineDescriptor.sampleCount = _antialiasingSampleCount;\n    _renderPipelineDescriptor.fragmentFunction = _fragmentFunctionNonHDR;\n}\nelse\n{\n    _renderPipelineDescriptor.sampleCount = 1;\n    _renderPipelineDescriptor.fragmentFunction = _usesHDR ? _fragmentFunctionHDR : _fragmentFunctionNonHDR;\n}\n_renderPipelineState = [_device newRenderPipelineStateWithDescriptor:_renderPipelineDescriptor error:nil];",
      "language" : "objective-c"
    },
    {
      "code" : "if (_resolvingOnTileShaders)\n{\n    renderPassDescriptor.tileWidth = AAPLTileWidth;\n    renderPassDescriptor.tileHeight = AAPLTileHeight;\n    renderPassDescriptor.imageblockSampleLength = 32;\n}\n\nMTLStoreAction storeAction = shouldResolve ? MTLStoreActionMultisampleResolve : MTLStoreActionStore;\nrenderPassDescriptor.colorAttachments[0].storeAction = storeAction;\nrenderPassDescriptor.colorAttachments[0].texture = _multisampleTexture;\nrenderPassDescriptor.colorAttachments[0].resolveTexture = shouldResolve ? _resolveResultTexture : nil;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ A custom resolve kernel that averages color at all sample points.\nkernel void\naverageResolveKernel(texture2d_ms<float, access::read> multisampledTexture [[texture(0)]],\n                     texture2d<float, access::write> resolvedTexture [[texture(1)]],\n                     uint2 gid [[thread_position_in_grid]])\n{\n    const uint count = multisampledTexture.get_num_samples();\n    \n    float4 resolved_color = 0;\n    \n    for (uint i = 0; i < count; ++i)\n    {\n        resolved_color += multisampledTexture.read(gid, i);\n    }\n    \n    resolved_color \/= count;\n    \n    resolvedTexture.write(resolved_color, gid);\n}",
      "language" : "metal"
    },
    {
      "code" : "\/\/ Resolve the multisample texture with the chosen custom filter.\nid<MTLComputeCommandEncoder> computeEncoder = [commandBuffer computeCommandEncoder];\n\ncomputeEncoder.label = @\"Resolve on Compute\";\n\n[computeEncoder setComputePipelineState:_resolveComputePipelineState];\n\n[computeEncoder setTexture:_multisampleTexture atIndex:0];\n[computeEncoder setTexture:_resolveResultTexture atIndex:1];\n\n[computeEncoder dispatchThreadgroups:_threadgroupsInGrid\n               threadsPerThreadgroup:_intrinsicThreadgroupSize];\n\n[computeEncoder endEncoding];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ Tone-maps an input color by calculating its Rec. 709 luminance and applying a simple tone-mapping operator.\nhalf3 tonemapByLuminance(half3 inColor)\n{\n    const half3 kRec709Luma(0.2126h, 0.7152h, 0.0722h);\n    \n    const half luminance = dot(inColor, kRec709Luma);\n    \n    return inColor \/ (1 + luminance);\n}",
      "language" : "metal"
    },
    {
      "code" : "for (uint i = 0; i < count; ++i)\n{\n    const half4 sampleColor = multisampledTexture.read(gid, i);\n    \n    const half3 tonemappedColor = tonemapByLuminance(sampleColor.xyz);\n    \n    resolved_color += half4(tonemappedColor, 1);\n}",
      "language" : "metal"
    },
    {
      "code" : "\/\/\/ Checks whether the device supports tile shaders that were introduced with Apple GPU family 4.\n- (BOOL)supportsTileShaders\n{\n    return [_device supportsFamily:MTLGPUFamilyApple4];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "_resolveTileRenderPipelineDescriptor = [MTLTileRenderPipelineDescriptor new];\n\n_resolveTileRenderPipelineDescriptor.label = @\"CustomResolvePipeline\";\n_resolveTileRenderPipelineDescriptor.tileFunction = _averageResolveTileKernelFunction;\n_resolveTileRenderPipelineDescriptor.threadgroupSizeMatchesTileSize = YES;\n_resolveTileRenderPipelineDescriptor.colorAttachments[0].pixelFormat = _renderTargetPixelFormat;\n\n_resolveTileRenderPipelineDescriptor.rasterSampleCount = _antialiasingSampleCount;\n\n_resolveTileRenderPipelineState = [_device newRenderPipelineStateWithTileDescriptor:_resolveTileRenderPipelineDescriptor\n                                                                            options:0\n                                                                         reflection:nil\n                                                                              error:&error];\nNSAssert(_resolveTileRenderPipelineState, @\"Failed aquiring pipeline state: %@\", error);",
      "language" : "objective-c"
    },
    {
      "code" : "if (_antialiasingEnabled && _resolveOption != AAPLResolveOptionBuiltin)\n{\n    \/\/ Resolve MSAA with a custom resolve filter.\n    [renderEncoder setRenderPipelineState:_resolveTileRenderPipelineState];\n    \n    [renderEncoder dispatchThreadsPerTile:MTLSizeMake(16, 16, 1)];\n}\n\n[renderEncoder endEncoding];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/\/ A tile kernel for a custom MSAA resolve that applies tone-mapping to HDR color samples before it calculates the average color for the pixel.\nkernel void\nhdrResolveTileKernel(imageblock<FragData> img_blk_colors,\n                     ushort2 tid [[thread_position_in_threadgroup]])\n{\n    \n    const ushort pixelColorCount = img_blk_colors.get_num_colors(tid);\n    \n    half4 resolved_color = half4(0);\n    \n    for (ushort i = 0; i < pixelColorCount; ++i)\n    {\n        const half4 color = img_blk_colors.read(tid, i, imageblock_data_rate::color).resolvedColor;\n        \n        const ushort sampleColorCount = popcount(img_blk_colors.get_color_coverage_mask(tid, i));\n        \n        const half3 tonemappedColor = tonemapByLuminance(color.xyz);\n        \n        resolved_color += half4(tonemappedColor, 1) * sampleColorCount;\n    }\n    \n    resolved_color \/= img_blk_colors.get_num_samples();\n    \n    const ushort output_sample_mask = 0xF;\n    \n    img_blk_colors.write(FragData{resolved_color}, tid, output_sample_mask);\n}",
      "language" : "metal"
    }
  ],
  "contentHash" : "c5f538962104a89ccf089d5fad8455bd08c46683bb5e7a40e501138c2c568c49",
  "crawledAt" : "2025-12-02T15:31:20Z",
  "id" : "9BA018F8-76D1-4B1C-94C9-5A3494AD7C21",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nMSAA improves the rendering of lines and edges by using several color and depth samples per pixel. An MSAA texture normally stores two or four samples per pixel. But some GPU devices support eight samples per pixel. After the app renders a scene to the MSAA texture, it *resolves* it to a normal texture that contains one sample per pixel. The built-in resolve uses a simple average, but sometimes you want to use a custom resolve.\n\nA custom resolve is essential when the built-in resolve isn’t sufficient. For example, you may want to tone-map high dynamic range (HDR) samples before averaging them. HDR means that color values exceed the normal color intensity range of zero to one. Tone-mapping means that values are compressed into the zero-to-one range for output to a display device.\n\nThis sample shows you how to use a custom resolve with immediate-mode devices and tile-based deferred rendering devices. The immediate-mode custom resolve uses a compute kernel to process the MSAA texture, while a tile-based shader works before the rendering is completed, saving time and memory bandwidth. The following image shows the results of applying MSAA to a colored set of thin shards with one, two, four, and eight samples per pixel.\n\n\n\nThe sample displays a user interface for you to control the code paths to use MSAA. The app customizes the options presented based on the current device. Some devices support eight samples or the tile-based resolve. You can choose between the built-in resolve or a custom resolve that replicates the built-in choice or applies a tone-mapping operator to the samples. You can choose between two, four, or eight samples per pixel and the immediate-mode path or the tile-based resolve.\n\nThere’s a checkbox to toggle MSAA on and off. There’s also a list of reduced resolutions—ranging from one-sixteenth resolution to full-resolution—that makes it easier to see the difference MSAA makes. Pressing the space bar on a macOS device or tapping the display on an iOS device causes the shards to rotate.\n\n### Configure the sample code project\n\nTo run this sample, you need Xcode 12 or later on a macOS, iOS, or tvOS device or simulator. To experience the tile-based custom resolve feature, you need a physical device that supports [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLGPUFamily\/apple4], such as:\n\nOn a device with an Intel or AMD GPU, or on a simulator, this sample runs with the custom resolve in immediate-mode rendering (IMR) only.\n\n### Check for MSAA support\n\nGPUs on Apple devices can support a variety of sample counts but need to support at least a sample count of four. The app checks the device’s supported sample count with [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsTextureSampleCount(_:)] and uses a default sample count of four.\n\n### Create a multisample texture\n\nThe app needs to create a multisample texture before rendering the scene. The following code shows that the texture declaration is the same as a normal texture.\n\nThe app configures the texture using a texture descriptor. It uses [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureType\/type2DMultisample] as the texture type, and sets the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/sampleCount] property with the current count selected in the UI.\n\nIf the app is running on a device that supports tile shaders, then the usage and storage mode enable the renderer to take advantage of memoryless storage. That means the device discards the texture when it finishes the tile-based resolve. In comparison, the immediate-mode custom resolve requires the texture to stay in memory, and the renderer uses a separate compute pass to resolve the MSAA texture. The app sets the shader-read flag to allow the compute kernel to access the texture. The following code shows how to set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/usage] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/storageMode] properties in the descriptor.\n\nThe renderer also creates a resolve texture to store the final image that’ll be copied to the drawable texture. The following code shows how it uses the same width and height for both textures. The `_resolveTextureDescriptor` uses a single sample for the resolve texture.\n\n### Configure the render pipeline\n\nThe renderer ensures the render pipeline state object (PSO) has the current sample count as the texture to use as a render target. It also decides the correct fragment function depending on whether HDR is enabled or not. The app uses a separate custom resolve step if HDR is enabled, so it doesn’t apply tone-mapping. But if antialiasing is disabled, then it uses a fragment function that applies tone-mapping. If the HDR resolve option is chosen in the UI, then toggling MSAA on and off shows the result of using tone-mapping. The following code shows how the renderer customizes the render pipeline descriptor before it creates the PSO.\n\nAfter the the renderer sets up the PSO, it also sets up the render pass descriptor to use the multisample texture as a color attachment. If MSAA isn’t enabled, then it sets up the `_resolveResultTexture` as the main color attachment. But if MSAA is enabled, then the following code shows how the renderer chooses the store action. If tile shaders are available or you choose the built-in resolve, then Metal resolves the texture without needing an extra compute pass. The code also shows how to prepare the render pass for a resolve using tile shaders that the README discusses later.\n\n### Use a custom resolve in IMR\n\nThe built-in resolve averages the color samples in the texture together to create the final pixel color in the resolve texture. But developers can use a custom resolve by using a compute kernel. Devices that don’t support tile-based rendering need to use a compute kernel. The compute kernel reads the multisample texture and writes a normal texture. The following code shows a compute kernel that accumulates the samples and calculates their average.\n\nThe following code shows how to resolve an MSAA texture with the compute kernel. It sets the two input textures for the kernel and dispatches the work.\n\n### Use a custom resolve to tone-map an HDR image\n\nImages with HDR need a tone-mapping operator before they’re output to a computer display. The sample shows how to use a custom resolve to prepare the image. The following code shows the simple tone-mapping operator that uses luminance to scale the input color.\n\nThe sample uses a different kernel function, `hdrResolveKernel`, that tone-maps the samples before it takes the average. Developers may choose to use a similar approach for applications where two mathematical functions don’t commute. In this case, tone-mapping the average of four samples isn’t necessarily the same numerical result as averaging four tone-mapped samples.\n\n### Use a tile-based resolve on an Apple silicon device\n\nOn Apple silicon devices, this app can resolve a multisample texture using a tile-based resolve, allowing the device to perform the resolve before the device saves the tile to memory. The app gains two advantages: The multisample texture doesn’t need to be stored, saving memory space, and it doesn’t require a second render or compute pass, saving compute time and memory bandwidth.\n\nNot all devices support tile shaders, so the app uses the following code to check whether the device supports the feature.\n\nIf the device supports the feature, then the renderer creates a new PSO that uses the `_averageResolveTileKernelFunction`. The following code shows how to set the kernel function, pixel format, sample count, and whether the kernel function expects the tile size to match the thread group size.\n\nAfter it creates the PSO, the renderer can dispatch the work before it finishes encoding the work. The following code shows how the app avoids this step when it uses the built-in resolve.\n\nFinally, the following code shows a custom kernel function that resolves the MSAA texture when the input texture has HDR samples. The other custom kernel function in the app is similar, but it only averages the sample values, like the built-in resolve.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/improving-edge-rendering-quality-with-multisample-antialiasing-msaa\ncrawled: 2025-12-02T15:31:20Z\n---\n\n# Improving edge-rendering quality with multisample antialiasing (MSAA)\n\n**Sample Code**\n\nApply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.\n\n## Overview\n\nMSAA improves the rendering of lines and edges by using several color and depth samples per pixel. An MSAA texture normally stores two or four samples per pixel. But some GPU devices support eight samples per pixel. After the app renders a scene to the MSAA texture, it *resolves* it to a normal texture that contains one sample per pixel. The built-in resolve uses a simple average, but sometimes you want to use a custom resolve.\n\nA custom resolve is essential when the built-in resolve isn’t sufficient. For example, you may want to tone-map high dynamic range (HDR) samples before averaging them. HDR means that color values exceed the normal color intensity range of zero to one. Tone-mapping means that values are compressed into the zero-to-one range for output to a display device.\n\nThis sample shows you how to use a custom resolve with immediate-mode devices and tile-based deferred rendering devices. The immediate-mode custom resolve uses a compute kernel to process the MSAA texture, while a tile-based shader works before the rendering is completed, saving time and memory bandwidth. The following image shows the results of applying MSAA to a colored set of thin shards with one, two, four, and eight samples per pixel.\n\n\n\nThe sample displays a user interface for you to control the code paths to use MSAA. The app customizes the options presented based on the current device. Some devices support eight samples or the tile-based resolve. You can choose between the built-in resolve or a custom resolve that replicates the built-in choice or applies a tone-mapping operator to the samples. You can choose between two, four, or eight samples per pixel and the immediate-mode path or the tile-based resolve.\n\nThere’s a checkbox to toggle MSAA on and off. There’s also a list of reduced resolutions—ranging from one-sixteenth resolution to full-resolution—that makes it easier to see the difference MSAA makes. Pressing the space bar on a macOS device or tapping the display on an iOS device causes the shards to rotate.\n\n### Configure the sample code project\n\nTo run this sample, you need Xcode 12 or later on a macOS, iOS, or tvOS device or simulator. To experience the tile-based custom resolve feature, you need a physical device that supports [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLGPUFamily\/apple4], such as:\n\n- A Mac with Apple silicon running macOS 11 or later\n- An iOS device with an A11 chip or later running iOS 13 or later\n- A tvOS device with an A12 chip or later running tvOS 14.5 or later\n\nOn a device with an Intel or AMD GPU, or on a simulator, this sample runs with the custom resolve in immediate-mode rendering (IMR) only.\n\n### Check for MSAA support\n\nGPUs on Apple devices can support a variety of sample counts but need to support at least a sample count of four. The app checks the device’s supported sample count with [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/supportsTextureSampleCount(_:)] and uses a default sample count of four.\n\n```objective-c\nNSUInteger sampleCounts[AAPLSampleCountOptionsCount] = { 2, 4, 8 };\nfor (int i = 0; i < AAPLSampleCountOptionsCount; i++)\n{\n    sampleCountSupported[i] = [_view.device supportsTextureSampleCount:sampleCounts[i]];\n}\n```\n\n### Create a multisample texture\n\nThe app needs to create a multisample texture before rendering the scene. The following code shows that the texture declaration is the same as a normal texture.\n\n```objective-c\nid<MTLTexture> _multisampleTexture;\n```\n\nThe app configures the texture using a texture descriptor. It uses [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureType\/type2DMultisample] as the texture type, and sets the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/sampleCount] property with the current count selected in the UI.\n\n```objective-c\n_multisampleTextureDescriptor.textureType = MTLTextureType2DMultisample;\n_multisampleTextureDescriptor.sampleCount = _antialiasingSampleCount;\n```\n\nIf the app is running on a device that supports tile shaders, then the usage and storage mode enable the renderer to take advantage of memoryless storage. That means the device discards the texture when it finishes the tile-based resolve. In comparison, the immediate-mode custom resolve requires the texture to stay in memory, and the renderer uses a separate compute pass to resolve the MSAA texture. The app sets the shader-read flag to allow the compute kernel to access the texture. The following code shows how to set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/usage] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor\/storageMode] properties in the descriptor.\n\n```objective-c\nif (_resolvingOnTileShaders)\n{\n    _multisampleTextureDescriptor.usage = MTLTextureUsageRenderTarget;\n    _multisampleTextureDescriptor.storageMode = MTLStorageModeMemoryless;\n}\nelse\n{\n    _multisampleTextureDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead;\n    _multisampleTextureDescriptor.storageMode = MTLStorageModePrivate;\n}\n```\n\nThe renderer also creates a resolve texture to store the final image that’ll be copied to the drawable texture. The following code shows how it uses the same width and height for both textures. The `_resolveTextureDescriptor` uses a single sample for the resolve texture.\n\n```objective-c\n_multisampleTextureDescriptor.width = _viewportSize.x;\n_multisampleTextureDescriptor.height = _viewportSize.y;\n\n_multisampleTexture = [_device newTextureWithDescriptor:_multisampleTextureDescriptor];\n\n_multisampleTexture.label = @\"Multisampled Texture\";\n\n_resolveTextureDescriptor.width = _viewportSize.x;\n_resolveTextureDescriptor.height = _viewportSize.y;\n\n_resolveResultTexture = [_device newTextureWithDescriptor:_resolveTextureDescriptor];\n\n_resolveResultTexture.label = @\"Resolved Texture\";\n```\n\n### Configure the render pipeline\n\nThe renderer ensures the render pipeline state object (PSO) has the current sample count as the texture to use as a render target. It also decides the correct fragment function depending on whether HDR is enabled or not. The app uses a separate custom resolve step if HDR is enabled, so it doesn’t apply tone-mapping. But if antialiasing is disabled, then it uses a fragment function that applies tone-mapping. If the HDR resolve option is chosen in the UI, then toggling MSAA on and off shows the result of using tone-mapping. The following code shows how the renderer customizes the render pipeline descriptor before it creates the PSO.\n\n```objective-c\nif (_antialiasingEnabled)\n{\n    _renderPipelineDescriptor.sampleCount = _antialiasingSampleCount;\n    _renderPipelineDescriptor.fragmentFunction = _fragmentFunctionNonHDR;\n}\nelse\n{\n    _renderPipelineDescriptor.sampleCount = 1;\n    _renderPipelineDescriptor.fragmentFunction = _usesHDR ? _fragmentFunctionHDR : _fragmentFunctionNonHDR;\n}\n_renderPipelineState = [_device newRenderPipelineStateWithDescriptor:_renderPipelineDescriptor error:nil];\n```\n\nAfter the the renderer sets up the PSO, it also sets up the render pass descriptor to use the multisample texture as a color attachment. If MSAA isn’t enabled, then it sets up the `_resolveResultTexture` as the main color attachment. But if MSAA is enabled, then the following code shows how the renderer chooses the store action. If tile shaders are available or you choose the built-in resolve, then Metal resolves the texture without needing an extra compute pass. The code also shows how to prepare the render pass for a resolve using tile shaders that the README discusses later.\n\n```objective-c\nif (_resolvingOnTileShaders)\n{\n    renderPassDescriptor.tileWidth = AAPLTileWidth;\n    renderPassDescriptor.tileHeight = AAPLTileHeight;\n    renderPassDescriptor.imageblockSampleLength = 32;\n}\n\nMTLStoreAction storeAction = shouldResolve ? MTLStoreActionMultisampleResolve : MTLStoreActionStore;\nrenderPassDescriptor.colorAttachments[0].storeAction = storeAction;\nrenderPassDescriptor.colorAttachments[0].texture = _multisampleTexture;\nrenderPassDescriptor.colorAttachments[0].resolveTexture = shouldResolve ? _resolveResultTexture : nil;\n```\n\n### Use a custom resolve in IMR\n\nThe built-in resolve averages the color samples in the texture together to create the final pixel color in the resolve texture. But developers can use a custom resolve by using a compute kernel. Devices that don’t support tile-based rendering need to use a compute kernel. The compute kernel reads the multisample texture and writes a normal texture. The following code shows a compute kernel that accumulates the samples and calculates their average.\n\n```metal\n\/\/\/ A custom resolve kernel that averages color at all sample points.\nkernel void\naverageResolveKernel(texture2d_ms<float, access::read> multisampledTexture [[texture(0)]],\n                     texture2d<float, access::write> resolvedTexture [[texture(1)]],\n                     uint2 gid [[thread_position_in_grid]])\n{\n    const uint count = multisampledTexture.get_num_samples();\n    \n    float4 resolved_color = 0;\n    \n    for (uint i = 0; i < count; ++i)\n    {\n        resolved_color += multisampledTexture.read(gid, i);\n    }\n    \n    resolved_color \/= count;\n    \n    resolvedTexture.write(resolved_color, gid);\n}\n```\n\nThe following code shows how to resolve an MSAA texture with the compute kernel. It sets the two input textures for the kernel and dispatches the work.\n\n```objective-c\n\/\/ Resolve the multisample texture with the chosen custom filter.\nid<MTLComputeCommandEncoder> computeEncoder = [commandBuffer computeCommandEncoder];\n\ncomputeEncoder.label = @\"Resolve on Compute\";\n\n[computeEncoder setComputePipelineState:_resolveComputePipelineState];\n\n[computeEncoder setTexture:_multisampleTexture atIndex:0];\n[computeEncoder setTexture:_resolveResultTexture atIndex:1];\n\n[computeEncoder dispatchThreadgroups:_threadgroupsInGrid\n               threadsPerThreadgroup:_intrinsicThreadgroupSize];\n\n[computeEncoder endEncoding];\n```\n\n### Use a custom resolve to tone-map an HDR image\n\nImages with HDR need a tone-mapping operator before they’re output to a computer display. The sample shows how to use a custom resolve to prepare the image. The following code shows the simple tone-mapping operator that uses luminance to scale the input color.\n\n```metal\n\/\/\/ Tone-maps an input color by calculating its Rec. 709 luminance and applying a simple tone-mapping operator.\nhalf3 tonemapByLuminance(half3 inColor)\n{\n    const half3 kRec709Luma(0.2126h, 0.7152h, 0.0722h);\n    \n    const half luminance = dot(inColor, kRec709Luma);\n    \n    return inColor \/ (1 + luminance);\n}\n```\n\nThe sample uses a different kernel function, `hdrResolveKernel`, that tone-maps the samples before it takes the average. Developers may choose to use a similar approach for applications where two mathematical functions don’t commute. In this case, tone-mapping the average of four samples isn’t necessarily the same numerical result as averaging four tone-mapped samples.\n\n```metal\nfor (uint i = 0; i < count; ++i)\n{\n    const half4 sampleColor = multisampledTexture.read(gid, i);\n    \n    const half3 tonemappedColor = tonemapByLuminance(sampleColor.xyz);\n    \n    resolved_color += half4(tonemappedColor, 1);\n}\n```\n\n### Use a tile-based resolve on an Apple silicon device\n\nOn Apple silicon devices, this app can resolve a multisample texture using a tile-based resolve, allowing the device to perform the resolve before the device saves the tile to memory. The app gains two advantages: The multisample texture doesn’t need to be stored, saving memory space, and it doesn’t require a second render or compute pass, saving compute time and memory bandwidth.\n\nNot all devices support tile shaders, so the app uses the following code to check whether the device supports the feature.\n\n```objective-c\n\/\/\/ Checks whether the device supports tile shaders that were introduced with Apple GPU family 4.\n- (BOOL)supportsTileShaders\n{\n    return [_device supportsFamily:MTLGPUFamilyApple4];\n}\n```\n\nIf the device supports the feature, then the renderer creates a new PSO that uses the `_averageResolveTileKernelFunction`. The following code shows how to set the kernel function, pixel format, sample count, and whether the kernel function expects the tile size to match the thread group size.\n\n```objective-c\n_resolveTileRenderPipelineDescriptor = [MTLTileRenderPipelineDescriptor new];\n\n_resolveTileRenderPipelineDescriptor.label = @\"CustomResolvePipeline\";\n_resolveTileRenderPipelineDescriptor.tileFunction = _averageResolveTileKernelFunction;\n_resolveTileRenderPipelineDescriptor.threadgroupSizeMatchesTileSize = YES;\n_resolveTileRenderPipelineDescriptor.colorAttachments[0].pixelFormat = _renderTargetPixelFormat;\n\n_resolveTileRenderPipelineDescriptor.rasterSampleCount = _antialiasingSampleCount;\n\n_resolveTileRenderPipelineState = [_device newRenderPipelineStateWithTileDescriptor:_resolveTileRenderPipelineDescriptor\n                                                                            options:0\n                                                                         reflection:nil\n                                                                              error:&error];\nNSAssert(_resolveTileRenderPipelineState, @\"Failed aquiring pipeline state: %@\", error);\n```\n\nAfter it creates the PSO, the renderer can dispatch the work before it finishes encoding the work. The following code shows how the app avoids this step when it uses the built-in resolve.\n\n```objective-c\nif (_antialiasingEnabled && _resolveOption != AAPLResolveOptionBuiltin)\n{\n    \/\/ Resolve MSAA with a custom resolve filter.\n    [renderEncoder setRenderPipelineState:_resolveTileRenderPipelineState];\n    \n    [renderEncoder dispatchThreadsPerTile:MTLSizeMake(16, 16, 1)];\n}\n\n[renderEncoder endEncoding];\n```\n\nFinally, the following code shows a custom kernel function that resolves the MSAA texture when the input texture has HDR samples. The other custom kernel function in the app is similar, but it only averages the sample values, like the built-in resolve.\n\n```metal\n\/\/\/ A tile kernel for a custom MSAA resolve that applies tone-mapping to HDR color samples before it calculates the average color for the pixel.\nkernel void\nhdrResolveTileKernel(imageblock<FragData> img_blk_colors,\n                     ushort2 tid [[thread_position_in_threadgroup]])\n{\n    \n    const ushort pixelColorCount = img_blk_colors.get_num_colors(tid);\n    \n    half4 resolved_color = half4(0);\n    \n    for (ushort i = 0; i < pixelColorCount; ++i)\n    {\n        const half4 color = img_blk_colors.read(tid, i, imageblock_data_rate::color).resolvedColor;\n        \n        const ushort sampleColorCount = popcount(img_blk_colors.get_color_coverage_mask(tid, i));\n        \n        const half3 tonemappedColor = tonemapByLuminance(color.xyz);\n        \n        resolved_color += half4(tonemappedColor, 1) * sampleColorCount;\n    }\n    \n    resolved_color \/= img_blk_colors.get_num_samples();\n    \n    const ushort output_sample_mask = 0xF;\n    \n    img_blk_colors.write(FragData{resolved_color}, tid, output_sample_mask);\n}\n```\n\n## Render workflows\n\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Selecting device objects for graphics rendering**: Switch dynamically between multiple GPUs to efficiently render to a display.\n- **Customizing render pass setup**: Render into an offscreen texture by creating a custom render pass.\n- **Creating a custom Metal view**: Implement a lightweight view for Metal rendering that’s customized to your app’s needs.\n- **Calculating primitive visibility using depth testing**: Determine which pixels are visible in a scene by using a depth texture.\n- **Encoding indirect command buffers on the CPU**: Reduce CPU overhead and simplify your command execution by reusing commands.\n- **Implementing order-independent transparency with image blocks**: Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.\n- **Loading textures and models using Metal fast resource loading**: Stream texture and buffer data directly from disk into Metal resources using fast resource loading.\n- **Adjusting the level of detail using Metal mesh shaders**: Choose and render meshes with several levels of detail using object and mesh shaders.\n- **Creating a 3D application with hydra rendering**: Build a 3D application that integrates with Hydra and USD.\n- **Culling occluded geometry using the visibility result buffer**: Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.\n- **Achieving smooth frame rates with a Metal display link**: Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        },
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Switch dynamically between multiple GPUs to efficiently render to a display.",
          "name" : "Selecting device objects for graphics rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-graphics-rendering"
        },
        {
          "description" : "Render into an offscreen texture by creating a custom render pass.",
          "name" : "Customizing render pass setup",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup"
        },
        {
          "description" : "Implement a lightweight view for Metal rendering that’s customized to your app’s needs.",
          "name" : "Creating a custom Metal view",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-custom-metal-view"
        },
        {
          "description" : "Determine which pixels are visible in a scene by using a depth texture.",
          "name" : "Calculating primitive visibility using depth testing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/calculating-primitive-visibility-using-depth-testing"
        },
        {
          "description" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "name" : "Encoding indirect command buffers on the CPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
        },
        {
          "description" : "Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.",
          "name" : "Implementing order-independent transparency with image blocks",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-order-independent-transparency-with-image-blocks"
        },
        {
          "description" : "Stream texture and buffer data directly from disk into Metal resources using fast resource loading.",
          "name" : "Loading textures and models using Metal fast resource loading",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/loading-textures-and-models-using-metal-fast-resource-loading"
        },
        {
          "description" : "Choose and render meshes with several levels of detail using object and mesh shaders.",
          "name" : "Adjusting the level of detail using Metal mesh shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/adjusting-the-level-of-detail-using-metal-mesh-shaders"
        },
        {
          "description" : "Build a 3D application that integrates with Hydra and USD.",
          "name" : "Creating a 3D application with hydra rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-3d-application-with-hydra-rendering"
        },
        {
          "description" : "Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.",
          "name" : "Culling occluded geometry using the visibility result buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/culling-occluded-geometry-using-the-visibility-result-buffer"
        },
        {
          "description" : "Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.",
          "name" : "Achieving smooth frame rates with a Metal display link",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/achieving-smooth-frame-rates-with-a-metal-display-link"
        }
      ],
      "title" : "Render workflows"
    }
  ],
  "source" : "appleJSON",
  "title" : "Improving edge-rendering quality with multisample antialiasing (MSAA)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-edge-rendering-quality-with-multisample-antialiasing-msaa"
}