{
  "abstract" : "Simplify data access and improve GPU utilization by storing custom primitive data directly in the acceleration structure.",
  "codeExamples" : [
    {
      "code" : "#include <simd\/simd.h>\n\nstruct PrimitiveTextureData {\n    uint64_t textureAddress;\n    vector_float2 coordinates[3];\n};\n\nstruct TriangleData {\n    vector_float3 normal0;\n    vector_float3 normal1;\n    vector_float3 normal2;\n\n    vector_float3 color0;\n    vector_float3 color1;\n    vector_float3 color2;\n};",
      "language" : "objective-c"
    },
    {
      "code" : "func configure(geometryDescriptor: MTLAccelerationStructureTriangleGeometryDescriptor,\n               with trianglePrimitiveData: MTLBuffer) {\n    geometryDescriptor.primitiveDataBuffer = trianglePrimitiveData\n    geometryDescriptor.primitiveDataBufferOffset = 0\n    geometryDescriptor.primitiveDataElementSize = MemoryLayout<PrimitiveTextureData>.size\n    geometryDescriptor.primitiveDataStride = MemoryLayout<PrimitiveTextureData>.stride\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ The GPU invokes this kernel for each ray it casts into the scene.\nkernel void rayTracingKernel(uint2 threadID [[thread_position_in_grid]],\n\/\/ ...\n                             instance_acceleration_structure accelerationStructure [[buffer(4)]],\n                             intersection_function_table<triangle_data, instancing> intersectionFunctionTable [[buffer(5)]]\n                             )\n{\n    \/\/\/ Represents a single ray for a ray-tracing scene.\n    ray ray;\n\n    \/\/\/ An intersector that tests for intersections between the ray and the geometry in the scene.\n    intersector<triangle_data, instancing> triangleIntersector;\n\n    \/\/\/ The result value type that represents an intersection with the scene's geometry.\n    intersector<triangle_data, instancing>::result_type result;\n\n    ...\n\n    \/\/ Test the ray for intersection with an acceleration structure's geometry.\n    result = triangleIntersector.intersect(ray, accelerationStructure);\n\n    if (result.type != intersection_type::none) {\n        const device PrimitiveTextureData *textureData;\n\n        \/\/ Retrieve the data that's specific to the triangle the ray intersects.\n        textureData = (const device PrimitiveTextureData *) result.primitive_data;\n\n        vector_float2 uv = textureData->coordinates;\n        uint64_t texture = textureData->textureAddress;\n\n        ...\n    }\n}",
      "language" : "metal"
    },
    {
      "code" : "\/\/\/ The intersection function for the triangle's kernel.\n[[intersection(triangle)]]\nbool triangle_intersection_function(const device PrimitiveTextureData *textureData [[primitive_data]]\n                                    ... ) {\n    ...\n\n    return true;\n}",
      "language" : "metal"
    },
    {
      "code" : "intersection_query<triangle_data, instancing> query;\n\nconst device PrimitiveTextureData* candidatePrimitiveData;\nconst device PrimitiveTextureData* committedPrimitiveData;\n\n...\n\ncandidatePrimitiveData = (const device PrimitiveTextureData *) query.get_candidate_primitive_data();\n\n...\n\ncommittedPrimitiveData = (const device PrimitiveTextureData *) query.get_committed_primitive_data();",
      "language" : "metal"
    }
  ],
  "contentHash" : "eaf092876c776df858ff919a70f63bcfdb812ef8a2a084c5c6a7c0f185c4fd4d",
  "crawledAt" : "2025-12-04T02:16:38Z",
  "id" : "40FC1DBB-8C9C-4599-A2C0-A5C1E05A1B9E",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nCreating a ray-traced renderer — or using ray tracing to implement other behaviors — requires more than simple geometry. Your app also needs to provide custom data to your ray-tracing kernels. For example, a renderer might need UV coordinates and textures, as well as colors and other material properties, to calculate proper reflections and lighting. Some ray tracers use those same elements to implement other behaviors. For example, you can use an alpha texture and a texture lookup to implement opacity in a custom intersection function. How you organize your custom data can affect both the readability and performance of your ray-tracing kernels.\n\nConsider the figure below, which describes one possible way to organize your app’s data. A material consists of multiple pieces of data, stored as textures and constants, that the renderer uses to compute lighting and shading. Each primitive in the geometry can have a different material applied to it. To avoid duplicating material data, the app stores a single copy of each material in a Metal buffer, and stores a material ID for each primitive in a second Metal buffer. A third Metal buffer contains UV data for each primitive. A shader or kernel that uses this data arrangement needs to first fetch the material ID and UV coordinates using the primitive index, and then use the material ID to look up the material data. A more complicated renderer could go a step further for multiple instances of the geometry, using another buffer to hold instanced data.\n\n\n\nRetrieving the data needed to calculate the result requires the kernel to dereference multiple pointers, and to store more intermediate variables. In a complex renderer, the performance penalties for this might be small. On the other hand, when you run an intersector using primitives with custom intersection functions, the intersector might execute multiple intersection tests for each ray. Such functions are often much simpler than shaders, so the penalty for dereferencing additional pointers might be a larger part of the total time executing the kernel.\n\nFor better Metal performance, copy primitive data into the acceleration structures and access it directly in your shaders. Using per-primitive data simplifies your shaders and make them easier to read, and you avoid needing to perform a separate data lookup based on the primitive ID. It also reduces the cost of transversing your data while simultaneously reducing GPU overhead. For kernels or functions that you run frequently on the GPU, or functions that contain many memory operations, use per-primitive data to improve performance.\n\n### Create a data type for the primitive data\n\nStart by defining a structure for your per-primitive data in a file that your project shares between the app’s CPU and shader code. For example, you could define the data structure in the same place where you define the parameter types for your shaders and compute kernels:\n\nA per-primitive data type can store the same types as an argument buffer (see [doc:\/\/com.apple.metal\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers]), including basic scalar types, vector types, and references to Metal resources. Metal doesn’t limit the size of per-primitive data structures, but acceleration structures with large primitive data may need significantly more memory and take longer to create, copy, and refit. The additional data may also affect your shaders’ performance at runtime. For best results, limit the data to values that are the same across multiple instances of the geometry, and store only those values needed to perform the most frequent or expensive tasks.\n\nOne way to reduce a per-primitive structure’s size is by including a pointer to another buffer. Although this approach brings back some of the complexity of the earlier buffered approach, it still provides relatively quick access to data in the secondary structure. Put the data that you need most in the per-primitive structure, and access the secondary structure only when necessary. For better cache performance, pack both structures so that you store values you access at the same time near each other in memory.\n\n### Add the per-primitive data to your acceleration structure\n\nYou add the primitive data to your acceleration structure by including it when you create the acceleration structure. Start by copying the data for the primitives into an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance. Each primitive needs its own instance of the primitive data, stored in linear order.\n\nWhen you configure the geometry descriptor, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataBuffer] property to point to this buffer. If the data doesn’t start at the beginning of the buffer, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataBufferOffset] to the location of the first byte of per-primitive data within the buffer.\n\nNext, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataElementSize] property to the size of your primitive data structure, and the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataStride] property to the number of bytes between two consecutive instances of the per-primitive data in the buffer. The stride property defaults to `0`, which tells Metal the buffer’s stride is the same as the element size.\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor] type defines these properties for its subclasses, which include the following descriptor types:\n\nIn the example below, the method configures per-primitive data for a triangle geometry descriptor with a buffer that contains one instance of the primitive data for each triangle.\n\nWhen you create the acceleration structure, Metal copies the data from the primitive data buffer into the new structure. Afterward, you can delete the primitive data buffer if you don’t have another use for it.\n\n### Access the per-primitive data within a ray-tracing kernel\n\nWhen your ray-tracing kernel calls an intersect method, Metal includes the primitive data for any intersected primitive in the intersection result. Retrieve the data for the primitive by accessing the `primitive_data` field:\n\nIf your implementation uses an intersection function, access the candidate’s primitive data by adding a parameter with the `[[primitive_data]]` attribute:\n\nFinally, if your implementation uses intersection queries, access a primitive’s data by calling the query’s `get_candidate_primitive_data()` and `get_committed_primitive_data()` methods.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/improving-ray-tracing-data-access-using-per-primitive-data\ncrawled: 2025-12-04T02:16:38Z\n---\n\n# Improving ray-tracing data access using per-primitive data\n\n**Article**\n\nSimplify data access and improve GPU utilization by storing custom primitive data directly in the acceleration structure.\n\n## Overview\n\nCreating a ray-traced renderer — or using ray tracing to implement other behaviors — requires more than simple geometry. Your app also needs to provide custom data to your ray-tracing kernels. For example, a renderer might need UV coordinates and textures, as well as colors and other material properties, to calculate proper reflections and lighting. Some ray tracers use those same elements to implement other behaviors. For example, you can use an alpha texture and a texture lookup to implement opacity in a custom intersection function. How you organize your custom data can affect both the readability and performance of your ray-tracing kernels.\n\nConsider the figure below, which describes one possible way to organize your app’s data. A material consists of multiple pieces of data, stored as textures and constants, that the renderer uses to compute lighting and shading. Each primitive in the geometry can have a different material applied to it. To avoid duplicating material data, the app stores a single copy of each material in a Metal buffer, and stores a material ID for each primitive in a second Metal buffer. A third Metal buffer contains UV data for each primitive. A shader or kernel that uses this data arrangement needs to first fetch the material ID and UV coordinates using the primitive index, and then use the material ID to look up the material data. A more complicated renderer could go a step further for multiple instances of the geometry, using another buffer to hold instanced data.\n\n\n\nRetrieving the data needed to calculate the result requires the kernel to dereference multiple pointers, and to store more intermediate variables. In a complex renderer, the performance penalties for this might be small. On the other hand, when you run an intersector using primitives with custom intersection functions, the intersector might execute multiple intersection tests for each ray. Such functions are often much simpler than shaders, so the penalty for dereferencing additional pointers might be a larger part of the total time executing the kernel.\n\nFor better Metal performance, copy primitive data into the acceleration structures and access it directly in your shaders. Using per-primitive data simplifies your shaders and make them easier to read, and you avoid needing to perform a separate data lookup based on the primitive ID. It also reduces the cost of transversing your data while simultaneously reducing GPU overhead. For kernels or functions that you run frequently on the GPU, or functions that contain many memory operations, use per-primitive data to improve performance.\n\n### Create a data type for the primitive data\n\nStart by defining a structure for your per-primitive data in a file that your project shares between the app’s CPU and shader code. For example, you could define the data structure in the same place where you define the parameter types for your shaders and compute kernels:\n\n```objective-c\n#include <simd\/simd.h>\n\nstruct PrimitiveTextureData {\n    uint64_t textureAddress;\n    vector_float2 coordinates[3];\n};\n\nstruct TriangleData {\n    vector_float3 normal0;\n    vector_float3 normal1;\n    vector_float3 normal2;\n\n    vector_float3 color0;\n    vector_float3 color1;\n    vector_float3 color2;\n};\n```\n\nA per-primitive data type can store the same types as an argument buffer (see [doc:\/\/com.apple.metal\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers]), including basic scalar types, vector types, and references to Metal resources. Metal doesn’t limit the size of per-primitive data structures, but acceleration structures with large primitive data may need significantly more memory and take longer to create, copy, and refit. The additional data may also affect your shaders’ performance at runtime. For best results, limit the data to values that are the same across multiple instances of the geometry, and store only those values needed to perform the most frequent or expensive tasks.\n\n\n\nOne way to reduce a per-primitive structure’s size is by including a pointer to another buffer. Although this approach brings back some of the complexity of the earlier buffered approach, it still provides relatively quick access to data in the secondary structure. Put the data that you need most in the per-primitive structure, and access the secondary structure only when necessary. For better cache performance, pack both structures so that you store values you access at the same time near each other in memory.\n\n### Add the per-primitive data to your acceleration structure\n\nYou add the primitive data to your acceleration structure by including it when you create the acceleration structure. Start by copying the data for the primitives into an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance. Each primitive needs its own instance of the primitive data, stored in linear order.\n\nWhen you configure the geometry descriptor, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataBuffer] property to point to this buffer. If the data doesn’t start at the beginning of the buffer, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataBufferOffset] to the location of the first byte of per-primitive data within the buffer.\n\nNext, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataElementSize] property to the size of your primitive data structure, and the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor\/primitiveDataStride] property to the number of bytes between two consecutive instances of the per-primitive data in the buffer. The stride property defaults to `0`, which tells Metal the buffer’s stride is the same as the element size.\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureGeometryDescriptor] type defines these properties for its subclasses, which include the following descriptor types:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureTriangleGeometryDescriptor]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureMotionTriangleGeometryDescriptor]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureCurveGeometryDescriptor]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureMotionCurveGeometryDescriptor]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureBoundingBoxGeometryDescriptor]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor]\n\nIn the example below, the method configures per-primitive data for a triangle geometry descriptor with a buffer that contains one instance of the primitive data for each triangle.\n\n```swift\nfunc configure(geometryDescriptor: MTLAccelerationStructureTriangleGeometryDescriptor,\n               with trianglePrimitiveData: MTLBuffer) {\n    geometryDescriptor.primitiveDataBuffer = trianglePrimitiveData\n    geometryDescriptor.primitiveDataBufferOffset = 0\n    geometryDescriptor.primitiveDataElementSize = MemoryLayout<PrimitiveTextureData>.size\n    geometryDescriptor.primitiveDataStride = MemoryLayout<PrimitiveTextureData>.stride\n}\n```\n\nWhen you create the acceleration structure, Metal copies the data from the primitive data buffer into the new structure. Afterward, you can delete the primitive data buffer if you don’t have another use for it.\n\n### Access the per-primitive data within a ray-tracing kernel\n\nWhen your ray-tracing kernel calls an intersect method, Metal includes the primitive data for any intersected primitive in the intersection result. Retrieve the data for the primitive by accessing the `primitive_data` field:\n\n```metal\n\/\/\/ The GPU invokes this kernel for each ray it casts into the scene.\nkernel void rayTracingKernel(uint2 threadID [[thread_position_in_grid]],\n\/\/ ...\n                             instance_acceleration_structure accelerationStructure [[buffer(4)]],\n                             intersection_function_table<triangle_data, instancing> intersectionFunctionTable [[buffer(5)]]\n                             )\n{\n    \/\/\/ Represents a single ray for a ray-tracing scene.\n    ray ray;\n\n    \/\/\/ An intersector that tests for intersections between the ray and the geometry in the scene.\n    intersector<triangle_data, instancing> triangleIntersector;\n\n    \/\/\/ The result value type that represents an intersection with the scene's geometry.\n    intersector<triangle_data, instancing>::result_type result;\n\n    ...\n\n    \/\/ Test the ray for intersection with an acceleration structure's geometry.\n    result = triangleIntersector.intersect(ray, accelerationStructure);\n\n    if (result.type != intersection_type::none) {\n        const device PrimitiveTextureData *textureData;\n\n        \/\/ Retrieve the data that's specific to the triangle the ray intersects.\n        textureData = (const device PrimitiveTextureData *) result.primitive_data;\n\n        vector_float2 uv = textureData->coordinates;\n        uint64_t texture = textureData->textureAddress;\n\n        ...\n    }\n}\n```\n\nIf your implementation uses an intersection function, access the candidate’s primitive data by adding a parameter with the `[[primitive_data]]` attribute:\n\n```metal\n\/\/\/ The intersection function for the triangle's kernel.\n[[intersection(triangle)]]\nbool triangle_intersection_function(const device PrimitiveTextureData *textureData [[primitive_data]]\n                                    ... ) {\n    ...\n\n    return true;\n}\n```\n\nFinally, if your implementation uses intersection queries, access a primitive’s data by calling the query’s `get_candidate_primitive_data()` and `get_committed_primitive_data()` methods.\n\n```metal\nintersection_query<triangle_data, instancing> query;\n\nconst device PrimitiveTextureData* candidatePrimitiveData;\nconst device PrimitiveTextureData* committedPrimitiveData;\n\n...\n\ncandidatePrimitiveData = (const device PrimitiveTextureData *) query.get_candidate_primitive_data();\n\n...\n\ncommittedPrimitiveData = (const device PrimitiveTextureData *) query.get_committed_primitive_data();\n```\n\n\n\n## Acceleration structures\n\n- **MTLAccelerationStructure**: A collection of model data for GPU-accelerated intersection of rays with the model.\n- **MTL4AccelerationStructureDescriptor**: Base class for Metal 4 acceleration structure descriptors.\n- **MTLAccelerationStructureDescriptor**: A base class for classes that define the configuration for a new acceleration structure.\n- **MTL4PrimitiveAccelerationStructureDescriptor**: Descriptor for a primitive acceleration structure that directly references geometric shapes, such as triangles and bounding boxes.\n- **MTLPrimitiveAccelerationStructureDescriptor**: A description of an acceleration structure that contains geometry primitives.\n- **MTL4InstanceAccelerationStructureDescriptor**: Descriptor for an instance acceleration structure.\n- **MTLInstanceAccelerationStructureDescriptor**: A description of an acceleration structure that derives from instances of primitive acceleration structures.\n- **MTLAccelerationStructureCommandEncoder**: Encodes commands that build and refit acceleration structures for a single pass.\n- **MTLAccelerationStructureUsage**: Options that affect how Metal builds an acceleration structure and the behavior of that acceleration structure.\n- **MTLAccelerationStructureRefitOptions**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A collection of model data for GPU-accelerated intersection of rays with the model.",
          "name" : "MTLAccelerationStructure",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAccelerationStructure"
        },
        {
          "description" : "Base class for Metal 4 acceleration structure descriptors.",
          "name" : "MTL4AccelerationStructureDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4AccelerationStructureDescriptor"
        },
        {
          "description" : "A base class for classes that define the configuration for a new acceleration structure.",
          "name" : "MTLAccelerationStructureDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAccelerationStructureDescriptor"
        },
        {
          "description" : "Descriptor for a primitive acceleration structure that directly references geometric shapes, such as triangles and bounding boxes.",
          "name" : "MTL4PrimitiveAccelerationStructureDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4PrimitiveAccelerationStructureDescriptor"
        },
        {
          "description" : "A description of an acceleration structure that contains geometry primitives.",
          "name" : "MTLPrimitiveAccelerationStructureDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLPrimitiveAccelerationStructureDescriptor"
        },
        {
          "description" : "Descriptor for an instance acceleration structure.",
          "name" : "MTL4InstanceAccelerationStructureDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTL4InstanceAccelerationStructureDescriptor"
        },
        {
          "description" : "A description of an acceleration structure that derives from instances of primitive acceleration structures.",
          "name" : "MTLInstanceAccelerationStructureDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLInstanceAccelerationStructureDescriptor"
        },
        {
          "description" : "Encodes commands that build and refit acceleration structures for a single pass.",
          "name" : "MTLAccelerationStructureCommandEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAccelerationStructureCommandEncoder"
        },
        {
          "description" : "Options that affect how Metal builds an acceleration structure and the behavior of that acceleration structure.",
          "name" : "MTLAccelerationStructureUsage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAccelerationStructureUsage"
        },
        {
          "description" : "",
          "name" : "MTLAccelerationStructureRefitOptions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAccelerationStructureRefitOptions"
        }
      ],
      "title" : "Acceleration structures"
    }
  ],
  "source" : "appleJSON",
  "title" : "Improving ray-tracing data access using per-primitive data",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-ray-tracing-data-access-using-per-primitive-data"
}