{
  "abstract" : "Create pipelines for different levels of detail from a common shader source.",
  "codeExamples" : [
    {
      "code" : "+ (BOOL)isTexturedProperty:(AAPLFunctionConstant)propertyIndex atQualityLevel:(AAPLQualityLevel)quality\n{\n    AAPLQualityLevel minLevelForProperty = AAPLQualityLevelHigh;\n\n    switch(propertyIndex)\n    {\n        case AAPLFunctionConstantBaseColorMapIndex:\n        case AAPLFunctionConstantIrradianceMapIndex:\n            minLevelForProperty = AAPLQualityLevelMedium;\n            break;\n        default:\n            break;\n    }\n\n    return quality <= minLevelForProperty;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "constant bool has_base_color_map        [[ function_constant(AAPLFunctionConstantBaseColorMapIndex) ]];\nconstant bool has_normal_map            [[ function_constant(AAPLFunctionConstantNormalMapIndex) ]];\nconstant bool has_metallic_map          [[ function_constant(AAPLFunctionConstantMetallicMapIndex) ]];\nconstant bool has_roughness_map         [[ function_constant(AAPLFunctionConstantRoughnessMapIndex) ]];\nconstant bool has_ambient_occlusion_map [[ function_constant(AAPLFunctionConstantAmbientOcclusionMapIndex) ]];\nconstant bool has_irradiance_map        [[ function_constant(AAPLFunctionConstantIrradianceMapIndex) ]];",
      "language" : "metal"
    },
    {
      "code" : "constant bool has_any_map = (has_base_color_map        ||\n                             has_normal_map            ||\n                             has_metallic_map          ||\n                             has_roughness_map         ||\n                             has_ambient_occlusion_map ||\n                             has_irradiance_map);",
      "language" : "metal"
    },
    {
      "code" : "if (has_any_map)\n{\n    out.texCoord = in.texCoord;\n}",
      "language" : "metal"
    },
    {
      "code" : "LightingParameters calculateParameters(                 ColorInOut in,\n                                       constant AAPLFrameData    & frameData,\n                                       constant AAPLMaterialData & materialData,\n                                       texture2d<float>   baseColorMap        [[ function_constant(has_base_color_map) ]],\n                                       texture2d<float>   normalMap           [[ function_constant(has_normal_map) ]],\n                                       texture2d<float>   metallicMap         [[ function_constant(has_metallic_map) ]],\n                                       texture2d<float>   roughnessMap        [[ function_constant(has_roughness_map) ]],\n                                       texture2d<float>   ambientOcclusionMap [[ function_constant(has_ambient_occlusion_map) ]],\n                                       texturecube<float> irradianceMap       [[ function_constant(has_irradiance_map) ]])",
      "language" : "metal"
    },
    {
      "code" : "fragment float4\nfragmentLighting(                 ColorInOut in           [[ stage_in ]],\n                 constant AAPLFrameData    & frameData    [[ buffer(AAPLBufferIndexFrameData) ]],\n                 constant AAPLMaterialData & materialData [[ buffer(AAPLBufferIndexMaterialData) ]],\n                 texture2d<float>   baseColorMap          [[ texture(AAPLTextureIndexBaseColor),        function_constant(has_base_color_map) ]],\n                 texture2d<float>   normalMap             [[ texture(AAPLTextureIndexNormal),           function_constant(has_normal_map) ]],\n                 texture2d<float>   metallicMap           [[ texture(AAPLTextureIndexMetallic),         function_constant(has_metallic_map) ]],\n                 texture2d<float>   roughnessMap          [[ texture(AAPLTextureIndexRoughness),        function_constant(has_roughness_map) ]],\n                 texture2d<float>   ambientOcclusionMap   [[ texture(AAPLTextureIndexAmbientOcclusion), function_constant(has_ambient_occlusion_map) ]],\n                 texturecube<float> irradianceMap         [[ texture(AAPLTextureIndexIrradianceMap),    function_constant(has_irradiance_map)]])",
      "language" : "metal"
    },
    {
      "code" : "for (uint qualityLevel = 0; qualityLevel < AAPLNumQualityLevels; qualityLevel++)\n{\n    dispatch_group_enter(specializationGroup);\n\n    MTLFunctionConstantValues* constantValues = [self functionConstantsForQualityLevel:qualityLevel];\n\n    [defaultLibrary newFunctionWithName:@\"fragmentLighting\" constantValues:constantValues\n                      completionHandler:^(id<MTLFunction> newFunction, NSError *error )\n     {\n         NSAssert(newFunction, @\"Failed to specialize function: %@\", error);\n\n         self->_fragmentFunctions[qualityLevel] = newFunction;\n         dispatch_group_leave(specializationGroup);\n     }];\n\n    dispatch_group_enter(specializationGroup);\n\n    [defaultLibrary newFunctionWithName:@\"vertexTransform\" constantValues:constantValues\n                      completionHandler:^(id<MTLFunction> newFunction, NSError *error )\n     {\n         NSAssert(newFunction, @\"Failed to specialize function: %@\", error);\n\n         self->_vertexFunctions[qualityLevel] = newFunction;\n         dispatch_group_leave(specializationGroup);\n     }];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "dispatch_group_enter(_pipelineCreationGroup);\n\nvoid (^notifyBlock)(void) = ^void()\n{\n    const id<MTLDevice> device  = self->_device;\n    const dispatch_group_t pipelineCreationGroup = self->_pipelineCreationGroup;\n\n    MTLRenderPipelineDescriptor *pipelineStateDescriptors[AAPLNumQualityLevels];\n\n    dispatch_group_wait(specializationGroup, DISPATCH_TIME_FOREVER);\n\n    for (uint qualityLevel = 0; qualityLevel < AAPLNumQualityLevels; qualityLevel++)\n    {\n        dispatch_group_enter(pipelineCreationGroup);\n\n        pipelineStateDescriptors[qualityLevel] = [pipelineStateDescriptor copy];\n        pipelineStateDescriptors[qualityLevel].fragmentFunction = self->_fragmentFunctions[qualityLevel];\n        pipelineStateDescriptors[qualityLevel].vertexFunction = self->_vertexFunctions[qualityLevel];\n\n        [device newRenderPipelineStateWithDescriptor:pipelineStateDescriptors[qualityLevel]\n                                   completionHandler:^(id<MTLRenderPipelineState> newPipelineState, NSError *error )\n         {\n             NSAssert(newPipelineState, @\"Failed to create pipeline state, error %@\", error);\n\n             self->_pipelineStates[qualityLevel] = newPipelineState;\n             dispatch_group_leave(pipelineCreationGroup);\n         }];\n    }\n\n    dispatch_group_leave(pipelineCreationGroup);\n};\n\ndispatch_group_notify(specializationGroup, pipelineQueue, notifyBlock);",
      "language" : "objective-c"
    },
    {
      "code" : "- (void)calculateQualityAtDistance:(float)distance\n{\n    static const float MediumQualityDepth     = 150.f;\n    static const float LowQualityDepth        = 650.f;\n    static const float TransitionDepthAmount  = 50.f;\n\n    assert(distance >= 0.0f);\n    if (distance < MediumQualityDepth)\n    {\n        static const float TransitionDepth = MediumQualityDepth - TransitionDepthAmount;\n        if(distance > TransitionDepth)\n        {\n            _globalMapWeight = distance - TransitionDepth;\n            _globalMapWeight \/= TransitionDepthAmount;\n            _globalMapWeight = 1.0 - _globalMapWeight;\n        }\n        else\n        {\n            _globalMapWeight = 1.0;\n        }\n        _currentQualityLevel = AAPLQualityLevelHigh;\n    }\n    else if (distance < LowQualityDepth)\n    {\n        static const float TransitionDepth = LowQualityDepth - TransitionDepthAmount;\n        if(distance > TransitionDepth)\n        {\n            _globalMapWeight = distance - (TransitionDepth);\n            _globalMapWeight \/= TransitionDepthAmount;\n            _globalMapWeight = 1.0 - _globalMapWeight;\n        }\n        else\n        {\n            _globalMapWeight = 1.0;\n        }\n        _currentQualityLevel = AAPLQualityLevelMedium;\n    }\n    else\n    {\n        _currentQualityLevel = AAPLQualityLevelLow;\n        _globalMapWeight = 0.0;\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder setRenderPipelineState:_pipelineStates[_currentQualityLevel]];",
      "language" : "objective-c"
    },
    {
      "code" : "[submesh computeTextureWeightsForQualityLevel:_currentQualityLevel\n                          withGlobalMapWeight:_globalMapWeight];",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder drawIndexedPrimitives:metalKitSubmesh.primitiveType\n                          indexCount:metalKitSubmesh.indexCount\n                           indexType:metalKitSubmesh.indexType\n                         indexBuffer:metalKitSubmesh.indexBuffer.buffer\n                   indexBufferOffset:metalKitSubmesh.indexBuffer.offset];",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "4cc7c50b35330bcd116d3dbcbcf9e27e6015854c98835d9ad2d21abc256894f3",
  "crawledAt" : "2025-12-02T15:49:47Z",
  "id" : "0BEDC0AE-F580-4423-B232-51534E05F971",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nA high-quality gaming experience has to manage trade-offs between great graphics and great performance. High-quality models look great, but their complexity requires a significant amount of processing power. By increasing or decreasing the level of detail (LOD) of a model, games can selectively manage both graphics and performance.\n\n\n\nInstead of selecting a fixed LOD at build time, games can dynamically select between a range of LODs at runtime based on certain model-view conditions. For example, a focal-point foreground model could have a high LOD, whereas a fast-moving background model could have a low LOD.\n\nThis sample demonstrates dynamic LOD selection for a fire truck model, based on its distance from the scene’s camera. When the model is closer to the camera, the renderer uses a higher LOD; when the model is further from the camera, the renderer uses a lower LOD.\n\n\n\n### Getting started\n\nThe Xcode project contains schemes for running the sample on macOS, iOS, or tvOS.\n\n### GPU branch statements\n\nUnlike CPU code, graphics processing unit (GPU) branch statements like `if` and `else` are very expensive. The massively parallel architecture of GPUs isn’t particularly well suited to handling GPU functions that have many branches. More branches result in more register allocations and thus decrease the number of GPU threads that can execute concurrently. Nevertheless, branch statements are useful programming constructs, particularly for functions that share a lot of code. In fact, a common problem for graphics functions that share code is how to handle a branch condition that differs only between draw calls, not between individual threads executing within a single draw call.\n\nTraditionally, branches that differ between draw calls are mitigated in one of these ways:\n\nThe Metal *function specialization* feature reduces branch performance costs, avoids code duplication, and leverages build time compilation. Function specialization allows you to create multiple executable versions of a single source function. You create specialized functions by declaring *function constants* in your Metal shading language code and setting their values at runtime. Doing so allows the front-end compiler to precompile your source function at build time and the back-end compiler to compile the specialized function at runtime, when the pipeline is created.\n\n### Define your LOD selection criteria\n\nThis sample demonstrates function specialization by creating different render pipelines for different LODs. All of the pipelines share the same source function, but function constants determine LOD-specific paths and inputs for each pipeline. Specifically, the sample demonstrates dynamic LOD selection for a fire truck model, based on its distance from the scene’s camera. When the fire truck is close to the camera, it occupies more pixels on the screen; therefore, the sample uses a high-quality render pipeline. When the fire truck is far from the camera, it occupies fewer pixels on the screen; therefore, the sample uses a low-quality render pipeline.\n\nThe fire truck model in this sample uses many types of textures, such as *albedo*, *normal*, *metallic*, *roughness*, *ambient occlusion*, and *irradiance*. It’s too wasteful to sample from each of these textures when the model is far from the camera because the detail provided by the full combination of textures isn’t seen. The sample uses various function constant values to create specialized functions that sample from more or fewer textures, depending on the selected LOD. Additionally, specialized functions that sample from fewer textures also perform less complex computations and result in a faster render pipeline.\n\nThe `isTexturedProperty:atQualityLevel:` method controls whether a material property is set by sampling from a texture or by reading a constant value.\n\n### Implement specialized functions\n\nThe sample uses six function constants to control the various inputs available to the `fragmentLighting` fragment function.\n\nThe sample also declares a derived function constant, `has_any_map`, that’s used in the `vertexTransform` vertex function. This value determines whether the render pipeline requires the vertex function to output a texture coordinate to the `ColorInOut.texCoord` return value.\n\nWhen the value of `has_any_map` is `false`, the vertex function does not write a value to the `texCoord` member.\n\nThe function constants control the source of a parameter to the lighting computation in the `calculateParameters()` function. When you use the  `[[function_constant(index)]]` attribute, this function can determine whether it should sample from a texture. The function only samples from a texture if the attribute indicates that a texture parameter is present; otherwise, it reads a value from the `materialData` buffer.\n\nThe corresponding inputs to the fragment function also use the same function constants.\n\n### Create different pipelines\n\nThis sample uses three different `MTLRenderPipelineState` objects, each representing a different LOD. Specializing functions and building pipelines is expensive, so the sample performs these tasks asynchronously before starting the render loop. When the `AAPLRenderer` object is initialized, each LOD pipeline is created asynchronously by using dispatch groups, completion handlers, and notification blocks.\n\nThe sample creates six specialized functions overall: one vertex and one fragment function for each of the three LODs. This task is monitored by the `specializationGroup` dispatch group, and each function is specialized by calling the `newFunctionWithName:constantValues:completionHandler:` method.\n\nThe `notifyBlock` block builds the three render pipelines. This task is monitored by the `_pipelineCreationGroup` dispatch group, and each pipeline is built by calling the `newRenderPipelineStateWithDescriptor:completionHandler:` method.\n\n### Render with a specific LOD\n\nAt the beginning of the render loop, for each frame, the sample calls the `_calculateQualityAtDistance:` method to update the `_currentQualityLevel` value. This value defines the LOD for the frame based on the distance between the model and the camera. The `_calculateQualityAtDistance:` method also sets a `_globalMapWeight` value that creates a smooth transition between LOD boundaries.\n\nThe updated `_currentQualityLevel` value is used to set the corresponding `MTLRenderPipelineState` object for the frame.\n\nThe updated `_globalMapWeight` value is used to interpolate between quality levels and prevent abrupt LOD transitions.\n\nFinally, the render loop draws each submesh in the model with the specific LOD pipeline.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/using-function-specialization-to-build-pipeline-variants\ncrawled: 2025-12-02T15:49:47Z\n---\n\n# Using function specialization to build pipeline variants\n\n**Sample Code**\n\nCreate pipelines for different levels of detail from a common shader source.\n\n## Overview\n\nA high-quality gaming experience has to manage trade-offs between great graphics and great performance. High-quality models look great, but their complexity requires a significant amount of processing power. By increasing or decreasing the level of detail (LOD) of a model, games can selectively manage both graphics and performance.\n\n\n\nInstead of selecting a fixed LOD at build time, games can dynamically select between a range of LODs at runtime based on certain model-view conditions. For example, a focal-point foreground model could have a high LOD, whereas a fast-moving background model could have a low LOD.\n\nThis sample demonstrates dynamic LOD selection for a fire truck model, based on its distance from the scene’s camera. When the model is closer to the camera, the renderer uses a higher LOD; when the model is further from the camera, the renderer uses a lower LOD.\n\n\n\n### Getting started\n\nThe Xcode project contains schemes for running the sample on macOS, iOS, or tvOS.\n\n### GPU branch statements\n\nUnlike CPU code, graphics processing unit (GPU) branch statements like `if` and `else` are very expensive. The massively parallel architecture of GPUs isn’t particularly well suited to handling GPU functions that have many branches. More branches result in more register allocations and thus decrease the number of GPU threads that can execute concurrently. Nevertheless, branch statements are useful programming constructs, particularly for functions that share a lot of code. In fact, a common problem for graphics functions that share code is how to handle a branch condition that differs only between draw calls, not between individual threads executing within a single draw call.\n\nTraditionally, branches that differ between draw calls are mitigated in one of these ways:\n\n- Writing per-branch functions. Each branch is written as a complete and separate function, and the render loop determines which function to use at runtime. This approach greatly increases code duplication because all possible outcomes of each branch condition require their own standalone function. For example, a single `if` statement requires one function for the `true` outcome and another function for the `false` outcome.\n- Using preprocessor directives. Instead of using a regular `if` statement, functions can use the `#if` preprocessor directive that selectively compiles a function after evaluating its branch conditions. This approach avoids code duplication but reduces the performance benefits of precompiled Metal shading language code. Because the branch conditions can only be evaluated at runtime, the functions can’t be precompiled at build time.\n\nThe Metal *function specialization* feature reduces branch performance costs, avoids code duplication, and leverages build time compilation. Function specialization allows you to create multiple executable versions of a single source function. You create specialized functions by declaring *function constants* in your Metal shading language code and setting their values at runtime. Doing so allows the front-end compiler to precompile your source function at build time and the back-end compiler to compile the specialized function at runtime, when the pipeline is created.\n\n### Define your LOD selection criteria\n\nThis sample demonstrates function specialization by creating different render pipelines for different LODs. All of the pipelines share the same source function, but function constants determine LOD-specific paths and inputs for each pipeline. Specifically, the sample demonstrates dynamic LOD selection for a fire truck model, based on its distance from the scene’s camera. When the fire truck is close to the camera, it occupies more pixels on the screen; therefore, the sample uses a high-quality render pipeline. When the fire truck is far from the camera, it occupies fewer pixels on the screen; therefore, the sample uses a low-quality render pipeline.\n\nThe fire truck model in this sample uses many types of textures, such as *albedo*, *normal*, *metallic*, *roughness*, *ambient occlusion*, and *irradiance*. It’s too wasteful to sample from each of these textures when the model is far from the camera because the detail provided by the full combination of textures isn’t seen. The sample uses various function constant values to create specialized functions that sample from more or fewer textures, depending on the selected LOD. Additionally, specialized functions that sample from fewer textures also perform less complex computations and result in a faster render pipeline.\n\nThe `isTexturedProperty:atQualityLevel:` method controls whether a material property is set by sampling from a texture or by reading a constant value.\n\n```objective-c\n+ (BOOL)isTexturedProperty:(AAPLFunctionConstant)propertyIndex atQualityLevel:(AAPLQualityLevel)quality\n{\n    AAPLQualityLevel minLevelForProperty = AAPLQualityLevelHigh;\n\n    switch(propertyIndex)\n    {\n        case AAPLFunctionConstantBaseColorMapIndex:\n        case AAPLFunctionConstantIrradianceMapIndex:\n            minLevelForProperty = AAPLQualityLevelMedium;\n            break;\n        default:\n            break;\n    }\n\n    return quality <= minLevelForProperty;\n}\n```\n\n### Implement specialized functions\n\nThe sample uses six function constants to control the various inputs available to the `fragmentLighting` fragment function.\n\n```metal\nconstant bool has_base_color_map        [[ function_constant(AAPLFunctionConstantBaseColorMapIndex) ]];\nconstant bool has_normal_map            [[ function_constant(AAPLFunctionConstantNormalMapIndex) ]];\nconstant bool has_metallic_map          [[ function_constant(AAPLFunctionConstantMetallicMapIndex) ]];\nconstant bool has_roughness_map         [[ function_constant(AAPLFunctionConstantRoughnessMapIndex) ]];\nconstant bool has_ambient_occlusion_map [[ function_constant(AAPLFunctionConstantAmbientOcclusionMapIndex) ]];\nconstant bool has_irradiance_map        [[ function_constant(AAPLFunctionConstantIrradianceMapIndex) ]];\n```\n\nThe sample also declares a derived function constant, `has_any_map`, that’s used in the `vertexTransform` vertex function. This value determines whether the render pipeline requires the vertex function to output a texture coordinate to the `ColorInOut.texCoord` return value.\n\n```metal\nconstant bool has_any_map = (has_base_color_map        ||\n                             has_normal_map            ||\n                             has_metallic_map          ||\n                             has_roughness_map         ||\n                             has_ambient_occlusion_map ||\n                             has_irradiance_map);\n```\n\nWhen the value of `has_any_map` is `false`, the vertex function does not write a value to the `texCoord` member.\n\n```metal\nif (has_any_map)\n{\n    out.texCoord = in.texCoord;\n}\n```\n\nThe function constants control the source of a parameter to the lighting computation in the `calculateParameters()` function. When you use the  `[[function_constant(index)]]` attribute, this function can determine whether it should sample from a texture. The function only samples from a texture if the attribute indicates that a texture parameter is present; otherwise, it reads a value from the `materialData` buffer.\n\n```metal\nLightingParameters calculateParameters(                 ColorInOut in,\n                                       constant AAPLFrameData    & frameData,\n                                       constant AAPLMaterialData & materialData,\n                                       texture2d<float>   baseColorMap        [[ function_constant(has_base_color_map) ]],\n                                       texture2d<float>   normalMap           [[ function_constant(has_normal_map) ]],\n                                       texture2d<float>   metallicMap         [[ function_constant(has_metallic_map) ]],\n                                       texture2d<float>   roughnessMap        [[ function_constant(has_roughness_map) ]],\n                                       texture2d<float>   ambientOcclusionMap [[ function_constant(has_ambient_occlusion_map) ]],\n                                       texturecube<float> irradianceMap       [[ function_constant(has_irradiance_map) ]])\n```\n\nThe corresponding inputs to the fragment function also use the same function constants.\n\n```metal\nfragment float4\nfragmentLighting(                 ColorInOut in           [[ stage_in ]],\n                 constant AAPLFrameData    & frameData    [[ buffer(AAPLBufferIndexFrameData) ]],\n                 constant AAPLMaterialData & materialData [[ buffer(AAPLBufferIndexMaterialData) ]],\n                 texture2d<float>   baseColorMap          [[ texture(AAPLTextureIndexBaseColor),        function_constant(has_base_color_map) ]],\n                 texture2d<float>   normalMap             [[ texture(AAPLTextureIndexNormal),           function_constant(has_normal_map) ]],\n                 texture2d<float>   metallicMap           [[ texture(AAPLTextureIndexMetallic),         function_constant(has_metallic_map) ]],\n                 texture2d<float>   roughnessMap          [[ texture(AAPLTextureIndexRoughness),        function_constant(has_roughness_map) ]],\n                 texture2d<float>   ambientOcclusionMap   [[ texture(AAPLTextureIndexAmbientOcclusion), function_constant(has_ambient_occlusion_map) ]],\n                 texturecube<float> irradianceMap         [[ texture(AAPLTextureIndexIrradianceMap),    function_constant(has_irradiance_map)]])\n```\n\n### Create different pipelines\n\nThis sample uses three different `MTLRenderPipelineState` objects, each representing a different LOD. Specializing functions and building pipelines is expensive, so the sample performs these tasks asynchronously before starting the render loop. When the `AAPLRenderer` object is initialized, each LOD pipeline is created asynchronously by using dispatch groups, completion handlers, and notification blocks.\n\nThe sample creates six specialized functions overall: one vertex and one fragment function for each of the three LODs. This task is monitored by the `specializationGroup` dispatch group, and each function is specialized by calling the `newFunctionWithName:constantValues:completionHandler:` method.\n\n```objective-c\nfor (uint qualityLevel = 0; qualityLevel < AAPLNumQualityLevels; qualityLevel++)\n{\n    dispatch_group_enter(specializationGroup);\n\n    MTLFunctionConstantValues* constantValues = [self functionConstantsForQualityLevel:qualityLevel];\n\n    [defaultLibrary newFunctionWithName:@\"fragmentLighting\" constantValues:constantValues\n                      completionHandler:^(id<MTLFunction> newFunction, NSError *error )\n     {\n         NSAssert(newFunction, @\"Failed to specialize function: %@\", error);\n\n         self->_fragmentFunctions[qualityLevel] = newFunction;\n         dispatch_group_leave(specializationGroup);\n     }];\n\n    dispatch_group_enter(specializationGroup);\n\n    [defaultLibrary newFunctionWithName:@\"vertexTransform\" constantValues:constantValues\n                      completionHandler:^(id<MTLFunction> newFunction, NSError *error )\n     {\n         NSAssert(newFunction, @\"Failed to specialize function: %@\", error);\n\n         self->_vertexFunctions[qualityLevel] = newFunction;\n         dispatch_group_leave(specializationGroup);\n     }];\n}\n```\n\nThe `notifyBlock` block builds the three render pipelines. This task is monitored by the `_pipelineCreationGroup` dispatch group, and each pipeline is built by calling the `newRenderPipelineStateWithDescriptor:completionHandler:` method.\n\n```objective-c\ndispatch_group_enter(_pipelineCreationGroup);\n\nvoid (^notifyBlock)(void) = ^void()\n{\n    const id<MTLDevice> device  = self->_device;\n    const dispatch_group_t pipelineCreationGroup = self->_pipelineCreationGroup;\n\n    MTLRenderPipelineDescriptor *pipelineStateDescriptors[AAPLNumQualityLevels];\n\n    dispatch_group_wait(specializationGroup, DISPATCH_TIME_FOREVER);\n\n    for (uint qualityLevel = 0; qualityLevel < AAPLNumQualityLevels; qualityLevel++)\n    {\n        dispatch_group_enter(pipelineCreationGroup);\n\n        pipelineStateDescriptors[qualityLevel] = [pipelineStateDescriptor copy];\n        pipelineStateDescriptors[qualityLevel].fragmentFunction = self->_fragmentFunctions[qualityLevel];\n        pipelineStateDescriptors[qualityLevel].vertexFunction = self->_vertexFunctions[qualityLevel];\n\n        [device newRenderPipelineStateWithDescriptor:pipelineStateDescriptors[qualityLevel]\n                                   completionHandler:^(id<MTLRenderPipelineState> newPipelineState, NSError *error )\n         {\n             NSAssert(newPipelineState, @\"Failed to create pipeline state, error %@\", error);\n\n             self->_pipelineStates[qualityLevel] = newPipelineState;\n             dispatch_group_leave(pipelineCreationGroup);\n         }];\n    }\n\n    dispatch_group_leave(pipelineCreationGroup);\n};\n\ndispatch_group_notify(specializationGroup, pipelineQueue, notifyBlock);\n```\n\n### Render with a specific LOD\n\nAt the beginning of the render loop, for each frame, the sample calls the `_calculateQualityAtDistance:` method to update the `_currentQualityLevel` value. This value defines the LOD for the frame based on the distance between the model and the camera. The `_calculateQualityAtDistance:` method also sets a `_globalMapWeight` value that creates a smooth transition between LOD boundaries.\n\n```objective-c\n- (void)calculateQualityAtDistance:(float)distance\n{\n    static const float MediumQualityDepth     = 150.f;\n    static const float LowQualityDepth        = 650.f;\n    static const float TransitionDepthAmount  = 50.f;\n\n    assert(distance >= 0.0f);\n    if (distance < MediumQualityDepth)\n    {\n        static const float TransitionDepth = MediumQualityDepth - TransitionDepthAmount;\n        if(distance > TransitionDepth)\n        {\n            _globalMapWeight = distance - TransitionDepth;\n            _globalMapWeight \/= TransitionDepthAmount;\n            _globalMapWeight = 1.0 - _globalMapWeight;\n        }\n        else\n        {\n            _globalMapWeight = 1.0;\n        }\n        _currentQualityLevel = AAPLQualityLevelHigh;\n    }\n    else if (distance < LowQualityDepth)\n    {\n        static const float TransitionDepth = LowQualityDepth - TransitionDepthAmount;\n        if(distance > TransitionDepth)\n        {\n            _globalMapWeight = distance - (TransitionDepth);\n            _globalMapWeight \/= TransitionDepthAmount;\n            _globalMapWeight = 1.0 - _globalMapWeight;\n        }\n        else\n        {\n            _globalMapWeight = 1.0;\n        }\n        _currentQualityLevel = AAPLQualityLevelMedium;\n    }\n    else\n    {\n        _currentQualityLevel = AAPLQualityLevelLow;\n        _globalMapWeight = 0.0;\n    }\n}\n```\n\nThe updated `_currentQualityLevel` value is used to set the corresponding `MTLRenderPipelineState` object for the frame.\n\n```objective-c\n[renderEncoder setRenderPipelineState:_pipelineStates[_currentQualityLevel]];\n```\n\nThe updated `_globalMapWeight` value is used to interpolate between quality levels and prevent abrupt LOD transitions.\n\n```objective-c\n[submesh computeTextureWeightsForQualityLevel:_currentQualityLevel\n                          withGlobalMapWeight:_globalMapWeight];\n```\n\nFinally, the render loop draws each submesh in the model with the specific LOD pipeline.\n\n```objective-c\n[renderEncoder drawIndexedPrimitives:metalKitSubmesh.primitiveType\n                          indexCount:metalKitSubmesh.indexCount\n                           indexType:metalKitSubmesh.indexType\n                         indexBuffer:metalKitSubmesh.indexBuffer.buffer\n                   indexBufferOffset:metalKitSubmesh.indexBuffer.offset];\n```\n\n## Shader compilation and libraries\n\n- **Using the Metal 4 compilation API**: Control when and how you compile an app’s shaders.\n- **Shader libraries**: Manage and load your app’s Metal shaders.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Control when and how you compile an app’s shaders.",
          "name" : "Using the Metal 4 compilation API",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-the-metal-4-compilation-api"
        },
        {
          "description" : "Manage and load your app’s Metal shaders.",
          "name" : "Shader libraries",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/shader-libraries"
        }
      ],
      "title" : "Shader compilation and libraries"
    }
  ],
  "source" : "appleJSON",
  "title" : "Using function specialization to build pipeline variants",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-function-specialization-to-build-pipeline-variants"
}