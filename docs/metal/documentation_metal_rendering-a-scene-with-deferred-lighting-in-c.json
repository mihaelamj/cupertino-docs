{
  "abstract" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
  "codeExamples" : [
    {
      "code" : "#define USE_EYE_DEPTH              1\n#define LIGHT_STENCIL_CULLING      1\n#define SUPPORT_BUFFER_EXAMINATION 1",
      "language" : "cpp"
    },
    {
      "code" : "MTL::RenderCommandEncoder* pRenderEncoder = pCommandBuffer->renderCommandEncoder(m_pViewRenderPassDescriptor);\npRenderEncoder->setLabel( AAPLSTR( \"Combined GBuffer & Lighting Pass\" ) );\n\nRenderer::drawGBuffer( pRenderEncoder );\n\ndrawDirectionalLight( pRenderEncoder );\n\nRenderer::drawPointLightMask( pRenderEncoder );\n\ndrawPointLights( pRenderEncoder );\n\nRenderer::drawSky( pRenderEncoder );\n\nRenderer::drawFairies( pRenderEncoder );\n\npRenderEncoder->endEncoding();",
      "language" : "cpp"
    },
    {
      "code" : "MTL::RenderCommandEncoder* pRenderEncoder = pCommandBuffer->renderCommandEncoder( m_pGBufferRenderPassDescriptor );\npRenderEncoder->setLabel( AAPLSTR( \"GBuffer Generation\" ) );\n\nRenderer::drawGBuffer( pRenderEncoder );\n\npRenderEncoder->endEncoding();",
      "language" : "cpp"
    },
    {
      "code" : "MTL::RenderCommandEncoder* pRenderEncoder = pCommandBuffer->renderCommandEncoder( m_pFinalRenderPassDescriptor );\npRenderEncoder->setLabel( AAPLSTR( \"Lighting & Composition Pass\" ) );\n\ndrawDirectionalLight( pRenderEncoder );\n\nRenderer::drawPointLightMask( pRenderEncoder );\n\ndrawPointLights( pRenderEncoder );\n\nRenderer::drawSky( pRenderEncoder );\n\nRenderer::drawFairies( pRenderEncoder );\n\npRenderEncoder->endEncoding();",
      "language" : "cpp"
    },
    {
      "code" : "MTL::RenderPipelineDescriptor* pRenderPipelineDescriptor = MTL::RenderPipelineDescriptor::alloc()->init();\npRenderPipelineDescriptor->setLabel( AAPLSTR( \"Shadow Gen\" ) );\npRenderPipelineDescriptor->setVertexDescriptor( nullptr );\npRenderPipelineDescriptor->setVertexFunction( pShadowVertexFunction );\npRenderPipelineDescriptor->setFragmentFunction( nullptr );\npRenderPipelineDescriptor->setDepthAttachmentPixelFormat( shadowMapPixelFormat );\n\nm_pShadowGenPipelineState = m_pDevice->newRenderPipelineState( pRenderPipelineDescriptor, &pError );",
      "language" : "cpp"
    },
    {
      "code" : "pEncoder->setDepthBias( 0.015, 7, 0.02 );",
      "language" : "cpp"
    },
    {
      "code" : "half shadow_sample = shadowMap.sample_compare(shadowSampler, in.shadow_uv, in.shadow_depth);",
      "language" : "metal"
    },
    {
      "code" : "gBuffer.normal_shadow = half4(eye_normal.xyz, shadow_sample);",
      "language" : "metal"
    },
    {
      "code" : "m_GBufferStorageMode = MTL::StorageModeMemoryless;",
      "language" : "cpp"
    },
    {
      "code" : "fragment half4\ndeferred_directional_lighting_fragment_traditional(\n    QuadInOut            in                      [[ stage_in ]],\n    constant FrameData & frameData               [[ buffer(BufferIndexFrameData) ]],\n    texture2d<half>      albedo_specular_GBuffer [[ texture(RenderTargetAlbedo) ]],\n    texture2d<half>      normal_shadow_GBuffer   [[ texture(RenderTargetNormal) ]],\n    texture2d<float>     depth_GBuffer           [[ texture(RenderTargetDepth)  ]])",
      "language" : "metal"
    },
    {
      "code" : "struct GBufferData\n{\n    half4 lighting        [[ color(RenderTargetLighting), raster_order_group(LightingROG) ]];\n    half4 albedo_specular [[ color(RenderTargetAlbedo),   raster_order_group(GBufferROG) ]];\n    half4 normal_shadow   [[ color(RenderTargetNormal),   raster_order_group(GBufferROG) ]];\n    float depth           [[ color(RenderTargetDepth),    raster_order_group(GBufferROG) ]];\n};",
      "language" : "metal"
    },
    {
      "code" : "fragment AccumLightBuffer\ndeferred_directional_lighting_fragment_single_pass(\n    QuadInOut            in        [[ stage_in ]],\n    constant FrameData & frameData [[ buffer(BufferIndexFrameData) ]],\n    GBufferData          GBuffer)",
      "language" : "metal"
    },
    {
      "code" : "pRenderEncoder->setRenderPipelineState( m_pLightMaskPipelineState );\npRenderEncoder->setDepthStencilState( m_pLightMaskDepthStencilState );\n\npRenderEncoder->setStencilReferenceValue( 128 );\npRenderEncoder->setCullMode( MTL::CullModeFront );\n\npRenderEncoder->setVertexBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setFragmentBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setVertexBuffer( m_pLightsData, 0, BufferIndexLightsData );\npRenderEncoder->setVertexBuffer( m_lightPositions[m_frameDataBufferIndex], 0, BufferIndexLightsPosition );\n\nconst std::vector<MeshBuffer>& vertexBuffers = m_icosahedronMesh.vertexBuffers();\npRenderEncoder->setVertexBuffer( vertexBuffers[0].buffer(), vertexBuffers[0].offset(), BufferIndexMeshPositions );\n\nconst std::vector<Submesh>& icosahedronSubmesh = m_icosahedronMesh.submeshes();\n\npRenderEncoder->drawIndexedPrimitives( icosahedronSubmesh[0].primitiveType(),\n                                     icosahedronSubmesh[0].indexCount(),\n                                     icosahedronSubmesh[0].indexType(),\n                                     icosahedronSubmesh[0].indexBuffer().buffer(),\n                                     icosahedronSubmesh[0].indexBuffer().offset(),\n                                     NumLights );",
      "language" : "cpp"
    },
    {
      "code" : "pRenderEncoder->setDepthStencilState( m_pPointLightDepthStencilState );\n\npRenderEncoder->setStencilReferenceValue( 128 );\npRenderEncoder->setCullMode( MTL::CullModeBack );\n\npRenderEncoder->setVertexBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setVertexBuffer( m_pLightsData, 0, BufferIndexLightsData );\npRenderEncoder->setVertexBuffer( m_lightPositions[m_frameDataBufferIndex], 0, BufferIndexLightsPosition );\n\npRenderEncoder->setFragmentBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setFragmentBuffer( m_pLightsData, 0, BufferIndexLightsData );\npRenderEncoder->setFragmentBuffer( m_lightPositions[m_frameDataBufferIndex], 0, BufferIndexLightsPosition );\n\nconst std::vector<MeshBuffer>& vertexBuffers = m_icosahedronMesh.vertexBuffers();\npRenderEncoder->setVertexBuffer( vertexBuffers[0].buffer(), vertexBuffers[0].offset(), BufferIndexMeshPositions );\n\nconst std::vector<Submesh>& icosahedronSubmesh = m_icosahedronMesh.submeshes();\n\npRenderEncoder->drawIndexedPrimitives( icosahedronSubmesh[0].primitiveType(),\n                                     icosahedronSubmesh[0].indexCount(),\n                                     icosahedronSubmesh[0].indexType(),\n                                     icosahedronSubmesh[0].indexBuffer().buffer(),\n                                     icosahedronSubmesh[0].indexBuffer().offset(),\n                                     NumLights );",
      "language" : "cpp"
    },
    {
      "code" : "pRenderEncoder->setRenderPipelineState( m_pSkyboxPipelineState );\npRenderEncoder->setDepthStencilState( m_pDontWriteDepthStencilState );\npRenderEncoder->setCullMode( MTL::CullModeFront );\n\npRenderEncoder->setVertexBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setFragmentTexture( m_pSkyMap, TextureIndexBaseColor );\n\nfor (auto& meshBuffer : m_skyMesh.vertexBuffers())\n{\n    pRenderEncoder->setVertexBuffer(meshBuffer.buffer(),\n                                    meshBuffer.offset(),\n                                    meshBuffer.argumentIndex());\n}\n\n\nfor (auto& submesh : m_skyMesh.submeshes())\n{\n    pRenderEncoder->drawIndexedPrimitives(submesh.primitiveType(),\n                                          submesh.indexCount(),\n                                          submesh.indexType(),\n                                          submesh.indexBuffer().buffer(),\n                                          submesh.indexBuffer().offset() );\n}",
      "language" : "cpp"
    },
    {
      "code" : "half4 c = colorMap.sample(linearSampler, float2(in.tex_coord));\n\nhalf3 fragColor = in.color * c.x;\n\nreturn half4(fragColor, c.x);",
      "language" : "metal"
    }
  ],
  "contentHash" : "addf52ecdb97689f38da6031048eb0c5b978d1103cc5bc488bdfea61d0ae5d43",
  "crawledAt" : "2025-12-02T15:49:36Z",
  "id" : "4411E983-8845-417D-8941-E691FA7D013E",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nThis sample demonstrates a deferred lighting renderer that implements shadows using a shadow map, and culls light volumes using the stencil buffer.\n\n\n\nDeferred lighting can render a large number of lights more easily than forward lighting. For example, with forward lighting, in a scene with many lights, it’s infeasible for every fragment to calculate the contribution of every light. Complex sorting and binning algorithms need to be implemented to limit the calculation of light contributions to only those lights affecting each fragment. With deferred lighting, multiple lights can be applied to the scene with ease.\n\n### Configure the sample code project\n\nThe Xcode project contains schemes for running the sample on macOS, iOS, or tvOS.  The default scheme is macOS, which runs the sample as is on your Mac.\n\nThe sample contains the following preprocessor conditionals that you can modify to control the configuration of the app.\n\nHere’s what they modify in the app’s behavior:\n\nOn macOS, press the following keys to examine the scene at runtime:\n\nOn iOS, tap the screen to toggle between the standard and examination views at runtime.\n\n### Review important concepts\n\nBefore you get started with the sample app, review these concepts to better understand key details of a deferred lighting renderer and some unique Metal features.\n\n**Traditional Deferred Lighting Renderer**\n\nA traditional deferred lighting renderer is typically separated into two render passes:\n\n\n\n**Single-Pass Deferred Lighting on Apple silicon GPUs**\n\nApple silicon GPUs, found on all iOS and tvOS device and now certain macOS devices, use a tile-based deferred rendering (TBDR) architecture, which allows them to render data to tile memory within the GPU. By rendering to tile memory, the device avoids potentially expensive round trips between the GPU and system memory (via a bandwidth-constrained memory bus). Whether a GPU writes tile memory to system memory depends on these configurations:\n\nWhen `MTLStoreActionStore` is set as a store action, output data for the render targets of a render pass is written from tile memory to system memory, where the render targets are backed by textures. If this data is then used for a subsequent render pass, input data from these textures is read from system memory into a texture cache in the GPU. Therefore, a traditional deferred lighting renderer that accesses system memory requires geometry buffer data to be stored in system memory between the first and second render passes.\n\n\n\nHowever, because of the TBDR architecture, Apple silicon GPUs can also read data from tile memory at any given time. This allows fragment shaders to read from and perform calculations on render targets in tile memory, before this data is written to tile memory again. This feature allows the sample to avoid storing geometry buffer data in system memory between the first and second render passes; thus, a deferred lighting renderer can be implemented with a single render pass.\n\nGeometry buffer data is produced and consumed exclusively by the GPU, not the CPU, within the single render pass. Therefore, this data isn’t loaded from system memory before the render pass begins, nor is it stored in system memory after the render pass finishes. Instead of reading geometry buffer data from a texture in system memory, the lighting fragment functions read data from the geometry buffer while it’s still attached to the render pass as a render target. Thus, system memory doesn’t need to be allocated for geometry buffer textures, and each of these textures can be declared with a `MTLStorageModeMemoryless` storage mode.\n\n\n\n**Deferred Lighting with Raster Order Groups**\n\nBy default, when a fragment shader writes data to a pixel, the GPU waits until the shader has completely finished writing to that pixel before beginning the execution of another fragment shader for that same pixel.\n\n\n\nRaster order groups allow apps to increase the parallelization of the GPU’s fragment shaders. With raster order groups, a fragment function can separate render targets into different execution groups. This separation allows the GPU to read from and perform calculations on render targets in one group, before a previous instance of a fragment shader has finished writing data to pixels in another group.\n\n\n\nIn this sample, some lighting fragment functions use these raster order groups:\n\nThese raster order groups allow the GPU to read the geometry buffer in a fragment shader and execute the lighting calculations, before the lighting calculations from a previous instance of a fragment shader have finished writing their output data.\n\n### Render a deferred lighting frame\n\nThe sample renders each full frame by rendering these stages, in this order:\n\nThe sample’s single pass deferred renderer produces the geometry buffer and performs all subsequent stages in a single render pass. This single-pass implementation is possible due to the TBDR architecture of iOS and tvOS GPUs, which allows a device to read geometry buffer data from render targets in tile memory.\n\nThe sample’s traditional deferred renderer produces the geometry buffer in one render pass and then performs all subsequent stages in another render pass. This two-pass implementation is necessary with GPUs using an IMR architecture, which don’t support reading render target color data in a fragment function.\n\n### Render the shadow map\n\nThe sample renders a shadow map for the single directional light in the scene (the sun) by rendering the model from the light’s perspective.\n\n\n\nThe render pipeline for the shadow map has a vertex function but not a fragment function; therefore, the sample can determine the screen-space depth value written to the shadow map without executing further stages of the render pipeline. (Additionally, the render executes quickly because it doesn’t have a fragment function.)\n\nBefore drawing geometry for the shadow map, the sample sets a depth bias value to reduce shadow artifacts:\n\nThen, in the fragment function of the geometry buffer stage, the sample tests whether the fragment is occluded and shadowed:\n\nThe sample stores the result of the `sample_compare` function in the `w` component of the `normal_shadow` render target:\n\nIn the directional light and point light composition stages, the sample reads the shadow value from the geometry buffer and applies it to the fragment.\n\n### Render the geometry buffer\n\nThe sample’s geometry buffer contains these textures:\n\n\n\nWhen the sample renders the geometry buffer, both the traditional and single pass deferred renderers attach all the geometry buffer textures as render targets for the render pass. However, because devices with a TBDR architecture can both render the geometry buffer and read from it in a single render pass, the sample creates the geometry buffer textures with a memoryless storage mode, which indicates that system memory isn’t allocated for these textures. Instead, these textures are allocated and populated only in tile memory for the duration of the render pass.\n\nThe sample creates the geometry buffer textures in the common `drawableSizeWillChange()` method, but the single-pass deferred renderer sets the `storageMode` variable to `MTL::StorageModeMemoryless` while the traditional deferred renderer sets it to `MTL::StorageModePrivate`.\n\nFor the traditional deferred renderer, after the sample finishes writing data to the geometry buffer textures, it calls the `endEncoding` method to finalize the geometry buffer render pass. Because the store action for the render command encoder is set to `MTLStoreActionStore`, the GPU writes each of the render target textures to video memory when the encoder completes its execution. This allows the sample to read these textures from video memory in the subsequent deferred lighting and composition render pass.\n\nFor the single pass deferred renderer, after the sample finishes writing data to the geometry buffer textures, the sample doesn’t finalize the render command encoder and instead continues to use it for subsequent stages.\n\n### Apply the directional lighting and shadows\n\nThe sample applies directional lighting and shadows to the drawable that’s destined for the display.\n\nThe traditional deferred renderer reads geometry buffer data from textures set as arguments to a fragment function:\n\nThe single pass deferred renderer reads geometry buffer data from render targets attached to the render pass:\n\nAlthough these fragment functions have different inputs, they share a common implementation in the `deferred_directional_lighting_fragment_common` fragment function. This function performs these operations:\n\nBecause this is the first stage that renders to the drawable, the iOS and tvOS renderer obtains a drawable before the earlier geometry buffer stage so that the drawable can be merged with the output of later stages. The traditional deferred renderer, however, delays obtaining a drawable until after the geometry buffer stage is completed and before the directional light stage begins. This delay reduces the amount of time that the app holds onto the drawable and thus improves performance.\n\n### Cull the light volumes\n\nThe sample creates a stencil mask that’s used to avoid executing expensive lighting calculations for many fragments. It creates this stencil mask by using the depth buffer from the geometry buffer pass, and the stencil buffer, to track whether a light volume intersects any geometry. (If not, then it isn’t casting light on anything.)\n\nIn the `drawPointLightMask:` implementation, the sample sets the `m_lightMaskPipelineState` render pipeline and encodes an instanced draw call to draw only the back faces of icosahedrons, which encompass the volumes of the point lights. If a fragment within this draw call fails the depth test, this result indicates that the back face of the icosahedron is behind some geometry.\n\n`m_lightMaskPipelineState` doesn’t have a fragment function, so no color data is written from this render pipeline. However, due to the set `m_lightMaskDepthStencilState` depth and stencil state, any fragment that fails the depth test increments the stencil buffer for that fragment. Fragments that contain geometry have a starting depth value of `128`, which the sample set in the geometry buffer stage. Therefore, any fragment that fails the depth test while `m_lightMaskDepthStencilState` is set increments the depth value to greater than `128`. (Because front face culling is enabled, a fragment that fails the depth test and has a value greater than `128` indicates that at least the back half of the icosahedron is behind all geometry.)\n\nIn the next draw call, in the `drawPointLightsCommon` implementation, the sample applies the contribution of the point lights to the drawable. The sample tests whether the front half of the icosahedron is in front of all geometry, which determines if the volume intersects some geometry and thus if the fragment should be lit. The depth and stencil state,  `m_pointLightDepthStencilState`, set for this draw call only executes the fragment function if the stencil value for the fragment is greater than the reference value of `128`. (Because the stencil test value is set to `MTLCompareFunctionLess`, the sample passes the test only if the reference value of `128` is less than the value in the stencil buffer.)\n\nBecause the draw call in `drawPointLightMask:` increments the stencil values for fragments that are behind any geometry, the only fragments for which the sample executes the fragment function are those that meet both of these conditions:\n\nThe following diagrams show the difference in fragment coverage between a rendered frame that uses this stencil mask algorithm and another that doesn’t. When the algorithm is enabled, pixels in green are pixels for which the point light fragment function was executed.\n\n\n\nWhen the algorithm is disabled, pixels in green and red are pixels for which the point light fragment function was executed.\n\n\n\n### Render the skybox and fairy lights\n\nIn the final lighting stages, the sample applies much simpler lighting techniques to the scene.\n\nThe sample applies depth testing to the skybox, against the temple’s geometry, so the renderer only renders to areas of the drawable that have not been filled by some geometry.\n\nThe sample renders fairy lights onto the drawable as 2D circles and uses a texture to determine the alpha blending factors for their fragments.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-c++\ncrawled: 2025-12-02T15:49:36Z\n---\n\n# Rendering a scene with deferred lighting in C++\n\n**Sample Code**\n\nAvoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n\n## Overview\n\nThis sample demonstrates a deferred lighting renderer that implements shadows using a shadow map, and culls light volumes using the stencil buffer.\n\n\n\nDeferred lighting can render a large number of lights more easily than forward lighting. For example, with forward lighting, in a scene with many lights, it’s infeasible for every fragment to calculate the contribution of every light. Complex sorting and binning algorithms need to be implemented to limit the calculation of light contributions to only those lights affecting each fragment. With deferred lighting, multiple lights can be applied to the scene with ease.\n\n### Configure the sample code project\n\nThe Xcode project contains schemes for running the sample on macOS, iOS, or tvOS.  The default scheme is macOS, which runs the sample as is on your Mac.\n\n\n\nThe sample contains the following preprocessor conditionals that you can modify to control the configuration of the app.\n\n```cpp\n#define USE_EYE_DEPTH              1\n#define LIGHT_STENCIL_CULLING      1\n#define SUPPORT_BUFFER_EXAMINATION 1\n```\n\nHere’s what they modify in the app’s behavior:\n\n- `USE_EYE_DEPTH` — When enabled, writes depth values in eye space to the geometry buffer depth component. This allows the deferred pass to calculate the eye space fragment position more easily to apply lighting. When disabled, the screen depth is written to the geometry buffer depth component and an extra inverse transform from screen space to eye space is necessary to calculate lighting contributions in the deferred pass.\n- `LIGHT_STENCIL_CULLING` — When enabled, uses the stencil buffer to avoid execution of lighting calculations on fragments that don’t intersect with a 3D light volume. When disabled, the GPU calculates lighting for all fragments covered by a light in screen space. This means that considerably more fragments need expensive lighting calculations than is actually necessary.\n- `SUPPORT_BUFFER_EXAMINATION` — Enables toggling of buffer examination mode at runtime. Code protected by this definition is only useful to examine or debug parts of the underlying implementation.\n\nOn macOS, press the following keys to examine the scene at runtime:\n\n- Press 1 to see all of the examination views at the same time.\n- Press 2 to see the geometry buffer’s albedo data.\n- Press 3 to see the geometry buffer’s normal data.\n- Press 4 to see the geometry buffer’s depth data.\n- Press 5 to see the geometry buffer’s specular data.\n- Press 6 to see the geometry buffer’s shadow data.\n- Press 7 to see the shadow map.\n- Press 8 to see the masked light volume coverage.\n- Press 9 to see the full light volume coverage.\n- Press 0 or Return to exit an examination view and return to the standard view.\n\nOn iOS, tap the screen to toggle between the standard and examination views at runtime.\n\n### Review important concepts\n\nBefore you get started with the sample app, review these concepts to better understand key details of a deferred lighting renderer and some unique Metal features.\n\n**Traditional Deferred Lighting Renderer**\n\nA traditional deferred lighting renderer is typically separated into two render passes:\n\n- **First pass: Geometry buffer rendering.** The renderer draws and transforms the scene’s models, and the fragment function renders the results to a collection of textures known as the *geometry buffer* or *g-buffer*. The geometry buffer contains material colors from the models, as well as per-fragment normal, shadow, and depth values.\n- **Second pass: Deferred lighting and composition.** The renderer draws each light volume, using the geometry buffer data to reconstruct the position of each fragment and apply the lighting calculations. As the lights are drawn, the output of each light is blended on top of the previous light outputs. Finally, the renderer composites other data, such as shadows and directional lighting, onto the scene by executing a full-screen quad or a compute kernel.\n\n\n\n\n\n**Single-Pass Deferred Lighting on Apple silicon GPUs**\n\nApple silicon GPUs, found on all iOS and tvOS device and now certain macOS devices, use a tile-based deferred rendering (TBDR) architecture, which allows them to render data to tile memory within the GPU. By rendering to tile memory, the device avoids potentially expensive round trips between the GPU and system memory (via a bandwidth-constrained memory bus). Whether a GPU writes tile memory to system memory depends on these configurations:\n\n- The store action of the app’s render command encoders.\n- The storage mode of the app’s textures.\n\nWhen `MTLStoreActionStore` is set as a store action, output data for the render targets of a render pass is written from tile memory to system memory, where the render targets are backed by textures. If this data is then used for a subsequent render pass, input data from these textures is read from system memory into a texture cache in the GPU. Therefore, a traditional deferred lighting renderer that accesses system memory requires geometry buffer data to be stored in system memory between the first and second render passes.\n\n\n\nHowever, because of the TBDR architecture, Apple silicon GPUs can also read data from tile memory at any given time. This allows fragment shaders to read from and perform calculations on render targets in tile memory, before this data is written to tile memory again. This feature allows the sample to avoid storing geometry buffer data in system memory between the first and second render passes; thus, a deferred lighting renderer can be implemented with a single render pass.\n\nGeometry buffer data is produced and consumed exclusively by the GPU, not the CPU, within the single render pass. Therefore, this data isn’t loaded from system memory before the render pass begins, nor is it stored in system memory after the render pass finishes. Instead of reading geometry buffer data from a texture in system memory, the lighting fragment functions read data from the geometry buffer while it’s still attached to the render pass as a render target. Thus, system memory doesn’t need to be allocated for geometry buffer textures, and each of these textures can be declared with a `MTLStorageModeMemoryless` storage mode.\n\n\n\n\n\n**Deferred Lighting with Raster Order Groups**\n\nBy default, when a fragment shader writes data to a pixel, the GPU waits until the shader has completely finished writing to that pixel before beginning the execution of another fragment shader for that same pixel.\n\n\n\nRaster order groups allow apps to increase the parallelization of the GPU’s fragment shaders. With raster order groups, a fragment function can separate render targets into different execution groups. This separation allows the GPU to read from and perform calculations on render targets in one group, before a previous instance of a fragment shader has finished writing data to pixels in another group.\n\n\n\nIn this sample, some lighting fragment functions use these raster order groups:\n\n- **Raster order group 0.** `AAPLLightingROG` is used for the render target that contains the results of the lighting calculations.\n- **Raster order group 1.** `AAPLGBufferROG` is used for the geometry buffer data in the lighting function.\n\nThese raster order groups allow the GPU to read the geometry buffer in a fragment shader and execute the lighting calculations, before the lighting calculations from a previous instance of a fragment shader have finished writing their output data.\n\n### Render a deferred lighting frame\n\nThe sample renders each full frame by rendering these stages, in this order:\n\n1. Shadow map\n2. Geometry buffer\n3. Directional light\n4. Light mask\n5. Point lights\n6. Skybox\n7. Fairy lights\n\nThe sample’s single pass deferred renderer produces the geometry buffer and performs all subsequent stages in a single render pass. This single-pass implementation is possible due to the TBDR architecture of iOS and tvOS GPUs, which allows a device to read geometry buffer data from render targets in tile memory.\n\n```cpp\nMTL::RenderCommandEncoder* pRenderEncoder = pCommandBuffer->renderCommandEncoder(m_pViewRenderPassDescriptor);\npRenderEncoder->setLabel( AAPLSTR( \"Combined GBuffer & Lighting Pass\" ) );\n\nRenderer::drawGBuffer( pRenderEncoder );\n\ndrawDirectionalLight( pRenderEncoder );\n\nRenderer::drawPointLightMask( pRenderEncoder );\n\ndrawPointLights( pRenderEncoder );\n\nRenderer::drawSky( pRenderEncoder );\n\nRenderer::drawFairies( pRenderEncoder );\n\npRenderEncoder->endEncoding();\n```\n\nThe sample’s traditional deferred renderer produces the geometry buffer in one render pass and then performs all subsequent stages in another render pass. This two-pass implementation is necessary with GPUs using an IMR architecture, which don’t support reading render target color data in a fragment function.\n\n```cpp\nMTL::RenderCommandEncoder* pRenderEncoder = pCommandBuffer->renderCommandEncoder( m_pGBufferRenderPassDescriptor );\npRenderEncoder->setLabel( AAPLSTR( \"GBuffer Generation\" ) );\n\nRenderer::drawGBuffer( pRenderEncoder );\n\npRenderEncoder->endEncoding();\n```\n\n```cpp\nMTL::RenderCommandEncoder* pRenderEncoder = pCommandBuffer->renderCommandEncoder( m_pFinalRenderPassDescriptor );\npRenderEncoder->setLabel( AAPLSTR( \"Lighting & Composition Pass\" ) );\n\ndrawDirectionalLight( pRenderEncoder );\n\nRenderer::drawPointLightMask( pRenderEncoder );\n\ndrawPointLights( pRenderEncoder );\n\nRenderer::drawSky( pRenderEncoder );\n\nRenderer::drawFairies( pRenderEncoder );\n\npRenderEncoder->endEncoding();\n```\n\n### Render the shadow map\n\nThe sample renders a shadow map for the single directional light in the scene (the sun) by rendering the model from the light’s perspective.\n\n\n\nThe render pipeline for the shadow map has a vertex function but not a fragment function; therefore, the sample can determine the screen-space depth value written to the shadow map without executing further stages of the render pipeline. (Additionally, the render executes quickly because it doesn’t have a fragment function.)\n\n```cpp\nMTL::RenderPipelineDescriptor* pRenderPipelineDescriptor = MTL::RenderPipelineDescriptor::alloc()->init();\npRenderPipelineDescriptor->setLabel( AAPLSTR( \"Shadow Gen\" ) );\npRenderPipelineDescriptor->setVertexDescriptor( nullptr );\npRenderPipelineDescriptor->setVertexFunction( pShadowVertexFunction );\npRenderPipelineDescriptor->setFragmentFunction( nullptr );\npRenderPipelineDescriptor->setDepthAttachmentPixelFormat( shadowMapPixelFormat );\n\nm_pShadowGenPipelineState = m_pDevice->newRenderPipelineState( pRenderPipelineDescriptor, &pError );\n```\n\nBefore drawing geometry for the shadow map, the sample sets a depth bias value to reduce shadow artifacts:\n\n```cpp\npEncoder->setDepthBias( 0.015, 7, 0.02 );\n```\n\nThen, in the fragment function of the geometry buffer stage, the sample tests whether the fragment is occluded and shadowed:\n\n```metal\nhalf shadow_sample = shadowMap.sample_compare(shadowSampler, in.shadow_uv, in.shadow_depth);\n```\n\nThe sample stores the result of the `sample_compare` function in the `w` component of the `normal_shadow` render target:\n\n```metal\ngBuffer.normal_shadow = half4(eye_normal.xyz, shadow_sample);\n```\n\nIn the directional light and point light composition stages, the sample reads the shadow value from the geometry buffer and applies it to the fragment.\n\n### Render the geometry buffer\n\nThe sample’s geometry buffer contains these textures:\n\n- `albedo_specular_GBuffer`, which stores albedo and specular data. Albedo data is stored in the `x`, `y`, and `z` components; specular data is stored in the `w` component.\n- `normal_shadow_GBuffer`, which stores normal and shadow data. Normal data is stored in the `x`, `y`, and `z` components; shadow data is stored in the `w` component.\n- `depth_GBuffer`, which stores depth values in eye space.\n\n\n\nWhen the sample renders the geometry buffer, both the traditional and single pass deferred renderers attach all the geometry buffer textures as render targets for the render pass. However, because devices with a TBDR architecture can both render the geometry buffer and read from it in a single render pass, the sample creates the geometry buffer textures with a memoryless storage mode, which indicates that system memory isn’t allocated for these textures. Instead, these textures are allocated and populated only in tile memory for the duration of the render pass.\n\nThe sample creates the geometry buffer textures in the common `drawableSizeWillChange()` method, but the single-pass deferred renderer sets the `storageMode` variable to `MTL::StorageModeMemoryless` while the traditional deferred renderer sets it to `MTL::StorageModePrivate`.\n\n```cpp\nm_GBufferStorageMode = MTL::StorageModeMemoryless;\n```\n\nFor the traditional deferred renderer, after the sample finishes writing data to the geometry buffer textures, it calls the `endEncoding` method to finalize the geometry buffer render pass. Because the store action for the render command encoder is set to `MTLStoreActionStore`, the GPU writes each of the render target textures to video memory when the encoder completes its execution. This allows the sample to read these textures from video memory in the subsequent deferred lighting and composition render pass.\n\nFor the single pass deferred renderer, after the sample finishes writing data to the geometry buffer textures, the sample doesn’t finalize the render command encoder and instead continues to use it for subsequent stages.\n\n### Apply the directional lighting and shadows\n\nThe sample applies directional lighting and shadows to the drawable that’s destined for the display.\n\nThe traditional deferred renderer reads geometry buffer data from textures set as arguments to a fragment function:\n\n```metal\nfragment half4\ndeferred_directional_lighting_fragment_traditional(\n    QuadInOut            in                      [[ stage_in ]],\n    constant FrameData & frameData               [[ buffer(BufferIndexFrameData) ]],\n    texture2d<half>      albedo_specular_GBuffer [[ texture(RenderTargetAlbedo) ]],\n    texture2d<half>      normal_shadow_GBuffer   [[ texture(RenderTargetNormal) ]],\n    texture2d<float>     depth_GBuffer           [[ texture(RenderTargetDepth)  ]])\n```\n\nThe single pass deferred renderer reads geometry buffer data from render targets attached to the render pass:\n\n```metal\nstruct GBufferData\n{\n    half4 lighting        [[ color(RenderTargetLighting), raster_order_group(LightingROG) ]];\n    half4 albedo_specular [[ color(RenderTargetAlbedo),   raster_order_group(GBufferROG) ]];\n    half4 normal_shadow   [[ color(RenderTargetNormal),   raster_order_group(GBufferROG) ]];\n    float depth           [[ color(RenderTargetDepth),    raster_order_group(GBufferROG) ]];\n};\n```\n\n```metal\nfragment AccumLightBuffer\ndeferred_directional_lighting_fragment_single_pass(\n    QuadInOut            in        [[ stage_in ]],\n    constant FrameData & frameData [[ buffer(BufferIndexFrameData) ]],\n    GBufferData          GBuffer)\n```\n\nAlthough these fragment functions have different inputs, they share a common implementation in the `deferred_directional_lighting_fragment_common` fragment function. This function performs these operations:\n\n- Reconstructs the normals from the geometry buffer normal data to calculate the diffuse term.\n- Reconstructs the eye space position from the geometry buffer depth data to apply specular highlights.\n- Uses the geometry buffer shadow data to darken the fragment and apply the shadow to the scene.\n\nBecause this is the first stage that renders to the drawable, the iOS and tvOS renderer obtains a drawable before the earlier geometry buffer stage so that the drawable can be merged with the output of later stages. The traditional deferred renderer, however, delays obtaining a drawable until after the geometry buffer stage is completed and before the directional light stage begins. This delay reduces the amount of time that the app holds onto the drawable and thus improves performance.\n\n\n\n### Cull the light volumes\n\nThe sample creates a stencil mask that’s used to avoid executing expensive lighting calculations for many fragments. It creates this stencil mask by using the depth buffer from the geometry buffer pass, and the stencil buffer, to track whether a light volume intersects any geometry. (If not, then it isn’t casting light on anything.)\n\nIn the `drawPointLightMask:` implementation, the sample sets the `m_lightMaskPipelineState` render pipeline and encodes an instanced draw call to draw only the back faces of icosahedrons, which encompass the volumes of the point lights. If a fragment within this draw call fails the depth test, this result indicates that the back face of the icosahedron is behind some geometry.\n\n```cpp\npRenderEncoder->setRenderPipelineState( m_pLightMaskPipelineState );\npRenderEncoder->setDepthStencilState( m_pLightMaskDepthStencilState );\n\npRenderEncoder->setStencilReferenceValue( 128 );\npRenderEncoder->setCullMode( MTL::CullModeFront );\n\npRenderEncoder->setVertexBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setFragmentBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setVertexBuffer( m_pLightsData, 0, BufferIndexLightsData );\npRenderEncoder->setVertexBuffer( m_lightPositions[m_frameDataBufferIndex], 0, BufferIndexLightsPosition );\n\nconst std::vector<MeshBuffer>& vertexBuffers = m_icosahedronMesh.vertexBuffers();\npRenderEncoder->setVertexBuffer( vertexBuffers[0].buffer(), vertexBuffers[0].offset(), BufferIndexMeshPositions );\n\nconst std::vector<Submesh>& icosahedronSubmesh = m_icosahedronMesh.submeshes();\n\npRenderEncoder->drawIndexedPrimitives( icosahedronSubmesh[0].primitiveType(),\n                                     icosahedronSubmesh[0].indexCount(),\n                                     icosahedronSubmesh[0].indexType(),\n                                     icosahedronSubmesh[0].indexBuffer().buffer(),\n                                     icosahedronSubmesh[0].indexBuffer().offset(),\n                                     NumLights );\n```\n\n`m_lightMaskPipelineState` doesn’t have a fragment function, so no color data is written from this render pipeline. However, due to the set `m_lightMaskDepthStencilState` depth and stencil state, any fragment that fails the depth test increments the stencil buffer for that fragment. Fragments that contain geometry have a starting depth value of `128`, which the sample set in the geometry buffer stage. Therefore, any fragment that fails the depth test while `m_lightMaskDepthStencilState` is set increments the depth value to greater than `128`. (Because front face culling is enabled, a fragment that fails the depth test and has a value greater than `128` indicates that at least the back half of the icosahedron is behind all geometry.)\n\nIn the next draw call, in the `drawPointLightsCommon` implementation, the sample applies the contribution of the point lights to the drawable. The sample tests whether the front half of the icosahedron is in front of all geometry, which determines if the volume intersects some geometry and thus if the fragment should be lit. The depth and stencil state,  `m_pointLightDepthStencilState`, set for this draw call only executes the fragment function if the stencil value for the fragment is greater than the reference value of `128`. (Because the stencil test value is set to `MTLCompareFunctionLess`, the sample passes the test only if the reference value of `128` is less than the value in the stencil buffer.)\n\n```cpp\npRenderEncoder->setDepthStencilState( m_pPointLightDepthStencilState );\n\npRenderEncoder->setStencilReferenceValue( 128 );\npRenderEncoder->setCullMode( MTL::CullModeBack );\n\npRenderEncoder->setVertexBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setVertexBuffer( m_pLightsData, 0, BufferIndexLightsData );\npRenderEncoder->setVertexBuffer( m_lightPositions[m_frameDataBufferIndex], 0, BufferIndexLightsPosition );\n\npRenderEncoder->setFragmentBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setFragmentBuffer( m_pLightsData, 0, BufferIndexLightsData );\npRenderEncoder->setFragmentBuffer( m_lightPositions[m_frameDataBufferIndex], 0, BufferIndexLightsPosition );\n\nconst std::vector<MeshBuffer>& vertexBuffers = m_icosahedronMesh.vertexBuffers();\npRenderEncoder->setVertexBuffer( vertexBuffers[0].buffer(), vertexBuffers[0].offset(), BufferIndexMeshPositions );\n\nconst std::vector<Submesh>& icosahedronSubmesh = m_icosahedronMesh.submeshes();\n\npRenderEncoder->drawIndexedPrimitives( icosahedronSubmesh[0].primitiveType(),\n                                     icosahedronSubmesh[0].indexCount(),\n                                     icosahedronSubmesh[0].indexType(),\n                                     icosahedronSubmesh[0].indexBuffer().buffer(),\n                                     icosahedronSubmesh[0].indexBuffer().offset(),\n                                     NumLights );\n```\n\nBecause the draw call in `drawPointLightMask:` increments the stencil values for fragments that are behind any geometry, the only fragments for which the sample executes the fragment function are those that meet both of these conditions:\n\n- Fragments whose front face passes the depth test and is in front of some geometry.\n- Fragments whose back face fails the depth test and is behind some geometry.\n\nThe following diagrams show the difference in fragment coverage between a rendered frame that uses this stencil mask algorithm and another that doesn’t. When the algorithm is enabled, pixels in green are pixels for which the point light fragment function was executed.\n\n\n\nWhen the algorithm is disabled, pixels in green and red are pixels for which the point light fragment function was executed.\n\n\n\n### Render the skybox and fairy lights\n\nIn the final lighting stages, the sample applies much simpler lighting techniques to the scene.\n\nThe sample applies depth testing to the skybox, against the temple’s geometry, so the renderer only renders to areas of the drawable that have not been filled by some geometry.\n\n```cpp\npRenderEncoder->setRenderPipelineState( m_pSkyboxPipelineState );\npRenderEncoder->setDepthStencilState( m_pDontWriteDepthStencilState );\npRenderEncoder->setCullMode( MTL::CullModeFront );\n\npRenderEncoder->setVertexBuffer( m_frameDataBuffers[m_frameDataBufferIndex], 0, BufferIndexFrameData );\npRenderEncoder->setFragmentTexture( m_pSkyMap, TextureIndexBaseColor );\n\nfor (auto& meshBuffer : m_skyMesh.vertexBuffers())\n{\n    pRenderEncoder->setVertexBuffer(meshBuffer.buffer(),\n                                    meshBuffer.offset(),\n                                    meshBuffer.argumentIndex());\n}\n\n\nfor (auto& submesh : m_skyMesh.submeshes())\n{\n    pRenderEncoder->drawIndexedPrimitives(submesh.primitiveType(),\n                                          submesh.indexCount(),\n                                          submesh.indexType(),\n                                          submesh.indexBuffer().buffer(),\n                                          submesh.indexBuffer().offset() );\n}\n```\n\nThe sample renders fairy lights onto the drawable as 2D circles and uses a texture to determine the alpha blending factors for their fragments.\n\n```metal\nhalf4 c = colorMap.sample(linearSampler, float2(in.tex_coord));\n\nhalf3 fragColor = in.color * c.x;\n\nreturn half4(fragColor, c.x);\n```\n\n## Lighting techniques\n\n- **Rendering a scene with forward plus lighting using tile shaders**: Implement a forward plus renderer using the latest features on Apple GPUs.\n- **Rendering a scene with deferred lighting in Objective-C**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n- **Rendering a scene with deferred lighting in Swift**: Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.\n- **Rendering reflections with fewer render passes**: Use layer selection to reduce the number of render passes needed to generate an environment map.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Implement a forward plus renderer using the latest features on Apple GPUs.",
          "name" : "Rendering a scene with forward plus lighting using tile shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-forward-plus-lighting-using-tile-shaders"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in Objective-C",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-objective-c"
        },
        {
          "description" : "Avoid expensive lighting calculations by implementing a deferred lighting renderer optimized for immediate mode and tile-based deferred renderer GPUs.",
          "name" : "Rendering a scene with deferred lighting in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-swift"
        },
        {
          "description" : "Use layer selection to reduce the number of render passes needed to generate an environment map.",
          "name" : "Rendering reflections with fewer render passes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-reflections-with-fewer-render-passes"
        }
      ],
      "title" : "Lighting techniques"
    }
  ],
  "source" : "appleJSON",
  "title" : "Rendering a scene with deferred lighting in C++",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-a-scene-with-deferred-lighting-in-c++"
}