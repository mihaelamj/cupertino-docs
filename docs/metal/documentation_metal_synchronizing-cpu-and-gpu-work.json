{
  "abstract" : "Avoid stalls between CPU and GPU work by using multiple instances of a resource.",
  "codeExamples" : [
    {
      "code" : "typedef struct\n{\n    vector_float2 position;\n    vector_float4 color;\n} AAPLVertex;",
      "language" : "objective-c"
    },
    {
      "code" : "+(const AAPLVertex *)vertices\n{\n    const float TriangleSize = 64;\n    static const AAPLVertex triangleVertices[] =\n    {\n        \/\/ Pixel Positions,                          RGBA colors.\n        { { -0.5*TriangleSize, -0.5*TriangleSize },  { 1, 1, 1, 1 } },\n        { {  0.0*TriangleSize, +0.5*TriangleSize },  { 1, 1, 1, 1 } },\n        { { +0.5*TriangleSize, -0.5*TriangleSize },  { 1, 1, 1, 1 } }\n    };\n    return triangleVertices;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "NSMutableArray *triangles = [[NSMutableArray alloc] initWithCapacity:NumTriangles];\n\n\/\/ Initialize each triangle.\nfor(NSUInteger t = 0; t < NumTriangles; t++)\n{\n    vector_float2 trianglePosition;\n\n    \/\/ Determine the starting position of the triangle in a horizontal line.\n    trianglePosition.x = ((-((float)NumTriangles) \/ 2.0) + t) * horizontalSpacing;\n    trianglePosition.y = 0.0;\n\n    \/\/ Create the triangle, set its properties, and add it to the array.\n    AAPLTriangle * triangle = [AAPLTriangle new];\n    triangle.position = trianglePosition;\n    triangle.color = Colors[t % NumColors];\n    [triangles addObject:triangle];\n}\n_triangles = triangles;",
      "language" : "objective-c"
    },
    {
      "code" : "const NSUInteger triangleVertexCount = [AAPLTriangle vertexCount];\n_totalVertexCount = triangleVertexCount * _triangles.count;\nconst NSUInteger triangleVertexBufferSize = _totalVertexCount * sizeof(AAPLVertex);",
      "language" : "objective-c"
    },
    {
      "code" : "for(NSUInteger bufferIndex = 0; bufferIndex < MaxFramesInFlight; bufferIndex++)\n{\n    _vertexBuffers[bufferIndex] = [_device newBufferWithLength:triangleVertexBufferSize\n                                                       options:MTLResourceStorageModeShared];\n    _vertexBuffers[bufferIndex].label = [NSString stringWithFormat:@\"Vertex Buffer #%lu\", (unsigned long)bufferIndex];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Vertex data for the current triangles.\nAAPLVertex *currentTriangleVertices = _vertexBuffers[_currentBuffer].contents;\n\n\/\/ Update each triangle.\nfor(NSUInteger triangle = 0; triangle < NumTriangles; triangle++)\n{\n    vector_float2 trianglePosition = _triangles[triangle].position;\n\n    \/\/ Displace the y-position of the triangle using a sine wave.\n    trianglePosition.y = (sin(trianglePosition.x\/waveMagnitude + _wavePosition) * waveMagnitude);\n\n    \/\/ Update the position of the triangle.\n    _triangles[triangle].position = trianglePosition;\n\n    \/\/ Update the vertices of the current vertex buffer with the triangle's new position.\n    for(NSUInteger vertex = 0; vertex < triangleVertexCount; vertex++)\n    {\n        NSUInteger currentVertex = vertex + (triangle * triangleVertexCount);\n        currentTriangleVertices[currentVertex].position = triangleVertices[vertex].position + _triangles[triangle].position;\n        currentTriangleVertices[currentVertex].color = _triangles[triangle].color;\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder setVertexBuffer:_vertexBuffers[_currentBuffer]\n                        offset:0\n                       atIndex:AAPLVertexInputIndexVertices];\n\n\/\/ Set the viewport size.\n[renderEncoder setVertexBytes:&_viewportSize\n                       length:sizeof(_viewportSize)\n                      atIndex:AAPLVertexInputIndexViewportSize];\n\n\/\/ Draw the triangle vertices.\n[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle\n                  vertexStart:0\n                  vertexCount:_totalVertexCount];",
      "language" : "objective-c"
    },
    {
      "code" : "[commandBuffer commit];",
      "language" : "objective-c"
    },
    {
      "code" : "vertex RasterizerData\nvertexShader(const uint vertexID [[ vertex_id ]],\n             const device AAPLVertex *vertices [[ buffer(AAPLVertexInputIndexVertices) ]],\n             constant vector_uint2 *viewportSizePointer  [[ buffer(AAPLVertexInputIndexViewportSize) ]])",
      "language" : "metal"
    },
    {
      "code" : "static const NSUInteger MaxFramesInFlight = 3;",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Iterate through the Metal buffers, and cycle back to the first when you've written to the last.\n_currentBuffer = (_currentBuffer + 1) % MaxFramesInFlight;\n\n\/\/ Update buffer data.\n[self updateState];",
      "language" : "objective-c"
    },
    {
      "code" : "_inFlightSemaphore = dispatch_semaphore_create(MaxFramesInFlight);",
      "language" : "objective-c"
    },
    {
      "code" : "dispatch_semaphore_wait(_inFlightSemaphore, DISPATCH_TIME_FOREVER);",
      "language" : "objective-c"
    },
    {
      "code" : "__block dispatch_semaphore_t block_semaphore = _inFlightSemaphore;\n[commandBuffer addCompletedHandler:^(id<MTLCommandBuffer> buffer)\n {\n     dispatch_semaphore_signal(block_semaphore);\n }];",
      "language" : "objective-c"
    },
    {
      "code" : "pipelineStateDescriptor.vertexBuffers[AAPLVertexInputIndexVertices].mutability = MTLMutabilityImmutable;",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "7dd31dc184f13ef308e29afcb8aa63bbcd32c32e547a362a6ce1e0e9ed2c8ba6",
  "crawledAt" : "2025-12-02T15:49:44Z",
  "id" : "0BA3B028-5CF0-4997-AAB2-5B442A2469FE",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nIn this sample code project, you learn how to manage data dependencies and avoid processor stalls between the CPU and the GPU.\n\nThe project continuously renders triangles along a sine wave. In each frame, the sample updates the position of each triangle’s vertices and then renders a new image. These dynamic data updates create an illusion of motion, where the triangles appear to move along the sine wave.\n\n\n\nThe sample stores the triangle vertices in a buffer that’s shared between the CPU and the GPU. The CPU writes data to the buffer and the GPU reads it.\n\n### Understand the solution to data dependencies and processor stalls\n\nResource sharing creates a *data dependency* between the processors; the CPU needs to finish writing to the resource before the GPU reads it. If the GPU reads the resource before the CPU writes to it, the GPU reads undefined resource data. If the GPU reads the resource while the CPU is writing to it, the GPU reads incorrect resource data.\n\n\n\nThese data dependencies create *processor stalls* between the CPU and the GPU; each processor needs to wait for the other to finish its work before beginning its own work.\n\nHowever, because the CPU and GPU are separate processors, you can make them work simultaneously by using multiple instances of a resource. Each frame, you need to provide the same arguments to your shaders, but this doesn’t mean you need to reference the same resource object. Instead, you create a pool of multiple instances of a resource and use a different one each time you render a frame. For example, as shown below, the CPU can write position data to a buffer used for frame `n+1`, at the same time that the GPU reads position data from a buffer used for frame `n`. By using multiple instances of a buffer, the CPU and the GPU can work continuously and avoid stalls as long as you keep rendering frames.\n\n\n\n### Initialize data with the CPU\n\nDefine a custom `AAPLVertex` structure that represents a vertex. Each vertex has a position and a color:\n\nDefine a custom `AAPLTriangle` class that provides an interface to a default triangle, which is made up of 3 vertices:\n\nInitialize multiple triangle vertices with a position and a color, and store them in an array of triangles, `_triangles`:\n\n### Allocate data storage\n\nCalculate the total storage size of your triangle vertices. Your app renders 50 triangles; each triangle has 3 vertices, totaling 150 vertices, and each vertex is the size of `AAPLVertex`:\n\nInitialize multiple buffers to store multiple copies of your vertex data. For each buffer, allocate exactly enough memory to store 150 vertices:\n\nUpon initialization, the contents of the buffer instances in the `_vertexBuffers` array are empty.\n\n### Update data with the CPU\n\nIn each frame, at the start of the [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] render loop, use the CPU to update the contents of one buffer instance in the `updateState` method:\n\nAfter you update a buffer instance, you don’t access its data with the CPU for the rest of the frame.\n\n### Encode GPU commands\n\nNext, you encode commands that reference the buffer instance in a render pass:\n\n### Commit and execute GPU commands\n\nAt the end of the render loop, call your command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/commit()] method to submit your work to the GPU:\n\nThe GPU begins its work and reads from the `vertices` buffer in the `RasterizerData` vertex shader, which takes the buffer instance as an input argument:\n\n### Reuse multiple buffer instances in your app\n\nFor each frame, perform the following steps, as described above. A full frame’s work is finished when both processors have completed their work.\n\nWhen a frame’s work is finalized, the CPU and the GPU no longer need the buffer instance used in that frame. However, discarding a used buffer instance and creating a new one for each frame is expensive and wasteful. Instead, as shown below, set up your app to cycle through a first in, first out (FIFO) queue of buffer instances, `_vertexBuffers`, that you can reuse. The maximum number of buffer instances in the queue is defined by the value of `MaxFramesInFlight`, set to 3:\n\nIn each frame, at the start of the render loop, you update the next buffer instance from the `_vertexBuffer` queue. You cycle through the queue sequentially and update only one buffer instance per frame; at the end of every third frame, you return to the start of the queue:\n\n### Manage the rate of CPU and GPU work\n\nWhen you have multiple instances of a buffer, you can make the CPU start work for frame `n+1` with one instance, while the GPU finishes work for frame `n` with another instance. This implementation improves your app’s efficiency by making the CPU and the GPU work simultaneously. However, you need to manage your app’s rate of work so you don’t exceed the number of buffer instances available.\n\nTo manage your app’s rate of work, use a semaphore to wait for full frame completions in case the CPU is working much faster than the GPU. A semaphore is a non-Metal object that you use to control access to a resource that’s shared across multiple processors (or threads). The semaphore has an associated counting value, which you decrement or increment, that indicates whether a processor has started or finished accessing a resource. In your app, a semaphore controls CPU and GPU access to buffer instances.\n\nYou initialize the semaphore with a counting value of `MaxFramesInFlight`, to match the number of buffer instances. This value indicates that your app can simultaneously work on a maximum of 3 frames at any given time:\n\nAt the start of the render loop, you decrement the semaphore’s counting value by 1. This indicates that you’re ready to work on a new frame. However, if the counting value falls below 0, the semaphore makes the CPU wait until you increment the value:\n\nAt the end of the render loop, you register a command buffer completion handler. When the GPU completes the command buffer’s execution, it calls this completion handler and you increment the semaphore’s counting value by 1. This indicates that you’ve completed all work for a given frame and you can reuse the buffer instance used in that frame:\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/addCompletedHandler(_:)] method registers a block of code that’s called immediately after the GPU has finished executing the associated command buffer. Because you use only one command buffer per frame, receiving the completion callback indicates that the GPU has completed the frame.\n\n### Set the mutability of your buffers\n\nYour app performs all per-frame rendering setup on a single thread. First it writes data to a buffer instance with the CPU. After that, it encodes rendering commands that reference the buffer instance. Finally, it commits a command buffer for GPU execution. Because these tasks always happen in this order on a single thread, the app guarantees that it finishes writing data to a buffer instance before it encodes a command that references the buffer instance.\n\nThis order allows you to mark your buffer instances as immutable. When you configure your render pipeline descriptor, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPipelineBufferDescriptor\/mutability] property of the vertex buffer at the buffer instance index to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLMutability\/immutable]:\n\nMetal can optimize the performance of immutable buffers, but not mutable buffers. For best results, use immutable buffers as much as possible.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-cpu-and-gpu-work\ncrawled: 2025-12-02T15:49:44Z\n---\n\n# Synchronizing CPU and GPU work\n\n**Sample Code**\n\nAvoid stalls between CPU and GPU work by using multiple instances of a resource.\n\n## Overview\n\nIn this sample code project, you learn how to manage data dependencies and avoid processor stalls between the CPU and the GPU.\n\nThe project continuously renders triangles along a sine wave. In each frame, the sample updates the position of each triangle’s vertices and then renders a new image. These dynamic data updates create an illusion of motion, where the triangles appear to move along the sine wave.\n\n\n\nThe sample stores the triangle vertices in a buffer that’s shared between the CPU and the GPU. The CPU writes data to the buffer and the GPU reads it.\n\n\n\n### Understand the solution to data dependencies and processor stalls\n\nResource sharing creates a *data dependency* between the processors; the CPU needs to finish writing to the resource before the GPU reads it. If the GPU reads the resource before the CPU writes to it, the GPU reads undefined resource data. If the GPU reads the resource while the CPU is writing to it, the GPU reads incorrect resource data.\n\n\n\nThese data dependencies create *processor stalls* between the CPU and the GPU; each processor needs to wait for the other to finish its work before beginning its own work.\n\nHowever, because the CPU and GPU are separate processors, you can make them work simultaneously by using multiple instances of a resource. Each frame, you need to provide the same arguments to your shaders, but this doesn’t mean you need to reference the same resource object. Instead, you create a pool of multiple instances of a resource and use a different one each time you render a frame. For example, as shown below, the CPU can write position data to a buffer used for frame `n+1`, at the same time that the GPU reads position data from a buffer used for frame `n`. By using multiple instances of a buffer, the CPU and the GPU can work continuously and avoid stalls as long as you keep rendering frames.\n\n\n\n### Initialize data with the CPU\n\nDefine a custom `AAPLVertex` structure that represents a vertex. Each vertex has a position and a color:\n\n```objective-c\ntypedef struct\n{\n    vector_float2 position;\n    vector_float4 color;\n} AAPLVertex;\n```\n\nDefine a custom `AAPLTriangle` class that provides an interface to a default triangle, which is made up of 3 vertices:\n\n```objective-c\n+(const AAPLVertex *)vertices\n{\n    const float TriangleSize = 64;\n    static const AAPLVertex triangleVertices[] =\n    {\n        \/\/ Pixel Positions,                          RGBA colors.\n        { { -0.5*TriangleSize, -0.5*TriangleSize },  { 1, 1, 1, 1 } },\n        { {  0.0*TriangleSize, +0.5*TriangleSize },  { 1, 1, 1, 1 } },\n        { { +0.5*TriangleSize, -0.5*TriangleSize },  { 1, 1, 1, 1 } }\n    };\n    return triangleVertices;\n}\n```\n\nInitialize multiple triangle vertices with a position and a color, and store them in an array of triangles, `_triangles`:\n\n```objective-c\nNSMutableArray *triangles = [[NSMutableArray alloc] initWithCapacity:NumTriangles];\n\n\/\/ Initialize each triangle.\nfor(NSUInteger t = 0; t < NumTriangles; t++)\n{\n    vector_float2 trianglePosition;\n\n    \/\/ Determine the starting position of the triangle in a horizontal line.\n    trianglePosition.x = ((-((float)NumTriangles) \/ 2.0) + t) * horizontalSpacing;\n    trianglePosition.y = 0.0;\n\n    \/\/ Create the triangle, set its properties, and add it to the array.\n    AAPLTriangle * triangle = [AAPLTriangle new];\n    triangle.position = trianglePosition;\n    triangle.color = Colors[t % NumColors];\n    [triangles addObject:triangle];\n}\n_triangles = triangles;\n```\n\n### Allocate data storage\n\nCalculate the total storage size of your triangle vertices. Your app renders 50 triangles; each triangle has 3 vertices, totaling 150 vertices, and each vertex is the size of `AAPLVertex`:\n\n```objective-c\nconst NSUInteger triangleVertexCount = [AAPLTriangle vertexCount];\n_totalVertexCount = triangleVertexCount * _triangles.count;\nconst NSUInteger triangleVertexBufferSize = _totalVertexCount * sizeof(AAPLVertex);\n```\n\nInitialize multiple buffers to store multiple copies of your vertex data. For each buffer, allocate exactly enough memory to store 150 vertices:\n\n```objective-c\nfor(NSUInteger bufferIndex = 0; bufferIndex < MaxFramesInFlight; bufferIndex++)\n{\n    _vertexBuffers[bufferIndex] = [_device newBufferWithLength:triangleVertexBufferSize\n                                                       options:MTLResourceStorageModeShared];\n    _vertexBuffers[bufferIndex].label = [NSString stringWithFormat:@\"Vertex Buffer #%lu\", (unsigned long)bufferIndex];\n}\n```\n\nUpon initialization, the contents of the buffer instances in the `_vertexBuffers` array are empty.\n\n### Update data with the CPU\n\nIn each frame, at the start of the [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKViewDelegate\/draw(in:)] render loop, use the CPU to update the contents of one buffer instance in the `updateState` method:\n\n```objective-c\n\/\/ Vertex data for the current triangles.\nAAPLVertex *currentTriangleVertices = _vertexBuffers[_currentBuffer].contents;\n\n\/\/ Update each triangle.\nfor(NSUInteger triangle = 0; triangle < NumTriangles; triangle++)\n{\n    vector_float2 trianglePosition = _triangles[triangle].position;\n\n    \/\/ Displace the y-position of the triangle using a sine wave.\n    trianglePosition.y = (sin(trianglePosition.x\/waveMagnitude + _wavePosition) * waveMagnitude);\n\n    \/\/ Update the position of the triangle.\n    _triangles[triangle].position = trianglePosition;\n\n    \/\/ Update the vertices of the current vertex buffer with the triangle's new position.\n    for(NSUInteger vertex = 0; vertex < triangleVertexCount; vertex++)\n    {\n        NSUInteger currentVertex = vertex + (triangle * triangleVertexCount);\n        currentTriangleVertices[currentVertex].position = triangleVertices[vertex].position + _triangles[triangle].position;\n        currentTriangleVertices[currentVertex].color = _triangles[triangle].color;\n    }\n}\n```\n\nAfter you update a buffer instance, you don’t access its data with the CPU for the rest of the frame.\n\n\n\n### Encode GPU commands\n\nNext, you encode commands that reference the buffer instance in a render pass:\n\n```objective-c\n[renderEncoder setVertexBuffer:_vertexBuffers[_currentBuffer]\n                        offset:0\n                       atIndex:AAPLVertexInputIndexVertices];\n\n\/\/ Set the viewport size.\n[renderEncoder setVertexBytes:&_viewportSize\n                       length:sizeof(_viewportSize)\n                      atIndex:AAPLVertexInputIndexViewportSize];\n\n\/\/ Draw the triangle vertices.\n[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle\n                  vertexStart:0\n                  vertexCount:_totalVertexCount];\n```\n\n### Commit and execute GPU commands\n\nAt the end of the render loop, call your command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/commit()] method to submit your work to the GPU:\n\n```objective-c\n[commandBuffer commit];\n```\n\nThe GPU begins its work and reads from the `vertices` buffer in the `RasterizerData` vertex shader, which takes the buffer instance as an input argument:\n\n```metal\nvertex RasterizerData\nvertexShader(const uint vertexID [[ vertex_id ]],\n             const device AAPLVertex *vertices [[ buffer(AAPLVertexInputIndexVertices) ]],\n             constant vector_uint2 *viewportSizePointer  [[ buffer(AAPLVertexInputIndexViewportSize) ]])\n```\n\n### Reuse multiple buffer instances in your app\n\nFor each frame, perform the following steps, as described above. A full frame’s work is finished when both processors have completed their work.\n\n1. Write data to a buffer instance.\n2. Encode commands that reference the buffer instance.\n3. Commit a command buffer that contains the encoded commands.\n4. Read data from the buffer instance.\n\nWhen a frame’s work is finalized, the CPU and the GPU no longer need the buffer instance used in that frame. However, discarding a used buffer instance and creating a new one for each frame is expensive and wasteful. Instead, as shown below, set up your app to cycle through a first in, first out (FIFO) queue of buffer instances, `_vertexBuffers`, that you can reuse. The maximum number of buffer instances in the queue is defined by the value of `MaxFramesInFlight`, set to 3:\n\n```objective-c\nstatic const NSUInteger MaxFramesInFlight = 3;\n```\n\nIn each frame, at the start of the render loop, you update the next buffer instance from the `_vertexBuffer` queue. You cycle through the queue sequentially and update only one buffer instance per frame; at the end of every third frame, you return to the start of the queue:\n\n```objective-c\n\/\/ Iterate through the Metal buffers, and cycle back to the first when you've written to the last.\n_currentBuffer = (_currentBuffer + 1) % MaxFramesInFlight;\n\n\/\/ Update buffer data.\n[self updateState];\n```\n\n\n\n### Manage the rate of CPU and GPU work\n\nWhen you have multiple instances of a buffer, you can make the CPU start work for frame `n+1` with one instance, while the GPU finishes work for frame `n` with another instance. This implementation improves your app’s efficiency by making the CPU and the GPU work simultaneously. However, you need to manage your app’s rate of work so you don’t exceed the number of buffer instances available.\n\nTo manage your app’s rate of work, use a semaphore to wait for full frame completions in case the CPU is working much faster than the GPU. A semaphore is a non-Metal object that you use to control access to a resource that’s shared across multiple processors (or threads). The semaphore has an associated counting value, which you decrement or increment, that indicates whether a processor has started or finished accessing a resource. In your app, a semaphore controls CPU and GPU access to buffer instances.\n\nYou initialize the semaphore with a counting value of `MaxFramesInFlight`, to match the number of buffer instances. This value indicates that your app can simultaneously work on a maximum of 3 frames at any given time:\n\n```objective-c\n_inFlightSemaphore = dispatch_semaphore_create(MaxFramesInFlight);\n```\n\nAt the start of the render loop, you decrement the semaphore’s counting value by 1. This indicates that you’re ready to work on a new frame. However, if the counting value falls below 0, the semaphore makes the CPU wait until you increment the value:\n\n```objective-c\ndispatch_semaphore_wait(_inFlightSemaphore, DISPATCH_TIME_FOREVER);\n```\n\nAt the end of the render loop, you register a command buffer completion handler. When the GPU completes the command buffer’s execution, it calls this completion handler and you increment the semaphore’s counting value by 1. This indicates that you’ve completed all work for a given frame and you can reuse the buffer instance used in that frame:\n\n```objective-c\n__block dispatch_semaphore_t block_semaphore = _inFlightSemaphore;\n[commandBuffer addCompletedHandler:^(id<MTLCommandBuffer> buffer)\n {\n     dispatch_semaphore_signal(block_semaphore);\n }];\n```\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/addCompletedHandler(_:)] method registers a block of code that’s called immediately after the GPU has finished executing the associated command buffer. Because you use only one command buffer per frame, receiving the completion callback indicates that the GPU has completed the frame.\n\n### Set the mutability of your buffers\n\nYour app performs all per-frame rendering setup on a single thread. First it writes data to a buffer instance with the CPU. After that, it encodes rendering commands that reference the buffer instance. Finally, it commits a command buffer for GPU execution. Because these tasks always happen in this order on a single thread, the app guarantees that it finishes writing data to a buffer instance before it encodes a command that references the buffer instance.\n\nThis order allows you to mark your buffer instances as immutable. When you configure your render pipeline descriptor, set the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPipelineBufferDescriptor\/mutability] property of the vertex buffer at the buffer instance index to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLMutability\/immutable]:\n\n```objective-c\npipelineStateDescriptor.vertexBuffers[AAPLVertexInputIndexVertices].mutability = MTLMutabilityImmutable;\n```\n\nMetal can optimize the performance of immutable buffers, but not mutable buffers. For best results, use immutable buffers as much as possible.\n\n## Synchronization\n\n- **Implementing a multistage image filter using heaps and events**: Use events to synchronize access to resources allocated on a heap.\n- **Implementing a multistage image filter using heaps and fences**: Use fences to synchronize access to resources allocated on a heap.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use events to synchronize access to resources allocated on a heap.",
          "name" : "Implementing a multistage image filter using heaps and events",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-a-multistage-image-filter-using-heaps-and-events"
        },
        {
          "description" : "Use fences to synchronize access to resources allocated on a heap.",
          "name" : "Implementing a multistage image filter using heaps and fences",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-a-multistage-image-filter-using-heaps-and-fences"
        }
      ],
      "title" : "Synchronization"
    }
  ],
  "source" : "appleJSON",
  "title" : "Synchronizing CPU and GPU work",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/synchronizing-cpu-and-gpu-work"
}