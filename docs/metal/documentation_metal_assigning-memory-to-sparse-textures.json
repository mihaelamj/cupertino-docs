{
  "abstract" : "Use a resource state encoder to allocate and deallocate sparse tiles for a sparse texture.",
  "codeExamples" : [

  ],
  "contentHash" : "224c3858afba9d58f0fe679be79a2e064f6a11737ab3ac581b6baf703e57144b",
  "crawledAt" : "2025-12-04T02:20:13Z",
  "id" : "D641A748-2020-41DE-8A17-28D7E7805830",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nA sparse texture has storage only when you explicitly provide it. Every mipmap in the texture is partitioned into tile-sized regions. Each region can be in one of three states:\n\nInitially, all of the texture’s regions are unmapped. To provide data for a region, you ask the GPU to map regions in the texture to sparse tiles on the texture’s heap, and then copy or render data into those regions. When a region no longer needs memory, you unmap the region to free up its memory for future requests.\n\n### Map or unmap sparse tiles\n\nTo map or unmap sparse tiles, you issue commands to the GPU using a resource state command encoder ([doc:\/\/com.apple.metal\/documentation\/Metal\/MTLResourceStateCommandEncoder]). Encode a command for each update, specifying the texture, a slice and mipmap within that texture, and a region inside that mipmap. Specify the region in tile coordinates.\n\nThe GPU looks for free sparse tiles on the texture’s heap and assigns them to the texture. Once the mapping process is complete, future requests to read, write, or sample those regions access the assigned tiles. Metal doesn’t initialize the tiles with data, so to ensure that valid data is available, copy or render data into the newly mapped regions before you read or sample from them.\n\nThe GPU fulfills mapping requests in the order that you encoded the commands. Within each command, the GPU maps the tiles in a row-major order on a first-come, first-served basis. If the heap runs out of memory, Metal skips any remaining tiles in the request.\n\nTo free tiles and make additional memory available to satisfy other requests, encode commands using the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSparseTextureMappingMode\/unmap] mode instead.\n\n### Map the tail mipmaps after you create the texture\n\nIf you create a complete mipmap chain for your texture, many of the lower-level mipmaps are smaller than the sparse tile size. To save memory, Metal packs all of these smaller mipmaps into one memory allocation, typically one sparse tile. To guarantee that a texture always has some data to sample, you usually want to map the tail mipmaps after you create the texture and keep the tail mapped until you’re ready to release the texture.\n\nTo map the tail mipmaps, ask the texture for the first mipmap in the tail and map any region within it. All of the tail mipmaps are mapped.\n\nSimilarly, if you unmap the first mipmap in the tail, all of the tail mipmaps are unmapped.\n\n### Synchronize access to tile mapping and unmapping\n\nTile mapping is performed by the GPU, which means that it happens asynchronously at a future point after you commit the command buffer. Don’t change the memory assigned to a texture while the texture’s contents are being read or written. Use fences or events to ensure that these actions don’t overlap.\n\nFor more information about synchronizing Metal commands, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/assigning-memory-to-sparse-textures\ncrawled: 2025-12-04T02:20:13Z\n---\n\n# Assigning memory to sparse textures\n\n**Article**\n\nUse a resource state encoder to allocate and deallocate sparse tiles for a sparse texture.\n\n## Overview\n\nA sparse texture has storage only when you explicitly provide it. Every mipmap in the texture is partitioned into tile-sized regions. Each region can be in one of three states:\n\n- *Unmapped —* The region has no memory storage.\n- *Uninitialized —* You’ve mapped a sparse tile to the region, but provided no texture data.\n- *Initialized* — You’ve mapped a sparse tile and provided texture data.\n\nInitially, all of the texture’s regions are unmapped. To provide data for a region, you ask the GPU to map regions in the texture to sparse tiles on the texture’s heap, and then copy or render data into those regions. When a region no longer needs memory, you unmap the region to free up its memory for future requests.\n\n### Map or unmap sparse tiles\n\nTo map or unmap sparse tiles, you issue commands to the GPU using a resource state command encoder ([doc:\/\/com.apple.metal\/documentation\/Metal\/MTLResourceStateCommandEncoder]). Encode a command for each update, specifying the texture, a slice and mipmap within that texture, and a region inside that mipmap. Specify the region in tile coordinates.\n\n\n\nThe GPU looks for free sparse tiles on the texture’s heap and assigns them to the texture. Once the mapping process is complete, future requests to read, write, or sample those regions access the assigned tiles. Metal doesn’t initialize the tiles with data, so to ensure that valid data is available, copy or render data into the newly mapped regions before you read or sample from them.\n\nThe GPU fulfills mapping requests in the order that you encoded the commands. Within each command, the GPU maps the tiles in a row-major order on a first-come, first-served basis. If the heap runs out of memory, Metal skips any remaining tiles in the request.\n\nTo free tiles and make additional memory available to satisfy other requests, encode commands using the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSparseTextureMappingMode\/unmap] mode instead.\n\n\n\n### Map the tail mipmaps after you create the texture\n\nIf you create a complete mipmap chain for your texture, many of the lower-level mipmaps are smaller than the sparse tile size. To save memory, Metal packs all of these smaller mipmaps into one memory allocation, typically one sparse tile. To guarantee that a texture always has some data to sample, you usually want to map the tail mipmaps after you create the texture and keep the tail mapped until you’re ready to release the texture.\n\nTo map the tail mipmaps, ask the texture for the first mipmap in the tail and map any region within it. All of the tail mipmaps are mapped.\n\n\n\nSimilarly, if you unmap the first mipmap in the tail, all of the tail mipmaps are unmapped.\n\n### Synchronize access to tile mapping and unmapping\n\nTile mapping is performed by the GPU, which means that it happens asynchronously at a future point after you commit the command buffer. Don’t change the memory assigned to a texture while the texture’s contents are being read or written. Use fences or events to ensure that these actions don’t overlap.\n\n\n\nFor more information about synchronizing Metal commands, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization].\n\n## Sparse textures\n\n- **Managing sparse texture memory**: Take direct control of memory allocation for texture data by using sparse textures.\n- **Creating sparse heaps and sparse textures**: Allocate memory for sparse textures by creating a sparse heap.\n- **Converting between pixel regions and sparse tile regions**: Learn how a sparse texture’s contents are organized in memory.\n- **Reading and writing to sparse textures**: Decide how to handle access to unmapped texture regions.\n- **Estimating how often a texture region is accessed**: Use texture access patterns to determine when you need to map a texture region.\n- **MTLResourceStatePassDescriptor**: A configuration for a resource state pass, used to create a resource state command encoder.\n- **MTLResourceStatePassSampleBufferAttachmentDescriptor**: A description of where to store GPU counter information at the start and end of a resource state pass.\n- **MTLResourceStatePassSampleBufferAttachmentDescriptorArray**: An array of sample buffer attachments for a resource state pass.\n- **MTLResourceStateCommandEncoder**: An encoder that encodes commands that modify resource configurations.\n- **MTLMapIndirectArguments**: The data layout for mapping sparse texture regions when using indirect commands.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Take direct control of memory allocation for texture data by using sparse textures.",
          "name" : "Managing sparse texture memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-sparse-texture-memory"
        },
        {
          "description" : "Allocate memory for sparse textures by creating a sparse heap.",
          "name" : "Creating sparse heaps and sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-sparse-heaps-and-sparse-textures"
        },
        {
          "description" : "Learn how a sparse texture’s contents are organized in memory.",
          "name" : "Converting between pixel regions and sparse tile regions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/converting-between-pixel-regions-and-sparse-tile-regions"
        },
        {
          "description" : "Decide how to handle access to unmapped texture regions.",
          "name" : "Reading and writing to sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/reading-and-writing-to-sparse-textures"
        },
        {
          "description" : "Use texture access patterns to determine when you need to map a texture region.",
          "name" : "Estimating how often a texture region is accessed",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/estimating-how-often-a-texture-region-is-accessed"
        },
        {
          "description" : "A configuration for a resource state pass, used to create a resource state command encoder.",
          "name" : "MTLResourceStatePassDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassDescriptor"
        },
        {
          "description" : "A description of where to store GPU counter information at the start and end of a resource state pass.",
          "name" : "MTLResourceStatePassSampleBufferAttachmentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassSampleBufferAttachmentDescriptor"
        },
        {
          "description" : "An array of sample buffer attachments for a resource state pass.",
          "name" : "MTLResourceStatePassSampleBufferAttachmentDescriptorArray",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassSampleBufferAttachmentDescriptorArray"
        },
        {
          "description" : "An encoder that encodes commands that modify resource configurations.",
          "name" : "MTLResourceStateCommandEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStateCommandEncoder"
        },
        {
          "description" : "The data layout for mapping sparse texture regions when using indirect commands.",
          "name" : "MTLMapIndirectArguments",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLMapIndirectArguments"
        }
      ],
      "title" : "Sparse textures"
    }
  ],
  "source" : "appleJSON",
  "title" : "Assigning memory to sparse textures",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/assigning-memory-to-sparse-textures"
}