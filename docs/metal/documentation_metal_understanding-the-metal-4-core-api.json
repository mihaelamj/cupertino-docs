{
  "abstract" : "Discover the features and functionality in the Metal 4 foundational APIs.",
  "codeExamples" : [

  ],
  "contentHash" : "60fad9211d4c5144c6b727724278b49d9098d13c753e8c91502cff8186d8af0b",
  "crawledAt" : "2025-12-02T19:56:02Z",
  "id" : "8ABF3581-416A-4CAC-9701-4F08EB9C68C8",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nMetal 4 improves runtime performance and memory efficiency while making it easier to adapt your apps and games from other platforms, such as DirectX and Vulkan.\n\nMetal 4 introduces new types for existing concepts and several new ones, including:\n\nMetal 4 introduces several types with the `MTL4` prefix that are completely independent from the original `MTL` types they replace, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] versus [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue]. Other types are common to all versions of Metal.\n\nAt runtime, your app can detect whether the current system supports Metal 4. For devices that support Metal 4, you can create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue], otherwise, create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue]. The type of queue you create with determines which family of types you work with. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/work-submission].\n\nYou can incrementally adopt Metal 4 over time, which is convenient for larger projects. Portions of your app can individually switch to submitting work to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instance. When applicable, an app can synchronize the work it sends to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] with other parts of the app that send work to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue] instances. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization].\n\n### Command queues\n\nMetal 4 introduces a new command queue protocol, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue], which reduces CPU runtime and memory overhead by sending work to the GPU when you commit a command buffer. This means your app can submit work from any thread. You create a Metal 4 command queue by calling an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] factory method, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeMTL4CommandQueue()].\n\nMetal 4 command queues can commit multiple command buffers as a group. Apps can encode subsets of GPU work to multiple command buffers — each on a separate worker thread. When the worker threads finish encoding to their respective command buffers, you send the command buffers to the GPU as a whole by committing it to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instance with one of its methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue\/commit:count:]. This is similar to how you use an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLParallelRenderCommandEncoder], but different in that you can also apply other types of work in addition to rendering.\n\nYou can synchronize work between command queues with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLEvent] instance, or synchronize work on the CPU and other Metal devices with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] instance. Events work with any combination of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instances. This interoperability makes it easier for you to:\n\nYou can synchronize work within the same queue by adding a barrier (see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization]).\n\n### Command buffers\n\nMetal 4 introduces [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer], which is more efficient and works differently than [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer] in the following ways:\n\n\n\nAfter committing a command buffer to a queue, you can use it again by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method. You can then encode commands to the buffer as if it were a new instance. This is different from previous versions of Metal that require you to create a new transient, single-use command buffer when you need to commit more work to a queue.\n\n### Command allocators\n\nThe *command allocator* is a companion type that provides memory for command buffers. You associate a command allocator with one command buffer at a time by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method. When you finish encoding commands to a command buffer, you can apply the allocator to another command buffer by first calling the current command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/endCommandBuffer()] method and then another command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method.\n\nEach allocator manages the memory that your app needs to encode commands into the command buffer that you associate with it. Like command buffers, you create each new [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator] instance by calling a factory method of an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice], such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeCommandAllocator()].\n\nYour app can manage the memory that it requires by using a command allocator for each frame’s work. When the GPU finishes the work for that frame, call the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator\/reset()] method to release the memory for reuse.\n\nApps can render frames by reusing a series of allocators, one for each frame it might have in flight at the same time to begin working on the next frame.\n\nFor example, the sample code project, [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4] (Hello Triangle), works with three frames at the same time:\n\nAt any point, each in-flight frame is in a different part of its life cycle.\n\n### Command encoders\n\nThe *command encoder*, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder], is a base protocol for other work-specific protocols that Metal provides, including:\n\nThe base command encoder protocol defines a different interface and default behavior than its earlier counterpart, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandEncoder]. The most important difference with Metal 4 encoders is that they don’t have methods that bind individual buffers, textures, and heaps. Instead, you configure the resource bindings in an argument table and then bind that table to one or more pipeline stages with a command encoder.\n\nUse [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4MachineLearningCommandEncoder] to encodes inference commands that apply [doc:\/\/com.apple.documentation\/documentation\/CoreML] models into a command buffer, alongside your app’s rendering and computation workloads. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/machine-learning-passes].\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder] protocol is the equivalent to its earlier counterpart, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder], and has most of the same rendering methods. `MTL4RenderCommandEncoder` differs from `MTLRenderCommandEncoder` by removing methods that manage resource bindings and residency sets, and methods that configure store-action options and tessellation. Instead, `MTL4RenderCommandEncoder` gives you the ability to:\n\n`MTL4RenderCommandEncoder` also supports encoding a render pass across command buffers by:\n\nThis technique conceptually replaces the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLParallelRenderCommandEncoder] protocol and simplifies encoding a render pass in parallel with multiple threads because each thread can have its own render encoder instead of tying all of them to a single render encoder.\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ComputeCommandEncoder] protocol is a new type that combines the functionality of its three predecessors:\n\n### Argument tables\n\nMetal 4 introduces an *argument table* type that stores bindings to resources, such as data buffers, textures, and samplers, on an encoder’s behalf. Argument tables can reduce your app’s memory footprint because:\n\nEach [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTable] instance stores a list for each resource type, which your app creates and maintains.\n\nAssign an argument table to one or more stages of a command encoder, and then the commands you encode with it can refer to the resources in the argument table’s lists, such as textures and data buffers. You can also apply a single argument table to the stages of multiple encoders at the same time.\n\nAs your app adds render or dispatch work to a command buffer by calling an encoder’s methods, the encoder looks up the resources that the method needs from the encoder’s argument table.\n\nThe design adds flexibility for reducing your app’s CPU and memory overhead. For example, in Metal 4 you can create a single argument table that stores bindings to resources that apply to multiple encoders, and then reuse that argument table indefinitely. This is different from previous Metal versions, where each encoder instance manages its own resource binding tables. This approach is efficient compared to previous Metal encoder types, where each encoder instance manages its own resource binding tables. In Metal 4, the memory and runtime savings add up with each common resource your encoders share, and each time you assign the argument table to a new encoder.\n\n### Barriers\n\nEarlier versions of Metal support tracking data hazards for textures and heaps you create with hazard tracking (see the `hazardTrackingMode` property of the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLHeapDescriptor] types, respectively).\n\nIn Metal 4, the framework considers all resources untracked. You need to synchronize pipeline stages that can concurrently access a resource if any of the shaders in these pipelines modify it. For example, apps commonly encode a pass that writes to a common buffer that a later pass needs to read from to do its work, such as rendering to a texture.\n\nOne of the most efficient ways to synchronize work between two or more passes is to add a *barrier*. A barrier tells the GPU that it needs to avoid a race condition by delaying the start of a pipeline stage until a previous stage finishes, so that it’s safe to access the results of that stage. For example, if an app encodes a compute pass that produces data that a subsequent render pass consumes in its fragment shader, the app needs to add a barrier between the compute pass’s dispatch stage and the render pass’s fragment stage. In that scenario, the barrier signals to the GPU that it needs to wait before running the fragment stage of the render pass’s pipeline until the compute pass’s dispatch stage finishes modifying common resources.\n\n### Texture view pools\n\nMetal 4 introduces the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureViewPool] protocol which creates lightweight texture views that can reduce your app’s memory footprint compared to creating the equivalent instances of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture]. Each [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture] instance is a heavyweight type that stores a texture’s underlying data and metadata. Each texture also has an implicit *texture view*, which is the default format interpretation of the texture’s underlying data. With a texture view pool, you can create lightweight texture views that interpret and access a texture’s underlying data with a different format that its original. For example, you can create [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture] instance with its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture\/pixelFormat] equal to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPixelFormat\/rgba32Uint], and then create a new texture view of the same texture that interprets the underlying data as if its pixel format is [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPixelFormat\/rg11b10Float].\n\nEvery texture view has a unique [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLResourceID], which includes:\n\nThe resource IDs that a texture pool creates is part of a contiguous range of values that belong to that pool. For example, for a texture view pool that has 20 texture views, you can get the resource ID of the fifth texture view by adding `4` to the first texture view’s resource ID. Similarly, you can get the resource ID of the last (twentieth) texture view by adding `19` to the first texture view’s resource ID.\n\nYou can reuse a resource ID within a texture view pool, such as when you no longer need it, by reassigning the index of that pool with another view of any texture.\n\nA texture view pool has a contiguous range of `MTLResourceID` values that you can manage by creating lightweight texture view, each of which gets its own resource ID. You can repurpose any ID in the pool to another view when you no longer need the view that it currently represents.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/metal\/understanding-the-metal-4-core-api\ncrawled: 2025-12-02T19:56:02Z\n---\n\n# Understanding the Metal 4 core API\n\n**Article**\n\nDiscover the features and functionality in the Metal 4 foundational APIs.\n\n## Overview\n\nMetal 4 improves runtime performance and memory efficiency while making it easier to adapt your apps and games from other platforms, such as DirectX and Vulkan.\n\nMetal 4 introduces new types for existing concepts and several new ones, including:\n\n- Command queues\n- Command buffers\n- Command encoders\n- Command allocators\n- Argument tables\n- Texture view pools\n- Next generation barriers\n\nMetal 4 introduces several types with the `MTL4` prefix that are completely independent from the original `MTL` types they replace, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] versus [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue]. Other types are common to all versions of Metal.\n\n\n\nAt runtime, your app can detect whether the current system supports Metal 4. For devices that support Metal 4, you can create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue], otherwise, create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue]. The type of queue you create with determines which family of types you work with. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/work-submission].\n\nYou can incrementally adopt Metal 4 over time, which is convenient for larger projects. Portions of your app can individually switch to submitting work to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instance. When applicable, an app can synchronize the work it sends to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] with other parts of the app that send work to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue] instances. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization].\n\n### Command queues\n\nMetal 4 introduces a new command queue protocol, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue], which reduces CPU runtime and memory overhead by sending work to the GPU when you commit a command buffer. This means your app can submit work from any thread. You create a Metal 4 command queue by calling an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] factory method, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeMTL4CommandQueue()].\n\nMetal 4 command queues can commit multiple command buffers as a group. Apps can encode subsets of GPU work to multiple command buffers — each on a separate worker thread. When the worker threads finish encoding to their respective command buffers, you send the command buffers to the GPU as a whole by committing it to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instance with one of its methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue\/commit:count:]. This is similar to how you use an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLParallelRenderCommandEncoder], but different in that you can also apply other types of work in addition to rendering.\n\nYou can synchronize work between command queues with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLEvent] instance, or synchronize work on the CPU and other Metal devices with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLSharedEvent] instance. Events work with any combination of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instances. This interoperability makes it easier for you to:\n\n- Coordinate work between your app’s Metal 4 queues and existing Metal code.\n- Transition to Metal 4 over time and incrementally adopt its features.\n\nYou can synchronize work within the same queue by adding a barrier (see [doc:\/\/com.apple.metal\/documentation\/Metal\/resource-synchronization]).\n\n### Command buffers\n\nMetal 4 introduces [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer], which is more efficient and works differently than [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer] in the following ways:\n\n- You create a Metal 4 command buffer by calling an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] factory method, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeCommandBuffer()], instead of from a queue.\n- You submit a command buffer to any [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue] instance that belongs to the same device by calling one its methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandQueue\/commit:count:], unlike [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer] which has its own [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer\/commit()] method.\n- You can reuse and repurpose each command buffer indefinitely by starting over, encoding new commands, and committing it again, instead of allocating a new buffer.\n- Unlike the default behavior of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer], you may need to consider a resource’s retain count because each [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer] instance doesn’t create strong references to resources. This is similar to creating an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandBuffer] with the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue\/makeCommandBufferWithUnretainedReferences()] method of an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandQueue].\n\n\n\nAfter committing a command buffer to a queue, you can use it again by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method. You can then encode commands to the buffer as if it were a new instance. This is different from previous versions of Metal that require you to create a new transient, single-use command buffer when you need to commit more work to a queue.\n\n### Command allocators\n\nThe *command allocator* is a companion type that provides memory for command buffers. You associate a command allocator with one command buffer at a time by calling its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method. When you finish encoding commands to a command buffer, you can apply the allocator to another command buffer by first calling the current command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/endCommandBuffer()] method and then another command buffer’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandBuffer\/beginCommandBuffer(allocator:)] method.\n\nEach allocator manages the memory that your app needs to encode commands into the command buffer that you associate with it. Like command buffers, you create each new [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator] instance by calling a factory method of an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice], such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeCommandAllocator()].\n\nYour app can manage the memory that it requires by using a command allocator for each frame’s work. When the GPU finishes the work for that frame, call the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandAllocator\/reset()] method to release the memory for reuse.\n\nApps can render frames by reusing a series of allocators, one for each frame it might have in flight at the same time to begin working on the next frame.\n\nFor example, the sample code project, [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4] (Hello Triangle), works with three frames at the same time:\n\n\n\nAt any point, each in-flight frame is in a different part of its life cycle.\n\n- The current frame is what the app displays until the GPU finishes rendering the next frame.\n- Meanwhile, the GPU is rendering the first future frame from the most recent command buffers that the app submits to the GPU.\n- The app encodes the second future frame — either on the CPU or GPU — and submits the frame when other frames advance to the next stage in their life cycle.\n\n### Command encoders\n\nThe *command encoder*, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4CommandEncoder], is a base protocol for other work-specific protocols that Metal provides, including:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4MachineLearningCommandEncoder]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ComputeCommandEncoder]\n\nThe base command encoder protocol defines a different interface and default behavior than its earlier counterpart, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLCommandEncoder]. The most important difference with Metal 4 encoders is that they don’t have methods that bind individual buffers, textures, and heaps. Instead, you configure the resource bindings in an argument table and then bind that table to one or more pipeline stages with a command encoder.\n\nUse [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4MachineLearningCommandEncoder] to encodes inference commands that apply [doc:\/\/com.apple.documentation\/documentation\/CoreML] models into a command buffer, alongside your app’s rendering and computation workloads. For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/machine-learning-passes].\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4RenderCommandEncoder] protocol is the equivalent to its earlier counterpart, [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder], and has most of the same rendering methods. `MTL4RenderCommandEncoder` differs from `MTLRenderCommandEncoder` by removing methods that manage resource bindings and residency sets, and methods that configure store-action options and tessellation. Instead, `MTL4RenderCommandEncoder` gives you the ability to:\n\n- Add a residency set to either an encoder’s command buffer, or the command queue you submit that command buffer to.\n- Create an argument table, configure it with bindings to resources, and then assign it to an encoder that refers to those resources.\n- Apply mesh shader techniques to replace tessellation functionality.\n\n\n\n`MTL4RenderCommandEncoder` also supports encoding a render pass across command buffers by:\n\n- Suspending the work at the end of one render encoder\n- Resuming the work after the beginning of the next render encoder in the sequence\n\nThis technique conceptually replaces the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLParallelRenderCommandEncoder] protocol and simplifies encoding a render pass in parallel with multiple threads because each thread can have its own render encoder instead of tying all of them to a single render encoder.\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ComputeCommandEncoder] protocol is a new type that combines the functionality of its three predecessors:\n\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBlitCommandEncoder]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLComputeCommandEncoder]\n- [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLAccelerationStructureCommandEncoder]\n\n### Argument tables\n\nMetal 4 introduces an *argument table* type that stores bindings to resources, such as data buffers, textures, and samplers, on an encoder’s behalf. Argument tables can reduce your app’s memory footprint because:\n\n- Metal 4 encoders don’t require memory for storing the binding tables for every resource type, at every stage.\n- Each table consumes only the memory it needs to store its resource bindings.\n\nEach [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTable] instance stores a list for each resource type, which your app creates and maintains.\n\n- Create or reuse an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTableDescriptor] instance.\n- Configure how many bindings of each type it stores by configuring its properties, including [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTableDescriptor\/maxBufferBindCount] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTableDescriptor\/maxTextureBindCount].\n- Create an argument table by passing the descriptor instance to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice] factory method, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeArgumentTable(descriptor:)].\n- Add or update bindings to the argument table by calling its methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTable\/setResource(_:bufferIndex:)] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTL4ArgumentTable\/setSamplerState(_:index:)].\n\nAssign an argument table to one or more stages of a command encoder, and then the commands you encode with it can refer to the resources in the argument table’s lists, such as textures and data buffers. You can also apply a single argument table to the stages of multiple encoders at the same time.\n\nAs your app adds render or dispatch work to a command buffer by calling an encoder’s methods, the encoder looks up the resources that the method needs from the encoder’s argument table.\n\nThe design adds flexibility for reducing your app’s CPU and memory overhead. For example, in Metal 4 you can create a single argument table that stores bindings to resources that apply to multiple encoders, and then reuse that argument table indefinitely. This is different from previous Metal versions, where each encoder instance manages its own resource binding tables. This approach is efficient compared to previous Metal encoder types, where each encoder instance manages its own resource binding tables. In Metal 4, the memory and runtime savings add up with each common resource your encoders share, and each time you assign the argument table to a new encoder.\n\n\n\n### Barriers\n\nEarlier versions of Metal support tracking data hazards for textures and heaps you create with hazard tracking (see the `hazardTrackingMode` property of the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureDescriptor] and [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLHeapDescriptor] types, respectively).\n\nIn Metal 4, the framework considers all resources untracked. You need to synchronize pipeline stages that can concurrently access a resource if any of the shaders in these pipelines modify it. For example, apps commonly encode a pass that writes to a common buffer that a later pass needs to read from to do its work, such as rendering to a texture.\n\nOne of the most efficient ways to synchronize work between two or more passes is to add a *barrier*. A barrier tells the GPU that it needs to avoid a race condition by delaying the start of a pipeline stage until a previous stage finishes, so that it’s safe to access the results of that stage. For example, if an app encodes a compute pass that produces data that a subsequent render pass consumes in its fragment shader, the app needs to add a barrier between the compute pass’s dispatch stage and the render pass’s fragment stage. In that scenario, the barrier signals to the GPU that it needs to wait before running the fragment stage of the render pass’s pipeline until the compute pass’s dispatch stage finishes modifying common resources.\n\n### Texture view pools\n\nMetal 4 introduces the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureViewPool] protocol which creates lightweight texture views that can reduce your app’s memory footprint compared to creating the equivalent instances of [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture]. Each [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture] instance is a heavyweight type that stores a texture’s underlying data and metadata. Each texture also has an implicit *texture view*, which is the default format interpretation of the texture’s underlying data. With a texture view pool, you can create lightweight texture views that interpret and access a texture’s underlying data with a different format that its original. For example, you can create [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture] instance with its [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture\/pixelFormat] equal to [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPixelFormat\/rgba32Uint], and then create a new texture view of the same texture that interprets the underlying data as if its pixel format is [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPixelFormat\/rg11b10Float].\n\nEvery texture view has a unique [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLResourceID], which includes:\n\n- Texture views you create with an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTextureViewPool] instance’s methods, which is the return value of those methods\n- Implicit texture views that Metal assigns to each [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture] you create, which you can access with a texture’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLTexture\/gpuResourceID] property\n\nThe resource IDs that a texture pool creates is part of a contiguous range of values that belong to that pool. For example, for a texture view pool that has 20 texture views, you can get the resource ID of the fifth texture view by adding `4` to the first texture view’s resource ID. Similarly, you can get the resource ID of the last (twentieth) texture view by adding `19` to the first texture view’s resource ID.\n\nYou can reuse a resource ID within a texture view pool, such as when you no longer need it, by reassigning the index of that pool with another view of any texture.\n\nA texture view pool has a contiguous range of `MTLResourceID` values that you can manage by creating lightweight texture view, each of which gets its own resource ID. You can repurpose any ID in the pool to another view when you no longer need the view that it currently represents.\n\n## Essentials\n\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Performing calculations on a GPU**: Use Metal to find GPUs and perform calculations on them.\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Use Metal to find GPUs and perform calculations on them.",
          "name" : "Performing calculations on a GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/performing-calculations-on-a-gpu"
        },
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Understanding the Metal 4 core API",
  "url" : "https:\/\/developer.apple.com\/documentation\/metal\/understanding-the-metal-4-core-api"
}