{
  "abstract" : "Define how the Metal translator builds binary archives without precompiled binaries as a starting source.",
  "codeExamples" : [
    {
      "code" : "{\n  \"libraries\": {\n    \"paths\": [\n      {\n        \"label\": \"LibRender\",\n        \"path\": \".\/render.metallib\"\n      }\n    ]\n  }\n}",
      "language" : "json"
    },
    {
      "code" : "{\n  \"libraries\": {\n    \"paths\": [\n      {\n        \"label\": \"LibRender\",\n        \"path\": \".\/render.metallib\"\n      }\n    ]\n  },\n  \"pipelines\": {\n    \"render_pipelines\": [\n      {\n        \"vertex_function\": \"alias:LibRender#vertexShader\",\n        \"fragment_function\": \"alias:LibRender#fragmentShader\",\n        \"color_attachments\": [\n          {\n            \"pixel_format\": \"BGRA8Unorm\"\n          }\n        ]\n      }\n    ]\n  }\n}",
      "language" : "json"
    },
    {
      "code" : "{\n  \"pipelines\": {\n    \"compute_pipelines\": [\n      {\n        \"compute_function\": \"alias:LibRender#rayTracingKernel\",\n        \"linked_functions\": {\n          \"binary_functions\": [\n            \"sphereIntersection\",\n            \"evaluateGeometry\"\n          ]\n        }\n      }\n    ]\n  },\n  \"functions\": {\n    \"intersection_functions\": [\n      {\n        \"function\": \"alias:LibRender#sphereIntersection\"\n      }\n    ],\n    \"visible_functions\": [\n      {\n        \"function\": \"alias:LibRender#evaluateGeometry\"\n      }\n    ]\n  }\n}",
      "language" : "json"
    },
    {
      "code" : "{\n    \"specialized_functions\":[\n      {\n        \"label\": \"rayTracingWithIntersection\",\n        \"function\": \"alias:LibRender#rayTracingKernel\",\n        \"constant_values\": [\n          {\n            \"id_type\": \"FunctionConstantName\",\n            \"id\": \"useIntersectionFunctions\",\n            \"value_type\": \"ConstantBool\",\n            \"value\": {\n              \"data\": true\n            }\n          }\n        ]\n      },\n      {\n        \"label\": \"rayTracingNoIntersection\",\n        \"function\": \"alias:LibRender#rayTracingKernel\",\n        \"constant_values\": [\n          {\n            \"id_type\": \"FunctionConstantName\",\n            \"id\": \"useIntersectionFunctions\",\n            \"value_type\": \"ConstantBool\",\n            \"value\": {\n              \"data\": false\n            }\n          }\n        ]\n      }\n    ]\n  }\n}",
      "language" : "json"
    },
    {
      "code" : "{\n  \"pipelines\": {\n    \"compute_pipelines\": [\n      {\n        \"compute_function\": \"alias:rayTracingWithIntersection#rayTracingKernel\",\n        \"linked_functions\": {\n          \"binary_functions\": [\n            \"sphereIntersection\",\n            \"evaluateGeometry\"\n          ]\n        }\n      },\n      {\n        \"compute_function\": \"alias:rayTracingNoIntersection#rayTracingKernel\",\n      }\n    ]\n  }\n}",
      "language" : "json"
    },
    {
      "code" : "% xcrun -sdk iphoneos metal-tt render.metallib render.mtlp-json -o render.binary.metallib -target air64-apple-ios16.0",
      "language" : "shell"
    },
    {
      "code" : "% xcrun metal-lipo render.binary.metallib -archs\napplegpu_g10p applegpu_g5p applegpu_g9p applegpu_g9g applegpu_g11p applegpu_g12p applegpu_g13p applegpu_g13g applegpu_g14p applegpu_g14g applegpu_g16p applegpu_g15p",
      "language" : "shell"
    }
  ],
  "contentHash" : "a55225188dce1c55ea50fe6f9433f2c90edb2327be3dac88386d7118d7e47d17",
  "crawledAt" : "2025-12-03T14:49:49Z",
  "id" : "8225A4DE-0FEF-4ADD-BBDA-ECC5D8832036",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nCreating binary archives for additional GPU architectures, as [doc:\/\/com.apple.metal\/documentation\/Metal\/creating-binary-archives-from-device-built-pipeline-state-objects] describes, requires a compiled binary archive. To bypass this restriction, you can hand-author JSON configuration scripts that represent a pipeline state for the Metal translator. Hand-authoring configuration scripts gives you control over defining your pipeline states, and allows you to provide a script section of the JSON for conditional compilation on a per-architecture basis.\n\nThis article shows you how to create a Metal translator configuration script that represents a pipeline state, as the following code example demonstrates:\n\nThe code example above includes a render pipeline with a single-stage fragment and vertex shader, as well as a compute pipeline. The library `render.metallib` contains the Metal IR for the shaders, and `render.binary.metallib` is the binary you generate from the Metal translator. The compute kernel optonally uses ray tracing, depending on the value of `enableRayTracing`, and enabling ray tracing uses intersection functions.\n\n### Create your configuration script and add libraries\n\nCreate a file named `render.mtlp-json` in the same directory as `render.metallib`, and open it in a text editor. This is the configuration script the Metal translator uses to build your described pipeline states.\n\nThe basic format of this file is a JSON dictionary containing at least two keys, `libraries` and `pipelines`. The `libraries` key defines which compiled Metal libraries contain your compiled shaders, as an array of paths. Each path is a dictionary with a label that defines how you refer to the library in the configuration script, and a path that points to the library itself. The following code example is the start of a configuration script that sets the alias `LibRender` for the Metal library `render.metallib`:\n\n### Add render pipeline states\n\nEach pipeline in your configuration script needs a reference to shader functions and information about your app’s pipeline state when Metal invokes them. Any optional property that you omit from a pipeline description in the configuration script uses its default value, just as with a pipeline state descriptor instance in code. The example below creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor] instance for both a `vertexFunction` and a `fragmentFunction`. This render pipeline also uses a nondefault [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPixelFormat\/bgra8Unorm] pixel format.\n\nIn your translator configuration script, the top-level `pipelines` dictionary contains the definition for each pipeline. Inside this dictionary, the `render_pipelines` key contains an array of dictionaries describing your render pipelines. Function references use a format of `alias:<library name>#<function name>`.\n\nDictionaries describing render pipelines need both a `vertex_function` and a `fragment_function` key. The following code example is the JSON configuration script representation of the code above:\n\n### Add compute pipeline states with visible and intersection functions\n\nIn the following code example, the compute kernel uses the ray-tracing intersection function `sphereIntersection` and the visible function `evaluateGeometry`:\n\nTo add `sphereIntersection` and `evaluateGeometry` to your binary archive, modify the top-level `functions` key of your configuration script. This key’s value is a dictionary that describes the functions available to the Metal translator during compilation. Add the `intersection_functions` key for your intersection functions, and the v`isible_functions` key for visible functions. Each of these keys has an array of dictionaries containing the `function` key, which holds a reference to the function your shaders call.\n\nThe following code example is the JSON configuration script representation of the code above for a compute kernel named `rayTracingKernel`. Add the `compute_pipelines` key and value to your existing `pipelines` from adding the render pipeline, along with the new `functions` dictionary.\n\n### Add specialization constants for your compute pipeline\n\nIn this article’s code examples, the `enableRayTracing` constant controls whether the compute kernel uses ray-tracing support. In your app, you use `rayTracingKernel` for the compute kernel’s name, but each constant specializes the function to a single binary representation that has its own name. The following code example sets the specialized function names `rayTracingWithIntersection` and `rayTracingNoIntersection`, depending on the value of `enableRayTracing`:\n\nYour Metal pipeline state contains any constants shaders use, so your JSON configuration script needs to map these constants to a specialized function name. In a Metal translator JSON configuration script, each constant has an `id_type` that defines how the `id` resolves in your app. Constants also have a `value_type` that defines the type of the constant, and a `value` that provides the constant itself. When Metal doesn’t find a specialized function for a constant, the system falls back to compile shaders from Metal IR.\n\nEach constant value is for a `FunctionConstantName` with the identifier `useIntersectionFunctions`, a type of `ConstantBool`. The only difference between the two specialized functions `rayTracingWithIntersection` and `rayTracingNoIntersection` is the `value.data` key, which is `true` for `rayTracingWithIntersection` and `false` for `rayTracingNoIntersection`.\n\nThe following code example is the JSON configuration script representation of the code above:\n\nIn addition to including the specialized function definitions for your libraries, provide a separate `pipelines.compute_pipelines` entry for each specialized kernel. Use the label of each specialized function definition, along with the name of your kernel, to refer to the specialization in your configuration script. Write aliases for specialized functions using the format of `alias:<specialization>#<function name>`.\n\nModify the existing `compile_pipelines` section from the JSON configuration script examples to contain the specializations for your compute pass.\n\n### Compile binary archives\n\nWith the Metal IR library and a configuration script that describes a pipeline state matching your app’s code, the Metal translator can compile GPU-specific binaries for any device that supports Metal. In Terminal, run the following `metal-tt` command to build for GPUs targeting iOS 16:\n\nBy default, `metal-tt` compiles for all GPU architectures the target triple supports. Run the `metal-lipo` command-line tool in Terminal to confirm the binary archive’s contents.\n\n### Add the compiled binary archive to your app\n\nTo use your compiled Metal binary archive, you need to add it to your Xcode project’s bundle resources. Add the `precompiled.binary.metallib` archive to your project’s Copy Bundle Resources build phase. For instructions, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/customizing-the-build-phases-of-a-target].\n\nIn your code, load binary archives by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeBinaryArchive(descriptor:)] and add the resulting instances to your pipeline state descriptor’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFunctionDescriptor\/binaryArchives] property. For specialized, visible, and intersection functions, load them into an appropriate [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFunctionDescriptor] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFunctionDescriptor\/binaryArchives] property. The code examples throughout this article include sections for linking binary archives when a function has a precompiled shader.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/compiling-binary-archives-from-a-custom-configuration-script\ncrawled: 2025-12-03T14:49:49Z\n---\n\n# Compiling binary archives from a custom configuration script\n\n**Article**\n\nDefine how the Metal translator builds binary archives without precompiled binaries as a starting source.\n\n## Overview\n\nCreating binary archives for additional GPU architectures, as [doc:\/\/com.apple.metal\/documentation\/Metal\/creating-binary-archives-from-device-built-pipeline-state-objects] describes, requires a compiled binary archive. To bypass this restriction, you can hand-author JSON configuration scripts that represent a pipeline state for the Metal translator. Hand-authoring configuration scripts gives you control over defining your pipeline states, and allows you to provide a script section of the JSON for conditional compilation on a per-architecture basis.\n\nThis article shows you how to create a Metal translator configuration script that represents a pipeline state, as the following code example demonstrates:\n\n\n\nThe code example above includes a render pipeline with a single-stage fragment and vertex shader, as well as a compute pipeline. The library `render.metallib` contains the Metal IR for the shaders, and `render.binary.metallib` is the binary you generate from the Metal translator. The compute kernel optonally uses ray tracing, depending on the value of `enableRayTracing`, and enabling ray tracing uses intersection functions.\n\n### Create your configuration script and add libraries\n\nCreate a file named `render.mtlp-json` in the same directory as `render.metallib`, and open it in a text editor. This is the configuration script the Metal translator uses to build your described pipeline states.\n\n\n\nThe basic format of this file is a JSON dictionary containing at least two keys, `libraries` and `pipelines`. The `libraries` key defines which compiled Metal libraries contain your compiled shaders, as an array of paths. Each path is a dictionary with a label that defines how you refer to the library in the configuration script, and a path that points to the library itself. The following code example is the start of a configuration script that sets the alias `LibRender` for the Metal library `render.metallib`:\n\n```json\n{\n  \"libraries\": {\n    \"paths\": [\n      {\n        \"label\": \"LibRender\",\n        \"path\": \".\/render.metallib\"\n      }\n    ]\n  }\n}\n```\n\n### Add render pipeline states\n\nEach pipeline in your configuration script needs a reference to shader functions and information about your app’s pipeline state when Metal invokes them. Any optional property that you omit from a pipeline description in the configuration script uses its default value, just as with a pipeline state descriptor instance in code. The example below creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPipelineDescriptor] instance for both a `vertexFunction` and a `fragmentFunction`. This render pipeline also uses a nondefault [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLPixelFormat\/bgra8Unorm] pixel format.\n\n\n\nIn your translator configuration script, the top-level `pipelines` dictionary contains the definition for each pipeline. Inside this dictionary, the `render_pipelines` key contains an array of dictionaries describing your render pipelines. Function references use a format of `alias:<library name>#<function name>`.\n\nDictionaries describing render pipelines need both a `vertex_function` and a `fragment_function` key. The following code example is the JSON configuration script representation of the code above:\n\n```json\n{\n  \"libraries\": {\n    \"paths\": [\n      {\n        \"label\": \"LibRender\",\n        \"path\": \".\/render.metallib\"\n      }\n    ]\n  },\n  \"pipelines\": {\n    \"render_pipelines\": [\n      {\n        \"vertex_function\": \"alias:LibRender#vertexShader\",\n        \"fragment_function\": \"alias:LibRender#fragmentShader\",\n        \"color_attachments\": [\n          {\n            \"pixel_format\": \"BGRA8Unorm\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n\n### Add compute pipeline states with visible and intersection functions\n\nIn the following code example, the compute kernel uses the ray-tracing intersection function `sphereIntersection` and the visible function `evaluateGeometry`:\n\n\n\nTo add `sphereIntersection` and `evaluateGeometry` to your binary archive, modify the top-level `functions` key of your configuration script. This key’s value is a dictionary that describes the functions available to the Metal translator during compilation. Add the `intersection_functions` key for your intersection functions, and the v`isible_functions` key for visible functions. Each of these keys has an array of dictionaries containing the `function` key, which holds a reference to the function your shaders call.\n\nThe following code example is the JSON configuration script representation of the code above for a compute kernel named `rayTracingKernel`. Add the `compute_pipelines` key and value to your existing `pipelines` from adding the render pipeline, along with the new `functions` dictionary.\n\n```json\n{\n  \"pipelines\": {\n    \"compute_pipelines\": [\n      {\n        \"compute_function\": \"alias:LibRender#rayTracingKernel\",\n        \"linked_functions\": {\n          \"binary_functions\": [\n            \"sphereIntersection\",\n            \"evaluateGeometry\"\n          ]\n        }\n      }\n    ]\n  },\n  \"functions\": {\n    \"intersection_functions\": [\n      {\n        \"function\": \"alias:LibRender#sphereIntersection\"\n      }\n    ],\n    \"visible_functions\": [\n      {\n        \"function\": \"alias:LibRender#evaluateGeometry\"\n      }\n    ]\n  }\n}\n```\n\n\n\n### Add specialization constants for your compute pipeline\n\nIn this article’s code examples, the `enableRayTracing` constant controls whether the compute kernel uses ray-tracing support. In your app, you use `rayTracingKernel` for the compute kernel’s name, but each constant specializes the function to a single binary representation that has its own name. The following code example sets the specialized function names `rayTracingWithIntersection` and `rayTracingNoIntersection`, depending on the value of `enableRayTracing`:\n\n\n\nYour Metal pipeline state contains any constants shaders use, so your JSON configuration script needs to map these constants to a specialized function name. In a Metal translator JSON configuration script, each constant has an `id_type` that defines how the `id` resolves in your app. Constants also have a `value_type` that defines the type of the constant, and a `value` that provides the constant itself. When Metal doesn’t find a specialized function for a constant, the system falls back to compile shaders from Metal IR.\n\nEach constant value is for a `FunctionConstantName` with the identifier `useIntersectionFunctions`, a type of `ConstantBool`. The only difference between the two specialized functions `rayTracingWithIntersection` and `rayTracingNoIntersection` is the `value.data` key, which is `true` for `rayTracingWithIntersection` and `false` for `rayTracingNoIntersection`.\n\nThe following code example is the JSON configuration script representation of the code above:\n\n```json\n{\n    \"specialized_functions\":[\n      {\n        \"label\": \"rayTracingWithIntersection\",\n        \"function\": \"alias:LibRender#rayTracingKernel\",\n        \"constant_values\": [\n          {\n            \"id_type\": \"FunctionConstantName\",\n            \"id\": \"useIntersectionFunctions\",\n            \"value_type\": \"ConstantBool\",\n            \"value\": {\n              \"data\": true\n            }\n          }\n        ]\n      },\n      {\n        \"label\": \"rayTracingNoIntersection\",\n        \"function\": \"alias:LibRender#rayTracingKernel\",\n        \"constant_values\": [\n          {\n            \"id_type\": \"FunctionConstantName\",\n            \"id\": \"useIntersectionFunctions\",\n            \"value_type\": \"ConstantBool\",\n            \"value\": {\n              \"data\": false\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nIn addition to including the specialized function definitions for your libraries, provide a separate `pipelines.compute_pipelines` entry for each specialized kernel. Use the label of each specialized function definition, along with the name of your kernel, to refer to the specialization in your configuration script. Write aliases for specialized functions using the format of `alias:<specialization>#<function name>`.\n\nModify the existing `compile_pipelines` section from the JSON configuration script examples to contain the specializations for your compute pass.\n\n```json\n{\n  \"pipelines\": {\n    \"compute_pipelines\": [\n      {\n        \"compute_function\": \"alias:rayTracingWithIntersection#rayTracingKernel\",\n        \"linked_functions\": {\n          \"binary_functions\": [\n            \"sphereIntersection\",\n            \"evaluateGeometry\"\n          ]\n        }\n      },\n      {\n        \"compute_function\": \"alias:rayTracingNoIntersection#rayTracingKernel\",\n      }\n    ]\n  }\n}\n```\n\n### Compile binary archives\n\nWith the Metal IR library and a configuration script that describes a pipeline state matching your app’s code, the Metal translator can compile GPU-specific binaries for any device that supports Metal. In Terminal, run the following `metal-tt` command to build for GPUs targeting iOS 16:\n\n```shell\n% xcrun -sdk iphoneos metal-tt render.metallib render.mtlp-json -o render.binary.metallib -target air64-apple-ios16.0\n```\n\nBy default, `metal-tt` compiles for all GPU architectures the target triple supports. Run the `metal-lipo` command-line tool in Terminal to confirm the binary archive’s contents.\n\n```shell\n% xcrun metal-lipo render.binary.metallib -archs\napplegpu_g10p applegpu_g5p applegpu_g9p applegpu_g9g applegpu_g11p applegpu_g12p applegpu_g13p applegpu_g13g applegpu_g14p applegpu_g14g applegpu_g16p applegpu_g15p\n```\n\n### Add the compiled binary archive to your app\n\nTo use your compiled Metal binary archive, you need to add it to your Xcode project’s bundle resources. Add the `precompiled.binary.metallib` archive to your project’s Copy Bundle Resources build phase. For instructions, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/customizing-the-build-phases-of-a-target].\n\n\n\nIn your code, load binary archives by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLDevice\/makeBinaryArchive(descriptor:)] and add the resulting instances to your pipeline state descriptor’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFunctionDescriptor\/binaryArchives] property. For specialized, visible, and intersection functions, load them into an appropriate [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFunctionDescriptor] instance’s [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLFunctionDescriptor\/binaryArchives] property. The code examples throughout this article include sections for linking binary archives when a function has a precompiled shader.\n\n## Working with Metal binary archives\n\n- **Creating binary archives from device-built pipeline state objects**: Write your Metal pipeline states to a binary archive at app runtime, and build binaries for any supported GPU.\n- **Manipulating Metal binary archives**: Split precompiled binaries into individual slices, and combine them back together for targeted distribution.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Write your Metal pipeline states to a binary archive at app runtime, and build binaries for any supported GPU.",
          "name" : "Creating binary archives from device-built pipeline state objects",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-binary-archives-from-device-built-pipeline-state-objects"
        },
        {
          "description" : "Split precompiled binaries into individual slices, and combine them back together for targeted distribution.",
          "name" : "Manipulating Metal binary archives",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/manipulating-metal-binary-archives"
        }
      ],
      "title" : "Working with Metal binary archives"
    }
  ],
  "source" : "appleJSON",
  "title" : "Compiling binary archives from a custom configuration script",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/compiling-binary-archives-from-a-custom-configuration-script"
}