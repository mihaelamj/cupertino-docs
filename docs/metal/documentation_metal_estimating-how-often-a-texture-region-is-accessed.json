{
  "abstract" : "Use texture access patterns to determine when you need to map a texture region.",
  "codeExamples" : [

  ],
  "contentHash" : "5443b2115e3a45188f485ce892ab314325c87c35853af317b84fe926d76cce12",
  "crawledAt" : "2025-12-04T02:20:14Z",
  "id" : "7BBC0F8C-F747-400E-A623-76CAFF15F905",
  "kind" : "article",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nWhen you use sparse textures, you need to decide when to map or unmap texture regions. For example, one option is to map entire mipmaps, using existing techniques for determining which mipmaps are accessed. (For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/dynamically-adjusting-texture-level-of-detail]). You may also want to go further, and only map subregions within individual mipmaps. To help you do that, Metal provides a mechanism to estimate how often you access each region. When you detect a sufficient number of requests to a given region, you can map a sparse tile to it.\n\nWhen the GPU attempts to sample a pixel in texture memory:\n\nThe texture access count estimation comes from the number of cache misses, and isn’t an exact count of the number of memory operations to a specific region. If your app accesses the same regions frequently, because they’re more likely to be in the cache, the counts you receive from Metal might be smaller than the number of memory operations you actually made.\n\nTo take advantage of spatial locality, memory subsystems retrieve memory in larger chunks, called *cache lines*. A cache line is usually large enough to store multiple pixels of data, but the exact number of pixels depends on the pixel format.\n\nTo normalize the access counts, Metal increments the count as if you accessed all of the pixels in the cache line. For example, if a cache line is `64` bytes and a pixel is `4` bytes, the counter value increases by `16` `(64\/4)`. This abstraction means you can focus on the number of memory operations recorded, without needing to know the details of the underlying memory architecture.\n\nDetermine your own heuristics to decide how many pixel memory operations is sufficient to start mapping a sparse tile for that region.\n\n### Request the estimated texture access counts\n\nTo get the current access counts for a sparse texture, create a blit command encoder and encode commands to copy the GPU’s internal counters to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance. The following example code takes a tile region in the texture’s top-level mipmap, creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance large enough to accommodate all of the region’s tiles, and encodes a command to copy the counters.\n\nThe counters are organized as a 3D array of [doc:\/\/com.apple.documentation\/documentation\/kernel\/uint32_t] values, stored in row-major order. You tell the GPU whether to reset the access counters.\n\nIf you want information about more than one mipmap in the same texture or information about multiple textures, encode a separate command for each mipmap\/texture combination. Don’t allocate a buffer for each request; allocate larger [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instances and specify offsets within those buffers for each request.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/estimating-how-often-a-texture-region-is-accessed\ncrawled: 2025-12-04T02:20:14Z\n---\n\n# Estimating how often a texture region is accessed\n\n**Article**\n\nUse texture access patterns to determine when you need to map a texture region.\n\n## Overview\n\nWhen you use sparse textures, you need to decide when to map or unmap texture regions. For example, one option is to map entire mipmaps, using existing techniques for determining which mipmaps are accessed. (For more information, see [doc:\/\/com.apple.metal\/documentation\/Metal\/dynamically-adjusting-texture-level-of-detail]). You may also want to go further, and only map subregions within individual mipmaps. To help you do that, Metal provides a mechanism to estimate how often you access each region. When you detect a sufficient number of requests to a given region, you can map a sparse tile to it.\n\nWhen the GPU attempts to sample a pixel in texture memory:\n\n1. If the pixel is already in the GPU’s memory caches, it returns the cached pixel to your shader. Otherwise, it executes the remaining steps.\n2. The GPU increments its access counters and requests pixel data from the texture.\n3. If the sparse tile is mapped, after the request completes, the GPU puts the pixel data into the cache and returns it to your shader.\n4. If the sparse tile is unmapped, the GPU loads zeroed data into the cache and returns it to your shader.\n\nThe texture access count estimation comes from the number of cache misses, and isn’t an exact count of the number of memory operations to a specific region. If your app accesses the same regions frequently, because they’re more likely to be in the cache, the counts you receive from Metal might be smaller than the number of memory operations you actually made.\n\nTo take advantage of spatial locality, memory subsystems retrieve memory in larger chunks, called *cache lines*. A cache line is usually large enough to store multiple pixels of data, but the exact number of pixels depends on the pixel format.\n\nTo normalize the access counts, Metal increments the count as if you accessed all of the pixels in the cache line. For example, if a cache line is `64` bytes and a pixel is `4` bytes, the counter value increases by `16` `(64\/4)`. This abstraction means you can focus on the number of memory operations recorded, without needing to know the details of the underlying memory architecture.\n\nDetermine your own heuristics to decide how many pixel memory operations is sufficient to start mapping a sparse tile for that region.\n\n### Request the estimated texture access counts\n\nTo get the current access counts for a sparse texture, create a blit command encoder and encode commands to copy the GPU’s internal counters to an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance. The following example code takes a tile region in the texture’s top-level mipmap, creates an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instance large enough to accommodate all of the region’s tiles, and encodes a command to copy the counters.\n\n\n\nThe counters are organized as a 3D array of [doc:\/\/com.apple.documentation\/documentation\/kernel\/uint32_t] values, stored in row-major order. You tell the GPU whether to reset the access counters.\n\nIf you want information about more than one mipmap in the same texture or information about multiple textures, encode a separate command for each mipmap\/texture combination. Don’t allocate a buffer for each request; allocate larger [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLBuffer] instances and specify offsets within those buffers for each request.\n\n## Sparse textures\n\n- **Managing sparse texture memory**: Take direct control of memory allocation for texture data by using sparse textures.\n- **Creating sparse heaps and sparse textures**: Allocate memory for sparse textures by creating a sparse heap.\n- **Converting between pixel regions and sparse tile regions**: Learn how a sparse texture’s contents are organized in memory.\n- **Assigning memory to sparse textures**: Use a resource state encoder to allocate and deallocate sparse tiles for a sparse texture.\n- **Reading and writing to sparse textures**: Decide how to handle access to unmapped texture regions.\n- **MTLResourceStatePassDescriptor**: A configuration for a resource state pass, used to create a resource state command encoder.\n- **MTLResourceStatePassSampleBufferAttachmentDescriptor**: A description of where to store GPU counter information at the start and end of a resource state pass.\n- **MTLResourceStatePassSampleBufferAttachmentDescriptorArray**: An array of sample buffer attachments for a resource state pass.\n- **MTLResourceStateCommandEncoder**: An encoder that encodes commands that modify resource configurations.\n- **MTLMapIndirectArguments**: The data layout for mapping sparse texture regions when using indirect commands.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Take direct control of memory allocation for texture data by using sparse textures.",
          "name" : "Managing sparse texture memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/managing-sparse-texture-memory"
        },
        {
          "description" : "Allocate memory for sparse textures by creating a sparse heap.",
          "name" : "Creating sparse heaps and sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-sparse-heaps-and-sparse-textures"
        },
        {
          "description" : "Learn how a sparse texture’s contents are organized in memory.",
          "name" : "Converting between pixel regions and sparse tile regions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/converting-between-pixel-regions-and-sparse-tile-regions"
        },
        {
          "description" : "Use a resource state encoder to allocate and deallocate sparse tiles for a sparse texture.",
          "name" : "Assigning memory to sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/assigning-memory-to-sparse-textures"
        },
        {
          "description" : "Decide how to handle access to unmapped texture regions.",
          "name" : "Reading and writing to sparse textures",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/reading-and-writing-to-sparse-textures"
        },
        {
          "description" : "A configuration for a resource state pass, used to create a resource state command encoder.",
          "name" : "MTLResourceStatePassDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassDescriptor"
        },
        {
          "description" : "A description of where to store GPU counter information at the start and end of a resource state pass.",
          "name" : "MTLResourceStatePassSampleBufferAttachmentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassSampleBufferAttachmentDescriptor"
        },
        {
          "description" : "An array of sample buffer attachments for a resource state pass.",
          "name" : "MTLResourceStatePassSampleBufferAttachmentDescriptorArray",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStatePassSampleBufferAttachmentDescriptorArray"
        },
        {
          "description" : "An encoder that encodes commands that modify resource configurations.",
          "name" : "MTLResourceStateCommandEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLResourceStateCommandEncoder"
        },
        {
          "description" : "The data layout for mapping sparse texture regions when using indirect commands.",
          "name" : "MTLMapIndirectArguments",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLMapIndirectArguments"
        }
      ],
      "title" : "Sparse textures"
    }
  ],
  "source" : "appleJSON",
  "title" : "Estimating how often a texture region is accessed",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/estimating-how-often-a-texture-region-is-accessed"
}