{
  "abstract" : "Implement a lightweight view for Metal rendering that’s customized to your app’s needs.",
  "codeExamples" : [
    {
      "code" : "\/\/ When enabled, rendering occurs on the main application thread.\n\/\/ This can make responding to UI events during redraw simpler\n\/\/ to manage because UI calls usually need to occur on the main thread.\n\/\/ When disabled, rendering occurs on a background thread, allowing\n\/\/ the UI to respond more quickly in some cases because events can be\n\/\/ processed asynchronously from potentially CPU-intensive rendering code.\n#define RENDER_ON_MAIN_THREAD 1\n\n\/\/ When enabled, the view continually animates and renders\n\/\/ frames 60 times a second.  When disabled, rendering is event\n\/\/ based, occurring when a UI event requests a redraw.\n#define ANIMATION_RENDERING   1\n\n\/\/ When enabled, the drawable's size is updated automatically whenever\n\/\/ the view is resized. When disabled, you can update the drawable's\n\/\/ size explicitly outside the view class.\n#define AUTOMATICALLY_RESIZE  1\n\n\/\/ When enabled, the renderer creates a depth target (i.e. depth buffer)\n\/\/ and attaches with the render pass descritpr along with the drawable\n\/\/ texture for rendering.  This enables the app properly perform depth testing.\n#define CREATE_DEPTH_BUFFER   1",
      "language" : "objective-c"
    },
    {
      "code" : "+ (Class) layerClass\n{\n    return [CAMetalLayer class];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "self.wantsLayer = YES;",
      "language" : "objective-c"
    },
    {
      "code" : "- (CALayer *)makeBackingLayer\n{\n    return [CAMetalLayer layer];\n}",
      "language" : "objective-c"
    },
    {
      "code" : "_drawableRenderDescriptor = [MTLRenderPassDescriptor new];\n_drawableRenderDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;\n_drawableRenderDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;\n_drawableRenderDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0, 1, 1, 1);",
      "language" : "objective-c"
    },
    {
      "code" : "id<CAMetalDrawable> currentDrawable = [metalLayer nextDrawable];\n\n\/\/ If the current drawable is nil, skip rendering this frame\nif(!currentDrawable)\n{\n    return;\n}\n\n_drawableRenderDescriptor.colorAttachments[0].texture = currentDrawable.texture;",
      "language" : "objective-c"
    },
    {
      "code" : "- (void)setupCADisplayLinkForScreen:(UIScreen*)screen\n{\n    [self stopRenderLoop];\n\n    _displayLink = [screen displayLinkWithTarget:self selector:@selector(render)];\n\n    _displayLink.paused = self.paused;\n\n    _displayLink.preferredFramesPerSecond = 60;\n}",
      "language" : "objective-c"
    },
    {
      "code" : "- (BOOL)setupCVDisplayLinkForScreen:(NSScreen*)screen\n{\n#if RENDER_ON_MAIN_THREAD\n\n    \/\/ The CVDisplayLink callback, DispatchRenderLoop, never executes\n    \/\/ on the main thread. To execute rendering on the main thread, create\n    \/\/ a dispatch source using the main queue (the main thread).\n    \/\/ DispatchRenderLoop merges this dispatch source in each call\n    \/\/ to execute rendering on the main thread.\n    _displaySource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());\n    __weak AAPLView* weakSelf = self;\n    dispatch_source_set_event_handler(_displaySource, ^(){\n        @autoreleasepool\n        {\n            [weakSelf render];\n        }\n    });\n    dispatch_resume(_displaySource);\n\n#endif \/\/ END RENDER_ON_MAIN_THREAD\n\n    CVReturn cvReturn;\n\n    \/\/ Create a display link capable of being used with all active displays\n    cvReturn = CVDisplayLinkCreateWithActiveCGDisplays(&_displayLink);\n\n    if(cvReturn != kCVReturnSuccess)\n    {\n        return NO;\n    }\n\n#if RENDER_ON_MAIN_THREAD\n\n    \/\/ Set DispatchRenderLoop as the callback function and\n    \/\/ supply _displaySource as the argument to the callback.\n    cvReturn = CVDisplayLinkSetOutputCallback(_displayLink, &DispatchRenderLoop, (__bridge void*)_displaySource);\n\n#else \/\/ IF !RENDER_ON_MAIN_THREAD\n\n    \/\/ Set DispatchRenderLoop as the callback function and\n    \/\/ supply this view as the argument to the callback.\n    cvReturn = CVDisplayLinkSetOutputCallback(_displayLink, &DispatchRenderLoop, (__bridge void*)self);\n\n#endif \/\/ END !RENDER_ON_MAIN_THREAD\n\n    if(cvReturn != kCVReturnSuccess)\n    {\n        return NO;\n    }\n\n    \/\/ Associate the display link with the display on which the\n    \/\/ view resides\n    CGDirectDisplayID viewDisplayID =\n        (CGDirectDisplayID) [self.window.screen.deviceDescription[@\"NSScreenNumber\"] unsignedIntegerValue];;\n\n    cvReturn = CVDisplayLinkSetCurrentCGDisplay(_displayLink, viewDisplayID);\n\n    if(cvReturn != kCVReturnSuccess)\n    {\n        return NO;\n    }\n\n    CVDisplayLinkStart(_displayLink);\n\n    NSNotificationCenter* notificationCenter = [NSNotificationCenter defaultCenter];\n\n    \/\/ Register to be notified when the window closes so that you\n    \/\/ can stop the display link\n    [notificationCenter addObserver:self\n                           selector:@selector(windowWillClose:)\n                               name:NSWindowWillCloseNotification\n                             object:self.window];\n\n    return YES;\n}",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "184f61e823c35f2d9d9e19fb985a160160f1f635725bf33b29361be6fddce1bd",
  "crawledAt" : "2025-12-02T15:31:08Z",
  "id" : "35AEC6D4-D791-4377-89FA-EE32E98CA155",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nWhile MetalKit’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] provides significant functionality, allowing you to quickly get started writing Metal code, sometimes you want more control over how your Metal content is rendered. This sample app demonstrates how to create a simple Metal view derived directly from an [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSView] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView]. It uses a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] object to hold the view’s contents.\n\n### Configure the sample code project\n\nThis sample has targets for iOS, tvOS, and macOS. There are significant differences between apps that use UIKit and AppKit. Because of these differences, this sample creates two different classes. The iOS and tvOS versions of the sample use the `AAPLUIView` class, and the macOS version uses the `AAPLNSView` class. Both are derived from a common `AAPLView` class.\n\nThis sample provides a number of options you can enable when building the app, such as whether to animate the view’s contents or handle updates through system events. You control these options by changing the preprocessor definitions in the `AAPLConfig.h` file.\n\n### Configure the view with a Metal layer\n\nFor Metal to render to the view, the view needs to be backed by a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer].\n\nAll views in UIKit are layer backed. To indicate the type of layer backing, the view implements the `layerClass` class method.  To indicate that your view should be backed by a `CAMetalLayer`, you need to return the `CAMetalLayer` class type.\n\nIn AppKit, you make the view layer backed by setting the view’s `wantsLayer` property.\n\nThis triggers a call to the view’s  `makeBackingLayer` method, which returns a CAMetalLayer object.\n\n### Render to the view\n\nTo render to the view, create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPassDescriptor] object that targets a texture provided by the layer. The `AAPLRenderer` class stores the render pass descriptor in the `_drawableRenderPassDescriptor` instance variable. Most of the properties of this descriptor are set up automatically when you initialize the renderer. The code configures the render pass to clear the contents of the texture, and to store any rendered contents to the texture when the render pass completes.\n\nYou also need to set the texture that the render pass renders into. Each time the app renders a frame, the renderer obtains a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalDrawable] from the Metal layer. The drawable provides a texture for Core Animation to present onscreen. The renderer updates the render pass descriptor to render to this texture:\n\nThe rest of the rendering code is similar to that found in other Metal samples. For an explanation of a typical rendering path, see [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4].\n\n### Implement a render loop\n\nTo animate the view, the sample sets up a display link. The display link calls the view at the specified interval, synchronizing updates to the display’s refresh interval. The view calls the renderer object to render a new frame of animation.\n\n`AAPLUIView` creates a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CADisplayLink] in the `setupCADisplayLinkForScreen` method. Because you need to know which screen the window is on before creating the display link, you call this method when UIKit calls your view’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView\/didMoveToWindow()] method. UIKit calls this method the first time the view is added to a window and when the view is moved to another screen. The code below stops the render loop and initializes a new display link.\n\n`AAPLNSView` uses a [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvdisplaylink-k0k] instead of a `CADisplayLink` because `CADisplayLink` is not available on macOS. `CVDisplayLink` and `CADisplayLink` API look different, but, in principle, have the same goal, which is to allow callbacks in sync with the display. `AAPLNSView` creates a `CVDisplayLink` in the `setupCVDisplayLinkForScreen` method.  The `setupCVDisplayLinkForScreen` method is called from [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSView\/viewDidMoveToWindow()], which AppKit calls immediately after loading the view. If the view is moved to another screen, AppKit also calls `viewDidMoveToWindow`, and like the previous code for UIKit, the AppKit view needs to recreate the display link for the new screen.\n\nThe macOS version of this code performs a few additional steps. After creating the display link, it sets the callback and a parameter to pass to the callback. If you want rendering to happen on the main thread, it passes a dispatch source object; otherwise, it passes a reference to the view itself. Finally, it tells the display link which display the window is located on, and sets a notification to be called when the window is closed.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-custom-metal-view\ncrawled: 2025-12-02T15:31:08Z\n---\n\n# Creating a custom Metal view\n\n**Sample Code**\n\nImplement a lightweight view for Metal rendering that’s customized to your app’s needs.\n\n## Overview\n\nWhile MetalKit’s [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView] provides significant functionality, allowing you to quickly get started writing Metal code, sometimes you want more control over how your Metal content is rendered. This sample app demonstrates how to create a simple Metal view derived directly from an [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSView] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView]. It uses a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer] object to hold the view’s contents.\n\n### Configure the sample code project\n\nThis sample has targets for iOS, tvOS, and macOS. There are significant differences between apps that use UIKit and AppKit. Because of these differences, this sample creates two different classes. The iOS and tvOS versions of the sample use the `AAPLUIView` class, and the macOS version uses the `AAPLNSView` class. Both are derived from a common `AAPLView` class.\n\nThis sample provides a number of options you can enable when building the app, such as whether to animate the view’s contents or handle updates through system events. You control these options by changing the preprocessor definitions in the `AAPLConfig.h` file.\n\n```objective-c\n\/\/ When enabled, rendering occurs on the main application thread.\n\/\/ This can make responding to UI events during redraw simpler\n\/\/ to manage because UI calls usually need to occur on the main thread.\n\/\/ When disabled, rendering occurs on a background thread, allowing\n\/\/ the UI to respond more quickly in some cases because events can be\n\/\/ processed asynchronously from potentially CPU-intensive rendering code.\n#define RENDER_ON_MAIN_THREAD 1\n\n\/\/ When enabled, the view continually animates and renders\n\/\/ frames 60 times a second.  When disabled, rendering is event\n\/\/ based, occurring when a UI event requests a redraw.\n#define ANIMATION_RENDERING   1\n\n\/\/ When enabled, the drawable's size is updated automatically whenever\n\/\/ the view is resized. When disabled, you can update the drawable's\n\/\/ size explicitly outside the view class.\n#define AUTOMATICALLY_RESIZE  1\n\n\/\/ When enabled, the renderer creates a depth target (i.e. depth buffer)\n\/\/ and attaches with the render pass descritpr along with the drawable\n\/\/ texture for rendering.  This enables the app properly perform depth testing.\n#define CREATE_DEPTH_BUFFER   1\n```\n\n### Configure the view with a Metal layer\n\nFor Metal to render to the view, the view needs to be backed by a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalLayer].\n\nAll views in UIKit are layer backed. To indicate the type of layer backing, the view implements the `layerClass` class method.  To indicate that your view should be backed by a `CAMetalLayer`, you need to return the `CAMetalLayer` class type.\n\n```objective-c\n+ (Class) layerClass\n{\n    return [CAMetalLayer class];\n}\n```\n\nIn AppKit, you make the view layer backed by setting the view’s `wantsLayer` property.\n\n```objective-c\nself.wantsLayer = YES;\n```\n\nThis triggers a call to the view’s  `makeBackingLayer` method, which returns a CAMetalLayer object.\n\n```objective-c\n- (CALayer *)makeBackingLayer\n{\n    return [CAMetalLayer layer];\n}\n```\n\n### Render to the view\n\nTo render to the view, create an [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderPassDescriptor] object that targets a texture provided by the layer. The `AAPLRenderer` class stores the render pass descriptor in the `_drawableRenderPassDescriptor` instance variable. Most of the properties of this descriptor are set up automatically when you initialize the renderer. The code configures the render pass to clear the contents of the texture, and to store any rendered contents to the texture when the render pass completes.\n\n```objective-c\n_drawableRenderDescriptor = [MTLRenderPassDescriptor new];\n_drawableRenderDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;\n_drawableRenderDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;\n_drawableRenderDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0, 1, 1, 1);\n```\n\nYou also need to set the texture that the render pass renders into. Each time the app renders a frame, the renderer obtains a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CAMetalDrawable] from the Metal layer. The drawable provides a texture for Core Animation to present onscreen. The renderer updates the render pass descriptor to render to this texture:\n\n```objective-c\nid<CAMetalDrawable> currentDrawable = [metalLayer nextDrawable];\n\n\/\/ If the current drawable is nil, skip rendering this frame\nif(!currentDrawable)\n{\n    return;\n}\n\n_drawableRenderDescriptor.colorAttachments[0].texture = currentDrawable.texture;\n```\n\nThe rest of the rendering code is similar to that found in other Metal samples. For an explanation of a typical rendering path, see [doc:\/\/com.apple.metal\/documentation\/Metal\/drawing-a-triangle-with-metal-4].\n\n### Implement a render loop\n\nTo animate the view, the sample sets up a display link. The display link calls the view at the specified interval, synchronizing updates to the display’s refresh interval. The view calls the renderer object to render a new frame of animation.\n\n`AAPLUIView` creates a [doc:\/\/com.apple.documentation\/documentation\/QuartzCore\/CADisplayLink] in the `setupCADisplayLinkForScreen` method. Because you need to know which screen the window is on before creating the display link, you call this method when UIKit calls your view’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView\/didMoveToWindow()] method. UIKit calls this method the first time the view is added to a window and when the view is moved to another screen. The code below stops the render loop and initializes a new display link.\n\n```objective-c\n- (void)setupCADisplayLinkForScreen:(UIScreen*)screen\n{\n    [self stopRenderLoop];\n\n    _displayLink = [screen displayLinkWithTarget:self selector:@selector(render)];\n\n    _displayLink.paused = self.paused;\n\n    _displayLink.preferredFramesPerSecond = 60;\n}\n```\n\n`AAPLNSView` uses a [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvdisplaylink-k0k] instead of a `CADisplayLink` because `CADisplayLink` is not available on macOS. `CVDisplayLink` and `CADisplayLink` API look different, but, in principle, have the same goal, which is to allow callbacks in sync with the display. `AAPLNSView` creates a `CVDisplayLink` in the `setupCVDisplayLinkForScreen` method.  The `setupCVDisplayLinkForScreen` method is called from [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSView\/viewDidMoveToWindow()], which AppKit calls immediately after loading the view. If the view is moved to another screen, AppKit also calls `viewDidMoveToWindow`, and like the previous code for UIKit, the AppKit view needs to recreate the display link for the new screen.\n\n```objective-c\n- (BOOL)setupCVDisplayLinkForScreen:(NSScreen*)screen\n{\n#if RENDER_ON_MAIN_THREAD\n\n    \/\/ The CVDisplayLink callback, DispatchRenderLoop, never executes\n    \/\/ on the main thread. To execute rendering on the main thread, create\n    \/\/ a dispatch source using the main queue (the main thread).\n    \/\/ DispatchRenderLoop merges this dispatch source in each call\n    \/\/ to execute rendering on the main thread.\n    _displaySource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());\n    __weak AAPLView* weakSelf = self;\n    dispatch_source_set_event_handler(_displaySource, ^(){\n        @autoreleasepool\n        {\n            [weakSelf render];\n        }\n    });\n    dispatch_resume(_displaySource);\n\n#endif \/\/ END RENDER_ON_MAIN_THREAD\n\n    CVReturn cvReturn;\n\n    \/\/ Create a display link capable of being used with all active displays\n    cvReturn = CVDisplayLinkCreateWithActiveCGDisplays(&_displayLink);\n\n    if(cvReturn != kCVReturnSuccess)\n    {\n        return NO;\n    }\n\n#if RENDER_ON_MAIN_THREAD\n\n    \/\/ Set DispatchRenderLoop as the callback function and\n    \/\/ supply _displaySource as the argument to the callback.\n    cvReturn = CVDisplayLinkSetOutputCallback(_displayLink, &DispatchRenderLoop, (__bridge void*)_displaySource);\n\n#else \/\/ IF !RENDER_ON_MAIN_THREAD\n\n    \/\/ Set DispatchRenderLoop as the callback function and\n    \/\/ supply this view as the argument to the callback.\n    cvReturn = CVDisplayLinkSetOutputCallback(_displayLink, &DispatchRenderLoop, (__bridge void*)self);\n\n#endif \/\/ END !RENDER_ON_MAIN_THREAD\n\n    if(cvReturn != kCVReturnSuccess)\n    {\n        return NO;\n    }\n\n    \/\/ Associate the display link with the display on which the\n    \/\/ view resides\n    CGDirectDisplayID viewDisplayID =\n        (CGDirectDisplayID) [self.window.screen.deviceDescription[@\"NSScreenNumber\"] unsignedIntegerValue];;\n\n    cvReturn = CVDisplayLinkSetCurrentCGDisplay(_displayLink, viewDisplayID);\n\n    if(cvReturn != kCVReturnSuccess)\n    {\n        return NO;\n    }\n\n    CVDisplayLinkStart(_displayLink);\n\n    NSNotificationCenter* notificationCenter = [NSNotificationCenter defaultCenter];\n\n    \/\/ Register to be notified when the window closes so that you\n    \/\/ can stop the display link\n    [notificationCenter addObserver:self\n                           selector:@selector(windowWillClose:)\n                               name:NSWindowWillCloseNotification\n                             object:self.window];\n\n    return YES;\n}\n```\n\nThe macOS version of this code performs a few additional steps. After creating the display link, it sets the callback and a parameter to pass to the callback. If you want rendering to happen on the main thread, it passes a dispatch source object; otherwise, it passes a reference to the view itself. Finally, it tells the display link which display the window is located on, and sets a notification to be called when the window is closed.\n\n## Render workflows\n\n- **Using Metal to draw a view’s contents**: Create a MetalKit view and a render pass to draw the view’s contents.\n- **Drawing a triangle with Metal 4**: Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.\n- **Selecting device objects for graphics rendering**: Switch dynamically between multiple GPUs to efficiently render to a display.\n- **Customizing render pass setup**: Render into an offscreen texture by creating a custom render pass.\n- **Calculating primitive visibility using depth testing**: Determine which pixels are visible in a scene by using a depth texture.\n- **Encoding indirect command buffers on the CPU**: Reduce CPU overhead and simplify your command execution by reusing commands.\n- **Implementing order-independent transparency with image blocks**: Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.\n- **Loading textures and models using Metal fast resource loading**: Stream texture and buffer data directly from disk into Metal resources using fast resource loading.\n- **Adjusting the level of detail using Metal mesh shaders**: Choose and render meshes with several levels of detail using object and mesh shaders.\n- **Creating a 3D application with hydra rendering**: Build a 3D application that integrates with Hydra and USD.\n- **Culling occluded geometry using the visibility result buffer**: Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.\n- **Improving edge-rendering quality with multisample antialiasing (MSAA)**: Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.\n- **Achieving smooth frame rates with a Metal display link**: Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a MetalKit view and a render pass to draw the view’s contents.",
          "name" : "Using Metal to draw a view’s contents",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-metal-to-draw-a-view's-contents"
        },
        {
          "description" : "Render a colorful, rotating 2D triangle by running draw commands with a render pipeline on a GPU.",
          "name" : "Drawing a triangle with Metal 4",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/drawing-a-triangle-with-metal-4"
        },
        {
          "description" : "Switch dynamically between multiple GPUs to efficiently render to a display.",
          "name" : "Selecting device objects for graphics rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/selecting-device-objects-for-graphics-rendering"
        },
        {
          "description" : "Render into an offscreen texture by creating a custom render pass.",
          "name" : "Customizing render pass setup",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/customizing-render-pass-setup"
        },
        {
          "description" : "Determine which pixels are visible in a scene by using a depth texture.",
          "name" : "Calculating primitive visibility using depth testing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/calculating-primitive-visibility-using-depth-testing"
        },
        {
          "description" : "Reduce CPU overhead and simplify your command execution by reusing commands.",
          "name" : "Encoding indirect command buffers on the CPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-indirect-command-buffers-on-the-cpu"
        },
        {
          "description" : "Draw overlapping, transparent surfaces in any order by using tile shaders and image blocks.",
          "name" : "Implementing order-independent transparency with image blocks",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/implementing-order-independent-transparency-with-image-blocks"
        },
        {
          "description" : "Stream texture and buffer data directly from disk into Metal resources using fast resource loading.",
          "name" : "Loading textures and models using Metal fast resource loading",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/loading-textures-and-models-using-metal-fast-resource-loading"
        },
        {
          "description" : "Choose and render meshes with several levels of detail using object and mesh shaders.",
          "name" : "Adjusting the level of detail using Metal mesh shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/adjusting-the-level-of-detail-using-metal-mesh-shaders"
        },
        {
          "description" : "Build a 3D application that integrates with Hydra and USD.",
          "name" : "Creating a 3D application with hydra rendering",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-3d-application-with-hydra-rendering"
        },
        {
          "description" : "Draw a scene without rendering hidden geometry by checking whether each object in the scene is visible.",
          "name" : "Culling occluded geometry using the visibility result buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/culling-occluded-geometry-using-the-visibility-result-buffer"
        },
        {
          "description" : "Apply MSAA to enhance the rendering of edges with custom resolve options and immediate and tile-based resolve paths.",
          "name" : "Improving edge-rendering quality with multisample antialiasing (MSAA)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-edge-rendering-quality-with-multisample-antialiasing-msaa"
        },
        {
          "description" : "Pace rendering with minimal input latency while providing essential information to the operating system for power-efficient rendering, thermal mitigation, and the scheduling of sustainable workloads.",
          "name" : "Achieving smooth frame rates with a Metal display link",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/achieving-smooth-frame-rates-with-a-metal-display-link"
        }
      ],
      "title" : "Render workflows"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a custom Metal view",
  "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/creating-a-custom-metal-view"
}