{
  "abstract" : "Create argument buffers to organize related resources.",
  "codeExamples" : [
    {
      "code" : "struct FragmentShaderArguments {\n    texture2d<half> exampleTexture  [[ id(AAPLArgumentBufferIDExampleTexture)  ]];\n    sampler         exampleSampler  [[ id(AAPLArgumentBufferIDExampleSampler)  ]];\n    device float   *exampleBuffer   [[ id(AAPLArgumentBufferIDExampleBuffer)   ]];\n    uint32_t        exampleConstant [[ id(AAPLArgumentBufferIDExampleConstant) ]];\n};",
      "language" : "metal"
    },
    {
      "code" : "struct FragmentShaderArguments {\n    texture2d<half>  exampleTexture;\n    sampler          exampleSampler;\n    DEVICE float    *exampleBuffer;\n    uint32_t         exampleConstant;\n};",
      "language" : "objective-c"
    },
    {
      "code" : "fragment float4\nfragmentShader(       RasterizerData            in                 [[ stage_in ]],\n               device FragmentShaderArguments & fragmentShaderArgs [[ buffer(AAPLFragmentBufferIndexArguments) ]])",
      "language" : "metal"
    },
    {
      "code" : "id <MTLFunction> fragmentFunction = [defaultLibrary newFunctionWithName:@\"fragmentShader\"];\n\nid <MTLArgumentEncoder> argumentEncoder =\n    [fragmentFunction newArgumentEncoderWithBufferIndex:AAPLFragmentBufferIndexArguments];",
      "language" : "objective-c"
    },
    {
      "code" : "NSUInteger argumentBufferLength = argumentEncoder.encodedLength;\n\n_fragmentShaderArgumentBuffer = [_device newBufferWithLength:argumentBufferLength options:0];",
      "language" : "objective-c"
    },
    {
      "code" : "[argumentEncoder setArgumentBuffer:_fragmentShaderArgumentBuffer offset:0];",
      "language" : "objective-c"
    },
    {
      "code" : "[argumentEncoder setTexture:_texture atIndex:AAPLArgumentBufferIDExampleTexture];\n[argumentEncoder setSamplerState:_sampler atIndex:AAPLArgumentBufferIDExampleSampler];\n[argumentEncoder setBuffer:_indirectBuffer offset:0 atIndex:AAPLArgumentBufferIDExampleBuffer];",
      "language" : "objective-c"
    },
    {
      "code" : "uint32_t *numElementsAddress =  (uint32_t *)[argumentEncoder constantDataAtIndex:AAPLArgumentBufferIDExampleConstant];\n\n*numElementsAddress = bufferElements;",
      "language" : "objective-c"
    },
    {
      "code" : "NSUInteger argumentBufferLength = sizeof(FragmentShaderArguments);\n\n_fragmentShaderArgumentBuffer = [_device newBufferWithLength:argumentBufferLength options:0];",
      "language" : "objective-c"
    },
    {
      "code" : "FragmentShaderArguments *argumentStructure = (FragmentShaderArguments *)_fragmentShaderArgumentBuffer.contents;\n\nargumentStructure->exampleTexture = _texture.gpuResourceID;\nargumentStructure->exampleBuffer = (float*) _indirectBuffer.gpuAddress;\nargumentStructure->exampleSampler = _sampler.gpuResourceID;\nargumentStructure->exampleConstant = bufferElements;",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder useResource:_texture usage:MTLResourceUsageRead stages:MTLRenderStageFragment];\n[renderEncoder useResource:_indirectBuffer usage:MTLResourceUsageRead stages:MTLRenderStageFragment];",
      "language" : "objective-c"
    },
    {
      "code" : "[renderEncoder setFragmentBuffer:_fragmentShaderArgumentBuffer\n                          offset:0\n                         atIndex:AAPLFragmentBufferIndexArguments];",
      "language" : "objective-c"
    },
    {
      "code" : "\/\/ Get the encoded sampler from the argument buffer.\nsampler exampleSampler = fragmentShaderArgs.exampleSampler;\n\n\/\/ Sample the encoded texture in the argument buffer.\nhalf4 textureSample = fragmentShaderArgs.exampleTexture.sample(exampleSampler, in.texCoord);\n\n\/\/ Use the fragment position and the encoded constant in the argument buffer to calculate an array index.\nuint32_t index = (uint32_t)in.position.x % fragmentShaderArgs.exampleConstant;\n\n\/\/ Index into the encoded buffer in the argument buffer.\nfloat colorScale = fragmentShaderArgs.exampleBuffer[index];",
      "language" : "metal"
    }
  ],
  "contentHash" : "b19eb0054af2d7687d425dd9ece6c9b89ccf871a8e314db28449cc886c52f8d8",
  "crawledAt" : "2025-12-02T19:37:39Z",
  "id" : "A6CA4FBA-66FB-41BD-8B68-6A3D08CF7276",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Metal",
  "overview" : "## Overview\n\nAn argument buffer represents a group of resources that you can collectively assign as an argument to a graphics or compute function. You use argument buffers to reduce CPU overhead, simplify resource management, and implement GPU-driven pipelines.\n\nThis sample code project shows how to specify, encode, set, and access resources in an argument buffer. In particular, you can learn about the advantages of managing groups of resources in an argument buffer instead of individual resources. The sample app renders a static quad using a texture, sampler, buffer, and constant that the renderer encodes into an argument buffer.\n\nThe Xcode project contains schemes for running the sample in macOS and iOS.  For each, it specifies targets for a Metal 2 and a Metal 3 version of the app.\n\n### Reduce CPU overhead\n\nMetal commands are efficient, and incur minimal CPU overhead when apps access the GPU. However, each command does incur some overhead, so the sample app uses the following strategies to further reduce that amount:\n\nThe Metal argument buffer feature reduces the number and performance cost of CPU commands in the sample app’s critical path, such as in the render loop. An argument buffer groups and encodes multiple resources within a single buffer instead of encoding each resource individually. By using argument buffers, the sample shifts a significant amount of CPU overhead from its critical path to its initial setup.\n\n### Pack resources into argument buffers\n\nMetal apps, particularly games, typically contain multiple 3D objects, each associated with a set of resources, such as textures, samplers, buffers, and constants. To render each object, the Metal apps encode commands that set these resources as arguments to a graphics function before issuing a draw call.\n\nMetal apps set individual resources as arguments by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setFragmentTexture(_:index:)] for each resource.\n\n\n\nCommands that set individual resources can become numerous and expensive, especially for large apps or games. Instead, the sample app groups related resources into an argument buffer and then sets that entire buffer as a single argument to a graphics function. This approach greatly reduces CPU overhead and still provides individual GPU access to the resources.\n\n`MTLBuffer` objects represent the argument buffers in the sample code. The sample code sets the objects as arguments by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setFragmentBuffer(_:offset:index:)] for each argument buffer.\n\n\n\n### Define argument buffers\n\nThe Metal Shading Language defines argument buffers as custom structures. Each structure element represents an individual resource that the shader code declares as a texture, sampler, buffer, or constant data type.\n\nThe sample declares the argument buffer as a `FragmentShaderArguments` structure.\n\nWith Metal 2, the sample app associates an integer, which the shader code declares with the `[[id(n)]]` attribute qualifier to specify the index of the individual resources.  The Metal 2 target uses these identifiers to encode resources into a buffer.\n\nThis argument buffer contains the following resources:\n\nWith Metal 3, the sample app’s Objective-C code can write the resources directly to a buffer.  Because of this, the Metal 3 target defines  `FragmentShaderArguments` in a header it shares with the `AAPLRenderer` classes’ code.\n\nThe following example’s fragment function, `fragmentShader`, uses the argument buffer as a single parameter:\n\nThe `fragmentShaderArgs` parameter is a buffer of type `FragmentShaderArguments`. When the sample code sets a `MTLBuffer` as an argument to the fragment function, the function interprets the data in the `fragmentShaderArgs` parameter as an argument buffer with a texture, sampler, buffer, and constant (as the `FragmentShaderArguments` structure defines).\n\n### Encode resources into an argument buffer with Metal 2\n\nWith Metal 2, the renderer encodes individual resources into an argument buffer before a buffer accesses it. It accomplishes this by creating a `MTLArgumentBufferEncoder` from a `MTLFunction` that uses an argument buffer.\n\nThe following example creates a `MTLArgumentBufferEncoder` from the `fragmentShader` function, which contains the `fragmentShaderArgs` parameter:\n\nThe `encodedLength` property of `argumentEncoder` determines the size, in bytes, necessary to contain all the resources in the argument buffer. This example uses that value to create a new buffer, `_fragmentShaderArgumentBuffer`, with a `length` parameter that matches the required size for the argument buffer:\n\nThe following example calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder\/setArgumentBuffer(_:offset:)] method to specify that `_fragmentShaderArgumentBuffer` is an argument buffer that the renderer can encode resources into:\n\nThe example below encodes individual resources into the argument buffer by:\n\nThe renderer encodes constants a bit differently.  It embeds constant data directly into the argument buffer, instead of storing the data in another object that the argument buffer points to. The renderer calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder\/constantData(at:)] method to retrieve the address in the argument buffer where the constant resides. Then, it sets the actual value of the constant, `bufferElements`, at the retrieved address.\n\n### Set resource handles in an argument buffer with Metal 3\n\nWith Metal 3, the renderer writes GPU resource handles directly into a buffer’s contents.\n\nBecause the sample code defines the `FragmentShaderArguments` structure in a header it shares with the `AAPLRenderer` source, the renderer determines the size necessary for the buffer by using the `sizeof` operator on the structure.\n\nThe following example writes to the buffer’s contents using the `gpuResourceID` property of the `MTLTexture` and `MTLSampler` objects, and the `gpuHandle` property of the `MTLBuffer` object.\n\n### Enable the GPU memory of resources in the argument buffer\n\nMetal efficiently manages memory accessed by the GPU. However, before the GPU uses any resource, Metal needs to ensure that the GPU has access to the resource’s memory. Setting resources individually by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setFragmentTexture(_:index:)], ensures that the resource’s memory is accessible to the GPU.\n\nHowever, when the renderer encodes resources into an argument buffer, setting the argument buffer doesn’t set each of its resources individually. Metal doesn’t determine what resource’s memory to make accessible to the GPU by inspecting the argument buffer. Instead, the renderer calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/useResource(_:usage:stages:)] method to explicitly make a specific resource’s memory accessible to the GPU.\n\n### Set argument buffers\n\nThe following example calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/useResource(_:usage:stages:)] method for the `_texture` and `_indirectBuffer` encoded resources in the argument buffer. These calls specify `MTLResourceUsage` values that further indicate which GPU operations to perform on each resource (the GPU samples the texture and reads the buffer):\n\nThe following example sets only `_fragmentShaderArgumentBuffer` as an argument to the fragment function. It doesn’t set the `_texture`, `_indirectBuffer`, `_sampler`, or `bufferElements` resources individually. This command allows the fragment function to access the argument buffer and its encoded resources:\n\n### Access the resources in an argument buffer\n\nWithin a function, accessing encoded resources in an argument buffer is similar to accessing individual resources directly. The main difference is that the function accesses the resources as elements of the argument buffer structure.\n\nIn the following example, the `fragmentShaderArgs` parameter of the `fragmentShader` function accesses the argument buffer resources:\n\nThe example uses all four resources in the argument buffer to produce the final color for each fragment.\n\n### Combine argument buffers with a resource heap\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/using-argument-buffers-with-resource-heaps] sample code project demonstrates how to combine argument buffers with arrays of resources and resource heaps. This further reduces CPU overhead.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/metal\/managing-groups-of-resources-with-argument-buffers\ncrawled: 2025-12-02T19:37:39Z\n---\n\n# Managing groups of resources with argument buffers\n\n**Sample Code**\n\nCreate argument buffers to organize related resources.\n\n## Overview\n\nAn argument buffer represents a group of resources that you can collectively assign as an argument to a graphics or compute function. You use argument buffers to reduce CPU overhead, simplify resource management, and implement GPU-driven pipelines.\n\nThis sample code project shows how to specify, encode, set, and access resources in an argument buffer. In particular, you can learn about the advantages of managing groups of resources in an argument buffer instead of individual resources. The sample app renders a static quad using a texture, sampler, buffer, and constant that the renderer encodes into an argument buffer.\n\nThe Xcode project contains schemes for running the sample in macOS and iOS.  For each, it specifies targets for a Metal 2 and a Metal 3 version of the app.\n\n### Reduce CPU overhead\n\nMetal commands are efficient, and incur minimal CPU overhead when apps access the GPU. However, each command does incur some overhead, so the sample app uses the following strategies to further reduce that amount:\n\n- Perform more GPU work with fewer CPU commands.\n- Avoid repeating expensive CPU commands.\n\nThe Metal argument buffer feature reduces the number and performance cost of CPU commands in the sample app’s critical path, such as in the render loop. An argument buffer groups and encodes multiple resources within a single buffer instead of encoding each resource individually. By using argument buffers, the sample shifts a significant amount of CPU overhead from its critical path to its initial setup.\n\n### Pack resources into argument buffers\n\nMetal apps, particularly games, typically contain multiple 3D objects, each associated with a set of resources, such as textures, samplers, buffers, and constants. To render each object, the Metal apps encode commands that set these resources as arguments to a graphics function before issuing a draw call.\n\nMetal apps set individual resources as arguments by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setFragmentTexture(_:index:)] for each resource.\n\n\n\nCommands that set individual resources can become numerous and expensive, especially for large apps or games. Instead, the sample app groups related resources into an argument buffer and then sets that entire buffer as a single argument to a graphics function. This approach greatly reduces CPU overhead and still provides individual GPU access to the resources.\n\n`MTLBuffer` objects represent the argument buffers in the sample code. The sample code sets the objects as arguments by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setFragmentBuffer(_:offset:index:)] for each argument buffer.\n\n\n\n\n\n### Define argument buffers\n\nThe Metal Shading Language defines argument buffers as custom structures. Each structure element represents an individual resource that the shader code declares as a texture, sampler, buffer, or constant data type.\n\nThe sample declares the argument buffer as a `FragmentShaderArguments` structure.\n\nWith Metal 2, the sample app associates an integer, which the shader code declares with the `[[id(n)]]` attribute qualifier to specify the index of the individual resources.  The Metal 2 target uses these identifiers to encode resources into a buffer.\n\n```metal\nstruct FragmentShaderArguments {\n    texture2d<half> exampleTexture  [[ id(AAPLArgumentBufferIDExampleTexture)  ]];\n    sampler         exampleSampler  [[ id(AAPLArgumentBufferIDExampleSampler)  ]];\n    device float   *exampleBuffer   [[ id(AAPLArgumentBufferIDExampleBuffer)   ]];\n    uint32_t        exampleConstant [[ id(AAPLArgumentBufferIDExampleConstant) ]];\n};\n```\n\nThis argument buffer contains the following resources:\n\n- `exampleTexture`, a 2D texture with an index of `0`\n- `exampleSampler`, a sampler with an index of `1`\n- `exampleBuffer`, a `float` buffer with an index of `2`\n- `exampleConstant`, a `uint32_t` constant with an index of `3`\n\nWith Metal 3, the sample app’s Objective-C code can write the resources directly to a buffer.  Because of this, the Metal 3 target defines  `FragmentShaderArguments` in a header it shares with the `AAPLRenderer` classes’ code.\n\n```objective-c\nstruct FragmentShaderArguments {\n    texture2d<half>  exampleTexture;\n    sampler          exampleSampler;\n    DEVICE float    *exampleBuffer;\n    uint32_t         exampleConstant;\n};\n```\n\nThe following example’s fragment function, `fragmentShader`, uses the argument buffer as a single parameter:\n\n```metal\nfragment float4\nfragmentShader(       RasterizerData            in                 [[ stage_in ]],\n               device FragmentShaderArguments & fragmentShaderArgs [[ buffer(AAPLFragmentBufferIndexArguments) ]])\n```\n\nThe `fragmentShaderArgs` parameter is a buffer of type `FragmentShaderArguments`. When the sample code sets a `MTLBuffer` as an argument to the fragment function, the function interprets the data in the `fragmentShaderArgs` parameter as an argument buffer with a texture, sampler, buffer, and constant (as the `FragmentShaderArguments` structure defines).\n\n### Encode resources into an argument buffer with Metal 2\n\nWith Metal 2, the renderer encodes individual resources into an argument buffer before a buffer accesses it. It accomplishes this by creating a `MTLArgumentBufferEncoder` from a `MTLFunction` that uses an argument buffer.\n\nThe following example creates a `MTLArgumentBufferEncoder` from the `fragmentShader` function, which contains the `fragmentShaderArgs` parameter:\n\n```objective-c\nid <MTLFunction> fragmentFunction = [defaultLibrary newFunctionWithName:@\"fragmentShader\"];\n\nid <MTLArgumentEncoder> argumentEncoder =\n    [fragmentFunction newArgumentEncoderWithBufferIndex:AAPLFragmentBufferIndexArguments];\n```\n\nThe `encodedLength` property of `argumentEncoder` determines the size, in bytes, necessary to contain all the resources in the argument buffer. This example uses that value to create a new buffer, `_fragmentShaderArgumentBuffer`, with a `length` parameter that matches the required size for the argument buffer:\n\n```objective-c\nNSUInteger argumentBufferLength = argumentEncoder.encodedLength;\n\n_fragmentShaderArgumentBuffer = [_device newBufferWithLength:argumentBufferLength options:0];\n```\n\nThe following example calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder\/setArgumentBuffer(_:offset:)] method to specify that `_fragmentShaderArgumentBuffer` is an argument buffer that the renderer can encode resources into:\n\n```objective-c\n[argumentEncoder setArgumentBuffer:_fragmentShaderArgumentBuffer offset:0];\n```\n\nThe example below encodes individual resources into the argument buffer by:\n\n- Calling specific methods for each resource type, such as `setTexture:atIndex:`, `setSamplerState:atIndex:`, and `setBuffer:offset:atIndex`.\n- Matching the value of the `index` parameter to the value of the `[[id(n)]]` attribute qualifier the shader code declares for each element of the `FragmentShaderArguments` structure.\n\n```objective-c\n[argumentEncoder setTexture:_texture atIndex:AAPLArgumentBufferIDExampleTexture];\n[argumentEncoder setSamplerState:_sampler atIndex:AAPLArgumentBufferIDExampleSampler];\n[argumentEncoder setBuffer:_indirectBuffer offset:0 atIndex:AAPLArgumentBufferIDExampleBuffer];\n```\n\nThe renderer encodes constants a bit differently.  It embeds constant data directly into the argument buffer, instead of storing the data in another object that the argument buffer points to. The renderer calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLArgumentEncoder\/constantData(at:)] method to retrieve the address in the argument buffer where the constant resides. Then, it sets the actual value of the constant, `bufferElements`, at the retrieved address.\n\n```objective-c\nuint32_t *numElementsAddress =  (uint32_t *)[argumentEncoder constantDataAtIndex:AAPLArgumentBufferIDExampleConstant];\n\n*numElementsAddress = bufferElements;\n```\n\n### Set resource handles in an argument buffer with Metal 3\n\nWith Metal 3, the renderer writes GPU resource handles directly into a buffer’s contents.\n\nBecause the sample code defines the `FragmentShaderArguments` structure in a header it shares with the `AAPLRenderer` source, the renderer determines the size necessary for the buffer by using the `sizeof` operator on the structure.\n\n```objective-c\nNSUInteger argumentBufferLength = sizeof(FragmentShaderArguments);\n\n_fragmentShaderArgumentBuffer = [_device newBufferWithLength:argumentBufferLength options:0];\n```\n\nThe following example writes to the buffer’s contents using the `gpuResourceID` property of the `MTLTexture` and `MTLSampler` objects, and the `gpuHandle` property of the `MTLBuffer` object.\n\n```objective-c\nFragmentShaderArguments *argumentStructure = (FragmentShaderArguments *)_fragmentShaderArgumentBuffer.contents;\n\nargumentStructure->exampleTexture = _texture.gpuResourceID;\nargumentStructure->exampleBuffer = (float*) _indirectBuffer.gpuAddress;\nargumentStructure->exampleSampler = _sampler.gpuResourceID;\nargumentStructure->exampleConstant = bufferElements;\n```\n\n### Enable the GPU memory of resources in the argument buffer\n\nMetal efficiently manages memory accessed by the GPU. However, before the GPU uses any resource, Metal needs to ensure that the GPU has access to the resource’s memory. Setting resources individually by calling [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder] methods, such as [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setVertexBuffer(_:offset:index:)] or [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/setFragmentTexture(_:index:)], ensures that the resource’s memory is accessible to the GPU.\n\nHowever, when the renderer encodes resources into an argument buffer, setting the argument buffer doesn’t set each of its resources individually. Metal doesn’t determine what resource’s memory to make accessible to the GPU by inspecting the argument buffer. Instead, the renderer calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/useResource(_:usage:stages:)] method to explicitly make a specific resource’s memory accessible to the GPU.\n\n\n\n### Set argument buffers\n\nThe following example calls the [doc:\/\/com.apple.metal\/documentation\/Metal\/MTLRenderCommandEncoder\/useResource(_:usage:stages:)] method for the `_texture` and `_indirectBuffer` encoded resources in the argument buffer. These calls specify `MTLResourceUsage` values that further indicate which GPU operations to perform on each resource (the GPU samples the texture and reads the buffer):\n\n```objective-c\n[renderEncoder useResource:_texture usage:MTLResourceUsageRead stages:MTLRenderStageFragment];\n[renderEncoder useResource:_indirectBuffer usage:MTLResourceUsageRead stages:MTLRenderStageFragment];\n```\n\n\n\nThe following example sets only `_fragmentShaderArgumentBuffer` as an argument to the fragment function. It doesn’t set the `_texture`, `_indirectBuffer`, `_sampler`, or `bufferElements` resources individually. This command allows the fragment function to access the argument buffer and its encoded resources:\n\n```objective-c\n[renderEncoder setFragmentBuffer:_fragmentShaderArgumentBuffer\n                          offset:0\n                         atIndex:AAPLFragmentBufferIndexArguments];\n```\n\n### Access the resources in an argument buffer\n\nWithin a function, accessing encoded resources in an argument buffer is similar to accessing individual resources directly. The main difference is that the function accesses the resources as elements of the argument buffer structure.\n\nIn the following example, the `fragmentShaderArgs` parameter of the `fragmentShader` function accesses the argument buffer resources:\n\n```metal\n\/\/ Get the encoded sampler from the argument buffer.\nsampler exampleSampler = fragmentShaderArgs.exampleSampler;\n\n\/\/ Sample the encoded texture in the argument buffer.\nhalf4 textureSample = fragmentShaderArgs.exampleTexture.sample(exampleSampler, in.texCoord);\n\n\/\/ Use the fragment position and the encoded constant in the argument buffer to calculate an array index.\nuint32_t index = (uint32_t)in.position.x % fragmentShaderArgs.exampleConstant;\n\n\/\/ Index into the encoded buffer in the argument buffer.\nfloat colorScale = fragmentShaderArgs.exampleBuffer[index];\n```\n\nThe example uses all four resources in the argument buffer to produce the final color for each fragment.\n\n### Combine argument buffers with a resource heap\n\nThe [doc:\/\/com.apple.metal\/documentation\/Metal\/using-argument-buffers-with-resource-heaps] sample code project demonstrates how to combine argument buffers with arrays of resources and resource heaps. This further reduces CPU overhead.\n\n## Argument buffers\n\n- **Improving CPU performance by using argument buffers**: Optimize your app’s performance by grouping your resources into argument buffers.\n- **Tracking the resource residency of argument buffers**: Optimize resource performance within an argument buffer.\n- **Indexing argument buffers**: Assign resource indices within an argument buffer.\n- **Rendering terrain dynamically with argument buffers**: Use argument buffers to render terrain in real time with a GPU-driven pipeline.\n- **Encoding argument buffers on the GPU**: Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.\n- **Using argument buffers with resource heaps**: Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.\n- **MTLArgumentDescriptor**: A representation of an argument within an argument buffer.\n- **MTLArgumentEncoder**: An interface you can use to encode argument data into an argument buffer.\n- **MTLAttributeStrideStatic**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Optimize your app’s performance by grouping your resources into argument buffers.",
          "name" : "Improving CPU performance by using argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/improving-cpu-performance-by-using-argument-buffers"
        },
        {
          "description" : "Optimize resource performance within an argument buffer.",
          "name" : "Tracking the resource residency of argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/tracking-the-resource-residency-of-argument-buffers"
        },
        {
          "description" : "Assign resource indices within an argument buffer.",
          "name" : "Indexing argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/indexing-argument-buffers"
        },
        {
          "description" : "Use argument buffers to render terrain in real time with a GPU-driven pipeline.",
          "name" : "Rendering terrain dynamically with argument buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/rendering-terrain-dynamically-with-argument-buffers"
        },
        {
          "description" : "Use a compute pass to encode an argument buffer and access its arguments in a subsequent render pass.",
          "name" : "Encoding argument buffers on the GPU",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/encoding-argument-buffers-on-the-gpu"
        },
        {
          "description" : "Reduce CPU overhead by using arrays inside argument buffers and combining them with resource heaps.",
          "name" : "Using argument buffers with resource heaps",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/using-argument-buffers-with-resource-heaps"
        },
        {
          "description" : "A representation of an argument within an argument buffer.",
          "name" : "MTLArgumentDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentDescriptor"
        },
        {
          "description" : "An interface you can use to encode argument data into an argument buffer.",
          "name" : "MTLArgumentEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLArgumentEncoder"
        },
        {
          "description" : "",
          "name" : "MTLAttributeStrideStatic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Metal\/MTLAttributeStrideStatic"
        }
      ],
      "title" : "Argument buffers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Managing groups of resources with argument buffers",
  "url" : "https:\/\/developer.apple.com\/documentation\/metal\/managing-groups-of-resources-with-argument-buffers"
}