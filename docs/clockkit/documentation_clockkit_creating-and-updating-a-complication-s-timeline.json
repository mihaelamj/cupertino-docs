{
  "abstract" : "Create complications that batch-load a timeline of future entries and run periodic background sessions to update the timeline.",
  "codeExamples" : [
    {
      "code" : "func complicationDescriptors() async -> [CLKComplicationDescriptor] {\n    logger.debug(\"Accessing the complication descriptors.\")\n    let descriptor = CLKComplicationDescriptor(identifier: \"Coffee_Tracker_Caffeine_Dose\",\n                                               displayName: \"Caffeine Dose\",\n                                               supportedFamilies: CLKComplicationFamily.allCases)\n    return [descriptor]\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Define how far into the future the app can provide data.\nfunc timelineEndDate(for complication: CLKComplication) async -> Date? {\n    \n    \/\/ Indicate that the app can provide timeline entries for the next 24 hours.\n    Date().addingTimeInterval(24.0 * 60.0 * 60.0)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Define whether the complication is visible when the watch is unlocked.\nfunc privacyBehavior(for complication: CLKComplication) async -> CLKComplicationPrivacyBehavior {\n\n    \/\/ This is potentially sensitive data. Hide it on the lock screen.\n    .hideOnLockScreen\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Return the current timeline entry.\nfunc currentTimelineEntry(for complication: CLKComplication) async -> CLKComplicationTimelineEntry? {\n    logger.debug(\"Accessing the current timeline entry.\")\n    return createTimelineEntry(forComplication: complication, date: Date())\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Return future timeline entries.\nfunc timelineEntries(for complication: CLKComplication,\n                     after date: Date,\n                     limit: Int) async -> [CLKComplicationTimelineEntry]? {\n    logger.debug(\"Accessing timeline entries for dates after \\(DateFormatter.localizedString(from: date, dateStyle: .none, timeStyle: .short)).\")\n\n    let fiveMinutes = 5.0 * 60.0\n    let twentyFourHours = 24.0 * 60.0 * 60.0\n\n    \/\/ Create an array to hold the timeline entries.\n    var entries: [CLKComplicationTimelineEntry] = []\n\n    \/\/ Calculate the start and end dates.\n    var current = date.addingTimeInterval(fiveMinutes)\n    let endDate = date.addingTimeInterval(twentyFourHours)\n\n    \/\/ Create a timeline entry for every five minutes from the start time.\n    \/\/ Stop after you reach the limit or the end date.\n    while current < endDate && entries.count < limit {\n        entries.append(createTimelineEntry(forComplication: complication, date: current))\n        current = current.addingTimeInterval(fiveMinutes)\n    }\n\n    return entries\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Select the correct template based on the complication's family.\nprivate func createTemplate(forComplication complication: CLKComplication, date: Date) -> CLKComplicationTemplate {\n    switch complication.family {\n    case .modularSmall:\n        return createModularSmallTemplate(forDate: date)\n    case .modularLarge:\n        return createModularLargeTemplate(forDate: date)\n    case .utilitarianSmall, .utilitarianSmallFlat:\n        return createUtilitarianSmallFlatTemplate(forDate: date)\n    case .utilitarianLarge:\n        return createUtilitarianLargeTemplate(forDate: date)\n    case .circularSmall:\n        return createCircularSmallTemplate(forDate: date)\n    case .extraLarge:\n        return createExtraLargeTemplate(forDate: date)\n    case .graphicCorner:\n        return createGraphicCornerTemplate(forDate: date)\n    case .graphicCircular:\n        return createGraphicCircleTemplate(forDate: date)\n    case .graphicRectangular:\n        return createGraphicRectangularTemplate(forDate: date)\n    case .graphicBezel:\n        return createGraphicBezelTemplate(forDate: date)\n    case .graphicExtraLarge:\n        return createGraphicExtraLargeTemplate(forDate: date)\n\n    @unknown default:\n        logger.error(\"Unknown Complication Family\")\n        fatalError()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Return a graphic template that fills the corner of the watch face.\nprivate func createGraphicCornerTemplate(forDate date: Date) -> CLKComplicationTemplate {\n    \/\/ Create the data providers.\n    let leadingValueProvider = CLKSimpleTextProvider(text: \"0\")\n    leadingValueProvider.tintColor = data.color(forCaffeineDose: 0.0)\n    \n    let trailingValueProvider = CLKSimpleTextProvider(text: \"500\")\n    trailingValueProvider.tintColor = data.color(forCaffeineDose: 500.0)\n    \n    let mgCaffeineProvider = CLKSimpleTextProvider(text: data.mgCaffeineString(atDate: date))\n    let mgUnitProvider = CLKSimpleTextProvider(text: \"mg Caffeine\", shortText: \"mg\")\n    mgUnitProvider.tintColor = data.color(forCaffeineDose: data.mgCaffeine(atDate: date))\n    let combinedMGProvider = CLKTextProvider(format: \"%@ %@\", mgCaffeineProvider, mgUnitProvider)\n    \n    let percentage = Float(min(data.mgCaffeine(atDate: date) \/ 500.0, 1.0))\n    let gaugeProvider = CLKSimpleGaugeProvider(style: .fill,\n                                               gaugeColors: [.green, .yellow, .red],\n                                               gaugeColorLocations: [0.0, 300.0 \/ 500.0, 450.0 \/ 500.0] as [NSNumber],\n                                               fillFraction: percentage)\n    \n    \/\/ Create the template using the providers.\n    return CLKComplicationTemplateGraphicCornerGaugeText(gaugeProvider: gaugeProvider,\n                                                         leadingTextProvider: leadingValueProvider,\n                                                         trailingTextProvider: trailingValueProvider,\n                                                         outerTextProvider: combinedMGProvider)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ The list of drinks consumed.\n\/\/ Because this is @Published property,\n\/\/ Combine updates the app's main interface when a change occurs.\n@Published public private(set) var currentDrinks: [Drink] = []\n\n\/\/ Asynchronously update any active complications and save\n\/\/ the list of drinks after the current drinks property changes.\nprivate func drinkDataUpdated() async {\n    logger.debug(\"Updating the system based on the new current drinks property.\")\n    \n    \/\/ Save the app's data.\n    await store.save(currentDrinks)\n    \n    \/\/ Update any complications on active watch faces.\n    let server = CLKComplicationServer.sharedInstance()\n    let complications = await server.getActiveComplications()\n    \n    for complication in complications {\n        server.reloadTimeline(for: complication)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension CLKComplicationServer {\n    \n    \/\/ Safely access the server's active complications.\n    @MainActor\n    func getActiveComplications() async -> [CLKComplication] {\n        return await withCheckedContinuation { continuation in\n            \n            \/\/ First, set up the notification.\n            let center = NotificationCenter.default\n            let mainQueue = OperationQueue.main\n            var token: NSObjectProtocol?\n            token = center.addObserver(forName: .CLKComplicationServerActiveComplicationsDidChange, object: nil, queue: mainQueue) { _ in\n                center.removeObserver(token!)\n                continuation.resume(returning: self.activeComplications!)\n            }\n            \n            \/\/ Then check to see if we have a valid active complications array.\n            if activeComplications != nil {\n                center.removeObserver(token!)\n                continuation.resume(returning: self.activeComplications!)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Authorize HealthKit and set up the background observer query.\npublic func setUpHealthKit() {\n    \n    \/\/ Make sure HealthKit is available and authorized.\n    guard isAvailable else { return }\n    guard store.authorizationStatus(for: caffeineType) == .sharingAuthorized else { return }\n    \n    \/\/ Return if an observer query is already running.\n    guard backgroundObserver == nil else { return }\n    \n    logger.debug(\"Setting up the background observer queries.\")\n    \n    \/\/ Set up the background delivery rate.\n    store.enableBackgroundDelivery(for: caffeineType, frequency: .immediate) { success, error in\n        guard success else {\n            self.logger.error(\"Unable to set up background delivery from HealthKit: \\(error!.localizedDescription)\")\n            fatalError()\n        }\n    }\n    \n    \/\/ Set up the observer query.\n    backgroundObserver =\n    HKObserverQuery(sampleType: caffeineType,\n                    predicate: nil,\n                    updateHandler: processUpdate(query:completionHandler:error:))\n    \n    if let query = backgroundObserver {\n        logger.debug(\"Starting the background observer query.\")\n        store.execute(query)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func processUpdate(query: HKObserverQuery,\n                   completionHandler: @escaping () -> Void,\n                   error: Error?) {\n    \n    logger.debug(\"Received an update from the background observer query.\")\n    \n    \/\/ Check for any errors that occur while setting up the observer query.\n    guard error == nil else {\n        logger.error(\"Unable to set up a background observer query: \\(error!.localizedDescription)\")\n        fatalError()\n    }\n    \n    logger.debug(\"Responding to a background query.\")\n    \n    Task {\n        \n        \/\/ Load the updated data from the HealthKit Store.\n        let success = await loadNewDataFromHealthKit()\n        \n        \/\/ Check for any errors.\n        guard success == true else {\n            logger.error(\"Unable to query for new or deleted caffeine samples.\")\n            fatalError()\n        }\n        \n        \/\/ Call the completion handler when done.\n        completionHandler()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "62066e6bea65b46de43b1e650683532934c34c2d67126d47211af52a092a37aa",
  "crawledAt" : "2025-12-02T15:54:52Z",
  "id" : "9D4E1572-6A98-4BF7-BE92-9DCDA133CCFE",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "ClockKit",
  "overview" : "## Overview\n\nThe Coffee Tracker app records a user’s caffeine intake. Each time the user adds a drink, the app recalculates the current caffeine levels and the equivalent cups of coffee consumed. It then updates the complication timeline and estimates the decrease in the user’s caffeine level over the next 24 hours.\n\nThis sample demonstrates the basic steps to set up and fill the complication’s timeline, including setting up support for complications, creating entries to fill the complication’s timeline, and then updating the timeline every time the user makes a change.\n\nThe app also updates the complications based on external changes that occur when the app isn’t running. Coffee Tracker saves and reads caffeine samples to HealthKit, so the app must respond to any external changes, such as another app adding or deleting a caffeine sample from HealthKit. Coffee Tracker uses a background observer query to monitor HealthKit for changes, and updates the app’s data and the complication timeline.\n\n### Configure the Sample Code Project\n\nTo add the complication to an active watch face, start by building and running the sample code project in the simulator, and follow these steps:\n\nFor more information on setting up watch faces, see [https:\/\/support.apple.com\/en-us\/HT205536].\n\nAfter configuring and running the Coffee Tracker app, you can test the background updates. Make sure the Coffee Tracker complication appears on the active watch face. Then build and run the app in the simulator, and follow these steps:\n\nCoffee Tracker updates the complication within 1 minute; however, the system may delay updates based on it’s current state.\n\n### Set up support for complications\n\nThe app declares the `ComplicationController` class as the complication’s data source. Xcode saves this setting in the WatchKit Extension’s `Info.plist` file.\n\nNext, the Coffee Tracker app implements the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource] protocol’s methods to configure the app’s timeline. The app declares the supported complications by implementing the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getComplicationDescriptors(handler:)] method.\n\nClockKit identifies complications based on their [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplication\/identifier] and their [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplication\/family]. Apps can declare support for multiple complications by giving each complication a unique identifier. Coffee Tracker declares support for a single complication, returning a [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDescriptor] object that declares support for the `Coffee_Tracker_Caffeine_Dose` identifier for all families.\n\nBecause every copy of Coffee Tracker supports the same set of `CLKComplicationDescriptor` objects, the app doesn’t need to implement the data source’s [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/handleSharedComplicationDescriptors(_:)] method. For more information on defining the supported families, see [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/declaring-complications-for-your-app].\n\n### Load Future Entries\n\nBecause the app can easily calculate caffeine levels in the future, Coffee Tracker declares that it can batch-load future timeline entries by implementing the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getTimelineEndDate(for:withHandler:)] method and setting the end date for the timeline to 24 hours in the future.\n\nClockKit can request batches of timeline entries up to that deadline. After that point, the caffeine level drops to `0.0`. Because the data stops changing at that point, ClockKit won’t need any additional timeline entries until the user adds another drink.\n\nFinally, the app sets the privacy behavior by implementing the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getPrivacyBehavior(for:withHandler:)] method, hiding the complication data on the user’s caffeine intake when the watch is locked.\n\n### Display current data\n\nCoffee Tracker uses three techniques to keep the complications up to date.\n\nFor more information, see [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/keeping-your-complications-up-to-date].\n\n### Create timeline entries\n\nIf there’s an active complication on the watch face, ClockKit calls the data source’s methods to keep the complication’s timeline filled. ClockKit calls the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getCurrentTimelineEntry(for:withHandler:)] method to get the current complication.\n\nThen it calls the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getTimelineEntries(for:after:limit:withHandler:)] method to batch load future timeline entries.\n\nClockKit automatically calls these methods when it needs to refill the timeline. In Coffee Tracker, both of these methods call the `createTimelineEntry(forComplication:date:)` method to create the event. `createTimelineEntry(forComplication:date:)` then calls `createTemplate(forComplication:date:)`  to build the template, and wraps the template in a [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationTimelineEntry] object.\n\nFor more information, see [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/loading-future-timeline-events].\n\n### Create and fill a complication template\n\nClockKit uses a template-driven user interface. The system divides the complications into a number of families based on their size and capabilities, and each family then provides a number of templates that define its layout. When ClockKit asks the data source for a timeline entry, the app needs to instantiate a template for the specified identifier and family, and then fill the template with the required data, before wrapping it in a `CLKComplicationTimelineEntry` object and returning it.\n\nBecause Coffee Tracker uses only a single identifier, it starts by creating a `switch` statement covering all the families that the app supports.\n\nThe app calls a helper method for each family that creates a template the family supports. The helper method also creates all the data providers needed to fill the template. For example, the following helper method creates a graphical corner template.\n\nThis example creates a curved gauge with text outside it. The gauge is a graphical element, like a thermometer or progress bar. To fill the template, the app supplies a gauge provider, which specifies the gauge’s start value, end value, current value, and the color gradient it uses. The app also provides two text providers for the labels at the start and end of the gauge. Finally, it adds another text provider for the main text. Depending on the watch face, the gauge and text may use the specified colors to provide additional information.\n\n### Reload the timeline\n\nThe `CoffeeData` model object declares `currentDrinks`  as a `@Published` property. The system alerts subscribers to any change to the `currentDrinks` array. For example, SwiftUI uses the publisher to trigger updates to the main view.\n\nHowever, the app also needs to update the complications and the app’s saved data after the value is changed. To control this, the app declares the `currentDrinks` setter as `private`, and create an asyncronous `drinkDataUpdated()` method that it calls whenever it updates the `currentDrinks` property.\n\nThe `drinkDataUpdated()` method starts by saving the app’s data. Next, it accesses the list of active complications from the complication server, and tells the complication to reload its timeline — deleting the existing timeline and loading new data.\n\nHowever, if the system launches the app to handle a background update, Coffee Tracker may call the `drinkDataUpdated()` method before the complication server reattaches to the active complications. Therefore, the app uses the `getActiveComplication()` to wait, if necessary, until the server connects.\n\nThis method starts by setting up an observer for the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/CLKComplicationServerActiveComplicationsDidChange] notification. Then it checks the value of the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationServer\/activeComplications] property. If the property has a non-`nil` value, it cancels the observer and returns the value. Otherwise, it waits for the observer, and then returns the value.\n\n### Schedule background observer queries\n\nBefore Coffee Tracker can communicate with HealthKit, it needs to authorize HealthKit and set up the background observer query.\n\nCoffee Tracker requests both read and write access to [doc:\/\/com.apple.documentation\/documentation\/HealthKit\/HKQuantityTypeIdentifier\/dietaryCaffeine] samples. Then it enables the background delivery for observer queries. Finally, it creates and executes an observer query for the `.dietaryCaffeine` data type.\n\nCoffee tracker creates the background observer query immediately after it launches. Setting up an observer query quickly after launch enables the observer to respond promptly when the system launches it in the background because of a change in HealthKit.\n\nThe query runs the `processUpdate(query:,completionHandler:,error:)` method whenever it recieves an update from the observer query.\n\nThis method checks the update for errors. If there aren’t any errors, it asynchronously loads the new data from HealthKit, calling the update’s completion handler as soon as it’s done processing the results.\n\nTo preserve battery life and maintain performance, WatchKit carefully budgets each app’s time for background tasks. In general, if an app has a complication on the active watch face, it can safely use four updates per hour, shared between both the app’s background tasks and it’s background observer queries. However, HealthKit further limits the update on caffeine samples to a maximum of one per hour. And the system may further limit background activity as needed.\n\nThis means, the first update from HealthKit should trigger within a minute. However, the system may delay additional updates for up to an hour or more. For more information, see [doc:\/\/com.apple.documentation\/documentation\/HealthKit\/HKHealthStore\/enableBackgroundDelivery(for:frequency:withCompletion:)].\n\nThe app also loads any new data from HealthKit whenever it enters the foreground.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ClockKit\/creating-and-updating-a-complication-s-timeline\ncrawled: 2025-12-02T15:54:52Z\n---\n\n# Creating and updating a complication’s timeline\n\n**Sample Code**\n\nCreate complications that batch-load a timeline of future entries and run periodic background sessions to update the timeline.\n\n## Overview\n\nThe Coffee Tracker app records a user’s caffeine intake. Each time the user adds a drink, the app recalculates the current caffeine levels and the equivalent cups of coffee consumed. It then updates the complication timeline and estimates the decrease in the user’s caffeine level over the next 24 hours.\n\nThis sample demonstrates the basic steps to set up and fill the complication’s timeline, including setting up support for complications, creating entries to fill the complication’s timeline, and then updating the timeline every time the user makes a change.\n\nThe app also updates the complications based on external changes that occur when the app isn’t running. Coffee Tracker saves and reads caffeine samples to HealthKit, so the app must respond to any external changes, such as another app adding or deleting a caffeine sample from HealthKit. Coffee Tracker uses a background observer query to monitor HealthKit for changes, and updates the app’s data and the complication timeline.\n\n### Configure the Sample Code Project\n\nTo add the complication to an active watch face, start by building and running the sample code project in the simulator, and follow these steps:\n\n1. Click the Digital Crown to exit the app and return to the watch face.\n2. Using the trackpad, firmly press the watch face to put the face in edit mode, then tap Edit.\n3. Swipe left until the edit screen highlights the complications. Select the complication to modify.\n4. Scroll to the Coffee Tracker complication, and then click the Digital Crown again to save your changes.\n5. Tap the watch screen to exit the edit screen.\n6. Tap the Coffee Tracker complication to go back to the app.\n\nFor more information on setting up watch faces, see [https:\/\/support.apple.com\/en-us\/HT205536].\n\nAfter configuring and running the Coffee Tracker app, you can test the background updates. Make sure the Coffee Tracker complication appears on the active watch face. Then build and run the app in the simulator, and follow these steps:\n\n1. Add one or more drinks using the app’s main view.\n2. Click the Digital Crown to send the app to the background.\n3. Open Settings, and scroll down to Health > Health Data > Nutrition > Caffeine. Settings should show all the drinks you added to the app.\n4. Click Delete Caffeine Data to clear all the caffeine samples from HealthKit.\n5. Navigate back to the watch face.\n\nCoffee Tracker updates the complication within 1 minute; however, the system may delay updates based on it’s current state.\n\n### Set up support for complications\n\nThe app declares the `ComplicationController` class as the complication’s data source. Xcode saves this setting in the WatchKit Extension’s `Info.plist` file.\n\nNext, the Coffee Tracker app implements the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource] protocol’s methods to configure the app’s timeline. The app declares the supported complications by implementing the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getComplicationDescriptors(handler:)] method.\n\n```swift\nfunc complicationDescriptors() async -> [CLKComplicationDescriptor] {\n    logger.debug(\"Accessing the complication descriptors.\")\n    let descriptor = CLKComplicationDescriptor(identifier: \"Coffee_Tracker_Caffeine_Dose\",\n                                               displayName: \"Caffeine Dose\",\n                                               supportedFamilies: CLKComplicationFamily.allCases)\n    return [descriptor]\n}\n```\n\nClockKit identifies complications based on their [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplication\/identifier] and their [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplication\/family]. Apps can declare support for multiple complications by giving each complication a unique identifier. Coffee Tracker declares support for a single complication, returning a [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDescriptor] object that declares support for the `Coffee_Tracker_Caffeine_Dose` identifier for all families.\n\nBecause every copy of Coffee Tracker supports the same set of `CLKComplicationDescriptor` objects, the app doesn’t need to implement the data source’s [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/handleSharedComplicationDescriptors(_:)] method. For more information on defining the supported families, see [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/declaring-complications-for-your-app].\n\n### Load Future Entries\n\nBecause the app can easily calculate caffeine levels in the future, Coffee Tracker declares that it can batch-load future timeline entries by implementing the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getTimelineEndDate(for:withHandler:)] method and setting the end date for the timeline to 24 hours in the future.\n\nClockKit can request batches of timeline entries up to that deadline. After that point, the caffeine level drops to `0.0`. Because the data stops changing at that point, ClockKit won’t need any additional timeline entries until the user adds another drink.\n\n```swift\n\/\/ Define how far into the future the app can provide data.\nfunc timelineEndDate(for complication: CLKComplication) async -> Date? {\n    \n    \/\/ Indicate that the app can provide timeline entries for the next 24 hours.\n    Date().addingTimeInterval(24.0 * 60.0 * 60.0)\n}\n```\n\nFinally, the app sets the privacy behavior by implementing the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getPrivacyBehavior(for:withHandler:)] method, hiding the complication data on the user’s caffeine intake when the watch is locked.\n\n```swift\n\/\/ Define whether the complication is visible when the watch is unlocked.\nfunc privacyBehavior(for complication: CLKComplication) async -> CLKComplicationPrivacyBehavior {\n\n    \/\/ This is potentially sensitive data. Hide it on the lock screen.\n    .hideOnLockScreen\n}\n```\n\n### Display current data\n\nCoffee Tracker uses three techniques to keep the complications up to date.\n\n- The app provides future timeline entries in five-minute increments that ClockKit uses to update the complications automatically.\n- While the app is running, Coffee Tracker updates its complications whenever the user adds a drink. This updates not just the current complication, but also reloads the entire complication timeline.\n- Finally, the app uses a background observer query to monitor HealthKit for any updates to its caffeine samples. The app then updates its data based on any changes.\n\nFor more information, see [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/keeping-your-complications-up-to-date].\n\n### Create timeline entries\n\nIf there’s an active complication on the watch face, ClockKit calls the data source’s methods to keep the complication’s timeline filled. ClockKit calls the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getCurrentTimelineEntry(for:withHandler:)] method to get the current complication.\n\n```swift\n\/\/ Return the current timeline entry.\nfunc currentTimelineEntry(for complication: CLKComplication) async -> CLKComplicationTimelineEntry? {\n    logger.debug(\"Accessing the current timeline entry.\")\n    return createTimelineEntry(forComplication: complication, date: Date())\n}\n```\n\nThen it calls the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource\/getTimelineEntries(for:after:limit:withHandler:)] method to batch load future timeline entries.\n\n```swift\n\/\/ Return future timeline entries.\nfunc timelineEntries(for complication: CLKComplication,\n                     after date: Date,\n                     limit: Int) async -> [CLKComplicationTimelineEntry]? {\n    logger.debug(\"Accessing timeline entries for dates after \\(DateFormatter.localizedString(from: date, dateStyle: .none, timeStyle: .short)).\")\n\n    let fiveMinutes = 5.0 * 60.0\n    let twentyFourHours = 24.0 * 60.0 * 60.0\n\n    \/\/ Create an array to hold the timeline entries.\n    var entries: [CLKComplicationTimelineEntry] = []\n\n    \/\/ Calculate the start and end dates.\n    var current = date.addingTimeInterval(fiveMinutes)\n    let endDate = date.addingTimeInterval(twentyFourHours)\n\n    \/\/ Create a timeline entry for every five minutes from the start time.\n    \/\/ Stop after you reach the limit or the end date.\n    while current < endDate && entries.count < limit {\n        entries.append(createTimelineEntry(forComplication: complication, date: current))\n        current = current.addingTimeInterval(fiveMinutes)\n    }\n\n    return entries\n}\n```\n\nClockKit automatically calls these methods when it needs to refill the timeline. In Coffee Tracker, both of these methods call the `createTimelineEntry(forComplication:date:)` method to create the event. `createTimelineEntry(forComplication:date:)` then calls `createTemplate(forComplication:date:)`  to build the template, and wraps the template in a [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationTimelineEntry] object.\n\nFor more information, see [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/loading-future-timeline-events].\n\n### Create and fill a complication template\n\nClockKit uses a template-driven user interface. The system divides the complications into a number of families based on their size and capabilities, and each family then provides a number of templates that define its layout. When ClockKit asks the data source for a timeline entry, the app needs to instantiate a template for the specified identifier and family, and then fill the template with the required data, before wrapping it in a `CLKComplicationTimelineEntry` object and returning it.\n\nBecause Coffee Tracker uses only a single identifier, it starts by creating a `switch` statement covering all the families that the app supports.\n\n```swift\n\/\/ Select the correct template based on the complication's family.\nprivate func createTemplate(forComplication complication: CLKComplication, date: Date) -> CLKComplicationTemplate {\n    switch complication.family {\n    case .modularSmall:\n        return createModularSmallTemplate(forDate: date)\n    case .modularLarge:\n        return createModularLargeTemplate(forDate: date)\n    case .utilitarianSmall, .utilitarianSmallFlat:\n        return createUtilitarianSmallFlatTemplate(forDate: date)\n    case .utilitarianLarge:\n        return createUtilitarianLargeTemplate(forDate: date)\n    case .circularSmall:\n        return createCircularSmallTemplate(forDate: date)\n    case .extraLarge:\n        return createExtraLargeTemplate(forDate: date)\n    case .graphicCorner:\n        return createGraphicCornerTemplate(forDate: date)\n    case .graphicCircular:\n        return createGraphicCircleTemplate(forDate: date)\n    case .graphicRectangular:\n        return createGraphicRectangularTemplate(forDate: date)\n    case .graphicBezel:\n        return createGraphicBezelTemplate(forDate: date)\n    case .graphicExtraLarge:\n        return createGraphicExtraLargeTemplate(forDate: date)\n\n    @unknown default:\n        logger.error(\"Unknown Complication Family\")\n        fatalError()\n    }\n}\n```\n\nThe app calls a helper method for each family that creates a template the family supports. The helper method also creates all the data providers needed to fill the template. For example, the following helper method creates a graphical corner template.\n\n```swift\n\/\/ Return a graphic template that fills the corner of the watch face.\nprivate func createGraphicCornerTemplate(forDate date: Date) -> CLKComplicationTemplate {\n    \/\/ Create the data providers.\n    let leadingValueProvider = CLKSimpleTextProvider(text: \"0\")\n    leadingValueProvider.tintColor = data.color(forCaffeineDose: 0.0)\n    \n    let trailingValueProvider = CLKSimpleTextProvider(text: \"500\")\n    trailingValueProvider.tintColor = data.color(forCaffeineDose: 500.0)\n    \n    let mgCaffeineProvider = CLKSimpleTextProvider(text: data.mgCaffeineString(atDate: date))\n    let mgUnitProvider = CLKSimpleTextProvider(text: \"mg Caffeine\", shortText: \"mg\")\n    mgUnitProvider.tintColor = data.color(forCaffeineDose: data.mgCaffeine(atDate: date))\n    let combinedMGProvider = CLKTextProvider(format: \"%@ %@\", mgCaffeineProvider, mgUnitProvider)\n    \n    let percentage = Float(min(data.mgCaffeine(atDate: date) \/ 500.0, 1.0))\n    let gaugeProvider = CLKSimpleGaugeProvider(style: .fill,\n                                               gaugeColors: [.green, .yellow, .red],\n                                               gaugeColorLocations: [0.0, 300.0 \/ 500.0, 450.0 \/ 500.0] as [NSNumber],\n                                               fillFraction: percentage)\n    \n    \/\/ Create the template using the providers.\n    return CLKComplicationTemplateGraphicCornerGaugeText(gaugeProvider: gaugeProvider,\n                                                         leadingTextProvider: leadingValueProvider,\n                                                         trailingTextProvider: trailingValueProvider,\n                                                         outerTextProvider: combinedMGProvider)\n}\n```\n\nThis example creates a curved gauge with text outside it. The gauge is a graphical element, like a thermometer or progress bar. To fill the template, the app supplies a gauge provider, which specifies the gauge’s start value, end value, current value, and the color gradient it uses. The app also provides two text providers for the labels at the start and end of the gauge. Finally, it adds another text provider for the main text. Depending on the watch face, the gauge and text may use the specified colors to provide additional information.\n\n### Reload the timeline\n\nThe `CoffeeData` model object declares `currentDrinks`  as a `@Published` property. The system alerts subscribers to any change to the `currentDrinks` array. For example, SwiftUI uses the publisher to trigger updates to the main view.\n\nHowever, the app also needs to update the complications and the app’s saved data after the value is changed. To control this, the app declares the `currentDrinks` setter as `private`, and create an asyncronous `drinkDataUpdated()` method that it calls whenever it updates the `currentDrinks` property.\n\n```swift\n\/\/ The list of drinks consumed.\n\/\/ Because this is @Published property,\n\/\/ Combine updates the app's main interface when a change occurs.\n@Published public private(set) var currentDrinks: [Drink] = []\n\n\/\/ Asynchronously update any active complications and save\n\/\/ the list of drinks after the current drinks property changes.\nprivate func drinkDataUpdated() async {\n    logger.debug(\"Updating the system based on the new current drinks property.\")\n    \n    \/\/ Save the app's data.\n    await store.save(currentDrinks)\n    \n    \/\/ Update any complications on active watch faces.\n    let server = CLKComplicationServer.sharedInstance()\n    let complications = await server.getActiveComplications()\n    \n    for complication in complications {\n        server.reloadTimeline(for: complication)\n    }\n}\n```\n\nThe `drinkDataUpdated()` method starts by saving the app’s data. Next, it accesses the list of active complications from the complication server, and tells the complication to reload its timeline — deleting the existing timeline and loading new data.\n\nHowever, if the system launches the app to handle a background update, Coffee Tracker may call the `drinkDataUpdated()` method before the complication server reattaches to the active complications. Therefore, the app uses the `getActiveComplication()` to wait, if necessary, until the server connects.\n\n```swift\nextension CLKComplicationServer {\n    \n    \/\/ Safely access the server's active complications.\n    @MainActor\n    func getActiveComplications() async -> [CLKComplication] {\n        return await withCheckedContinuation { continuation in\n            \n            \/\/ First, set up the notification.\n            let center = NotificationCenter.default\n            let mainQueue = OperationQueue.main\n            var token: NSObjectProtocol?\n            token = center.addObserver(forName: .CLKComplicationServerActiveComplicationsDidChange, object: nil, queue: mainQueue) { _ in\n                center.removeObserver(token!)\n                continuation.resume(returning: self.activeComplications!)\n            }\n            \n            \/\/ Then check to see if we have a valid active complications array.\n            if activeComplications != nil {\n                center.removeObserver(token!)\n                continuation.resume(returning: self.activeComplications!)\n            }\n        }\n    }\n}\n```\n\nThis method starts by setting up an observer for the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/CLKComplicationServerActiveComplicationsDidChange] notification. Then it checks the value of the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationServer\/activeComplications] property. If the property has a non-`nil` value, it cancels the observer and returns the value. Otherwise, it waits for the observer, and then returns the value.\n\n### Schedule background observer queries\n\nBefore Coffee Tracker can communicate with HealthKit, it needs to authorize HealthKit and set up the background observer query.\n\n```swift\n\/\/ Authorize HealthKit and set up the background observer query.\npublic func setUpHealthKit() {\n    \n    \/\/ Make sure HealthKit is available and authorized.\n    guard isAvailable else { return }\n    guard store.authorizationStatus(for: caffeineType) == .sharingAuthorized else { return }\n    \n    \/\/ Return if an observer query is already running.\n    guard backgroundObserver == nil else { return }\n    \n    logger.debug(\"Setting up the background observer queries.\")\n    \n    \/\/ Set up the background delivery rate.\n    store.enableBackgroundDelivery(for: caffeineType, frequency: .immediate) { success, error in\n        guard success else {\n            self.logger.error(\"Unable to set up background delivery from HealthKit: \\(error!.localizedDescription)\")\n            fatalError()\n        }\n    }\n    \n    \/\/ Set up the observer query.\n    backgroundObserver =\n    HKObserverQuery(sampleType: caffeineType,\n                    predicate: nil,\n                    updateHandler: processUpdate(query:completionHandler:error:))\n    \n    if let query = backgroundObserver {\n        logger.debug(\"Starting the background observer query.\")\n        store.execute(query)\n    }\n}\n```\n\nCoffee Tracker requests both read and write access to [doc:\/\/com.apple.documentation\/documentation\/HealthKit\/HKQuantityTypeIdentifier\/dietaryCaffeine] samples. Then it enables the background delivery for observer queries. Finally, it creates and executes an observer query for the `.dietaryCaffeine` data type.\n\nCoffee tracker creates the background observer query immediately after it launches. Setting up an observer query quickly after launch enables the observer to respond promptly when the system launches it in the background because of a change in HealthKit.\n\nThe query runs the `processUpdate(query:,completionHandler:,error:)` method whenever it recieves an update from the observer query.\n\n```swift\nfunc processUpdate(query: HKObserverQuery,\n                   completionHandler: @escaping () -> Void,\n                   error: Error?) {\n    \n    logger.debug(\"Received an update from the background observer query.\")\n    \n    \/\/ Check for any errors that occur while setting up the observer query.\n    guard error == nil else {\n        logger.error(\"Unable to set up a background observer query: \\(error!.localizedDescription)\")\n        fatalError()\n    }\n    \n    logger.debug(\"Responding to a background query.\")\n    \n    Task {\n        \n        \/\/ Load the updated data from the HealthKit Store.\n        let success = await loadNewDataFromHealthKit()\n        \n        \/\/ Check for any errors.\n        guard success == true else {\n            logger.error(\"Unable to query for new or deleted caffeine samples.\")\n            fatalError()\n        }\n        \n        \/\/ Call the completion handler when done.\n        completionHandler()\n    }\n}\n```\n\nThis method checks the update for errors. If there aren’t any errors, it asynchronously loads the new data from HealthKit, calling the update’s completion handler as soon as it’s done processing the results.\n\nTo preserve battery life and maintain performance, WatchKit carefully budgets each app’s time for background tasks. In general, if an app has a complication on the active watch face, it can safely use four updates per hour, shared between both the app’s background tasks and it’s background observer queries. However, HealthKit further limits the update on caffeine samples to a maximum of one per hour. And the system may further limit background activity as needed.\n\nThis means, the first update from HealthKit should trigger within a minute. However, the system may delay additional updates for up to an hour or more. For more information, see [doc:\/\/com.apple.documentation\/documentation\/HealthKit\/HKHealthStore\/enableBackgroundDelivery(for:frequency:withCompletion:)].\n\nThe app also loads any new data from HealthKit whenever it enters the foreground.\n\n## Sample Code\n\n- **Providing Multiple Complications**: Present multiple complications for a single complication family using descriptors.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Present multiple complications for a single complication family using descriptors.",
          "name" : "Providing Multiple Complications",
          "url" : "https:\/\/developer.apple.com\/documentation\/ClockKit\/providing-multiple-complications"
        }
      ],
      "title" : "Sample Code"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating and updating a complication’s timeline",
  "url" : "https:\/\/developer.apple.com\/documentation\/ClockKit\/creating-and-updating-a-complication-s-timeline"
}