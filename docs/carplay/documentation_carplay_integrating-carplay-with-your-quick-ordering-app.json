{
  "abstract" : "Configure your food-ordering app to work with CarPlay.",
  "codeExamples" : [
    {
      "code" : "func interfaceControllerDidConnect(_ interfaceController: CPInterfaceController, scene: CPTemplateApplicationScene) {\n    MemoryLogger.shared.appendEvent(\"Connected to CarPlay window.\")\n    carplayInterfaceController = interfaceController\n    carplayScene = scene\n    carplayInterfaceController?.delegate = self\n    sessionConfiguration = CPSessionConfiguration(delegate: self)\n    locationManager.delegate = self\n    requestLocation()\n    setupMap()\n}\n\nfunc setupMap() {\n    let pointOfInterestTemplate = CPPointOfInterestTemplate(\n        title: \"Hoagie Options\",\n        pointsOfInterest: [],\n        selectedIndex: NSNotFound)\n    pointOfInterestTemplate.pointOfInterestDelegate = self\n    pointOfInterestTemplate.tabTitle = \"Map\"\n    pointOfInterestTemplate.tabImage = UIImage(systemName: \"car\")!\n    \n    let tabTemplate = CPTabBarTemplate(templates: [pointOfInterestTemplate])\n    \n    carplayInterfaceController?.setRootTemplate(tabTemplate, animated: true, completion: { (done, error) in\n        \/\/ Note: Ensure that 12 is the maximum POI locations that appear on the display.\n        self.search(for: \"Hoagies\")\n    })\n}",
      "language" : "swift"
    },
    {
      "code" : "extension TemplateManager: CPPointOfInterestTemplateDelegate {\n    func pointOfInterestTemplate(_ aTemplate: CPPointOfInterestTemplate, didChangeMapRegion region: MKCoordinateRegion) {\n        MemoryLogger.shared.appendEvent(\"Region Changed: \\(region).\")\n        \/\/ In your app, you need to update your search results when this triggers.\n        boundingRegion = region\n        search(for: \"hoagies\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Make ordering the primary button.\nlet button = CPTextButton(title: \"Order\", textStyle: .normal, handler: { (button) in\n    MemoryLogger.shared.appendEvent(\"Order tapped \\(place).\")\n    self.showOrderTemplate(place: place)\n})\nplace.primaryButton = button\n\/\/ Try directions or a phone number as the secondary button.\nif let address = place.summary,\n   let encodedAddress = address.addingPercentEncoding(withAllowedCharacters: CharacterSet.alphanumerics),\n   let lon = place.location.placemark.location?.coordinate.longitude,\n   let lat = place.location.placemark.location?.coordinate.latitude,\n   let url = URL(string: \"maps:\/\/?q=\\(encodedAddress)&ll=\\(lon),\\(lat)\") {\n    place.secondaryButton = CPTextButton(title: \"Directions\", textStyle: .normal, handler: { (button) in\n        MemoryLogger.shared.appendEvent(\"Opening Maps with \\(address).\")\n        self.carplayScene?.open(url, options: nil, completionHandler: nil)\n    })\n} else if let phoneNumber = place.subtitle, let url = URL(string: \"tel:\/\/\" + phoneNumber.replacingOccurrences(of: \" \", with: \"\")) {\n    place.secondaryButton = CPTextButton(title: \"Call\", textStyle: .normal, handler: { (button) in\n        MemoryLogger.shared.appendEvent(\"Calling \\(phoneNumber).\")\n        self.carplayScene?.open(url, options: nil, completionHandler: nil)\n    })\n}",
      "language" : "swift"
    },
    {
      "code" : "func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n    switch manager.authorizationStatus {\n    case .denied, .restricted, .notDetermined:\n        let alert = CPAlertTemplate(\n            titleVariants: [\"Please enable location services.\"],\n            actions: [\n                CPAlertAction(\n                    title: \"Ok\",\n                    style: .default,\n                    handler: { [weak self] (action) in\n                        self?.carplayInterfaceController?.setRootTemplate(\n                            CPTabBarTemplate(templates: []), animated: false, completion: { (done, error) in\n                                MemoryLogger.shared.appendEvent(\"Error setting root template.\")\n                            }\n                        )\n                    }\n                )\n            ])\n        \n        \/\/ Check for a presented template and dismiss it for this important message.\n        if carplayInterfaceController?.presentedTemplate != nil {\n            dismissAlertAndPopToRootTemplate {\n                self.carplayInterfaceController?.presentTemplate(alert, animated: false, completion: { [weak self] (done, error) in\n                    self?.handleError(error, prependedMessage: \"Error presenting \\(alert.classForCoder)\")\n                })\n            }\n        } else {\n            carplayInterfaceController?.presentTemplate(alert, animated: false, completion: { [weak self] (done, error) in\n                self?.handleError(error, prependedMessage: \"Error presenting \\(alert.classForCoder)\")\n            })\n        }\n    default:\n        dismissAlertAndPopToRootTemplate {\n            self.setupMap()\n        }\n        return\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "            MemoryLogger.shared.appendEvent(\"Placing Order\")\n            do {\n                \n\/\/             Simulate a scenario where a person using the app enters a tunnel with no service just as they\n\/\/             place an order. The test API can't confirm the order in sendOrderToHoagieMakers(), and then the app loses service.\n\/\/             The Live Activity starts manually.\n                let attrs = OrderStatusAttributes(hoagieOrder: hoagieOrder)\n                let initialState = OrderStatusAttributes.ContentState(\n                    isPickedUp: false,\n                    isReady: false,\n                    isPreparing: false,\n                    isConfirmed: true)\n                \n                try saveOrderState(state: initialState)\n                \n                MemoryLogger.shared.appendEvent(\"Starting Live Activity\")\n                OrderingService.service.orderActivity = try Activity.request(\n                    attributes: attrs,\n                    content: .init(state: initialState, staleDate: Date(timeIntervalSinceNow: 60 * 30)),\n                    pushType: .token\n                )\n                try await finalizeOrder(hoagieOrder: hoagieOrder)\n            } catch {\n                throw OrderingError.errorOrdering\n            }",
      "language" : "swift"
    },
    {
      "code" : "\/\/      For the purposes of this demonstration, hoagies are ready in 10 minutes or less.\n\/\/      Here, a push notification indicates whether an order is ready earlier.\n\/\/      Spin off another thread to listen for updates.\n        Task { @MainActor in\n            MemoryLogger.shared.appendEvent(\"Change Listener Task Started\")\n            for await change in activity.contentUpdates {\n                MemoryLogger.shared.appendEvent(\"Content update change \\(change.description)\")\n                try saveOrderState(state: change.state)\n                WidgetCenter.shared.reloadAllTimelines()\n            }\n        }\n        \n        Task { @MainActor in\n            MemoryLogger.shared.appendEvent(\"State Listener Task Started\")\n            for await state in activity.activityStateUpdates {\n                MemoryLogger.shared.appendEvent(\"Content update change \\(state)\")\n                if state == .dismissed || state == .ended {\n                    await activity.end(nil, dismissalPolicy: .immediate)\n                    OrderingService.service.updateTokens[activity.id] = nil\n                }\n                WidgetCenter.shared.reloadAllTimelines()\n            }\n        }\n        \n        Task { @MainActor in\n            MemoryLogger.shared.appendEvent(\"Push Token Update Listener Task Started\")\n            for await pushToken in activity.pushTokenUpdates {\n                let pushTokenString = pushToken.reduce(\"\") {\n                    $0 + String(format: \"%02x\", $1)\n                }\n                \n                OrderingService.service.updateTokens[activity.id] = pushTokenString\n                try await self.sendPushToken(hoagieOrder: hoagieOrder, pushTokenString: pushTokenString)\n            }\n        }",
      "language" : "swift"
    },
    {
      "code" : "private static func createJWT() throws -> String {\n    if TestHoagieData.hoagieDefaults.string(forKey: savedTokenKey) == nil {\n        let symKey = try P256.Signing.PrivateKey(pemRepresentation: privateKey)\n        let headerJSONData = try JSONEncoder().encode(Header())\n        let headerBase64String = headerJSONData.urlSafeBase64EncodedString()\n        let payloadJSONData = try JSONEncoder().encode(Payload())\n        let payloadBase64String = payloadJSONData.urlSafeBase64EncodedString()\n        let toSign = Data((headerBase64String + \".\" + payloadBase64String).utf8)\n        let signature = try symKey.signature(for: toSign)\n        let signatureBase64String = signature.rawRepresentation.urlSafeBase64EncodedString()\n        let token = [headerBase64String, payloadBase64String, signatureBase64String].joined(separator: \".\")\n        TestHoagieData.hoagieDefaults.set(Date.now, forKey: lastTokenCreationDate)\n        TestHoagieData.hoagieDefaults.set(token, forKey: savedTokenKey)\n        print(token)\n        return token\n    } else if\n        let savedDate = TestHoagieData.hoagieDefaults.object(forKey: lastTokenCreationDate) as? Date,\n        Date.now.timeIntervalSince(savedDate) > TestHoagieData.tenMinutes {\n        TestHoagieData.hoagieDefaults.set(nil, forKey: lastTokenCreationDate)\n        TestHoagieData.hoagieDefaults.set(nil, forKey: savedTokenKey)\n        return try createJWT()\n    } else if let token = TestHoagieData.hoagieDefaults.string(forKey: savedTokenKey) {\n        print(token)\n        return token\n    } else {\n        fatalError()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "70c5d426dd71d8a594f3fbf4f2cb982a9402afd884536e9c8841ce98b83e0c22",
  "crawledAt" : "2025-12-02T15:47:51Z",
  "id" : "C2450D62-D1C2-4781-ABA3-C50FE3138983",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "CarPlay",
  "overview" : "## Overview\n\nThis sample code project demonstrates how to display custom ordering options in a vehicle using CarPlay. The sample app integrates with the CarPlay framework by implementing `CPTemplate` subclasses, such as [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/CPPointOfInterestTemplate] and [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/CPListTemplate]. This sample’s iOS app component provides a logging interface to help you understand the life cycle of a CarPlay app.\n\n### Configure the sample code project\n\nCarPlay quick-ordering apps require a CarPlay quick-ordering entitlement, which you can request [https:\/\/developer.apple.com\/contact\/carplay]. After Apple grants the entitlement, follow these steps:\n\n### Handle communication with CarPlay\n\nAfter a device connects to CarPlay and the sample app launches, it sets a root template to display content onscreen. The system sets the root template on the `CPInterfaceController` when the app connects to CarPlay. In this sample, the root template is an instance of `CPTabBarTemplate` with a `CPPointOfInterestTemplate` as the template that initially displays.\n\n### Keep the map in focus\n\nThe sample uses [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/CPPointOfInterestTemplateDelegate\/pointOfInterestTemplate(_:didChangeMapRegion:)] to keep the map in focus. The data that `CLLocationManager` provides for a given location can change as a person is moving. This means the results need to update as the map region changes.\n\nAfter someone selects an item, options to place an order and open Maps for directions, or to call the point of interest, appear onscreen, depending on metadata availability.\n\nBecause the sample relies on a person’s location to provide relevant results, handle permission issues gracefully. The sample removes any presented view controllers and presents a message that the location isn’t available.\n\n### Provide updates\n\nAfter a person places an order, the system starts a Live Activity to show the order’s status. Live Activities don’t display in CarPlay, but do provide a glanceable view on the person’s Lock Screen to inform them about updates to their order.\n\nAfter the Live Activity is running, you need to create a listener for updates to the state of the activity and token changes. Your app can update Live Activities, but only in the foreground. If your app spends significant amounts of time in the background, such as in a quick-ordering app, you need to use notifications to provide updates to people using the app. The code example below shows one way to listen for updates to the Live Activity token. Your app doesn’t need to support background updates, or use any `UIApplication` cycle methods. The system wakes the process that contains your Live Activity when the token changes and calls the attached block of code on the listener.\n\nThe sample includes a macOS target that provides a mock order status app. This is similar to what a service provider uses to convey updates to an order. The service app needs a JSON Web Token (JWT) to create push notifications for use with Live Activities. The following code example shows how the sample creates the JWT for use with the payload to send to Apple, which in turn sends a push notification to the associated device:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CarPlay\/integrating-carplay-with-your-quick-ordering-app\ncrawled: 2025-12-02T15:47:51Z\n---\n\n# Integrating CarPlay with your quick-ordering app\n\n**Sample Code**\n\nConfigure your food-ordering app to work with CarPlay.\n\n## Overview\n\nThis sample code project demonstrates how to display custom ordering options in a vehicle using CarPlay. The sample app integrates with the CarPlay framework by implementing `CPTemplate` subclasses, such as [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/CPPointOfInterestTemplate] and [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/CPListTemplate]. This sample’s iOS app component provides a logging interface to help you understand the life cycle of a CarPlay app.\n\n### Configure the sample code project\n\nCarPlay quick-ordering apps require a CarPlay quick-ordering entitlement, which you can request [https:\/\/developer.apple.com\/contact\/carplay]. After Apple grants the entitlement, follow these steps:\n\n1. Log in to your account on the Apple Developer website and create a new provisioning profile that includes the CarPlay quick ordering-app entitlement.\n2. Import the newly created provisioning profile into Xcode.\n3. Create an `Entitlements.plist` file in the project, if you don’t have one already.\n4. Create a key for the CarPlay quick-ordering app entitlement as a Boolean. Make sure that the target project setting `CODE_SIGN_ENTITLEMENTS` has the path of the `Entitlements.plist` file.\n\n### Handle communication with CarPlay\n\nAfter a device connects to CarPlay and the sample app launches, it sets a root template to display content onscreen. The system sets the root template on the `CPInterfaceController` when the app connects to CarPlay. In this sample, the root template is an instance of `CPTabBarTemplate` with a `CPPointOfInterestTemplate` as the template that initially displays.\n\n```swift\nfunc interfaceControllerDidConnect(_ interfaceController: CPInterfaceController, scene: CPTemplateApplicationScene) {\n    MemoryLogger.shared.appendEvent(\"Connected to CarPlay window.\")\n    carplayInterfaceController = interfaceController\n    carplayScene = scene\n    carplayInterfaceController?.delegate = self\n    sessionConfiguration = CPSessionConfiguration(delegate: self)\n    locationManager.delegate = self\n    requestLocation()\n    setupMap()\n}\n\nfunc setupMap() {\n    let pointOfInterestTemplate = CPPointOfInterestTemplate(\n        title: \"Hoagie Options\",\n        pointsOfInterest: [],\n        selectedIndex: NSNotFound)\n    pointOfInterestTemplate.pointOfInterestDelegate = self\n    pointOfInterestTemplate.tabTitle = \"Map\"\n    pointOfInterestTemplate.tabImage = UIImage(systemName: \"car\")!\n    \n    let tabTemplate = CPTabBarTemplate(templates: [pointOfInterestTemplate])\n    \n    carplayInterfaceController?.setRootTemplate(tabTemplate, animated: true, completion: { (done, error) in\n        \/\/ Note: Ensure that 12 is the maximum POI locations that appear on the display.\n        self.search(for: \"Hoagies\")\n    })\n}\n```\n\n### Keep the map in focus\n\nThe sample uses [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/CPPointOfInterestTemplateDelegate\/pointOfInterestTemplate(_:didChangeMapRegion:)] to keep the map in focus. The data that `CLLocationManager` provides for a given location can change as a person is moving. This means the results need to update as the map region changes.\n\n```swift\nextension TemplateManager: CPPointOfInterestTemplateDelegate {\n    func pointOfInterestTemplate(_ aTemplate: CPPointOfInterestTemplate, didChangeMapRegion region: MKCoordinateRegion) {\n        MemoryLogger.shared.appendEvent(\"Region Changed: \\(region).\")\n        \/\/ In your app, you need to update your search results when this triggers.\n        boundingRegion = region\n        search(for: \"hoagies\")\n    }\n}\n```\n\nAfter someone selects an item, options to place an order and open Maps for directions, or to call the point of interest, appear onscreen, depending on metadata availability.\n\n```swift\n\/\/ Make ordering the primary button.\nlet button = CPTextButton(title: \"Order\", textStyle: .normal, handler: { (button) in\n    MemoryLogger.shared.appendEvent(\"Order tapped \\(place).\")\n    self.showOrderTemplate(place: place)\n})\nplace.primaryButton = button\n\/\/ Try directions or a phone number as the secondary button.\nif let address = place.summary,\n   let encodedAddress = address.addingPercentEncoding(withAllowedCharacters: CharacterSet.alphanumerics),\n   let lon = place.location.placemark.location?.coordinate.longitude,\n   let lat = place.location.placemark.location?.coordinate.latitude,\n   let url = URL(string: \"maps:\/\/?q=\\(encodedAddress)&ll=\\(lon),\\(lat)\") {\n    place.secondaryButton = CPTextButton(title: \"Directions\", textStyle: .normal, handler: { (button) in\n        MemoryLogger.shared.appendEvent(\"Opening Maps with \\(address).\")\n        self.carplayScene?.open(url, options: nil, completionHandler: nil)\n    })\n} else if let phoneNumber = place.subtitle, let url = URL(string: \"tel:\/\/\" + phoneNumber.replacingOccurrences(of: \" \", with: \"\")) {\n    place.secondaryButton = CPTextButton(title: \"Call\", textStyle: .normal, handler: { (button) in\n        MemoryLogger.shared.appendEvent(\"Calling \\(phoneNumber).\")\n        self.carplayScene?.open(url, options: nil, completionHandler: nil)\n    })\n}\n```\n\nBecause the sample relies on a person’s location to provide relevant results, handle permission issues gracefully. The sample removes any presented view controllers and presents a message that the location isn’t available.\n\n```swift\nfunc locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n    switch manager.authorizationStatus {\n    case .denied, .restricted, .notDetermined:\n        let alert = CPAlertTemplate(\n            titleVariants: [\"Please enable location services.\"],\n            actions: [\n                CPAlertAction(\n                    title: \"Ok\",\n                    style: .default,\n                    handler: { [weak self] (action) in\n                        self?.carplayInterfaceController?.setRootTemplate(\n                            CPTabBarTemplate(templates: []), animated: false, completion: { (done, error) in\n                                MemoryLogger.shared.appendEvent(\"Error setting root template.\")\n                            }\n                        )\n                    }\n                )\n            ])\n        \n        \/\/ Check for a presented template and dismiss it for this important message.\n        if carplayInterfaceController?.presentedTemplate != nil {\n            dismissAlertAndPopToRootTemplate {\n                self.carplayInterfaceController?.presentTemplate(alert, animated: false, completion: { [weak self] (done, error) in\n                    self?.handleError(error, prependedMessage: \"Error presenting \\(alert.classForCoder)\")\n                })\n            }\n        } else {\n            carplayInterfaceController?.presentTemplate(alert, animated: false, completion: { [weak self] (done, error) in\n                self?.handleError(error, prependedMessage: \"Error presenting \\(alert.classForCoder)\")\n            })\n        }\n    default:\n        dismissAlertAndPopToRootTemplate {\n            self.setupMap()\n        }\n        return\n    }\n}\n```\n\n### Provide updates\n\nAfter a person places an order, the system starts a Live Activity to show the order’s status. Live Activities don’t display in CarPlay, but do provide a glanceable view on the person’s Lock Screen to inform them about updates to their order.\n\n```swift\n            MemoryLogger.shared.appendEvent(\"Placing Order\")\n            do {\n                \n\/\/             Simulate a scenario where a person using the app enters a tunnel with no service just as they\n\/\/             place an order. The test API can't confirm the order in sendOrderToHoagieMakers(), and then the app loses service.\n\/\/             The Live Activity starts manually.\n                let attrs = OrderStatusAttributes(hoagieOrder: hoagieOrder)\n                let initialState = OrderStatusAttributes.ContentState(\n                    isPickedUp: false,\n                    isReady: false,\n                    isPreparing: false,\n                    isConfirmed: true)\n                \n                try saveOrderState(state: initialState)\n                \n                MemoryLogger.shared.appendEvent(\"Starting Live Activity\")\n                OrderingService.service.orderActivity = try Activity.request(\n                    attributes: attrs,\n                    content: .init(state: initialState, staleDate: Date(timeIntervalSinceNow: 60 * 30)),\n                    pushType: .token\n                )\n                try await finalizeOrder(hoagieOrder: hoagieOrder)\n            } catch {\n                throw OrderingError.errorOrdering\n            }\n```\n\nAfter the Live Activity is running, you need to create a listener for updates to the state of the activity and token changes. Your app can update Live Activities, but only in the foreground. If your app spends significant amounts of time in the background, such as in a quick-ordering app, you need to use notifications to provide updates to people using the app. The code example below shows one way to listen for updates to the Live Activity token. Your app doesn’t need to support background updates, or use any `UIApplication` cycle methods. The system wakes the process that contains your Live Activity when the token changes and calls the attached block of code on the listener.\n\n```swift\n\/\/      For the purposes of this demonstration, hoagies are ready in 10 minutes or less.\n\/\/      Here, a push notification indicates whether an order is ready earlier.\n\/\/      Spin off another thread to listen for updates.\n        Task { @MainActor in\n            MemoryLogger.shared.appendEvent(\"Change Listener Task Started\")\n            for await change in activity.contentUpdates {\n                MemoryLogger.shared.appendEvent(\"Content update change \\(change.description)\")\n                try saveOrderState(state: change.state)\n                WidgetCenter.shared.reloadAllTimelines()\n            }\n        }\n        \n        Task { @MainActor in\n            MemoryLogger.shared.appendEvent(\"State Listener Task Started\")\n            for await state in activity.activityStateUpdates {\n                MemoryLogger.shared.appendEvent(\"Content update change \\(state)\")\n                if state == .dismissed || state == .ended {\n                    await activity.end(nil, dismissalPolicy: .immediate)\n                    OrderingService.service.updateTokens[activity.id] = nil\n                }\n                WidgetCenter.shared.reloadAllTimelines()\n            }\n        }\n        \n        Task { @MainActor in\n            MemoryLogger.shared.appendEvent(\"Push Token Update Listener Task Started\")\n            for await pushToken in activity.pushTokenUpdates {\n                let pushTokenString = pushToken.reduce(\"\") {\n                    $0 + String(format: \"%02x\", $1)\n                }\n                \n                OrderingService.service.updateTokens[activity.id] = pushTokenString\n                try await self.sendPushToken(hoagieOrder: hoagieOrder, pushTokenString: pushTokenString)\n            }\n        }\n```\n\nThe sample includes a macOS target that provides a mock order status app. This is similar to what a service provider uses to convey updates to an order. The service app needs a JSON Web Token (JWT) to create push notifications for use with Live Activities. The following code example shows how the sample creates the JWT for use with the payload to send to Apple, which in turn sends a push notification to the associated device:\n\n```swift\nprivate static func createJWT() throws -> String {\n    if TestHoagieData.hoagieDefaults.string(forKey: savedTokenKey) == nil {\n        let symKey = try P256.Signing.PrivateKey(pemRepresentation: privateKey)\n        let headerJSONData = try JSONEncoder().encode(Header())\n        let headerBase64String = headerJSONData.urlSafeBase64EncodedString()\n        let payloadJSONData = try JSONEncoder().encode(Payload())\n        let payloadBase64String = payloadJSONData.urlSafeBase64EncodedString()\n        let toSign = Data((headerBase64String + \".\" + payloadBase64String).utf8)\n        let signature = try symKey.signature(for: toSign)\n        let signatureBase64String = signature.rawRepresentation.urlSafeBase64EncodedString()\n        let token = [headerBase64String, payloadBase64String, signatureBase64String].joined(separator: \".\")\n        TestHoagieData.hoagieDefaults.set(Date.now, forKey: lastTokenCreationDate)\n        TestHoagieData.hoagieDefaults.set(token, forKey: savedTokenKey)\n        print(token)\n        return token\n    } else if\n        let savedDate = TestHoagieData.hoagieDefaults.object(forKey: lastTokenCreationDate) as? Date,\n        Date.now.timeIntervalSince(savedDate) > TestHoagieData.tenMinutes {\n        TestHoagieData.hoagieDefaults.set(nil, forKey: lastTokenCreationDate)\n        TestHoagieData.hoagieDefaults.set(nil, forKey: savedTokenKey)\n        return try createJWT()\n    } else if let token = TestHoagieData.hoagieDefaults.string(forKey: savedTokenKey) {\n        print(token)\n        return token\n    } else {\n        fatalError()\n    }\n}\n```\n\n## Location and Information\n\n- **CPPointOfInterestTemplate**: A template that displays a map with selectable points of interest.\n- **CPInformationTemplate**: A template that provides information for a point of interest, food order, parking location, or charging location.\n- **CPTextButton**: A button that displays a stylized title.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A template that displays a map with selectable points of interest.",
          "name" : "CPPointOfInterestTemplate",
          "url" : "https:\/\/developer.apple.com\/documentation\/CarPlay\/CPPointOfInterestTemplate"
        },
        {
          "description" : "A template that provides information for a point of interest, food order, parking location, or charging location.",
          "name" : "CPInformationTemplate",
          "url" : "https:\/\/developer.apple.com\/documentation\/CarPlay\/CPInformationTemplate"
        },
        {
          "description" : "A button that displays a stylized title.",
          "name" : "CPTextButton",
          "url" : "https:\/\/developer.apple.com\/documentation\/CarPlay\/CPTextButton"
        }
      ],
      "title" : "Location and Information"
    }
  ],
  "source" : "appleJSON",
  "title" : "Integrating CarPlay with your quick-ordering app",
  "url" : "https:\/\/developer.apple.com\/documentation\/CarPlay\/integrating-carplay-with-your-quick-ordering-app"
}