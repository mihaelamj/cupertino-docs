{
  "abstract" : "Implement a configurable virtual MIDI driver as a driver extension that runs in user space in macOS and iPadOS.",
  "codeExamples" : [
    {
      "code" : "kern_return_t IMPL(CreatingMIDIDriverSampleAppDriver, Start)\n{\n\tDebugMsg(\"+\");\n\tbool success = true;\n\n\tOSSharedPtr<OSString> deviceName(OSString::withCString(\"CreatingMIDIDriverSampleAppDevice\"), OSNoRetain);\n\tOSSharedPtr<OSString> modelUID(OSString::withCString(\"CreatingMIDIDriverSampleAppDevice-Model\"), OSNoRetain);\n\tOSSharedPtr<OSString> manufacturerUID(OSString::withCString(\"Apple Inc.\"), OSNoRetain);\n\n\tkern_return_t error = Start(provider, SUPERDISPATCH);\n\tif (error)\n\t{\n\t\tDebugMsg(\"Failed to start Super\");\n\t\tgoto Failure;\n\t}\n\n\t\/\/ Get the service's default dispatch queue from the driver object.\n\tivars->mWorkQueue = GetWorkQueue();\n\tif (ivars->mWorkQueue.get() == nullptr)\n\t{\n\t\tDebugMsg(\"Failed to get default work queue\");\n\t\terror = kIOReturnInvalid;\n\t\tgoto Failure;\n\t}\n\n\tivars->mCreatingMIDIDriverSampleAppDevice = OSSharedPtr(OSTypeAlloc(CreatingMIDIDriverSampleAppDevice), OSNoRetain);\n\tif (ivars->mCreatingMIDIDriverSampleAppDevice.get() == nullptr)\n\t{\n\t\tDebugMsg(\"Failed to allocate CreatingMIDIDriverSampleAppDevice\");\n\t\terror = kIOReturnNoMemory;\n\t\tgoto Failure;\n\t}\n\n\tsuccess = ivars->mCreatingMIDIDriverSampleAppDevice->init(this, deviceName.get(), modelUID.get(), manufacturerUID.get());\n\tif (!success)\n\t{\n\t\tDebugMsg(\"Failed to init CreatingMIDIDriverSampleAppDevice\");\n\t\terror = kIOReturnNoMemory;\n\t\tgoto Failure;\n\t}\n\n\tAddObject(ivars->mCreatingMIDIDriverSampleAppDevice.get());\n\n\t\/\/ Register the service\n\terror = RegisterService();\n\tif (error)\n\t{\n\t\tDebugMsg(\"Failed to register service\");\n\t\tgoto Failure;\n\t}\n\n\treturn kIOReturnSuccess;\n\nFailure:\n\n\tivars->mCreatingMIDIDriverSampleAppDevice.reset();\n\treturn error;\n}",
      "language" : "other"
    },
    {
      "code" : "kern_return_t IMPL(CreatingMIDIDriverSampleAppDriver, NewUserClient)\n{\n\tDebugMsg(\"type: %u out_user-client: %p\", type, userClient);\n\tkern_return_t error = kIOReturnSuccess;\n\n\t\/\/\tHave the superclass create the `IOUserMIDIDriverUserClient` object if the type is\n\t\/\/\tkIOUserMIDIDriverUserClientType.\n\tif (type == kIOUserMIDIDriverUserClientType)\n\t{\n\t\terror = super::NewUserClient(type, userClient, SUPERDISPATCH);\n\t\tif (error)\n\t\t{\n\t\t\tDebugMsg(\"Failed to create user client\");\n\t\t\tgoto Failure;\n\t\t}\n\t\tif (*userClient == nullptr)\n\t\t{\n\t\t\tDebugMsg(\"Failed to create user client\");\n\t\t\terror = kIOReturnNoMemory;\n\t\t\tgoto Failure;\n\t\t}\n\t}\n\telse\n\t{\n\t\tIOService* userClientService = nullptr;\n\t\terror = Create(this, \"CreatingMIDIDriverSampleAppUserClientProperties\", &userClientService);\n\t\tif (error != kIOReturnSuccess)\n\t\t{\n\t\t\tDebugMsg(\"failed to create the CreatingMIDIDriverSampleAppDriver user-client\");\n\t\t\tgoto Failure;\n\n\t\t}\n\t\t*userClient = OSDynamicCast(IOUserClient, userClientService);\n\t}\n\nFailure:\n\treturn error;\n}",
      "language" : "other"
    },
    {
      "code" : "\tauto entityName = CreateEntityName(1);\n\tauto entity = IOUserMIDIEntity::Create(driver,\n\t\t\t\t\t\t\t\t\t\t   this,\n\t\t\t\t\t\t\t\t\t\t   entityName.get(),\n\t\t\t\t\t\t\t\t\t\t   IOUserMIDIProtocolID::MIDIProtocol_2_0,\n\t\t\t\t\t\t\t\t\t\t   1, 1);\n\tAddEntity(entity.get());\n\n\tSetupEntities();\n\t\n\tSetProperty(IOUserMIDIProperty::Offline, offline.get());",
      "language" : "other"
    },
    {
      "code" : "void CreatingMIDIDriverSampleAppDevice::SetupEntities()\n{\n\tivars->mDestinations = OSSharedPtr(OSArray::withCapacity(1), OSNoRetain);\n\n\tGetEntities()->iterateObjects(^bool(OSObject* object){\n\t\tauto e = OSDynamicCast(IOUserMIDIEntity, object);\n\t\tif (e != nullptr)\n\t\t{\n\t\t\tauto source = e->GetSource(0);\n\t\t\tauto destination = e->GetDestination(0);\n\t\t\tauto ioBlock = ^kern_return_t(IOUserMIDIUMPWord const* umpWords, size_t numWords) {\n\t\t\t\treturn source->Send(umpWords, numWords);\n\t\t\t};\n\t\t\tdestination->SetIOBlock(ioBlock);\n\t\t}\n\t\treturn false;\n\t});\n}",
      "language" : "other"
    },
    {
      "code" : "kern_return_t CreatingMIDIDriverSampleAppDevice::StartIO()\n{\n\tDebugMsg(\"StartIO: device %u\", GetObjectID());\n\n\t__block kern_return_t error = kIOReturnSuccess;\n\n\tivars->mWorkQueue->DispatchSync(^{\n\t\t\/\/ Tell IOUserMIDIObject base class to start I\/O for the device.\n\t\terror = super::StartIO();\n\t\tif (error) {\n\t\t\tDebugMsg(\"Failed to start I\/O, error %d\", error);\n\t\t\tsuper::StopIO();\n\t\t}\n\t});\n\n\tif (error == kIOReturnSuccess) {\n\t\tauto offline = OSSharedPtr(OSNumber::withNumber(uint64_t{0}, 32), OSNoRetain);\n\t\tSetProperty(IOUserMIDIProperty::Offline, offline.get());\n\t}\n\t\t\n\treturn error;\n}",
      "language" : "other"
    },
    {
      "code" : "kern_return_t CreatingMIDIDriverSampleAppDriver::HandleAddPort()\n{\n\t__block kern_return_t ret = kIOReturnSuccess;\n\tivars->mWorkQueue->DispatchSync(^(){\n\t\tret = ivars->mCreatingMIDIDriverSampleAppDevice->AddPort();\n\t});\n\treturn ret;\n}",
      "language" : "other"
    },
    {
      "code" : "kern_return_t CreatingMIDIDriverSampleAppDevice::AddPort()\n{\n\tauto changeInfo = OSSharedPtr(OSString::withCString(\"Add Port\"), OSNoRetain);\n\tif (GetDeviceIsRunning())\n\t{\n\t\treturn RequestDeviceConfigurationChange(kAddPortConfigChangeAction, changeInfo.get());\n\t}\n\telse\n\t{\n\t\treturn PerformDeviceConfigurationChange(kAddPortConfigChangeAction, changeInfo.get());\n\t}\n}",
      "language" : "other"
    },
    {
      "code" : "kern_return_t CreatingMIDIDriverSampleAppDevice::PerformDeviceConfigurationChange(\n\t\tuint64_t changeAction, OSObject* changeInfo)\n{\n\n\tDebugMsg(\"change action %llu\", changeAction);\n\tkern_return_t ret = kIOReturnSuccess;\n\tswitch (changeAction) {\n\t\t\/\/ Add custom configuration change handlers.\n\t\tcase kAddPortConfigChangeAction:\n\t\t{\n\t\t\tif (changeInfo)\n\t\t\t{\n\t\t\t\tauto changeInfoString = OSDynamicCast(OSString, changeInfo);\n\t\t\t\tDebugMsg(\"%s\", changeInfoString->getCStringNoCopy());\n\t\t\t}\n\t\t\tauto entities = GetEntities();\n\t\t\tif (entities.get() != nullptr) {\n\t\t\t\tauto index = entities->getCount() + 1;\n\t\t\t\tauto entityName = CreateEntityName(index);\n\t\t\t\tauto entity = IOUserMIDIEntity::Create(ivars->mDriver.get(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   entityName.get(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   IOUserMIDIProtocolID::MIDIProtocol_2_0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   1, 1);\n\t\t\t\tAddEntity(entity.get());\n\t\t\t\tSetupEntities();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tret = super::PerformDeviceConfigurationChange(changeAction, changeInfo);\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
      "language" : "other"
    }
  ],
  "contentHash" : "070ed58e21ea24eed1ba01a3f55f29653d997ff2910c54540c7faf360fc749ce",
  "crawledAt" : "2025-12-02T15:51:31Z",
  "id" : "4FEA6C30-5F26-4A8C-980D-A377CB54D5EE",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "MIDIDriverKit",
  "overview" : "## Overview\n\nThis sample code project shows how to create a MIDI driver extension using the MIDIDriverKit framework. It provides a C++ DriverKit implementation that allows you to publish a single MIDI device with one port that contains a MIDI source and a MIDI destination, as well as a Swift client app that installs and configures the drivers.\n\nThe sample implements a dynamic environment that can support multiple MIDI devices and any other MIDI objects the MIDIDriverKit framework provides. The MIDI device provides the following features:\n\nMIDIDriverKit is available in macOS, and in iPadOS 18 and later when running on an iPad device with an M-series chip. This sample code project supports both platforms.\n\nThe sample app connects to the MIDI driver extension through a custom user client connection. The custom user client shows an example of how to toggle the offline property and add or remove a port on the MIDI driver extension. In macOS, the sample app also provides the installer for the driver. In iPadOS, you install the driver by enabling it in Settings.\n\n### Configure the sample code project\n\nBy default, the sample code project uses manual code signing. If you just want to run the app to see how it works, select “Automatically manage signing” for each of the targets.\n\nIf you want to run the app with manual signing, do the following:\n\n### Run the sample app in macOS\n\nTo run the sample app in macOS, use the scheme selector to select the CreatingMIDIDriverSampleApp scheme and the My Mac destination. Build the target, then copy the app to the Applications folder and launch the app.\n\nIn macOS, the CreatingMIDIDriverSampleApp app has two sections: Driver Manager, which installs the app, and User Client Manager, which interacts with the running driver. Under Driver Manager, click Install Driver. If a System Extension Blocked dialog appears, open System Settings and navigate to the Login Items & Extensions pane. Unlock the pane, if necessary, and click Allow to complete the installation. When installation completes, the Driver Manager status in the app displays the message “CreatingMIDIDriverSampleAppDriver has been activated and is ready to use.”\n\nAt this point, the sample’s MIDI device is available to CoreMIDI. To inspect the newly installed device, use the Audio MIDI Setup app (`Applications\/Utilities`), which shows the CreatingMIDIDriverSampleAppDevice on the MIDI pane with one port. You can change the number of ports and toggle the offline property there, or in the CreatingMIDIDriverSampleApp app’s User Client Manager section. Click Open User Client to open a connection from the app to the driver. Then you can use the other buttons in this section to toggle the offline property and to add or remove ports.\n\nTo use the driver, you can use any app that supports MIDI input and output, and select CreatingMIDIDriverSampleAppDevice’s sources or destinations.\n\nTo uninstall the driver, delete the sample app, which also stops and removes the driver extension (dext). You can also use `systemextensionsctl` from the command line to list and selectively uninstall system extensions like `com.example.apple-samplecode.ExampleDriver.Driver`.\n\n### Run the sample app in iPadOS\n\nTo run the sample app in iPadOS, connect an iPad device with an M-series chip to your Mac. Use the scheme selector to select the CreatingMIDIDriverSampleApp scheme and the name of your iPad as the destination. Run the app directly from Xcode to launch it on your iPad.\n\nIn iPadOS, the CreatingMIDIDriverSampleApp app doesn’t show the Driver Manager section because the app isn’t responsible for installing the driver like it is in macOS. Instead, choose Settings > Privacy & Security > Drivers, and enable the driver there.\n\nAfter enabling the driver, return to the CreatingMIDIDriverSampleApp app to open a user client connection and modify the device’s offline property or change the number of ports.\n\nWhen you finish using the driver, delete the app, which deletes the driver as well.\n\n### Create driver and device classes\n\nTo create a MIDIDriverKit driver, the sample creates a driver that subclasses [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididriver], and a device that subclasses [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice]. The dext’s `Info.plist` file contains entries that identify the driver class to MIDIDriverKit, which instantiates and initializes the driver. The sample’s `Info.plist` file shows how this works: the [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserclass?language=objc] key maps to the class name string `CreatingMIDIDriverSampleAppDriver`, and [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserservername?language=objc] contains the bundle ID.\n\nThe driver subclass is the entry point into the dext, while the device subclass handles start and stop I\/O-related messages and configuration messages. The device also owns various [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidiobject] instances for things like timer dispatch sources. In an actual hardware driver, the device class is also responsible for communication with the hardware over USB or PCI, and requires appropriate DriverKit entitlements for those transports. The sample doesn’t actually connect to hardware, and instead provides a virtual device with virtual MIDI sources and MIDI destinations.\n\nAfter initialization, DriverKit calls the driver’s [https:\/\/developer.apple.com\/documentation\/kernel\/ioservice\/3180710-start] method. The implementation in `CreatingMIDIDriverSampleAppDriver` creates and configures the `CreatingMIDIDriverSampleAppDevice` instance and, if successful, calls [https:\/\/developer.apple.com\/documentation\/kernel\/ioservice\/3180701-registerservice] to let the system know the driver is running.\n\n### Implement a user client interface\n\nThere are two dictionaries in the `Info.plist` file that define how the driver acts as a user client to CoreMIDI and to other apps. The first dictionary, `IOUserMIDIDriverUserClientProperties`, maps [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/ioclass?language=objc] to `IOUserUserClient` and [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserclass?language=objc] to `IOUserMIDIDriverUserClient`. This allows CoreMIDI to connect to the driver. To support user client connections from apps, the sample also defines a custom user client class. The dictionary for the custom user client has the key `CreatingMIDIDriverSampleAppUserClientProperties`, and its [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserclass?language=objc] has the value `CreatingMIDIDriverSampleAppDriverUserClient`, a custom subclass of [https:\/\/developer.apple.com\/documentation\/driverkit\/iouserclient]. Drivers that don’t accept user client connections from apps don’t need this second dictionary.\n\nWhen CoreMIDI requires a new user client connection to the dext, it calls the driver’s [https:\/\/developer.apple.com\/documentation\/driverkit\/ioservice\/3325581-newuserclient] method. In the sample, the implementation of this method serves two purposes. If the incoming client type is [https:\/\/developer.apple.com\/documentation\/mididriverkit\/mididriverkit_kiousermidiobjectiddriver], this is a request from CoreMIDI. In this case, the driver just forwards the call to the [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididriver] superclass. For other client types, such as apps connecting to the driver, it uses the `CreatingMIDIDriverSampleAppUserClientProperties` values from the `Info.plist` file to create an instance of the custom `CreatingMIDIDriverSampleAppDriverUserClient` class.\n\n### Create MIDI objects and set properties in the device initializer\n\nThe device class manages the [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidientity] interfaces containing [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidisource] and [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididestination] objects that perform MIDI I\/O.\n\nIn the sample, the `CreatingMIDIDriverSampleAppDevice` initializer method declares one instance of [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidientity], including one of each [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidisource] and [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididestination] objects.\n\n### Set up I\/O for MIDI sources and MIDI destinations\n\nTo receive MIDI data coming from CoreMIDI, each destination needs to set the I\/O block. The sample routes each destination to its corresponding source to implement a virtual driver.\n\n### Start device I\/O\n\nWhen CoreMIDI attempts to start I\/O on the device, it calls `CreatingMIDIDriverSampleAppDevice::StartIO`. MIDIDriverKit provides this method to signal the driver to perform any necessary calls to start I\/O on the device.\n\n### Handle configuration changes\n\nAt this point, the driver and device can supply a MIDI port with one source and one destination as if it’s coming from an external device. One other task a driver needs to support is handling configuration changes from the device. Three methods from [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice] support this ability:\n\nIn the sample code project, changing the number of ports provides an example of how to perform a configuration change. When a person taps the Add Port button, the app makes a user client call to the driver’s `HandleAddPort` method. The driver calls into the device’s `AddPort` method, which calls [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407883-requestdeviceconfigurationchange]. The latter tells MIDIDriverKit to shut down I\/O and then make a callback to [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407882-performdeviceconfigurationchange].\n\nThe implementation of [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407882-performdeviceconfigurationchange] starts by logging a string it receives from the initial callback in the app. Then it adds the new [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidientity] with each [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidisource] and [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididestination]. Assuming this succeeds, it sets up the callback blocks for I\/O. Finally, it calls the superclass’s implementation of [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407882-performdeviceconfigurationchange].\n\nWhen this method returns, the configuration change is complete, and the system resumes I\/O with the device.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/MIDIDriverKit\/creating-a-midi-device-driver\ncrawled: 2025-12-02T15:51:31Z\n---\n\n# Creating a MIDI device driver\n\n**Sample Code**\n\nImplement a configurable virtual MIDI driver as a driver extension that runs in user space in macOS and iPadOS.\n\n## Overview\n\nThis sample code project shows how to create a MIDI driver extension using the MIDIDriverKit framework. It provides a C++ DriverKit implementation that allows you to publish a single MIDI device with one port that contains a MIDI source and a MIDI destination, as well as a Swift client app that installs and configures the drivers.\n\nThe sample implements a dynamic environment that can support multiple MIDI devices and any other MIDI objects the MIDIDriverKit framework provides. The MIDI device provides the following features:\n\n- A port\n- A virtual MIDI source\n- A virtual MIDI destination\n- A toggle for the offline property\n- The possibility to add or remove a port\n\nMIDIDriverKit is available in macOS, and in iPadOS 18 and later when running on an iPad device with an M-series chip. This sample code project supports both platforms.\n\nThe sample app connects to the MIDI driver extension through a custom user client connection. The custom user client shows an example of how to toggle the offline property and add or remove a port on the MIDI driver extension. In macOS, the sample app also provides the installer for the driver. In iPadOS, you install the driver by enabling it in Settings.\n\n### Configure the sample code project\n\nBy default, the sample code project uses manual code signing. If you just want to run the app to see how it works, select “Automatically manage signing” for each of the targets.\n\nIf you want to run the app with manual signing, do the following:\n\n1. Create new bundle identifiers for the app and driver. The bundle identifiers in the project already have App IDs associated with them, so you need unique identifiers to create your own App IDs. Use a reverse-DNS format for your identifiers, as described in [https:\/\/developer.apple.com\/documentation\/xcode\/preparing-your-app-for-distribution]. Additionally, iPadOS requires that your driver’s bundle identifier begin with the host app’s bundle identifier. For example, the default bundle identifiers are `com.example.apple-samplecode.CreatingMIDIDriverSampleApp` for the app and `com.example.apple-samplecode.ExampleDriver.Driver` for the driver.\n2. In the Xcode project, click the Signing & Capabilities tab for each of the two targets — the driver and the macOS\/iOS app — and set the respective bundle identifier.\n3. In the driver’s `Info.plist` file, set the value of the [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserservername?language=objc] to the driver bundle identifier.\n4. In `CreatingMIDIDriverSampleAppViewModel.swift`, make sure the string concatentation that initializes `dextIdentifier` matches the bundle identifier for the driver.\n5. Create an explicit App ID and provisioning profile for the sample app with the entitlements [https:\/\/developer.apple.com\/documentation\/bundleresources\/entitlements\/com_apple_developer_system-extension_install?language=objc] and [https:\/\/developer.apple.com\/documentation\/bundleresources\/entitlements\/com_apple_developer_driverkit_communicates-with-drivers?language=objc]. For information about how to request entitlements, see [https:\/\/developer.apple.com\/documentation\/driverkit\/requesting_entitlements_for_driverkit_development].\n6. Create an explicit App ID and provisioning profile for the sample driver with the following entitlements: [https:\/\/developer.apple.com\/documentation\/bundleresources\/entitlements\/com_apple_developer_driverkit?language=objc], `com.apple.developer.driverkit.family.midi`, and `com.apple.developer.driverkit.allow-any-userclient-access`. This latter macOS-only entitlement allows any app to connect to the driver as a user client. Although this simplifies running the sample code, in your own apps you may prefer to use [https:\/\/developer.apple.com\/documentation\/bundleresources\/entitlements\/com_apple_developer_driverkit_userclient-access?language=objc]. This entitlement goes on the app rather than the driver, and lists bundle identifiers of drivers it can connect to. If you don’t intend for your driver to allow user client connections, just use the `com.apple.developer.driverkit.family.midi` entitlement.\n7. For each of the App IDs you create in the previous steps, select Profiles to create a new provisioning profile. You need one for the macOS app, one for the iPadOS app, and one for the driver, which supports both macOS and iPadOS. When creating the driver’s profile, be sure to select DriverKit App Development as the profile type.\n8. Download each profile and add it to Xcode.\n9. Click the Signing & Capabilities tab, set each target to manual code signing, and select its new profile.\n\n### Run the sample app in macOS\n\nTo run the sample app in macOS, use the scheme selector to select the CreatingMIDIDriverSampleApp scheme and the My Mac destination. Build the target, then copy the app to the Applications folder and launch the app.\n\n\n\nIn macOS, the CreatingMIDIDriverSampleApp app has two sections: Driver Manager, which installs the app, and User Client Manager, which interacts with the running driver. Under Driver Manager, click Install Driver. If a System Extension Blocked dialog appears, open System Settings and navigate to the Login Items & Extensions pane. Unlock the pane, if necessary, and click Allow to complete the installation. When installation completes, the Driver Manager status in the app displays the message “CreatingMIDIDriverSampleAppDriver has been activated and is ready to use.”\n\nAt this point, the sample’s MIDI device is available to CoreMIDI. To inspect the newly installed device, use the Audio MIDI Setup app (`Applications\/Utilities`), which shows the CreatingMIDIDriverSampleAppDevice on the MIDI pane with one port. You can change the number of ports and toggle the offline property there, or in the CreatingMIDIDriverSampleApp app’s User Client Manager section. Click Open User Client to open a connection from the app to the driver. Then you can use the other buttons in this section to toggle the offline property and to add or remove ports.\n\nTo use the driver, you can use any app that supports MIDI input and output, and select CreatingMIDIDriverSampleAppDevice’s sources or destinations.\n\nTo uninstall the driver, delete the sample app, which also stops and removes the driver extension (dext). You can also use `systemextensionsctl` from the command line to list and selectively uninstall system extensions like `com.example.apple-samplecode.ExampleDriver.Driver`.\n\n### Run the sample app in iPadOS\n\nTo run the sample app in iPadOS, connect an iPad device with an M-series chip to your Mac. Use the scheme selector to select the CreatingMIDIDriverSampleApp scheme and the name of your iPad as the destination. Run the app directly from Xcode to launch it on your iPad.\n\nIn iPadOS, the CreatingMIDIDriverSampleApp app doesn’t show the Driver Manager section because the app isn’t responsible for installing the driver like it is in macOS. Instead, choose Settings > Privacy & Security > Drivers, and enable the driver there.\n\nAfter enabling the driver, return to the CreatingMIDIDriverSampleApp app to open a user client connection and modify the device’s offline property or change the number of ports.\n\nWhen you finish using the driver, delete the app, which deletes the driver as well.\n\n### Create driver and device classes\n\nTo create a MIDIDriverKit driver, the sample creates a driver that subclasses [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididriver], and a device that subclasses [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice]. The dext’s `Info.plist` file contains entries that identify the driver class to MIDIDriverKit, which instantiates and initializes the driver. The sample’s `Info.plist` file shows how this works: the [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserclass?language=objc] key maps to the class name string `CreatingMIDIDriverSampleAppDriver`, and [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserservername?language=objc] contains the bundle ID.\n\nThe driver subclass is the entry point into the dext, while the device subclass handles start and stop I\/O-related messages and configuration messages. The device also owns various [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidiobject] instances for things like timer dispatch sources. In an actual hardware driver, the device class is also responsible for communication with the hardware over USB or PCI, and requires appropriate DriverKit entitlements for those transports. The sample doesn’t actually connect to hardware, and instead provides a virtual device with virtual MIDI sources and MIDI destinations.\n\nAfter initialization, DriverKit calls the driver’s [https:\/\/developer.apple.com\/documentation\/kernel\/ioservice\/3180710-start] method. The implementation in `CreatingMIDIDriverSampleAppDriver` creates and configures the `CreatingMIDIDriverSampleAppDevice` instance and, if successful, calls [https:\/\/developer.apple.com\/documentation\/kernel\/ioservice\/3180701-registerservice] to let the system know the driver is running.\n\n```other\nkern_return_t IMPL(CreatingMIDIDriverSampleAppDriver, Start)\n{\n\tDebugMsg(\"+\");\n\tbool success = true;\n\n\tOSSharedPtr<OSString> deviceName(OSString::withCString(\"CreatingMIDIDriverSampleAppDevice\"), OSNoRetain);\n\tOSSharedPtr<OSString> modelUID(OSString::withCString(\"CreatingMIDIDriverSampleAppDevice-Model\"), OSNoRetain);\n\tOSSharedPtr<OSString> manufacturerUID(OSString::withCString(\"Apple Inc.\"), OSNoRetain);\n\n\tkern_return_t error = Start(provider, SUPERDISPATCH);\n\tif (error)\n\t{\n\t\tDebugMsg(\"Failed to start Super\");\n\t\tgoto Failure;\n\t}\n\n\t\/\/ Get the service's default dispatch queue from the driver object.\n\tivars->mWorkQueue = GetWorkQueue();\n\tif (ivars->mWorkQueue.get() == nullptr)\n\t{\n\t\tDebugMsg(\"Failed to get default work queue\");\n\t\terror = kIOReturnInvalid;\n\t\tgoto Failure;\n\t}\n\n\tivars->mCreatingMIDIDriverSampleAppDevice = OSSharedPtr(OSTypeAlloc(CreatingMIDIDriverSampleAppDevice), OSNoRetain);\n\tif (ivars->mCreatingMIDIDriverSampleAppDevice.get() == nullptr)\n\t{\n\t\tDebugMsg(\"Failed to allocate CreatingMIDIDriverSampleAppDevice\");\n\t\terror = kIOReturnNoMemory;\n\t\tgoto Failure;\n\t}\n\n\tsuccess = ivars->mCreatingMIDIDriverSampleAppDevice->init(this, deviceName.get(), modelUID.get(), manufacturerUID.get());\n\tif (!success)\n\t{\n\t\tDebugMsg(\"Failed to init CreatingMIDIDriverSampleAppDevice\");\n\t\terror = kIOReturnNoMemory;\n\t\tgoto Failure;\n\t}\n\n\tAddObject(ivars->mCreatingMIDIDriverSampleAppDevice.get());\n\n\t\/\/ Register the service\n\terror = RegisterService();\n\tif (error)\n\t{\n\t\tDebugMsg(\"Failed to register service\");\n\t\tgoto Failure;\n\t}\n\n\treturn kIOReturnSuccess;\n\nFailure:\n\n\tivars->mCreatingMIDIDriverSampleAppDevice.reset();\n\treturn error;\n}\n```\n\n### Implement a user client interface\n\nThere are two dictionaries in the `Info.plist` file that define how the driver acts as a user client to CoreMIDI and to other apps. The first dictionary, `IOUserMIDIDriverUserClientProperties`, maps [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/ioclass?language=objc] to `IOUserUserClient` and [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserclass?language=objc] to `IOUserMIDIDriverUserClient`. This allows CoreMIDI to connect to the driver. To support user client connections from apps, the sample also defines a custom user client class. The dictionary for the custom user client has the key `CreatingMIDIDriverSampleAppUserClientProperties`, and its [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/iouserclass?language=objc] has the value `CreatingMIDIDriverSampleAppDriverUserClient`, a custom subclass of [https:\/\/developer.apple.com\/documentation\/driverkit\/iouserclient]. Drivers that don’t accept user client connections from apps don’t need this second dictionary.\n\nWhen CoreMIDI requires a new user client connection to the dext, it calls the driver’s [https:\/\/developer.apple.com\/documentation\/driverkit\/ioservice\/3325581-newuserclient] method. In the sample, the implementation of this method serves two purposes. If the incoming client type is [https:\/\/developer.apple.com\/documentation\/mididriverkit\/mididriverkit_kiousermidiobjectiddriver], this is a request from CoreMIDI. In this case, the driver just forwards the call to the [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididriver] superclass. For other client types, such as apps connecting to the driver, it uses the `CreatingMIDIDriverSampleAppUserClientProperties` values from the `Info.plist` file to create an instance of the custom `CreatingMIDIDriverSampleAppDriverUserClient` class.\n\n```other\nkern_return_t IMPL(CreatingMIDIDriverSampleAppDriver, NewUserClient)\n{\n\tDebugMsg(\"type: %u out_user-client: %p\", type, userClient);\n\tkern_return_t error = kIOReturnSuccess;\n\n\t\/\/\tHave the superclass create the `IOUserMIDIDriverUserClient` object if the type is\n\t\/\/\tkIOUserMIDIDriverUserClientType.\n\tif (type == kIOUserMIDIDriverUserClientType)\n\t{\n\t\terror = super::NewUserClient(type, userClient, SUPERDISPATCH);\n\t\tif (error)\n\t\t{\n\t\t\tDebugMsg(\"Failed to create user client\");\n\t\t\tgoto Failure;\n\t\t}\n\t\tif (*userClient == nullptr)\n\t\t{\n\t\t\tDebugMsg(\"Failed to create user client\");\n\t\t\terror = kIOReturnNoMemory;\n\t\t\tgoto Failure;\n\t\t}\n\t}\n\telse\n\t{\n\t\tIOService* userClientService = nullptr;\n\t\terror = Create(this, \"CreatingMIDIDriverSampleAppUserClientProperties\", &userClientService);\n\t\tif (error != kIOReturnSuccess)\n\t\t{\n\t\t\tDebugMsg(\"failed to create the CreatingMIDIDriverSampleAppDriver user-client\");\n\t\t\tgoto Failure;\n\n\t\t}\n\t\t*userClient = OSDynamicCast(IOUserClient, userClientService);\n\t}\n\nFailure:\n\treturn error;\n}\n```\n\n### Create MIDI objects and set properties in the device initializer\n\nThe device class manages the [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidientity] interfaces containing [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidisource] and [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididestination] objects that perform MIDI I\/O.\n\nIn the sample, the `CreatingMIDIDriverSampleAppDevice` initializer method declares one instance of [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidientity], including one of each [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidisource] and [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididestination] objects.\n\n```other\n\tauto entityName = CreateEntityName(1);\n\tauto entity = IOUserMIDIEntity::Create(driver,\n\t\t\t\t\t\t\t\t\t\t   this,\n\t\t\t\t\t\t\t\t\t\t   entityName.get(),\n\t\t\t\t\t\t\t\t\t\t   IOUserMIDIProtocolID::MIDIProtocol_2_0,\n\t\t\t\t\t\t\t\t\t\t   1, 1);\n\tAddEntity(entity.get());\n\n\tSetupEntities();\n\t\n\tSetProperty(IOUserMIDIProperty::Offline, offline.get());\n```\n\n### Set up I\/O for MIDI sources and MIDI destinations\n\nTo receive MIDI data coming from CoreMIDI, each destination needs to set the I\/O block. The sample routes each destination to its corresponding source to implement a virtual driver.\n\n```other\nvoid CreatingMIDIDriverSampleAppDevice::SetupEntities()\n{\n\tivars->mDestinations = OSSharedPtr(OSArray::withCapacity(1), OSNoRetain);\n\n\tGetEntities()->iterateObjects(^bool(OSObject* object){\n\t\tauto e = OSDynamicCast(IOUserMIDIEntity, object);\n\t\tif (e != nullptr)\n\t\t{\n\t\t\tauto source = e->GetSource(0);\n\t\t\tauto destination = e->GetDestination(0);\n\t\t\tauto ioBlock = ^kern_return_t(IOUserMIDIUMPWord const* umpWords, size_t numWords) {\n\t\t\t\treturn source->Send(umpWords, numWords);\n\t\t\t};\n\t\t\tdestination->SetIOBlock(ioBlock);\n\t\t}\n\t\treturn false;\n\t});\n}\n```\n\n### Start device I\/O\n\nWhen CoreMIDI attempts to start I\/O on the device, it calls `CreatingMIDIDriverSampleAppDevice::StartIO`. MIDIDriverKit provides this method to signal the driver to perform any necessary calls to start I\/O on the device.\n\n```other\nkern_return_t CreatingMIDIDriverSampleAppDevice::StartIO()\n{\n\tDebugMsg(\"StartIO: device %u\", GetObjectID());\n\n\t__block kern_return_t error = kIOReturnSuccess;\n\n\tivars->mWorkQueue->DispatchSync(^{\n\t\t\/\/ Tell IOUserMIDIObject base class to start I\/O for the device.\n\t\terror = super::StartIO();\n\t\tif (error) {\n\t\t\tDebugMsg(\"Failed to start I\/O, error %d\", error);\n\t\t\tsuper::StopIO();\n\t\t}\n\t});\n\n\tif (error == kIOReturnSuccess) {\n\t\tauto offline = OSSharedPtr(OSNumber::withNumber(uint64_t{0}, 32), OSNoRetain);\n\t\tSetProperty(IOUserMIDIProperty::Offline, offline.get());\n\t}\n\t\t\n\treturn error;\n}\n```\n\n### Handle configuration changes\n\nAt this point, the driver and device can supply a MIDI port with one source and one destination as if it’s coming from an external device. One other task a driver needs to support is handling configuration changes from the device. Three methods from [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice] support this ability:\n\n- [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407883-requestdeviceconfigurationchange] — A driver calls this method on the device prior to any configuration action. MIDIDriverKit temporarily shuts down ports — calling the device’s [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4337352-stopio] callback — so that the device class can perform the configuration change.\n- [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407882-performdeviceconfigurationchange] — MIDIDriverKit calls this method after stopping any running I\/O, signaling to the device class that it can perform its configuration change. This is where the device can change the number of ports, source, and destination, or perform other changes that are only safe while I\/O isn’t occurring. After this method returns, MIDIDriverKit restarts I\/O, if necessary, calling the device’s [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4337351-startio] callback.\n- [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407881-abortdeviceconfigurationchange] — A driver calls this method to stop a change from a request to [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407883-requestdeviceconfigurationchange]. The sample doesn’t need to perform any additional work to implement this method, so it just calls its superclass’s implementation.\n\nIn the sample code project, changing the number of ports provides an example of how to perform a configuration change. When a person taps the Add Port button, the app makes a user client call to the driver’s `HandleAddPort` method. The driver calls into the device’s `AddPort` method, which calls [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407883-requestdeviceconfigurationchange]. The latter tells MIDIDriverKit to shut down I\/O and then make a callback to [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407882-performdeviceconfigurationchange].\n\n```other\nkern_return_t CreatingMIDIDriverSampleAppDriver::HandleAddPort()\n{\n\t__block kern_return_t ret = kIOReturnSuccess;\n\tivars->mWorkQueue->DispatchSync(^(){\n\t\tret = ivars->mCreatingMIDIDriverSampleAppDevice->AddPort();\n\t});\n\treturn ret;\n}\n```\n\n```other\nkern_return_t CreatingMIDIDriverSampleAppDevice::AddPort()\n{\n\tauto changeInfo = OSSharedPtr(OSString::withCString(\"Add Port\"), OSNoRetain);\n\tif (GetDeviceIsRunning())\n\t{\n\t\treturn RequestDeviceConfigurationChange(kAddPortConfigChangeAction, changeInfo.get());\n\t}\n\telse\n\t{\n\t\treturn PerformDeviceConfigurationChange(kAddPortConfigChangeAction, changeInfo.get());\n\t}\n}\n```\n\nThe implementation of [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407882-performdeviceconfigurationchange] starts by logging a string it receives from the initial callback in the app. Then it adds the new [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidientity] with each [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermidisource] and [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididestination]. Assuming this succeeds, it sets up the callback blocks for I\/O. Finally, it calls the superclass’s implementation of [https:\/\/developer.apple.com\/documentation\/mididriverkit\/iousermididevice\/4407882-performdeviceconfigurationchange].\n\n```other\nkern_return_t CreatingMIDIDriverSampleAppDevice::PerformDeviceConfigurationChange(\n\t\tuint64_t changeAction, OSObject* changeInfo)\n{\n\n\tDebugMsg(\"change action %llu\", changeAction);\n\tkern_return_t ret = kIOReturnSuccess;\n\tswitch (changeAction) {\n\t\t\/\/ Add custom configuration change handlers.\n\t\tcase kAddPortConfigChangeAction:\n\t\t{\n\t\t\tif (changeInfo)\n\t\t\t{\n\t\t\t\tauto changeInfoString = OSDynamicCast(OSString, changeInfo);\n\t\t\t\tDebugMsg(\"%s\", changeInfoString->getCStringNoCopy());\n\t\t\t}\n\t\t\tauto entities = GetEntities();\n\t\t\tif (entities.get() != nullptr) {\n\t\t\t\tauto index = entities->getCount() + 1;\n\t\t\t\tauto entityName = CreateEntityName(index);\n\t\t\t\tauto entity = IOUserMIDIEntity::Create(ivars->mDriver.get(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   entityName.get(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   IOUserMIDIProtocolID::MIDIProtocol_2_0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   1, 1);\n\t\t\t\tAddEntity(entity.get());\n\t\t\t\tSetupEntities();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tret = super::PerformDeviceConfigurationChange(changeAction, changeInfo);\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n```\n\nWhen this method returns, the configuration change is complete, and the system resumes I\/O with the device.\n\n## Essentials\n\n- **com.apple.developer.driverkit.family.midi**: A Boolean value that indicates whether to match the driver against devices that support MIDI.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A Boolean value that indicates whether to match the driver against devices that support MIDI.",
          "name" : "com.apple.developer.driverkit.family.midi",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit.family.midi"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a MIDI device driver",
  "url" : "https:\/\/developer.apple.com\/documentation\/MIDIDriverKit\/creating-a-midi-device-driver"
}