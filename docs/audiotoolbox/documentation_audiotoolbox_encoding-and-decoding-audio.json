{
  "abstract" : "Convert audio formats to efficiently manage data and quality.",
  "codeExamples" : [
    {
      "code" : "\/\/ Open the input file and get its data format.\nauto inputFile = AudioFile::Open(argv[2]);\nAudioStreamBasicDescription inputDescription;\ninputFile.GetProperty(\n\tkAudioFilePropertyDataFormat,\n\tsizeof(inputDescription),\n\t&inputDescription);\n\n\/\/ If encoding, make sure the input data is PCM.\nif (encode && (inputDescription.mFormatID != kAudioFormatLinearPCM)) {\n\tstd::cerr << \"The input file data format is not PCM\" << std::endl;\n\treturn EXIT_FAILURE;\n}",
      "language" : "c++"
    },
    {
      "code" : "const bool inputUsesPacketDescriptions =\n\t(inputDescription.mBytesPerPacket == 0 || inputDescription.mFramesPerPacket == 0);",
      "language" : "c++"
    },
    {
      "code" : "\/\/ Create the output file as PCM or AAC of the same sampling rate and number of channels as\n\/\/ the input.\nAudioStreamBasicDescription outputDescription{\n\t.mSampleRate = inputDescription.mSampleRate,\n\t.mChannelsPerFrame = inputDescription.mChannelsPerFrame,\n};\nAudioFileTypeID outputFileType;\nif (encode) {\n\toutputFileType = kAudioFileM4AType;\n\toutputDescription.mFormatID = kAudioFormatMPEG4AAC;\n\toutputDescription.mFormatFlags = kAudioFormatFlagsAreAllClear;\n\toutputDescription.mFramesPerPacket = 1024;\n} else {\n\toutputFileType = kAudioFileWAVEType;\n\toutputDescription.mFormatID = kAudioFormatLinearPCM;\n\toutputDescription.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;\n\toutputDescription.mBytesPerPacket = 4 * inputDescription.mChannelsPerFrame;\n\toutputDescription.mFramesPerPacket = 1;\n\toutputDescription.mBytesPerFrame = 4 * inputDescription.mChannelsPerFrame;\n\toutputDescription.mBitsPerChannel = 32;\n}",
      "language" : "c++"
    },
    {
      "code" : "std::optional<size_t> magicCookieSize =\n\tinputFile.GetPropertySize(kAudioFilePropertyMagicCookieData);\nif (magicCookieSize.has_value()) {\n\tstd::cout << \"The magic cookie is \"\n\t\t\t  << *magicCookieSize\n\t          << \" bytes in size.\"\n\t\t\t  << std::endl;\n\n\t\/\/ Get the magic cookie from the input file.\n\tstd::vector<uint8_t> magicCookie(*magicCookieSize);\n\tinputFile.GetProperty(\n\t\tkAudioFilePropertyMagicCookieData,\n\t\tmagicCookie.size(),\n\t\tmagicCookie.data());\n\n\t\/\/ Provide the magic cookie to the decoder, via the AudioConverter.\n\taudioConverter.SetProperty(kAudioConverterDecompressionMagicCookie,\n\t\tmagicCookie.size(),\n\t\tmagicCookie.data());\n} else {\n\tstd::cout << \"There is no magic cookie.\" << std::endl;\n}",
      "language" : "c++"
    },
    {
      "code" : "\/\/ Try to handle more packets depending on whether the sample is encoding or decoding.\nUInt32 numPackets = packetsPerLoop;\nAudioBufferList abl{ 1, {\n\t\t\t\t\t\t\toutputDescription.mChannelsPerFrame, \/\/ mNumberChannels\n\t\t\t\t\t\t\t(UInt32)packetBuffer.size(),         \/\/ mDataByteSize\n\t\t\t\t\t\t\tpacketBuffer.data()                  \/\/ mData\n\t\t\t\t\t\t} };\naudioConverter.FillComplexBuffer(InputContext::InputDataProc,\n\t\t\t\t\t\t\t\t &inputContext,\n\t\t\t\t\t\t\t\t numPackets,\n\t\t\t\t\t\t\t\t abl,\n\t\t\t\t\t\t\t\t encode ? packetDescriptions.data() : NULL);",
      "language" : "c++"
    },
    {
      "code" : "\/\/ Read packets from the file into the buffer, along with packet descriptions, if any exist.\ntry {\n\tself.mInputFile.ReadPackets(ioData->mBuffers[0].mDataByteSize,\n\t\t\t\t\t\t\t\tself.mInputUsesPacketDescriptions ? self.mPacketDescriptions.data() : NULL,\n\t\t\t\t\t\t\t\t*ioNumberDataPackets,\n\t\t\t\t\t\t\t\tioData->mBuffers[0].mData);\n} catch (AudioToolboxError err) {\n\tstd::cerr << \"Encountered an error while reading packets: \" << err.what() << std::endl;\n\treturn err.status;\n}",
      "language" : "c++"
    },
    {
      "code" : "\/\/ If there are output packets, write them to the output file.\nif (numPackets > 0) {\n\toutputFile.WritePackets(abl.mBuffers[0].mDataByteSize,\n\t\t\t\t\t\t\tencode ? packetDescriptions.data() : NULL,\n\t\t\t\t\t\t\tnumPackets,\n\t\t\t\t\t\t\tabl.mBuffers[0].mData);\n}",
      "language" : "c++"
    }
  ],
  "contentHash" : "c76d91ff5833f851391896a1a435cdf347b2fed845337ab06db2f28ac4b5297a",
  "crawledAt" : "2025-12-02T15:47:45Z",
  "id" : "FE35EE0F-C3EA-45E7-86AB-633F5273138F",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Audio Toolbox",
  "overview" : "## Overview\n\nThis sample shows how to encode and decode audio by using Audio Toolbox. If it’s encoding, the sample outputs the audio using the Advanced Audio Coding (AAC) audio format. AAC is a compressed, lossy audio format that maintains audio quality while using less storage space. When the sample decodes audio, the output audio format is represented as pulse code modulation (PCM). PCM is both an uncompressed and lossless audio format, resulting in a larger file format.\n\nThe sample also explores how to set up data structures that describe audio formats, read and write packets to and from audio files, retrieve and set magic cookies, and loop through the input callback that signals the end of a buffer stream.\n\n### Create input and output descriptions\n\nWhether it’s encoding or decoding audio, the sample uses the structure [doc:\/\/com.apple.documentation\/documentation\/CoreAudioTypes\/AudioStreamBasicDescription] to describe  the input and output audio data formats. When encoding audio, the sample checks whether the input audio is in PCM format. If the input is not PCM, the sample fails because a single audio converter instance can’t transcode (decode one non-PCM format and encode to another non-PCM format).\n\nThe sample checks whether the input uses packet descriptions. Packet descriptions accompany packets if the audio format indicates a variable number of bytes per packet, or frames per packet. Function calls and callbacks may produce or consume packet descriptions. Provide a buffer even if the client doesn’t need them or if it’s only processing a single packet.\n\nThe sample initializes the output description with the input sample rate and channels per frame. Once created, the output configuration depends on whether the sample is encoding or decoding the audio.\n\nWith the output specification, the sample creates the audio converter object that it uses for encoding or decoding the audio.\n\n### Provide a magic cookie\n\nSome audio formats have a magic cookie that the converter requires to decompress audio data. A *magic cookie* refers to information in an audio file that describes its data format. An encoder produces the magic cookie, and it’s included in the same file or stream as the audio packets, in a header, or a container file format through a box.\n\nWhen decoding audio, the sample checks if the format of the audio data that the framework is converting has a magic cookie. If the audio data format has a magic cookie, the sample adds the information to the audio converter instance before converting the audio.\n\nWhen encoding an audio file, the sample adds the magic cookie back to the file — after converting the audio — because it could change during the encoding process. Get the magic cookie by using the property [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/kAudioConverterCompressionMagicCookie] and then add it to the output file.\n\n### Convert the audio\n\nAfter the sample creates the output description, and sets the magic cookie if it’s decoding, it converts the audio by looping through the available data. The loop begins by trying to decode the available packets.\n\nWhen looping through the available packets, the sample reads packets from the input file through an input callback that wraps [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioFileReadPacketData(_:_:_:_:_:_:_:)]. It’s important that `ioNumberDataPackets` and `mDataByteSize` in the buffers remain consistent. If one changes, the other must match. If the audio format calls for packet descriptions, they should also be consistent with `ioNumberDataPackets` and `mDataByteSize`.\n\nIf the sample receives output packets, it writes them to an output file in the project build folder.\n\nThe loop stops when there aren’t enough packets to satisfy the input request. There are two additional cases to consider when running out of data.\n\nFirst, there’s no data currently available from the input stream, but data remains to convert. For example, when streaming input data in real time, the converter may not reach the end of the stream because it’s waiting to receive the next input packet. In this case, set `ioNumberDataPackets` to zero and return a custom error code. The error propagates to the call [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioConverterFillComplexBuffer(_:_:_:_:_:_:)], which makes it distinguishable from other errors in the conversion process, such as errors that indicate there’s no data currently available. The caller receives any remaining data the converter processes.\n\nSecond, the conversion reaches the end of the stream. In this case, set `ioNumberDataPackets` and `mDataByteSize` to zero and return `noErr`. The audio converter may call the input procedure a few times, so return zero and `noErr`.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AudioToolbox\/encoding-and-decoding-audio\ncrawled: 2025-12-02T15:47:45Z\n---\n\n# Encoding and decoding audio\n\n**Sample Code**\n\nConvert audio formats to efficiently manage data and quality.\n\n## Overview\n\nThis sample shows how to encode and decode audio by using Audio Toolbox. If it’s encoding, the sample outputs the audio using the Advanced Audio Coding (AAC) audio format. AAC is a compressed, lossy audio format that maintains audio quality while using less storage space. When the sample decodes audio, the output audio format is represented as pulse code modulation (PCM). PCM is both an uncompressed and lossless audio format, resulting in a larger file format.\n\nThe sample also explores how to set up data structures that describe audio formats, read and write packets to and from audio files, retrieve and set magic cookies, and loop through the input callback that signals the end of a buffer stream.\n\n### Create input and output descriptions\n\nWhether it’s encoding or decoding audio, the sample uses the structure [doc:\/\/com.apple.documentation\/documentation\/CoreAudioTypes\/AudioStreamBasicDescription] to describe  the input and output audio data formats. When encoding audio, the sample checks whether the input audio is in PCM format. If the input is not PCM, the sample fails because a single audio converter instance can’t transcode (decode one non-PCM format and encode to another non-PCM format).\n\n```c++\n\/\/ Open the input file and get its data format.\nauto inputFile = AudioFile::Open(argv[2]);\nAudioStreamBasicDescription inputDescription;\ninputFile.GetProperty(\n\tkAudioFilePropertyDataFormat,\n\tsizeof(inputDescription),\n\t&inputDescription);\n\n\/\/ If encoding, make sure the input data is PCM.\nif (encode && (inputDescription.mFormatID != kAudioFormatLinearPCM)) {\n\tstd::cerr << \"The input file data format is not PCM\" << std::endl;\n\treturn EXIT_FAILURE;\n}\n```\n\nThe sample checks whether the input uses packet descriptions. Packet descriptions accompany packets if the audio format indicates a variable number of bytes per packet, or frames per packet. Function calls and callbacks may produce or consume packet descriptions. Provide a buffer even if the client doesn’t need them or if it’s only processing a single packet.\n\n```c++\nconst bool inputUsesPacketDescriptions =\n\t(inputDescription.mBytesPerPacket == 0 || inputDescription.mFramesPerPacket == 0);\n```\n\nThe sample initializes the output description with the input sample rate and channels per frame. Once created, the output configuration depends on whether the sample is encoding or decoding the audio.\n\n```c++\n\/\/ Create the output file as PCM or AAC of the same sampling rate and number of channels as\n\/\/ the input.\nAudioStreamBasicDescription outputDescription{\n\t.mSampleRate = inputDescription.mSampleRate,\n\t.mChannelsPerFrame = inputDescription.mChannelsPerFrame,\n};\nAudioFileTypeID outputFileType;\nif (encode) {\n\toutputFileType = kAudioFileM4AType;\n\toutputDescription.mFormatID = kAudioFormatMPEG4AAC;\n\toutputDescription.mFormatFlags = kAudioFormatFlagsAreAllClear;\n\toutputDescription.mFramesPerPacket = 1024;\n} else {\n\toutputFileType = kAudioFileWAVEType;\n\toutputDescription.mFormatID = kAudioFormatLinearPCM;\n\toutputDescription.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked;\n\toutputDescription.mBytesPerPacket = 4 * inputDescription.mChannelsPerFrame;\n\toutputDescription.mFramesPerPacket = 1;\n\toutputDescription.mBytesPerFrame = 4 * inputDescription.mChannelsPerFrame;\n\toutputDescription.mBitsPerChannel = 32;\n}\n```\n\nWith the output specification, the sample creates the audio converter object that it uses for encoding or decoding the audio.\n\n### Provide a magic cookie\n\nSome audio formats have a magic cookie that the converter requires to decompress audio data. A *magic cookie* refers to information in an audio file that describes its data format. An encoder produces the magic cookie, and it’s included in the same file or stream as the audio packets, in a header, or a container file format through a box.\n\nWhen decoding audio, the sample checks if the format of the audio data that the framework is converting has a magic cookie. If the audio data format has a magic cookie, the sample adds the information to the audio converter instance before converting the audio.\n\n```c++\nstd::optional<size_t> magicCookieSize =\n\tinputFile.GetPropertySize(kAudioFilePropertyMagicCookieData);\nif (magicCookieSize.has_value()) {\n\tstd::cout << \"The magic cookie is \"\n\t\t\t  << *magicCookieSize\n\t          << \" bytes in size.\"\n\t\t\t  << std::endl;\n\n\t\/\/ Get the magic cookie from the input file.\n\tstd::vector<uint8_t> magicCookie(*magicCookieSize);\n\tinputFile.GetProperty(\n\t\tkAudioFilePropertyMagicCookieData,\n\t\tmagicCookie.size(),\n\t\tmagicCookie.data());\n\n\t\/\/ Provide the magic cookie to the decoder, via the AudioConverter.\n\taudioConverter.SetProperty(kAudioConverterDecompressionMagicCookie,\n\t\tmagicCookie.size(),\n\t\tmagicCookie.data());\n} else {\n\tstd::cout << \"There is no magic cookie.\" << std::endl;\n}\n```\n\nWhen encoding an audio file, the sample adds the magic cookie back to the file — after converting the audio — because it could change during the encoding process. Get the magic cookie by using the property [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/kAudioConverterCompressionMagicCookie] and then add it to the output file.\n\n### Convert the audio\n\nAfter the sample creates the output description, and sets the magic cookie if it’s decoding, it converts the audio by looping through the available data. The loop begins by trying to decode the available packets.\n\n```c++\n\/\/ Try to handle more packets depending on whether the sample is encoding or decoding.\nUInt32 numPackets = packetsPerLoop;\nAudioBufferList abl{ 1, {\n\t\t\t\t\t\t\toutputDescription.mChannelsPerFrame, \/\/ mNumberChannels\n\t\t\t\t\t\t\t(UInt32)packetBuffer.size(),         \/\/ mDataByteSize\n\t\t\t\t\t\t\tpacketBuffer.data()                  \/\/ mData\n\t\t\t\t\t\t} };\naudioConverter.FillComplexBuffer(InputContext::InputDataProc,\n\t\t\t\t\t\t\t\t &inputContext,\n\t\t\t\t\t\t\t\t numPackets,\n\t\t\t\t\t\t\t\t abl,\n\t\t\t\t\t\t\t\t encode ? packetDescriptions.data() : NULL);\n```\n\nWhen looping through the available packets, the sample reads packets from the input file through an input callback that wraps [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioFileReadPacketData(_:_:_:_:_:_:_:)]. It’s important that `ioNumberDataPackets` and `mDataByteSize` in the buffers remain consistent. If one changes, the other must match. If the audio format calls for packet descriptions, they should also be consistent with `ioNumberDataPackets` and `mDataByteSize`.\n\n```c++\n\/\/ Read packets from the file into the buffer, along with packet descriptions, if any exist.\ntry {\n\tself.mInputFile.ReadPackets(ioData->mBuffers[0].mDataByteSize,\n\t\t\t\t\t\t\t\tself.mInputUsesPacketDescriptions ? self.mPacketDescriptions.data() : NULL,\n\t\t\t\t\t\t\t\t*ioNumberDataPackets,\n\t\t\t\t\t\t\t\tioData->mBuffers[0].mData);\n} catch (AudioToolboxError err) {\n\tstd::cerr << \"Encountered an error while reading packets: \" << err.what() << std::endl;\n\treturn err.status;\n}\n```\n\nIf the sample receives output packets, it writes them to an output file in the project build folder.\n\n```c++\n\/\/ If there are output packets, write them to the output file.\nif (numPackets > 0) {\n\toutputFile.WritePackets(abl.mBuffers[0].mDataByteSize,\n\t\t\t\t\t\t\tencode ? packetDescriptions.data() : NULL,\n\t\t\t\t\t\t\tnumPackets,\n\t\t\t\t\t\t\tabl.mBuffers[0].mData);\n}\n```\n\nThe loop stops when there aren’t enough packets to satisfy the input request. There are two additional cases to consider when running out of data.\n\nFirst, there’s no data currently available from the input stream, but data remains to convert. For example, when streaming input data in real time, the converter may not reach the end of the stream because it’s waiting to receive the next input packet. In this case, set `ioNumberDataPackets` to zero and return a custom error code. The error propagates to the call [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioConverterFillComplexBuffer(_:_:_:_:_:_:)], which makes it distinguishable from other errors in the conversion process, such as errors that indicate there’s no data currently available. The caller receives any remaining data the converter processes.\n\nSecond, the conversion reaches the end of the stream. In this case, set `ioNumberDataPackets` and `mDataByteSize` to zero and return `noErr`. The audio converter may call the input procedure a few times, so return zero and `noErr`.\n\n## Performing Conversions\n\n- **AudioConverterConvertBuffer(_:_:_:_:_:)**: Converts audio data from one linear PCM format to another.\n- **AudioConverterFillComplexBuffer(_:_:_:_:_:_:)**: Converts audio data supplied by a callback function, supporting non-interleaved and packetized formats.\n- **AudioConverterConvertComplexBuffer(_:_:_:_:)**: Converts audio data from one linear PCM format to another, where both use the same sample rate.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Converts audio data from one linear PCM format to another.",
          "name" : "AudioConverterConvertBuffer(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AudioConverterConvertBuffer(_:_:_:_:_:)"
        },
        {
          "description" : "Converts audio data supplied by a callback function, supporting non-interleaved and packetized formats.",
          "name" : "AudioConverterFillComplexBuffer(_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AudioConverterFillComplexBuffer(_:_:_:_:_:_:)"
        },
        {
          "description" : "Converts audio data from one linear PCM format to another, where both use the same sample rate.",
          "name" : "AudioConverterConvertComplexBuffer(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AudioConverterConvertComplexBuffer(_:_:_:_:)"
        }
      ],
      "title" : "Performing Conversions"
    }
  ],
  "source" : "appleJSON",
  "title" : "Encoding and decoding audio",
  "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/encoding-and-decoding-audio"
}