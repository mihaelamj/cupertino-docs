{
  "abstract" : "Add custom audio processing and MIDI instruments to your app by hosting Audio Unit (AU) plug-ins.",
  "codeExamples" : [
    {
      "code" : "\/\/ Make a component description matching any Audio Unit.\nlet description = AudioComponentDescription(componentType: 0,\n                                            componentSubType: 0,\n                                            componentManufacturer: 0,\n                                            componentFlags: 0,\n                                            componentFlagsMask: 0)\n\nlet components = AVAudioUnitComponentManager.shared().components(matching: description)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Instantiate the Audio Unit\nAVAudioUnit.instantiate(with: description) { avAudioUnit, error in\n   \/\/ Use Audio Unit or handle error\n}",
      "language" : "swift"
    },
    {
      "code" : "let options: AudioComponentInstantiationOptions = .loadInProcess\n\n\/\/ Instantiate the Audio Unit\nAVAudioUnit.instantiate(with: description, options: options) { avAudioUnit, error in\n   \/\/ Use Audio Unit or handle error\n}",
      "language" : "swift"
    },
    {
      "code" : "func loadAudioUnitViewController(completion: @escaping (ViewController?) -> Void) {\n    if let avAudioUnit = avAudioUnit {\n        \/\/ Call our AVAudioUnit extension to request the ViewController\n        \/\/ We will obtain a generic view if the plugin does not provide a custom view\n        avAudioUnit.requestViewController(completion: completion)\n    } else {\n        completion(nil)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private var currentViewConfigurationIndex = 1\n\n\/\/\/ View configurations supported by the host app\nprivate var viewConfigurations: [AUAudioUnitViewConfiguration] = {\n    let compact = AUAudioUnitViewConfiguration(width: 400, height: 100, hostHasController: false)\n    let expanded = AUAudioUnitViewConfiguration(width: 800, height: 500, hostHasController: false)\n    return [compact, expanded]\n}()",
      "language" : "swift"
    },
    {
      "code" : "let supportedConfigurations = audioUnit.supportedViewConfigurations(viewConfigurations)",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Toggles the current view mode (compact or expanded)\nfunc toggleViewMode() {\n    guard let audioUnit = audioUnit else { return }\n    currentViewConfigurationIndex = currentViewConfigurationIndex == 0 ? 1 : 0\n    audioUnit.select(viewConfigurations[currentViewConfigurationIndex])\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Gets the audio unit's factory presets.\npublic var factoryPresets: [Preset] {\n    guard let presets = audioUnit?.factoryPresets else { return [] }\n    return presets.map { Preset(preset: $0) }\n}",
      "language" : "swift"
    },
    {
      "code" : "var supportsUserPresets: Bool {\n    return audioUnit?.supportsUserPresets ?? false\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Gets the audio unit's user presets.\npublic var userPresets: [Preset] {\n    guard let presets = audioUnit?.userPresets else { return [] }\n    return presets.map { Preset(preset: $0) }.reversed()\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Add key-value observer to the userPresets property.\nobservation = audioUnit?.observe(\\.userPresets) { _, _ in\n    \/\/ User presets changed. Update the user interface.\n}",
      "language" : "swift"
    },
    {
      "code" : "let preset = AUAudioUnitPreset()\npreset.name = “A Custom Preset”\npreset.number = -1\n\n\/\/ Save the preset’s parameter state.\ndo {\n    try audioUnit.saveUserPreset(preset)\n} catch {\n    \/\/ Handle the error.\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Get or set the audio unit's current preset.\npublic var currentPreset: Preset? {\n    get {\n        guard let preset = audioUnit?.currentPreset else { return nil }\n        return Preset(preset: preset)\n    }\n    set {\n        audioUnit?.currentPreset = newValue?.audioUnitPreset\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "616540c9153f89dc5cceaad527d0ca0487ed9b598363bfde0970ea678b81a193",
  "crawledAt" : "2025-12-02T15:47:48Z",
  "id" : "73FA7276-0B38-4557-9C6B-6698975648D1",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Audio Toolbox",
  "overview" : "## Overview\n\nThis sample app shows you how to use AU plug-ins in your iOS and macOS apps. You find and instantiate plug-ins, incorporate their user interfaces into your app’s interface, and work with their presets.\n\nThe sample app has targets for iOS and macOS. Both versions have three primary classes.\n\n\n\n### Find Audio Units\n\nYou find Audio Units that are registered with the host system by creating an [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioComponentDescription] defining your search criteria. The sample app searches for component types, either audio effects ([doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/kAudioUnitType_Effect]) or MIDI instruments ([doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/kAudioUnitType_MusicDevice]). You can also pass values for the other fields of `AudioComponentDescription` or pass `0` as a wildcard matching all values. Get the shared instance of [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnitComponentManager] and call its [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnitComponentManager\/components(matching:)-96l2c] method to find the components matching your search criteria.\n\nThis method returns an array of [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnitComponent] objects matching the component description, or an empty array if it found no matches. You can access a component’s properties to determine its capabilities and find identifying values, such as its name and manufacturer, for display in your user interface.\n\n### Instantiate Audio Units\n\nWhen the user selects an Audio Unit in the user interface, your app needs to find the component and instantiate it.\n\niOS supports third-party plug-ins built using the latest Audio Unit standard (AUv3), which is based on the [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/ExtensibilityPG] model. Like all App Extensions in iOS, AUv3 plug-ins run *out-of-process*, which means they run in a dedicated process outside your app, and communication with the extension is done over interprocess communication (IPC).\n\nYou instantiate an AU by calling the [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnit\/instantiate(with:options:completionHandler:)] method, passing it the component description. This method asynchronously returns the instantiated `AVAudioUnit` or an `Error` if the process failed. You must avoid blocking your application’s main thread when instantiating an Audio Unit.\n\nIn macOS, AUv3 plug-ins also default to running out-of-process. Running an Audio Unit this way is safer and more secure, because a misbehaving plug-in can’t corrupt or crash your app. However, the interprocess communication required of this model adds some small but potentially significant overhead. This can be problematic in professional audio environments where multiple Audio Units are used, especially when rendering at small audio I\/O buffer sizes. To resolve this problem, AU authors can package their plug-ins to be run *in-process*. In macOS only, you can load an appropriately packaged plug-in in-process by passing that instantiation option to the `instantiate` method, as shown below.\n\n### Present an Audio Unit’s Custom View\n\nA plug-in can provide a custom user interface to control its parameters. You get the custom view by asking the plug-in for its view controller, which returns an instance of [doc:\/\/com.apple.documentation\/documentation\/CoreAudioKit\/AUViewController], or `nil` if it doesn’t provide a custom view. You add the view controller’s view to your user interface using the appropriate approach for your platform.\n\n### Select Alternative View Configurations\n\nAll AU plug-ins can provide a custom user interface, but AUv3 plug-ins may also provide alternative views. A host app can support multiple view configurations. For example, an iOS app may provide compact and expanded views and switch between them depending on the device size or orientation. You define one or more supported view configurations using the [doc:\/\/com.apple.documentation\/documentation\/CoreAudioKit\/AUAudioUnitViewConfiguration] class.\n\nThe host can ask the plug-in which, if any, custom view configurations it supports.\n\nWhen the host switches between its supported configurations, it can ask the Audio Unit to do the same. The sample app defines two configurations and attempts to toggle between them.\n\n### Load Factory Presets\n\nA plug-in author can optionally provide one or more presets that define specific configurations of the plug-in’s parameter values. You access an [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit] object’s presets through its [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/factoryPresets] property, which returns an array of [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnitPreset] instances, or an empty array if it defines none.\n\nThe sample app uses a simple wrapper type called `Preset` to pass to the user interface tier. The view controller uses these objects to build the app’s preset selection interface.\n\n### Manage User Presets\n\nA plug-in may also support *user presets*, which are user-configured parameter settings. You query the Audio Unit’s [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/supportsUserPresets] property to determine if it supports saving user presets.\n\nIf a plug-in supports user presets, you can get the currently saved presets by querying its [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/userPresets] property.\n\nTo be notified of changes to the Audio Unit’s user presets, you add a key-value observer to the `userPresets` property. By observing changes to this property, you’ll get callbacks as presets are added or deleted.\n\nTo create a new user preset, first create an instance of [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnitPreset] and give it a user-defined name and a negative `number` value (user presets require a negative value for this property). Then call the [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/saveUserPreset(_:)] method, which persists the parameter state so the Audio Unit can recall it later.\n\nIf the user decides to delete this or another user preset, you call [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/deleteUserPreset(_:)] to remove it.\n\n### Select Factory and User Presets\n\nTo select a factory or user preset, set it as the Audio Unit’s [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/currentPreset] property. This restores the plug-in’s parameter state to the values stored with the specified preset.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AudioToolbox\/incorporating-audio-effects-and-instruments\ncrawled: 2025-12-02T15:47:48Z\n---\n\n# Incorporating Audio Effects and Instruments\n\n**Sample Code**\n\nAdd custom audio processing and MIDI instruments to your app by hosting Audio Unit (AU) plug-ins.\n\n## Overview\n\nThis sample app shows you how to use AU plug-ins in your iOS and macOS apps. You find and instantiate plug-ins, incorporate their user interfaces into your app’s interface, and work with their presets.\n\nThe sample app has targets for iOS and macOS. Both versions have three primary classes.\n\n\n\n- `HostViewController` and its associated Storyboard provide the user interface.\n- `AudioUnitManager` manages the interactions with the effect and instrument plug-ins.\n- `SimplePlayEngine` uses [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioEngine] to play back audio samples and MIDI data.\n\n### Find Audio Units\n\nYou find Audio Units that are registered with the host system by creating an [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioComponentDescription] defining your search criteria. The sample app searches for component types, either audio effects ([doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/kAudioUnitType_Effect]) or MIDI instruments ([doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/kAudioUnitType_MusicDevice]). You can also pass values for the other fields of `AudioComponentDescription` or pass `0` as a wildcard matching all values. Get the shared instance of [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnitComponentManager] and call its [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnitComponentManager\/components(matching:)-96l2c] method to find the components matching your search criteria.\n\n```swift\n\/\/ Make a component description matching any Audio Unit.\nlet description = AudioComponentDescription(componentType: 0,\n                                            componentSubType: 0,\n                                            componentManufacturer: 0,\n                                            componentFlags: 0,\n                                            componentFlagsMask: 0)\n\nlet components = AVAudioUnitComponentManager.shared().components(matching: description)\n```\n\nThis method returns an array of [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnitComponent] objects matching the component description, or an empty array if it found no matches. You can access a component’s properties to determine its capabilities and find identifying values, such as its name and manufacturer, for display in your user interface.\n\n### Instantiate Audio Units\n\nWhen the user selects an Audio Unit in the user interface, your app needs to find the component and instantiate it.\n\niOS supports third-party plug-ins built using the latest Audio Unit standard (AUv3), which is based on the [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/ExtensibilityPG] model. Like all App Extensions in iOS, AUv3 plug-ins run *out-of-process*, which means they run in a dedicated process outside your app, and communication with the extension is done over interprocess communication (IPC).\n\nYou instantiate an AU by calling the [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioUnit\/instantiate(with:options:completionHandler:)] method, passing it the component description. This method asynchronously returns the instantiated `AVAudioUnit` or an `Error` if the process failed. You must avoid blocking your application’s main thread when instantiating an Audio Unit.\n\n```swift\n\/\/ Instantiate the Audio Unit\nAVAudioUnit.instantiate(with: description) { avAudioUnit, error in\n   \/\/ Use Audio Unit or handle error\n}\n```\n\nIn macOS, AUv3 plug-ins also default to running out-of-process. Running an Audio Unit this way is safer and more secure, because a misbehaving plug-in can’t corrupt or crash your app. However, the interprocess communication required of this model adds some small but potentially significant overhead. This can be problematic in professional audio environments where multiple Audio Units are used, especially when rendering at small audio I\/O buffer sizes. To resolve this problem, AU authors can package their plug-ins to be run *in-process*. In macOS only, you can load an appropriately packaged plug-in in-process by passing that instantiation option to the `instantiate` method, as shown below.\n\n```swift\nlet options: AudioComponentInstantiationOptions = .loadInProcess\n\n\/\/ Instantiate the Audio Unit\nAVAudioUnit.instantiate(with: description, options: options) { avAudioUnit, error in\n   \/\/ Use Audio Unit or handle error\n}\n```\n\n\n\n### Present an Audio Unit’s Custom View\n\nA plug-in can provide a custom user interface to control its parameters. You get the custom view by asking the plug-in for its view controller, which returns an instance of [doc:\/\/com.apple.documentation\/documentation\/CoreAudioKit\/AUViewController], or `nil` if it doesn’t provide a custom view. You add the view controller’s view to your user interface using the appropriate approach for your platform.\n\n```swift\nfunc loadAudioUnitViewController(completion: @escaping (ViewController?) -> Void) {\n    if let avAudioUnit = avAudioUnit {\n        \/\/ Call our AVAudioUnit extension to request the ViewController\n        \/\/ We will obtain a generic view if the plugin does not provide a custom view\n        avAudioUnit.requestViewController(completion: completion)\n    } else {\n        completion(nil)\n    }\n}\n```\n\n### Select Alternative View Configurations\n\nAll AU plug-ins can provide a custom user interface, but AUv3 plug-ins may also provide alternative views. A host app can support multiple view configurations. For example, an iOS app may provide compact and expanded views and switch between them depending on the device size or orientation. You define one or more supported view configurations using the [doc:\/\/com.apple.documentation\/documentation\/CoreAudioKit\/AUAudioUnitViewConfiguration] class.\n\n```swift\nprivate var currentViewConfigurationIndex = 1\n\n\/\/\/ View configurations supported by the host app\nprivate var viewConfigurations: [AUAudioUnitViewConfiguration] = {\n    let compact = AUAudioUnitViewConfiguration(width: 400, height: 100, hostHasController: false)\n    let expanded = AUAudioUnitViewConfiguration(width: 800, height: 500, hostHasController: false)\n    return [compact, expanded]\n}()\n```\n\n\n\nThe host can ask the plug-in which, if any, custom view configurations it supports.\n\n```swift\nlet supportedConfigurations = audioUnit.supportedViewConfigurations(viewConfigurations)\n```\n\nWhen the host switches between its supported configurations, it can ask the Audio Unit to do the same. The sample app defines two configurations and attempts to toggle between them.\n\n```swift\n\/\/\/ Toggles the current view mode (compact or expanded)\nfunc toggleViewMode() {\n    guard let audioUnit = audioUnit else { return }\n    currentViewConfigurationIndex = currentViewConfigurationIndex == 0 ? 1 : 0\n    audioUnit.select(viewConfigurations[currentViewConfigurationIndex])\n}\n```\n\n### Load Factory Presets\n\nA plug-in author can optionally provide one or more presets that define specific configurations of the plug-in’s parameter values. You access an [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit] object’s presets through its [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/factoryPresets] property, which returns an array of [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnitPreset] instances, or an empty array if it defines none.\n\n```swift\n\/\/\/ Gets the audio unit's factory presets.\npublic var factoryPresets: [Preset] {\n    guard let presets = audioUnit?.factoryPresets else { return [] }\n    return presets.map { Preset(preset: $0) }\n}\n```\n\nThe sample app uses a simple wrapper type called `Preset` to pass to the user interface tier. The view controller uses these objects to build the app’s preset selection interface.\n\n### Manage User Presets\n\nA plug-in may also support *user presets*, which are user-configured parameter settings. You query the Audio Unit’s [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/supportsUserPresets] property to determine if it supports saving user presets.\n\n```swift\nvar supportsUserPresets: Bool {\n    return audioUnit?.supportsUserPresets ?? false\n}\n```\n\nIf a plug-in supports user presets, you can get the currently saved presets by querying its [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/userPresets] property.\n\n```swift\n\/\/\/ Gets the audio unit's user presets.\npublic var userPresets: [Preset] {\n    guard let presets = audioUnit?.userPresets else { return [] }\n    return presets.map { Preset(preset: $0) }.reversed()\n}\n```\n\nTo be notified of changes to the Audio Unit’s user presets, you add a key-value observer to the `userPresets` property. By observing changes to this property, you’ll get callbacks as presets are added or deleted.\n\n```swift\n\/\/ Add key-value observer to the userPresets property.\nobservation = audioUnit?.observe(\\.userPresets) { _, _ in\n    \/\/ User presets changed. Update the user interface.\n}\n```\n\nTo create a new user preset, first create an instance of [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnitPreset] and give it a user-defined name and a negative `number` value (user presets require a negative value for this property). Then call the [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/saveUserPreset(_:)] method, which persists the parameter state so the Audio Unit can recall it later.\n\n```swift\nlet preset = AUAudioUnitPreset()\npreset.name = “A Custom Preset”\npreset.number = -1\n\n\/\/ Save the preset’s parameter state.\ndo {\n    try audioUnit.saveUserPreset(preset)\n} catch {\n    \/\/ Handle the error.\n}\n```\n\nIf the user decides to delete this or another user preset, you call [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/deleteUserPreset(_:)] to remove it.\n\n### Select Factory and User Presets\n\nTo select a factory or user preset, set it as the Audio Unit’s [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AUAudioUnit\/currentPreset] property. This restores the plug-in’s parameter state to the values stored with the specified preset.\n\n```swift\n\/\/\/ Get or set the audio unit's current preset.\npublic var currentPreset: Preset? {\n    get {\n        guard let preset = audioUnit?.currentPreset else { return nil }\n        return Preset(preset: preset)\n    }\n    set {\n        audioUnit?.currentPreset = newValue?.audioUnitPreset\n    }\n}\n```\n\n## Audio Units\n\n- **Creating an audio unit extension**: Build an extension by using an Xcode template.\n- **Creating custom audio effects**: Add custom audio-effect processing to apps like Logic Pro X and GarageBand by creating Audio Unit (AU) plug-ins.\n- **Debugging Out-of-Process Audio Units on Apple Silicon**: Connect to out-of-process audio units using the Xcode debugger.\n- **AUAudioUnit**: A class that defines a host’s interface to an audio unit.\n- **AUAudioUnitBus**: A class that defines an input or output connection point on an audio unit.\n- **AUAudioUnitBusArray**: A class that defines a container for an audio unit’s input or output busses.\n- **AUAudioUnitPreset**: A class that describes an interface for custom parameter settings provided by the audio unit developer.\n- **AUAudioUnitV2Bridge**: A class that wraps a version 2 audio unit as version 3 audio unit.\n- **AudioUnitExtensionCopyComponentList(_:)**: Returns the component registrations for a given audio unit extension.\n- **AudioUnitExtensionSetComponentList(_:_:)**: Allows the implementor of an audio unit extension to dynamically modify the list of component registrations for the extension.\n- **AUAudioUnitFactory**: An object that creates a version 3 audio unit.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Build an extension by using an Xcode template.",
          "name" : "Creating an audio unit extension",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFAudio\/creating-an-audio-unit-extension"
        },
        {
          "description" : "Add custom audio-effect processing to apps like Logic Pro X and GarageBand by creating Audio Unit (AU) plug-ins.",
          "name" : "Creating custom audio effects",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFAudio\/creating-custom-audio-effects"
        },
        {
          "description" : "Connect to out-of-process audio units using the Xcode debugger.",
          "name" : "Debugging Out-of-Process Audio Units on Apple Silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/debugging-out-of-process-audio-units-on-apple-silicon"
        },
        {
          "description" : "A class that defines a host’s interface to an audio unit.",
          "name" : "AUAudioUnit",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AUAudioUnit"
        },
        {
          "description" : "A class that defines an input or output connection point on an audio unit.",
          "name" : "AUAudioUnitBus",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AUAudioUnitBus"
        },
        {
          "description" : "A class that defines a container for an audio unit’s input or output busses.",
          "name" : "AUAudioUnitBusArray",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AUAudioUnitBusArray"
        },
        {
          "description" : "A class that describes an interface for custom parameter settings provided by the audio unit developer.",
          "name" : "AUAudioUnitPreset",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AUAudioUnitPreset"
        },
        {
          "description" : "A class that wraps a version 2 audio unit as version 3 audio unit.",
          "name" : "AUAudioUnitV2Bridge",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AUAudioUnitV2Bridge"
        },
        {
          "description" : "Returns the component registrations for a given audio unit extension.",
          "name" : "AudioUnitExtensionCopyComponentList(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AudioUnitExtensionCopyComponentList(_:)"
        },
        {
          "description" : "Allows the implementor of an audio unit extension to dynamically modify the list of component registrations for the extension.",
          "name" : "AudioUnitExtensionSetComponentList(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AudioUnitExtensionSetComponentList(_:_:)"
        },
        {
          "description" : "An object that creates a version 3 audio unit.",
          "name" : "AUAudioUnitFactory",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/AUAudioUnitFactory"
        }
      ],
      "title" : "Audio Units"
    }
  ],
  "source" : "appleJSON",
  "title" : "Incorporating Audio Effects and Instruments",
  "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/incorporating-audio-effects-and-instruments"
}