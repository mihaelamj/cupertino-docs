{
  "abstract" : "Optimize system performance by adding real-time audio threads that run asynchronously to the I\/O thread to custom audio workgroups.",
  "codeExamples" : [
    {
      "code" : "#include <mach\/mach_time.h>\n#import <AudioToolbox\/AudioToolbox.h>\n\n\/\/ This workgroup attribute isn't currently used. Set it to NULL.\nos_workgroup_attr_t _Nullable attr = nullptr;\n\n\/\/ One nanosecond in seconds.\nconstexpr static double kOneNanosecond = 1.0e9;\n\n\/\/ The I\/O interval time in seconds.\nconstexpr static double kIOIntervalTime = 0.020;\n\n\/\/ The clock identifier that specifies interval timestamps.\nos_clockid_t clockId = OS_CLOCK_MACH_ABSOLUTE_TIME;\n\n\/\/ Create a workgroup interval.\nos_workgroup_interval_t _Nullable workgroup =\n    AudioWorkIntervalCreate(\"My Work Interval\", clockId, attr);\n\nvoid realtimeThreadFunction() {\n\n    \/\/ Join this thread to the workgroup.\n    if (!joinThisThreadToWorkgroup(workgroup)) {\n        \/\/ Early return, unable to add this thread to the workgroup\n        return;\n    }\n\n    \/\/ Get the mach time info.\n    struct mach_timebase_info timeBaseInfo;\n    mach_timebase_info(&timeBaseInfo);\n\n    \/\/ The frequency of the clock is: (timeBaseInfo.denom \/ timeBaseInfo.numer) * kOneNanosecond\n    const auto nanoSecFrequency = static_cast<double>(timeBaseInfo.denom) \/ static_cast<double>(timeBaseInfo.numer);\n    const auto frequency = nanoSecFrequency * kOneNanosecond;\n\n    \/\/ Convert the interval time in seconds to mach time length.\n    const auto intervalMachLength = static_cast<int64_t>(kIOIntervalTime * frequency);\n    while (true) {\n        \/\/ Get the current host time.\n        const auto currentTime = mach_absolute_time();\n        const auto deadline = currentTime + intervalMachLength;\n\n        \/\/ Call os_workgroup_interval_start each time the thread begins a work cycle\n        int result = os_workgroup_interval_start(workgroup, currentTime, deadline, nullptr);\n\n        if (result != 0) {\n            \/\/ Something went wrong.\n        }\n\n        \/\/ Perform some custom DSP processing.\n        customAudioDSP();\n\n        \/\/ Call os_workgroup_interval_finish on completion of each a work cycle.\n        result = os_workgroup_interval_finish(workgroup, nullptr);\n    }\n}\n\n\/\/ Return true if the method joined the thread to the workgroup.\nbool joinThisThreadToWorkgroup(os_workgroup_t workgroup) {\n    \/\/ Join this thread to the workgroup.\n    const int result = os_workgroup_join(workgroup, &joinToken);\n    if (result == 0) {\n        \/\/ Success.\n    } else if (result == EALREADY) {\n        \/\/ The thread is already part of a workgroup that can't be\n        \/\/ nested in the the specified workgroup.\n        return false;\n    } else if (result == EINVAL) {\n        \/\/ The workgroup has been canceled.\n        return false;\n    }\n    return true;\n}",
      "language" : "objc"
    },
    {
      "code" : "#import <AudioToolbox\/AudioToolbox.h>\n \n#import <AudioToolbox\/AudioToolbox.h>\n\n\/\/ The workgroup interval created in the previous example.\nos_workgroup_interval_t workgroup = ...\n\nvoid realtimeThreadFunction(os_workgroup_t workgroup) {\n\n    \/\/ Join this thread to the workgroup.\n    if (!joinThisThreadToWorkgroup(workgroup)) {\n        \/\/ Early return, unable to add this thread to the workgroup\n        return;\n    }\n\n    \/\/ Work cycle.\n    while (threadShouldRun) {\n        \/\/ Typically, wait on a semaphore.\n        waitForWork();\n        \/\/ The controlling thread signaled this thread to stop.\n        if (threadShouldRun) {\n            performCustomAudioDSPWorkUnit();\n            \/\/ Typically, signal a semaphore.\n            signalWorkComplete();\n        }\n    }\n\n    \/\/ Before exiting the thread, leave the workgroup.\n    os_workgroup_leave(workgroup, &joinToken);\n}",
      "language" : "objc"
    }
  ],
  "contentHash" : "d76f2b50f72bc4d1dcf0c014e77d29a34e1808dde46254ac0ae0c64e3a7dfdb0",
  "crawledAt" : "2025-12-06T07:39:18Z",
  "id" : "A9EC6CD9-32A8-4904-BEC9-909E773DBAC9",
  "kind" : "article",
  "language" : "swift",
  "module" : "Audio Toolbox",
  "overview" : "## Overview\n\nIf your app creates auxiliary real-time threads that run asynchronously to the audio server’s I\/O thread, add them to a custom audio workgroup. Doing so informs the system of these threads and their deadlines, which helps it optimize performance.\n\n### Create Workgroups\n\nIf your auxiliary real-time threads run asynchronously to the I\/O thread, you don’t add them to the audio device workgroup, but instead create a new audio workgroup. For each thread that has a unique work interval, create a new audio workgroup for it by calling [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioWorkIntervalCreate]. Your workgroup may contain multiple threads, but only one is the primary thread and is responsible for controlling the others. In this thread, call [doc:\/\/com.apple.documentation\/documentation\/os\/os_workgroup_interval_start] in each work cycle. The start time that you pass to this function can be the present, or a time in the past if you know exactly when the system scheduled your work cycle to begin. The function’s deadline argument has to be a timestamp value greater than the start time.\n\nIf your app has other real-time threads that render to this audio workgroup’s deadline, you can join them to the audio workgroup as shown in the example below.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AudioToolbox\/adding-asynchronous-real-time-threads-to-audio-workgroups\ncrawled: 2025-12-06T07:39:18Z\n---\n\n# Adding Asynchronous Real-Time Threads to Audio Workgroups\n\n**Article**\n\nOptimize system performance by adding real-time audio threads that run asynchronously to the I\/O thread to custom audio workgroups.\n\n## Overview\n\nIf your app creates auxiliary real-time threads that run asynchronously to the audio server’s I\/O thread, add them to a custom audio workgroup. Doing so informs the system of these threads and their deadlines, which helps it optimize performance.\n\n### Create Workgroups\n\nIf your auxiliary real-time threads run asynchronously to the I\/O thread, you don’t add them to the audio device workgroup, but instead create a new audio workgroup. For each thread that has a unique work interval, create a new audio workgroup for it by calling [doc:\/\/com.apple.audiotoolbox\/documentation\/AudioToolbox\/AudioWorkIntervalCreate]. Your workgroup may contain multiple threads, but only one is the primary thread and is responsible for controlling the others. In this thread, call [doc:\/\/com.apple.documentation\/documentation\/os\/os_workgroup_interval_start] in each work cycle. The start time that you pass to this function can be the present, or a time in the past if you know exactly when the system scheduled your work cycle to begin. The function’s deadline argument has to be a timestamp value greater than the start time.\n\n```objc\n#include <mach\/mach_time.h>\n#import <AudioToolbox\/AudioToolbox.h>\n\n\/\/ This workgroup attribute isn't currently used. Set it to NULL.\nos_workgroup_attr_t _Nullable attr = nullptr;\n\n\/\/ One nanosecond in seconds.\nconstexpr static double kOneNanosecond = 1.0e9;\n\n\/\/ The I\/O interval time in seconds.\nconstexpr static double kIOIntervalTime = 0.020;\n\n\/\/ The clock identifier that specifies interval timestamps.\nos_clockid_t clockId = OS_CLOCK_MACH_ABSOLUTE_TIME;\n\n\/\/ Create a workgroup interval.\nos_workgroup_interval_t _Nullable workgroup =\n    AudioWorkIntervalCreate(\"My Work Interval\", clockId, attr);\n\nvoid realtimeThreadFunction() {\n\n    \/\/ Join this thread to the workgroup.\n    if (!joinThisThreadToWorkgroup(workgroup)) {\n        \/\/ Early return, unable to add this thread to the workgroup\n        return;\n    }\n\n    \/\/ Get the mach time info.\n    struct mach_timebase_info timeBaseInfo;\n    mach_timebase_info(&timeBaseInfo);\n\n    \/\/ The frequency of the clock is: (timeBaseInfo.denom \/ timeBaseInfo.numer) * kOneNanosecond\n    const auto nanoSecFrequency = static_cast<double>(timeBaseInfo.denom) \/ static_cast<double>(timeBaseInfo.numer);\n    const auto frequency = nanoSecFrequency * kOneNanosecond;\n\n    \/\/ Convert the interval time in seconds to mach time length.\n    const auto intervalMachLength = static_cast<int64_t>(kIOIntervalTime * frequency);\n    while (true) {\n        \/\/ Get the current host time.\n        const auto currentTime = mach_absolute_time();\n        const auto deadline = currentTime + intervalMachLength;\n\n        \/\/ Call os_workgroup_interval_start each time the thread begins a work cycle\n        int result = os_workgroup_interval_start(workgroup, currentTime, deadline, nullptr);\n\n        if (result != 0) {\n            \/\/ Something went wrong.\n        }\n\n        \/\/ Perform some custom DSP processing.\n        customAudioDSP();\n\n        \/\/ Call os_workgroup_interval_finish on completion of each a work cycle.\n        result = os_workgroup_interval_finish(workgroup, nullptr);\n    }\n}\n\n\/\/ Return true if the method joined the thread to the workgroup.\nbool joinThisThreadToWorkgroup(os_workgroup_t workgroup) {\n    \/\/ Join this thread to the workgroup.\n    const int result = os_workgroup_join(workgroup, &joinToken);\n    if (result == 0) {\n        \/\/ Success.\n    } else if (result == EALREADY) {\n        \/\/ The thread is already part of a workgroup that can't be\n        \/\/ nested in the the specified workgroup.\n        return false;\n    } else if (result == EINVAL) {\n        \/\/ The workgroup has been canceled.\n        return false;\n    }\n    return true;\n}\n```\n\nIf your app has other real-time threads that render to this audio workgroup’s deadline, you can join them to the audio workgroup as shown in the example below.\n\n```objc\n#import <AudioToolbox\/AudioToolbox.h>\n \n#import <AudioToolbox\/AudioToolbox.h>\n\n\/\/ The workgroup interval created in the previous example.\nos_workgroup_interval_t workgroup = ...\n\nvoid realtimeThreadFunction(os_workgroup_t workgroup) {\n\n    \/\/ Join this thread to the workgroup.\n    if (!joinThisThreadToWorkgroup(workgroup)) {\n        \/\/ Early return, unable to add this thread to the workgroup\n        return;\n    }\n\n    \/\/ Work cycle.\n    while (threadShouldRun) {\n        \/\/ Typically, wait on a semaphore.\n        waitForWork();\n        \/\/ The controlling thread signaled this thread to stop.\n        if (threadShouldRun) {\n            performCustomAudioDSPWorkUnit();\n            \/\/ Typically, signal a semaphore.\n            signalWorkComplete();\n        }\n    }\n\n    \/\/ Before exiting the thread, leave the workgroup.\n    os_workgroup_leave(workgroup, &joinToken);\n}\n```\n\n## Essentials\n\n- **Understanding Audio Workgroups**: Learn how to optimize real-time rendering performance with the Audio Workgroups API.\n- **Adding Parallel Real-Time Threads to Audio Workgroups**: Optimize the performance of real-time audio threads that run in sync with the I\/O thread by adding them to the audio device workgroup.\n- **Adding Audio Unit Auxiliary Real-Time Threads to Audio Workgroups**: If your Audio Unit plug-in creates auxiliary real-time rendering threads, add them to the host app’s audio workgroup so the system can schedule them appropriately.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn how to optimize real-time rendering performance with the Audio Workgroups API.",
          "name" : "Understanding Audio Workgroups",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/understanding-audio-workgroups"
        },
        {
          "description" : "Optimize the performance of real-time audio threads that run in sync with the I\/O thread by adding them to the audio device workgroup.",
          "name" : "Adding Parallel Real-Time Threads to Audio Workgroups",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/adding-parallel-real-time-threads-to-audio-workgroups"
        },
        {
          "description" : "If your Audio Unit plug-in creates auxiliary real-time rendering threads, add them to the host app’s audio workgroup so the system can schedule them appropriately.",
          "name" : "Adding Audio Unit Auxiliary Real-Time Threads to Audio Workgroups",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/adding-audio-unit-auxiliary-real-time-threads-to-audio-workgroups"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding Asynchronous Real-Time Threads to Audio Workgroups",
  "url" : "https:\/\/developer.apple.com\/documentation\/AudioToolbox\/adding-asynchronous-real-time-threads-to-audio-workgroups"
}