{
  "abstract" : "Inform people when they may have been exposed to COVID-19.",
  "codeExamples" : [
    {
      "code" : "    manager.activate { _ in\n        \/\/ Ensure Exposure Notifications is enabled if the app is authorized. The app\n        \/\/ could get into a state where it is authorized, but Exposure Notifications\n        \/\/ is not enabled, if the user initially denied Exposure Notifications\n        \/\/ during onboarding, but then flipped on the \"COVID-19 Exposure Notifications\" switch\n        \/\/ in Settings.\n        if !self.manager.exposureNotificationEnabled {\n            self.manager.setExposureNotificationEnabled(true) { (error) in\n                if let error = error {\n                    print(\"Error attempting to enable on launch: \\(error.localizedDescription)\")\n                }\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class LocalStore {\n    \n    static let shared = LocalStore()\n    \n    @Persisted(userDefaultsKey: \"isOnboarded\", notificationName: .init(\"LocalStoreIsOnboardedDidChange\"), defaultValue: false)\n    var isOnboarded: Bool\n    \n    @Persisted(userDefaultsKey: \"nextDiagnosisKeyFileIndex\", notificationName: .init(\"LocalStoreNextDiagnosisKeyFileIndexDidChange\"), defaultValue: 0)\n    var nextDiagnosisKeyFileIndex: Int\n    \n    @Persisted(userDefaultsKey: \"exposures\", notificationName: .init(\"LocalStoreExposuresDidChange\"), defaultValue: [])\n    var exposures: [Exposure]\n    \n    @Persisted(userDefaultsKey: \"dateLastPerformedExposureDetection\",\n               notificationName: .init(\"LocalStoreDateLastPerformedExposureDetectionDidChange\"), defaultValue: nil)\n    var dateLastPerformedExposureDetection: Date?\n    \n    @Persisted(userDefaultsKey: \"exposureDetectionErrorLocalizedDescription\", notificationName:\n        .init(\"LocalStoreExposureDetectionErrorLocalizedDescriptionDidChange\"), defaultValue: nil)\n    var exposureDetectionErrorLocalizedDescription: String?\n    \n    @Persisted(userDefaultsKey: \"testResults\", notificationName: .init(\"LocalStoreTestResultsDidChange\"), defaultValue: [:])\n    var testResults: [UUID: TestResult]\n}",
      "language" : "swift"
    },
    {
      "code" : "struct TestResult: Codable {\n    var id: UUID                \/\/ A unique identifier for this test result\n    var isAdded: Bool           \/\/ Whether the user completed the add positive diagnosis flow for this test result\n    var dateAdministered: Date  \/\/ The date the test was administered\n    var isShared: Bool          \/\/ Whether diagnosis keys were shared with the Health Authority for the purpose of notifying others\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Replace this class with your own class that communicates with your server.\nclass Server {\n    \n    static let shared = Server()\n    \n    \/\/ For testing purposes, this object stores all of the TEKs it receives locally on device\n    \/\/ In a real implementation, these would be stored on a remote server\n    @Persisted(userDefaultsKey: \"diagnosisKeys\", notificationName: .init(\"ServerDiagnosisKeysDidChange\"), defaultValue: [])\n    var diagnosisKeys: [CodableDiagnosisKey]",
      "language" : "swift"
    },
    {
      "code" : "func getAndPostDiagnosisKeys(testResult: TestResult, completion: @escaping (Error?) -> Void) {\n    manager.getDiagnosisKeys { temporaryExposureKeys, error in\n        if let error = error {\n            completion(error)\n        } else {\n            guard let temporaryExposureKeys = temporaryExposureKeys else {\n                print(\"No exposure keys, aborting key share\")\n                return\n            }\n            \n            \/\/ In this sample app, transmissionRiskLevel isn't set for any of the diagnosis keys. However, it is at this point that an app could\n            \/\/ use information accumulated in testResult to determine a transmissionRiskLevel for each diagnosis key.\n            Server.shared.postDiagnosisKeys(temporaryExposureKeys) { error in\n                completion(error)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func postDiagnosisKeys(_ diagnosisKeys: [ENTemporaryExposureKey], completion: (Error?) -> Void) {\n    \n    \/\/ Convert keys to something that can be encoded to JSON and upload them.\n    let codableDiagnosisKeys = diagnosisKeys.compactMap { diagnosisKey -> CodableDiagnosisKey? in\n        return CodableDiagnosisKey(keyData: diagnosisKey.keyData,\n                                   rollingPeriod: diagnosisKey.rollingPeriod,\n                                   rollingStartNumber: diagnosisKey.rollingStartNumber,\n                                   transmissionRiskLevel: diagnosisKey.transmissionRiskLevel)\n    }\n    \n    \/\/ In a real implementation, these keys would be uploaded with URLSession instead of being saved here.\n    \/\/ Your server needs to handle de-duplicating keys.\n    for codableDiagnosisKey in codableDiagnosisKeys where !self.diagnosisKeys.contains(codableDiagnosisKey) {\n        self.diagnosisKeys.append(codableDiagnosisKey)\n    }\n    completion(nil)\n}",
      "language" : "swift"
    },
    {
      "code" : "@available(iOS 14.4, *)\nfunc preAuthorizeKeys(\n    completion: @escaping (Error?) -> Void) {\n    manager.preAuthorizeDiagnosisKeys { (error) in\n        if let error = error {\n            print(\"Error pre-authorizing keys: \\(error)\")\n            completion(error)\n            return\n        }\n        print(\"Successfully pre-authorized keys\")\n        completion(nil)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ This handler receives preauthorized keys. Once the handler is called,\n\/\/ the preauthorization expires, so the handler should only be called\n\/\/ once per preauthorization request. If the user doesn't authorize\n\/\/ release, this handler isn't called.\nmanager.diagnosisKeysAvailableHandler = { (keys) in\n    Server.shared.postDiagnosisKeys(keys) { (error) in\n        if let error = error {\n            print(\"Error posting pre-authorized diagnosis keys: \\(error)\")\n        }\n        completion(error)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ This call requests preauthorized keys. The request fails if the\n\/\/ user doesn't authorize release or if more than five days pass after\n\/\/ authorization. If requestPreAuthorizedDiagnosisKeys(:) has already\n\/\/ been called since the last time the user preauthorized, the call\n\/\/ doesn't fail but also doesn't return any keys.\nmanager.requestPreAuthorizedDiagnosisKeys { (error) in\n    if let error = error {\n        print(\"Error retrieving pre-authorized diganosis keys: \\(error)\")\n        completion(error)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func ENManagerIsAvailable() -> Bool {\n    return NSClassFromString(\"ENManager\") != nil\n}\n\nenum SupportedENAPIVersion {\n    case version2\n    case version1\n    case unsupported\n}\n\nfunc getSupportedExposureNotificationsVersion() -> SupportedENAPIVersion {\n    if #available(iOS 13.7, *) {\n        return .version2\n    } else if #available(iOS 13.5, *) {\n        return .version1\n    } else if ENManagerIsAvailable() {\n        return .version2\n    } else {\n        return .unsupported\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Handles getting exposures using the version 2 API in iOS 13.7+ and\n\/\/ in iOS 12.5\nfunc getExposuresV2(_ summary: ENExposureDetectionSummary) {\n    self.manager.getExposureWindows(summary: summary) { windows, error in\n        if let error = error {\n            finish(.failure(error))\n            return\n        }\n        let allWindows = windows!.map { window in\n            Exposure(date: window.date)\n        }\n        finish(.success((allWindows, nextDiagnosisKeyFileIndex + localURLs.count)))\n    }\n}\n\n\/\/ Handles getting exposures using the version 1 API used in iOS 13.5 and iOS 13.6\n@available(iOS 13.5, *)\nfunc getExposuresV1(_ summary: ENExposureDetectionSummary) {\n    let userExplanation = NSLocalizedString(\"USER_NOTIFICATION_EXPLANATION\", comment: \"User notification\")\n    ExposureManager.shared.manager.getExposureInfo(summary: summary,\n                                                   userExplanation: userExplanation) { exposures, error in\n        if let error = error {\n            finish(.failure(error))\n            return\n        }\n        let newExposures = exposures!.map { exposure in\n            Exposure(date: exposure.date)\n        }\n        finish(.success((newExposures, nextDiagnosisKeyFileIndex + localURLs.count)))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func scheduleBackgroundTaskIfNeeded() {\n    if #available(iOS 13.5, *) {\n        guard ENManager.authorizationStatus == .authorized else { return }\n        let taskRequest = BGProcessingTaskRequest(identifier: backgroundTaskIdentifier)\n        taskRequest.requiresNetworkConnectivity = true\n        do {\n            try BGTaskScheduler.shared.submit(taskRequest)\n        } catch {\n            print(\"Unable to schedule background task: \\(error)\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func createBackgroundTaskIfNeeded() {\n    if #available(iOS 13.0, *) {\n        BGTaskScheduler.shared.register(forTaskWithIdentifier: backgroundTaskIdentifier, using: .main) { task in\n            \n            \/\/ Notify the user if Bluetooth is off\n            ExposureManager.shared.showBluetoothOffUserNotificationIfNeeded()\n            \n            \/\/ Perform the exposure detection\n            let progress = ExposureManager.shared.detectExposures { success in\n                task.setTaskCompleted(success: success)\n            }\n            \n            \/\/ Handle running out of time\n            task.expirationHandler = {\n                progress.cancel()\n                LocalStore.shared.exposureDetectionErrorLocalizedDescription = NSLocalizedString(\"BACKGROUND_TIMEOUT\", comment: \"Error\")\n            }\n            \n            \/\/ Schedule the next background task\n            scheduleBackgroundTaskIfNeeded()\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "if #available(iOS 13.5, *) {\n    \/\/ In iOS 13.5 and later, the Background Tasks framework is available,\n    \/\/ so create and schedule a background task for downloading keys and\n    \/\/ detecting exposures\n    createBackgroundTaskIfNeeded()\n    scheduleBackgroundTaskIfNeeded()\n} else if ENManagerIsAvailable() {\n    \/\/ If `ENManager` exists, and the iOS version is earlier than 13.5,\n    \/\/ the app is running on iOS 12.5, where the Background Tasks\n    \/\/ framework is unavailable. Specify an EN activity handler here, which\n    \/\/ allows the app to receive background time for downloading keys\n    \/\/ and looking for exposures when background tasks aren't available.\n    \/\/ Apps should should call this method before calling activate().\n    manager.setLaunchActivityHandler { (activityFlags) in\n        \/\/ ENManager gives apps that register an activity handler\n        \/\/ in iOS 12.5 up to 3.5 minutes of background time at\n        \/\/ least once per day. In iOS 13 and later, registering an\n        \/\/ activity handler does nothing.\n        if activityFlags.contains(.periodicRun) {\n            print(\"Periodic activity callback called (iOS 12.5)\")\n            _ = ExposureManager.shared.detectExposures()\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let nextDiagnosisKeyFileIndex = LocalStore.shared.nextDiagnosisKeyFileIndex\n\nServer.shared.getDiagnosisKeyFileURLs(startingAt: nextDiagnosisKeyFileIndex) { result in\n    \n    let dispatchGroup = DispatchGroup()\n    var localURLResults = [Result<[URL], Error>]()\n    \n    switch result {\n    case let .success(remoteURLs):\n        for remoteURL in remoteURLs {\n            dispatchGroup.enter()\n            Server.shared.downloadDiagnosisKeyFile(at: remoteURL) { result in\n                localURLResults.append(result)\n                dispatchGroup.leave()\n            }\n        }\n        \n    case let .failure(error):\n        finish(.failure(error))\n    }",
      "language" : "swift"
    },
    {
      "code" : "dispatchGroup.notify(queue: .main) {\n    for result in localURLResults {\n        switch result {\n        case let .success(urls):\n            localURLs.append(contentsOf: urls)\n        case let .failure(error):\n            finish(.failure(error))\n            return\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "func getExposureConfiguration(completion: (Result<ENExposureConfiguration, Error>) -> Void) {\n    \n    let dataFromServer = \"\"\"\n    {\n    \"immediateDurationWeight\":100,\n    \"nearDurationWeight\":100,\n    \"mediumDurationWeight\":100,\n    \"otherDurationWeight\":100,\n    \"infectiousnessForDaysSinceOnsetOfSymptoms\":{\n        \"unknown\":1,\n        \"-14\":1,\n        \"-13\":1,\n        \"-12\":1,\n        \"-11\":1,\n        \"-10\":1,\n        \"-9\":1,\n        \"-8\":1,\n        \"-7\":1,\n        \"-6\":1,\n        \"-5\":1,\n        \"-4\":1,\n        \"-3\":1,\n        \"-2\":1,\n        \"-1\":1,\n        \"0\":1,\n        \"1\":1,\n        \"2\":1,\n        \"3\":1,\n        \"4\":1,\n        \"5\":1,\n        \"6\":1,\n        \"7\":1,\n        \"8\":1,\n        \"9\":1,\n        \"10\":1,\n        \"11\":1,\n        \"12\":1,\n        \"13\":1,\n        \"14\":1\n    },\n    \"infectiousnessStandardWeight\":100,\n    \"infectiousnessHighWeight\":100,\n    \"reportTypeConfirmedTestWeight\":100,\n    \"reportTypeConfirmedClinicalDiagnosisWeight\":100,\n    \"reportTypeSelfReportedWeight\":100,\n    \"reportTypeRecursiveWeight\":100,\n    \"reportTypeNoneMap\":1,\n    \"minimumRiskScore\":0,\n    \"attenuationDurationThresholds\":[50, 70],\n    \"attenuationLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8],\n    \"daysSinceLastExposureLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8],\n    \"durationLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8],\n    \"transmissionRiskLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8]\n    }\n    \"\"\".data(using: .utf8)!\n    \n    do {\n        let codableExposureConfiguration = try JSONDecoder().decode(CodableExposureConfiguration.self, from: dataFromServer)\n        let exposureConfiguration = ENExposureConfiguration()\n        if ENManagerIsAvailable() {\n            exposureConfiguration.immediateDurationWeight = codableExposureConfiguration.immediateDurationWeight\n            exposureConfiguration.nearDurationWeight = codableExposureConfiguration.nearDurationWeight\n            exposureConfiguration.mediumDurationWeight = codableExposureConfiguration.mediumDurationWeight\n            exposureConfiguration.otherDurationWeight = codableExposureConfiguration.otherDurationWeight\n            var infectiousnessForDaysSinceOnsetOfSymptoms = [Int: Int]()\n            for (stringDay, infectiousness) in codableExposureConfiguration.infectiousnessForDaysSinceOnsetOfSymptoms {\n                if stringDay == \"unknown\" {\n                    if #available(iOS 14.0, *) {\n                        infectiousnessForDaysSinceOnsetOfSymptoms[ENDaysSinceOnsetOfSymptomsUnknown] = infectiousness\n                    } else {\n                        \/\/ ENDaysSinceOnsetOfSymptomsUnknown is not available\n                        \/\/ in earlier versions of iOS; use an equivalent value\n                        infectiousnessForDaysSinceOnsetOfSymptoms[NSIntegerMax] = infectiousness\n                    }\n                } else if let day = Int(stringDay) {\n                    infectiousnessForDaysSinceOnsetOfSymptoms[day] = infectiousness\n                }\n            }\n            exposureConfiguration.infectiousnessForDaysSinceOnsetOfSymptoms = infectiousnessForDaysSinceOnsetOfSymptoms as [NSNumber: NSNumber]\n            exposureConfiguration.infectiousnessStandardWeight = codableExposureConfiguration.infectiousnessStandardWeight\n            exposureConfiguration.infectiousnessHighWeight = codableExposureConfiguration.infectiousnessHighWeight\n            exposureConfiguration.reportTypeConfirmedTestWeight = codableExposureConfiguration.reportTypeConfirmedTestWeight\n            exposureConfiguration.reportTypeConfirmedClinicalDiagnosisWeight = codableExposureConfiguration.reportTypeConfirmedClinicalDiagnosisWeight\n            exposureConfiguration.reportTypeSelfReportedWeight = codableExposureConfiguration.reportTypeSelfReportedWeight\n            exposureConfiguration.reportTypeRecursiveWeight = codableExposureConfiguration.reportTypeRecursiveWeight\n            if let reportTypeNoneMap = ENDiagnosisReportType(rawValue: UInt32(codableExposureConfiguration.reportTypeNoneMap)) {\n                exposureConfiguration.reportTypeNoneMap = reportTypeNoneMap\n            }\n        }\n        exposureConfiguration.minimumRiskScore = codableExposureConfiguration.minimumRiskScore\n        exposureConfiguration.attenuationLevelValues = codableExposureConfiguration.attenuationLevelValues as [NSNumber]\n        exposureConfiguration.daysSinceLastExposureLevelValues = codableExposureConfiguration.daysSinceLastExposureLevelValues as [NSNumber]\n        exposureConfiguration.durationLevelValues = codableExposureConfiguration.durationLevelValues as [NSNumber]\n        exposureConfiguration.transmissionRiskLevelValues = codableExposureConfiguration.transmissionRiskLevelValues as [NSNumber]\n        exposureConfiguration.metadata = [\"attenuationDurationThresholds\": codableExposureConfiguration.attenuationDurationThresholds]\n        completion(.success(exposureConfiguration))\n    } catch {\n        completion(.failure(error))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "Server.shared.getExposureConfiguration { result in\n    switch result {\n    case let .success(configuration):\n        ExposureManager.shared.manager.detectExposures(configuration: configuration, diagnosisKeyURLs: localURLs) { summary, error in\n            if let error = error {\n                finish(.failure(error))\n                return\n            }\n            if #available(iOS 13.7, *) {\n                getExposuresV2(summary!)\n            } else if #available(iOS 13.5, *) {\n                getExposuresV1(summary!)\n            } else if ENManagerIsAvailable() {\n                getExposuresV2(summary!)\n            } else {\n                print(\"Exposure Notifications not supported on this version of iOS.\")\n            }\n        }\n        \n    case let .failure(error):\n        finish(.failure(error))\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "38be122d2da08b70bf94b21c8c0b4954bc19dadec45e8090149550f182f6544c",
  "crawledAt" : "2025-12-02T15:48:53Z",
  "id" : "440052E8-6C1B-4910-8CA5-A5DF9452061E",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Exposure Notification",
  "overview" : "## Overview\n\nThis code project uses the [https:\/\/developer.apple.com\/exposure-notification\/] to build a sample app that demonstrates how to notify people when they have come into contact with someone who meets a set of criteria for a case of COVID-19. When using the project as a reference for designing an Exposure Notifications app, you can define the criteria for how the framework determines whether the risk is high enough to report to the user.\n\nThe sample app includes code to simulate server responses. When building an Exposure Notifications app based on this project, create a server environment to provide diagnosis keys and exposure criteria, and add code to your app to communicate with this server. If the app you build operates in a country that authenticates medical tests for COVID-19, you may need to include additional network code to communicate with those authentication services.\n\nExposure Notifications is available on all iOS devices running iOS 13.5 or later. It’s also available on iOS 12.5 with some additional setup. The Xcode project has two targets:\n\nFor more information on the architecture and security of the Exposure Notification service, see [https:\/\/www.apple.com\/covid19\/contacttracing\/]. For more information on supporting iOS 12.5 in your Exposure Notifications App, see [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/supporting-exposure-notifications-in-ios-12-5].\n\n### Configure the Sample Code Project\n\nBefore you run the sample code project in Xcode, make sure:\n\n### Authorize Exposure Notifications\n\nUsers must explicitly authorize an app to use Exposure Notifications. The [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager] class provides information on the user’s authorization status and requests authorization. The project has a singleton class called `ExposureManager` that instantiates and manages the life cycle of an `ENManager` object. During `init`, It calls [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/activate(completionHandler:)] on `ENManager`, then checks the callback to find out if Exposure Notifications is enabled. If it isn’t, `ExposureManager` attempts to enable it.\n\n### Store User Data Locally\n\nThe app stores information about test results and high-risk exposures in the user defaults directory. The local data is private and stays on the device.\n\nA custom property wrapper transforms data between its native format and a JSON-formatted equivalent, reads and writes data in the user defaults dictionary, and posts notifications to the app when local data changes. The `LocalStore` class manages the user’s private data, defined as a series of properties that all use this property wrapper.\n\nThe app defines its own data structures for any data it persists. For example, a test result records the date the user took the test, and whether the user shared this data with the server. This information is used to populate the user interface.\n\n### Share Diagnosis Keys with the Server\n\nA user with a diagnosis for COVID-19 can upload *diagnosis keys* to the server. Each instance of the app periodically downloads diagnosis keys to search the device’s private interaction data for matching interactions.\n\nThis project simulates a remote server with which the app communicates. There is a single `Server` object in the app that stores the received diagnosis keys and provides them on demand. The sample server does not partition the data by region. It maintains a single list of keys, and provides the entire list upon request.\n\nAs with the local store, this local server stores the data in JSON format, using the same `Persisted` property wrapper.\n\n### Ask Users to Share COVID-19 Indicators\n\nThe sample app demonstrates a strategy in which a recognized medical authority tested the user and found positive COVID-19 indicators. The sample app provides a way for users to enter an authentication code, but doesn’t submit this data to an authentication service, so all codes automatically pass.\n\nWhen the user provides information about a positive test result, the app records the test result in the local store and asks the user to share it. To share the result, the app needs to get a list of diagnosis keys and send the list to the server. To get the keys, the app calls the singleton `ENManager` object’s [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/getDiagnosisKeys(completionHandler:)] method, as shown in the code below.\n\nEach time the app calls this method, the user must authorize the transaction. The framework then returns the list of keys to the app. The app sends those keys as-is to the server and then updates the test record to indicate that it was shared.\n\nThe sample app’s server implementation appends the keys onto a list it maintains, skipping any keys that are already there. It stores the keys sequentially so that the app can request just the keys it hasn’t received before.\n\n### Ask Users to Preauthorize Key Release at the Time of the Test\n\nStarting with iOS 14.4, the Exposure Notification framework allows apps to ask users for permission to release temporary exposure keys when they take a COVID-19 diagnostic test. This authorization lasts for up to five days and should be requested only if the app determines that the user is about to take a test and the app has a way to determine the results. To request preauthorization, the app calls [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/preAuthorizeDiagnosisKeys(completionHandler:)].\n\nWithin five days of being granted permission, if the app determines that the user has received a positive test result, it can request the preauthorized keys and submit them to the key server. `ENManager` sends keys to the app using a completion handler property called [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/diagnosisKeysAvailableHandler], which the app sets before requesting the keys:\n\nAfter setting the  `diagnosisKeysAvailableHandler` property, the app requests the keys by calling [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/requestPreAuthorizedDiagnosisKeys(completionHandler:)]. This call returns an error if the user doesn’t authorize release or if more than five days pass after authorization. Otherwise, the completion handler is called with the keys. When the sample app releases the keys, it notifies the user that because they’ve had a positive test result, their keys are being shared pursuant to their prior authorization.\n\n### Detect Exposure Notifications API Version at Runtime\n\nThe Exposure Notifications APIs are available in the following distinct versions that implement slightly different versions of the detection algorithm:\n\nThe sample app includes a utility function to determine which API versions are available on the current device:\n\nThe main difference between using the two API versions is the method called to detect exposures. When running on devices that only support version 1, the sample app uses [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/getExposureInfo(summary:userExplanation:completionHandler:)] to evaluate diagnosis keys for potential exposures. When running on devices that support version 2 of the API, it uses [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/getExposureWindows(summary:completionHandler:)] instead.\n\n### Check for Exposures in iOS 13.5+\n\nThe ExposureNotificationApp target demonstrates how to create a background task in iOS 13.5 or later to periodically download new keys and check whether the user may have been exposed to an individual with COVID-19.\n\nThe app’s `Info.plist` file declares a background task named `com.example.apple-samplecode.ExposureNotificationSampleApp.exposure-notification`. The Background Task framework automatically detects apps that contain the Exposure Notification entitlement and a background task that ends in `exposure-notification`. The operating system automatically launches these apps when they aren’t running and guarantees them more background time to ensure that the app can test and report results promptly.\n\nFirst, the background task provides a handler in case it runs out of time. Then it calls the app’s `detectExposures` method to test for exposures. Finally, it schedules the next time the system should execute the background task.\n\n### Check for Exposures in iOS 12.5\n\nTo support iOS 12.5, apps must register an activity handler with `ENManager`’s `setLaunchActivityHandler()` instead of creating a background task, but only when running on iOS 12.5. This step is necessary because [doc:\/\/com.apple.documentation\/documentation\/BackgroundTasks] do not exist in iOS 12.5. Instead, `ENManager` provides apps that register an activity handler with 3.5 minutes of background processing at least once per day.\n\nThe remaining sections describe how the app obtains the set of diagnosis keys and submits them to the framework for evaluation.\n\n### Download Diagnosis Keys\n\nThe app downloads diagnosis keys from the server to pass to the framework, starting with the first key the app hasn’t downloaded before. This design ensures that the app checks each diagnosis key only once on any given device.\n\nThe app needs to provide signed key files to the framework. The app asks the server for the URLs of any key files that the server generated after the last file that the app checked. After receiving the URLs from the server, the app uses a dispatch group to download the files to the device.\n\nFinally, the app creates an array of the local URLs for the downloaded files.\n\n### Configure Criteria to Estimate Risk\n\nThe framework will compare locally saved interaction data against the diagnosis keys provided by the app. When the framework finds a match, it calculates a risk score for that interaction based on a number of different factors, such as when the interaction took place and how long the devices were in proximity to each other.\n\nTo provide specific guidance to the framework about how risk should be evaluated, the app creates an [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENExposureConfiguration] object. The app requests the criteria from the `Server` object, which creates and returns an `ENExposureConfiguration` object as shown below. The sample configuration has placeholder data that evaluates any interaction as risky, so the framework returns all interactions that match the diagnosis keys.\n\n### Submit Diagnosis Keys to the Framework\n\nAfter downloading the key files, the app performs the search for exposures using a series of asynchronous steps. First, the app requests the criteria from the server, which calls into the code shown in the Configure Criteria to Estimate Risk section above. Then the app calls the `ENManager` objects’s [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/detectExposures(configuration:diagnosisKeyURLs:completionHandler:)] method, passing the criteria and the URLs for the downloaded key files. This method returns a summary of the search results.\n\nThe code then passes off the downloaded keys to one of two different methods based on which API version is available on the device.\n\nFinally, the app calls its `finish` method to complete the search. The `finish` method updates the local store with the new data, including any exposures, the date and time the app executed the search, and the index for the key file to check next time.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/ExposureNotification\/building-an-app-to-notify-users-of-covid-19-exposure\ncrawled: 2025-12-02T15:48:53Z\n---\n\n# Building an App to Notify Users of COVID-19 Exposure\n\n**Sample Code**\n\nInform people when they may have been exposed to COVID-19.\n\n## Overview\n\nThis code project uses the [https:\/\/developer.apple.com\/exposure-notification\/] to build a sample app that demonstrates how to notify people when they have come into contact with someone who meets a set of criteria for a case of COVID-19. When using the project as a reference for designing an Exposure Notifications app, you can define the criteria for how the framework determines whether the risk is high enough to report to the user.\n\nThe sample app includes code to simulate server responses. When building an Exposure Notifications app based on this project, create a server environment to provide diagnosis keys and exposure criteria, and add code to your app to communicate with this server. If the app you build operates in a country that authenticates medical tests for COVID-19, you may need to include additional network code to communicate with those authentication services.\n\nExposure Notifications is available on all iOS devices running iOS 13.5 or later. It’s also available on iOS 12.5 with some additional setup. The Xcode project has two targets:\n\n- ExposureNotificationApp — Supports iOS 13.5 and later\n- ExposureNotificationApp-iOS12 — Supports iOS 12.5, and iOS 13.5 and later\n\nFor more information on the architecture and security of the Exposure Notification service, see [https:\/\/www.apple.com\/covid19\/contacttracing\/]. For more information on supporting iOS 12.5 in your Exposure Notifications App, see [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/supporting-exposure-notifications-in-ios-12-5].\n\n### Configure the Sample Code Project\n\nBefore you run the sample code project in Xcode, make sure:\n\n- Your iOS device is running either iOS 12.5 or 13.5 or later.\n- You are running Xcode 12 or later.\n- You configure the project with a provisioning profile that includes the Exposure Notification entitlement. To get permission to use this entitlement, see [https:\/\/developer.apple.com\/contact\/request\/exposure-notification-entitlement].\n\n### Authorize Exposure Notifications\n\nUsers must explicitly authorize an app to use Exposure Notifications. The [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager] class provides information on the user’s authorization status and requests authorization. The project has a singleton class called `ExposureManager` that instantiates and manages the life cycle of an `ENManager` object. During `init`, It calls [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/activate(completionHandler:)] on `ENManager`, then checks the callback to find out if Exposure Notifications is enabled. If it isn’t, `ExposureManager` attempts to enable it.\n\n```swift\n    manager.activate { _ in\n        \/\/ Ensure Exposure Notifications is enabled if the app is authorized. The app\n        \/\/ could get into a state where it is authorized, but Exposure Notifications\n        \/\/ is not enabled, if the user initially denied Exposure Notifications\n        \/\/ during onboarding, but then flipped on the \"COVID-19 Exposure Notifications\" switch\n        \/\/ in Settings.\n        if !self.manager.exposureNotificationEnabled {\n            self.manager.setExposureNotificationEnabled(true) { (error) in\n                if let error = error {\n                    print(\"Error attempting to enable on launch: \\(error.localizedDescription)\")\n                }\n            }\n        }\n    }\n}\n```\n\n### Store User Data Locally\n\nThe app stores information about test results and high-risk exposures in the user defaults directory. The local data is private and stays on the device.\n\nA custom property wrapper transforms data between its native format and a JSON-formatted equivalent, reads and writes data in the user defaults dictionary, and posts notifications to the app when local data changes. The `LocalStore` class manages the user’s private data, defined as a series of properties that all use this property wrapper.\n\n```swift\nclass LocalStore {\n    \n    static let shared = LocalStore()\n    \n    @Persisted(userDefaultsKey: \"isOnboarded\", notificationName: .init(\"LocalStoreIsOnboardedDidChange\"), defaultValue: false)\n    var isOnboarded: Bool\n    \n    @Persisted(userDefaultsKey: \"nextDiagnosisKeyFileIndex\", notificationName: .init(\"LocalStoreNextDiagnosisKeyFileIndexDidChange\"), defaultValue: 0)\n    var nextDiagnosisKeyFileIndex: Int\n    \n    @Persisted(userDefaultsKey: \"exposures\", notificationName: .init(\"LocalStoreExposuresDidChange\"), defaultValue: [])\n    var exposures: [Exposure]\n    \n    @Persisted(userDefaultsKey: \"dateLastPerformedExposureDetection\",\n               notificationName: .init(\"LocalStoreDateLastPerformedExposureDetectionDidChange\"), defaultValue: nil)\n    var dateLastPerformedExposureDetection: Date?\n    \n    @Persisted(userDefaultsKey: \"exposureDetectionErrorLocalizedDescription\", notificationName:\n        .init(\"LocalStoreExposureDetectionErrorLocalizedDescriptionDidChange\"), defaultValue: nil)\n    var exposureDetectionErrorLocalizedDescription: String?\n    \n    @Persisted(userDefaultsKey: \"testResults\", notificationName: .init(\"LocalStoreTestResultsDidChange\"), defaultValue: [:])\n    var testResults: [UUID: TestResult]\n}\n```\n\nThe app defines its own data structures for any data it persists. For example, a test result records the date the user took the test, and whether the user shared this data with the server. This information is used to populate the user interface.\n\n```swift\nstruct TestResult: Codable {\n    var id: UUID                \/\/ A unique identifier for this test result\n    var isAdded: Bool           \/\/ Whether the user completed the add positive diagnosis flow for this test result\n    var dateAdministered: Date  \/\/ The date the test was administered\n    var isShared: Bool          \/\/ Whether diagnosis keys were shared with the Health Authority for the purpose of notifying others\n}\n```\n\n### Share Diagnosis Keys with the Server\n\nA user with a diagnosis for COVID-19 can upload *diagnosis keys* to the server. Each instance of the app periodically downloads diagnosis keys to search the device’s private interaction data for matching interactions.\n\nThis project simulates a remote server with which the app communicates. There is a single `Server` object in the app that stores the received diagnosis keys and provides them on demand. The sample server does not partition the data by region. It maintains a single list of keys, and provides the entire list upon request.\n\n```swift\n\/\/ Replace this class with your own class that communicates with your server.\nclass Server {\n    \n    static let shared = Server()\n    \n    \/\/ For testing purposes, this object stores all of the TEKs it receives locally on device\n    \/\/ In a real implementation, these would be stored on a remote server\n    @Persisted(userDefaultsKey: \"diagnosisKeys\", notificationName: .init(\"ServerDiagnosisKeysDidChange\"), defaultValue: [])\n    var diagnosisKeys: [CodableDiagnosisKey]\n```\n\nAs with the local store, this local server stores the data in JSON format, using the same `Persisted` property wrapper.\n\n### Ask Users to Share COVID-19 Indicators\n\nThe sample app demonstrates a strategy in which a recognized medical authority tested the user and found positive COVID-19 indicators. The sample app provides a way for users to enter an authentication code, but doesn’t submit this data to an authentication service, so all codes automatically pass.\n\nWhen the user provides information about a positive test result, the app records the test result in the local store and asks the user to share it. To share the result, the app needs to get a list of diagnosis keys and send the list to the server. To get the keys, the app calls the singleton `ENManager` object’s [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/getDiagnosisKeys(completionHandler:)] method, as shown in the code below.\n\n```swift\nfunc getAndPostDiagnosisKeys(testResult: TestResult, completion: @escaping (Error?) -> Void) {\n    manager.getDiagnosisKeys { temporaryExposureKeys, error in\n        if let error = error {\n            completion(error)\n        } else {\n            guard let temporaryExposureKeys = temporaryExposureKeys else {\n                print(\"No exposure keys, aborting key share\")\n                return\n            }\n            \n            \/\/ In this sample app, transmissionRiskLevel isn't set for any of the diagnosis keys. However, it is at this point that an app could\n            \/\/ use information accumulated in testResult to determine a transmissionRiskLevel for each diagnosis key.\n            Server.shared.postDiagnosisKeys(temporaryExposureKeys) { error in\n                completion(error)\n            }\n        }\n    }\n}\n```\n\nEach time the app calls this method, the user must authorize the transaction. The framework then returns the list of keys to the app. The app sends those keys as-is to the server and then updates the test record to indicate that it was shared.\n\nThe sample app’s server implementation appends the keys onto a list it maintains, skipping any keys that are already there. It stores the keys sequentially so that the app can request just the keys it hasn’t received before.\n\n```swift\nfunc postDiagnosisKeys(_ diagnosisKeys: [ENTemporaryExposureKey], completion: (Error?) -> Void) {\n    \n    \/\/ Convert keys to something that can be encoded to JSON and upload them.\n    let codableDiagnosisKeys = diagnosisKeys.compactMap { diagnosisKey -> CodableDiagnosisKey? in\n        return CodableDiagnosisKey(keyData: diagnosisKey.keyData,\n                                   rollingPeriod: diagnosisKey.rollingPeriod,\n                                   rollingStartNumber: diagnosisKey.rollingStartNumber,\n                                   transmissionRiskLevel: diagnosisKey.transmissionRiskLevel)\n    }\n    \n    \/\/ In a real implementation, these keys would be uploaded with URLSession instead of being saved here.\n    \/\/ Your server needs to handle de-duplicating keys.\n    for codableDiagnosisKey in codableDiagnosisKeys where !self.diagnosisKeys.contains(codableDiagnosisKey) {\n        self.diagnosisKeys.append(codableDiagnosisKey)\n    }\n    completion(nil)\n}\n```\n\n### Ask Users to Preauthorize Key Release at the Time of the Test\n\nStarting with iOS 14.4, the Exposure Notification framework allows apps to ask users for permission to release temporary exposure keys when they take a COVID-19 diagnostic test. This authorization lasts for up to five days and should be requested only if the app determines that the user is about to take a test and the app has a way to determine the results. To request preauthorization, the app calls [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/preAuthorizeDiagnosisKeys(completionHandler:)].\n\n```swift\n@available(iOS 14.4, *)\nfunc preAuthorizeKeys(\n    completion: @escaping (Error?) -> Void) {\n    manager.preAuthorizeDiagnosisKeys { (error) in\n        if let error = error {\n            print(\"Error pre-authorizing keys: \\(error)\")\n            completion(error)\n            return\n        }\n        print(\"Successfully pre-authorized keys\")\n        completion(nil)\n    }\n}\n```\n\nWithin five days of being granted permission, if the app determines that the user has received a positive test result, it can request the preauthorized keys and submit them to the key server. `ENManager` sends keys to the app using a completion handler property called [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/diagnosisKeysAvailableHandler], which the app sets before requesting the keys:\n\n```swift\n\/\/ This handler receives preauthorized keys. Once the handler is called,\n\/\/ the preauthorization expires, so the handler should only be called\n\/\/ once per preauthorization request. If the user doesn't authorize\n\/\/ release, this handler isn't called.\nmanager.diagnosisKeysAvailableHandler = { (keys) in\n    Server.shared.postDiagnosisKeys(keys) { (error) in\n        if let error = error {\n            print(\"Error posting pre-authorized diagnosis keys: \\(error)\")\n        }\n        completion(error)\n    }\n}\n```\n\nAfter setting the  `diagnosisKeysAvailableHandler` property, the app requests the keys by calling [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/requestPreAuthorizedDiagnosisKeys(completionHandler:)]. This call returns an error if the user doesn’t authorize release or if more than five days pass after authorization. Otherwise, the completion handler is called with the keys. When the sample app releases the keys, it notifies the user that because they’ve had a positive test result, their keys are being shared pursuant to their prior authorization.\n\n```swift\n\/\/ This call requests preauthorized keys. The request fails if the\n\/\/ user doesn't authorize release or if more than five days pass after\n\/\/ authorization. If requestPreAuthorizedDiagnosisKeys(:) has already\n\/\/ been called since the last time the user preauthorized, the call\n\/\/ doesn't fail but also doesn't return any keys.\nmanager.requestPreAuthorizedDiagnosisKeys { (error) in\n    if let error = error {\n        print(\"Error retrieving pre-authorized diganosis keys: \\(error)\")\n        completion(error)\n    }\n}\n```\n\n\n\n### Detect Exposure Notifications API Version at Runtime\n\nThe Exposure Notifications APIs are available in the following distinct versions that implement slightly different versions of the detection algorithm:\n\n- Version 1 — Devices running iOS 13.5 or iOS 13.6 support the version 1 API only. To prevent runtime errors, Exposure Notifications apps for iOS 13.5 and iOS 13.6 must fall back to this version.\n- Version 2 — When available, apps should use this version of the API.\n\nThe sample app includes a utility function to determine which API versions are available on the current device:\n\n```swift\nfunc ENManagerIsAvailable() -> Bool {\n    return NSClassFromString(\"ENManager\") != nil\n}\n\nenum SupportedENAPIVersion {\n    case version2\n    case version1\n    case unsupported\n}\n\nfunc getSupportedExposureNotificationsVersion() -> SupportedENAPIVersion {\n    if #available(iOS 13.7, *) {\n        return .version2\n    } else if #available(iOS 13.5, *) {\n        return .version1\n    } else if ENManagerIsAvailable() {\n        return .version2\n    } else {\n        return .unsupported\n    }\n}\n```\n\nThe main difference between using the two API versions is the method called to detect exposures. When running on devices that only support version 1, the sample app uses [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/getExposureInfo(summary:userExplanation:completionHandler:)] to evaluate diagnosis keys for potential exposures. When running on devices that support version 2 of the API, it uses [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/getExposureWindows(summary:completionHandler:)] instead.\n\n```swift\n\/\/ Handles getting exposures using the version 2 API in iOS 13.7+ and\n\/\/ in iOS 12.5\nfunc getExposuresV2(_ summary: ENExposureDetectionSummary) {\n    self.manager.getExposureWindows(summary: summary) { windows, error in\n        if let error = error {\n            finish(.failure(error))\n            return\n        }\n        let allWindows = windows!.map { window in\n            Exposure(date: window.date)\n        }\n        finish(.success((allWindows, nextDiagnosisKeyFileIndex + localURLs.count)))\n    }\n}\n\n\/\/ Handles getting exposures using the version 1 API used in iOS 13.5 and iOS 13.6\n@available(iOS 13.5, *)\nfunc getExposuresV1(_ summary: ENExposureDetectionSummary) {\n    let userExplanation = NSLocalizedString(\"USER_NOTIFICATION_EXPLANATION\", comment: \"User notification\")\n    ExposureManager.shared.manager.getExposureInfo(summary: summary,\n                                                   userExplanation: userExplanation) { exposures, error in\n        if let error = error {\n            finish(.failure(error))\n            return\n        }\n        let newExposures = exposures!.map { exposure in\n            Exposure(date: exposure.date)\n        }\n        finish(.success((newExposures, nextDiagnosisKeyFileIndex + localURLs.count)))\n    }\n}\n```\n\n### Check for Exposures in iOS 13.5+\n\nThe ExposureNotificationApp target demonstrates how to create a background task in iOS 13.5 or later to periodically download new keys and check whether the user may have been exposed to an individual with COVID-19.\n\nThe app’s `Info.plist` file declares a background task named `com.example.apple-samplecode.ExposureNotificationSampleApp.exposure-notification`. The Background Task framework automatically detects apps that contain the Exposure Notification entitlement and a background task that ends in `exposure-notification`. The operating system automatically launches these apps when they aren’t running and guarantees them more background time to ensure that the app can test and report results promptly.\n\n```swift\nfunc scheduleBackgroundTaskIfNeeded() {\n    if #available(iOS 13.5, *) {\n        guard ENManager.authorizationStatus == .authorized else { return }\n        let taskRequest = BGProcessingTaskRequest(identifier: backgroundTaskIdentifier)\n        taskRequest.requiresNetworkConnectivity = true\n        do {\n            try BGTaskScheduler.shared.submit(taskRequest)\n        } catch {\n            print(\"Unable to schedule background task: \\(error)\")\n        }\n    }\n}\n```\n\nFirst, the background task provides a handler in case it runs out of time. Then it calls the app’s `detectExposures` method to test for exposures. Finally, it schedules the next time the system should execute the background task.\n\n```swift\nfunc createBackgroundTaskIfNeeded() {\n    if #available(iOS 13.0, *) {\n        BGTaskScheduler.shared.register(forTaskWithIdentifier: backgroundTaskIdentifier, using: .main) { task in\n            \n            \/\/ Notify the user if Bluetooth is off\n            ExposureManager.shared.showBluetoothOffUserNotificationIfNeeded()\n            \n            \/\/ Perform the exposure detection\n            let progress = ExposureManager.shared.detectExposures { success in\n                task.setTaskCompleted(success: success)\n            }\n            \n            \/\/ Handle running out of time\n            task.expirationHandler = {\n                progress.cancel()\n                LocalStore.shared.exposureDetectionErrorLocalizedDescription = NSLocalizedString(\"BACKGROUND_TIMEOUT\", comment: \"Error\")\n            }\n            \n            \/\/ Schedule the next background task\n            scheduleBackgroundTaskIfNeeded()\n        }\n    }\n}\n```\n\n### Check for Exposures in iOS 12.5\n\nTo support iOS 12.5, apps must register an activity handler with `ENManager`’s `setLaunchActivityHandler()` instead of creating a background task, but only when running on iOS 12.5. This step is necessary because [doc:\/\/com.apple.documentation\/documentation\/BackgroundTasks] do not exist in iOS 12.5. Instead, `ENManager` provides apps that register an activity handler with 3.5 minutes of background processing at least once per day.\n\n```swift\nif #available(iOS 13.5, *) {\n    \/\/ In iOS 13.5 and later, the Background Tasks framework is available,\n    \/\/ so create and schedule a background task for downloading keys and\n    \/\/ detecting exposures\n    createBackgroundTaskIfNeeded()\n    scheduleBackgroundTaskIfNeeded()\n} else if ENManagerIsAvailable() {\n    \/\/ If `ENManager` exists, and the iOS version is earlier than 13.5,\n    \/\/ the app is running on iOS 12.5, where the Background Tasks\n    \/\/ framework is unavailable. Specify an EN activity handler here, which\n    \/\/ allows the app to receive background time for downloading keys\n    \/\/ and looking for exposures when background tasks aren't available.\n    \/\/ Apps should should call this method before calling activate().\n    manager.setLaunchActivityHandler { (activityFlags) in\n        \/\/ ENManager gives apps that register an activity handler\n        \/\/ in iOS 12.5 up to 3.5 minutes of background time at\n        \/\/ least once per day. In iOS 13 and later, registering an\n        \/\/ activity handler does nothing.\n        if activityFlags.contains(.periodicRun) {\n            print(\"Periodic activity callback called (iOS 12.5)\")\n            _ = ExposureManager.shared.detectExposures()\n        }\n    }\n}\n```\n\nThe remaining sections describe how the app obtains the set of diagnosis keys and submits them to the framework for evaluation.\n\n### Download Diagnosis Keys\n\nThe app downloads diagnosis keys from the server to pass to the framework, starting with the first key the app hasn’t downloaded before. This design ensures that the app checks each diagnosis key only once on any given device.\n\nThe app needs to provide signed key files to the framework. The app asks the server for the URLs of any key files that the server generated after the last file that the app checked. After receiving the URLs from the server, the app uses a dispatch group to download the files to the device.\n\n```swift\nlet nextDiagnosisKeyFileIndex = LocalStore.shared.nextDiagnosisKeyFileIndex\n\nServer.shared.getDiagnosisKeyFileURLs(startingAt: nextDiagnosisKeyFileIndex) { result in\n    \n    let dispatchGroup = DispatchGroup()\n    var localURLResults = [Result<[URL], Error>]()\n    \n    switch result {\n    case let .success(remoteURLs):\n        for remoteURL in remoteURLs {\n            dispatchGroup.enter()\n            Server.shared.downloadDiagnosisKeyFile(at: remoteURL) { result in\n                localURLResults.append(result)\n                dispatchGroup.leave()\n            }\n        }\n        \n    case let .failure(error):\n        finish(.failure(error))\n    }\n```\n\nFinally, the app creates an array of the local URLs for the downloaded files.\n\n```swift\ndispatchGroup.notify(queue: .main) {\n    for result in localURLResults {\n        switch result {\n        case let .success(urls):\n            localURLs.append(contentsOf: urls)\n        case let .failure(error):\n            finish(.failure(error))\n            return\n        }\n    }\n```\n\n### Configure Criteria to Estimate Risk\n\nThe framework will compare locally saved interaction data against the diagnosis keys provided by the app. When the framework finds a match, it calculates a risk score for that interaction based on a number of different factors, such as when the interaction took place and how long the devices were in proximity to each other.\n\nTo provide specific guidance to the framework about how risk should be evaluated, the app creates an [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENExposureConfiguration] object. The app requests the criteria from the `Server` object, which creates and returns an `ENExposureConfiguration` object as shown below. The sample configuration has placeholder data that evaluates any interaction as risky, so the framework returns all interactions that match the diagnosis keys.\n\n```swift\nfunc getExposureConfiguration(completion: (Result<ENExposureConfiguration, Error>) -> Void) {\n    \n    let dataFromServer = \"\"\"\n    {\n    \"immediateDurationWeight\":100,\n    \"nearDurationWeight\":100,\n    \"mediumDurationWeight\":100,\n    \"otherDurationWeight\":100,\n    \"infectiousnessForDaysSinceOnsetOfSymptoms\":{\n        \"unknown\":1,\n        \"-14\":1,\n        \"-13\":1,\n        \"-12\":1,\n        \"-11\":1,\n        \"-10\":1,\n        \"-9\":1,\n        \"-8\":1,\n        \"-7\":1,\n        \"-6\":1,\n        \"-5\":1,\n        \"-4\":1,\n        \"-3\":1,\n        \"-2\":1,\n        \"-1\":1,\n        \"0\":1,\n        \"1\":1,\n        \"2\":1,\n        \"3\":1,\n        \"4\":1,\n        \"5\":1,\n        \"6\":1,\n        \"7\":1,\n        \"8\":1,\n        \"9\":1,\n        \"10\":1,\n        \"11\":1,\n        \"12\":1,\n        \"13\":1,\n        \"14\":1\n    },\n    \"infectiousnessStandardWeight\":100,\n    \"infectiousnessHighWeight\":100,\n    \"reportTypeConfirmedTestWeight\":100,\n    \"reportTypeConfirmedClinicalDiagnosisWeight\":100,\n    \"reportTypeSelfReportedWeight\":100,\n    \"reportTypeRecursiveWeight\":100,\n    \"reportTypeNoneMap\":1,\n    \"minimumRiskScore\":0,\n    \"attenuationDurationThresholds\":[50, 70],\n    \"attenuationLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8],\n    \"daysSinceLastExposureLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8],\n    \"durationLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8],\n    \"transmissionRiskLevelValues\":[1, 2, 3, 4, 5, 6, 7, 8]\n    }\n    \"\"\".data(using: .utf8)!\n    \n    do {\n        let codableExposureConfiguration = try JSONDecoder().decode(CodableExposureConfiguration.self, from: dataFromServer)\n        let exposureConfiguration = ENExposureConfiguration()\n        if ENManagerIsAvailable() {\n            exposureConfiguration.immediateDurationWeight = codableExposureConfiguration.immediateDurationWeight\n            exposureConfiguration.nearDurationWeight = codableExposureConfiguration.nearDurationWeight\n            exposureConfiguration.mediumDurationWeight = codableExposureConfiguration.mediumDurationWeight\n            exposureConfiguration.otherDurationWeight = codableExposureConfiguration.otherDurationWeight\n            var infectiousnessForDaysSinceOnsetOfSymptoms = [Int: Int]()\n            for (stringDay, infectiousness) in codableExposureConfiguration.infectiousnessForDaysSinceOnsetOfSymptoms {\n                if stringDay == \"unknown\" {\n                    if #available(iOS 14.0, *) {\n                        infectiousnessForDaysSinceOnsetOfSymptoms[ENDaysSinceOnsetOfSymptomsUnknown] = infectiousness\n                    } else {\n                        \/\/ ENDaysSinceOnsetOfSymptomsUnknown is not available\n                        \/\/ in earlier versions of iOS; use an equivalent value\n                        infectiousnessForDaysSinceOnsetOfSymptoms[NSIntegerMax] = infectiousness\n                    }\n                } else if let day = Int(stringDay) {\n                    infectiousnessForDaysSinceOnsetOfSymptoms[day] = infectiousness\n                }\n            }\n            exposureConfiguration.infectiousnessForDaysSinceOnsetOfSymptoms = infectiousnessForDaysSinceOnsetOfSymptoms as [NSNumber: NSNumber]\n            exposureConfiguration.infectiousnessStandardWeight = codableExposureConfiguration.infectiousnessStandardWeight\n            exposureConfiguration.infectiousnessHighWeight = codableExposureConfiguration.infectiousnessHighWeight\n            exposureConfiguration.reportTypeConfirmedTestWeight = codableExposureConfiguration.reportTypeConfirmedTestWeight\n            exposureConfiguration.reportTypeConfirmedClinicalDiagnosisWeight = codableExposureConfiguration.reportTypeConfirmedClinicalDiagnosisWeight\n            exposureConfiguration.reportTypeSelfReportedWeight = codableExposureConfiguration.reportTypeSelfReportedWeight\n            exposureConfiguration.reportTypeRecursiveWeight = codableExposureConfiguration.reportTypeRecursiveWeight\n            if let reportTypeNoneMap = ENDiagnosisReportType(rawValue: UInt32(codableExposureConfiguration.reportTypeNoneMap)) {\n                exposureConfiguration.reportTypeNoneMap = reportTypeNoneMap\n            }\n        }\n        exposureConfiguration.minimumRiskScore = codableExposureConfiguration.minimumRiskScore\n        exposureConfiguration.attenuationLevelValues = codableExposureConfiguration.attenuationLevelValues as [NSNumber]\n        exposureConfiguration.daysSinceLastExposureLevelValues = codableExposureConfiguration.daysSinceLastExposureLevelValues as [NSNumber]\n        exposureConfiguration.durationLevelValues = codableExposureConfiguration.durationLevelValues as [NSNumber]\n        exposureConfiguration.transmissionRiskLevelValues = codableExposureConfiguration.transmissionRiskLevelValues as [NSNumber]\n        exposureConfiguration.metadata = [\"attenuationDurationThresholds\": codableExposureConfiguration.attenuationDurationThresholds]\n        completion(.success(exposureConfiguration))\n    } catch {\n        completion(.failure(error))\n    }\n}\n```\n\n### Submit Diagnosis Keys to the Framework\n\nAfter downloading the key files, the app performs the search for exposures using a series of asynchronous steps. First, the app requests the criteria from the server, which calls into the code shown in the Configure Criteria to Estimate Risk section above. Then the app calls the `ENManager` objects’s [doc:\/\/com.apple.documentation\/documentation\/ExposureNotification\/ENManager\/detectExposures(configuration:diagnosisKeyURLs:completionHandler:)] method, passing the criteria and the URLs for the downloaded key files. This method returns a summary of the search results.\n\nThe code then passes off the downloaded keys to one of two different methods based on which API version is available on the device.\n\n```swift\nServer.shared.getExposureConfiguration { result in\n    switch result {\n    case let .success(configuration):\n        ExposureManager.shared.manager.detectExposures(configuration: configuration, diagnosisKeyURLs: localURLs) { summary, error in\n            if let error = error {\n                finish(.failure(error))\n                return\n            }\n            if #available(iOS 13.7, *) {\n                getExposuresV2(summary!)\n            } else if #available(iOS 13.5, *) {\n                getExposuresV1(summary!)\n            } else if ENManagerIsAvailable() {\n                getExposuresV2(summary!)\n            } else {\n                print(\"Exposure Notifications not supported on this version of iOS.\")\n            }\n        }\n        \n    case let .failure(error):\n        finish(.failure(error))\n    }\n}\n```\n\nFinally, the app calls its `finish` method to complete the search. The `finish` method updates the local store with the new data, including any exposures, the date and time the app executed the search, and the index for the key file to check next time.\n\n## Essentials\n\n- **Supporting Exposure Notifications Express**: Configure servers to notify users of potential exposures to COVID-19 without an app.\n- **Setting Up a Key Server**: Ensure that your server meets the requirements for supporting Exposure Notifications.\n- **ENManager**: A class that manages exposure notifications.\n- **ENDeveloperRegion**: A string that specifies the region that the app supports.\n- **ENAPIVersion**: A number that specifies the version of the API to use.\n- **Changing Configuration Values Using the Server‑to‑Server API**: Update Exposure Notifications configuration values from a Public Health Authority’s server.\n- **Testing Exposure Notifications Apps in iOS 13.7 and Later**: Perform end-to-end validation of Exposure Notifications apps on a device by manually loading configuration files.\n- **Supporting Exposure Notifications in iOS 12.5**: Prepare your Exposure Notifications app to run on a previous version of iOS.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Configure servers to notify users of potential exposures to COVID-19 without an app.",
          "name" : "Supporting Exposure Notifications Express",
          "url" : "https:\/\/developer.apple.com\/documentation\/ExposureNotification\/supporting-exposure-notifications-express"
        },
        {
          "description" : "Ensure that your server meets the requirements for supporting Exposure Notifications.",
          "name" : "Setting Up a Key Server",
          "url" : "https:\/\/developer.apple.com\/documentation\/ExposureNotification\/setting-up-a-key-server"
        },
        {
          "description" : "A class that manages exposure notifications.",
          "name" : "ENManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/ExposureNotification\/ENManager"
        },
        {
          "description" : "A string that specifies the region that the app supports.",
          "name" : "ENDeveloperRegion",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/ENDeveloperRegion"
        },
        {
          "description" : "A number that specifies the version of the API to use.",
          "name" : "ENAPIVersion",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/ENAPIVersion"
        },
        {
          "description" : "Update Exposure Notifications configuration values from a Public Health Authority’s server.",
          "name" : "Changing Configuration Values Using the Server‑to‑Server API",
          "url" : "https:\/\/developer.apple.com\/documentation\/ExposureNotification\/changing-configuration-values-using-the-server-to-server-api"
        },
        {
          "description" : "Perform end-to-end validation of Exposure Notifications apps on a device by manually loading configuration files.",
          "name" : "Testing Exposure Notifications Apps in iOS 13.7 and Later",
          "url" : "https:\/\/developer.apple.com\/documentation\/ExposureNotification\/testing-exposure-notifications-apps-in-ios-13-7-and-later"
        },
        {
          "description" : "Prepare your Exposure Notifications app to run on a previous version of iOS.",
          "name" : "Supporting Exposure Notifications in iOS 12.5",
          "url" : "https:\/\/developer.apple.com\/documentation\/ExposureNotification\/supporting-exposure-notifications-in-ios-12-5"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Building an App to Notify Users of COVID-19 Exposure",
  "url" : "https:\/\/developer.apple.com\/documentation\/ExposureNotification\/building-an-app-to-notify-users-of-covid-19-exposure"
}