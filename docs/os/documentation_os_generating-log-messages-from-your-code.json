{
  "abstract" : "Record useful debugging and analysis information, and include dynamic content in your messages.",
  "codeExamples" : [
    {
      "code" : "\/\/ Log a message to the default log and default log level.os_log(OS_LOG_DEFAULT, \"This is a default message.\");\n    \n\/\/ Log a message to the default log and debug log level\nos_log_with_type(OS_LOG_DEFAULT, OS_LOG_TYPE_DEBUG, \"This is a debug message.\");\n    \n\/\/ Log an error to a custom log object.\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nos_log_with_type(customLog, OS_LOG_TYPE_ERROR, \"An error occurred!\");\n",
      "language" : "swift"
    },
    {
      "code" : "os_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nint itemCount = [self getItemCount];\nNSString* selectedColor = [self getSelectedColor];\nchar* pointer = \"Hello world\";\n    \nos_log(customLog, \"The array contains %d items\", itemCount);\nos_log(customLog, \"The user selected the color %@\", selectedColor);\n\n\/\/ Log raw bytes from a pointer.\nos_log(customLog, \"%.*P\", 11, pointer);",
      "language" : "swift"
    },
    {
      "code" : "let shapeType: String = getShapeType()\nlet selectedColor: String = getSelectedColor()\nlet bigNumber = 1.0234e30\nlet theAnswer = true\n\n\/\/ Apply custom formatting to variables.\ncustomLog.debug(\"Shape type: \\(shapeType, align: .right(columns: 15)) Color: \\(selectedColor, align: .left(columns: 10))\")\ncustomLog.info(\"The big number is \\(bigNumber, format: .exponential(precision: 10, explicitPositiveSign: true, uppercase: false) )\")\ncustomLog.debug(\"The answer is \\(theAnswer, format: .answer)\")",
      "language" : "swift"
    },
    {
      "code" : "os_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nint baudRate = [self getBaudRate];\nuuid_t* uuid = [self getItemUUID];\n\nos_log(customLog, \"The baud rate is %{bitrate}d\", baudRate);\nos_log(customLog, \"The UUID is %{uuid}.*P\", (int)sizeof(uuid_t), uuid);",
      "language" : "objc"
    },
    {
      "code" : "\/\/ Make the smoothie name visible, because it’s not sensitive data.\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nos_log(customLog, \"Smoothie name: %{public}s \", smoothieName);",
      "language" : "swift"
    },
    {
      "code" : "int userAge = getUserAge();\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\n\n\/\/ Hide the user’s age in the log entry. \nos_log(customLog, \"User's age: %{private}d \", userAge);",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Hide the user’s account number, but include a hash mask to allow\n\/\/ the correlation of this log message with others for the same account.\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nos_log(customLog, \"Start transaction for account: %{mask.hash}d \", accountNumber);",
      "language" : "swift"
    }
  ],
  "contentHash" : "4e74e6f3e8acd241d8e39848a6219e5bcf5c6c31191dee5e373816575903cea7",
  "crawledAt" : "2025-12-05T11:07:44Z",
  "id" : "1F4699A8-93AD-4CF0-8718-D1CE15FED734",
  "kind" : "article",
  "language" : "swift",
  "module" : "os",
  "overview" : "## Overview\n\nInsert log messages at appropriate points in your code and use them to diagnose issues later. Typically, you use log messages to:\n\nMessages may contain more than just static strings. The unified logging system allows you to include custom data from your app, and format that data to make it more readable. Like `fprintf`, you can incorporate strings, numbers, Objective-C objects, and other custom data types from your app directly into your log messages. When data types contain sensitive user information, the system has privacy options that hide the actual values without losing any filtering capabilities.\n\n### Create a Log Object to Organize Messages\n\nA log object collects messages associated with a particular part of your app. When you generate log messages, you do so either directly from, or in conjunction with, a log object that you create. The type of log object you create depends on whether you write your code using Swift or Objective-C.\n\nTo prevent the system from displaying an overwhelmingly large number of log messages each time you diagnose issues, each log object contains two custom strings to help you filter out unrelated messages. You specify both strings when creating the log object, using values that are relevant to your app:\n\nIf you don’t need to filter messages, [doc:\/\/com.apple.os\/documentation\/os\/Logger] and [doc:\/\/com.apple.os\/documentation\/os\/OSLog] provide a default log for storing messages. You might use the default log to record messages that don’t require a specific subsystem and category.\n\n### Choose the Appropriate Log Level for Each Message\n\nLog levels define the severity and importance of a particular message, and you specify a log level value each time you record a message. The log level you choose determines how the system handles the message. The system stores all messages in memory initially, and it writes messages with more severe log levels to disk. The following table lists the log levels in increasing order of severity.\n\nNormally, the system stores debug and info messages only in memory, but you can write info messages to disk using the `log` command-line tool. For the other message types, the system compresses the messages and writes them to the on-disk data store. When that data store exceeds a predefined size, the system purges old messages to make room for new ones.\n\nThe severity of the log level impacts the speed at which the system logs the information. Debug logs have very low overhead because the system stores them only in memory. Faults and other severe messages incur more overhead because the system often captures additional information and writes all of that information to disk.\n\n### Generate a Log Message\n\nTo generate a log message:\n\nThe simplest type of log message contains only static text. You might use such messages to report specific events, or anytime you don’t need to include program variables in the message. The following example shows different ways to log messages that contain only static text. The first two examples add messages to the default log, but the third example adds an error message to a custom log object.\n\n### Include Custom Data Values in Log Messages\n\nMessage strings may include the content of program variables. How you include these variables depends on which programming language you use:\n\nThe following example shows several log messages that include different types of variables. In macOS 11 and later, specify variables in Swift directly in the message string as interpolated values. Otherwise, use format-string specifiers and a variable list of arguments to specify values. To log raw bytes from a pointer in Objective-C, use the `%.*P` format modifier.\n\n### Format Custom Values in Message Strings\n\nThe unified logging system formats Swift interpolated variables based on the default settings, but you can apply custom formatting to your variables to make them more readable. In particular, you can:\n\nTo specify a formatting option for an interpolated value, include the appropriate format parameter and value. In the following example, the first log message includes alignment parameters to set the column width and alignment within that column. The second log message formats a floating-point number to include extra digits of precision and a plus sign in front of positive numbers. The third log message formats a Boolean value as a yes\/no answer to a question.\n\nIn addition to the preceding formatting options, the unified logging system supports custom formatting modifiers. In Swift, specify them using the `format` parameter. In Objective-C, use a modifier of the form `%{value_type}d`. Each modifier formats the corresponding data according to the specific type. To format binary data types, use the `%.*P` specifier and add the total number of bytes and the pointer as arguments to the function. The following table lists the built-in format specifiers.\n\nThe following example shows how to format custom bit rates and a UUID structure.\n\nFor information about the options to use when formatting values, see [doc:\/\/com.apple.os\/documentation\/os\/OSLogStringAlignment], [doc:\/\/com.apple.os\/documentation\/os\/OSLogIntegerFormatting], [doc:\/\/com.apple.os\/documentation\/os\/OSLogFloatFormatting], [doc:\/\/com.apple.os\/documentation\/os\/OSLogBoolFormat], [doc:\/\/com.apple.os\/documentation\/os\/OSLogInt32ExtendedFormat], and [doc:\/\/com.apple.os\/documentation\/os\/OSLogPointerFormat].\n\n### Redact Sensitive User Data from a Log Message\n\nLog messages that contain sensitive user data present a potential problem for users, because anyone with access to the logs or the user’s computer can see the information. To protect the privacy of your users, try to limit your log messages to static strings and numbers that you define. If you must include dynamically generated data in your messages, redact any values that contain sensitive user information.\n\nThe unified logging system uses privacy options to hide or show interpolated variables in a message. By default, the system doesn’t redact integer, floating-point and Boolean values, but it does redact the contents of dynamic strings and complex dynamic objects. To make a private value public again, configure the privacy of the variable using appropriate modifiers in your message string or interpolated variable. For example, the following code shows how to make a dynamic string visible again using the [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/public] modifier:\n\nWhen you know a variable contains potentially sensitive user information, mark it as [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/private] explicitly, as shown in the following example:\n\nTo diagnose certain problems, you might need to identify when several log messages all refer to the same piece of user data. For example, when diagnosing issues with a particular user account, you might want to see all log messages associated with that account number. To allow this behavior and still protect user privacy, configure your privacy setting with a [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/Mask\/hash] value, as shown in the following example:\n\nThe inclusion of the [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/Mask\/hash] option replaces the generic redaction text with a hash value that is unique for the current process. The [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/Mask\/hash] value corresponds to the redacted value, but doesn’t provide any identifying information about that value.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/os\/generating-log-messages-from-your-code\ncrawled: 2025-12-05T11:07:44Z\n---\n\n# Generating Log Messages from Your Code\n\n**Article**\n\nRecord useful debugging and analysis information, and include dynamic content in your messages.\n\n## Overview\n\nInsert log messages at appropriate points in your code and use them to diagnose issues later. Typically, you use log messages to:\n\n- Write a message at the start and end of functions and important tasks.\n- Write a message for any interesting events.\n- Write a message when a significant error occurs.\n- Write messages for important or unusual actions with a function. For example, log rarely taken code paths.\n- Write a message before each step of a multi-step task.\n\nMessages may contain more than just static strings. The unified logging system allows you to include custom data from your app, and format that data to make it more readable. Like `fprintf`, you can incorporate strings, numbers, Objective-C objects, and other custom data types from your app directly into your log messages. When data types contain sensitive user information, the system has privacy options that hide the actual values without losing any filtering capabilities.\n\n### Create a Log Object to Organize Messages\n\nA log object collects messages associated with a particular part of your app. When you generate log messages, you do so either directly from, or in conjunction with, a log object that you create. The type of log object you create depends on whether you write your code using Swift or Objective-C.\n\n- In Swift, create a [doc:\/\/com.apple.os\/documentation\/os\/Logger] structure and use its methods to generate log messages.\n- In Objective-C, create an [doc:\/\/com.apple.os\/documentation\/os\/OSLog] object and pass it to logging functions.\n\nTo prevent the system from displaying an overwhelmingly large number of log messages each time you diagnose issues, each log object contains two custom strings to help you filter out unrelated messages. You specify both strings when creating the log object, using values that are relevant to your app:\n\n- The subsystem string identifies a large functional area within your app or apps. For example, if your app spawns additional processes, you might use a different string for each process. Use reverse-DNS notation, such as `com.example.myapp`, for each subsystem string.\n- The category string identifies a particular component or module in a given subsystem. For example, you might define separate strings for your app’s user interface, data model, and networking code. Use any convention you want for these strings.\n\nIf you don’t need to filter messages, [doc:\/\/com.apple.os\/documentation\/os\/Logger] and [doc:\/\/com.apple.os\/documentation\/os\/OSLog] provide a default log for storing messages. You might use the default log to record messages that don’t require a specific subsystem and category.\n\n### Choose the Appropriate Log Level for Each Message\n\nLog levels define the severity and importance of a particular message, and you specify a log level value each time you record a message. The log level you choose determines how the system handles the message. The system stores all messages in memory initially, and it writes messages with more severe log levels to disk. The following table lists the log levels in increasing order of severity.\n\n\n\nNormally, the system stores debug and info messages only in memory, but you can write info messages to disk using the `log` command-line tool. For the other message types, the system compresses the messages and writes them to the on-disk data store. When that data store exceeds a predefined size, the system purges old messages to make room for new ones.\n\n\n\nThe severity of the log level impacts the speed at which the system logs the information. Debug logs have very low overhead because the system stores them only in memory. Faults and other severe messages incur more overhead because the system often captures additional information and writes all of that information to disk.\n\n### Generate a Log Message\n\nTo generate a log message:\n\n- In Swift, call the appropriate method of the [doc:\/\/com.apple.os\/documentation\/os\/Logger] structure in macOS 11 and later. In earlier versions of macOS, call `os_log(_:log:type:)` or one of the related log functions that take an [doc:\/\/com.apple.os\/documentation\/os\/OSLog] object as a parameter.\n- In Objective-C code, call [doc:\/\/com.apple.os\/documentation\/os\/os_log] or an equivalent function that takes an [doc:\/\/com.apple.os\/documentation\/os\/os-log-t] type as a parameter.\n\nThe simplest type of log message contains only static text. You might use such messages to report specific events, or anytime you don’t need to include program variables in the message. The following example shows different ways to log messages that contain only static text. The first two examples add messages to the default log, but the third example adds an error message to a custom log object.\n\n```swift\n\/\/ Log a message to the default log and default log level.os_log(OS_LOG_DEFAULT, \"This is a default message.\");\n    \n\/\/ Log a message to the default log and debug log level\nos_log_with_type(OS_LOG_DEFAULT, OS_LOG_TYPE_DEBUG, \"This is a debug message.\");\n    \n\/\/ Log an error to a custom log object.\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nos_log_with_type(customLog, OS_LOG_TYPE_ERROR, \"An error occurred!\");\n\n```\n\n### Include Custom Data Values in Log Messages\n\nMessage strings may include the content of program variables. How you include these variables depends on which programming language you use:\n\n- In Swift, add interpolated variables of the form `\\(variableName)` to your message strings.\n- In Objective-C, add format string specifiers such as `%@` and `%d`.\n\nThe following example shows several log messages that include different types of variables. In macOS 11 and later, specify variables in Swift directly in the message string as interpolated values. Otherwise, use format-string specifiers and a variable list of arguments to specify values. To log raw bytes from a pointer in Objective-C, use the `%.*P` format modifier.\n\n```swift\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nint itemCount = [self getItemCount];\nNSString* selectedColor = [self getSelectedColor];\nchar* pointer = \"Hello world\";\n    \nos_log(customLog, \"The array contains %d items\", itemCount);\nos_log(customLog, \"The user selected the color %@\", selectedColor);\n\n\/\/ Log raw bytes from a pointer.\nos_log(customLog, \"%.*P\", 11, pointer);\n```\n\n### Format Custom Values in Message Strings\n\nThe unified logging system formats Swift interpolated variables based on the default settings, but you can apply custom formatting to your variables to make them more readable. In particular, you can:\n\n- Specify the width of a variable and align the variable’s text inside that space.\n- Format integers as [doc:\/\/com.apple.os\/documentation\/os\/OSLogIntegerFormatting\/decimal], [doc:\/\/com.apple.os\/documentation\/os\/OSLogIntegerFormatting\/hex], or [doc:\/\/com.apple.os\/documentation\/os\/OSLogIntegerFormatting\/octal] numbers.\n- Format floating-point numbers using [doc:\/\/com.apple.os\/documentation\/os\/OSLogFloatFormatting\/fixed]-point, [doc:\/\/com.apple.os\/documentation\/os\/OSLogFloatFormatting\/hex], [doc:\/\/com.apple.os\/documentation\/os\/OSLogFloatFormatting\/exponential], or [doc:\/\/com.apple.os\/documentation\/os\/OSLogFloatFormatting\/hybrid] notation.\n- Format Boolean values as true\/false or yes\/no strings.\n- Specify the precision of floating-point numbers.\n- Specify the minimum number of digits.\n- Specify whether a number includes an explicit plus or minus sign.\n- Log binary data contained in a pointer.\n\nTo specify a formatting option for an interpolated value, include the appropriate format parameter and value. In the following example, the first log message includes alignment parameters to set the column width and alignment within that column. The second log message formats a floating-point number to include extra digits of precision and a plus sign in front of positive numbers. The third log message formats a Boolean value as a yes\/no answer to a question.\n\n```swift\nlet shapeType: String = getShapeType()\nlet selectedColor: String = getSelectedColor()\nlet bigNumber = 1.0234e30\nlet theAnswer = true\n\n\/\/ Apply custom formatting to variables.\ncustomLog.debug(\"Shape type: \\(shapeType, align: .right(columns: 15)) Color: \\(selectedColor, align: .left(columns: 10))\")\ncustomLog.info(\"The big number is \\(bigNumber, format: .exponential(precision: 10, explicitPositiveSign: true, uppercase: false) )\")\ncustomLog.debug(\"The answer is \\(theAnswer, format: .answer)\")\n```\n\nIn addition to the preceding formatting options, the unified logging system supports custom formatting modifiers. In Swift, specify them using the `format` parameter. In Objective-C, use a modifier of the form `%{value_type}d`. Each modifier formats the corresponding data according to the specific type. To format binary data types, use the `%.*P` specifier and add the total number of bytes and the pointer as arguments to the function. The following table lists the built-in format specifiers.\n\n\n\nThe following example shows how to format custom bit rates and a UUID structure.\n\n```objc\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nint baudRate = [self getBaudRate];\nuuid_t* uuid = [self getItemUUID];\n\nos_log(customLog, \"The baud rate is %{bitrate}d\", baudRate);\nos_log(customLog, \"The UUID is %{uuid}.*P\", (int)sizeof(uuid_t), uuid);\n```\n\nFor information about the options to use when formatting values, see [doc:\/\/com.apple.os\/documentation\/os\/OSLogStringAlignment], [doc:\/\/com.apple.os\/documentation\/os\/OSLogIntegerFormatting], [doc:\/\/com.apple.os\/documentation\/os\/OSLogFloatFormatting], [doc:\/\/com.apple.os\/documentation\/os\/OSLogBoolFormat], [doc:\/\/com.apple.os\/documentation\/os\/OSLogInt32ExtendedFormat], and [doc:\/\/com.apple.os\/documentation\/os\/OSLogPointerFormat].\n\n### Redact Sensitive User Data from a Log Message\n\nLog messages that contain sensitive user data present a potential problem for users, because anyone with access to the logs or the user’s computer can see the information. To protect the privacy of your users, try to limit your log messages to static strings and numbers that you define. If you must include dynamically generated data in your messages, redact any values that contain sensitive user information.\n\nThe unified logging system uses privacy options to hide or show interpolated variables in a message. By default, the system doesn’t redact integer, floating-point and Boolean values, but it does redact the contents of dynamic strings and complex dynamic objects. To make a private value public again, configure the privacy of the variable using appropriate modifiers in your message string or interpolated variable. For example, the following code shows how to make a dynamic string visible again using the [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/public] modifier:\n\n```swift\n\/\/ Make the smoothie name visible, because it’s not sensitive data.\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nos_log(customLog, \"Smoothie name: %{public}s \", smoothieName);\n```\n\nWhen you know a variable contains potentially sensitive user information, mark it as [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/private] explicitly, as shown in the following example:\n\n```swift\nint userAge = getUserAge();\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\n\n\/\/ Hide the user’s age in the log entry. \nos_log(customLog, \"User's age: %{private}d \", userAge);\n```\n\nTo diagnose certain problems, you might need to identify when several log messages all refer to the same piece of user data. For example, when diagnosing issues with a particular user account, you might want to see all log messages associated with that account number. To allow this behavior and still protect user privacy, configure your privacy setting with a [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/Mask\/hash] value, as shown in the following example:\n\n```swift\n\/\/ Hide the user’s account number, but include a hash mask to allow\n\/\/ the correlation of this log message with others for the same account.\nos_log_t customLog = os_log_create(\"com.your_company.your_subsystem\", \"your_category_name\");\nos_log(customLog, \"Start transaction for account: %{mask.hash}d \", accountNumber);\n```\n\nThe inclusion of the [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/Mask\/hash] option replaces the generic redaction text with a hash value that is unique for the current process. The [doc:\/\/com.apple.os\/documentation\/os\/OSLogPrivacy\/Mask\/hash] value corresponds to the redacted value, but doesn’t provide any identifying information about that value.\n\n## Essentials\n\n- **Viewing Log Messages**: Use various tools to retrieve log information.\n- **Customizing Logging Behavior While Debugging**: Control which log events are recorded.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use various tools to retrieve log information.",
          "name" : "Viewing Log Messages",
          "url" : "https:\/\/developer.apple.com\/documentation\/os\/viewing-log-messages"
        },
        {
          "description" : "Control which log events are recorded.",
          "name" : "Customizing Logging Behavior While Debugging",
          "url" : "https:\/\/developer.apple.com\/documentation\/os\/customizing-logging-behavior-while-debugging"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Generating Log Messages from Your Code",
  "url" : "https:\/\/developer.apple.com\/documentation\/os\/generating-log-messages-from-your-code"
}