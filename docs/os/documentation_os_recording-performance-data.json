{
  "abstract" : "Add signposts to record interesting time-based events.",
  "codeExamples" : [
    {
      "code" : "\/\/ Create a signposter that uses the default subsystem and category.\nlet signposter = OSSignposter()\n        \n\/\/ Generate a signpost ID to associate with a signposted interval.\nlet signpostID = signposter.makeSignpostID()",
      "language" : "swift"
    },
    {
      "code" : "func processRequest(_ request: URLRequest, signposter: OSSignposter) {\n    \/\/ Generate a signpost ID to associate with the signposted interval.\n    let signpostID = signposter.makeSignpostID()\n        \n    \/\/ Begin a signposted interval and store the interval state.\n    let state = signposter.beginInterval(\"processRequest\", id: signpostID)\n        \n    let data = fetchData(from: request)\n        \n    \/\/ Emit an event to mark a specific point of interest.\n    signposter.emitEvent(\"Fetch complete.\", id: signpostID)\n    processData(data)\n        \n    \/\/ End the signposted interval using the stored interval state.\n    signposter.endInterval(\"processRequest\", state)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "868fe25ff8174e4f688695716962d37e12e28db1608fecb7212cc0f4c32cfa1c",
  "crawledAt" : "2025-12-01T09:18:54Z",
  "id" : "778FE4DB-7906-4368-8461-07469D5E2CF2",
  "kind" : "article",
  "module" : "os",
  "overview" : "## Overview\n\nUsers notice when an app’s performance degrades, which makes performance tuning a critical part of app development. If your app performs several tasks and leverages concurrency, it can often be difficult to visualize which tasks are executing and how long each one takes to complete.\n\nSignposts allow you to measure your app’s tasks using the same subsystems and categories that you use for logging. After adding signposts to your app using [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter], you use Xcode’s Instruments app to record your app’s behavior as you perform the tasks to measure, and Instruments displays that data in a timeline. If you have complex workloads, you can create an instrument that presents a custom representation of your app’s signpost data.\n\n### Disambiguate Each Instance of a Task\n\nWhen emitting signposts, you need to be able to disambiguate between separate invocations of the same measured code. For example, if your app requests data from a remote server and you’re measuring those requests, you need to be able to identify each individual request, especially if several requests are executing concurrently. To do this, associate a signpost ID with each set of related signposts.\n\nThe easiest way to create a signpost ID is to call your signposter’s [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/makeSignpostID()] method, which creates a unique identifier within the scope of that signposter. The following example shows how to create a signpost ID that you can use to track a specific request:\n\nAlternatively, use one of the system-defined signpost IDs or derive one from an instance of one of your app’s objects. Each of these approaches has its own caveats. For more information, see [doc:\/\/com.apple.os\/documentation\/os\/OSSignpostID].\n\n### Emit Signposted Intervals and Events\n\nAfter you generate a signpost ID, emit signposts for the tasks you want to measure. To begin a signposted interval, use the signposter’s [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/beginInterval(_:id:)] method. Store the interval state the method returns, and then pass it to the [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/endInterval(_:_:)] method to finish the interval. Interval state contains the signpost ID, which the signposter uses to pair the two calls and to enforce a number of runtime assertions. [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter] provides alternative versions of these two methods that allow you to capture a message that Instruments displays, as well as methods to measure the execution of a specific closure. To mark a single point of interest in time, use the [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/emitEvent(_:id:)] method.\n\nThe following example creates a signposted interval that measures the amount of time it takes to process a server request. It also emits a notable event during that process.\n\n### Review Signposts in Instruments\n\nTo record and view your signposts, open your project in Xcode and choose Product > Profile to launch Instruments. Select the Blank profiling template and then click the Add button (+) to open the Instrument library. Double-click the os_signposts instrument to add it to your session. Then click the Record button and perform the tasks in your app that you want to measure. The os_signpost instrument displays separate rows for each subsystem and category combination, and the table below the timeline provides detailed information for each signpost that Instruments captures.\n\n\n\nIf your app generates a significant amount of signpost data, it may be difficult to analyze that data using the standard instrument. Consider building a custom instrument to do the analysis on your behalf. Identify the specific behaviors of your app and create a set of rules to detect and display the corresponding data. For more information, see [https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/410\/].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/os\/recording-performance-data\ncrawled: 2025-12-01T09:18:54Z\n---\n\n# Recording Performance Data\n\n**Article**\n\nAdd signposts to record interesting time-based events.\n\n## Overview\n\nUsers notice when an app’s performance degrades, which makes performance tuning a critical part of app development. If your app performs several tasks and leverages concurrency, it can often be difficult to visualize which tasks are executing and how long each one takes to complete.\n\nSignposts allow you to measure your app’s tasks using the same subsystems and categories that you use for logging. After adding signposts to your app using [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter], you use Xcode’s Instruments app to record your app’s behavior as you perform the tasks to measure, and Instruments displays that data in a timeline. If you have complex workloads, you can create an instrument that presents a custom representation of your app’s signpost data.\n\n### Disambiguate Each Instance of a Task\n\nWhen emitting signposts, you need to be able to disambiguate between separate invocations of the same measured code. For example, if your app requests data from a remote server and you’re measuring those requests, you need to be able to identify each individual request, especially if several requests are executing concurrently. To do this, associate a signpost ID with each set of related signposts.\n\nThe easiest way to create a signpost ID is to call your signposter’s [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/makeSignpostID()] method, which creates a unique identifier within the scope of that signposter. The following example shows how to create a signpost ID that you can use to track a specific request:\n\n```swift\n\/\/ Create a signposter that uses the default subsystem and category.\nlet signposter = OSSignposter()\n        \n\/\/ Generate a signpost ID to associate with a signposted interval.\nlet signpostID = signposter.makeSignpostID()\n```\n\nAlternatively, use one of the system-defined signpost IDs or derive one from an instance of one of your app’s objects. Each of these approaches has its own caveats. For more information, see [doc:\/\/com.apple.os\/documentation\/os\/OSSignpostID].\n\n### Emit Signposted Intervals and Events\n\nAfter you generate a signpost ID, emit signposts for the tasks you want to measure. To begin a signposted interval, use the signposter’s [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/beginInterval(_:id:)] method. Store the interval state the method returns, and then pass it to the [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/endInterval(_:_:)] method to finish the interval. Interval state contains the signpost ID, which the signposter uses to pair the two calls and to enforce a number of runtime assertions. [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter] provides alternative versions of these two methods that allow you to capture a message that Instruments displays, as well as methods to measure the execution of a specific closure. To mark a single point of interest in time, use the [doc:\/\/com.apple.os\/documentation\/os\/OSSignposter\/emitEvent(_:id:)] method.\n\nThe following example creates a signposted interval that measures the amount of time it takes to process a server request. It also emits a notable event during that process.\n\n```swift\nfunc processRequest(_ request: URLRequest, signposter: OSSignposter) {\n    \/\/ Generate a signpost ID to associate with the signposted interval.\n    let signpostID = signposter.makeSignpostID()\n        \n    \/\/ Begin a signposted interval and store the interval state.\n    let state = signposter.beginInterval(\"processRequest\", id: signpostID)\n        \n    let data = fetchData(from: request)\n        \n    \/\/ Emit an event to mark a specific point of interest.\n    signposter.emitEvent(\"Fetch complete.\", id: signpostID)\n    processData(data)\n        \n    \/\/ End the signposted interval using the stored interval state.\n    signposter.endInterval(\"processRequest\", state)\n}\n```\n\n### Review Signposts in Instruments\n\nTo record and view your signposts, open your project in Xcode and choose Product > Profile to launch Instruments. Select the Blank profiling template and then click the Add button (+) to open the Instrument library. Double-click the os_signposts instrument to add it to your session. Then click the Record button and perform the tasks in your app that you want to measure. The os_signpost instrument displays separate rows for each subsystem and category combination, and the table below the timeline provides detailed information for each signpost that Instruments captures.\n\n\n\nIf your app generates a significant amount of signpost data, it may be difficult to analyze that data using the standard instrument. Consider building a custom instrument to do the analysis on your behalf. Identify the specific behaviors of your app and create a set of rules to detect and display the corresponding data. For more information, see [https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/410\/].\n\n## Measure Events\n\n- **OSSignposter**: An object for measuring task performance using the unified logging system.\n- **Legacy Signpost Symbols**: Migrate your code away from using these legacy symbols.\n- **OSSignpostType**: The different kinds of signpost.\n- **os_signpost_id_t**: An identifier you use to distinguish between signposts that have the same name and destination log.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object for measuring task performance using the unified logging system.",
          "name" : "OSSignposter",
          "url" : "https:\/\/developer.apple.com\/documentation\/os\/OSSignposter"
        },
        {
          "description" : "Migrate your code away from using these legacy symbols.",
          "name" : "Legacy Signpost Symbols",
          "url" : "https:\/\/developer.apple.com\/documentation\/os\/legacy-signpost-symbols"
        },
        {
          "description" : "The different kinds of signpost.",
          "name" : "OSSignpostType",
          "url" : "https:\/\/developer.apple.com\/documentation\/os\/OSSignpostType"
        },
        {
          "description" : "An identifier you use to distinguish between signposts that have the same name and destination log.",
          "name" : "os_signpost_id_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/os\/os_signpost_id_t"
        }
      ],
      "title" : "Measure Events"
    }
  ],
  "source" : "appleJSON",
  "title" : "Recording Performance Data",
  "url" : "https:\/\/developer.apple.com\/documentation\/os\/recording-performance-data"
}