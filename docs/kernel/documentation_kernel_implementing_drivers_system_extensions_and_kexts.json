{
  "abstract" : "Create drivers and system extensions to communicate with hardware and provide low-level services, and only use kernel extensions for a few tasks. ",
  "codeExamples" : [

  ],
  "contentHash" : "cef0ca341dffa24f43999713e2dcf142f65804390789f3cfa154826f333b3442",
  "crawledAt" : "2025-12-03T04:47:49Z",
  "id" : "6E59CD23-9BAB-46C8-B958-683564C693A7",
  "kind" : "article",
  "language" : "occ",
  "module" : "System Extensions",
  "overview" : "## Overview\n\nCreate drivers, system extensions, and kernel extensions for specific low-level system services.\n\n\n\nUse the DriverKit SDK and [doc:\/\/com.apple.systemextensions\/documentation\/SystemExtensions] framework to implement low-level services whenever possible. Drivers and system extensions run in user space, instead of inside the kernel’s process space. Running in user space improves system stability and makes it easier to develop, debug, and install your code. \n\n### Implement low-level services using system extensions\n\nThe System Extensions framework supports a class of kernel-level features that previously required kexts. System extensions run in user space and interact with the kernel to perform specific tasks. For example, an endpoint-security system extension monitors system events for potential security threats.\n\nFor more information about the types of system extensions you can create, and how to install them, see [doc:\/\/com.apple.systemextensions\/documentation\/SystemExtensions]. \n\n### Communicate with custom hardware using a DriverKit extension\n\nA dext contains the drivers you need to communicate with your company’s custom hardware. A driver provides a layer of services for accessing the hardware. For example, a driver might configure the device, or it might implement a specific interface for communicating with the device. Because dexts are system extensions, they run in user space and you ship them inside your app bundle. \n\nWhen the user attaches a new hardware device to the computer, the kernel searches for any dexts that handle the device. From those dexts, the kernel assembles a series of drivers to communicate with the device. Each new driver builds upon the capabilities of the previous driver, offering new services or configuration options. \n\nApple provides drivers for all standards-based hardware protocols that Mac computers support. Create custom drivers only for the protocols and features unique to your hardware. You can also use a codeless dext to map your hardware to one of Apple’s built-in drivers.\n\nFor information about how to create and install custom drivers, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/creating-a-driver-using-the-driverkit-sdk].\n\n### Support custom hardware without writing driver code\n\nNot all drivers require actual code. If your hardware communicates entirely using standards-based protocols, you can ship a driver that matches your hardware to one of the built-in system drivers. Shipping a codeless driver requires less effort, and lets you select which driver the system uses for your hardware. \n\nShip a codeless driver in one of the following packages:\n\nCreate a codeless dext when the system provides DriverKit support for your hardware. A codeless dext isn’t entirely codeless. It contains a minimal executable file with an empty subclass—that is, a subclass of an existing DriverKit class, where you don’t implement any methods. In the `Info.plist` file of your dext, set the value of the `IOUserClass` key to the name of your custom subclass. At runtime, the system instantiates your class, but all method calls fall through to the implementation of the parent class.\n\nIn the few cases where your driver requires a kernel extension, use a codeless kext to match your hardware to the existing system driver. Unlike a DriverKit extension, a codeless kext doesn’t have an executable file. Instead, its `Info.plist` file provides all the information that the system needs to match your hardware to a system driver.\n\nFor information about how to create and install a dext, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/creating-a-driver-using-the-driverkit-sdk].\n\n### Build kernel extensions with well-known restrictions\n\nKexts run inside the kernel and must support the same architecture and restrictions as other kernel code. \n\n### Install kernel extensions as the final step in an installer package\n\nIf your custom installer package includes kexts, install them as the final installation step. The system manages kexts differently in macOS 11 and later, requiring a reboot to finish the installation process. As part of the reboot process, users must also explicitly change the security settings of their computer to allow the kext installation. \n\nFor information about the kext installation process, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/installing-a-custom-kernel-extension].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/kernel\/implementing_drivers_system_extensions_and_kexts\ncrawled: 2025-12-03T04:47:49Z\n---\n\n# Implementing drivers, system extensions, and kexts\n\n**Article**\n\nCreate drivers and system extensions to communicate with hardware and provide low-level services, and only use kernel extensions for a few tasks. \n\n## Overview\n\nCreate drivers, system extensions, and kernel extensions for specific low-level system services.\n\n- A DriverKit extension (dext) manages the communication between your company’s hardware device and the rest of the system. \n- A system extension implements features that require kernel-level cooperation, such as custom security and network behaviors. \n- A kernel extension (kext) supports any low-level services that cannot be implemented using a dext or system extension.\n\n\n\nUse the DriverKit SDK and [doc:\/\/com.apple.systemextensions\/documentation\/SystemExtensions] framework to implement low-level services whenever possible. Drivers and system extensions run in user space, instead of inside the kernel’s process space. Running in user space improves system stability and makes it easier to develop, debug, and install your code. \n\n### Implement low-level services using system extensions\n\nThe System Extensions framework supports a class of kernel-level features that previously required kexts. System extensions run in user space and interact with the kernel to perform specific tasks. For example, an endpoint-security system extension monitors system events for potential security threats.\n\n\n\nFor more information about the types of system extensions you can create, and how to install them, see [doc:\/\/com.apple.systemextensions\/documentation\/SystemExtensions]. \n\n### Communicate with custom hardware using a DriverKit extension\n\nA dext contains the drivers you need to communicate with your company’s custom hardware. A driver provides a layer of services for accessing the hardware. For example, a driver might configure the device, or it might implement a specific interface for communicating with the device. Because dexts are system extensions, they run in user space and you ship them inside your app bundle. \n\nWhen the user attaches a new hardware device to the computer, the kernel searches for any dexts that handle the device. From those dexts, the kernel assembles a series of drivers to communicate with the device. Each new driver builds upon the capabilities of the previous driver, offering new services or configuration options. \n\nApple provides drivers for all standards-based hardware protocols that Mac computers support. Create custom drivers only for the protocols and features unique to your hardware. You can also use a codeless dext to map your hardware to one of Apple’s built-in drivers.\n\n\n\nFor information about how to create and install custom drivers, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/creating-a-driver-using-the-driverkit-sdk].\n\n### Support custom hardware without writing driver code\n\nNot all drivers require actual code. If your hardware communicates entirely using standards-based protocols, you can ship a driver that matches your hardware to one of the built-in system drivers. Shipping a codeless driver requires less effort, and lets you select which driver the system uses for your hardware. \n\nShip a codeless driver in one of the following packages:\n\n- A codeless dext, in which your driver class has no implementation.\n- A codeless kext, which has no executable file. \n\nCreate a codeless dext when the system provides DriverKit support for your hardware. A codeless dext isn’t entirely codeless. It contains a minimal executable file with an empty subclass—that is, a subclass of an existing DriverKit class, where you don’t implement any methods. In the `Info.plist` file of your dext, set the value of the `IOUserClass` key to the name of your custom subclass. At runtime, the system instantiates your class, but all method calls fall through to the implementation of the parent class.\n\nIn the few cases where your driver requires a kernel extension, use a codeless kext to match your hardware to the existing system driver. Unlike a DriverKit extension, a codeless kext doesn’t have an executable file. Instead, its `Info.plist` file provides all the information that the system needs to match your hardware to a system driver.\n\nFor information about how to create and install a dext, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/creating-a-driver-using-the-driverkit-sdk].\n\n### Build kernel extensions with well-known restrictions\n\nKexts run inside the kernel and must support the same architecture and restrictions as other kernel code. \n\n- Kexts on Apple silicon must support the `arm64e` architecture. The `arm64e` architecture includes pointer authentication codes (PACs) to detect and guard against malicious or accidental modifications to pointers in memory. The compiler transparently adds and removes PACs to your code at compile time, but the addition of PACs may require you to adjust how you handle pointers in your kexts. For information about supporting PACs, see [doc:\/\/com.apple.security\/documentation\/Security\/preparing-your-app-to-work-with-pointer-authentication].\n- Kexts run under Kernel Integrity Protection (KIP). After the system initializes the kernel and kexts, KIP locks down the kernel memory pages to prevent modifications to kernel and driver code. For more information about KIP, see [link-3625984].\n\n### Install kernel extensions as the final step in an installer package\n\nIf your custom installer package includes kexts, install them as the final installation step. The system manages kexts differently in macOS 11 and later, requiring a reboot to finish the installation process. As part of the reboot process, users must also explicitly change the security settings of their computer to allow the kext installation. \n\nFor information about the kext installation process, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/installing-a-custom-kernel-extension].\n\n## Kernel Extensions\n\n- **Installing a custom kernel extension**: Install kernel extensions using a custom installer package, and help users understand the installation process.\n- **Debugging a custom kernel extension**: Configure your system to enable the debugging of custom kernel extensions from a second Mac.\n- **Generating a Non-Maskable Interrupt**: Interrupt the kernel on a target Mac and attach a remote debugger to it.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Install kernel extensions using a custom installer package, and help users understand the installation process.",
          "name" : "Installing a custom kernel extension",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/installing-a-custom-kernel-extension"
        },
        {
          "description" : "Configure your system to enable the debugging of custom kernel extensions from a second Mac.",
          "name" : "Debugging a custom kernel extension",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/debugging-a-custom-kernel-extension"
        },
        {
          "description" : "Interrupt the kernel on a target Mac and attach a remote debugger to it.",
          "name" : "Generating a Non-Maskable Interrupt",
          "url" : "https:\/\/developer.apple.com\/documentation\/kernel\/generating_a_non-maskable_interrupt"
        }
      ],
      "title" : "Kernel Extensions"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing drivers, system extensions, and kexts",
  "url" : "https:\/\/developer.apple.com\/documentation\/kernel\/implementing_drivers_system_extensions_and_kexts"
}