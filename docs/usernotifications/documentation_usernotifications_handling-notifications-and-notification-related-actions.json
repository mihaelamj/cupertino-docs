{
  "abstract" : "Respond to user interactions with the system’s notification interfaces, including handling your app’s custom actions.",
  "codeExamples" : [
    {
      "code" : "func userNotificationCenter(_ center: UNUserNotificationCenter,\n            didReceive response: UNNotificationResponse,\n            withCompletionHandler completionHandler: \n               @escaping () -> Void) {\n   \/\/ Get the meeting ID from the original notification.\n   let userInfo = response.notification.request.content.userInfo\n        \n   if response.notification.request.content.categoryIdentifier ==\n              \"MEETING_INVITATION\" {\n      \/\/ Retrieve the meeting details.\n      let meetingID = userInfo[\"MEETING_ID\"] as! String\n      let userID = userInfo[\"USER_ID\"] as! String\n            \n      switch response.actionIdentifier {\n      case \"ACCEPT_ACTION\":\n         sharedMeetingManager.acceptMeeting(user: userID, \n               meetingID: meetingID)\n         break\n                \n      case \"DECLINE_ACTION\":\n         sharedMeetingManager.declineMeeting(user: userID, \n               meetingID: meetingID)\n         break\n                \n      case UNNotificationDefaultActionIdentifier,\n           UNNotificationDismissActionIdentifier:\n         \/\/ Queue meeting-related notifications for later\n         \/\/  if the user does not act.\n         sharedMeetingManager.queueMeetingForDelivery(user: userID,\n               meetingID: meetingID)\n         break\n                \n      default:\n         break\n      }\n   }\n   else {\n      \/\/ Handle other notification types...\n   }\n        \n   \/\/ Always call the completion handler when done.\n   completionHandler()\n}",
      "language" : "swift"
    },
    {
      "code" : "func userNotificationCenter(_ center: UNUserNotificationCenter,\n         willPresent notification: UNNotification,\n         withCompletionHandler completionHandler: \n            @escaping (UNNotificationPresentationOptions) -> Void) {\n   if notification.request.content.categoryIdentifier == \n            \"MEETING_INVITATION\" {\n      \/\/ Retrieve the meeting details.\n      let meetingID = notification.request.content.\n                       userInfo[\"MEETING_ID\"] as! String\n      let userID = notification.request.content.\n                       userInfo[\"USER_ID\"] as! String\n            \n      \/\/ Add the meeting to the queue.\n      sharedMeetingManager.queueMeetingForDelivery(user: userID,\n            meetingID: meetingID)\n\n      \/\/ Play a sound to let the user know about the invitation.\n      completionHandler(.sound)\n      return\n   }\n   else {\n      \/\/ Handle other notification types...\n   }\n\n   \/\/ Don't alert the user for other types.\n   completionHandler(UNNotificationPresentationOptions(rawValue: 0))\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "3d616a73c315e8498f1813c31d3a7d0fa90d61b87d528a6b121b481f1ffff459",
  "crawledAt" : "2025-12-03T04:56:01Z",
  "id" : "B4265E1F-4F4C-4E05-BB5A-47EB11816341",
  "kind" : "article",
  "language" : "swift",
  "module" : "User Notifications",
  "overview" : "## Overview\n\nNotifications are primarily a way of putting information in front of the user, but your app can also respond to them. For example, you might want to respond to:\n\n### Handle user-selected actions\n\nActionable notifications let the user respond to a notification directly from the notification interface. In addition to the notification’s content, an actionable notification displays one or more buttons representing the actions that the user can take. Tapping one of the buttons forwards the selected action to your app, without bringing the app to the foreground. If your app supports actionable notification types, you must handle the associated actions.\n\n\n\nYou handle selected actions from the delegate object of the shared [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenter] object. When the user selects an action, the system launches your app in the background and calls the delegate’s [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenterDelegate\/userNotificationCenter(_:didReceive:withCompletionHandler:)] method. Match the value in the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNNotificationResponse\/actionIdentifier] property of the response object to one of your app’s actions or a system-defined action. The system reports special actions when the user dismisses the notification or launches your app.\n\nListing 1 shows an example that processes actions associated with a meeting invitation. The `ACCEPT_ACTION` and `DECLINE_ACTION` strings identify the app-specific actions, which generate an appropriate response to the meeting invitation. If the user doesn’t choose one of the app-defined actions, the method saves the invitation until the user launches the app.\n\nListing 1. Handling the actions in your actionable notifications\n\n### Handle notifications while your app runs in the foreground\n\nIf a notification arrives when your app is running in the foreground, the system delivers that notification directly to your app. Upon receiving a notification, you can use the notification’s payload to do whatever you want. For example, you can update your app’s interface to reflect new information contained in the notification. You can then suppress any scheduled alerts or modify those alerts.\n\nWhen a notification arrives, the system calls the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenterDelegate\/userNotificationCenter(_:willPresent:withCompletionHandler:)] method of the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenter] object’s delegate. Use that method to process the notification and let the system know how you want it to proceed. Listing 2 shows a version of this method for a calendar app. When a meeting invitation arrives, the app calls its custom `queueMeetingForDelivery` method to show the new invitation in the app’s interface. The app also asks the system to play the notification’s sound by passing the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNNotificationPresentationOptions\/sound] value to the completion handler. For other notification types, the method silences the notification.\n\nListing 2. Processing notifications in the foreground\n\nIf you registered your app with PushKit, notifications targeting PushKit-types are always delivered directly to your app and are never displayed to the user. If your app is in the foreground or background, the system gives your app time to process the notification. If your app isn’t running, the system launches your app in the background so that it can process the notification. To send a PushKit notification, your provider server must set the notification’s topic to the appropriate target, such as your app’s complication. For more information about registering for PushKit notifications, see [doc:\/\/com.apple.documentation\/documentation\/PushKit].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UserNotifications\/handling-notifications-and-notification-related-actions\ncrawled: 2025-12-03T04:56:01Z\n---\n\n# Handling notifications and notification-related actions\n\n**Article**\n\nRespond to user interactions with the system’s notification interfaces, including handling your app’s custom actions.\n\n## Overview\n\nNotifications are primarily a way of putting information in front of the user, but your app can also respond to them. For example, you might want to respond to:\n\n- Actions selected by the user from the notification interface.\n- A notification that arrives when your app is running in the foreground.\n- A silent notification (see [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/pushing-background-updates-to-your-app]).\n- A notification associated with the [doc:\/\/com.apple.documentation\/documentation\/PushKit] framework, such as VoIP or complication-related notifications.\n\n### Handle user-selected actions\n\nActionable notifications let the user respond to a notification directly from the notification interface. In addition to the notification’s content, an actionable notification displays one or more buttons representing the actions that the user can take. Tapping one of the buttons forwards the selected action to your app, without bringing the app to the foreground. If your app supports actionable notification types, you must handle the associated actions.\n\n\n\n\n\nYou handle selected actions from the delegate object of the shared [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenter] object. When the user selects an action, the system launches your app in the background and calls the delegate’s [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenterDelegate\/userNotificationCenter(_:didReceive:withCompletionHandler:)] method. Match the value in the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNNotificationResponse\/actionIdentifier] property of the response object to one of your app’s actions or a system-defined action. The system reports special actions when the user dismisses the notification or launches your app.\n\nListing 1 shows an example that processes actions associated with a meeting invitation. The `ACCEPT_ACTION` and `DECLINE_ACTION` strings identify the app-specific actions, which generate an appropriate response to the meeting invitation. If the user doesn’t choose one of the app-defined actions, the method saves the invitation until the user launches the app.\n\nListing 1. Handling the actions in your actionable notifications\n\n```swift\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n            didReceive response: UNNotificationResponse,\n            withCompletionHandler completionHandler: \n               @escaping () -> Void) {\n   \/\/ Get the meeting ID from the original notification.\n   let userInfo = response.notification.request.content.userInfo\n        \n   if response.notification.request.content.categoryIdentifier ==\n              \"MEETING_INVITATION\" {\n      \/\/ Retrieve the meeting details.\n      let meetingID = userInfo[\"MEETING_ID\"] as! String\n      let userID = userInfo[\"USER_ID\"] as! String\n            \n      switch response.actionIdentifier {\n      case \"ACCEPT_ACTION\":\n         sharedMeetingManager.acceptMeeting(user: userID, \n               meetingID: meetingID)\n         break\n                \n      case \"DECLINE_ACTION\":\n         sharedMeetingManager.declineMeeting(user: userID, \n               meetingID: meetingID)\n         break\n                \n      case UNNotificationDefaultActionIdentifier,\n           UNNotificationDismissActionIdentifier:\n         \/\/ Queue meeting-related notifications for later\n         \/\/  if the user does not act.\n         sharedMeetingManager.queueMeetingForDelivery(user: userID,\n               meetingID: meetingID)\n         break\n                \n      default:\n         break\n      }\n   }\n   else {\n      \/\/ Handle other notification types...\n   }\n        \n   \/\/ Always call the completion handler when done.\n   completionHandler()\n}\n```\n\n### Handle notifications while your app runs in the foreground\n\nIf a notification arrives when your app is running in the foreground, the system delivers that notification directly to your app. Upon receiving a notification, you can use the notification’s payload to do whatever you want. For example, you can update your app’s interface to reflect new information contained in the notification. You can then suppress any scheduled alerts or modify those alerts.\n\nWhen a notification arrives, the system calls the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenterDelegate\/userNotificationCenter(_:willPresent:withCompletionHandler:)] method of the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNUserNotificationCenter] object’s delegate. Use that method to process the notification and let the system know how you want it to proceed. Listing 2 shows a version of this method for a calendar app. When a meeting invitation arrives, the app calls its custom `queueMeetingForDelivery` method to show the new invitation in the app’s interface. The app also asks the system to play the notification’s sound by passing the [doc:\/\/com.apple.usernotifications\/documentation\/UserNotifications\/UNNotificationPresentationOptions\/sound] value to the completion handler. For other notification types, the method silences the notification.\n\nListing 2. Processing notifications in the foreground\n\n```swift\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n         willPresent notification: UNNotification,\n         withCompletionHandler completionHandler: \n            @escaping (UNNotificationPresentationOptions) -> Void) {\n   if notification.request.content.categoryIdentifier == \n            \"MEETING_INVITATION\" {\n      \/\/ Retrieve the meeting details.\n      let meetingID = notification.request.content.\n                       userInfo[\"MEETING_ID\"] as! String\n      let userID = notification.request.content.\n                       userInfo[\"USER_ID\"] as! String\n            \n      \/\/ Add the meeting to the queue.\n      sharedMeetingManager.queueMeetingForDelivery(user: userID,\n            meetingID: meetingID)\n\n      \/\/ Play a sound to let the user know about the invitation.\n      completionHandler(.sound)\n      return\n   }\n   else {\n      \/\/ Handle other notification types...\n   }\n\n   \/\/ Don't alert the user for other types.\n   completionHandler(UNNotificationPresentationOptions(rawValue: 0))\n}\n```\n\nIf you registered your app with PushKit, notifications targeting PushKit-types are always delivered directly to your app and are never displayed to the user. If your app is in the foreground or background, the system gives your app time to process the notification. If your app isn’t running, the system launches your app in the background so that it can process the notification. To send a PushKit notification, your provider server must set the notification’s topic to the appropriate target, such as your app’s complication. For more information about registering for PushKit notifications, see [doc:\/\/com.apple.documentation\/documentation\/PushKit].\n\n## Notification responses\n\n- **UNNotificationResponse**: The user’s response to an actionable notification.\n- **UNTextInputNotificationResponse**: The user’s response to an actionable notification, including any custom text that the user typed or dictated.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The user’s response to an actionable notification.",
          "name" : "UNNotificationResponse",
          "url" : "https:\/\/developer.apple.com\/documentation\/UserNotifications\/UNNotificationResponse"
        },
        {
          "description" : "The user’s response to an actionable notification, including any custom text that the user typed or dictated.",
          "name" : "UNTextInputNotificationResponse",
          "url" : "https:\/\/developer.apple.com\/documentation\/UserNotifications\/UNTextInputNotificationResponse"
        }
      ],
      "title" : "Notification responses"
    }
  ],
  "source" : "appleJSON",
  "title" : "Handling notifications and notification-related actions",
  "url" : "https:\/\/developer.apple.com\/documentation\/UserNotifications\/handling-notifications-and-notification-related-actions"
}