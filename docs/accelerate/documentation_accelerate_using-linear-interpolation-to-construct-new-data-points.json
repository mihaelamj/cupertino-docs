{
  "abstract" : "Fill the gaps in arrays of numerical data using linear interpolation.",
  "codeExamples" : [
    {
      "code" : "let values: [Float] = [50,  90,  55,  10,  40,  85,  65,  15,  30,   80]\nlet indices: [Float] = [0, 113, 227, 341, 455, 568, 682, 796, 910, 1024]",
      "language" : "swift"
    },
    {
      "code" : "let count = 1024",
      "language" : "swift"
    },
    {
      "code" : "let result = vDSP.linearInterpolate(values: values,\n                                    atIndices: indices)",
      "language" : "swift"
    },
    {
      "code" : "let base: Float = 0\nlet end = Float(values.count - 1)\n\nlet control = vDSP.ramp(in: base ... end,\n                        count: count)",
      "language" : "swift"
    },
    {
      "code" : "let result = vDSP.linearInterpolate(elementsOf: values,\n                                    using: control)",
      "language" : "swift"
    },
    {
      "code" : "let denominator = Float(n) \/ Float(values.count - 1)\n\nlet control: [Float] = (0 ... count).map {\n    let x = Float($0) \/ denominator\n    return floor(x) + simd_smoothstep(0, 1, simd_fract(x))\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "e961339059483c28e0bbd5ec771872b6b6da81461ddc5decb2f87295cc4bb895",
  "crawledAt" : "2025-12-02T15:37:14Z",
  "id" : "FC6E128E-E4C3-4050-917C-DF1A8CFCF5FF",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nLinear interpolation is a method of calculating intermediate data between known values by conceptually drawing a straight line between two adjacent known values. An interpolated value is any point along that line. You use linear interpolation to, for example, draw graphs or animate between keyframes. The following figure shows an example interpolated value between two points:\n\n\n\nvDSP provides the following functions to linearly interpolate between the elements in an array:\n\nThis article discusses using these functions to draw a continuous line graph based on a set of discrete data points.\n\n### Create the data\n\nIn this example, the code interpolates the data that the `values` and `indices` arrays represent.\n\nEach array consists of 10 elements. A pair of corresponding elements in the two arrays defines a single point in the diagram as follows:\n\n\n\n### Define the constant that represents the number of elements\n\nThe following code defines `count` as the number of elements in the interpolation result:\n\n### Generate a vector by interpolation\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(values:atIndices:)-5mbnu] function accepts the `values` and `indices` arrays and returns the interpolation result.\n\nOn return, `result` contains the interpolated values. The following graph shows the values in `result` as a line between the known values that the `values` and `indices` arrays describe:\n\n\n\n### Interpolate with fine control\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] function requires a control vector array that includes fractional parts. The fractional parts define the interpolation between the pair of values in the `values` array, starting at the index that the integer part defines.\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-79aw7] to generate a linear ramp from `0` to the number of elements in `values`, minus `1`. Note that the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-79aw7] function wraps [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vgen].\n\nOn return, `control` contains the following:\n\n        `[0]\tFloat\t0.0000`\n\n        `[1]\tFloat\t0.0087`\n\n        `[2]\tFloat\t0.0175`\n\n        `...`\n\n        `[1021]\tFloat\t8.9824`\n\n        `[1022]\tFloat\t8.9912`\n\n        `[1023]\tFloat\t9.0000`\n\nThe following figure shows a visualization of the values in `control`, with small circles indicating each integer index:\n\n\n\nThe following code passes the control values to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] to calculate the interpolated values:\n\nOn return, `result` contains the interpolated values. The graph below shows the values in `result` as a line between the known values that the `values` and `indices` arrays describe:\n\n\n\nThe result of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] is equal to the result of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(values:atIndices:)-5mbnu].\n\n### Add smoothing to the interpolation result\n\nYou can change the way that you generate the control array to alter the interpolated result. For example, you may want to add smoothing between the segments of a line graph or add easing to an animation. The following code uses [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_smoothstep(_:_:_:)-993b1] to smooth the fractional parts of `control` near the increments to the integer parts:\n\nThe following graph shows a visualization of the values in `control`, with small circles indicating each integer index:\n\n\n\nUsing the same call to  [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] as above, the result, as shown below, shows a smoother transition between the known values.\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/using-linear-interpolation-to-construct-new-data-points\ncrawled: 2025-12-02T15:37:14Z\n---\n\n# Using linear interpolation to construct new data points\n\n**Article**\n\nFill the gaps in arrays of numerical data using linear interpolation.\n\n## Overview\n\nLinear interpolation is a method of calculating intermediate data between known values by conceptually drawing a straight line between two adjacent known values. An interpolated value is any point along that line. You use linear interpolation to, for example, draw graphs or animate between keyframes. The following figure shows an example interpolated value between two points:\n\n\n\nvDSP provides the following functions to linearly interpolate between the elements in an array:\n\n- The single-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(values:atIndices:)-5mbnu] and the double-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(values:atIndices:)-9rxb4] that provide a simple interface for generating interpolated data. These functions wrap [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vgenp] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vgenpD], respectively.\n- The single-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] and the double-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-5i3jc] that provide fine control over the interpolation. These functions wrap [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vlint] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vlintD], respectively.\n\nThis article discusses using these functions to draw a continuous line graph based on a set of discrete data points.\n\n### Create the data\n\nIn this example, the code interpolates the data that the `values` and `indices` arrays represent.\n\n```swift\nlet values: [Float] = [50,  90,  55,  10,  40,  85,  65,  15,  30,   80]\nlet indices: [Float] = [0, 113, 227, 341, 455, 568, 682, 796, 910, 1024]\n```\n\nEach array consists of 10 elements. A pair of corresponding elements in the two arrays defines a single point in the diagram as follows:\n\n- Elements in the `values` array denote the vertical position.\n- Elements in the `indices` array denote the horizontal position.\n\n\n\n### Define the constant that represents the number of elements\n\nThe following code defines `count` as the number of elements in the interpolation result:\n\n```swift\nlet count = 1024\n```\n\n### Generate a vector by interpolation\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(values:atIndices:)-5mbnu] function accepts the `values` and `indices` arrays and returns the interpolation result.\n\n```swift\nlet result = vDSP.linearInterpolate(values: values,\n                                    atIndices: indices)\n```\n\nOn return, `result` contains the interpolated values. The following graph shows the values in `result` as a line between the known values that the `values` and `indices` arrays describe:\n\n\n\n### Interpolate with fine control\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] function requires a control vector array that includes fractional parts. The fractional parts define the interpolation between the pair of values in the `values` array, starting at the index that the integer part defines.\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-79aw7] to generate a linear ramp from `0` to the number of elements in `values`, minus `1`. Note that the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-79aw7] function wraps [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vgen].\n\n```swift\nlet base: Float = 0\nlet end = Float(values.count - 1)\n\nlet control = vDSP.ramp(in: base ... end,\n                        count: count)\n```\n\nOn return, `control` contains the following:\n\n        `[0]\tFloat\t0.0000`\n\n        `[1]\tFloat\t0.0087`\n\n        `[2]\tFloat\t0.0175`\n\n        `...`\n\n        `[1021]\tFloat\t8.9824`\n\n        `[1022]\tFloat\t8.9912`\n\n        `[1023]\tFloat\t9.0000`\n\nThe following figure shows a visualization of the values in `control`, with small circles indicating each integer index:\n\n\n\nThe following code passes the control values to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] to calculate the interpolated values:\n\n```swift\nlet result = vDSP.linearInterpolate(elementsOf: values,\n                                    using: control)\n```\n\nOn return, `result` contains the interpolated values. The graph below shows the values in `result` as a line between the known values that the `values` and `indices` arrays describe:\n\n\n\nThe result of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] is equal to the result of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(values:atIndices:)-5mbnu].\n\n### Add smoothing to the interpolation result\n\nYou can change the way that you generate the control array to alter the interpolated result. For example, you may want to add smoothing between the segments of a line graph or add easing to an animation. The following code uses [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_smoothstep(_:_:_:)-993b1] to smooth the fractional parts of `control` near the increments to the integer parts:\n\n```swift\nlet denominator = Float(n) \/ Float(values.count - 1)\n\nlet control: [Float] = (0 ... count).map {\n    let x = Float($0) \/ denominator\n    return floor(x) + simd_smoothstep(0, 1, simd_fract(x))\n}\n```\n\nThe following graph shows a visualization of the values in `control`, with small circles indicating each integer index:\n\n\n\nUsing the same call to  [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c] as above, the result, as shown below, shows a smoother transition between the known values.\n\n\n\n## Signal Processing Essentials\n\n- **Controlling vDSP operations with stride**: Operate selectively on the elements of a vector at regular intervals.\n- **Using vDSP for vector-based arithmetic**: Increase the performance of common mathematical tasks with vDSP vector-vector and vector-scalar operations.\n- **Resampling a signal with decimation**: Reduce the sample rate of a signal by specifying a decimation factor and applying a custom antialiasing filter.\n- **vDSP**: Perform basic arithmetic operations and common digital signal processing (DSP) routines on large vectors.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Operate selectively on the elements of a vector at regular intervals.",
          "name" : "Controlling vDSP operations with stride",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/controlling-vdsp-operations-with-stride"
        },
        {
          "description" : "Increase the performance of common mathematical tasks with vDSP vector-vector and vector-scalar operations.",
          "name" : "Using vDSP for vector-based arithmetic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-vdsp-for-vector-based-arithmetic"
        },
        {
          "description" : "Reduce the sample rate of a signal by specifying a decimation factor and applying a custom antialiasing filter.",
          "name" : "Resampling a signal with decimation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/resampling-a-signal-with-decimation"
        },
        {
          "description" : "Perform basic arithmetic operations and common digital signal processing (DSP) routines on large vectors.",
          "name" : "vDSP",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vdsp-library"
        }
      ],
      "title" : "Signal Processing Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Using linear interpolation to construct new data points",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-linear-interpolation-to-construct-new-data-points"
}