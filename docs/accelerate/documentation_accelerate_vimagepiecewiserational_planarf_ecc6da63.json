{
  "abstract" : "Applies a set of piecewise rational expressions to transform a 32-bit planar image.",
  "codeExamples" : [
    {
      "code" : "let source = vImage.PixelBuffer<vImage.PlanarF>(\n    pixelValues: [0.2, 0.4, 0.6, 0.8, 1],\n    size: vImage.Size(width: 5, height: 1))\n\nlet destination = vImage.PixelBuffer<vImage.PlanarF>(\n    size: source.size)\n\n\/\/ 0.0 * x⁰ + 0.5 * x¹ + 0.0 * x²\nlet topCoefficients: [Float] = [0.0, 0.5, 0.0]\nlet topOrder = UInt32(topCoefficients.count - 1)\n\n\/\/ 0.0 * x⁰ + 0.0 * x¹ + 1.0 * x² + 0.2 * x³\nlet bottomCoefficients: [Float] = [0.0, 0.0, 1.0, 0.2]\nlet bottomOrder = UInt32(bottomCoefficients.count - 1)\n\nlet boundaries: [Float] = [-.infinity, .infinity]\n\nlet log2segments = UInt32(0)\n\ntopCoefficients.withUnsafeBufferPointer { topCoefficientsPtr in\n    bottomCoefficients.withUnsafeBufferPointer { bottomCoefficientsPtr in\n        source.withUnsafePointerToVImageBuffer { src in\n            destination.withUnsafePointerToVImageBuffer { dest in\n                \n                var topCoeffs = [ topCoefficientsPtr.baseAddress ]\n                var bottomCoeffs = [ bottomCoefficientsPtr.baseAddress ]\n                \n                vImagePiecewiseRational_PlanarF(\n                    src,\n                    dest,\n                    &topCoeffs,\n                    &bottomCoeffs,\n                    boundaries,\n                    topOrder,\n                    bottomOrder,\n                    log2segments,\n                    vImage_Flags(kvImageNoFlags))\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let result = source.array.map { x in\n    \n    let numerator = topCoefficients[0] * pow(x, 0) +\n                    topCoefficients[1] * pow(x, 1) +\n                    topCoefficients[2] * pow(x, 2)\n    \n    let denominator = bottomCoefficients[0] * pow(x, 0) +\n                      bottomCoefficients[1] * pow(x, 1) +\n                      bottomCoefficients[2] * pow(x, 2) +\n                      bottomCoefficients[3] * pow(x, 3)\n    \n    return numerator \/ denominator\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "a14dc078ed2595f9a7f395302eb9400dd260793ff94a3cdcc2fe206a1da122ee",
  "crawledAt" : "2025-12-03T20:55:16Z",
  "declaration" : {
    "code" : "func vImagePiecewiseRational_PlanarF(_ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ topCoefficients: UnsafeMutablePointer<UnsafePointer<Float>?>, _ bottomCoefficients: UnsafeMutablePointer<UnsafePointer<Float>?>, _ boundaries: UnsafePointer<Float>, _ topOrder: UInt32, _ bottomOrder: UInt32, _ log2segments: UInt32, _ flags: vImage_Flags) -> vImage_Error",
    "language" : "swift"
  },
  "id" : "C4760CD8-7AAA-4461-8C41-E3158CE858E1",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\n[doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageNoError]; otherwise, one of the error codes in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/data-types-and-constants].\n\n## Discussion\n\nYou can approximate many different correction functions by carefully choosing the polynomials and the ranges of input values they operate on. For example, the sample code project [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-tone-curve-adjustments-to-images] demonstrates how to apply tone curve adjustments to images using polynomial transforms.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePiecewiseRational_PlanarF(_:_:_:_:_:_:_:_:_:)] function evaluates polynomials similarly to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePiecewisePolynomial_PlanarF(_:_:_:_:_:_:_:)], but works with two sets of polynomials the `topCoefficients` and `bottomCoefficients` parameters specify. The function writes the result of evaluating the top polynomials divided by the result of evaluating the bottom polynomials to the destination pixel.\n\nThe following code defines two sets of polynomial coefficients, `topCoefficients` as `[0.0, 0.5, 0.0]` and `bottomCoefficients` as `[0.0, 0.0, 1.0, 0.2]`. The result of the expression for each pixel is (`0.0 * x⁰ + 0.5 * x¹ + 0.0 * x²) \/ (0.0 * x⁰ + 0.0 * x¹ + 1.0 * x² + 0.2 * x³)`.\n\nNote that this function allows the top and bottom polynomials to be of different orders. This example defines the boundaries array as `[-.infinity, .infinity]` so that a single rational expression covers pixels of any value.\n\nOn return, the destination buffer contains the values `[2.4038463, 1.1574074, 0.7440475, 0.53879315, 0.41666666]`. This is equivalent to the following scalar code:\n\nThis function doesn’t deliver IEEE-754 correct division and doesn’t round per the IEEE-754 current rounding mode. It incurs up to two units in the last place of error. This function returns undefined results for edge cases that include denormals, infinities, NaNs, and division by zero.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/vImagePiecewiseRational_PlanarF(_:_:_:_:_:_:_:_:_:)\ncrawled: 2025-12-03T20:55:16Z\n---\n\n# vImagePiecewiseRational_PlanarF(_:_:_:_:_:_:_:_:_:)\n\n**Function**\n\nApplies a set of piecewise rational expressions to transform a 32-bit planar image.\n\n## Declaration\n\n```swift\nfunc vImagePiecewiseRational_PlanarF(_ src: UnsafePointer<vImage_Buffer>, _ dest: UnsafePointer<vImage_Buffer>, _ topCoefficients: UnsafeMutablePointer<UnsafePointer<Float>?>, _ bottomCoefficients: UnsafeMutablePointer<UnsafePointer<Float>?>, _ boundaries: UnsafePointer<Float>, _ topOrder: UInt32, _ bottomOrder: UInt32, _ log2segments: UInt32, _ flags: vImage_Flags) -> vImage_Error\n```\n\n## Parameters\n\n- **src**: The source vImage buffer.\n- **dest**: A pointer to the destination vImage buffer structure. You’re responsible for filling out the `height`, `width`, and `rowBytes` fields of this structure, and for allocating a data buffer of the appropriate size. On return, the data buffer this structure points to contains the destination image data. When you no longer need the data buffer, deallocate the memory to prevent memory leaks.\n- **topCoefficients**: A pointer to an array of numerator polynomial coefficient arrays. Each polynomial coefficient array contains the coefficients for one polynomial. A polynomial of order `R` has `R+1` coefficients, and all of the polynomials in this array must have the same order.\n\nOrder the coefficients from the zeroth-order term to the highest order term. For example, the function evaluates the coefficients `[0.5, 0.6, 0.7]` as `0.5 * x⁰ + 0.6 * x¹ + 0.7 * x²`.\n- **bottomCoefficients**: A pointer to an array of denominator polynomial coefficient arrays. Each polynomial coefficient array contains the coefficients for one polynomial. A polynomial of order `R` has `R+1` coefficients, and all of the polynomials in this array must have the same order.\n\nOrder the coefficients from the zeroth-order term to the highest order term. For example, the function evaluates the coefficients `[0.5, 0.6, 0.7]` as `0.5 * x⁰ + 0.6 * x¹ + 0.7 * x²`.\n- **boundaries**: A pointer to an array of boundary values, in increasing order, that separates adjacent ranges of pixel values. The first boundary value is the lowest in the range and the function clips input values lower than this to this value. The last boundary value is the highest in the range and the function clips input values higher than this to this value. The boundary values between the first and last separate the subranges from each other.\n- **topOrder**: The order of the numerator polynomials.\n- **bottomOrder**: The order of the denominator polynomials.\n- **log2segments**: The number of rational expressions to represent as a base-2 logarithm. If you pass a noninteger power-of-two number of polynomials, round up to the next integer power of two, and repeat the last expression the appropriate number of times.\n- **flags**: The options to use when performing the operation. If your code implements its own tiling or its own multithreading, pass [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageDoNotTile]; otherwise, pass [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageNoFlags].\n\n## Return Value\n\n[doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageNoError]; otherwise, one of the error codes in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/data-types-and-constants].\n\n## Discussion\n\nYou can approximate many different correction functions by carefully choosing the polynomials and the ranges of input values they operate on. For example, the sample code project [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-tone-curve-adjustments-to-images] demonstrates how to apply tone curve adjustments to images using polynomial transforms.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePiecewiseRational_PlanarF(_:_:_:_:_:_:_:_:_:)] function evaluates polynomials similarly to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePiecewisePolynomial_PlanarF(_:_:_:_:_:_:_:)], but works with two sets of polynomials the `topCoefficients` and `bottomCoefficients` parameters specify. The function writes the result of evaluating the top polynomials divided by the result of evaluating the bottom polynomials to the destination pixel.\n\nThe following code defines two sets of polynomial coefficients, `topCoefficients` as `[0.0, 0.5, 0.0]` and `bottomCoefficients` as `[0.0, 0.0, 1.0, 0.2]`. The result of the expression for each pixel is (`0.0 * x⁰ + 0.5 * x¹ + 0.0 * x²) \/ (0.0 * x⁰ + 0.0 * x¹ + 1.0 * x² + 0.2 * x³)`.\n\nNote that this function allows the top and bottom polynomials to be of different orders. This example defines the boundaries array as `[-.infinity, .infinity]` so that a single rational expression covers pixels of any value.\n\n```swift\nlet source = vImage.PixelBuffer<vImage.PlanarF>(\n    pixelValues: [0.2, 0.4, 0.6, 0.8, 1],\n    size: vImage.Size(width: 5, height: 1))\n\nlet destination = vImage.PixelBuffer<vImage.PlanarF>(\n    size: source.size)\n\n\/\/ 0.0 * x⁰ + 0.5 * x¹ + 0.0 * x²\nlet topCoefficients: [Float] = [0.0, 0.5, 0.0]\nlet topOrder = UInt32(topCoefficients.count - 1)\n\n\/\/ 0.0 * x⁰ + 0.0 * x¹ + 1.0 * x² + 0.2 * x³\nlet bottomCoefficients: [Float] = [0.0, 0.0, 1.0, 0.2]\nlet bottomOrder = UInt32(bottomCoefficients.count - 1)\n\nlet boundaries: [Float] = [-.infinity, .infinity]\n\nlet log2segments = UInt32(0)\n\ntopCoefficients.withUnsafeBufferPointer { topCoefficientsPtr in\n    bottomCoefficients.withUnsafeBufferPointer { bottomCoefficientsPtr in\n        source.withUnsafePointerToVImageBuffer { src in\n            destination.withUnsafePointerToVImageBuffer { dest in\n                \n                var topCoeffs = [ topCoefficientsPtr.baseAddress ]\n                var bottomCoeffs = [ bottomCoefficientsPtr.baseAddress ]\n                \n                vImagePiecewiseRational_PlanarF(\n                    src,\n                    dest,\n                    &topCoeffs,\n                    &bottomCoeffs,\n                    boundaries,\n                    topOrder,\n                    bottomOrder,\n                    log2segments,\n                    vImage_Flags(kvImageNoFlags))\n            }\n        }\n    }\n}\n```\n\nOn return, the destination buffer contains the values `[2.4038463, 1.1574074, 0.7440475, 0.53879315, 0.41666666]`. This is equivalent to the following scalar code:\n\n```swift\nlet result = source.array.map { x in\n    \n    let numerator = topCoefficients[0] * pow(x, 0) +\n                    topCoefficients[1] * pow(x, 1) +\n                    topCoefficients[2] * pow(x, 2)\n    \n    let denominator = bottomCoefficients[0] * pow(x, 0) +\n                      bottomCoefficients[1] * pow(x, 1) +\n                      bottomCoefficients[2] * pow(x, 2) +\n                      bottomCoefficients[3] * pow(x, 3)\n    \n    return numerator \/ denominator\n}\n```\n\nThis function doesn’t deliver IEEE-754 correct division and doesn’t round per the IEEE-754 current rounding mode. It incurs up to two units in the last place of error. This function returns undefined results for edge cases that include denormals, infinities, NaNs, and division by zero.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "vImagePiecewiseRational_PlanarF(_:_:_:_:_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vImagePiecewiseRational_PlanarF(_:_:_:_:_:_:_:_:_:)"
}