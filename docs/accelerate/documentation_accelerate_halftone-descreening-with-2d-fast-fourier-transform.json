{
  "abstract" : "Reduce or remove periodic artifacts from images.",
  "codeExamples" : [
    {
      "code" : "let pixelsStorage = UnsafeMutableBufferPointer<Float>.allocate(capacity: pixelCount)\ndefer {\n    pixelsStorage.deallocate()\n}\n\nvar tmpBuffer = vImage_Buffer(\n    data: pixelsStorage.baseAddress,\n    height: vImagePixelCount(cgImage.height),\n    width: vImagePixelCount(cgImage.width),\n    rowBytes: cgImage.width * MemoryLayout<Float>.stride)\n\nvImageBuffer_InitWithCGImage(\n    &tmpBuffer,\n    &Self.imageFormat,\n    [0, 0, 0, 0],\n    cgImage,\n    vImage_Flags(kvImageNoAllocate))",
      "language" : "swift"
    },
    {
      "code" : "pixelsStorage.withMemoryRebound(to: DSPComplex.self) {\n    \n    vDSP_ctoz([DSPComplex]($0), 2,\n              &self.dspSplitComplex, 1,\n              vDSP_Length(complexValuesCount))\n}",
      "language" : "swift"
    },
    {
      "code" : "static let fftSetUp = vDSP.FFT2D(width: imageWidth,\n                                 height: imageHeight,\n                                 ofType: DSPSplitComplex.self)!",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ The `SplitComplex` structure that stores the source image frequency-domain pixels.\nvar imageFrequencyDomainPixels = SplitComplex(count: HalftoneDescreener.complexValuesCount)\n\n\/\/\/ The `SplitComplex` structure that stores the halftone sample frequency-domain pixels.\nvar halftoneFrequencyDomainPixels = SplitComplex(count: HalftoneDescreener.complexValuesCount)\n\n\/\/\/ The array that stores the square magnitudes of the halftone frequency-domain values.\nvar halftoneSampleAmplitudes = [Float](repeating: 0,\n                                       count: HalftoneDescreener.complexValuesCount)",
      "language" : "swift"
    },
    {
      "code" : "fftSetUp.transform(input: imagePixels.dspSplitComplex,\n                   output: &imageFrequencyDomainPixels.dspSplitComplex,\n                   direction: .forward)\n\nfftSetUp.transform(input: halftonePixels.dspSplitComplex,\n                   output: &halftoneFrequencyDomainPixels.dspSplitComplex,\n                   direction: .forward)\n\nvDSP.squareMagnitudes(halftoneFrequencyDomainPixels.dspSplitComplex,\n                      result: &halftoneSampleAmplitudes)",
      "language" : "swift"
    },
    {
      "code" : "let outputConstant: Float = -1\n\nvDSP.threshold(halftoneSampleAmplitudes,\n               to: threshold,\n               with: .signedConstant(outputConstant),\n               result: &halftoneSampleAmplitudes)",
      "language" : "swift"
    },
    {
      "code" : "vDSP.clip(halftoneSampleAmplitudes,\n          to: 0 ... 1,\n          result: &halftoneSampleAmplitudes)",
      "language" : "swift"
    },
    {
      "code" : "vDSP.multiply(imageFrequencyDomainPixels.dspSplitComplex,\n              by: halftoneSampleAmplitudes,\n              result: &imageFrequencyDomainPixels.dspSplitComplex)",
      "language" : "swift"
    },
    {
      "code" : "fftSetUp.transform(input: imageFrequencyDomainPixels.dspSplitComplex,\n                   output: &destinationSpatialDomainPixels.dspSplitComplex,\n                   direction: .inverse)",
      "language" : "swift"
    },
    {
      "code" : "var floatPixels = [Float](fromSplitComplex: self.dspSplitComplex,\n                          scale: 1 \/ Float(count),\n                          count: count * 2)\n\nreturn floatPixels.withUnsafeMutableBytes {\n    let tmpBuffer = vImage_Buffer(\n        data: $0.baseAddress,\n        height: vImagePixelCount(HalftoneDescreener.imageHeight),\n        width: vImagePixelCount(HalftoneDescreener.imageWidth),\n        rowBytes: HalftoneDescreener.imageWidth * MemoryLayout<Float>.stride)\n    \n    return try! tmpBuffer.createCGImage(format: SplitComplex.imageFormat)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "bc79997bd00623d8607e595bbe6a73fca7a76bc5e12e2f3b7a4dea9024281880",
  "crawledAt" : "2025-12-02T15:46:05Z",
  "id" : "6B42FB05-6774-49D4-8275-D0B09100477F",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nAccelerate’s vDSP module provides functions to perform 2D fast Fourier transforms (FFTs) on matrices of data, such as images. You can exploit the amplitude peaks in the frequency domain of periodic patterns, such as halftone screens, to reduce or remove such artifacts from images. The example below shows an image with halftone artifacts (left) and the same image with the halftone artifacts reduced (right):\n\n\n\nThe sample app reduces halftone artifacts from a source image by first performing forward FFTs on the image and a halftone screen sample. The following image shows the positive frequencies of the halftone sample’s frequency-domain representation. For more information on performing Fourier transforms on 2D data, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms].\n\n\n\nThe descreening operation zeroes frequency-domain values in the source image that correspond to the bright peaks in the halftone sample’s frequency-domain values.\n\n### Convert the image data to a split-complex vector\n\nThe vImage [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageBuffer_InitWithCGImage(_:_:_:_:_:)] function converts the source Core Graphics image to an array of single-precision values. The sample app creates its own backing storage, `pixelsStorage`, rather than using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageBuffer_Init(_:_:_:_:_:)] to ensure that the vImage buffer doesn’t contain any additional padding bytes.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] function converts the interleaved pixel values to split-complex format. The function copies odd-numbered pixels to the real parts and the even-numbered pixels to the imaginary parts of each complex value.\n\n### Create the FFT setup object\n\nThe sample app creates an FFT setup object that contains all the information required to perform the forward and inverse 2D FFT operations. Creating this setup object can be expensive, so the sample only performs this initialization once.\n\nThe following code creates a setup object suitable for performing forward and inverse 2D FFTs on a 1024 x 1024 pixel image:\n\n### Prepare arrays for transformed image data\n\nRather than allocating and deallocating memory with each call to the descreening code, the sample app declares several `SplitComplex` structures and an array that the descreening operation uses.\n\n### Perform forward 2D FFTs on the image data\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/FFT\/transform(input:output:direction:)] function performs a forward 2D FFT on the image data, and creates the frequency-domain representation of the image.\n\nThe following code performs the FFT on the source image and the halftone sample data. After the code completes the forward FFT of the halftone sample, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/squareMagnitudes(_:result:)-22k5h] function computes the magnitudes of the complex values representing the halftone sample:\n\n### Zero the peaks in the halftone sample magnitude\n\nThe sample app reduces the halftone screen artifacts by manipulating the magnitude of the frequency-domain data for the halftone sample.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/threshold(_:to:with:)-77g7l] function sets all magnitude values that are over the threshold to -1, and all magnitude values that are less than or equal to the threshold to 1:\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/clip(_:to:result:)-3lbii] function clips the values in the `halftoneSampleAmplitude`, setting all of the high-magnitude values to `0.0`, and all of the low-magnitude values to `1.0`.\n\n### Descreen the source image\n\nThe app multiplies the frequency-domain data of the source image by the values in `halftoneSampleAmplitude`, thus removing or reducing the halftone screen.\n\n### Perform an inverse 2D FFT on the frequency domain data\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/FFT\/transform(input:output:direction:)] function performs an inverse FFT on the frequency-domain image data to generate the descreened spatial-domain image.\n\n### Generate an image from the split-complex vector\n\nFinally, the app creates a displayable image from the spatial-domain representation of the treated source image.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform\ncrawled: 2025-12-02T15:46:05Z\n---\n\n# Halftone descreening with 2D fast Fourier transform\n\n**Sample Code**\n\nReduce or remove periodic artifacts from images.\n\n## Overview\n\nAccelerate’s vDSP module provides functions to perform 2D fast Fourier transforms (FFTs) on matrices of data, such as images. You can exploit the amplitude peaks in the frequency domain of periodic patterns, such as halftone screens, to reduce or remove such artifacts from images. The example below shows an image with halftone artifacts (left) and the same image with the halftone artifacts reduced (right):\n\n\n\nThe sample app reduces halftone artifacts from a source image by first performing forward FFTs on the image and a halftone screen sample. The following image shows the positive frequencies of the halftone sample’s frequency-domain representation. For more information on performing Fourier transforms on 2D data, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms].\n\n\n\nThe descreening operation zeroes frequency-domain values in the source image that correspond to the bright peaks in the halftone sample’s frequency-domain values.\n\n### Convert the image data to a split-complex vector\n\nThe vImage [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageBuffer_InitWithCGImage(_:_:_:_:_:)] function converts the source Core Graphics image to an array of single-precision values. The sample app creates its own backing storage, `pixelsStorage`, rather than using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageBuffer_Init(_:_:_:_:_:)] to ensure that the vImage buffer doesn’t contain any additional padding bytes.\n\n```swift\nlet pixelsStorage = UnsafeMutableBufferPointer<Float>.allocate(capacity: pixelCount)\ndefer {\n    pixelsStorage.deallocate()\n}\n\nvar tmpBuffer = vImage_Buffer(\n    data: pixelsStorage.baseAddress,\n    height: vImagePixelCount(cgImage.height),\n    width: vImagePixelCount(cgImage.width),\n    rowBytes: cgImage.width * MemoryLayout<Float>.stride)\n\nvImageBuffer_InitWithCGImage(\n    &tmpBuffer,\n    &Self.imageFormat,\n    [0, 0, 0, 0],\n    cgImage,\n    vImage_Flags(kvImageNoAllocate))\n```\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] function converts the interleaved pixel values to split-complex format. The function copies odd-numbered pixels to the real parts and the even-numbered pixels to the imaginary parts of each complex value.\n\n```swift\npixelsStorage.withMemoryRebound(to: DSPComplex.self) {\n    \n    vDSP_ctoz([DSPComplex]($0), 2,\n              &self.dspSplitComplex, 1,\n              vDSP_Length(complexValuesCount))\n}\n```\n\n### Create the FFT setup object\n\nThe sample app creates an FFT setup object that contains all the information required to perform the forward and inverse 2D FFT operations. Creating this setup object can be expensive, so the sample only performs this initialization once.\n\nThe following code creates a setup object suitable for performing forward and inverse 2D FFTs on a 1024 x 1024 pixel image:\n\n```swift\nstatic let fftSetUp = vDSP.FFT2D(width: imageWidth,\n                                 height: imageHeight,\n                                 ofType: DSPSplitComplex.self)!\n```\n\n### Prepare arrays for transformed image data\n\nRather than allocating and deallocating memory with each call to the descreening code, the sample app declares several `SplitComplex` structures and an array that the descreening operation uses.\n\n```swift\n\/\/\/ The `SplitComplex` structure that stores the source image frequency-domain pixels.\nvar imageFrequencyDomainPixels = SplitComplex(count: HalftoneDescreener.complexValuesCount)\n\n\/\/\/ The `SplitComplex` structure that stores the halftone sample frequency-domain pixels.\nvar halftoneFrequencyDomainPixels = SplitComplex(count: HalftoneDescreener.complexValuesCount)\n\n\/\/\/ The array that stores the square magnitudes of the halftone frequency-domain values.\nvar halftoneSampleAmplitudes = [Float](repeating: 0,\n                                       count: HalftoneDescreener.complexValuesCount)\n```\n\n### Perform forward 2D FFTs on the image data\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/FFT\/transform(input:output:direction:)] function performs a forward 2D FFT on the image data, and creates the frequency-domain representation of the image.\n\nThe following code performs the FFT on the source image and the halftone sample data. After the code completes the forward FFT of the halftone sample, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/squareMagnitudes(_:result:)-22k5h] function computes the magnitudes of the complex values representing the halftone sample:\n\n```swift\nfftSetUp.transform(input: imagePixels.dspSplitComplex,\n                   output: &imageFrequencyDomainPixels.dspSplitComplex,\n                   direction: .forward)\n\nfftSetUp.transform(input: halftonePixels.dspSplitComplex,\n                   output: &halftoneFrequencyDomainPixels.dspSplitComplex,\n                   direction: .forward)\n\nvDSP.squareMagnitudes(halftoneFrequencyDomainPixels.dspSplitComplex,\n                      result: &halftoneSampleAmplitudes)\n```\n\n### Zero the peaks in the halftone sample magnitude\n\nThe sample app reduces the halftone screen artifacts by manipulating the magnitude of the frequency-domain data for the halftone sample.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/threshold(_:to:with:)-77g7l] function sets all magnitude values that are over the threshold to -1, and all magnitude values that are less than or equal to the threshold to 1:\n\n```swift\nlet outputConstant: Float = -1\n\nvDSP.threshold(halftoneSampleAmplitudes,\n               to: threshold,\n               with: .signedConstant(outputConstant),\n               result: &halftoneSampleAmplitudes)\n```\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/clip(_:to:result:)-3lbii] function clips the values in the `halftoneSampleAmplitude`, setting all of the high-magnitude values to `0.0`, and all of the low-magnitude values to `1.0`.\n\n```swift\nvDSP.clip(halftoneSampleAmplitudes,\n          to: 0 ... 1,\n          result: &halftoneSampleAmplitudes)\n```\n\n### Descreen the source image\n\nThe app multiplies the frequency-domain data of the source image by the values in `halftoneSampleAmplitude`, thus removing or reducing the halftone screen.\n\n```swift\nvDSP.multiply(imageFrequencyDomainPixels.dspSplitComplex,\n              by: halftoneSampleAmplitudes,\n              result: &imageFrequencyDomainPixels.dspSplitComplex)\n```\n\n### Perform an inverse 2D FFT on the frequency domain data\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/FFT\/transform(input:output:direction:)] function performs an inverse FFT on the frequency-domain image data to generate the descreened spatial-domain image.\n\n```swift\nfftSetUp.transform(input: imageFrequencyDomainPixels.dspSplitComplex,\n                   output: &destinationSpatialDomainPixels.dspSplitComplex,\n                   direction: .inverse)\n```\n\n### Generate an image from the split-complex vector\n\nFinally, the app creates a displayable image from the spatial-domain representation of the treated source image.\n\n```swift\nvar floatPixels = [Float](fromSplitComplex: self.dspSplitComplex,\n                          scale: 1 \/ Float(count),\n                          count: count * 2)\n\nreturn floatPixels.withUnsafeMutableBytes {\n    let tmpBuffer = vImage_Buffer(\n        data: $0.baseAddress,\n        height: vImagePixelCount(HalftoneDescreener.imageHeight),\n        width: vImagePixelCount(HalftoneDescreener.imageWidth),\n        rowBytes: HalftoneDescreener.imageWidth * MemoryLayout<Float>.stride)\n    \n    return try! tmpBuffer.createCGImage(format: SplitComplex.imageFormat)\n}\n```\n\n## Fourier and Cosine Transforms\n\n- **Understanding data packing for Fourier transforms**: Format source data for the vDSP Fourier functions, and interpret the results.\n- **Finding the component frequencies in a composite sine wave**: Use 1D fast Fourier transform to compute the frequency components of a signal.\n- **Performing Fourier transforms on interleaved-complex data**: Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.\n- **Reducing spectral leakage with windowing**: Multiply signal data by window sequence values when performing transforms with noninteger period signals.\n- **Signal extraction from noise**: Use Accelerate’s discrete cosine transform to remove noise from a signal.\n- **Performing Fourier Transforms on Multiple Signals**: Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.\n- **Fast Fourier transforms**: Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Fourier transforms**: Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Format source data for the vDSP Fourier functions, and interpret the results.",
          "name" : "Understanding data packing for Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms"
        },
        {
          "description" : "Use 1D fast Fourier transform to compute the frequency components of a signal.",
          "name" : "Finding the component frequencies in a composite sine wave",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave"
        },
        {
          "description" : "Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.",
          "name" : "Performing Fourier transforms on interleaved-complex data",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data"
        },
        {
          "description" : "Multiply signal data by window sequence values when performing transforms with noninteger period signals.",
          "name" : "Reducing spectral leakage with windowing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing"
        },
        {
          "description" : "Use Accelerate’s discrete cosine transform to remove noise from a signal.",
          "name" : "Signal extraction from noise",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise"
        },
        {
          "description" : "Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.",
          "name" : "Performing Fourier Transforms on Multiple Signals",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals"
        },
        {
          "description" : "Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Fast Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/fast-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Discrete Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Fourier and Cosine Transforms"
    }
  ],
  "source" : "appleJSON",
  "title" : "Halftone descreening with 2D fast Fourier transform",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform"
}