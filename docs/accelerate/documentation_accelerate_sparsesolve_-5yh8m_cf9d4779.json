{
  "abstract" : "Solves the equation *AX = B* for matrices of double-precision values using the specified iterative method and opaque preconditioner.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Double] =      [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\nlet preconditioner = SparseCreatePreconditioner(SparsePreconditionerDiagScaling,\n                                                A)\n\ndefer {\n    SparseCleanup(A)\n    SparseCleanup(preconditioner)\n}\n\n\/\/\/ Create the right-hand-side matrix, _B_.\nvar bValues: [Double] = [30, 35, 100,\n                         300, 350, 1000]\nlet n = bValues.count\n\nlet xValues = [Double](unsafeUninitializedCapacity: n) {\n    buffer, count in\n    bValues.withUnsafeMutableBufferPointer { bPtr in\n        let B = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: bPtr.baseAddress!)\n        \n        let X = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: buffer.baseAddress!)\n        \n        SparseSolve(SparseLSMR(),\n                    A, B, X,\n                    preconditioner)\n        count = n\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "5b7177db8f02802e5324d12ed0b6eb57730963436337b574459a7dd0f0b30cc0",
  "crawledAt" : "2025-12-02T22:49:39Z",
  "declaration" : {
    "code" : "func SparseSolve(_ method: SparseIterativeMethod, _ A: SparseMatrix_Double, _ B: DenseMatrix_Double, _ X: DenseMatrix_Double, _ Preconditioner: SparseOpaquePreconditioner_Double) -> SparseIterativeStatus_t",
    "language" : "swift"
  },
  "id" : "AC2C8818-5E67-4872-8D8A-30E053B1AC82",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. Preconditioning the coefficient matrix can reduce the number of iterations the function requires to converge the system.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system by applying a diagonal scaling preconditioner and using the least squares minimum residual method:\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0, 10.0, 20.0, 30.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-5yh8m\ncrawled: 2025-12-02T22:49:39Z\n---\n\n# SparseSolve(_:_:_:_:_:)\n\n**Function**\n\nSolves the equation *AX = B* for matrices of double-precision values using the specified iterative method and opaque preconditioner.\n\n## Declaration\n\n```swift\nfunc SparseSolve(_ method: SparseIterativeMethod, _ A: SparseMatrix_Double, _ B: DenseMatrix_Double, _ X: DenseMatrix_Double, _ Preconditioner: SparseOpaquePreconditioner_Double) -> SparseIterativeStatus_t\n```\n\n## Parameters\n\n- **method**: The iterative method.\n- **A**: The matrix *A*.\n- **B**: The matrix *B*.\n- **X**: The matrix *X*.\n- **Preconditioner**: The preconditioner to apply.\n\n## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. Preconditioning the coefficient matrix can reduce the number of iterations the function requires to converge the system.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system by applying a diagonal scaling preconditioner and using the least squares minimum residual method:\n\n```swift\n\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Double] =      [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\nlet preconditioner = SparseCreatePreconditioner(SparsePreconditionerDiagScaling,\n                                                A)\n\ndefer {\n    SparseCleanup(A)\n    SparseCleanup(preconditioner)\n}\n\n\/\/\/ Create the right-hand-side matrix, _B_.\nvar bValues: [Double] = [30, 35, 100,\n                         300, 350, 1000]\nlet n = bValues.count\n\nlet xValues = [Double](unsafeUninitializedCapacity: n) {\n    buffer, count in\n    bValues.withUnsafeMutableBufferPointer { bPtr in\n        let B = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: bPtr.baseAddress!)\n        \n        let X = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: buffer.baseAddress!)\n        \n        SparseSolve(SparseLSMR(),\n                    A, B, X,\n                    preconditioner)\n        count = n\n    }\n}\n```\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0, 10.0, 20.0, 30.0]`.\n\n## Iterative sparse solve functions with preconditioner\n\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *AX = B* for matrices of single-precision values using the specified iterative method and opaque preconditioner.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *AX = B* for matrices of double-precision values using the specified iterative method and preconditioner type.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *AX = B* for matrices of single-precision values using the specified iterative method and preconditioner type.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *AX = B* for matrices of double-precision values, treating *A* as an operator and using the specified iterative method.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *AX = B* for matrices of single-precision values, treating *A* as an operator and using the specified iterative method.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Solves the equation *AX = B* for matrices of single-precision values using the specified iterative method and opaque preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-7vrh0"
        },
        {
          "description" : "Solves the equation *AX = B* for matrices of double-precision values using the specified iterative method and preconditioner type.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-5d7vf"
        },
        {
          "description" : "Solves the equation *AX = B* for matrices of single-precision values using the specified iterative method and preconditioner type.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-7apig"
        },
        {
          "description" : "Solves the equation *AX = B* for matrices of double-precision values, treating *A* as an operator and using the specified iterative method.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-8nfbc"
        },
        {
          "description" : "Solves the equation *AX = B* for matrices of single-precision values, treating *A* as an operator and using the specified iterative method.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-80ri4"
        }
      ],
      "title" : "Iterative sparse solve functions with preconditioner"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseSolve(_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-5yh8m"
}