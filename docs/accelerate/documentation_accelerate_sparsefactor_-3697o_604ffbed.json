{
  "abstract" : "Returns a symbolic factorization of the requested type for a specified sparsity structure.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Define the sparsity pattern of matrices `A0` and `A1`.\nlet rowIndices: [Int32] =    [ 0, 1, 1, 2]\nlet columnIndices: [Int32] = [ 2, 0, 2, 1]\n\n\/\/\/ Create the single-precision coefficient matrix _A0_.\nlet a0Values: [Float] = [10, 20, 5, 50]\nlet A0 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a0Values)\n\n\/\/\/ Create the double-precision coefficient matrix _A1_.\nlet a1Values: [Double] = [5, 10, 2.5, 25]\nlet A1 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a1Values)\n\n\/\/\/ Compute the symbolic factorization from the structure of either coefficient matrix.\nlet structure = A0.structure\nlet symbolicFactorization = SparseFactor(SparseFactorizationQR,\n                                         structure)\n\n\/\/\/ Factorize _A0_ using the symbolic factorization.\nlet factorization0 = SparseFactor(symbolicFactorization, A0)\n\n\/\/\/ Solve _A0 · x = b0_ in place.\nvar b0Values: [Float] = [30, 35, 100]\nb0Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Float(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization0, xb)\n}\n\n\/\/\/ Factorize _A1_ using the symbolic factorization.\nlet factorization1 = SparseFactor(symbolicFactorization, A1)\n\n\/\/\/ Solve _A1 · x = b1_ in place.\nvar b1Values: [Double] = [60, 70, 200]\nb1Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Double(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization1, xb)\n}\n\nSparseCleanup(A0)\nSparseCleanup(A1)\nSparseCleanup(factorization0)\nSparseCleanup(factorization1)",
      "language" : "swift"
    }
  ],
  "contentHash" : "d3343f16cc1d982fff6794238494c99f3218119947a0d9d3065c33a8c0f8c3f4",
  "crawledAt" : "2025-12-02T23:07:52Z",
  "declaration" : {
    "code" : "func SparseFactor(_ type: SparseFactorization_t, _ Matrix: SparseMatrixStructure) -> SparseOpaqueSymbolicFactorization",
    "language" : "swift"
  },
  "id" : "3A4BFFE1-CB5A-4D1F-A329-A0E1092FBED0",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseOpaqueSymbolicFactorization] structure that represents the symbolic factorization.\n\n## Discussion\n\nUse this function to calculate the symbolic factorization of a sparse matrix’s structure to pass to the direct solve functions. You can use the symbolic factorization that this function returns for multiple numerical factorizations with different numerical values and different precisions, but the same nonzero structure.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves these two systems by creating a symbolic factorization that’s common to both coefficient matrices. Note that the two coefficient matrices contain different numeric values with different precisions.\n\nOn return, `b0Values` contains the values `[1.0, 2.0, 3.0]`, and `b1Values` contains the values `[4.0, 8.0, 12.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseFactor(_:_:)-3697o\ncrawled: 2025-12-02T23:07:52Z\n---\n\n# SparseFactor(_:_:)\n\n**Function**\n\nReturns a symbolic factorization of the requested type for a specified sparsity structure.\n\n## Declaration\n\n```swift\nfunc SparseFactor(_ type: SparseFactorization_t, _ Matrix: SparseMatrixStructure) -> SparseOpaqueSymbolicFactorization\n```\n\n## Parameters\n\n- **type**: The factorization type.\n- **Matrix**: The matrix to factorize.\n\n## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseOpaqueSymbolicFactorization] structure that represents the symbolic factorization.\n\n## Discussion\n\nUse this function to calculate the symbolic factorization of a sparse matrix’s structure to pass to the direct solve functions. You can use the symbolic factorization that this function returns for multiple numerical factorizations with different numerical values and different precisions, but the same nonzero structure.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves these two systems by creating a symbolic factorization that’s common to both coefficient matrices. Note that the two coefficient matrices contain different numeric values with different precisions.\n\n```swift\n\/\/\/ Define the sparsity pattern of matrices `A0` and `A1`.\nlet rowIndices: [Int32] =    [ 0, 1, 1, 2]\nlet columnIndices: [Int32] = [ 2, 0, 2, 1]\n\n\/\/\/ Create the single-precision coefficient matrix _A0_.\nlet a0Values: [Float] = [10, 20, 5, 50]\nlet A0 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a0Values)\n\n\/\/\/ Create the double-precision coefficient matrix _A1_.\nlet a1Values: [Double] = [5, 10, 2.5, 25]\nlet A1 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a1Values)\n\n\/\/\/ Compute the symbolic factorization from the structure of either coefficient matrix.\nlet structure = A0.structure\nlet symbolicFactorization = SparseFactor(SparseFactorizationQR,\n                                         structure)\n\n\/\/\/ Factorize _A0_ using the symbolic factorization.\nlet factorization0 = SparseFactor(symbolicFactorization, A0)\n\n\/\/\/ Solve _A0 · x = b0_ in place.\nvar b0Values: [Float] = [30, 35, 100]\nb0Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Float(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization0, xb)\n}\n\n\/\/\/ Factorize _A1_ using the symbolic factorization.\nlet factorization1 = SparseFactor(symbolicFactorization, A1)\n\n\/\/\/ Solve _A1 · x = b1_ in place.\nvar b1Values: [Double] = [60, 70, 200]\nb1Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Double(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization1, xb)\n}\n\nSparseCleanup(A0)\nSparseCleanup(A1)\nSparseCleanup(factorization0)\nSparseCleanup(factorization1)\n```\n\nOn return, `b0Values` contains the values `[1.0, 2.0, 3.0]`, and `b1Values` contains the values `[4.0, 8.0, 12.0]`.\n\n## Matrix symbolic factorization functions\n\n- **SparseFactor(_:_:_:)**: Returns a symbolic factorization of the requested type for a single-precision matrix with the specified structure.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a symbolic factorization of the requested type for a single-precision matrix with the specified structure.",
          "name" : "SparseFactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseFactor(_:_:_:)-45gsz"
        }
      ],
      "title" : "Matrix symbolic factorization functions"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseFactor(_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseFactor(_:_:)-3697o"
}