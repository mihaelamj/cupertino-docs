{
  "abstract" : "Reduce the sample rate of a signal by specifying a decimation factor and applying a custom antialiasing filter.",
  "codeExamples" : [
    {
      "code" : "let inputLength = 1024\nlet inputSignal = (0 ..< inputLength).map {\n    let x = Float($0)\n    return sin(x * 0.007) + sin(x * 0.03)\n}",
      "language" : "swift"
    },
    {
      "code" : "let filterLength = 2\nlet filter = [Float](repeating: 1 \/ Float(filterLength),\n                     count: filterLength)",
      "language" : "swift"
    },
    {
      "code" : "let originalSignal: [Float] = [10, 15, 20, 25, 50, 25, 20, 15, 10,\n                               10, 15, 20, 25, 50, 25, 20, 15, 10]",
      "language" : "swift"
    },
    {
      "code" : "\/\/ The output signal contains `(source.count - filter.count) \/ decimationFactor + 1`\n\/\/ elements.\nlet outputSignal = vDSP.downsample(inputSignal,\n                                   decimationFactor: decimationFactor,\n                                   filter: filter)",
      "language" : "swift"
    }
  ],
  "contentHash" : "21a8386ed5f33b844c24636fb09a4c10fb684f66d078500a391bb02a5fc97dd5",
  "crawledAt" : "2025-12-02T15:37:16Z",
  "id" : "7E77A8CB-F0F3-4E64-A4D6-B0962F99A365",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nvDSP provides functions for decimating a signal. A decimated signal has a lower sample rate compared to its original. Decimation can be advantageous when, for example, you are transmitting a signal, creating a visual representation of a large dataset, or reducing the memory overhead when processing data.\n\nIn the following pair of images, the original signal on the left contains 1024 samples. After decimation by a factor of two, the result on the right contains 512 samples.\n\n\n\n### Create the input signal\n\nThe following code creates an array and populates it with a composite sine wave:\n\nThe following image shows a visualization of the values in `inputSignal`:\n\n\n\nvDSP provides the single-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/downsample(_:decimationFactor:filter:)-40d8o] and the double-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/downsample(_:decimationFactor:filter:)-1o8it] to decimate the elements in an array. These function wrap [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_desamp] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_desampD], respectively.\n\n### Define the antialiasing filter\n\nThe vDSP decimation functions accept a filter that controls how adjacent samples combine. Each decimated value is the sum of the combined original values multiplied by the corresponding filter value.\n\nThe following code creates a filter that contains `[0.5, 0.5]`:\n\nThe resulting filter averages pairs of adjacent values in the original signal.\n\nFor the most complete result, set the filter length to the same value as the decimation factor, which indicates how much the original signal is decimated. For example, consider an input signal containing 18 values.\n\nThe following images visualize the original and decimated signals and illustrate the effects of different antialiasing filters. The graph below visualizes the signal.\n\n\n\nA filter that contains a single value `[1.0]` combined with a decimation factor of `2` will sample only the even values of the original signal. The decimation functions return a result that misses the second `50` at position `13`, as shown below.\n\n\n\nHowever, a filter with two values, `[0.5, 0.5]` considers all values in the original signal, as illustrated below.\n\n\n\n### Perform the Decimation\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/downsample(_:decimationFactor:filter:)-40d8o] function performs the decimation.\n\nOn return, `outputSignal` contains the result.\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/resampling-a-signal-with-decimation\ncrawled: 2025-12-02T15:37:16Z\n---\n\n# Resampling a signal with decimation\n\n**Article**\n\nReduce the sample rate of a signal by specifying a decimation factor and applying a custom antialiasing filter.\n\n## Overview\n\nvDSP provides functions for decimating a signal. A decimated signal has a lower sample rate compared to its original. Decimation can be advantageous when, for example, you are transmitting a signal, creating a visual representation of a large dataset, or reducing the memory overhead when processing data.\n\nIn the following pair of images, the original signal on the left contains 1024 samples. After decimation by a factor of two, the result on the right contains 512 samples.\n\n\n\n### Create the input signal\n\nThe following code creates an array and populates it with a composite sine wave:\n\n```swift\nlet inputLength = 1024\nlet inputSignal = (0 ..< inputLength).map {\n    let x = Float($0)\n    return sin(x * 0.007) + sin(x * 0.03)\n}\n```\n\nThe following image shows a visualization of the values in `inputSignal`:\n\n\n\nvDSP provides the single-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/downsample(_:decimationFactor:filter:)-40d8o] and the double-precision function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/downsample(_:decimationFactor:filter:)-1o8it] to decimate the elements in an array. These function wrap [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_desamp] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_desampD], respectively.\n\n### Define the antialiasing filter\n\nThe vDSP decimation functions accept a filter that controls how adjacent samples combine. Each decimated value is the sum of the combined original values multiplied by the corresponding filter value.\n\nThe following code creates a filter that contains `[0.5, 0.5]`:\n\n```swift\nlet filterLength = 2\nlet filter = [Float](repeating: 1 \/ Float(filterLength),\n                     count: filterLength)\n```\n\nThe resulting filter averages pairs of adjacent values in the original signal.\n\nFor the most complete result, set the filter length to the same value as the decimation factor, which indicates how much the original signal is decimated. For example, consider an input signal containing 18 values.\n\n```swift\nlet originalSignal: [Float] = [10, 15, 20, 25, 50, 25, 20, 15, 10,\n                               10, 15, 20, 25, 50, 25, 20, 15, 10]\n```\n\nThe following images visualize the original and decimated signals and illustrate the effects of different antialiasing filters. The graph below visualizes the signal.\n\n\n\nA filter that contains a single value `[1.0]` combined with a decimation factor of `2` will sample only the even values of the original signal. The decimation functions return a result that misses the second `50` at position `13`, as shown below.\n\n\n\nHowever, a filter with two values, `[0.5, 0.5]` considers all values in the original signal, as illustrated below.\n\n\n\n### Perform the Decimation\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/downsample(_:decimationFactor:filter:)-40d8o] function performs the decimation.\n\n```swift\n\/\/ The output signal contains `(source.count - filter.count) \/ decimationFactor + 1`\n\/\/ elements.\nlet outputSignal = vDSP.downsample(inputSignal,\n                                   decimationFactor: decimationFactor,\n                                   filter: filter)\n```\n\nOn return, `outputSignal` contains the result.\n\n\n\n## Signal Processing Essentials\n\n- **Controlling vDSP operations with stride**: Operate selectively on the elements of a vector at regular intervals.\n- **Using linear interpolation to construct new data points**: Fill the gaps in arrays of numerical data using linear interpolation.\n- **Using vDSP for vector-based arithmetic**: Increase the performance of common mathematical tasks with vDSP vector-vector and vector-scalar operations.\n- **vDSP**: Perform basic arithmetic operations and common digital signal processing (DSP) routines on large vectors.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Operate selectively on the elements of a vector at regular intervals.",
          "name" : "Controlling vDSP operations with stride",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/controlling-vdsp-operations-with-stride"
        },
        {
          "description" : "Fill the gaps in arrays of numerical data using linear interpolation.",
          "name" : "Using linear interpolation to construct new data points",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-linear-interpolation-to-construct-new-data-points"
        },
        {
          "description" : "Increase the performance of common mathematical tasks with vDSP vector-vector and vector-scalar operations.",
          "name" : "Using vDSP for vector-based arithmetic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-vdsp-for-vector-based-arithmetic"
        },
        {
          "description" : "Perform basic arithmetic operations and common digital signal processing (DSP) routines on large vectors.",
          "name" : "vDSP",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vdsp-library"
        }
      ],
      "title" : "Signal Processing Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Resampling a signal with decimation",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/resampling-a-signal-with-decimation"
}