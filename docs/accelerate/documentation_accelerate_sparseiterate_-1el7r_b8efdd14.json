{
  "abstract" : "Performs a single iteration of the specified iterative method for single-precision matrices.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Create the coefficient matrix _A_\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Float] =      [10, 20, 5, 50]\n\nlet rowCount = Int32(3)\nlet columnCount = Int32(3)\n\nlet A = SparseConvertFromCoordinate(rowCount, columnCount,\n                                    aValues.count, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\ndefer {\n    SparseCleanup(A)\n}\n\n\/\/\/ Define the size of the constants matrix, residuals matrix, and solution vectors.\nlet rhsCount = Int32(2)\nlet count = Int(rowCount * rhsCount)\n\n\/\/\/ Create the constants matrix, _B_ data.\nlet bData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nbData.initialize(from: [30, 35, 100,\n                        300, 350, 1000], count: count)\n\n\/\/\/ Create the residual estimate matrix, _R_ data.\nlet rData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nrData.initialize(from: bData, count: count)\n\n\/\/\/ Create the solution vectors, _X_ data.\nlet xData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nxData.initialize(repeating: 0, count: count)\n\n\/\/\/ Create the state space.\nlet method = SparseLSMR()\nlet stateSize = SparseGetStateSize_Float(method, false,\n                                         rowCount, columnCount,\n                                         rhsCount)\nlet state = UnsafeMutablePointer<Double>.allocate(capacity: stateSize)\nstate.initialize(repeating: 0, count: stateSize)\n\ndefer {\n    bData.deallocate()\n    rData.deallocate()\n    xData.deallocate()\n    state.deallocate()\n}\n\n\/\/\/ Create the apply operator block.\nfunc applyOperator(accumulate: Bool,\n                   trans: CBLAS_TRANSPOSE,\n                   X: DenseMatrix_Float,\n                   Y: DenseMatrix_Float) {\n    switch(accumulate, trans == CblasTrans) {\n        case (false, false):\n            SparseMultiply(A, X, Y)\n        case (false, true):\n            SparseMultiply(SparseGetTranspose(A), X, Y)\n        case (true, false):\n            SparseMultiplyAdd(A, X, Y)\n        case (true, true):\n            SparseMultiplyAdd(SparseGetTranspose(A), X, Y)\n    }\n}\n\nvar iteration = Int32(0)\nvar converged = [Bool](repeating: false,\n                       count: Int(rhsCount))\n\nwhile iteration >= 0 {\n    \/\/\/ If all right-hand-sides have converged, set `converge` \n    \/\/\/ to a negative value to indicate the current iteration is final.\n    if converged.allSatisfy({ $0 }) {\n        iteration = -.max\n    }\n    \n    print(\"Iteration:\", iteration)\n    let B = DenseMatrix_Float(rowCount: rowCount,\n                              columnCount: rhsCount,\n                              columnStride: rowCount,\n                              attributes: SparseAttributes_t(),\n                              data: bData)\n    \n    let R = DenseMatrix_Float(rowCount: rowCount,\n                              columnCount: rhsCount,\n                              columnStride: rowCount,\n                              attributes: SparseAttributes_t(),\n                              data: rData)\n    \n    let X = DenseMatrix_Float(rowCount: rowCount,\n                              columnCount: rhsCount,\n                              columnStride: rowCount,\n                              attributes: SparseAttributes_t(),\n                              data: xData)\n    \n    SparseIterate(method,\n                  iteration, converged,\n                  state,\n                  applyOperator,\n                  B, R, X)\n    \n    \/\/\/ Elements 1 and 4 of the residual estimate contain the least squares residual, _‖ b-Ax ‖₂_,\n    \/\/\/ for columns 0 and 1, respectively. Define a suitable tolerance for convergence testing.\n    converged = [\n        rData[1] < 1e-4,\n        rData[4] < 1e-4\n    ]\n\n    iteration += 1\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "1089e55ab089c5d321b68c26122cc07eda5126107c7a927261b0a2ec3bce3070",
  "crawledAt" : "2025-12-02T23:08:57Z",
  "declaration" : {
    "code" : "func SparseIterate(_ method: SparseIterativeMethod, _ iteration: Int32, _ converged: UnsafePointer<Bool>, _ state: UnsafeMutableRawPointer, _ ApplyOperator: @escaping (Bool, CBLAS_TRANSPOSE, DenseMatrix_Float, DenseMatrix_Float) -> Void, _ B: DenseMatrix_Float, _ R: DenseMatrix_Float, _ X: DenseMatrix_Float)",
    "language" : "swift"
  },
  "id" : "65339285-F8D6-4402-98BC-2D6D8780DF1B",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. This function provides complete control over each iteration, and you’re responsible for convergence tests and the number of iterations.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system using the least squares minimum residual method:\n\nOn return, x`Data` points to the values `[1.0, 2.0, 3.0, 10.0, 20.0, 30.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseIterate(_:_:_:_:_:_:_:_:)-1el7r\ncrawled: 2025-12-02T23:08:57Z\n---\n\n# SparseIterate(_:_:_:_:_:_:_:_:)\n\n**Function**\n\nPerforms a single iteration of the specified iterative method for single-precision matrices.\n\n## Declaration\n\n```swift\nfunc SparseIterate(_ method: SparseIterativeMethod, _ iteration: Int32, _ converged: UnsafePointer<Bool>, _ state: UnsafeMutableRawPointer, _ ApplyOperator: @escaping (Bool, CBLAS_TRANSPOSE, DenseMatrix_Float, DenseMatrix_Float) -> Void, _ B: DenseMatrix_Float, _ R: DenseMatrix_Float, _ X: DenseMatrix_Float)\n```\n\n## Parameters\n\n- **method**: The iterative method specification, such as the return value of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseConjugateGradient()].\n\nNote that this function ignores the options for convergence testing (for example, [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseLSMROptions\/maxIterations], [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseLSMROptions\/atol], [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseLSMROptions\/rtol]) because you’re responsible for convergence tests.\n- **iteration**: The current iteration number, starting from `0`. If `iteration<0`, the function finalizes the current iteration, and updates the value of `X`. Note that this may force some methods to restart, and slow convergence.\n- **converged**: The convergence status of each right-hand-side. Set `converged[j]` to `true` to indicate that the operation has converged the vector that it stores as column `j` of `X`, and the function must ignore it in this iteration.\n- **state**: A pointer to a state space with a size that [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseGetStateSize_Float(_:_:_:_:_:)] defines. Don’t alter the state space between iterations, and deallocate it after the final call to `SparseIterate`.\n- **ApplyOperator**: The apply operator block to run. The block takes the following parameters:\n\n\n- **B**: The right-hand-sides to solve for.\n- **R**: The residual estimate. For the first entry, that is, when `iteration = 0`, set this to the residuals *b-Ax* (equal to `B` if `X = 0`). On return from each call with `iteration >= 0`, the first entries of each vector contain various estimates of norms to use in convergence testing.\n\nFor CG and GMRES:\n\n- `R(0,j)` holds an estimate of *‖ b-Ax ‖₂* for the `j`-th right-hand-side.\n\nFor LSMR:\n\n- `R(0,j)` holds an estimate of *‖ Aᵀ(b-Ax) ‖₂* for the `j`-th right-hand-side.\n- `R(1,j)` holds an estimate of *‖ b-Ax ‖₂* for the `j`-th right-hand-side.\n- `R(2,j)` holds an estimate of *‖ A ‖ꜰ*, the Frobenius norm of *A*, that the operation estimates using calculations from to the `j`-th right-hand-side.\n- `R(3,j)` holds an estimate of *cond(A)*, the condition number of A, that the operation estimates using calculations from the `j`-th right-hand-side.\n\nThe function may use other entries of `R` as a workspace. On return from a call with `iteration < 0`, the function returns the exact residual vector *b-Ax*.\n- **X**: The current estimate of the solution vectors `X`.\n\nOn entry with `iteration = 0`, this is an initial estimate for the solution. If no good estimate is available, use `X = 0.0`.\n\nDepending on the method, the function may not update `X` at each iteration. Make a call with `iteration < 0` after the function achieves convergence to update `X`.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. This function provides complete control over each iteration, and you’re responsible for convergence tests and the number of iterations.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system using the least squares minimum residual method:\n\n```swift\n\/\/\/ Create the coefficient matrix _A_\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Float] =      [10, 20, 5, 50]\n\nlet rowCount = Int32(3)\nlet columnCount = Int32(3)\n\nlet A = SparseConvertFromCoordinate(rowCount, columnCount,\n                                    aValues.count, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\ndefer {\n    SparseCleanup(A)\n}\n\n\/\/\/ Define the size of the constants matrix, residuals matrix, and solution vectors.\nlet rhsCount = Int32(2)\nlet count = Int(rowCount * rhsCount)\n\n\/\/\/ Create the constants matrix, _B_ data.\nlet bData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nbData.initialize(from: [30, 35, 100,\n                        300, 350, 1000], count: count)\n\n\/\/\/ Create the residual estimate matrix, _R_ data.\nlet rData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nrData.initialize(from: bData, count: count)\n\n\/\/\/ Create the solution vectors, _X_ data.\nlet xData = UnsafeMutablePointer<Float>.allocate(capacity: count)\nxData.initialize(repeating: 0, count: count)\n\n\/\/\/ Create the state space.\nlet method = SparseLSMR()\nlet stateSize = SparseGetStateSize_Float(method, false,\n                                         rowCount, columnCount,\n                                         rhsCount)\nlet state = UnsafeMutablePointer<Double>.allocate(capacity: stateSize)\nstate.initialize(repeating: 0, count: stateSize)\n\ndefer {\n    bData.deallocate()\n    rData.deallocate()\n    xData.deallocate()\n    state.deallocate()\n}\n\n\/\/\/ Create the apply operator block.\nfunc applyOperator(accumulate: Bool,\n                   trans: CBLAS_TRANSPOSE,\n                   X: DenseMatrix_Float,\n                   Y: DenseMatrix_Float) {\n    switch(accumulate, trans == CblasTrans) {\n        case (false, false):\n            SparseMultiply(A, X, Y)\n        case (false, true):\n            SparseMultiply(SparseGetTranspose(A), X, Y)\n        case (true, false):\n            SparseMultiplyAdd(A, X, Y)\n        case (true, true):\n            SparseMultiplyAdd(SparseGetTranspose(A), X, Y)\n    }\n}\n\nvar iteration = Int32(0)\nvar converged = [Bool](repeating: false,\n                       count: Int(rhsCount))\n\nwhile iteration >= 0 {\n    \/\/\/ If all right-hand-sides have converged, set `converge` \n    \/\/\/ to a negative value to indicate the current iteration is final.\n    if converged.allSatisfy({ $0 }) {\n        iteration = -.max\n    }\n    \n    print(\"Iteration:\", iteration)\n    let B = DenseMatrix_Float(rowCount: rowCount,\n                              columnCount: rhsCount,\n                              columnStride: rowCount,\n                              attributes: SparseAttributes_t(),\n                              data: bData)\n    \n    let R = DenseMatrix_Float(rowCount: rowCount,\n                              columnCount: rhsCount,\n                              columnStride: rowCount,\n                              attributes: SparseAttributes_t(),\n                              data: rData)\n    \n    let X = DenseMatrix_Float(rowCount: rowCount,\n                              columnCount: rhsCount,\n                              columnStride: rowCount,\n                              attributes: SparseAttributes_t(),\n                              data: xData)\n    \n    SparseIterate(method,\n                  iteration, converged,\n                  state,\n                  applyOperator,\n                  B, R, X)\n    \n    \/\/\/ Elements 1 and 4 of the residual estimate contain the least squares residual, _‖ b-Ax ‖₂_,\n    \/\/\/ for columns 0 and 1, respectively. Define a suitable tolerance for convergence testing.\n    converged = [\n        rData[1] < 1e-4,\n        rData[4] < 1e-4\n    ]\n\n    iteration += 1\n}\n```\n\nOn return, x`Data` points to the values `[1.0, 2.0, 3.0, 10.0, 20.0, 30.0]`.\n\n## Sparse Iterate Functions\n\n- **SparseIterate(_:_:_:_:_:_:_:_:)**: Performs a single iteration of the specified iterative method for double-precision matrices.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Performs a single iteration of the specified iterative method for double-precision matrices.",
          "name" : "SparseIterate(_:_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseIterate(_:_:_:_:_:_:_:_:)-c54n"
        }
      ],
      "title" : "Sparse Iterate Functions"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseIterate(_:_:_:_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseIterate(_:_:_:_:_:_:_:_:)-1el7r"
}