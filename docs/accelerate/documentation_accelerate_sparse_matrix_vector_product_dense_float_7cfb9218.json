{
  "abstract" : "Multiplies the dense vector *x* by the sparse matrix *A* and adds the result to the dense vector *y*, with all operands containing single-precision values.",
  "codeExamples" : [

  ],
  "contentHash" : "f7a8cc276eeedbe07ad5632570e8737fb914d0fc1617266ecd8b1042a5528b05",
  "crawledAt" : "2025-12-02T23:03:13Z",
  "declaration" : {
    "code" : "func sparse_matrix_vector_product_dense_float(_ transa: CBLAS_TRANSPOSE, _ alpha: Float, _ A: sparse_matrix_float!, _ x: UnsafePointer<Float>!, _ incx: sparse_stride, _ y: UnsafeMutablePointer<Float>!, _ incy: sparse_stride) -> sparse_status",
    "language" : "swift"
  },
  "id" : "FD8138EC-4065-4C6F-93DE-28D06F45DFDE",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\nOn success [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SPARSE_SUCCESS]  (`y` will be updated with result of the operation).  Retruns [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SPARSE_ILLEGAL_PARAMETER] if `transa` is invalid and `y` will be unchanged.\n\n## Discussion\n\nMultiplies the dense vector *x* by the sparse matrix *A* and adds the result to the dense vector *y* (*y = alpha * op(A) * x + y*, where *op(A)* is either *A* or the transpose of *A*).If the desired operation is *y = A * x*, then an efficient option is to create the `y` buffer of zeros and then perform the operation with the zero filled `y`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_matrix_vector_product_dense_float(_:_:_:_:_:_:_:)\ncrawled: 2025-12-02T23:03:13Z\n---\n\n# sparse_matrix_vector_product_dense_float(_:_:_:_:_:_:_:)\n\n**Function**\n\nMultiplies the dense vector *x* by the sparse matrix *A* and adds the result to the dense vector *y*, with all operands containing single-precision values.\n\n## Declaration\n\n```swift\nfunc sparse_matrix_vector_product_dense_float(_ transa: CBLAS_TRANSPOSE, _ alpha: Float, _ A: sparse_matrix_float!, _ x: UnsafePointer<Float>!, _ incx: sparse_stride, _ y: UnsafeMutablePointer<Float>!, _ incy: sparse_stride) -> sparse_status\n```\n\n## Parameters\n\n- **transa**: Specifies whether to perform the operation with A or the transpose of A. Must be one of `CblasNoTrans` or `CblasTrans`.\n- **alpha**: Scalar multiplier of *A*.\n- **A**: The sparse matrix, *A*.\n- **x**: Pointer to the dense vector *x*. The dimension must be the number of columns of the matrix *A* when `transa` is no transpose or the number of rows of the matrix *A* when `transa` is transpose.  The behavior of this function is undefined if this is not met.  Negative strides are supported.  Note, unlike dense BLAS routines, the pointer points to the last element when stride is negative.\n- **incx**: Increment between valid values in the dense vector x. Negative strides are supported.\n- **y**: Pointer to the dense vector *y*. The dimension must be the number of rows of the matrix *A* when `transa` is no transpose or the number of columns of the matrix *A* when `transa` is transpose.  The behavior of this function is undefined if this is not met.  Negative strides are supported.  Note, unlike dense BLAS routines, the pointer points to the last element when stride is negative.\n- **incy**: Increment between valid values in the dense vector *y*.  Negative strides are supported.\n\n## Return Value\n\nOn success [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SPARSE_SUCCESS]  (`y` will be updated with result of the operation).  Retruns [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SPARSE_ILLEGAL_PARAMETER] if `transa` is invalid and `y` will be unchanged.\n\n## Discussion\n\nMultiplies the dense vector *x* by the sparse matrix *A* and adds the result to the dense vector *y* (*y = alpha * op(A) * x + y*, where *op(A)* is either *A* or the transpose of *A*).If the desired operation is *y = A * x*, then an efficient option is to create the `y` buffer of zeros and then perform the operation with the zero filled `y`.\n\n\n\n## Matrix-Vector Operations\n\n- **sparse_matrix_vector_product_dense_double(_:_:_:_:_:_:_:)**: Multiplies the dense vector *x* by the sparse matrix *A* and adds the result to the dense vector *y*, with all operands containing double-precision values.\n- **sparse_vector_triangular_solve_dense_double(_:_:_:_:_:)**: Solves the system of equations *x = alpha * T⁻¹ * x* for x where *x* is a dense vector and *T* is a triangular sparse matrix, with all operands containing double-precision values.\n- **sparse_vector_triangular_solve_dense_float(_:_:_:_:_:)**: Solves the system of equations *x = alpha * T⁻¹ * x* for x where *x* is a dense vector and *T* is a triangular sparse matrix, with all operands containing single-precision values.\n- **sparse_outer_product_dense_double(_:_:_:_:_:_:_:_:_:)**: Computes the outer product of the dense vector *x* and the sparse vector *y*, with both operands containing double-precision values.\n- **sparse_outer_product_dense_float(_:_:_:_:_:_:_:_:_:)**: Computes the outer product of the dense vector *x* and the sparse vector *y*, with both operands containing single-precision values.\n- **sparse_permute_rows_double(_:_:)**: Permutes the rows of the double-precision sparse matrix *A* based on the provided permutation array.\n- **sparse_permute_rows_float(_:_:)**: Permutes the rows of the single-precision sparse matrix *A* based on the provided permutation array.\n- **sparse_permute_cols_double(_:_:)**: Permutes the columns of the double-precision sparse matrix *A* based on the provided permutation array.\n- **sparse_permute_cols_float(_:_:)**: Permutes the columns of the single-precision sparse matrix *A* based on the provided permutation array.\n- **sparse_elementwise_norm_double(_:_:)**: Computes the specified element-wise norm of the double-precision sparse matrix *A*.\n- **sparse_elementwise_norm_float(_:_:)**: Computes the specified element-wise norm of the single-precision sparse matrix *A*.\n- **sparse_operator_norm_double(_:_:)**: Computes the specified operator norm of the double-precision sparse matrix *A*.\n- **sparse_operator_norm_float(_:_:)**: Computes the specified operator norm of the single-precision sparse matrix *A*.\n- **sparse_matrix_trace_double(_:_:)**: Computes the sum along the specified diagonal of the double-precision sparse matrix *A*.\n- **sparse_matrix_trace_float(_:_:)**: Computes the sum along the specified diagonal of the single-precision sparse matrix *A*.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Multiplies the dense vector *x* by the sparse matrix *A* and adds the result to the dense vector *y*, with all operands containing double-precision values.",
          "name" : "sparse_matrix_vector_product_dense_double(_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_matrix_vector_product_dense_double(_:_:_:_:_:_:_:)"
        },
        {
          "description" : "Solves the system of equations *x = alpha * T⁻¹ * x* for x where *x* is a dense vector and *T* is a triangular sparse matrix, with all operands containing double-precision values.",
          "name" : "sparse_vector_triangular_solve_dense_double(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_vector_triangular_solve_dense_double(_:_:_:_:_:)"
        },
        {
          "description" : "Solves the system of equations *x = alpha * T⁻¹ * x* for x where *x* is a dense vector and *T* is a triangular sparse matrix, with all operands containing single-precision values.",
          "name" : "sparse_vector_triangular_solve_dense_float(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_vector_triangular_solve_dense_float(_:_:_:_:_:)"
        },
        {
          "description" : "Computes the outer product of the dense vector *x* and the sparse vector *y*, with both operands containing double-precision values.",
          "name" : "sparse_outer_product_dense_double(_:_:_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_outer_product_dense_double(_:_:_:_:_:_:_:_:_:)"
        },
        {
          "description" : "Computes the outer product of the dense vector *x* and the sparse vector *y*, with both operands containing single-precision values.",
          "name" : "sparse_outer_product_dense_float(_:_:_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_outer_product_dense_float(_:_:_:_:_:_:_:_:_:)"
        },
        {
          "description" : "Permutes the rows of the double-precision sparse matrix *A* based on the provided permutation array.",
          "name" : "sparse_permute_rows_double(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_permute_rows_double(_:_:)"
        },
        {
          "description" : "Permutes the rows of the single-precision sparse matrix *A* based on the provided permutation array.",
          "name" : "sparse_permute_rows_float(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_permute_rows_float(_:_:)"
        },
        {
          "description" : "Permutes the columns of the double-precision sparse matrix *A* based on the provided permutation array.",
          "name" : "sparse_permute_cols_double(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_permute_cols_double(_:_:)"
        },
        {
          "description" : "Permutes the columns of the single-precision sparse matrix *A* based on the provided permutation array.",
          "name" : "sparse_permute_cols_float(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_permute_cols_float(_:_:)"
        },
        {
          "description" : "Computes the specified element-wise norm of the double-precision sparse matrix *A*.",
          "name" : "sparse_elementwise_norm_double(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_elementwise_norm_double(_:_:)"
        },
        {
          "description" : "Computes the specified element-wise norm of the single-precision sparse matrix *A*.",
          "name" : "sparse_elementwise_norm_float(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_elementwise_norm_float(_:_:)"
        },
        {
          "description" : "Computes the specified operator norm of the double-precision sparse matrix *A*.",
          "name" : "sparse_operator_norm_double(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_operator_norm_double(_:_:)"
        },
        {
          "description" : "Computes the specified operator norm of the single-precision sparse matrix *A*.",
          "name" : "sparse_operator_norm_float(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_operator_norm_float(_:_:)"
        },
        {
          "description" : "Computes the sum along the specified diagonal of the double-precision sparse matrix *A*.",
          "name" : "sparse_matrix_trace_double(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_matrix_trace_double(_:_:)"
        },
        {
          "description" : "Computes the sum along the specified diagonal of the single-precision sparse matrix *A*.",
          "name" : "sparse_matrix_trace_float(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_matrix_trace_float(_:_:)"
        }
      ],
      "title" : "Matrix-Vector Operations"
    }
  ],
  "source" : "appleJSON",
  "title" : "sparse_matrix_vector_product_dense_float(_:_:_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_matrix_vector_product_dense_float(_:_:_:_:_:_:_:)"
}