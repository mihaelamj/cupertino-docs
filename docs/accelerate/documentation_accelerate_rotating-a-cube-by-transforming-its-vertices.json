{
  "abstract" : "Rotate a cube through a series of keyframes using quaternion interpolation to transition between them.",
  "codeExamples" : [
    {
      "code" : "let cubeVertexOrigins: [simd_double3] = [\n    simd_double3(x: -0.5, y: -0.5, z: 0.5),\n    simd_double3(x: 0.5, y: -0.5, z: 0.5),\n    simd_double3(x: -0.5, y: -0.5, z: -0.5),\n    simd_double3(x: 0.5, y: -0.5, z: -0.5),\n    simd_double3(x: -0.5, y: 0.5, z: 0.5),\n    simd_double3(x: 0.5, y: 0.5, z: 0.5),\n    simd_double3(x: -0.5, y: 0.5, z: -0.5),\n    simd_double3(x: 0.5, y: 0.5, z: -0.5)\n    ]",
      "language" : "swift"
    },
    {
      "code" : "lazy var cubeVertices = cubeVertexOrigins",
      "language" : "swift"
    },
    {
      "code" : "let vertexRotations: [simd_quatd] = [\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1))),\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1))),\n    simd_quatd(angle: .pi * 0.05,\n               axis: simd_normalize(simd_double3(x: 0, y: 1, z: 0))),\n    simd_quatd(angle: .pi * 0.1,\n               axis: simd_normalize(simd_double3(x: 1, y: 0, z: -1))),\n    simd_quatd(angle: .pi * 0.15,\n               axis: simd_normalize(simd_double3(x: 0, y: 1, z: 0))),\n    simd_quatd(angle: .pi * 0.2,\n               axis: simd_normalize(simd_double3(x: -1, y: 0, z: 1))),\n    simd_quatd(angle: .pi * 0.15,\n               axis: simd_normalize(simd_double3(x: 0, y: -1, z: 0))),\n    simd_quatd(angle: .pi * 0.1,\n               axis: simd_normalize(simd_double3(x: 1, y: 0, z: -1))),\n    simd_quatd(angle: .pi * 0.05,\n               axis: simd_normalize(simd_double3(x: 0, y: 1, z: 0))),\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1))),\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1)))\n]",
      "language" : "swift"
    },
    {
      "code" : "CVDisplayLinkCreateWithCGDisplay(CGMainDisplayID(), &displayLink)\n\nlet displayCallback: CVDisplayLinkOutputCallback = { _, _, _, _, _, displayLinkContext in\n    \n    if let displayLinkContext = displayLinkContext {\n        DispatchQueue.main.async {\n            let cubeRotation = Unmanaged<CubeRotation>.fromOpaque(displayLinkContext).takeUnretainedValue()\n            cubeRotation.vertexRotationStep()\n        }\n    }\n    \n    return kCVReturnSuccess\n}\n\nCVDisplayLinkSetOutputCallback(displayLink,\n                               displayCallback,\n                               Unmanaged.passUnretained(self).toOpaque())\n\nCVDisplayLinkStart(displayLink)",
      "language" : "swift"
    },
    {
      "code" : "var vertexRotationIndex = 1\nvar vertexRotationTime: Double = 0",
      "language" : "swift"
    },
    {
      "code" : "let increment: Double = 0.02\nvertexRotationTime += increment",
      "language" : "swift"
    },
    {
      "code" : "quaternion = simd_slerp(\n    vertexRotations[vertexRotationIndex],\n    vertexRotations[vertexRotationIndex + 1],\n    vertexRotationTime)",
      "language" : "swift"
    },
    {
      "code" : "cubeVertices = cubeVertexOrigins.map {\n    return quaternion.act($0)\n}",
      "language" : "swift"
    },
    {
      "code" : "if vertexRotationTime >= 1 {\n    vertexRotationIndex += 1\n    vertexRotationTime = 0\n\n    if vertexRotationIndex > vertexRotations.count - 3 {\n        scene = setupSceneKit()\n\n        vertexRotationIndex = 1\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "quaternion = simd_spline(\n    vertexRotations[vertexRotationIndex - 1],\n    vertexRotations[vertexRotationIndex],\n    vertexRotations[vertexRotationIndex + 1],\n    vertexRotations[vertexRotationIndex + 2],\n    vertexRotationTime)",
      "language" : "swift"
    }
  ],
  "contentHash" : "40046b8058a416e20d44c39129c931016cbafa5c2e73ea6138462f07e3f4ee38",
  "crawledAt" : "2025-12-02T15:46:08Z",
  "id" : "097DA83A-CF00-4BF0-A839-3EFBB381936A",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nQuaternions are fundamental to graphics programming and are often used as a compact representation of the rotation of an object in three dimensions. You can rotate a 3D object in space by applying unit quaternion actions to each of its vertices. The [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/simd-library] module includes functions to interpolate between a series of rotational keyframes — defined by unit quaternions — with either the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] (for linear interpolation) or the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] (for smooth, spline-based interpolation) functions.\n\nThis sample code project defines a cube using eight vertices and transforms it through a series of rotations. The sample app provides a SwiftUI [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Toggle] control that switches between a series of discrete spherical linear interpolations (that is, a series of separate arcs between each keyframe) and a continuous spline (that is, a single, smooth path between each keyframe).\n\n### Define a cube by its vertices\n\nThe sample code defines a cube with eight [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_double3] vectors. Each vector specifies the 3D position of one of the cube’s corners.\n\nThe quaternion keyframes act upon the vertex origins and mutate `cubeVertices` to rotate the cube.\n\nThis sample uses [https:\/\/developer.apple.com\/scenekit\/] to render the cube that vertices in the `cubeVertices` array define. You can also use the technique that the sample code uses to rotate geometry in other technologies such as [https:\/\/developer.apple.com\/metal\/]. The following image shows the cube, defined by the vertices above, rendered in SceneKit:\n\n\n\n### Define the quaternion rotation keyframes\n\nAs discussed in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/working-with-quaternions], spline interpolation requires a quaternion before the current value and a quaternion after the next value to compute the interpolated value. To support this, the following code defines the series of rotations with additional values at the beginning and end. The following declaration duplicates the first and last elements.\n\n### Animate between keyframes with spherical interpolation\n\nThis sample uses a [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvdisplaylink-k0k] instance to schedule updates to the cube’s vertices and calls the  `vertexRotationStep()` function every frame.\n\nThe following variables define the current index in `vertexRotations` and the time, between `0.0` and `1.0`, for the current interpolation:\n\nWith each display link notification, the `vertexRotationStep` function increments the vertex rotation time variable by a small amount.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] function returns a quaternion that’s spherically interpolated between the current and next quaternion keyframe at the specified time:\n\nThe quaternion acts upon each of the cube’s vertices and rotates the cube around its center:\n\nIf the vertex rotation time is greater than or equal to one, the code progresses to the next keyframe, increments the index to the rotations array, and resets the rotation time to zero. When the code has reached the last usable quaternion in the array of rotations, it ends the animation.\n\nOver time, the cube animates through the series of keyframes. The following image shows the sharp change in direction as the cube rotates between the keyframes:\n\n\n\n### Animate between keyframes with spline interpolation\n\nThe sample code uses the identical code to the spherical interpolation sample for spline interpolation, apart from one difference: rather than generating the quaternion that acts upon the vertices with [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db], it uses the  [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] function.\n\nThe image below shows that the spline interpolation creates transitions between the quaternion keyframes that are smoother than the linear spherical interpolation.\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/rotating-a-cube-by-transforming-its-vertices\ncrawled: 2025-12-02T15:46:08Z\n---\n\n# Rotating a cube by transforming its vertices\n\n**Sample Code**\n\nRotate a cube through a series of keyframes using quaternion interpolation to transition between them.\n\n## Overview\n\nQuaternions are fundamental to graphics programming and are often used as a compact representation of the rotation of an object in three dimensions. You can rotate a 3D object in space by applying unit quaternion actions to each of its vertices. The [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/simd-library] module includes functions to interpolate between a series of rotational keyframes — defined by unit quaternions — with either the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] (for linear interpolation) or the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] (for smooth, spline-based interpolation) functions.\n\nThis sample code project defines a cube using eight vertices and transforms it through a series of rotations. The sample app provides a SwiftUI [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Toggle] control that switches between a series of discrete spherical linear interpolations (that is, a series of separate arcs between each keyframe) and a continuous spline (that is, a single, smooth path between each keyframe).\n\n### Define a cube by its vertices\n\nThe sample code defines a cube with eight [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_double3] vectors. Each vector specifies the 3D position of one of the cube’s corners.\n\n```swift\nlet cubeVertexOrigins: [simd_double3] = [\n    simd_double3(x: -0.5, y: -0.5, z: 0.5),\n    simd_double3(x: 0.5, y: -0.5, z: 0.5),\n    simd_double3(x: -0.5, y: -0.5, z: -0.5),\n    simd_double3(x: 0.5, y: -0.5, z: -0.5),\n    simd_double3(x: -0.5, y: 0.5, z: 0.5),\n    simd_double3(x: 0.5, y: 0.5, z: 0.5),\n    simd_double3(x: -0.5, y: 0.5, z: -0.5),\n    simd_double3(x: 0.5, y: 0.5, z: -0.5)\n    ]\n```\n\nThe quaternion keyframes act upon the vertex origins and mutate `cubeVertices` to rotate the cube.\n\n```swift\nlazy var cubeVertices = cubeVertexOrigins\n```\n\nThis sample uses [https:\/\/developer.apple.com\/scenekit\/] to render the cube that vertices in the `cubeVertices` array define. You can also use the technique that the sample code uses to rotate geometry in other technologies such as [https:\/\/developer.apple.com\/metal\/]. The following image shows the cube, defined by the vertices above, rendered in SceneKit:\n\n\n\n### Define the quaternion rotation keyframes\n\nAs discussed in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/working-with-quaternions], spline interpolation requires a quaternion before the current value and a quaternion after the next value to compute the interpolated value. To support this, the following code defines the series of rotations with additional values at the beginning and end. The following declaration duplicates the first and last elements.\n\n```swift\nlet vertexRotations: [simd_quatd] = [\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1))),\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1))),\n    simd_quatd(angle: .pi * 0.05,\n               axis: simd_normalize(simd_double3(x: 0, y: 1, z: 0))),\n    simd_quatd(angle: .pi * 0.1,\n               axis: simd_normalize(simd_double3(x: 1, y: 0, z: -1))),\n    simd_quatd(angle: .pi * 0.15,\n               axis: simd_normalize(simd_double3(x: 0, y: 1, z: 0))),\n    simd_quatd(angle: .pi * 0.2,\n               axis: simd_normalize(simd_double3(x: -1, y: 0, z: 1))),\n    simd_quatd(angle: .pi * 0.15,\n               axis: simd_normalize(simd_double3(x: 0, y: -1, z: 0))),\n    simd_quatd(angle: .pi * 0.1,\n               axis: simd_normalize(simd_double3(x: 1, y: 0, z: -1))),\n    simd_quatd(angle: .pi * 0.05,\n               axis: simd_normalize(simd_double3(x: 0, y: 1, z: 0))),\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1))),\n    simd_quatd(angle: 0,\n               axis: simd_normalize(simd_double3(x: 0, y: 0, z: 1)))\n]\n```\n\n### Animate between keyframes with spherical interpolation\n\nThis sample uses a [doc:\/\/com.apple.documentation\/documentation\/CoreVideo\/cvdisplaylink-k0k] instance to schedule updates to the cube’s vertices and calls the  `vertexRotationStep()` function every frame.\n\n```swift\nCVDisplayLinkCreateWithCGDisplay(CGMainDisplayID(), &displayLink)\n\nlet displayCallback: CVDisplayLinkOutputCallback = { _, _, _, _, _, displayLinkContext in\n    \n    if let displayLinkContext = displayLinkContext {\n        DispatchQueue.main.async {\n            let cubeRotation = Unmanaged<CubeRotation>.fromOpaque(displayLinkContext).takeUnretainedValue()\n            cubeRotation.vertexRotationStep()\n        }\n    }\n    \n    return kCVReturnSuccess\n}\n\nCVDisplayLinkSetOutputCallback(displayLink,\n                               displayCallback,\n                               Unmanaged.passUnretained(self).toOpaque())\n\nCVDisplayLinkStart(displayLink)\n```\n\nThe following variables define the current index in `vertexRotations` and the time, between `0.0` and `1.0`, for the current interpolation:\n\n```swift\nvar vertexRotationIndex = 1\nvar vertexRotationTime: Double = 0\n```\n\nWith each display link notification, the `vertexRotationStep` function increments the vertex rotation time variable by a small amount.\n\n```swift\nlet increment: Double = 0.02\nvertexRotationTime += increment\n```\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] function returns a quaternion that’s spherically interpolated between the current and next quaternion keyframe at the specified time:\n\n```swift\nquaternion = simd_slerp(\n    vertexRotations[vertexRotationIndex],\n    vertexRotations[vertexRotationIndex + 1],\n    vertexRotationTime)\n```\n\nThe quaternion acts upon each of the cube’s vertices and rotates the cube around its center:\n\n```swift\ncubeVertices = cubeVertexOrigins.map {\n    return quaternion.act($0)\n}\n```\n\nIf the vertex rotation time is greater than or equal to one, the code progresses to the next keyframe, increments the index to the rotations array, and resets the rotation time to zero. When the code has reached the last usable quaternion in the array of rotations, it ends the animation.\n\n```swift\nif vertexRotationTime >= 1 {\n    vertexRotationIndex += 1\n    vertexRotationTime = 0\n\n    if vertexRotationIndex > vertexRotations.count - 3 {\n        scene = setupSceneKit()\n\n        vertexRotationIndex = 1\n    }\n}\n```\n\nOver time, the cube animates through the series of keyframes. The following image shows the sharp change in direction as the cube rotates between the keyframes:\n\n\n\n### Animate between keyframes with spline interpolation\n\nThe sample code uses the identical code to the spherical interpolation sample for spline interpolation, apart from one difference: rather than generating the quaternion that acts upon the vertices with [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db], it uses the  [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] function.\n\n```swift\nquaternion = simd_spline(\n    vertexRotations[vertexRotationIndex - 1],\n    vertexRotations[vertexRotationIndex],\n    vertexRotations[vertexRotationIndex + 1],\n    vertexRotations[vertexRotationIndex + 2],\n    vertexRotationTime)\n```\n\nThe image below shows that the spline interpolation creates transitions between the quaternion keyframes that are smoother than the linear spherical interpolation.\n\n\n\n## Vectors, Matrices, and Quaternions\n\n- **Working with Vectors**: Use vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.\n- **Working with Matrices**: Solve simultaneous equations and transform points in space.\n- **Working with Quaternions**: Rotate points around the surface of a sphere, and interpolate between them.\n- **simd**: Perform computations on small vectors and matrices.\n- **vForce**: Perform transcendental and trigonometric functions on vectors of any length.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.",
          "name" : "Working with Vectors",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-vectors"
        },
        {
          "description" : "Solve simultaneous equations and transform points in space.",
          "name" : "Working with Matrices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-matrices"
        },
        {
          "description" : "Rotate points around the surface of a sphere, and interpolate between them.",
          "name" : "Working with Quaternions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-quaternions"
        },
        {
          "description" : "Perform computations on small vectors and matrices.",
          "name" : "simd",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/simd-library"
        },
        {
          "description" : "Perform transcendental and trigonometric functions on vectors of any length.",
          "name" : "vForce",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vforce-library"
        }
      ],
      "title" : "Vectors, Matrices, and Quaternions"
    }
  ],
  "source" : "appleJSON",
  "title" : "Rotating a cube by transforming its vertices",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/rotating-a-cube-by-transforming-its-vertices"
}