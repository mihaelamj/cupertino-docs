{
  "abstract" : "Use direct methods to solve systems of equations where the coefficient matrix is sparse.",
  "codeExamples" : [

  ],
  "contentHash" : "8e86479a2afee817bf82d42450597db73195ae9193f4da2ba510b2dea50ffa37",
  "crawledAt" : "2025-12-02T15:37:36Z",
  "id" : "FC0DB3B4-9B34-49B1-8A1A-30C2048C0ED8",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nDirect methods offer high-precision solving with a simple API when compared to iterative methods. The code example below uses sparse Cholesky factorization to solve the following equation:\n\n\n\nIn the equation above, *A* refers to the four-by-four coefficient matrix and *b* to the right-hand-side vector. The code in this article solves the equation *Ax = b* by finding *x*.\n\nNote that *A* is sparse. Some entries (those that are blank) are zero. For small matrices such as this, there’s little gain in exploiting this structure. However, it’s essential for larger systems that don’t otherwise fit in memory, even on a large computer.\n\nThe code in this article performs a sparse Cholesky factorization, equivalent to calling the LAPACK function `dpotrf_(_:_:_:_:_:)` on a dense matrix. The main requirement for sparse Cholesky factorization is that the matrix is symmetric positive-definite (that is, *A=Aᵀ),* and all eigenvalues are greater than zero. A sufficient, but not necessary, condition is that the matrix is diagonally dominant (that is, the sum of the absolute values of the off-diagonal entries in each row or column is less than the value of the diagonal). This is the case for the above matrix.\n\n### Create the matrix structure\n\nUse the code below to define the matrix structure. As [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/creating-sparse-matrices] explains, because *A* is symmetric, it stores only half of the data.\n\n### Create and factorize the matrix\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:)-8gl6j] function performs the actual Cholesky factorization, finding *L* such that *A = LLᵀ*.\n\nIf the factorization function encounters an error, the code prints an error message and terminates. You may instead want to capture the error by using the optional [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSymbolicFactorOptions] parameter and set the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSymbolicFactorOptions\/reportError] parameter to a user-supplied error-handling routine. The returned [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseOpaqueFactorization_Double] structure reflects the error.\n\n### Solve the equation\n\nUse the factorization to solve the equation. The right-hand-side and solution vectors are arrays that you wrap in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DenseVector_Double] structures. The actual values of `x` don’t matter because the function overwrites them.\n\nThe solve call takes the factorization *A = LLᵀ* and solves the system *Ax = b* as *LLᵀx = b* by solving the two triangular systems:\n\nHowever, you need only to supply the right-hand-side vector and the factorization.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSolve(_:_:_:)-416bj] function solves the equation and populates `x` with the solution.\n\nIf the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSolve(_:_:_:)-416bj] function encounters an error, the code prints an error message and terminates, unless you set [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSymbolicFactorOptions\/reportError] on the initial call to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:)-8gl6j].\n\nThe following code iterates over the solution vector, `x`, and prints the solution, `x = 0.10 0.20 0.30 0.40`.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-using-direct-methods\ncrawled: 2025-12-02T15:37:36Z\n---\n\n# Solving systems using direct methods\n\n**Article**\n\nUse direct methods to solve systems of equations where the coefficient matrix is sparse.\n\n## Overview\n\nDirect methods offer high-precision solving with a simple API when compared to iterative methods. The code example below uses sparse Cholesky factorization to solve the following equation:\n\n\n\nIn the equation above, *A* refers to the four-by-four coefficient matrix and *b* to the right-hand-side vector. The code in this article solves the equation *Ax = b* by finding *x*.\n\nNote that *A* is sparse. Some entries (those that are blank) are zero. For small matrices such as this, there’s little gain in exploiting this structure. However, it’s essential for larger systems that don’t otherwise fit in memory, even on a large computer.\n\nThe code in this article performs a sparse Cholesky factorization, equivalent to calling the LAPACK function `dpotrf_(_:_:_:_:_:)` on a dense matrix. The main requirement for sparse Cholesky factorization is that the matrix is symmetric positive-definite (that is, *A=Aᵀ),* and all eigenvalues are greater than zero. A sufficient, but not necessary, condition is that the matrix is diagonally dominant (that is, the sum of the absolute values of the off-diagonal entries in each row or column is less than the value of the diagonal). This is the case for the above matrix.\n\n### Create the matrix structure\n\nUse the code below to define the matrix structure. As [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/creating-sparse-matrices] explains, because *A* is symmetric, it stores only half of the data.\n\n\n\n### Create and factorize the matrix\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:)-8gl6j] function performs the actual Cholesky factorization, finding *L* such that *A = LLᵀ*.\n\n\n\nIf the factorization function encounters an error, the code prints an error message and terminates. You may instead want to capture the error by using the optional [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSymbolicFactorOptions] parameter and set the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSymbolicFactorOptions\/reportError] parameter to a user-supplied error-handling routine. The returned [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseOpaqueFactorization_Double] structure reflects the error.\n\n### Solve the equation\n\nUse the factorization to solve the equation. The right-hand-side and solution vectors are arrays that you wrap in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DenseVector_Double] structures. The actual values of `x` don’t matter because the function overwrites them.\n\n\n\nThe solve call takes the factorization *A = LLᵀ* and solves the system *Ax = b* as *LLᵀx = b* by solving the two triangular systems:\n\n- *Ly = b*\n- *Lᵀx = y*\n\nHowever, you need only to supply the right-hand-side vector and the factorization.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSolve(_:_:_:)-416bj] function solves the equation and populates `x` with the solution.\n\n\n\nIf the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSolve(_:_:_:)-416bj] function encounters an error, the code prints an error message and terminates, unless you set [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseSymbolicFactorOptions\/reportError] on the initial call to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:)-8gl6j].\n\nThe following code iterates over the solution vector, `x`, and prints the solution, `x = 0.10 0.20 0.30 0.40`.\n\n\n\n## Sparse Matrices\n\n- **Creating sparse matrices**: Create sparse matrices for factorization and solving systems.\n- **Solving systems using iterative methods**: Use iterative methods to solve systems of equations where the coefficient matrix is sparse.\n- **Creating a sparse matrix from coordinate format arrays**: Use separate coordinate format arrays to create sparse matrices.\n- **Sparse Solvers**: Solve systems of equations where the coefficient matrix is sparse.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create sparse matrices for factorization and solving systems.",
          "name" : "Creating sparse matrices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-sparse-matrices"
        },
        {
          "description" : "Use iterative methods to solve systems of equations where the coefficient matrix is sparse.",
          "name" : "Solving systems using iterative methods",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-using-iterative-methods"
        },
        {
          "description" : "Use separate coordinate format arrays to create sparse matrices.",
          "name" : "Creating a sparse matrix from coordinate format arrays",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-a-sparse-matrix-from-coordinate-format-arrays"
        },
        {
          "description" : "Solve systems of equations where the coefficient matrix is sparse.",
          "name" : "Sparse Solvers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-solvers-library"
        }
      ],
      "title" : "Sparse Matrices"
    }
  ],
  "source" : "appleJSON",
  "title" : "Solving systems using direct methods",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-using-direct-methods"
}