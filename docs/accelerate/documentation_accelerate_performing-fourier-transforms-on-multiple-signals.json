{
  "abstract" : "Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Returns an array that contains a composite sine wave from the \n\/\/\/ specified frequency-amplitude pairs.\nstatic func makeCompositeSineWave(from frequencyAmplitudePairs: [(f: Float,\n                                                                  a: Float)],\n                                  count: Int) -> [Float] {\n\n\n    return [Float](unsafeUninitializedCapacity: count) {\n        buffer, initializedCount in\n        \n        \/\/\/ Fill the buffer with zeros.\n        vDSP.fill(&buffer, with: 0)\n        \/\/\/ Create a reusable array to store the sine wave for each iteration.\n        var iterationValues = [Float](repeating: 0, count: count)\n        \n        for frequencyAmplitudePair in frequencyAmplitudePairs {\n            \/\/\/ Fill the working array with a ramp in the range `0 ..< frequency`.\n            vDSP.formRamp(withInitialValue: 0,\n                          increment: frequencyAmplitudePair.f \/ Float(count \/ 2),\n                          result: &iterationValues)\n            \/\/\/ Compute `sin(x * .pi)` for each element.\n            vForce.sinPi(iterationValues, result: &iterationValues)\n            if frequencyAmplitudePair.a != 1 {\n                \/\/\/ Mulitply each element by the specified amplitude.\n                vDSP.multiply(frequencyAmplitudePair.a, iterationValues,\n                              result: &iterationValues)\n            }\n            \/\/\/ Add this sine wave iteration to the composite sine wave accumulator.\n            vDSP.add(iterationValues, buffer, result: &buffer)\n        }\n        \n        initializedCount = count\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let realValuesCount = 256\n\nlet signal: [Float] = {\n    let signal0 = makeCompositeSineWave(from: [(f: 1, a: 1),\n                                               (f: 5, a: 0.2)],\n                                        count: realValuesCount)\n    \n    let signal1 = makeCompositeSineWave(from: [(f: 5, a: 1),\n                                               (f: 7, a: 0.3)],\n                                        count: realValuesCount)\n    \n    let signal2 = makeCompositeSineWave(from: [(f: 3, a: 1),\n                                               (f: 9, a: 0.6)],\n                                        count: realValuesCount)\n    \n    let signal3 = makeCompositeSineWave(from: [(f: 7, a: 1),\n                                               (f: 2, a: 0.15)],\n                                        count: realValuesCount)\n    \n    return signal0 + signal1 + signal2 + signal3\n}()",
      "language" : "swift"
    },
    {
      "code" : "let complexValuesCount = signal.count \/ 2\n\nvar complexReals = [Float]()\nvar complexImaginaries = [Float]()\n\nsignal.withUnsafeBytes { signalPtr in\n    complexReals = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n        realBuffer, realInitializedCount in\n        complexImaginaries = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n            imagBuffer, imagInitializedCount in\n            var splitComplex = DSPSplitComplex(realp: realBuffer.baseAddress!,\n                                               imagp: imagBuffer.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n            \n            imagInitializedCount = complexValuesCount\n        }\n        realInitializedCount = complexValuesCount\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let signalCount = 4\n\ncomplexReals.withUnsafeMutableBufferPointer { realPtr in\n    complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n        var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                           imagp: imagPtr.baseAddress!)\n        \n        let log2n = vDSP_Length(log2(Float(realValuesCount)))\n        if let fft = vDSP_create_fftsetup(log2n, FFTRadix(kFFTRadix2)) {\n            \n            vDSP_fftm_zrip(fft,\n                           &splitComplex, 1,\n                           vDSP_Stride(realValuesCount \/ 2),\n                           log2n,\n                           vDSP_Length(signalCount),\n                           FFTDirection(kFFTDirection_Forward))\n\n            vDSP_destroy_fftsetup(fft)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let magnitudes = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n    buffer, initializedCount in\n    complexReals.withUnsafeMutableBufferPointer { realPtr in\n        complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n            \n            let splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP.squareMagnitudes(splitComplex,\n                                  result: &buffer)\n        }\n    }\n    \n    initializedCount = complexValuesCount\n}",
      "language" : "swift"
    },
    {
      "code" : "for i in 0 ..< signalCount {\n    let start = i * (realValuesCount \/ 2)\n    let end = start + (realValuesCount \/ 2) - 1\n    \n    let signalMagnitudes = magnitudes[start ..< end]\n    \n    let components = signalMagnitudes.enumerated().filter {\n        $0.element > sqrt(.ulpOfOne)\n    }\n\n    \/\/ Prints\n    \/\/  [(offset: 1, element: 65536.0), (offset: 5, element: 2621.4412)]\n    \/\/  [(offset: 5, element: 65536.016), (offset: 7, element: 5898.24)]\n    \/\/  [(offset: 3, element: 65536.0), (offset: 9, element: 23592.96)]\n    \/\/  [(offset: 2, element: 1474.56), (offset: 7, element: 65536.0)]    \n    print(components)\n}",
      "language" : "swift"
    },
    {
      "code" : "let complexValuesCount = 256\n\nvar realSignal: [Float] = {\n    let signal0 = makeCompositeSineWave(from: [(f: 1, a: 1)],\n                                        count: complexValuesCount)\n    \n    let signal1 = makeCompositeSineWave(from: [(f: 5, a: 1)],\n                                        count: complexValuesCount)\n    \n    let signal2 = makeCompositeSineWave(from: [(f: 3, a: 1)],\n                                        count: complexValuesCount)\n    \n    let signal3 = makeCompositeSineWave(from: [(f: 7, a: 1)],\n                                        count: complexValuesCount)\n    \n    return signal0 + signal1 + signal2 + signal3\n}()\n\nvar imaginarySignal: [Float] = {\n    let signal0 = makeCompositeSineWave(from: [(f: 5, a: 0.2)],\n                                        count: complexValuesCount)\n    \n    let signal1 = makeCompositeSineWave(from: [(f: 7, a: 0.3)],\n                                        count: complexValuesCount)\n    \n    let signal2 = makeCompositeSineWave(from: [(f: 9, a: 0.6)],\n                                        count: complexValuesCount)\n    \n    let signal3 = makeCompositeSineWave(from: [(f: 2, a: 0.15)],\n                                        count: complexValuesCount)\n    \n    return signal0 + signal1 + signal2 + signal3\n}()",
      "language" : "swift"
    },
    {
      "code" : "let signalCount = 4\n\nrealSignal.withUnsafeMutableBufferPointer { realPtr in\n    imaginarySignal.withUnsafeMutableBufferPointer { imagPtr in\n        var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                           imagp: imagPtr.baseAddress!)\n        \n        let log2n = vDSP_Length(log2(Float(complexValuesCount)))\n        if let fft = vDSP_create_fftsetup(log2n, FFTRadix(kFFTRadix2)) {\n            \n            vDSP_fftm_zip(fft,\n                          &splitComplex, 1,\n                          vDSP_Stride(complexValuesCount),\n                          log2n,\n                          vDSP_Length(signalCount),\n                          FFTDirection(kFFTDirection_Forward))\n\n            vDSP_destroy_fftsetup(fft)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let magnitudesCount = complexValuesCount * signalCount\nlet magnitudes = [Float](unsafeUninitializedCapacity: magnitudesCount) {\n    buffer, initializedCount in\n    realSignal.withUnsafeMutableBufferPointer { realPtr in\n        imaginarySignal.withUnsafeMutableBufferPointer { imagPtr in\n            \n            let splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP.squareMagnitudes(splitComplex,\n                                  result: &buffer)\n        }\n    }\n    \n    initializedCount = magnitudesCount\n}",
      "language" : "swift"
    },
    {
      "code" : "for i in 0 ..< signalCount {\n    let start = i * (complexValuesCount)\n    let end = start + (complexValuesCount \/ 2) - 1\n    \n    let signalMagnitudes = magnitudes[start ..< end]\n    \n    let components = signalMagnitudes.enumerated().filter {\n        $0.element > sqrt(.ulpOfOne)\n    }\n    \n    \/\/ Prints\n    \/\/ [(offset: 1, element: 16384.0), (offset: 5, element: 655.3602)]\n    \/\/ [(offset: 5, element: 16384.0), (offset: 7, element: 1474.56)]\n    \/\/ [(offset: 3, element: 16384.0), (offset: 9, element: 5898.24)]\n    \/\/ [(offset: 2, element: 368.64), (offset: 7, element: 16384.0)]\n    print(components)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ab5a1e1e7a4c1da48fec2ff61cbc14584866c9a142bd44fbb8dac9b8d4f01438",
  "crawledAt" : "2025-12-02T15:37:21Z",
  "id" : "DD9AD4AD-90E8-4308-B884-34D955A450E7",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nvDSP provides functions for performing fast Fourier transforms (FFTs) on multiple signals with a single function call. Transforming multiple signals is suited to processing stereo audio data or data that’s aquired from multiple sources.\n\n### Create a Composite Sine Wave\n\nThe examples in this article use the following function to create an array with values that represent a composite sine wave:\n\n### Perform FFT on Multiple Real Signals\n\nThe vDSP multiple-signal FFT functions accept multiple signals concatenated together. The following code creates a single 1024 element array from four separate composite sine waves:\n\nThe following image is a visualization of the values in `signal`:\n\n\n\nThe vDSP FFT and DFT functions work with data in split-complex format. Split-complex format stores the real and imaginary parts of complex numbers in the corresponding elements of two separate arrays.\n\nUse the [doc:\/\/com.apple.documentation\/documentation\/kernel\/1579975-vdsp_ctoz] function to convert the real values in the signal array to split-complex format. The [doc:\/\/com.apple.documentation\/documentation\/kernel\/1579975-vdsp_ctoz] function transforms the real values so that the real array contains even elements, and the imaginary array contains odd elements.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fftm_zrip] function performs the FFT. Create a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure that acts as a mediatory between the real and imaginary arrays and the FFT function. The third parameter to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fftm_zrip] (the stride between the individual signals) is measured in complex elements.\n\nOn return, `complexReals` and `complexImaginaries` contain the frequency-domain representation of the four real signals. Call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/squareMagnitudes(_:result:)-22k5h] to compute the energy at each frequency.\n\nUse the magnitudes information to calculate the component frequencies of each of the four signals. The offset of each nonzero magnitude represents the frequency, and the value represents the energy.\n\n### Perform FFT on Multiple Complex Signals\n\nA complex signal contains two real signals, one in the real parts and one in the imaginary parts. The following code creates two 1024-element arrays that contain the real and imaginary parts of four 256-element complex signals:\n\nThe following image is a visualization of the values in `realSignal` as a solid line and the values in `imaginarySignal` as a dashed line:\n\n\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fftm_zip] function performs the FFT in-place on the real and imaginary arrays.\n\nOn return, `realSignal` and `imaginarySignal` contain the frequency-domain representation of the four complex signals. Call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/squareMagnitudes(_:result:)-22k5h] to compute the energy at each frequency.\n\nUse the magnitudes information to calculate the component frequencies of each of the four signals. The offset of each nonzero magnitude represents the frequency, and the value represents the energy.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals\ncrawled: 2025-12-02T15:37:21Z\n---\n\n# Performing Fourier Transforms on Multiple Signals\n\n**Article**\n\nUse Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.\n\n## Overview\n\nvDSP provides functions for performing fast Fourier transforms (FFTs) on multiple signals with a single function call. Transforming multiple signals is suited to processing stereo audio data or data that’s aquired from multiple sources.\n\n### Create a Composite Sine Wave\n\nThe examples in this article use the following function to create an array with values that represent a composite sine wave:\n\n```swift\n\/\/\/ Returns an array that contains a composite sine wave from the \n\/\/\/ specified frequency-amplitude pairs.\nstatic func makeCompositeSineWave(from frequencyAmplitudePairs: [(f: Float,\n                                                                  a: Float)],\n                                  count: Int) -> [Float] {\n\n\n    return [Float](unsafeUninitializedCapacity: count) {\n        buffer, initializedCount in\n        \n        \/\/\/ Fill the buffer with zeros.\n        vDSP.fill(&buffer, with: 0)\n        \/\/\/ Create a reusable array to store the sine wave for each iteration.\n        var iterationValues = [Float](repeating: 0, count: count)\n        \n        for frequencyAmplitudePair in frequencyAmplitudePairs {\n            \/\/\/ Fill the working array with a ramp in the range `0 ..< frequency`.\n            vDSP.formRamp(withInitialValue: 0,\n                          increment: frequencyAmplitudePair.f \/ Float(count \/ 2),\n                          result: &iterationValues)\n            \/\/\/ Compute `sin(x * .pi)` for each element.\n            vForce.sinPi(iterationValues, result: &iterationValues)\n            if frequencyAmplitudePair.a != 1 {\n                \/\/\/ Mulitply each element by the specified amplitude.\n                vDSP.multiply(frequencyAmplitudePair.a, iterationValues,\n                              result: &iterationValues)\n            }\n            \/\/\/ Add this sine wave iteration to the composite sine wave accumulator.\n            vDSP.add(iterationValues, buffer, result: &buffer)\n        }\n        \n        initializedCount = count\n    }\n}\n```\n\n### Perform FFT on Multiple Real Signals\n\nThe vDSP multiple-signal FFT functions accept multiple signals concatenated together. The following code creates a single 1024 element array from four separate composite sine waves:\n\n```swift\nlet realValuesCount = 256\n\nlet signal: [Float] = {\n    let signal0 = makeCompositeSineWave(from: [(f: 1, a: 1),\n                                               (f: 5, a: 0.2)],\n                                        count: realValuesCount)\n    \n    let signal1 = makeCompositeSineWave(from: [(f: 5, a: 1),\n                                               (f: 7, a: 0.3)],\n                                        count: realValuesCount)\n    \n    let signal2 = makeCompositeSineWave(from: [(f: 3, a: 1),\n                                               (f: 9, a: 0.6)],\n                                        count: realValuesCount)\n    \n    let signal3 = makeCompositeSineWave(from: [(f: 7, a: 1),\n                                               (f: 2, a: 0.15)],\n                                        count: realValuesCount)\n    \n    return signal0 + signal1 + signal2 + signal3\n}()\n```\n\nThe following image is a visualization of the values in `signal`:\n\n\n\nThe vDSP FFT and DFT functions work with data in split-complex format. Split-complex format stores the real and imaginary parts of complex numbers in the corresponding elements of two separate arrays.\n\nUse the [doc:\/\/com.apple.documentation\/documentation\/kernel\/1579975-vdsp_ctoz] function to convert the real values in the signal array to split-complex format. The [doc:\/\/com.apple.documentation\/documentation\/kernel\/1579975-vdsp_ctoz] function transforms the real values so that the real array contains even elements, and the imaginary array contains odd elements.\n\n```swift\nlet complexValuesCount = signal.count \/ 2\n\nvar complexReals = [Float]()\nvar complexImaginaries = [Float]()\n\nsignal.withUnsafeBytes { signalPtr in\n    complexReals = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n        realBuffer, realInitializedCount in\n        complexImaginaries = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n            imagBuffer, imagInitializedCount in\n            var splitComplex = DSPSplitComplex(realp: realBuffer.baseAddress!,\n                                               imagp: imagBuffer.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n            \n            imagInitializedCount = complexValuesCount\n        }\n        realInitializedCount = complexValuesCount\n    }\n}\n```\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fftm_zrip] function performs the FFT. Create a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure that acts as a mediatory between the real and imaginary arrays and the FFT function. The third parameter to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fftm_zrip] (the stride between the individual signals) is measured in complex elements.\n\n```swift\nlet signalCount = 4\n\ncomplexReals.withUnsafeMutableBufferPointer { realPtr in\n    complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n        var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                           imagp: imagPtr.baseAddress!)\n        \n        let log2n = vDSP_Length(log2(Float(realValuesCount)))\n        if let fft = vDSP_create_fftsetup(log2n, FFTRadix(kFFTRadix2)) {\n            \n            vDSP_fftm_zrip(fft,\n                           &splitComplex, 1,\n                           vDSP_Stride(realValuesCount \/ 2),\n                           log2n,\n                           vDSP_Length(signalCount),\n                           FFTDirection(kFFTDirection_Forward))\n\n            vDSP_destroy_fftsetup(fft)\n        }\n    }\n}\n```\n\nOn return, `complexReals` and `complexImaginaries` contain the frequency-domain representation of the four real signals. Call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/squareMagnitudes(_:result:)-22k5h] to compute the energy at each frequency.\n\n```swift\nlet magnitudes = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n    buffer, initializedCount in\n    complexReals.withUnsafeMutableBufferPointer { realPtr in\n        complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n            \n            let splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP.squareMagnitudes(splitComplex,\n                                  result: &buffer)\n        }\n    }\n    \n    initializedCount = complexValuesCount\n}\n```\n\nUse the magnitudes information to calculate the component frequencies of each of the four signals. The offset of each nonzero magnitude represents the frequency, and the value represents the energy.\n\n```swift\nfor i in 0 ..< signalCount {\n    let start = i * (realValuesCount \/ 2)\n    let end = start + (realValuesCount \/ 2) - 1\n    \n    let signalMagnitudes = magnitudes[start ..< end]\n    \n    let components = signalMagnitudes.enumerated().filter {\n        $0.element > sqrt(.ulpOfOne)\n    }\n\n    \/\/ Prints\n    \/\/  [(offset: 1, element: 65536.0), (offset: 5, element: 2621.4412)]\n    \/\/  [(offset: 5, element: 65536.016), (offset: 7, element: 5898.24)]\n    \/\/  [(offset: 3, element: 65536.0), (offset: 9, element: 23592.96)]\n    \/\/  [(offset: 2, element: 1474.56), (offset: 7, element: 65536.0)]    \n    print(components)\n}\n```\n\n### Perform FFT on Multiple Complex Signals\n\nA complex signal contains two real signals, one in the real parts and one in the imaginary parts. The following code creates two 1024-element arrays that contain the real and imaginary parts of four 256-element complex signals:\n\n```swift\nlet complexValuesCount = 256\n\nvar realSignal: [Float] = {\n    let signal0 = makeCompositeSineWave(from: [(f: 1, a: 1)],\n                                        count: complexValuesCount)\n    \n    let signal1 = makeCompositeSineWave(from: [(f: 5, a: 1)],\n                                        count: complexValuesCount)\n    \n    let signal2 = makeCompositeSineWave(from: [(f: 3, a: 1)],\n                                        count: complexValuesCount)\n    \n    let signal3 = makeCompositeSineWave(from: [(f: 7, a: 1)],\n                                        count: complexValuesCount)\n    \n    return signal0 + signal1 + signal2 + signal3\n}()\n\nvar imaginarySignal: [Float] = {\n    let signal0 = makeCompositeSineWave(from: [(f: 5, a: 0.2)],\n                                        count: complexValuesCount)\n    \n    let signal1 = makeCompositeSineWave(from: [(f: 7, a: 0.3)],\n                                        count: complexValuesCount)\n    \n    let signal2 = makeCompositeSineWave(from: [(f: 9, a: 0.6)],\n                                        count: complexValuesCount)\n    \n    let signal3 = makeCompositeSineWave(from: [(f: 2, a: 0.15)],\n                                        count: complexValuesCount)\n    \n    return signal0 + signal1 + signal2 + signal3\n}()\n```\n\nThe following image is a visualization of the values in `realSignal` as a solid line and the values in `imaginarySignal` as a dashed line:\n\n\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fftm_zip] function performs the FFT in-place on the real and imaginary arrays.\n\n```swift\nlet signalCount = 4\n\nrealSignal.withUnsafeMutableBufferPointer { realPtr in\n    imaginarySignal.withUnsafeMutableBufferPointer { imagPtr in\n        var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                           imagp: imagPtr.baseAddress!)\n        \n        let log2n = vDSP_Length(log2(Float(complexValuesCount)))\n        if let fft = vDSP_create_fftsetup(log2n, FFTRadix(kFFTRadix2)) {\n            \n            vDSP_fftm_zip(fft,\n                          &splitComplex, 1,\n                          vDSP_Stride(complexValuesCount),\n                          log2n,\n                          vDSP_Length(signalCount),\n                          FFTDirection(kFFTDirection_Forward))\n\n            vDSP_destroy_fftsetup(fft)\n        }\n    }\n}\n```\n\nOn return, `realSignal` and `imaginarySignal` contain the frequency-domain representation of the four complex signals. Call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/squareMagnitudes(_:result:)-22k5h] to compute the energy at each frequency.\n\n```swift\nlet magnitudesCount = complexValuesCount * signalCount\nlet magnitudes = [Float](unsafeUninitializedCapacity: magnitudesCount) {\n    buffer, initializedCount in\n    realSignal.withUnsafeMutableBufferPointer { realPtr in\n        imaginarySignal.withUnsafeMutableBufferPointer { imagPtr in\n            \n            let splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP.squareMagnitudes(splitComplex,\n                                  result: &buffer)\n        }\n    }\n    \n    initializedCount = magnitudesCount\n}\n```\n\nUse the magnitudes information to calculate the component frequencies of each of the four signals. The offset of each nonzero magnitude represents the frequency, and the value represents the energy.\n\n```swift\nfor i in 0 ..< signalCount {\n    let start = i * (complexValuesCount)\n    let end = start + (complexValuesCount \/ 2) - 1\n    \n    let signalMagnitudes = magnitudes[start ..< end]\n    \n    let components = signalMagnitudes.enumerated().filter {\n        $0.element > sqrt(.ulpOfOne)\n    }\n    \n    \/\/ Prints\n    \/\/ [(offset: 1, element: 16384.0), (offset: 5, element: 655.3602)]\n    \/\/ [(offset: 5, element: 16384.0), (offset: 7, element: 1474.56)]\n    \/\/ [(offset: 3, element: 16384.0), (offset: 9, element: 5898.24)]\n    \/\/ [(offset: 2, element: 368.64), (offset: 7, element: 16384.0)]\n    print(components)\n}\n```\n\n## Fourier and Cosine Transforms\n\n- **Understanding data packing for Fourier transforms**: Format source data for the vDSP Fourier functions, and interpret the results.\n- **Finding the component frequencies in a composite sine wave**: Use 1D fast Fourier transform to compute the frequency components of a signal.\n- **Performing Fourier transforms on interleaved-complex data**: Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.\n- **Reducing spectral leakage with windowing**: Multiply signal data by window sequence values when performing transforms with noninteger period signals.\n- **Signal extraction from noise**: Use Accelerate’s discrete cosine transform to remove noise from a signal.\n- **Halftone descreening with 2D fast Fourier transform**: Reduce or remove periodic artifacts from images.\n- **Fast Fourier transforms**: Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Fourier transforms**: Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Format source data for the vDSP Fourier functions, and interpret the results.",
          "name" : "Understanding data packing for Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms"
        },
        {
          "description" : "Use 1D fast Fourier transform to compute the frequency components of a signal.",
          "name" : "Finding the component frequencies in a composite sine wave",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave"
        },
        {
          "description" : "Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.",
          "name" : "Performing Fourier transforms on interleaved-complex data",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data"
        },
        {
          "description" : "Multiply signal data by window sequence values when performing transforms with noninteger period signals.",
          "name" : "Reducing spectral leakage with windowing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing"
        },
        {
          "description" : "Use Accelerate’s discrete cosine transform to remove noise from a signal.",
          "name" : "Signal extraction from noise",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise"
        },
        {
          "description" : "Reduce or remove periodic artifacts from images.",
          "name" : "Halftone descreening with 2D fast Fourier transform",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform"
        },
        {
          "description" : "Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Fast Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/fast-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Discrete Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Fourier and Cosine Transforms"
    }
  ],
  "source" : "appleJSON",
  "title" : "Performing Fourier Transforms on Multiple Signals",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals"
}