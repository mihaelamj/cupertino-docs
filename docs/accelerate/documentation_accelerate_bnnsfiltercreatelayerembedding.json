{
  "abstract" : "Returns a new embedding layer.",
  "codeExamples" : [
    {
      "code" : "static func embeddingLayer() {\n    \n    let indicesData = UnsafeMutableBufferPointer<Int8>.allocate(capacity: 3)\n    _ = indicesData.initialize(from: [1, 5, 2])\n    let indicesDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                  layout: BNNSDataLayoutVector,\n                                                  size: (3, 0, 0, 0, 0, 0, 0, 0),\n                                                  stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                  data: indicesData.baseAddress!,\n                                                  data_type: BNNSDataType.int8,\n                                                  table_data: nil,\n                                                  table_data_type: BNNSDataType.int8,\n                                                  data_scale: 1, data_bias: 0)\n    \n    let dictionaryItemSize = 5\n    let dictionaryItemCount = 7\n    let dictionaryData = UnsafeMutableBufferPointer<Float>.allocate(capacity: dictionaryItemSize * dictionaryItemCount)\n    _ = dictionaryData.initialize(from: [01, 02, 03, 04, 05,\n                                         11, 12, 13, 14, 15,\n                                         21, 22, 23, 24, 25,\n                                         31, 32, 33, 34, 35,\n                                         41, 42, 43, 44, 45,\n                                         51, 52, 53, 54, 55,\n                                         61, 62, 63, 64, 65])\n    let dictionaryDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                     layout: BNNSDataLayout2DLastMajor,\n                                                     size: (dictionaryItemSize, dictionaryItemCount,\n                                                            0, 0, 0, 0, 0, 0),\n                                                     stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                     data: dictionaryData.baseAddress!,\n                                                     data_type: BNNSDataType.float,\n                                                     table_data: nil,\n                                                     table_data_type: BNNSDataType.float,\n                                                     data_scale: 1, data_bias: 0)\n    \n    let outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: dictionaryItemSize * indicesData.count)\n    let outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                 layout: BNNSDataLayout2DLastMajor,\n                                                 size: (dictionaryItemSize, indicesData.count,\n                                                        0, 0, 0, 0, 0, 0),\n                                                 stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                 data: outputData.baseAddress!,\n                                                 data_type: BNNSDataType.float,\n                                                 table_data: nil,\n                                                 table_data_type: BNNSDataType.float,\n                                                 data_scale: 1, data_bias: 0)\n    \n    var parameters = BNNSLayerParametersEmbedding(flags: BNNSEmbeddingFlags(rawValue: 0),\n                                                  i_desc: indicesDescriptor,\n                                                  o_desc: outputDescriptor,\n                                                  dictionary: dictionaryDescriptor,\n                                                  padding_idx: 0,\n                                                  max_norm: 0,\n                                                  norm_type: 0)\n    \n    let embeddingLayer = BNNSFilterCreateLayerEmbedding(&parameters, nil)\n    \n    BNNSFilterApply(embeddingLayer,\n                    indicesDescriptor.data!,\n                    outputDescriptor.data!)\n    \n    \/\/ Prints:\n    \/\/ [11.0, 12.0, 13.0, 14.0, 15.0,\n    \/\/  51.0, 52.0, 53.0, 54.0, 55.0,\n    \/\/  21.0, 22.0, 23.0, 24.0, 25.0]\n    print(Array(outputData))\n    \n    indicesData.deallocate()\n    dictionaryData.deallocate()\n    outputData.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "static func embeddingLayerClipByNorm() {\n    let indicesData = UnsafeMutableBufferPointer<Int8>.allocate(capacity: 2)\n    _ = indicesData.initialize(from: [1, 2])\n    let indicesDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                  layout: BNNSDataLayoutVector,\n                                                  size: (2, 0, 0, 0, 0, 0, 0, 0),\n                                                  stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                  data: indicesData.baseAddress!,\n                                                  data_type: BNNSDataType.int8,\n                                                  table_data: nil,\n                                                  table_data_type: BNNSDataType.float,\n                                                  data_scale: 1, data_bias: 0)\n    \n    let dictionaryItemRowCount = 2\n    let dictionaryItemColumnCount = 3\n    let dictionaryItemCount = 3\n    let dictionaryElementCount = dictionaryItemRowCount * dictionaryItemColumnCount * dictionaryItemCount\n    let dictionaryData = UnsafeMutableBufferPointer<Float>.allocate(capacity: dictionaryElementCount)\n    _ = dictionaryData.initialize(from: [0.1, 0.2, 0.3,\n                                         0.4, 0.5, 0.6,\n                                       \n                                         1, 3, 5,\n                                         2, 4, 6,\n                                         \n                                         60, 50, 40,\n                                         30, 20, 10])\n    let dictionaryDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                     layout: BNNSDataLayout3DLastMajor,\n                                                     size: (dictionaryItemRowCount,\n                                                            dictionaryItemColumnCount,\n                                                            dictionaryItemCount, 0, 0, 0, 0, 0),\n                                                     stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                     data: dictionaryData.baseAddress!,\n                                                     data_type: BNNSDataType.float,\n                                                     table_data: nil,\n                                                     table_data_type: BNNSDataType.float,\n                                                     data_scale: 1, data_bias: 0)\n    \n    let outputElementCount = dictionaryItemRowCount * dictionaryItemColumnCount * indicesData.count\n    let outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: outputElementCount)\n    let outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                 layout: BNNSDataLayout3DLastMajor,\n                                                 size: (dictionaryItemRowCount,\n                                                        dictionaryItemColumnCount,\n                                                        indicesData.count, 0, 0, 0, 0, 0),\n                                                 stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                 data: outputData.baseAddress!,\n                                                 data_type: BNNSDataType.float,\n                                                 table_data: nil,\n                                                 table_data_type: BNNSDataType.float,\n                                                 data_scale: 1, data_bias: 0)\n    \n    var parameters = BNNSLayerParametersEmbedding(flags: BNNSEmbeddingFlags(rawValue: 0),\n                                                  i_desc: indicesDescriptor,\n                                                  o_desc: outputDescriptor,\n                                                  dictionary: dictionaryDescriptor,\n                                                  padding_idx: 0,\n                                                  max_norm: 0.6,\n                                                  norm_type: .infinity)\n    \n    let embeddingLayer = BNNSFilterCreateLayerEmbedding(&parameters, nil)\n    \n    BNNSFilterApply(embeddingLayer,\n                    indicesDescriptor.data!,\n                    outputDescriptor.data!)\n    \n    \/\/ Prints:\n    \/\/     [0.1, 0.3, 0.5,\n    \/\/      0.2, 0.4, 0.6,\n    \/\/\n    \/\/      0.6, 0.5, 0.4,\n    \/\/      0.3, 0.2, 0.1]\n    print(Array(outputData))\n    \n    indicesData.deallocate()\n    dictionaryData.deallocate()\n    outputData.deallocate()\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "043d1eddd3af389ca6361eb93f2de187f0a92528b3e23f29786c031b915707d1",
  "crawledAt" : "2025-12-02T01:21:32Z",
  "declaration" : {
    "code" : "func BNNSFilterCreateLayerEmbedding(_ layer_params: UnsafePointer<BNNSLayerParametersEmbedding>, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> BNNSFilter?",
    "language" : "swift"
  },
  "id" : "DD0F8809-E263-4019-BD27-EF5048C8ABDC",
  "kind" : "function",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nUse this function in conjunction with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersEmbedding] to create an embedding layer that accesses dictionary items based on the integer indices that the input tensor defines.\n\nFor example, the following code shows how to access three dictionary items at indices `1`, `5`, and `2`. The dictionary contains seven items that are five-element vectors. Therefore, the indices descriptor has the shape `(3)`, the dictionary descriptor has the shape `(5, 7)`, and the output descriptor has the shape `(5, 3)`.\n\nThe embedding layer supports clipping to a maximum norm. The following code accesses the second and third items from a dictionary that contains three 2 x 3 matrices. The code initializes the embedding layer with a maximum norm that is the infinity-norm of the first dictionary item.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFilterCreateLayerEmbedding(_:_:)\ncrawled: 2025-12-02T01:21:32Z\n---\n\n# BNNSFilterCreateLayerEmbedding(_:_:)\n\n**Function**\n\nReturns a new embedding layer.\n\n## Declaration\n\n```swift\nfunc BNNSFilterCreateLayerEmbedding(_ layer_params: UnsafePointer<BNNSLayerParametersEmbedding>, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> BNNSFilter?\n```\n\n## Parameters\n\n- **layer_params**: The layer parameters.\n- **filter_params**: The filter runtime parameters.\n\n## Discussion\n\nUse this function in conjunction with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersEmbedding] to create an embedding layer that accesses dictionary items based on the integer indices that the input tensor defines.\n\nFor example, the following code shows how to access three dictionary items at indices `1`, `5`, and `2`. The dictionary contains seven items that are five-element vectors. Therefore, the indices descriptor has the shape `(3)`, the dictionary descriptor has the shape `(5, 7)`, and the output descriptor has the shape `(5, 3)`.\n\n```swift\nstatic func embeddingLayer() {\n    \n    let indicesData = UnsafeMutableBufferPointer<Int8>.allocate(capacity: 3)\n    _ = indicesData.initialize(from: [1, 5, 2])\n    let indicesDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                  layout: BNNSDataLayoutVector,\n                                                  size: (3, 0, 0, 0, 0, 0, 0, 0),\n                                                  stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                  data: indicesData.baseAddress!,\n                                                  data_type: BNNSDataType.int8,\n                                                  table_data: nil,\n                                                  table_data_type: BNNSDataType.int8,\n                                                  data_scale: 1, data_bias: 0)\n    \n    let dictionaryItemSize = 5\n    let dictionaryItemCount = 7\n    let dictionaryData = UnsafeMutableBufferPointer<Float>.allocate(capacity: dictionaryItemSize * dictionaryItemCount)\n    _ = dictionaryData.initialize(from: [01, 02, 03, 04, 05,\n                                         11, 12, 13, 14, 15,\n                                         21, 22, 23, 24, 25,\n                                         31, 32, 33, 34, 35,\n                                         41, 42, 43, 44, 45,\n                                         51, 52, 53, 54, 55,\n                                         61, 62, 63, 64, 65])\n    let dictionaryDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                     layout: BNNSDataLayout2DLastMajor,\n                                                     size: (dictionaryItemSize, dictionaryItemCount,\n                                                            0, 0, 0, 0, 0, 0),\n                                                     stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                     data: dictionaryData.baseAddress!,\n                                                     data_type: BNNSDataType.float,\n                                                     table_data: nil,\n                                                     table_data_type: BNNSDataType.float,\n                                                     data_scale: 1, data_bias: 0)\n    \n    let outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: dictionaryItemSize * indicesData.count)\n    let outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                 layout: BNNSDataLayout2DLastMajor,\n                                                 size: (dictionaryItemSize, indicesData.count,\n                                                        0, 0, 0, 0, 0, 0),\n                                                 stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                 data: outputData.baseAddress!,\n                                                 data_type: BNNSDataType.float,\n                                                 table_data: nil,\n                                                 table_data_type: BNNSDataType.float,\n                                                 data_scale: 1, data_bias: 0)\n    \n    var parameters = BNNSLayerParametersEmbedding(flags: BNNSEmbeddingFlags(rawValue: 0),\n                                                  i_desc: indicesDescriptor,\n                                                  o_desc: outputDescriptor,\n                                                  dictionary: dictionaryDescriptor,\n                                                  padding_idx: 0,\n                                                  max_norm: 0,\n                                                  norm_type: 0)\n    \n    let embeddingLayer = BNNSFilterCreateLayerEmbedding(&parameters, nil)\n    \n    BNNSFilterApply(embeddingLayer,\n                    indicesDescriptor.data!,\n                    outputDescriptor.data!)\n    \n    \/\/ Prints:\n    \/\/ [11.0, 12.0, 13.0, 14.0, 15.0,\n    \/\/  51.0, 52.0, 53.0, 54.0, 55.0,\n    \/\/  21.0, 22.0, 23.0, 24.0, 25.0]\n    print(Array(outputData))\n    \n    indicesData.deallocate()\n    dictionaryData.deallocate()\n    outputData.deallocate()\n}\n```\n\nThe embedding layer supports clipping to a maximum norm. The following code accesses the second and third items from a dictionary that contains three 2 x 3 matrices. The code initializes the embedding layer with a maximum norm that is the infinity-norm of the first dictionary item.\n\n```swift\nstatic func embeddingLayerClipByNorm() {\n    let indicesData = UnsafeMutableBufferPointer<Int8>.allocate(capacity: 2)\n    _ = indicesData.initialize(from: [1, 2])\n    let indicesDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                  layout: BNNSDataLayoutVector,\n                                                  size: (2, 0, 0, 0, 0, 0, 0, 0),\n                                                  stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                  data: indicesData.baseAddress!,\n                                                  data_type: BNNSDataType.int8,\n                                                  table_data: nil,\n                                                  table_data_type: BNNSDataType.float,\n                                                  data_scale: 1, data_bias: 0)\n    \n    let dictionaryItemRowCount = 2\n    let dictionaryItemColumnCount = 3\n    let dictionaryItemCount = 3\n    let dictionaryElementCount = dictionaryItemRowCount * dictionaryItemColumnCount * dictionaryItemCount\n    let dictionaryData = UnsafeMutableBufferPointer<Float>.allocate(capacity: dictionaryElementCount)\n    _ = dictionaryData.initialize(from: [0.1, 0.2, 0.3,\n                                         0.4, 0.5, 0.6,\n                                       \n                                         1, 3, 5,\n                                         2, 4, 6,\n                                         \n                                         60, 50, 40,\n                                         30, 20, 10])\n    let dictionaryDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                     layout: BNNSDataLayout3DLastMajor,\n                                                     size: (dictionaryItemRowCount,\n                                                            dictionaryItemColumnCount,\n                                                            dictionaryItemCount, 0, 0, 0, 0, 0),\n                                                     stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                     data: dictionaryData.baseAddress!,\n                                                     data_type: BNNSDataType.float,\n                                                     table_data: nil,\n                                                     table_data_type: BNNSDataType.float,\n                                                     data_scale: 1, data_bias: 0)\n    \n    let outputElementCount = dictionaryItemRowCount * dictionaryItemColumnCount * indicesData.count\n    let outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: outputElementCount)\n    let outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                 layout: BNNSDataLayout3DLastMajor,\n                                                 size: (dictionaryItemRowCount,\n                                                        dictionaryItemColumnCount,\n                                                        indicesData.count, 0, 0, 0, 0, 0),\n                                                 stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                 data: outputData.baseAddress!,\n                                                 data_type: BNNSDataType.float,\n                                                 table_data: nil,\n                                                 table_data_type: BNNSDataType.float,\n                                                 data_scale: 1, data_bias: 0)\n    \n    var parameters = BNNSLayerParametersEmbedding(flags: BNNSEmbeddingFlags(rawValue: 0),\n                                                  i_desc: indicesDescriptor,\n                                                  o_desc: outputDescriptor,\n                                                  dictionary: dictionaryDescriptor,\n                                                  padding_idx: 0,\n                                                  max_norm: 0.6,\n                                                  norm_type: .infinity)\n    \n    let embeddingLayer = BNNSFilterCreateLayerEmbedding(&parameters, nil)\n    \n    BNNSFilterApply(embeddingLayer,\n                    indicesDescriptor.data!,\n                    outputDescriptor.data!)\n    \n    \/\/ Prints:\n    \/\/     [0.1, 0.3, 0.5,\n    \/\/      0.2, 0.4, 0.6,\n    \/\/\n    \/\/      0.6, 0.5, 0.4,\n    \/\/      0.3, 0.2, 0.1]\n    print(Array(outputData))\n    \n    indicesData.deallocate()\n    dictionaryData.deallocate()\n    outputData.deallocate()\n}\n```\n\n## Embedding layers\n\n- **BNNS.EmbeddingLayer**: A layer object that wraps an embedding filter and manages its deinitialization.\n- **BNNSLayerParametersEmbedding**: A structure that contains the parameters of an embedding layer.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A layer object that wraps an embedding filter and manages its deinitialization.",
          "name" : "BNNS.EmbeddingLayer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/EmbeddingLayer"
        },
        {
          "description" : "A structure that contains the parameters of an embedding layer.",
          "name" : "BNNSLayerParametersEmbedding",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSLayerParametersEmbedding"
        }
      ],
      "title" : "Embedding layers"
    }
  ],
  "source" : "appleJSON",
  "title" : "BNNSFilterCreateLayerEmbedding(_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFilterCreateLayerEmbedding(_:_:)"
}