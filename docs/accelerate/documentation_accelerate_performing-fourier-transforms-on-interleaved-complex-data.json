{
  "abstract" : "Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.",
  "codeExamples" : [
    {
      "code" : "let interleaved = [DSPComplex(real: real₀, imag: imag₀),\n                   DSPComplex(real: real₁, imag: imag₁),\n                   DSPComplex(real: real₂, imag: imag₂),\n                   DSPComplex(real: real₃, imag: imag₃)]",
      "language" : "swift"
    },
    {
      "code" : "let reals = [real₀, real₁, real₂, real₃]\nlet imaginaries = [imag₀, imag₁, imag₂, imag₃]",
      "language" : "swift"
    },
    {
      "code" : "let complexValuesCount = 32\n\nlet signal: [DSPComplex] = [ ... ] \/\/ `signal.count` equals `complexValuesCount`.\n\nvar splitSignalReal = [Float](repeating: 0,\n                              count: complexValuesCount)\nvar splitSignalImag = [Float](repeating: 0,\n                              count: complexValuesCount)\n\nsignal.withUnsafeBufferPointer { signalPtr in\n    splitSignalReal.withUnsafeMutableBufferPointer { signalRealPtr in\n        splitSignalImag.withUnsafeMutableBufferPointer { signalImagPtr in\n            var splitComplex = DSPSplitComplex(realp: signalRealPtr.baseAddress!,\n                                               imagp: signalImagPtr.baseAddress!)\n            \n            vDSP_ctoz(signalPtr.baseAddress!, 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var splitOutputReal = [Float](repeating: 0,\n                              count: complexValuesCount)\nvar splitOutputImag = [Float](repeating: 0,\n                              count: complexValuesCount)\n\nif let splitComplexSetup = vDSP_DFT_zop_CreateSetup(nil,\n                                                    vDSP_Length(complexValuesCount),\n                                                    .FORWARD) {\n    \n    vDSP_DFT_Execute(splitComplexSetup,\n                     splitSignalReal, splitSignalImag,\n                     &splitOutputReal, &splitOutputImag)\n    \n    vDSP_DFT_DestroySetup(splitComplexSetup)\n}\n\n\nlet splitComplexDominantFrequency = vDSP.indexOfMaximum(splitOutputReal)\n\nprint(\"Split-complex dominant frequency\",\n      splitComplexDominantFrequency.0,\n      splitComplexDominantFrequency.1)",
      "language" : "swift"
    },
    {
      "code" : "var dftOutputInterleaved = [DSPComplex](repeating: DSPComplex(),\n                                        count: complexValuesCount)\n\nsplitOutputReal.withUnsafeMutableBufferPointer { dftOutputRealPtr in\n    splitOutputImag.withUnsafeMutableBufferPointer { dftOutputImagPtr in\n        var splitComplex = DSPSplitComplex(realp: dftOutputRealPtr.baseAddress!,\n                                           imagp: dftOutputImagPtr.baseAddress!)\n        \n        vDSP_ztoc(&splitComplex, 1,\n                  &dftOutputInterleaved, 2,\n                  vDSP_Length(complexValuesCount))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var interleavedOutput = [DSPComplex](repeating: DSPComplex(real: 0, imag: 0),\n                                     count: complexValuesCount)\n\nif let interleavedSetup = vDSP_DFT_Interleaved_CreateSetup(nil,\n                                                           vDSP_Length(complexValuesCount),\n                                                           .FORWARD,\n                                                           .interleaved_ComplextoComplex) {\n    vDSP_DFT_Interleaved_Execute(interleavedSetup,\n                                 signal,\n                                 &interleavedOutput)\n    \n    vDSP_DFT_Interleaved_DestroySetup(interleavedSetup)\n}\n\nlet interleavedDominantFrequency = interleavedOutput.enumerated().max {\n    a, b in a.element.real < b.element.real\n}\n\nprint(\"Interleaved dominant frequency\",\n      interleavedDominantFrequency?.offset ?? -1,\n      interleavedDominantFrequency?.element.real ?? 0)",
      "language" : "swift"
    }
  ],
  "contentHash" : "71c37ec2dbcb6eac2db60a84cd3469623edb596c16f0ea24375b308580de2843",
  "crawledAt" : "2025-12-02T15:37:19Z",
  "id" : "90241D9B-68AD-403F-B6B2-1AEBF4FA3FF6",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nIn many cases, your code performs Fourier transforms on data that originates as interleaved-complex values. An interleaved-complex representation stores the real and imaginary parts of complex values together as collections of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPComplex] or [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPDoubleComplex] structures. Many Fourier-related routines in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP] accept complex values in a split-complex representation that stores real and imaginary parts as separate collections.\n\nFor example, the following shows a collection of four complex values in a single interleaved collection:\n\nThe following shows the same four complex values as two collections in a split representation:\n\nvDSP routines accept split-complex values either as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structures or as two separate collections.\n\n### Convert interleaved values to split-complex format\n\nGiven an array `signal` that contains 32 interleaved-complex values, the following code performs a Fourier transform on the values. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to populate the split collections `splitSignalReal` and `splitSignalImag` with the interleaved values from `signal`:\n\n### Perform a Fourier transform on split data\n\nUse the vDSP function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_zop_CreateSetup] to create a setup object for complex-to-complex DFTs. The execute function, [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_Execute], automatically switches to a fast Fourier transform (FFT) when the specified count supports the FFT algorithm.\n\nOn return,`splitOutputReal` and `splitOutputImag` contain the split format frequency-domain representation of the values in `signal`. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/indexOfMaximum(_:)-5qdtm] to find the dominant frequency.\n\n### Convert split-complex values to interleaved format\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ztoc] to convert the split result to the interleaved format.\n\nOn return, `dftOutputInterleaved` contains the DFT result in the interleaved format.\n\n### Perform a Fourier transform directly on interleaved data\n\nvDSP provides routines for DFTs directly on interleaved data. Use these functions instead of using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ztoc] to convert between interleaved and split formats.\n\nThe following code performs the transform from the [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data#Perform-a-Fourier-transform-on-split-data] section directly on the interleaved data:\n\nOn return, `interleavedOutput` contains the FFT result in the interleaved format.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data\ncrawled: 2025-12-02T15:37:19Z\n---\n\n# Performing Fourier transforms on interleaved-complex data\n\n**Article**\n\nOptimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.\n\n## Overview\n\nIn many cases, your code performs Fourier transforms on data that originates as interleaved-complex values. An interleaved-complex representation stores the real and imaginary parts of complex values together as collections of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPComplex] or [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPDoubleComplex] structures. Many Fourier-related routines in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP] accept complex values in a split-complex representation that stores real and imaginary parts as separate collections.\n\nFor example, the following shows a collection of four complex values in a single interleaved collection:\n\n```swift\nlet interleaved = [DSPComplex(real: real₀, imag: imag₀),\n                   DSPComplex(real: real₁, imag: imag₁),\n                   DSPComplex(real: real₂, imag: imag₂),\n                   DSPComplex(real: real₃, imag: imag₃)]\n```\n\nThe following shows the same four complex values as two collections in a split representation:\n\n```swift\nlet reals = [real₀, real₁, real₂, real₃]\nlet imaginaries = [imag₀, imag₁, imag₂, imag₃]\n```\n\nvDSP routines accept split-complex values either as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structures or as two separate collections.\n\n### Convert interleaved values to split-complex format\n\nGiven an array `signal` that contains 32 interleaved-complex values, the following code performs a Fourier transform on the values. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to populate the split collections `splitSignalReal` and `splitSignalImag` with the interleaved values from `signal`:\n\n```swift\nlet complexValuesCount = 32\n\nlet signal: [DSPComplex] = [ ... ] \/\/ `signal.count` equals `complexValuesCount`.\n\nvar splitSignalReal = [Float](repeating: 0,\n                              count: complexValuesCount)\nvar splitSignalImag = [Float](repeating: 0,\n                              count: complexValuesCount)\n\nsignal.withUnsafeBufferPointer { signalPtr in\n    splitSignalReal.withUnsafeMutableBufferPointer { signalRealPtr in\n        splitSignalImag.withUnsafeMutableBufferPointer { signalImagPtr in\n            var splitComplex = DSPSplitComplex(realp: signalRealPtr.baseAddress!,\n                                               imagp: signalImagPtr.baseAddress!)\n            \n            vDSP_ctoz(signalPtr.baseAddress!, 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n        }\n    }\n}\n```\n\n### Perform a Fourier transform on split data\n\nUse the vDSP function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_zop_CreateSetup] to create a setup object for complex-to-complex DFTs. The execute function, [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_Execute], automatically switches to a fast Fourier transform (FFT) when the specified count supports the FFT algorithm.\n\n```swift\nvar splitOutputReal = [Float](repeating: 0,\n                              count: complexValuesCount)\nvar splitOutputImag = [Float](repeating: 0,\n                              count: complexValuesCount)\n\nif let splitComplexSetup = vDSP_DFT_zop_CreateSetup(nil,\n                                                    vDSP_Length(complexValuesCount),\n                                                    .FORWARD) {\n    \n    vDSP_DFT_Execute(splitComplexSetup,\n                     splitSignalReal, splitSignalImag,\n                     &splitOutputReal, &splitOutputImag)\n    \n    vDSP_DFT_DestroySetup(splitComplexSetup)\n}\n\n\nlet splitComplexDominantFrequency = vDSP.indexOfMaximum(splitOutputReal)\n\nprint(\"Split-complex dominant frequency\",\n      splitComplexDominantFrequency.0,\n      splitComplexDominantFrequency.1)\n```\n\nOn return,`splitOutputReal` and `splitOutputImag` contain the split format frequency-domain representation of the values in `signal`. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/indexOfMaximum(_:)-5qdtm] to find the dominant frequency.\n\n### Convert split-complex values to interleaved format\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ztoc] to convert the split result to the interleaved format.\n\n```swift\nvar dftOutputInterleaved = [DSPComplex](repeating: DSPComplex(),\n                                        count: complexValuesCount)\n\nsplitOutputReal.withUnsafeMutableBufferPointer { dftOutputRealPtr in\n    splitOutputImag.withUnsafeMutableBufferPointer { dftOutputImagPtr in\n        var splitComplex = DSPSplitComplex(realp: dftOutputRealPtr.baseAddress!,\n                                           imagp: dftOutputImagPtr.baseAddress!)\n        \n        vDSP_ztoc(&splitComplex, 1,\n                  &dftOutputInterleaved, 2,\n                  vDSP_Length(complexValuesCount))\n    }\n}\n```\n\nOn return, `dftOutputInterleaved` contains the DFT result in the interleaved format.\n\n### Perform a Fourier transform directly on interleaved data\n\nvDSP provides routines for DFTs directly on interleaved data. Use these functions instead of using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ztoc] to convert between interleaved and split formats.\n\nThe following code performs the transform from the [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data#Perform-a-Fourier-transform-on-split-data] section directly on the interleaved data:\n\n```swift\nvar interleavedOutput = [DSPComplex](repeating: DSPComplex(real: 0, imag: 0),\n                                     count: complexValuesCount)\n\nif let interleavedSetup = vDSP_DFT_Interleaved_CreateSetup(nil,\n                                                           vDSP_Length(complexValuesCount),\n                                                           .FORWARD,\n                                                           .interleaved_ComplextoComplex) {\n    vDSP_DFT_Interleaved_Execute(interleavedSetup,\n                                 signal,\n                                 &interleavedOutput)\n    \n    vDSP_DFT_Interleaved_DestroySetup(interleavedSetup)\n}\n\nlet interleavedDominantFrequency = interleavedOutput.enumerated().max {\n    a, b in a.element.real < b.element.real\n}\n\nprint(\"Interleaved dominant frequency\",\n      interleavedDominantFrequency?.offset ?? -1,\n      interleavedDominantFrequency?.element.real ?? 0)\n```\n\nOn return, `interleavedOutput` contains the FFT result in the interleaved format.\n\n## Fourier and Cosine Transforms\n\n- **Understanding data packing for Fourier transforms**: Format source data for the vDSP Fourier functions, and interpret the results.\n- **Finding the component frequencies in a composite sine wave**: Use 1D fast Fourier transform to compute the frequency components of a signal.\n- **Reducing spectral leakage with windowing**: Multiply signal data by window sequence values when performing transforms with noninteger period signals.\n- **Signal extraction from noise**: Use Accelerate’s discrete cosine transform to remove noise from a signal.\n- **Performing Fourier Transforms on Multiple Signals**: Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.\n- **Halftone descreening with 2D fast Fourier transform**: Reduce or remove periodic artifacts from images.\n- **Fast Fourier transforms**: Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Fourier transforms**: Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Format source data for the vDSP Fourier functions, and interpret the results.",
          "name" : "Understanding data packing for Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms"
        },
        {
          "description" : "Use 1D fast Fourier transform to compute the frequency components of a signal.",
          "name" : "Finding the component frequencies in a composite sine wave",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave"
        },
        {
          "description" : "Multiply signal data by window sequence values when performing transforms with noninteger period signals.",
          "name" : "Reducing spectral leakage with windowing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing"
        },
        {
          "description" : "Use Accelerate’s discrete cosine transform to remove noise from a signal.",
          "name" : "Signal extraction from noise",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise"
        },
        {
          "description" : "Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.",
          "name" : "Performing Fourier Transforms on Multiple Signals",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals"
        },
        {
          "description" : "Reduce or remove periodic artifacts from images.",
          "name" : "Halftone descreening with 2D fast Fourier transform",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform"
        },
        {
          "description" : "Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Fast Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/fast-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Discrete Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Fourier and Cosine Transforms"
    }
  ],
  "source" : "appleJSON",
  "title" : "Performing Fourier transforms on interleaved-complex data",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data"
}