{
  "abstract" : "Compress a string, write it to the file system, and decompress the same file using buffer compression.",
  "codeExamples" : [
    {
      "code" : "import Compression\n\nlet sourceString = \"\"\"\n    Lorem ipsum dolor sit amet consectetur adipiscing elit mi\n    nibh ornare proin blandit diam ridiculus, faucibus mus\n    dui eu vehicula nam donec dictumst sed vivamus bibendum\n    aliquet efficitur. Felis imperdiet sodales dictum morbi\n    vivamus augue dis duis aliquet velit ullamcorper porttitor,\n    lobortis dapibus hac purus aliquam natoque iaculis blandit\n    montes nunc pretium.\n    \"\"\"\n\nvar sourceBuffer = Array(sourceString.utf8)",
      "language" : "swift"
    },
    {
      "code" : "let destinationBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: sourceString.count)\n\ndefer {\n    destinationBuffer.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "let algorithm = COMPRESSION_LZFSE",
      "language" : "swift"
    },
    {
      "code" : "let compressedSize = compression_encode_buffer(destinationBuffer, sourceString.count,\n                                               &sourceBuffer, sourceString.count,\n                                               nil,\n                                               algorithm)",
      "language" : "swift"
    },
    {
      "code" : "if compressedSize == 0 {\n    fatalError(\"Encoding failed.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "let encodedFileName = \"stringEncoded.LZFSE\"\n\nlet tempDirURL = NSURL(fileURLWithPath: NSTemporaryDirectory())\n\nguard\n    let encodedFileURL = tempDirURL.appendingPathComponent(encodedFileName) else {\n        return\n}\n\nFileManager.default.createFile(atPath: encodedFileURL.path,\n                               contents: nil,\n                               attributes: nil)\n\nguard let destinationFileHandle = try? FileHandle(forWritingTo: encodedFileURL) else {\n    print(\"destinationFileHandle fail.\")\n    return\n}\n\nlet encodedData = NSData(bytesNoCopy: destinationBuffer,\n                         length: compressedSize,\n                         freeWhenDone: false)\n\ndestinationFileHandle.write(encodedData as Data)\ndestinationFileHandle.closeFile()",
      "language" : "swift"
    },
    {
      "code" : "guard\n    let encodedFileHandle = try? FileHandle(forReadingFrom: encodedFileURL) else {\n        print(\"encodedFileHandle fail.\")\n        return\n}",
      "language" : "swift"
    },
    {
      "code" : "let encodedSourceData = encodedFileHandle.readDataToEndOfFile()",
      "language" : "swift"
    },
    {
      "code" : "let decodedCapacity = 8_000_000\nlet decodedDestinationBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: decodedCapacity)\ndefer {\n    decodedDestinationBuffer.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "let decodedString: String = encodedSourceData.withUnsafeBytes { encodedSourceBuffer in\n    let typedPointer = encodedSourceBuffer.bindMemory(to: UInt8.self)\n    let decodedCharCount = compression_decode_buffer(decodedDestinationBuffer, decodedCapacity,\n                                                     typedPointer.baseAddress!, encodedSourceData.count,\n                                                     nil,\n                                                     algorithm)\n\n    return String(cString: decodedDestinationBuffer)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "99476047d69e77f9b24372dbc229cbff7a282680e3468875cb29340977352c1b",
  "crawledAt" : "2025-12-02T15:37:03Z",
  "id" : "8B4B607D-826D-4732-B5B1-E0DA3252537D",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThe code in this article uses the [doc:\/\/com.apple.documentation\/documentation\/Compression] framework to encode (compress) and decode (decompress) a string. The code writes the encoded result to the temporary directory that the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSTemporaryDirectory()] function returns.\n\nThe code in this sample is useful in applications that store or transmit text files where saving or sending smaller files can improve performance and reduce storage overhead. This sample app implements *buffer compression*, where it reads the contents of a source buffer in a single step to compress or decompress data.\n\n### Create the source data\n\nTypically, your app would dynamically generate the source data that it compresses, but for this example, the source data is a hard-coded string.\n\nOn return, `sourceBuffer` is an array of [doc:\/\/com.apple.documentation\/documentation\/kernel\/uint8] values that contains the UTF-8 representation of the source string.\n\n### Create the destination buffer\n\nCreate an [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafeMutablePointer] structure and allocate it with a capacity of the source string’s `count` to receive the encoded data.\n\n### Select a compression algorithm\n\nThe code in this example uses the [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_LZFSE] algorithm, which provides the compression ratio of zlib level 5, but with much higher energy efficiency and speed (between 2x and 3x) for both encode and decode operations.\n\nFor apps that require interoperability with non-Apple devices, use [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_ZLIB] instead. For more information on other compression algorithms, see [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_algorithm].\n\n### Compress the data\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_encode_buffer(_:_:_:_:_:_:)] function compresses the data, writes the result to the destination buffer, and returns the size of the encoded data.\n\nWhen working with small files, the compression may fail and [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_encode_buffer(_:_:_:_:_:_:)] returns `0`.\n\nYou may elect to handle this situation differently, for example, by displaying a warning to the user that the compression failed.\n\n### Write the encoded data to a file\n\nThe code below writes the encoded data to a file in the the app’s temporary directory on macOS:\n\n### Read the encoded data from a file\n\nTo read the encoded file, create a file handle for reading from the encoded file’s URL.\n\nUse the file handle to read the entire encoded file and populate `encodedSourceData`.\n\n### Decompress the data\n\nAllocate memory to contain the decoded data. Typically, the encoded payload would be part of a larger structure containing additional metadata such as the uncompressed size, and you’d use that to define the buffer capacity. However, for this example, allocate 8 MB:\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_decode_buffer(_:_:_:_:_:_:)] to decode the raw bytes of the encoded source data and write the result to `decodedDestinationBuffer`. You can create a string from the destination buffer using the [doc:\/\/com.apple.documentation\/documentation\/Swift\/String\/init(cString:)-2p84k] initializer.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_decode_buffer(_:_:_:_:_:_:)] function returns the size of the decoded data. If the decompression fails, the size returned is zero. This may indicate that the memory allocated to the destination buffer is insufficient and you should switch to the stream API or retry with a larger buffer.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-buffer-compression\ncrawled: 2025-12-02T15:37:03Z\n---\n\n# Compressing and decompressing data with buffer compression\n\n**Article**\n\nCompress a string, write it to the file system, and decompress the same file using buffer compression.\n\n## Overview\n\nThe code in this article uses the [doc:\/\/com.apple.documentation\/documentation\/Compression] framework to encode (compress) and decode (decompress) a string. The code writes the encoded result to the temporary directory that the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSTemporaryDirectory()] function returns.\n\nThe code in this sample is useful in applications that store or transmit text files where saving or sending smaller files can improve performance and reduce storage overhead. This sample app implements *buffer compression*, where it reads the contents of a source buffer in a single step to compress or decompress data.\n\n### Create the source data\n\nTypically, your app would dynamically generate the source data that it compresses, but for this example, the source data is a hard-coded string.\n\n```swift\nimport Compression\n\nlet sourceString = \"\"\"\n    Lorem ipsum dolor sit amet consectetur adipiscing elit mi\n    nibh ornare proin blandit diam ridiculus, faucibus mus\n    dui eu vehicula nam donec dictumst sed vivamus bibendum\n    aliquet efficitur. Felis imperdiet sodales dictum morbi\n    vivamus augue dis duis aliquet velit ullamcorper porttitor,\n    lobortis dapibus hac purus aliquam natoque iaculis blandit\n    montes nunc pretium.\n    \"\"\"\n\nvar sourceBuffer = Array(sourceString.utf8)\n```\n\nOn return, `sourceBuffer` is an array of [doc:\/\/com.apple.documentation\/documentation\/kernel\/uint8] values that contains the UTF-8 representation of the source string.\n\n### Create the destination buffer\n\nCreate an [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafeMutablePointer] structure and allocate it with a capacity of the source string’s `count` to receive the encoded data.\n\n```swift\nlet destinationBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: sourceString.count)\n\ndefer {\n    destinationBuffer.deallocate()\n}\n```\n\n### Select a compression algorithm\n\nThe code in this example uses the [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_LZFSE] algorithm, which provides the compression ratio of zlib level 5, but with much higher energy efficiency and speed (between 2x and 3x) for both encode and decode operations.\n\n```swift\nlet algorithm = COMPRESSION_LZFSE\n```\n\nFor apps that require interoperability with non-Apple devices, use [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_ZLIB] instead. For more information on other compression algorithms, see [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_algorithm].\n\n### Compress the data\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_encode_buffer(_:_:_:_:_:_:)] function compresses the data, writes the result to the destination buffer, and returns the size of the encoded data.\n\n```swift\nlet compressedSize = compression_encode_buffer(destinationBuffer, sourceString.count,\n                                               &sourceBuffer, sourceString.count,\n                                               nil,\n                                               algorithm)\n```\n\nWhen working with small files, the compression may fail and [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_encode_buffer(_:_:_:_:_:_:)] returns `0`.\n\n```swift\nif compressedSize == 0 {\n    fatalError(\"Encoding failed.\")\n}\n```\n\nYou may elect to handle this situation differently, for example, by displaying a warning to the user that the compression failed.\n\n### Write the encoded data to a file\n\nThe code below writes the encoded data to a file in the the app’s temporary directory on macOS:\n\n```swift\nlet encodedFileName = \"stringEncoded.LZFSE\"\n\nlet tempDirURL = NSURL(fileURLWithPath: NSTemporaryDirectory())\n\nguard\n    let encodedFileURL = tempDirURL.appendingPathComponent(encodedFileName) else {\n        return\n}\n\nFileManager.default.createFile(atPath: encodedFileURL.path,\n                               contents: nil,\n                               attributes: nil)\n\nguard let destinationFileHandle = try? FileHandle(forWritingTo: encodedFileURL) else {\n    print(\"destinationFileHandle fail.\")\n    return\n}\n\nlet encodedData = NSData(bytesNoCopy: destinationBuffer,\n                         length: compressedSize,\n                         freeWhenDone: false)\n\ndestinationFileHandle.write(encodedData as Data)\ndestinationFileHandle.closeFile()\n```\n\n### Read the encoded data from a file\n\nTo read the encoded file, create a file handle for reading from the encoded file’s URL.\n\n```swift\nguard\n    let encodedFileHandle = try? FileHandle(forReadingFrom: encodedFileURL) else {\n        print(\"encodedFileHandle fail.\")\n        return\n}\n```\n\nUse the file handle to read the entire encoded file and populate `encodedSourceData`.\n\n```swift\nlet encodedSourceData = encodedFileHandle.readDataToEndOfFile()\n```\n\n### Decompress the data\n\nAllocate memory to contain the decoded data. Typically, the encoded payload would be part of a larger structure containing additional metadata such as the uncompressed size, and you’d use that to define the buffer capacity. However, for this example, allocate 8 MB:\n\n```swift\nlet decodedCapacity = 8_000_000\nlet decodedDestinationBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: decodedCapacity)\ndefer {\n    decodedDestinationBuffer.deallocate()\n}\n```\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_decode_buffer(_:_:_:_:_:_:)] to decode the raw bytes of the encoded source data and write the result to `decodedDestinationBuffer`. You can create a string from the destination buffer using the [doc:\/\/com.apple.documentation\/documentation\/Swift\/String\/init(cString:)-2p84k] initializer.\n\n```swift\nlet decodedString: String = encodedSourceData.withUnsafeBytes { encodedSourceBuffer in\n    let typedPointer = encodedSourceBuffer.bindMemory(to: UInt8.self)\n    let decodedCharCount = compression_decode_buffer(decodedDestinationBuffer, decodedCapacity,\n                                                     typedPointer.baseAddress!, encodedSourceData.count,\n                                                     nil,\n                                                     algorithm)\n\n    return String(cString: decodedDestinationBuffer)\n}\n```\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_decode_buffer(_:_:_:_:_:_:)] function returns the size of the decoded data. If the decompression fails, the size returned is zero. This may indicate that the memory allocated to the destination buffer is insufficient and you should switch to the stream API or retry with a larger buffer.\n\n## Compression\n\n- **Compressing and decompressing files with stream compression**: Perform compression for all files and decompression for files with supported extension types.\n- **Compressing and decompressing data with input and output filters**: Compress and decompress streamed or from-memory data, using input and output filters.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Perform compression for all files and decompression for files with supported extension types.",
          "name" : "Compressing and decompressing files with stream compression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-files-with-stream-compression"
        },
        {
          "description" : "Compress and decompress streamed or from-memory data, using input and output filters.",
          "name" : "Compressing and decompressing data with input and output filters",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-input-and-output-filters"
        }
      ],
      "title" : "Compression"
    }
  ],
  "source" : "appleJSON",
  "title" : "Compressing and decompressing data with buffer compression",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-buffer-compression"
}