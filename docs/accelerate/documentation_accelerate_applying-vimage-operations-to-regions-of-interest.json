{
  "abstract" : "Limit the effect of vImage operations to rectangular regions of interest.",
  "codeExamples" : [
    {
      "code" : "\/\/ `source` is a `vImage.PixelBuffer<vImage.Interleaved8x4>` that contains an ARGB8888 image.\n\/\/ `destination` is an initialized `vImage.PixelBuffer<vImage.Interleaved8x4>` that's the same \n\/\/ size as `source`.\n\nlet landscapeROI = CGRect( ... )\n\nsource.withUnsafeRegionOfInterest(landscapeROI) { src in\n    src.multiply(by: desaturationMatrix,\n                 divisor: divisor,\n                 preBias: (0, 0, 0, 0),\n                 postBias: (0, 0, 0, 0),\n                 destination: src)\n}\n\nsource.copy(to: destination)\n\nlet portraitROI = CGRect( ... )\n\nsource.withUnsafeRegionOfInterest(portraitROI) { src in\n    destination.withUnsafeRegionOfInterest(portraitROI) { dst in\n        src.tentConvolve(kernelSize: .init(width: 100, height: 100),\n                         edgeMode: .truncateKernel,\n                         destination: dst)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ `source` is a `vImage_Buffer` that contains an ARGB8888 image.\n\nsource.desaturate_ARGB8888(regionOfInterest: CGRect( ... ))\n\nlet destination = source.blurred_ARGB8888(regionOfInterest: CGRect( ... ),\n                                          blurRadius: 100)\n",
      "language" : "swift"
    },
    {
      "code" : "extension vImage_Buffer {\n\n    mutating func desaturate_ARGB8888(regionOfInterest roi: CGRect) {",
      "language" : "swift"
    },
    {
      "code" : "        guard Int(roi.maxX) <= width && Int(roi.maxY) <= height &&\n            Int(roi.minX) >= 0 && Int(roi.minY) >= 0 else {\n                print(\"ROI is out of bounds.\")\n                return\n        }",
      "language" : "swift"
    },
    {
      "code" : "        let bytesPerPixel = 4\n        \n        let start = Int(roi.origin.y) * rowBytes +\n                    Int(roi.origin.x) * bytesPerPixel",
      "language" : "swift"
    },
    {
      "code" : "        var desaturationBuffer = vImage_Buffer(data: data.advanced(by: start),\n                                               height: vImagePixelCount(roi.height),\n                                               width: vImagePixelCount(roi.width),\n                                               rowBytes: rowBytes)",
      "language" : "swift"
    },
    {
      "code" : "        let divisor: Int32 = 0x1000\n        \n        let desaturationMatrix = [\n            0.0722, 0.0722, 0.0722, 0,\n            0.7152, 0.7152, 0.7152, 0,\n            0.2126, 0.2126, 0.2126, 0,\n            0,      0,      0,      1\n            ].map {\n                return Int16($0 * Float(divisor))\n        }\n        \n        let error = vImageMatrixMultiply_ARGB8888(&desaturationBuffer,\n                                                  &desaturationBuffer,\n                                                  desaturationMatrix,\n                                                  divisor,\n                                                  nil, nil,\n                                                  vImage_Flags(kvImageNoFlags))\n        \n        if error != kvImageNoError {\n            print(\"Error: \\(error)\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension vImage_Buffer {\n    \n    func blurred_ARGB8888(regionOfInterest roi: CGRect,\n                          blurRadius: Int) -> vImage_Buffer? {",
      "language" : "swift"
    },
    {
      "code" : "        guard Int(roi.maxX) <= width && Int(roi.maxY) <= height &&\n            Int(roi.minX) >= 0 && Int(roi.minY) >= 0 else {\n                print(\"ROI is out of bounds.\")\n                return nil\n        }",
      "language" : "swift"
    },
    {
      "code" : "        guard var destination = try? vImage_Buffer(width: Int(width),\n                                                   height: Int(height),\n                                                   bitsPerPixel: 32) else {\n                                                    return nil\n        }\n        \n        let bytesPerPixel = 4\n        \n        withUnsafePointer(to: self) { src in\n            vImageCopyBuffer(src,\n                             &destination,\n                             bytesPerPixel,\n                             vImage_Flags(kvImageNoFlags))\n        }",
      "language" : "swift"
    },
    {
      "code" : "        let start = Int(roi.origin.y) * destination.rowBytes +\n            Int(roi.origin.x) * bytesPerPixel\n        \n        var blurDestination = vImage_Buffer(data: destination.data.advanced(by: start),\n                                            height: vImagePixelCount(roi.height),\n                                            width: vImagePixelCount(roi.width),\n                                            rowBytes: destination.rowBytes)",
      "language" : "swift"
    },
    {
      "code" : "        var error = kvImageNoError\n        \n        withUnsafePointer(to: self) { src in\n            let blurDiameter = UInt32(blurRadius * 2 + 1)\n            error = vImageTentConvolve_ARGB8888(src,\n                                                &blurDestination,\n                                                nil,\n                                                vImagePixelCount(roi.origin.x),\n                                                vImagePixelCount(roi.origin.y),\n                                                blurDiameter, blurDiameter,\n                                                [0],\n                                                vImage_Flags(kvImageTruncateKernel))\n        }\n        \n        if error != kvImageNoError {\n            destination.free()\n            print(\"Error: \\(error)\")\n            return nil\n        }\n        \n        return destination\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "930386c759e59c4bf8fc1825ae420ee6726f8bc5faa532416bc5dd67275f5c97",
  "crawledAt" : "2025-12-02T15:55:16Z",
  "id" : "2C6EC2C8-BF65-49DF-9945-A8FBBE346FAB",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nYou can apply vImage operations, such as blurs and color transforms, to specified rectangular areas in an image, commonly referred to as *regions of interest* (ROI). Limiting the effect of an operation is useful when, for example, you want to overlay user interface elements on top of a blurred part of an image to make them stand out.\n\nThe following image is an example of the effects possible when you use the techniques in this article. The image shows a single photograph with a portrait-format ROI that the code has desaturated and a landscape-format ROI that the code has blurred.\n\n\n\n### Applying operations to an ROI of a pixel buffer\n\nIf you’re developing apps with Xcode 14.0 or later, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] structure provides the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/withUnsafeRegionOfInterest(_:_:)] function, which simplifies applying operations to ROIs. The following code creates the image above:\n\nOn return, the destination [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] contains the final image.\n\nThis article implements the remaining code in this article as extensions to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure. The two function calls below created the image above:\n\n### Apply an in-place operation to an ROI\n\nFor vImage routines that can operate in-place (that is, the operation mutates the source buffer’s contents), create a mutating function that applies that routine to an ROI. The following code is the function header for a desaturation function based around [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMatrixMultiply_ARGB8888(_:_:_:_:_:_:_:)]:\n\nThe function checks that the supplied ROI is within the bounds of the buffer.\n\nThe following code calculates the first pixel in the source buffer for the ROI:\n\nThe `start` value defines the offset to the data pointer for a second [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure that references the source buffer’s data with a size that equals the ROI.\n\nOn return, `desaturationBuffer` contains a reference to the data in the source buffer that the supplied ROI defines. Calling [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMatrixMultiply_ARGB8888(_:_:_:_:_:_:_:)] with `desaturationBuffer` as both the source and the destination performs the matrix multiplication on the pixels in the ROI:\n\nTo learn more about using matrix multiplication to convert color images to grayscale, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/converting-color-images-to-grayscale].\n\nThe following shows the result of desaturating an ROI:\n\n\n\n### Apply an out-of-place operation to an ROI\n\nFor vImage routines that don’t operate in-place, create a non-mutating function that applies that routine to an ROI and returns a new [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure that contains the result.\n\nThe following code is the function header for a blurring function that applies [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageTentConvolve_ARGB8888(_:_:_:_:_:_:_:_:_:)]:\n\nThe function performs the same check as [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest#Apply-an-in-place-operation-to-an-ROI] on the ROI size:\n\n`vImage_Buffer.blurred_ARGB8888(regionOfInterest:blurRadius:)` returns a buffer that’s the same size as the source. The function copies all source pixels that are outside of the ROI to the destination. The following code creates the buffer that the function returns, and copies the source pixels into the new buffer:\n\nThe out-of-place function uses the same approach as [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest#Apply-an-in-place-operation-to-an-ROI], calculate the start of the ROI. The destination buffer for the blur operation references the copied pixels in `destination`:\n\nFinally, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageTentConvolve_ARGB8888(_:_:_:_:_:_:_:_:_:)] function applies the blur to the source and writes the result to `blurDestination`.\n\nThe following shows the result of blurring an ROI:\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest\ncrawled: 2025-12-02T15:55:16Z\n---\n\n# Applying vImage operations to regions of interest\n\n**Article**\n\nLimit the effect of vImage operations to rectangular regions of interest.\n\n## Overview\n\nYou can apply vImage operations, such as blurs and color transforms, to specified rectangular areas in an image, commonly referred to as *regions of interest* (ROI). Limiting the effect of an operation is useful when, for example, you want to overlay user interface elements on top of a blurred part of an image to make them stand out.\n\nThe following image is an example of the effects possible when you use the techniques in this article. The image shows a single photograph with a portrait-format ROI that the code has desaturated and a landscape-format ROI that the code has blurred.\n\n\n\n### Applying operations to an ROI of a pixel buffer\n\nIf you’re developing apps with Xcode 14.0 or later, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] structure provides the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/withUnsafeRegionOfInterest(_:_:)] function, which simplifies applying operations to ROIs. The following code creates the image above:\n\n```swift\n\/\/ `source` is a `vImage.PixelBuffer<vImage.Interleaved8x4>` that contains an ARGB8888 image.\n\/\/ `destination` is an initialized `vImage.PixelBuffer<vImage.Interleaved8x4>` that's the same \n\/\/ size as `source`.\n\nlet landscapeROI = CGRect( ... )\n\nsource.withUnsafeRegionOfInterest(landscapeROI) { src in\n    src.multiply(by: desaturationMatrix,\n                 divisor: divisor,\n                 preBias: (0, 0, 0, 0),\n                 postBias: (0, 0, 0, 0),\n                 destination: src)\n}\n\nsource.copy(to: destination)\n\nlet portraitROI = CGRect( ... )\n\nsource.withUnsafeRegionOfInterest(portraitROI) { src in\n    destination.withUnsafeRegionOfInterest(portraitROI) { dst in\n        src.tentConvolve(kernelSize: .init(width: 100, height: 100),\n                         edgeMode: .truncateKernel,\n                         destination: dst)\n    }\n}\n```\n\nOn return, the destination [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] contains the final image.\n\nThis article implements the remaining code in this article as extensions to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure. The two function calls below created the image above:\n\n```swift\n\/\/ `source` is a `vImage_Buffer` that contains an ARGB8888 image.\n\nsource.desaturate_ARGB8888(regionOfInterest: CGRect( ... ))\n\nlet destination = source.blurred_ARGB8888(regionOfInterest: CGRect( ... ),\n                                          blurRadius: 100)\n\n```\n\n### Apply an in-place operation to an ROI\n\nFor vImage routines that can operate in-place (that is, the operation mutates the source buffer’s contents), create a mutating function that applies that routine to an ROI. The following code is the function header for a desaturation function based around [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMatrixMultiply_ARGB8888(_:_:_:_:_:_:_:)]:\n\n```swift\nextension vImage_Buffer {\n\n    mutating func desaturate_ARGB8888(regionOfInterest roi: CGRect) {\n```\n\nThe function checks that the supplied ROI is within the bounds of the buffer.\n\n```swift\n        guard Int(roi.maxX) <= width && Int(roi.maxY) <= height &&\n            Int(roi.minX) >= 0 && Int(roi.minY) >= 0 else {\n                print(\"ROI is out of bounds.\")\n                return\n        }\n```\n\nThe following code calculates the first pixel in the source buffer for the ROI:\n\n```swift\n        let bytesPerPixel = 4\n        \n        let start = Int(roi.origin.y) * rowBytes +\n                    Int(roi.origin.x) * bytesPerPixel\n```\n\nThe `start` value defines the offset to the data pointer for a second [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure that references the source buffer’s data with a size that equals the ROI.\n\n```swift\n        var desaturationBuffer = vImage_Buffer(data: data.advanced(by: start),\n                                               height: vImagePixelCount(roi.height),\n                                               width: vImagePixelCount(roi.width),\n                                               rowBytes: rowBytes)\n```\n\nOn return, `desaturationBuffer` contains a reference to the data in the source buffer that the supplied ROI defines. Calling [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMatrixMultiply_ARGB8888(_:_:_:_:_:_:_:)] with `desaturationBuffer` as both the source and the destination performs the matrix multiplication on the pixels in the ROI:\n\n```swift\n        let divisor: Int32 = 0x1000\n        \n        let desaturationMatrix = [\n            0.0722, 0.0722, 0.0722, 0,\n            0.7152, 0.7152, 0.7152, 0,\n            0.2126, 0.2126, 0.2126, 0,\n            0,      0,      0,      1\n            ].map {\n                return Int16($0 * Float(divisor))\n        }\n        \n        let error = vImageMatrixMultiply_ARGB8888(&desaturationBuffer,\n                                                  &desaturationBuffer,\n                                                  desaturationMatrix,\n                                                  divisor,\n                                                  nil, nil,\n                                                  vImage_Flags(kvImageNoFlags))\n        \n        if error != kvImageNoError {\n            print(\"Error: \\(error)\")\n        }\n    }\n}\n```\n\nTo learn more about using matrix multiplication to convert color images to grayscale, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/converting-color-images-to-grayscale].\n\nThe following shows the result of desaturating an ROI:\n\n\n\n### Apply an out-of-place operation to an ROI\n\nFor vImage routines that don’t operate in-place, create a non-mutating function that applies that routine to an ROI and returns a new [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure that contains the result.\n\nThe following code is the function header for a blurring function that applies [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageTentConvolve_ARGB8888(_:_:_:_:_:_:_:_:_:)]:\n\n```swift\nextension vImage_Buffer {\n    \n    func blurred_ARGB8888(regionOfInterest roi: CGRect,\n                          blurRadius: Int) -> vImage_Buffer? {\n```\n\nThe function performs the same check as [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest#Apply-an-in-place-operation-to-an-ROI] on the ROI size:\n\n```swift\n        guard Int(roi.maxX) <= width && Int(roi.maxY) <= height &&\n            Int(roi.minX) >= 0 && Int(roi.minY) >= 0 else {\n                print(\"ROI is out of bounds.\")\n                return nil\n        }\n```\n\n`vImage_Buffer.blurred_ARGB8888(regionOfInterest:blurRadius:)` returns a buffer that’s the same size as the source. The function copies all source pixels that are outside of the ROI to the destination. The following code creates the buffer that the function returns, and copies the source pixels into the new buffer:\n\n```swift\n        guard var destination = try? vImage_Buffer(width: Int(width),\n                                                   height: Int(height),\n                                                   bitsPerPixel: 32) else {\n                                                    return nil\n        }\n        \n        let bytesPerPixel = 4\n        \n        withUnsafePointer(to: self) { src in\n            vImageCopyBuffer(src,\n                             &destination,\n                             bytesPerPixel,\n                             vImage_Flags(kvImageNoFlags))\n        }\n```\n\nThe out-of-place function uses the same approach as [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest#Apply-an-in-place-operation-to-an-ROI], calculate the start of the ROI. The destination buffer for the blur operation references the copied pixels in `destination`:\n\n```swift\n        let start = Int(roi.origin.y) * destination.rowBytes +\n            Int(roi.origin.x) * bytesPerPixel\n        \n        var blurDestination = vImage_Buffer(data: destination.data.advanced(by: start),\n                                            height: vImagePixelCount(roi.height),\n                                            width: vImagePixelCount(roi.width),\n                                            rowBytes: destination.rowBytes)\n```\n\nFinally, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageTentConvolve_ARGB8888(_:_:_:_:_:_:_:_:_:)] function applies the blur to the source and writes the result to `blurDestination`.\n\n```swift\n        var error = kvImageNoError\n        \n        withUnsafePointer(to: self) { src in\n            let blurDiameter = UInt32(blurRadius * 2 + 1)\n            error = vImageTentConvolve_ARGB8888(src,\n                                                &blurDestination,\n                                                nil,\n                                                vImagePixelCount(roi.origin.x),\n                                                vImagePixelCount(roi.origin.y),\n                                                blurDiameter, blurDiameter,\n                                                [0],\n                                                vImage_Flags(kvImageTruncateKernel))\n        }\n        \n        if error != kvImageNoError {\n            destination.free()\n            print(\"Error: \\(error)\")\n            return nil\n        }\n        \n        return destination\n    }\n}\n```\n\nThe following shows the result of blurring an ROI:\n\n\n\n## Image Processing Essentials\n\n- **Converting bitmap data between Core Graphics images and vImage buffers**: Pass image data between Core Graphics and vImage to create and manipulate images.\n- **Creating and Populating Buffers from Core Graphics Images**: Initialize vImage buffers from Core Graphics images.\n- **Creating a Core Graphics Image from a vImage Buffer**: Create displayable representations of vImage buffers.\n- **Building a Basic Image-Processing Workflow**: Resize an image with vImage.\n- **Applying geometric transforms to images**: Reflect, shear, rotate, and scale image buffers using vImage.\n- **Compositing images with alpha blending**: Combine two images by using alpha blending to create a single output.\n- **Compositing images with vImage blend modes**: Combine two images by using blend modes to create a single output.\n- **Optimizing image-processing performance**: Improve your app’s performance by converting image buffer formats from interleaved to planar.\n- **vImage**: Manipulate large images using the CPU’s vector processor.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Pass image data between Core Graphics and vImage to create and manipulate images.",
          "name" : "Converting bitmap data between Core Graphics images and vImage buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/converting-bitmap-data-between-core-graphics-images-and-vimage-buffers"
        },
        {
          "description" : "Initialize vImage buffers from Core Graphics images.",
          "name" : "Creating and Populating Buffers from Core Graphics Images",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-and-populating-buffers-from-core-graphics-images"
        },
        {
          "description" : "Create displayable representations of vImage buffers.",
          "name" : "Creating a Core Graphics Image from a vImage Buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-a-core-graphics-image-from-a-vimage-buffer"
        },
        {
          "description" : "Resize an image with vImage.",
          "name" : "Building a Basic Image-Processing Workflow",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/building-a-basic-image-processing-workflow"
        },
        {
          "description" : "Reflect, shear, rotate, and scale image buffers using vImage.",
          "name" : "Applying geometric transforms to images",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-geometric-transforms-to-images"
        },
        {
          "description" : "Combine two images by using alpha blending to create a single output.",
          "name" : "Compositing images with alpha blending",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compositing-images-with-alpha-blending"
        },
        {
          "description" : "Combine two images by using blend modes to create a single output.",
          "name" : "Compositing images with vImage blend modes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compositing-images-with-vimage-blend-modes"
        },
        {
          "description" : "Improve your app’s performance by converting image buffer formats from interleaved to planar.",
          "name" : "Optimizing image-processing performance",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/optimizing-image-processing-performance"
        },
        {
          "description" : "Manipulate large images using the CPU’s vector processor.",
          "name" : "vImage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vimage-library"
        }
      ],
      "title" : "Image Processing Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Applying vImage operations to regions of interest",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest"
}