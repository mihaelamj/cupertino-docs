{
  "abstract" : "Perform compression for all files and decompression for files with supported extension types.",
  "codeExamples" : [
    {
      "code" : "let encodeAlgorithm = Algorithm.lzfse",
      "language" : "swift"
    },
    {
      "code" : "extension Algorithm {\n    init?(name: String) {\n        switch name.lowercased() {\n            case \"lz4\":\n                self = .lz4\n            case \"zlib\":\n                self = .zlib\n            case \"lzma\":\n                self = .lzma\n            case \"lzfse\":\n                self = .lzfse\n            default:\n                return nil\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let algorithm: Algorithm\nlet operation: FilterOperation\n                            \nif let decodeAlgorithm = Algorithm(name: url.pathExtension) {\n    algorithm = decodeAlgorithm\n    operation = .decompress\n    message = \"Decompressing \\(url.lastPathComponent)\"\n} else {\n    algorithm = self.encodeAlgorithm\n    operation = .compress\n    message = \"Compressing \\(url.lastPathComponent)\"\n}",
      "language" : "swift"
    },
    {
      "code" : "if\n    let sourceFileHandle = try? FileHandle(forReadingFrom: url),\n    let sourceLength = FileHelper.fileSize(atURL: url),\n    let fileName = url.pathComponents.last,\n    let fileNameDeletingPathExtension = url.deletingPathExtension().pathComponents.last,\n    let destinationFileHandle = FileHandle.makeFileHandle(forWritingToFileNameInTempDirectory:\n        operation == .compress\n            ? fileName + self.encodeAlgorithm.pathExtension\n            : fileNameDeletingPathExtension) {",
      "language" : "swift"
    },
    {
      "code" : "static func streamingCompression(operation: FilterOperation,\n                                 sourceFileHandle: FileHandle,\n                                 destinationFileHandle: FileHandle,\n                                 algorithm: Algorithm,\n                                 progressUpdateFunction: (UInt64) -> Void) {",
      "language" : "swift"
    },
    {
      "code" : "static func streamingCompression(operation: compression_stream_operation,\n                                 sourceFileHandle: FileHandle,\n                                 destinationFileHandle: FileHandle,\n                                 algorithm: compression_algorithm,\n                                 progressUpdateFunction: (UInt64) -> Void) {",
      "language" : "swift"
    },
    {
      "code" : "if useSwiftAPI {\n    Compressor.streamingCompression(operation: operation,\n                                    sourceFileHandle: sourceFileHandle,\n                                    destinationFileHandle: destinationFileHandle,\n                                    algorithm: algorithm) { progress in\n        DispatchQueue.main.async {\n            self.progress = Double(progress)\n        }\n    }\n} else {\n    Compressor.streamingCompression(operation: operation.rawValue,\n                                    sourceFileHandle: sourceFileHandle,\n                                    destinationFileHandle: destinationFileHandle,\n                                    algorithm: algorithm.rawValue) { progress in\n        \n        DispatchQueue.main.async {\n            self.progress = Double(progress)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "do {\n    let outputFilter = try OutputFilter(operation,\n                                        using: algorithm) {\n        (data: Data?) -> Void in\n        if let data = data {\n            destinationFileHandle.write(data)\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "while true {\n    let subdata = sourceFileHandle.readData(ofLength: bufferSize)\n    \n    progressUpdateFunction(sourceFileHandle.offsetInFile)\n    \n    try outputFilter.write(subdata)\n    if subdata.count < bufferSize {\n        break\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let destinationBufferPointer = UnsafeMutablePointer<UInt8>.allocate(capacity: bufferSize)\ndefer {\n    destinationBufferPointer.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "let streamPointer = UnsafeMutablePointer<compression_stream>.allocate(capacity: 1)\nvar status = compression_stream_init(streamPointer, operation, algorithm)\nguard status != COMPRESSION_STATUS_ERROR else {\n    fatalError(\"Unable to initialize the compression stream.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "defer {\n    compression_stream_destroy(streamPointer)\n    streamPointer.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "streamPointer.pointee.src_size = 0\nstreamPointer.pointee.dst_ptr = destinationBufferPointer\nstreamPointer.pointee.dst_size = bufferSize",
      "language" : "swift"
    },
    {
      "code" : "var sourceData: Data?\nrepeat {\n    var flags = Int32(0)\n    \n    \/\/ If this iteration has consumed all of the source data,\n    \/\/ read a new buffer from the input file.\n    if streamPointer.pointee.src_size == 0 {\n        sourceData = sourceFileHandle.readData(ofLength: bufferSize)\n        \n        streamPointer.pointee.src_size = sourceData!.count\n        if sourceData!.count < bufferSize {\n            flags = Int32(COMPRESSION_STREAM_FINALIZE.rawValue)\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "if let sourceData = sourceData {\n    let count = sourceData.count\n    \n    sourceData.withUnsafeBytes {\n        let baseAddress = $0.bindMemory(to: UInt8.self).baseAddress!\n        \n        streamPointer.pointee.src_ptr = baseAddress.advanced(by: count - streamPointer.pointee.src_size)\n        status = compression_stream_process(streamPointer, flags)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "switch status {\n    case COMPRESSION_STATUS_OK, COMPRESSION_STATUS_END:\n        \n        \/\/ Get the number of bytes put in the destination buffer.\n        \/\/ This is the difference between `stream.dst_size` before the\n        \/\/ call (`bufferSize`), and `stream.dst_size` after the call.\n        let count = bufferSize - streamPointer.pointee.dst_size\n        \n        let outputData = Data(bytesNoCopy: destinationBufferPointer,\n                              count: count,\n                              deallocator: .none)\n        \n        \/\/ Write all produced bytes to the output file.\n        destinationFileHandle.write(outputData)\n        \n        \/\/ Reset the stream to receive the next batch of output.\n        streamPointer.pointee.dst_ptr = destinationBufferPointer\n        streamPointer.pointee.dst_size = bufferSize",
      "language" : "swift"
    },
    {
      "code" : "sourceFileHandle.closeFile()\ndestinationFileHandle.closeFile()",
      "language" : "swift"
    }
  ],
  "contentHash" : "fd45d3296f56d9ae505cbe8156e031a07ab69f5e90d393b943f1b0e7858fd9bf",
  "crawledAt" : "2025-12-02T15:45:59Z",
  "id" : "6AD48E7B-4560-47D7-9AE2-0F8527C2458B",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThis sample code project uses the [doc:\/\/com.apple.documentation\/documentation\/Compression] framework to encode (compress) and decode (decompress) files when the user drags and drops them onto the app window. The app decompresses files with extensions that match one of four supported compression algorithms: `.lz4`, `.zlib`, `lzma`, or `.lzfse`, and compresses all other files, regardless of their extension. The app writes the encoded or decoded result to the temporary directory that the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSTemporaryDirectory()] function returns.\n\nThe code in this sample is useful in applications that store or transmit files, such as PDF or text, where saving or sending smaller files can improve performance and reduce storage overhead. This sample apps implements *stream compression*, where it reads chunks of data from a source buffer repeatedly to compress or decompress data, and appends each chunk to a destination buffer.\n\n\n\nBecause the sample app performs the encoding and decoding in a background thread, it’s able to remain interactive and update the user interface with progress of the operation with a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ProgressView]. Stream compression also enables tasks such as:\n\nThis sample code project includes implementations that use the Compression Swift API and C API. The Compression C API is suitable for use with Swift and Objective-C and for older operating systems that’s don’t support the Swift API.\n\n### Select a compression algorithm\n\nThe app uses the [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/lzfse] algorithm, which provides the compression ratio of zlib level 5, but with much higher energy efficiency and speed (between 2x and 3x) for both encode and decode operations.\n\nFor apps that require interoperability with non-Apple devices, use [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/zlib] instead. For more information about other compression algorithms, see [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_algorithm].\n\n### Distinguish between compressed and uncompressed files\n\nThe sample code uses a file’s path extension to infer whether a file is already compressed, or if the file needs to be compressed. To simplify this process, the project includes a failable initializer in an extension to the Compression framework’s [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm] enumeration.\n\nThe following code uses the new initializer to define the `algorithm` and `operation` constants:\n\n### Define the source and destination file handles\n\nThe sample uses [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle] instances to read from the source file and write to the destination file. Use optional binding to define the required file handles.\n\nIf the optional binding succeeded, the destination file handle points to the source filename by appending the respective compression algorithm extension, or removing the extension in the case of decompression.\n\nFor example, the compressed source file `MyCompressedFile.PDF.lzfse` would have a decompressed destination of `MyCompressedFile.PDF`; and the uncompressed source file, `MyRawFile.PDF`, would have a compressed destination of `MyRawFile.PDF.lzfse`.\n\n### Perform streaming compression\n\nThe `streamingCompression(operation:sourceFileHandle:destinationFileHandle:algorithm:progressUpdateFunction:)` functions iterate over the source data and encodes or decodes data in blocks based on the length that `bufferSize` defines. The methods write the result into the destination buffer, and write the destination buffer data to the destination file handle. The Swift and C API functions have slightly different signatures.\n\nThe following is the function declaration for the Swift version of the streaming compression function:\n\nThe following is the function declaration for the C API version of the streaming compression function:\n\nThe sample code passes the source and destination file handles, with the operation and algorithm values to either `streamingCompression` function based on the value of the Boolean constant, `useSwiftAPI`:\n\n### Create the output filter using the Swift API\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instance specifies the operation and the compression algorithm.  The final initializer parameter is a closure the instance calls as it writes each encoded or decoded block of data to the destination file handler.\n\n### Compress or decompress the dropped file using the Swift API\n\nThe Swift streaming compression function iterates over the source data and calls the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/readData(ofLength:)] method to copy `bufferSize` chunks to `subdata`.\n\n### Create a destination buffer using the C API\n\nThe C API streaming compression function allocates the destination buffer based on the `bufferSize` constant.\n\n### Create a compression stream using the C API\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_stream] structure defines the source and destination pointers and sizes.  The following code declares and initializes the compression stream:\n\nTo prevent memory leaks, the following code calls [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_stream_destroy(_:)] to free the memory that the stream initialization function allocated. A defer block frees the memory even if the `streamingCompression` method exits early:\n\nThe sample code sets up the initialized stream by defining its source and destination sizes and destination pointer:\n\n### Read the source file data iteratively using the C API\n\nA `repeat-while` loop manages the read-encode\/decode-write process. If the stream’s source size is zero, the code reads a block of data from the source file handle and points the stream’s source pointer to that data. If the read data is shorter than the buffer size, the code infers that it’s reading the last block of the source file and sets the stream’s status to [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_STREAM_FINALIZE]:\n\n### Compress or decompress the dropped file using the C API\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_stream_process(_:_:)] function encodes or decodes the current block.\n\nOn return, `destinationBufferPointer` points to the encoded or decoded data.\n\n### Write encoded or decoded data to a destination file\n\nThe following code checks the status that `compression_stream_process` returns. If the status is either [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_STATUS_OK] or [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_STATUS_END], the code writes the destination data to the destination file handler:\n\nThis read-encode\/decode-write loop continues while `status` equals `COMPRESSION_STATUS_OK`.\n\n### Close the source and destination files\n\nAfter the app has finished working with the source and destination file handles, it calls the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()] method to close them.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-files-with-stream-compression\ncrawled: 2025-12-02T15:45:59Z\n---\n\n# Compressing and decompressing files with stream compression\n\n**Sample Code**\n\nPerform compression for all files and decompression for files with supported extension types.\n\n## Overview\n\nThis sample code project uses the [doc:\/\/com.apple.documentation\/documentation\/Compression] framework to encode (compress) and decode (decompress) files when the user drags and drops them onto the app window. The app decompresses files with extensions that match one of four supported compression algorithms: `.lz4`, `.zlib`, `lzma`, or `.lzfse`, and compresses all other files, regardless of their extension. The app writes the encoded or decoded result to the temporary directory that the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSTemporaryDirectory()] function returns.\n\nThe code in this sample is useful in applications that store or transmit files, such as PDF or text, where saving or sending smaller files can improve performance and reduce storage overhead. This sample apps implements *stream compression*, where it reads chunks of data from a source buffer repeatedly to compress or decompress data, and appends each chunk to a destination buffer.\n\n\n\nBecause the sample app performs the encoding and decoding in a background thread, it’s able to remain interactive and update the user interface with progress of the operation with a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ProgressView]. Stream compression also enables tasks such as:\n\n- Decoding a compressed stream into a buffer, with the ability to grow that buffer and resume decoding if the expanded stream is too large to fit, without repeating any work.\n- Encoding a stream as pieces of it become available, without ever needing to create a buffer large enough to hold all the uncompressed data at one time.\n\nThis sample code project includes implementations that use the Compression Swift API and C API. The Compression C API is suitable for use with Swift and Objective-C and for older operating systems that’s don’t support the Swift API.\n\n### Select a compression algorithm\n\nThe app uses the [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/lzfse] algorithm, which provides the compression ratio of zlib level 5, but with much higher energy efficiency and speed (between 2x and 3x) for both encode and decode operations.\n\n```swift\nlet encodeAlgorithm = Algorithm.lzfse\n```\n\nFor apps that require interoperability with non-Apple devices, use [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/zlib] instead. For more information about other compression algorithms, see [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_algorithm].\n\n### Distinguish between compressed and uncompressed files\n\nThe sample code uses a file’s path extension to infer whether a file is already compressed, or if the file needs to be compressed. To simplify this process, the project includes a failable initializer in an extension to the Compression framework’s [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm] enumeration.\n\n```swift\nextension Algorithm {\n    init?(name: String) {\n        switch name.lowercased() {\n            case \"lz4\":\n                self = .lz4\n            case \"zlib\":\n                self = .zlib\n            case \"lzma\":\n                self = .lzma\n            case \"lzfse\":\n                self = .lzfse\n            default:\n                return nil\n        }\n    }\n}\n```\n\nThe following code uses the new initializer to define the `algorithm` and `operation` constants:\n\n```swift\nlet algorithm: Algorithm\nlet operation: FilterOperation\n                            \nif let decodeAlgorithm = Algorithm(name: url.pathExtension) {\n    algorithm = decodeAlgorithm\n    operation = .decompress\n    message = \"Decompressing \\(url.lastPathComponent)\"\n} else {\n    algorithm = self.encodeAlgorithm\n    operation = .compress\n    message = \"Compressing \\(url.lastPathComponent)\"\n}\n```\n\n### Define the source and destination file handles\n\nThe sample uses [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle] instances to read from the source file and write to the destination file. Use optional binding to define the required file handles.\n\n```swift\nif\n    let sourceFileHandle = try? FileHandle(forReadingFrom: url),\n    let sourceLength = FileHelper.fileSize(atURL: url),\n    let fileName = url.pathComponents.last,\n    let fileNameDeletingPathExtension = url.deletingPathExtension().pathComponents.last,\n    let destinationFileHandle = FileHandle.makeFileHandle(forWritingToFileNameInTempDirectory:\n        operation == .compress\n            ? fileName + self.encodeAlgorithm.pathExtension\n            : fileNameDeletingPathExtension) {\n```\n\nIf the optional binding succeeded, the destination file handle points to the source filename by appending the respective compression algorithm extension, or removing the extension in the case of decompression.\n\nFor example, the compressed source file `MyCompressedFile.PDF.lzfse` would have a decompressed destination of `MyCompressedFile.PDF`; and the uncompressed source file, `MyRawFile.PDF`, would have a compressed destination of `MyRawFile.PDF.lzfse`.\n\n### Perform streaming compression\n\nThe `streamingCompression(operation:sourceFileHandle:destinationFileHandle:algorithm:progressUpdateFunction:)` functions iterate over the source data and encodes or decodes data in blocks based on the length that `bufferSize` defines. The methods write the result into the destination buffer, and write the destination buffer data to the destination file handle. The Swift and C API functions have slightly different signatures.\n\nThe following is the function declaration for the Swift version of the streaming compression function:\n\n```swift\nstatic func streamingCompression(operation: FilterOperation,\n                                 sourceFileHandle: FileHandle,\n                                 destinationFileHandle: FileHandle,\n                                 algorithm: Algorithm,\n                                 progressUpdateFunction: (UInt64) -> Void) {\n```\n\nThe following is the function declaration for the C API version of the streaming compression function:\n\n```swift\nstatic func streamingCompression(operation: compression_stream_operation,\n                                 sourceFileHandle: FileHandle,\n                                 destinationFileHandle: FileHandle,\n                                 algorithm: compression_algorithm,\n                                 progressUpdateFunction: (UInt64) -> Void) {\n```\n\nThe sample code passes the source and destination file handles, with the operation and algorithm values to either `streamingCompression` function based on the value of the Boolean constant, `useSwiftAPI`:\n\n```swift\nif useSwiftAPI {\n    Compressor.streamingCompression(operation: operation,\n                                    sourceFileHandle: sourceFileHandle,\n                                    destinationFileHandle: destinationFileHandle,\n                                    algorithm: algorithm) { progress in\n        DispatchQueue.main.async {\n            self.progress = Double(progress)\n        }\n    }\n} else {\n    Compressor.streamingCompression(operation: operation.rawValue,\n                                    sourceFileHandle: sourceFileHandle,\n                                    destinationFileHandle: destinationFileHandle,\n                                    algorithm: algorithm.rawValue) { progress in\n        \n        DispatchQueue.main.async {\n            self.progress = Double(progress)\n        }\n    }\n}\n```\n\n### Create the output filter using the Swift API\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instance specifies the operation and the compression algorithm.  The final initializer parameter is a closure the instance calls as it writes each encoded or decoded block of data to the destination file handler.\n\n```swift\ndo {\n    let outputFilter = try OutputFilter(operation,\n                                        using: algorithm) {\n        (data: Data?) -> Void in\n        if let data = data {\n            destinationFileHandle.write(data)\n        }\n    }\n```\n\n### Compress or decompress the dropped file using the Swift API\n\nThe Swift streaming compression function iterates over the source data and calls the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/readData(ofLength:)] method to copy `bufferSize` chunks to `subdata`.\n\n```swift\nwhile true {\n    let subdata = sourceFileHandle.readData(ofLength: bufferSize)\n    \n    progressUpdateFunction(sourceFileHandle.offsetInFile)\n    \n    try outputFilter.write(subdata)\n    if subdata.count < bufferSize {\n        break\n    }\n}\n```\n\n### Create a destination buffer using the C API\n\nThe C API streaming compression function allocates the destination buffer based on the `bufferSize` constant.\n\n```swift\nlet destinationBufferPointer = UnsafeMutablePointer<UInt8>.allocate(capacity: bufferSize)\ndefer {\n    destinationBufferPointer.deallocate()\n}\n```\n\n### Create a compression stream using the C API\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_stream] structure defines the source and destination pointers and sizes.  The following code declares and initializes the compression stream:\n\n```swift\nlet streamPointer = UnsafeMutablePointer<compression_stream>.allocate(capacity: 1)\nvar status = compression_stream_init(streamPointer, operation, algorithm)\nguard status != COMPRESSION_STATUS_ERROR else {\n    fatalError(\"Unable to initialize the compression stream.\")\n}\n```\n\nTo prevent memory leaks, the following code calls [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_stream_destroy(_:)] to free the memory that the stream initialization function allocated. A defer block frees the memory even if the `streamingCompression` method exits early:\n\n```swift\ndefer {\n    compression_stream_destroy(streamPointer)\n    streamPointer.deallocate()\n}\n```\n\nThe sample code sets up the initialized stream by defining its source and destination sizes and destination pointer:\n\n```swift\nstreamPointer.pointee.src_size = 0\nstreamPointer.pointee.dst_ptr = destinationBufferPointer\nstreamPointer.pointee.dst_size = bufferSize\n```\n\n### Read the source file data iteratively using the C API\n\nA `repeat-while` loop manages the read-encode\/decode-write process. If the stream’s source size is zero, the code reads a block of data from the source file handle and points the stream’s source pointer to that data. If the read data is shorter than the buffer size, the code infers that it’s reading the last block of the source file and sets the stream’s status to [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_STREAM_FINALIZE]:\n\n```swift\nvar sourceData: Data?\nrepeat {\n    var flags = Int32(0)\n    \n    \/\/ If this iteration has consumed all of the source data,\n    \/\/ read a new buffer from the input file.\n    if streamPointer.pointee.src_size == 0 {\n        sourceData = sourceFileHandle.readData(ofLength: bufferSize)\n        \n        streamPointer.pointee.src_size = sourceData!.count\n        if sourceData!.count < bufferSize {\n            flags = Int32(COMPRESSION_STREAM_FINALIZE.rawValue)\n        }\n    }\n```\n\n### Compress or decompress the dropped file using the C API\n\nThe [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_stream_process(_:_:)] function encodes or decodes the current block.\n\n```swift\nif let sourceData = sourceData {\n    let count = sourceData.count\n    \n    sourceData.withUnsafeBytes {\n        let baseAddress = $0.bindMemory(to: UInt8.self).baseAddress!\n        \n        streamPointer.pointee.src_ptr = baseAddress.advanced(by: count - streamPointer.pointee.src_size)\n        status = compression_stream_process(streamPointer, flags)\n    }\n}\n```\n\nOn return, `destinationBufferPointer` points to the encoded or decoded data.\n\n### Write encoded or decoded data to a destination file\n\nThe following code checks the status that `compression_stream_process` returns. If the status is either [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_STATUS_OK] or [doc:\/\/com.apple.documentation\/documentation\/Compression\/COMPRESSION_STATUS_END], the code writes the destination data to the destination file handler:\n\n```swift\nswitch status {\n    case COMPRESSION_STATUS_OK, COMPRESSION_STATUS_END:\n        \n        \/\/ Get the number of bytes put in the destination buffer.\n        \/\/ This is the difference between `stream.dst_size` before the\n        \/\/ call (`bufferSize`), and `stream.dst_size` after the call.\n        let count = bufferSize - streamPointer.pointee.dst_size\n        \n        let outputData = Data(bytesNoCopy: destinationBufferPointer,\n                              count: count,\n                              deallocator: .none)\n        \n        \/\/ Write all produced bytes to the output file.\n        destinationFileHandle.write(outputData)\n        \n        \/\/ Reset the stream to receive the next batch of output.\n        streamPointer.pointee.dst_ptr = destinationBufferPointer\n        streamPointer.pointee.dst_size = bufferSize\n```\n\nThis read-encode\/decode-write loop continues while `status` equals `COMPRESSION_STATUS_OK`.\n\n### Close the source and destination files\n\nAfter the app has finished working with the source and destination file handles, it calls the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()] method to close them.\n\n```swift\nsourceFileHandle.closeFile()\ndestinationFileHandle.closeFile()\n```\n\n## Compression\n\n- **Compressing and decompressing data with buffer compression**: Compress a string, write it to the file system, and decompress the same file using buffer compression.\n- **Compressing and decompressing data with input and output filters**: Compress and decompress streamed or from-memory data, using input and output filters.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Compress a string, write it to the file system, and decompress the same file using buffer compression.",
          "name" : "Compressing and decompressing data with buffer compression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-buffer-compression"
        },
        {
          "description" : "Compress and decompress streamed or from-memory data, using input and output filters.",
          "name" : "Compressing and decompressing data with input and output filters",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-input-and-output-filters"
        }
      ],
      "title" : "Compression"
    }
  ],
  "source" : "appleJSON",
  "title" : "Compressing and decompressing files with stream compression",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-files-with-stream-compression"
}