{
  "abstract" : "Precompute translation values to optimize color space conversion and other pointwise operations.",
  "codeExamples" : [
    {
      "code" : "let entriesPerChannel = UInt8(16)\nlet srcChannelCount = UInt32(3)\nlet destChannelCount = UInt32(4)\n\nlet lookupTableElementCount = Int(pow(Float(entriesPerChannel),\n                                      Float(srcChannelCount))) *\n                              Int(destChannelCount)",
      "language" : "swift"
    },
    {
      "code" : "let tableData = [UInt16](unsafeUninitializedCapacity: lookupTableElementCount) {\n    buffer, count in\n    \n    \/\/\/ Supply the samples in the range `0...65535`. The transform function\n    \/\/\/ interpolates these to the range `0...1`.\n    let multiplier = CGFloat(UInt16.max)\n    var bufferIndex = 0\n    \n    for red in ( 0 ..< entriesPerChannel) {\n        for green in ( 0 ..< entriesPerChannel) {\n            for blue in ( 0 ..< entriesPerChannel) {\n                \n                \/\/\/ Create normalized red, green, and blue values in the range `0...1`.\n                let normalizedColor = simd_double3(\n                    x: CGFloat(red),\n                    y: CGFloat(green),\n                    z: CGFloat(blue)) \/ CGFloat(entriesPerChannel - 1)\n     \n                \/\/\/ Create a CMYK representsation of the RGB color.\n                let cmyk = ColorConverter.rgbToCMYK(normalizedColor) * multiplier\n                \n                \/\/\/ Append the cyan, magenta, yellow, and black components to the buffer.\n                buffer[ bufferIndex ] = UInt16(cmyk.x)\n                bufferIndex += 1\n                buffer[ bufferIndex ] = UInt16(cmyk.y)\n                bufferIndex += 1\n                buffer[ bufferIndex ] = UInt16(cmyk.z)\n                bufferIndex += 1\n                buffer[ bufferIndex ] = UInt16(cmyk.w)\n                bufferIndex += 1\n            }\n        }\n    }\n    \n    count = lookupTableElementCount\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ColorConverter {\n    static let rgbColorSpace = CGColorSpace(name: CGColorSpace.displayP3)!\n    static let cmykColorSpace = CGColorSpace(name: CGColorSpace.genericCMYK)!\n    \n    static let bitmapInfo = CGBitmapInfo(\n        rawValue: kCGBitmapByteOrder32Host.rawValue |\n        CGBitmapInfo.floatComponents.rawValue |\n        CGImageAlphaInfo.none.rawValue)\n    \n    static let cmykToLabConverter = try! vImageConverter.make(\n        sourceFormat: .init(bitsPerComponent: 32,\n                            bitsPerPixel: 32 * 3,\n                            colorSpace: rgbColorSpace,\n                            bitmapInfo: bitmapInfo)!,\n        destinationFormat: .init(bitsPerComponent: 32,\n                                 bitsPerPixel: 32 * 4,\n                                 colorSpace: cmykColorSpace,\n                                 bitmapInfo: bitmapInfo)!)\n    \n    @inlinable\n    static func rgbToCMYK(_ src: simd_double3) -> simd_double4 {\n        \n        let srcPixelBuffer = vImage.PixelBuffer<vImage.InterleavedFx3>(\n            pixelValues: [src.x, src.y, src.z].map { Float($0) },\n            size: .init(width: 1, height: 1))\n        \n        let dstPixelBuffer = vImage.PixelBuffer<vImage.InterleavedFx4>(\n            size: .init(width: 1, height: 1))\n        \n        try! cmykToLabConverter.convert(from: srcPixelBuffer, to: dstPixelBuffer)\n        \n        let dstColor = dstPixelBuffer.array.map { CGFloat($0 )}\n        \n        return .init(x: dstColor[0], y: dstColor[1], z: dstColor[2], w: dstColor[3])\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var error = kvImageNoError\n\nlet tableEntriesPerDimension = [UInt8](repeating: entriesPerChannel,\n                                       count: Int(srcChannelCount))\nguard let lookupTable = vImageMultidimensionalTable_Create(\n        tableData,\n        srcChannelCount,\n        destChannelCount,\n        tableEntriesPerDimension,\n        kvImageMDTableHint_Float,\n        vImage_Flags(kvImageNoFlags),\n        &error) else {\n    fatalError(\"Unable to create multidimensional table \\(error).\")\n}\n\ndefer {\n    vImageMultidimensionalTable_Release(lookupTable)\n}",
      "language" : "swift"
    },
    {
      "code" : "error = vImageMultiDimensionalInterpolatedLookupTable_PlanarF(\n    [srcRedBuffer, srcGreenBuffer, srcBlueBuffer],\n    [destCyanBuffer, destMagentaBuffer, destYellowBuffer, destBlackBuffer],\n    nil,\n    lookupTable,\n    kvImageFullInterpolation,\n    vImage_Flags(kvImageNoFlags))\n        \nif error != kvImageNoError {\n    fatalError(\"Error calling transform function` \\(error).\")\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ An array of three 32-bit planar pixels buffers that contain the RGB source.\nlet sources: [vImage.PixelBuffer<vImage.PlanarF>] = ... \n\n\/\/ An array of four 32-bit planar pixels buffers that represent the CMYK destination.\nlet destinations: [vImage.PixelBuffer<vImage.PlanarF>] = ...\n\nlet lookupTable = vImage.MultidimensionalLookupTable(\n    entryCountPerSourceChannel: tableEntriesPerDimension,\n    destinationChannelCount: Int(destChannelCount),\n    data: tableData)\n\nlookupTable.apply(sources: sources,\n                  destinations: destinations,\n                  interpolation: .full)",
      "language" : "swift"
    }
  ],
  "contentHash" : "34bce170f4ff3767c1632dbd29ce1e65cd7f07bb5934f61ce430ac6db07983f5",
  "crawledAt" : "2025-12-02T15:37:29Z",
  "id" : "018815F1-DD60-44CE-9184-9EBFB9953713",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nWhen you perform color space conversions or other color transformations, it can be quicker to precompute the conversion values rather than performing the calculation for each individual pixel. The vImage library provides functionality for transforming images using multidimensional lookup tables. A multidimensional lookup table allows you to define such complex color transformations between image formats with the same or different numbers of channels.\n\nAn example of a multidimensional lookup table is a 3D lookup table that converts RGB colors to the CMYK color model that’s commonly used in printing. As the following image illustrates, an RGB to CMYK multidimensional lookup table is a cube that represents the RGB color space, with axes for red, green, and blue. Each point in that cube corresponds to a unique RGB color that contains the corresponding CMYK value.\n\n\n\nEach dimension of the RGB cube in the image above contains eight entries — that is, there are 8³ or 512 source samples, which appear as small cubes. Each sample contains four values that represent the CMYK values for the corresponding RGB color. For example, the sample for pure red (RGB `[1, 0, 0]`) contains the CMYK values `[0, 1, 1, 0]`, and the sample for cyan (RGB `[0, 1, 1]`) contains the CMYK values `[1, 0, 0, 0]`.\n\n### Define the lookup table size\n\nDefine the number of elements in the lookup table from the number of table entries per channel, the number of source channels, and the number of destination channels. For the RGB to CMYK conversion, in the following example, the lookup table contains four values (for cyan, magenta, yellow, and black) at each point in the RGB cube. The RGB cube contains the number of table entries per channels cubed.\n\nYou can set the vImage multidimensional lookup table functions to linearly interpolate between values. A high `entriesPerChannel` value provides greater color fidelity than a low value, but with a corresponding performance and memory overhead.\n\n### Create the table data\n\nSupply the lookup table as a contiguous array of samples that define the lookup table values. The following code iterates over red, green, and blue values and creates an RGB [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGColor] instance for each permutation. The code converts the RGB color instance to the CMYK color space and populates the lookup table with the cyan, magenta, yellow, and black components.\n\nIn the following example, the RGB-to-CMYK value conversion code uses a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter] instance to convert a single RGB pixel to a single CMYK pixel:\n\n### Create the lookup table\n\nCall [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultidimensionalTable_Create(_:_:_:_:_:_:_:)] to create a multidimensional lookup table from the table data array. Because the code in this example only uses the 32-bit transform function, pass the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageMDTableHint_Float] hint to reduce memory overhead:\n\nThe lookup table structure is immutable and thread-safe, and therefore you can use it with multiple and concurrent calls to the appropriate transform function. After you finish using the lookup table, call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultidimensionalTable_Release(_:)] to free its resources.\n\n### Apply the transform\n\nvImage provides two functions to apply the multidimensional lookup table to an image: [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultiDimensionalInterpolatedLookupTable_PlanarF(_:_:_:_:_:_:)] for 32-bit planar buffers, and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12(_:_:_:_:_:_:)] for 16Q12 planar buffers.\n\nThe code below applies the lookup table to three 32-bit source buffers (`srcRedBuffer`, `srcGreenBuffer`, and `srcBlueBuffer`) and writes the result to four 32-bit destination buffers (`destCyanBuffer`, `destMagentaBuffer`, `destYellowBuffer`, and `destBlackBuffer`). For more information about working with planar buffers, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/optimizing-image-processing-performance].\n\nOn return, the four destination planar buffers contain the cyan, magenta, yellow, and black channels of the original RGB source image, as the following image shows:\n\n\n\n### Apply multidimensional lookup tables to pixel buffers\n\nIf you’re creating apps for recent operating systems that support the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] API, the vImage library includes the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/MultidimensionalLookupTable] structure, which provides a simple interface to a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_MultidimensionalTable] structure. A [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/MultidimensionalLookupTable] structure uses the same lookup table data as a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_MultidimensionalTable] structure. The code below performs an RGB-to-CMYK conversion using 32-bit planar pixel buffers:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-color-transforms-to-images-with-a-multidimensional-lookup-table\ncrawled: 2025-12-02T15:37:29Z\n---\n\n# Applying color transforms to images with a multidimensional lookup table\n\n**Article**\n\nPrecompute translation values to optimize color space conversion and other pointwise operations.\n\n## Overview\n\nWhen you perform color space conversions or other color transformations, it can be quicker to precompute the conversion values rather than performing the calculation for each individual pixel. The vImage library provides functionality for transforming images using multidimensional lookup tables. A multidimensional lookup table allows you to define such complex color transformations between image formats with the same or different numbers of channels.\n\nAn example of a multidimensional lookup table is a 3D lookup table that converts RGB colors to the CMYK color model that’s commonly used in printing. As the following image illustrates, an RGB to CMYK multidimensional lookup table is a cube that represents the RGB color space, with axes for red, green, and blue. Each point in that cube corresponds to a unique RGB color that contains the corresponding CMYK value.\n\n\n\nEach dimension of the RGB cube in the image above contains eight entries — that is, there are 8³ or 512 source samples, which appear as small cubes. Each sample contains four values that represent the CMYK values for the corresponding RGB color. For example, the sample for pure red (RGB `[1, 0, 0]`) contains the CMYK values `[0, 1, 1, 0]`, and the sample for cyan (RGB `[0, 1, 1]`) contains the CMYK values `[1, 0, 0, 0]`.\n\n### Define the lookup table size\n\nDefine the number of elements in the lookup table from the number of table entries per channel, the number of source channels, and the number of destination channels. For the RGB to CMYK conversion, in the following example, the lookup table contains four values (for cyan, magenta, yellow, and black) at each point in the RGB cube. The RGB cube contains the number of table entries per channels cubed.\n\n```swift\nlet entriesPerChannel = UInt8(16)\nlet srcChannelCount = UInt32(3)\nlet destChannelCount = UInt32(4)\n\nlet lookupTableElementCount = Int(pow(Float(entriesPerChannel),\n                                      Float(srcChannelCount))) *\n                              Int(destChannelCount)\n```\n\nYou can set the vImage multidimensional lookup table functions to linearly interpolate between values. A high `entriesPerChannel` value provides greater color fidelity than a low value, but with a corresponding performance and memory overhead.\n\n### Create the table data\n\nSupply the lookup table as a contiguous array of samples that define the lookup table values. The following code iterates over red, green, and blue values and creates an RGB [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGColor] instance for each permutation. The code converts the RGB color instance to the CMYK color space and populates the lookup table with the cyan, magenta, yellow, and black components.\n\n```swift\nlet tableData = [UInt16](unsafeUninitializedCapacity: lookupTableElementCount) {\n    buffer, count in\n    \n    \/\/\/ Supply the samples in the range `0...65535`. The transform function\n    \/\/\/ interpolates these to the range `0...1`.\n    let multiplier = CGFloat(UInt16.max)\n    var bufferIndex = 0\n    \n    for red in ( 0 ..< entriesPerChannel) {\n        for green in ( 0 ..< entriesPerChannel) {\n            for blue in ( 0 ..< entriesPerChannel) {\n                \n                \/\/\/ Create normalized red, green, and blue values in the range `0...1`.\n                let normalizedColor = simd_double3(\n                    x: CGFloat(red),\n                    y: CGFloat(green),\n                    z: CGFloat(blue)) \/ CGFloat(entriesPerChannel - 1)\n     \n                \/\/\/ Create a CMYK representsation of the RGB color.\n                let cmyk = ColorConverter.rgbToCMYK(normalizedColor) * multiplier\n                \n                \/\/\/ Append the cyan, magenta, yellow, and black components to the buffer.\n                buffer[ bufferIndex ] = UInt16(cmyk.x)\n                bufferIndex += 1\n                buffer[ bufferIndex ] = UInt16(cmyk.y)\n                bufferIndex += 1\n                buffer[ bufferIndex ] = UInt16(cmyk.z)\n                bufferIndex += 1\n                buffer[ bufferIndex ] = UInt16(cmyk.w)\n                bufferIndex += 1\n            }\n        }\n    }\n    \n    count = lookupTableElementCount\n}\n```\n\nIn the following example, the RGB-to-CMYK value conversion code uses a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter] instance to convert a single RGB pixel to a single CMYK pixel:\n\n```swift\nstruct ColorConverter {\n    static let rgbColorSpace = CGColorSpace(name: CGColorSpace.displayP3)!\n    static let cmykColorSpace = CGColorSpace(name: CGColorSpace.genericCMYK)!\n    \n    static let bitmapInfo = CGBitmapInfo(\n        rawValue: kCGBitmapByteOrder32Host.rawValue |\n        CGBitmapInfo.floatComponents.rawValue |\n        CGImageAlphaInfo.none.rawValue)\n    \n    static let cmykToLabConverter = try! vImageConverter.make(\n        sourceFormat: .init(bitsPerComponent: 32,\n                            bitsPerPixel: 32 * 3,\n                            colorSpace: rgbColorSpace,\n                            bitmapInfo: bitmapInfo)!,\n        destinationFormat: .init(bitsPerComponent: 32,\n                                 bitsPerPixel: 32 * 4,\n                                 colorSpace: cmykColorSpace,\n                                 bitmapInfo: bitmapInfo)!)\n    \n    @inlinable\n    static func rgbToCMYK(_ src: simd_double3) -> simd_double4 {\n        \n        let srcPixelBuffer = vImage.PixelBuffer<vImage.InterleavedFx3>(\n            pixelValues: [src.x, src.y, src.z].map { Float($0) },\n            size: .init(width: 1, height: 1))\n        \n        let dstPixelBuffer = vImage.PixelBuffer<vImage.InterleavedFx4>(\n            size: .init(width: 1, height: 1))\n        \n        try! cmykToLabConverter.convert(from: srcPixelBuffer, to: dstPixelBuffer)\n        \n        let dstColor = dstPixelBuffer.array.map { CGFloat($0 )}\n        \n        return .init(x: dstColor[0], y: dstColor[1], z: dstColor[2], w: dstColor[3])\n    }\n}\n```\n\n### Create the lookup table\n\nCall [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultidimensionalTable_Create(_:_:_:_:_:_:_:)] to create a multidimensional lookup table from the table data array. Because the code in this example only uses the 32-bit transform function, pass the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageMDTableHint_Float] hint to reduce memory overhead:\n\n```swift\nvar error = kvImageNoError\n\nlet tableEntriesPerDimension = [UInt8](repeating: entriesPerChannel,\n                                       count: Int(srcChannelCount))\nguard let lookupTable = vImageMultidimensionalTable_Create(\n        tableData,\n        srcChannelCount,\n        destChannelCount,\n        tableEntriesPerDimension,\n        kvImageMDTableHint_Float,\n        vImage_Flags(kvImageNoFlags),\n        &error) else {\n    fatalError(\"Unable to create multidimensional table \\(error).\")\n}\n\ndefer {\n    vImageMultidimensionalTable_Release(lookupTable)\n}\n```\n\nThe lookup table structure is immutable and thread-safe, and therefore you can use it with multiple and concurrent calls to the appropriate transform function. After you finish using the lookup table, call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultidimensionalTable_Release(_:)] to free its resources.\n\n### Apply the transform\n\nvImage provides two functions to apply the multidimensional lookup table to an image: [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultiDimensionalInterpolatedLookupTable_PlanarF(_:_:_:_:_:_:)] for 32-bit planar buffers, and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageMultiDimensionalInterpolatedLookupTable_Planar16Q12(_:_:_:_:_:_:)] for 16Q12 planar buffers.\n\nThe code below applies the lookup table to three 32-bit source buffers (`srcRedBuffer`, `srcGreenBuffer`, and `srcBlueBuffer`) and writes the result to four 32-bit destination buffers (`destCyanBuffer`, `destMagentaBuffer`, `destYellowBuffer`, and `destBlackBuffer`). For more information about working with planar buffers, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/optimizing-image-processing-performance].\n\n```swift\nerror = vImageMultiDimensionalInterpolatedLookupTable_PlanarF(\n    [srcRedBuffer, srcGreenBuffer, srcBlueBuffer],\n    [destCyanBuffer, destMagentaBuffer, destYellowBuffer, destBlackBuffer],\n    nil,\n    lookupTable,\n    kvImageFullInterpolation,\n    vImage_Flags(kvImageNoFlags))\n        \nif error != kvImageNoError {\n    fatalError(\"Error calling transform function` \\(error).\")\n}\n```\n\nOn return, the four destination planar buffers contain the cyan, magenta, yellow, and black channels of the original RGB source image, as the following image shows:\n\n\n\n### Apply multidimensional lookup tables to pixel buffers\n\nIf you’re creating apps for recent operating systems that support the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] API, the vImage library includes the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/MultidimensionalLookupTable] structure, which provides a simple interface to a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_MultidimensionalTable] structure. A [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/MultidimensionalLookupTable] structure uses the same lookup table data as a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_MultidimensionalTable] structure. The code below performs an RGB-to-CMYK conversion using 32-bit planar pixel buffers:\n\n```swift\n\/\/ An array of three 32-bit planar pixels buffers that contain the RGB source.\nlet sources: [vImage.PixelBuffer<vImage.PlanarF>] = ... \n\n\/\/ An array of four 32-bit planar pixels buffers that represent the CMYK destination.\nlet destinations: [vImage.PixelBuffer<vImage.PlanarF>] = ...\n\nlet lookupTable = vImage.MultidimensionalLookupTable(\n    entryCountPerSourceChannel: tableEntriesPerDimension,\n    destinationChannelCount: Int(destChannelCount),\n    data: tableData)\n\nlookupTable.apply(sources: sources,\n                  destinations: destinations,\n                  interpolation: .full)\n```\n\n## Conversion Between Image Formats\n\n- **Building a basic image conversion workflow**: Learn the fundamentals of the convert-any-to-any function by converting a CMYK image to an RGB image.\n- **Converting color images to grayscale**: Convert an RGB image to grayscale using matrix multiplication.\n- **Building a basic image conversion workflow**: Learn the fundamentals of the convert-any-to-any function by converting a CMYK image to an RGB image.\n- **Converting luminance and chrominance planes to an ARGB image**: Create a displayable ARGB image using the luminance and chrominance information from your device’s camera.\n- **Conversion**: Convert an image to a different format.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn the fundamentals of the convert-any-to-any function by converting a CMYK image to an RGB image.",
          "name" : "Building a basic image conversion workflow",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/building-a-basic-image-conversion-workflow"
        },
        {
          "description" : "Convert an RGB image to grayscale using matrix multiplication.",
          "name" : "Converting color images to grayscale",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/converting-color-images-to-grayscale"
        },
        {
          "description" : "Learn the fundamentals of the convert-any-to-any function by converting a CMYK image to an RGB image.",
          "name" : "Building a basic image conversion workflow",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/building-a-basic-image-conversion-workflow"
        },
        {
          "description" : "Create a displayable ARGB image using the luminance and chrominance information from your device’s camera.",
          "name" : "Converting luminance and chrominance planes to an ARGB image",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/converting-luminance-and-chrominance-planes-to-an-argb-image"
        },
        {
          "description" : "Convert an image to a different format.",
          "name" : "Conversion",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/conversion"
        }
      ],
      "title" : "Conversion Between Image Formats"
    }
  ],
  "source" : "appleJSON",
  "title" : "Applying color transforms to images with a multidimensional lookup table",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-color-transforms-to-images-with-a-multidimensional-lookup-table"
}