{
  "abstract" : "Perform floating-point arithmetic, transcendental, and trigonometric functions on 128-bit vectors.",
  "codeExamples" : [

  ],
  "contentHash" : "84fe678f415df3ade5b107ac57a8c11f3498f62f72920589be588e9c9dab8b70",
  "crawledAt" : "2025-12-02T16:36:52Z",
  "id" : "36A786D5-C976-4BA0-90C5-356B699B9EC4",
  "kind" : "collection",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nvfp.h declares a set of floating-point arithmetic, transcendental and trigonometric functions, on 128-bit vectors, using the floating-point types from vecLibTypes.h.\n\nThese functions are named with their customary mathematical names, prefixed with the letter “v”, and all except `vtablelookup()` have the suffix “f” to indicate that they work with single-precision floating-point data. For example, `vcosf` is the single-precision cosine function.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/vfp-library\ncrawled: 2025-12-02T16:36:52Z\n---\n\n# vfp\n\n**API Collection**\n\nPerform floating-point arithmetic, transcendental, and trigonometric functions on 128-bit vectors.\n\n## Overview\n\nvfp.h declares a set of floating-point arithmetic, transcendental and trigonometric functions, on 128-bit vectors, using the floating-point types from vecLibTypes.h.\n\nThese functions are named with their customary mathematical names, prefixed with the letter “v”, and all except `vtablelookup()` have the suffix “f” to indicate that they work with single-precision floating-point data. For example, `vcosf` is the single-precision cosine function.\n\n## Floating-Point Arithmetic and Auxiliary Functions (from vfp.h)\n\n- **vceilf(_:)**: Computes the ceiling of values in a vector of floating-point values.\n- **vcopysignf(_:_:)**: For each vector element, produces a value with the magnitude of `arg2` and sign `arg1`.  Note that the order of the arguments matches the recommendation of the IEEE 754 floating-point standard, which is opposite from the SANE copysign function.\n- **vdivf(_:_:)**: For each vector element, calculates `A`\/`B`.\n- **vfabf(_:)**: For each vector element, calculates the absolute value of `v`.\n- **vfabsf(_:)**\n- **vfloorf(_:)**: Computes the floor of values in a vector of floating-point values.\n- **vintf(_:)**: Truncates the decimal portion of a vector of floating-point values.\n- **vnintf(_:)**: Rounds to the nearest integer (nearest even for ties).\n- **vnextafterf(_:_:)**: For each vector element, calculates the next representable value after `x` in the direction of `y`.  If `x` is equal to `y`, then `y` is returned.\n- **vrecf(_:)**: Computes the reciprocal of values in a vector.\n- **vrsqrtf(_:)**: For each vector element, calculates the inverse of the square root of `X`.\n- **vsqrtf(_:)**: For each vector element, calculates the square root of `X`.\n- **vtablelookup(_:_:)**: For each vector element of `Index_Vect`, returns the corresponding value from `Table`.\n- **vtruncf(_:)**\n\n## Exponential and Logarithmic Functions (from vfp.h)\n\n- **vexpf(_:)**: For each vector element, calculates the exponential of X.\n- **vexp2f(_:)**\n- **vexpm1f(_:)**: For each vector element, calculates ExpM1(x) = Exp(x) - 1.  But, for small enough arguments, ExpM1(x) is expected to be more accurate than Exp(x) - 1.\n- **vlogf(_:)**: For each vector element, calculates the natural logarithm of `X`.\n- **vlog1pf(_:)**: For each vector element, calculates Log1P = Log(1 + x). But, for small enough arguments, Log1P is expected to be more accurate than Log(1 + x).\n- **vlog10f(_:)**: Computes the base-10 logarithm of values in a vector.\n- **vlogbf(_:)**: For each vector element, extracts the exponent of `X`, as a signed integral value. A subnormal argument is treated as though it were first normalized. Thus:   1  <=  x * 2^(-logb(x))  <  2.\n- **vlog2f(_:)**\n- **vvpows(_:_:_:_:)**: Calculates the cube root for each element of a vector.\n- **vvpowsf(_:_:_:_:)**: Calculates, elementwise, x**y for a vector x and a scalar y.\n- **vscalbf(_:_:)**: For each vector element, calculates x * 2^n efficiently.  This is not normally done by computing 2^n explicitly.\n\n## Trigonometric Functions (from vfp.h)\n\n- **vsinf(_:)**: For each vector element, calculates the sine.\n- **vcosf(_:)**: For each vector element, calculates the cosine.\n- **vsincosf(_:_:)**: Simultaneously computes sine and cosine of values in a vector.\n- **vtanf(_:)**: For each vector element, calculates the tangent.\n- **vasinf(_:)**: For each vector element, calculates the arcsine.  Results are in the interval [-pi\/2, pi\/2].\n- **vacosf(_:)**: For each vector element, calculates the arccosine.  Results are in the interval [0, pi].\n- **vatanf(_:)**: For each vector element, calculates the arctangent.  Results are in the interval [-pi\/2, pi\/2].\n- **vatan2f(_:_:)**: For each vector element, calculates the arctangent of `arg2`\/`arg1` in the interval [-pi,pi] using the sign of both arguments to determine the quadrant of the computed value.\n- **vvcbrt(_:_:_:)**: Calculates the cube root for each element of a vector.\n- **vvcbrtf(_:_:_:)**: Calculates the cube root for each element of a vector.\n\n## Hyperbolic Functions (from vfp.h)\n\n- **vsinhf(_:)**: For each vector element, calculates the hyperbolic sine of `X`.\n- **vcoshf(_:)**: For each vector element, calculates the hyperbolic cosine of `X`.\n- **vtanhf(_:)**: For each vector element, calculates the hyperbolic tangent of `X`.\n- **vasinhf(_:)**: For each vector element, calculates the inverse hyperbolic sine of `X`.\n- **vacoshf(_:)**: For each vector element, calculates the inverse hyperbolic cosine of `X`.\n- **vatanhf(_:)**: For each vector element, calculates the inverse hyperbolic tangent of `X`.\n\n## Power Functions (from vfp.h)\n\n- **vipowf(_:_:)**: For each vector element, calculates `X` to the integer power of `Y`.\n- **vpowf(_:_:)**: For each vector element, calculates `X` to the floating-point power of `Y`. The result is more accurate than using exp(log(`X`)*`Y`).\n\n## Remainder Functions (from vfp.h)\n\n- **vfmodf(_:_:)**: For each vector element, calculates `X` modulo `Y`.\n- **vremainderf(_:_:)**: For each vector element, calculates the remainder of `X`\/`Y`, according to the IEEE 754 floating-point standard.\n- **vremquof(_:_:_:)**: For each vector element, calculates the remainder of `X`\/`Y`, according to the SANE standard. It stores into `QUO` the 7 low-order bits of the integer quotient, such that -127 <= `QUO` <= 127.\n\n## Inquiry Functions (from vfp.h)\n\n- **vclassifyf(_:)**: For each vector element, returns the class of the argument (one of the FP_ … constants defined in math.h).\n- **vsignbitf(_:)**: For each vector element, returns a non-zero value if and only if the sign of `arg` is negative. This includes NaNs, infinities and zeros.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Computes the ceiling of values in a vector of floating-point values.",
          "name" : "vceilf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vceilf(_:)"
        },
        {
          "description" : "For each vector element, produces a value with the magnitude of `arg2` and sign `arg1`.  Note that the order of the arguments matches the recommendation of the IEEE 754 floating-point standard, which is opposite from the SANE copysign function.",
          "name" : "vcopysignf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vcopysignf(_:_:)"
        },
        {
          "description" : "For each vector element, calculates `A`\/`B`.",
          "name" : "vdivf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vdivf(_:_:)"
        },
        {
          "description" : "For each vector element, calculates the absolute value of `v`.",
          "name" : "vfabf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vfabf(_:)"
        },
        {
          "description" : "",
          "name" : "vfabsf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vfabsf(_:)"
        },
        {
          "description" : "Computes the floor of values in a vector of floating-point values.",
          "name" : "vfloorf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vfloorf(_:)"
        },
        {
          "description" : "Truncates the decimal portion of a vector of floating-point values.",
          "name" : "vintf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vintf(_:)"
        },
        {
          "description" : "Rounds to the nearest integer (nearest even for ties).",
          "name" : "vnintf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vnintf(_:)"
        },
        {
          "description" : "For each vector element, calculates the next representable value after `x` in the direction of `y`.  If `x` is equal to `y`, then `y` is returned.",
          "name" : "vnextafterf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vnextafterf(_:_:)"
        },
        {
          "description" : "Computes the reciprocal of values in a vector.",
          "name" : "vrecf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vrecf(_:)"
        },
        {
          "description" : "For each vector element, calculates the inverse of the square root of `X`.",
          "name" : "vrsqrtf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vrsqrtf(_:)"
        },
        {
          "description" : "For each vector element, calculates the square root of `X`.",
          "name" : "vsqrtf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vsqrtf(_:)"
        },
        {
          "description" : "For each vector element of `Index_Vect`, returns the corresponding value from `Table`.",
          "name" : "vtablelookup(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vtablelookup(_:_:)"
        },
        {
          "description" : "",
          "name" : "vtruncf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vtruncf(_:)"
        }
      ],
      "title" : "Floating-Point Arithmetic and Auxiliary Functions (from vfp.h)"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "For each vector element, calculates the exponential of X.",
          "name" : "vexpf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vexpf(_:)"
        },
        {
          "description" : "",
          "name" : "vexp2f(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vexp2f(_:)"
        },
        {
          "description" : "For each vector element, calculates ExpM1(x) = Exp(x) - 1.  But, for small enough arguments, ExpM1(x) is expected to be more accurate than Exp(x) - 1.",
          "name" : "vexpm1f(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vexpm1f(_:)"
        },
        {
          "description" : "For each vector element, calculates the natural logarithm of `X`.",
          "name" : "vlogf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vlogf(_:)"
        },
        {
          "description" : "For each vector element, calculates Log1P = Log(1 + x). But, for small enough arguments, Log1P is expected to be more accurate than Log(1 + x).",
          "name" : "vlog1pf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vlog1pf(_:)"
        },
        {
          "description" : "Computes the base-10 logarithm of values in a vector.",
          "name" : "vlog10f(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vlog10f(_:)"
        },
        {
          "description" : "For each vector element, extracts the exponent of `X`, as a signed integral value. A subnormal argument is treated as though it were first normalized. Thus:   1  <=  x * 2^(-logb(x))  <  2.",
          "name" : "vlogbf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vlogbf(_:)"
        },
        {
          "description" : "",
          "name" : "vlog2f(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vlog2f(_:)"
        },
        {
          "description" : "Calculates the cube root for each element of a vector.",
          "name" : "vvpows(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vvpows(_:_:_:_:)"
        },
        {
          "description" : "Calculates, elementwise, x**y for a vector x and a scalar y.",
          "name" : "vvpowsf(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vvpowsf(_:_:_:_:)"
        },
        {
          "description" : "For each vector element, calculates x * 2^n efficiently.  This is not normally done by computing 2^n explicitly.",
          "name" : "vscalbf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vscalbf(_:_:)"
        }
      ],
      "title" : "Exponential and Logarithmic Functions (from vfp.h)"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "For each vector element, calculates the sine.",
          "name" : "vsinf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vsinf(_:)"
        },
        {
          "description" : "For each vector element, calculates the cosine.",
          "name" : "vcosf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vcosf(_:)"
        },
        {
          "description" : "Simultaneously computes sine and cosine of values in a vector.",
          "name" : "vsincosf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vsincosf(_:_:)"
        },
        {
          "description" : "For each vector element, calculates the tangent.",
          "name" : "vtanf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vtanf(_:)"
        },
        {
          "description" : "For each vector element, calculates the arcsine.  Results are in the interval [-pi\/2, pi\/2].",
          "name" : "vasinf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vasinf(_:)"
        },
        {
          "description" : "For each vector element, calculates the arccosine.  Results are in the interval [0, pi].",
          "name" : "vacosf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vacosf(_:)"
        },
        {
          "description" : "For each vector element, calculates the arctangent.  Results are in the interval [-pi\/2, pi\/2].",
          "name" : "vatanf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vatanf(_:)"
        },
        {
          "description" : "For each vector element, calculates the arctangent of `arg2`\/`arg1` in the interval [-pi,pi] using the sign of both arguments to determine the quadrant of the computed value.",
          "name" : "vatan2f(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vatan2f(_:_:)"
        },
        {
          "description" : "Calculates the cube root for each element of a vector.",
          "name" : "vvcbrt(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vvcbrt(_:_:_:)"
        },
        {
          "description" : "Calculates the cube root for each element of a vector.",
          "name" : "vvcbrtf(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vvcbrtf(_:_:_:)"
        }
      ],
      "title" : "Trigonometric Functions (from vfp.h)"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "For each vector element, calculates the hyperbolic sine of `X`.",
          "name" : "vsinhf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vsinhf(_:)"
        },
        {
          "description" : "For each vector element, calculates the hyperbolic cosine of `X`.",
          "name" : "vcoshf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vcoshf(_:)"
        },
        {
          "description" : "For each vector element, calculates the hyperbolic tangent of `X`.",
          "name" : "vtanhf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vtanhf(_:)"
        },
        {
          "description" : "For each vector element, calculates the inverse hyperbolic sine of `X`.",
          "name" : "vasinhf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vasinhf(_:)"
        },
        {
          "description" : "For each vector element, calculates the inverse hyperbolic cosine of `X`.",
          "name" : "vacoshf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vacoshf(_:)"
        },
        {
          "description" : "For each vector element, calculates the inverse hyperbolic tangent of `X`.",
          "name" : "vatanhf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vatanhf(_:)"
        }
      ],
      "title" : "Hyperbolic Functions (from vfp.h)"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "For each vector element, calculates `X` to the integer power of `Y`.",
          "name" : "vipowf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vipowf(_:_:)"
        },
        {
          "description" : "For each vector element, calculates `X` to the floating-point power of `Y`. The result is more accurate than using exp(log(`X`)*`Y`).",
          "name" : "vpowf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vpowf(_:_:)"
        }
      ],
      "title" : "Power Functions (from vfp.h)"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "For each vector element, calculates `X` modulo `Y`.",
          "name" : "vfmodf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vfmodf(_:_:)"
        },
        {
          "description" : "For each vector element, calculates the remainder of `X`\/`Y`, according to the IEEE 754 floating-point standard.",
          "name" : "vremainderf(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vremainderf(_:_:)"
        },
        {
          "description" : "For each vector element, calculates the remainder of `X`\/`Y`, according to the SANE standard. It stores into `QUO` the 7 low-order bits of the integer quotient, such that -127 <= `QUO` <= 127.",
          "name" : "vremquof(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vremquof(_:_:_:)"
        }
      ],
      "title" : "Remainder Functions (from vfp.h)"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "For each vector element, returns the class of the argument (one of the FP_ … constants defined in math.h).",
          "name" : "vclassifyf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vclassifyf(_:)"
        },
        {
          "description" : "For each vector element, returns a non-zero value if and only if the sign of `arg` is negative. This includes NaNs, infinities and zeros.",
          "name" : "vsignbitf(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vsignbitf(_:)"
        }
      ],
      "title" : "Inquiry Functions (from vfp.h)"
    }
  ],
  "source" : "appleJSON",
  "title" : "vfp",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vfp-library"
}