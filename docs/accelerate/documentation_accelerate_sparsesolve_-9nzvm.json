{
  "abstract" : "Solves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and preconditioner type.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Float] =       [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\ndefer {\n    SparseCleanup(A)\n}\n\n\/\/\/ Create the right-hand-side vector, _b_.\nvar bValues: [Float] = [30, 35, 100]\nvar xValues = [Float](repeating: .nan, count: bValues.count)\n\nbValues.withUnsafeMutableBufferPointer { bPtr in\n    xValues.withUnsafeMutableBufferPointer { xPtr in\n        \n        let b = DenseVector_Float(count: 3,\n                                  data: bPtr.baseAddress!)\n        \n        let x = DenseVector_Float(count: 3,\n                                  data: xPtr.baseAddress!)\n        \n        SparseSolve(SparseLSMR(),\n                    A, b, x,\n                    SparsePreconditionerDiagScaling)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "6d86a282eb4a9f9a4a48e1825a147386120fc4d9945623fdfffdd47b2d686ac7",
  "crawledAt" : "2025-12-01T03:59:27Z",
  "declaration" : {
    "code" : "func SparseSolve(_ method: SparseIterativeMethod, _ A: SparseMatrix_Float, _ b: DenseVector_Float, _ x: DenseVector_Float, _ Preconditioner: SparsePreconditioner_t) -> SparseIterativeStatus_t",
    "language" : "swift"
  },
  "id" : "5C09C595-4607-46C3-9080-EF84EC8A5C20",
  "kind" : "function",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. Preconditioning the coefficient matrix can reduce the number of iterations the function requires to converge the system.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system by applying a diagonal scaling preconditioner and using the least squares minimum residual method:\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-9nzvm\ncrawled: 2025-12-01T03:59:27Z\n---\n\n# SparseSolve(_:_:_:_:_:)\n\n**Function**\n\nSolves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and preconditioner type.\n\n## Declaration\n\n```swift\nfunc SparseSolve(_ method: SparseIterativeMethod, _ A: SparseMatrix_Float, _ b: DenseVector_Float, _ x: DenseVector_Float, _ Preconditioner: SparsePreconditioner_t) -> SparseIterativeStatus_t\n```\n\n## Parameters\n\n- **method**: The iterative method.\n- **A**: The matrix *A*.\n- **b**: The vector *b*.\n- **x**: The vector *x*.\n- **Preconditioner**: The preconditioner to apply.\n\n## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. Preconditioning the coefficient matrix can reduce the number of iterations the function requires to converge the system.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system by applying a diagonal scaling preconditioner and using the least squares minimum residual method:\n\n```swift\n\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Float] =       [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\ndefer {\n    SparseCleanup(A)\n}\n\n\/\/\/ Create the right-hand-side vector, _b_.\nvar bValues: [Float] = [30, 35, 100]\nvar xValues = [Float](repeating: .nan, count: bValues.count)\n\nbValues.withUnsafeMutableBufferPointer { bPtr in\n    xValues.withUnsafeMutableBufferPointer { xPtr in\n        \n        let b = DenseVector_Float(count: 3,\n                                  data: bPtr.baseAddress!)\n        \n        let x = DenseVector_Float(count: 3,\n                                  data: xPtr.baseAddress!)\n        \n        SparseSolve(SparseLSMR(),\n                    A, b, x,\n                    SparsePreconditionerDiagScaling)\n    }\n}\n```\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0]`.\n\n## Iterative sparse solve functions with preconditioner\n\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and opaque preconditioner.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and opaque preconditioner.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and preconditioner type.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of double-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of single-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and opaque preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-1qwax"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and opaque preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-3aphv"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and preconditioner type.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-5vs11"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of double-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-6i1nx"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of single-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-7wnum"
        }
      ],
      "title" : "Iterative sparse solve functions with preconditioner"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseSolve(_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-9nzvm"
}