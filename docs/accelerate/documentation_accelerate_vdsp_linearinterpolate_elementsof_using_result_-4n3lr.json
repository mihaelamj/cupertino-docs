{
  "abstract" : "Calculates the interpolation between the neighboring elements of a double-precision vector.",
  "codeExamples" : [
    {
      "code" : "let result = vDSP.linearInterpolate(elementsOf: [100, 200, 300],\n                                    using: [0, 0.5, 1, 1.5, 2])",
      "language" : "swift"
    },
    {
      "code" : "let values: [Float] = [50, 90, 55, 10, 40, 85, 65, 15, 30, 80]\nlet controlVector: [Float] = vDSP.ramp(in: 0 ... Float(values.count) - 1,\n                                       count: 1024)\n\nlet result = vDSP.linearInterpolate(elementsOf: values,\n                                    using: controlVector)",
      "language" : "swift"
    },
    {
      "code" : "let values: [Float] = [50, 90, 55, 10, 40, 85, 65, 15, 30, 80]\n\nlet denominator = 1024 \/ Float(values.count - 1)\nlet tau = Float.pi * 2\nlet controlVector: [Float] = (0 ..< 1024).map {\n    let x = modf(Float($0) \/ denominator)\n    \n    return x.0 + (tanh((x.1 - 0.5) * tau) * 0.5) + 0.5\n}\n\nlet result = vDSP.linearInterpolate(elementsOf: values,\n                                    using: controlVector)",
      "language" : "swift"
    }
  ],
  "contentHash" : "033922ae4b0cf89649297dc8cd81acf89d2003cb26c47872e31e9591b4966ca1",
  "crawledAt" : "2025-12-01T03:15:38Z",
  "declaration" : {
    "code" : "static func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : AccelerateBuffer, U : AccelerateBuffer, V : AccelerateMutableBuffer, T.Element == Double, U.Element == Double, V.Element == Double",
    "language" : "swift"
  },
  "id" : "3E114AD7-1112-4E76-93B1-8E3A971D4ACD",
  "kind" : "method",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nSingle-precision and double-precision [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:result:)-4n3lr] functions calculate an array of an arbitrary length that’s constructed from the linearly interpolated values in a source array. Pass [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:result:)-4n3lr] a control vector that defines the interpolation: the integer part of each element in the control vector is the zero-based index of the first element of a pair of adjacent values in the source array, and the fractional part defines the linear interpolation between the values at those indices.\n\nFor example, the following code generates a five-element vector by interpolating three values:\n\nOn return, `result` contains `[100.0, 150.0, 200.0, 250.0, 300.0]`.\n\nTo compute longer interpolation results, use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-79aw7] to generate the control vector. The following code creates 1024 interpolated values from 10 source values:\n\nThe following figure visualizes the elements in `result`.\n\n\n\nBy changing the technique used to form the fractional parts of the control vector, you change the interpolation between the values in the source vector. The following code uses a sigmoid function—that is, a function that has an “S” shaped curve—to populate the control vector:\n\nThe following figure visualizes the elements in `result` using hyperbolic tangent for the sigmoid function.\n\n",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:result:)-4n3lr\ncrawled: 2025-12-01T03:15:38Z\n---\n\n# linearInterpolate(elementsOf:using:result:)\n\n**Type Method**\n\nCalculates the interpolation between the neighboring elements of a double-precision vector.\n\n## Declaration\n\n```swift\nstatic func linearInterpolate<T, U, V>(elementsOf vector: T, using controlVector: U, result: inout V) where T : AccelerateBuffer, U : AccelerateBuffer, V : AccelerateMutableBuffer, T.Element == Double, U.Element == Double, V.Element == Double\n```\n\n## Parameters\n\n- **vector**: An array that contains the values to interpolate.\n- **controlVector**: An array that defines the interpolation: integer parts are indices into `vector` and fractional parts are interpolation constants.\n- **result**: An array that receives the result of the calculation.\n\n## Discussion\n\nSingle-precision and double-precision [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:result:)-4n3lr] functions calculate an array of an arbitrary length that’s constructed from the linearly interpolated values in a source array. Pass [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:result:)-4n3lr] a control vector that defines the interpolation: the integer part of each element in the control vector is the zero-based index of the first element of a pair of adjacent values in the source array, and the fractional part defines the linear interpolation between the values at those indices.\n\nFor example, the following code generates a five-element vector by interpolating three values:\n\n```swift\nlet result = vDSP.linearInterpolate(elementsOf: [100, 200, 300],\n                                    using: [0, 0.5, 1, 1.5, 2])\n```\n\nOn return, `result` contains `[100.0, 150.0, 200.0, 250.0, 300.0]`.\n\nTo compute longer interpolation results, use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-79aw7] to generate the control vector. The following code creates 1024 interpolated values from 10 source values:\n\n```swift\nlet values: [Float] = [50, 90, 55, 10, 40, 85, 65, 15, 30, 80]\nlet controlVector: [Float] = vDSP.ramp(in: 0 ... Float(values.count) - 1,\n                                       count: 1024)\n\nlet result = vDSP.linearInterpolate(elementsOf: values,\n                                    using: controlVector)\n```\n\nThe following figure visualizes the elements in `result`.\n\n\n\nBy changing the technique used to form the fractional parts of the control vector, you change the interpolation between the values in the source vector. The following code uses a sigmoid function—that is, a function that has an “S” shaped curve—to populate the control vector:\n\n```swift\nlet values: [Float] = [50, 90, 55, 10, 40, 85, 65, 15, 30, 80]\n\nlet denominator = 1024 \/ Float(values.count - 1)\nlet tau = Float.pi * 2\nlet controlVector: [Float] = (0 ..< 1024).map {\n    let x = modf(Float($0) \/ denominator)\n    \n    return x.0 + (tanh((x.1 - 0.5) * tau) * 0.5) + 0.5\n}\n\nlet result = vDSP.linearInterpolate(elementsOf: values,\n                                    using: controlVector)\n```\n\nThe following figure visualizes the elements in `result` using hyperbolic tangent for the sigmoid function.\n\n\n\n## Single-Vector Linear Interpolation\n\n- **Using linear interpolation to construct new data points**: Fill the gaps in arrays of numerical data using linear interpolation.\n- **linearInterpolate(elementsOf:using:)**: Returns the interpolation between the neighboring elements of a double-precision vector.\n- **linearInterpolate(elementsOf:using:)**: Returns the interpolation between the neighboring elements of a single-precision vector.\n- **linearInterpolate(elementsOf:using:result:)**: Calculates the interpolation between the neighboring elements of a single-precision vector.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Fill the gaps in arrays of numerical data using linear interpolation.",
          "name" : "Using linear interpolation to construct new data points",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-linear-interpolation-to-construct-new-data-points"
        },
        {
          "description" : "Returns the interpolation between the neighboring elements of a double-precision vector.",
          "name" : "linearInterpolate(elementsOf:using:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-5i3jc"
        },
        {
          "description" : "Returns the interpolation between the neighboring elements of a single-precision vector.",
          "name" : "linearInterpolate(elementsOf:using:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:)-49r3c"
        },
        {
          "description" : "Calculates the interpolation between the neighboring elements of a single-precision vector.",
          "name" : "linearInterpolate(elementsOf:using:result:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:result:)-9y61c"
        }
      ],
      "title" : "Single-Vector Linear Interpolation"
    }
  ],
  "source" : "appleJSON",
  "title" : "linearInterpolate(elementsOf:using:result:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP\/linearInterpolate(elementsOf:using:result:)-4n3lr"
}