{
  "abstract" : "Reflect, shear, rotate, and scale image buffers using vImage.",
  "codeExamples" : [
    {
      "code" : "static func verticalReflectBuffer(source: vImage_Buffer,\n                                  destination: inout vImage_Buffer) {\n    \n    precondition(source.size == destination.size,\n                 \"Source and destination buffers need to have the same size.\")\n    \n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageVerticalReflect_ARGB8888(srcPointer,\n                                       &destination,\n                                       vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "static func verticalShearBuffer(source: vImage_Buffer,\n                                destination: inout vImage_Buffer,\n                                byAngleInDegrees angleInDegrees: Double,\n                                verticalScale: Float = 1,\n                                backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    \/\/ 1. Ensure the shear angle is valid.\n    precondition(angleInDegrees > -90 && angleInDegrees < 90,\n                 \"The shear angle needs to be greater than -90º and less than 90º.\")\n    \n    \/\/ 2. Calculate `shearSlope` as the tangent of the specified angle.\n    let angle = Measurement(value: angleInDegrees,\n                            unit: UnitAngle.degrees)\n    let radians = Float(angle.converted(to: .radians).value)\n    let shearSlope = tan(radians)\n\n    \/\/ 3. Create a default resampling filter using the specified scale.\n    let resamplingFilter = vImageNewResamplingFilter(verticalScale,\n                                                     vImage_Flags(kvImageNoFlags))\n    defer {\n        vImageDestroyResamplingFilter(resamplingFilter)\n    }\n    \n    \/\/ 4. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageVerticalShear_ARGB8888(srcPointer,\n                                     &destination,\n                                     0, 0,\n                                     0,\n                                     shearSlope,\n                                     resamplingFilter,\n                                     backgroundColor,\n                                     vImage_Flags(kvImageBackgroundColorFill))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let shearAngle = atan(Double(sourceImageBuffer.height) \/\n                      Double(sourceImageBuffer.width * 2)) *\n                      180 \/ .pi\n\nverticalShearBuffer(source: sourceImageBuffer,\n                    destination: &destinationImageBuffer,\n                    byAngleInDegrees: shearAngle,\n                    verticalScale: 0.5)",
      "language" : "swift"
    },
    {
      "code" : "static func rotateNinety(source: vImage_Buffer,\n                         rotation: Int) -> vImage_Buffer? {\n\n    \/\/ 1. Create the destination buffer.\n    guard var destination: vImage_Buffer = {\n        switch rotation {\n            case kRotate0DegreesClockwise, kRotate180DegreesClockwise:\n                return try? vImage_Buffer(size: source.size,\n                                          bitsPerPixel: 8 * 4)\n            case kRotate90DegreesClockwise, kRotate270DegreesClockwise:\n                return try? vImage_Buffer(width: Int(source.size.height),\n                                          height: Int(source.size.width),\n                                          bitsPerPixel: 8 * 4)\n            default:\n                NSLog(\"Unsupported rotation constant: \\(rotation).\")\n                return nil\n        }\n    }() else {\n        NSLog(\"Unable to initialize destination buffer.\")\n        return nil\n    }\n    \n    \/\/ 2. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { sourcePtr in\n        vImageRotate90_ARGB8888(sourcePtr,\n                                &destination,\n                                UInt8(rotation),\n                                [0],\n                                vImage_Flags(kvImageNoFlags))\n    }\n    \n    return destination\n}",
      "language" : "swift"
    },
    {
      "code" : "static func rotateBuffer(source: vImage_Buffer,\n                         destination: inout vImage_Buffer,\n                         byAngleInDegrees angleInDegrees: Double,\n                         backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    let angle = Measurement(value: angleInDegrees,\n                            unit: UnitAngle.degrees)\n    let radians = Float(angle.converted(to: .radians).value)\n    \n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageRotate_ARGB8888(srcPointer,\n                              &destination,\n                              nil,\n                              radians,\n                              backgroundColor,\n                              vImage_Flags(kvImageBackgroundColorFill))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "static func scaleBuffer(source: vImage_Buffer,\n                        destination: inout vImage_Buffer) {\n    \n    _ = withUnsafePointer(to: source) { sourcePointer in\n        vImageScale_ARGB8888(sourcePointer,\n                             &destination,\n                             nil,\n                             vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "static func scaleAndCenterBuffer(source: vImage_Buffer,\n                                 destination: inout vImage_Buffer,\n                                 to scale: Double,\n                                 backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    \/\/ 1. Calculate the translate required to center the scaled buffer.\n    let sourceCenter = SIMD2<Double>(\n        x: Double(source.size.width \/ 2),\n        y: Double(source.size.height \/ 2))\n    \n    let desinationCenter = SIMD2<Double>(\n        x: Double(destination.size.width \/ 2),\n        y: Double(destination.size.height \/ 2))\n    \n    let tx = desinationCenter.x - sourceCenter.x * scale\n    let ty = desinationCenter.y - sourceCenter.y * scale\n    \n    \/\/ 2. Create the affine transformation that represents the scale-translate.\n    var vImageTransform = vImage_CGAffineTransform(\n        a: scale, b: 0,\n        c: 0,     d: scale,\n        tx: tx,   ty: ty)\n\n    \/\/ 3. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageAffineWarpCG_ARGB8888(srcPointer,\n                                    &destination,\n                                    nil,\n                                    &vImageTransform,\n                                    backgroundColor,\n                                    vImage_Flags(kvImageBackgroundColorFill))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "static func rotateAndScaleBuffer(source: vImage_Buffer,\n                                 destination: inout vImage_Buffer,\n                                 byAngleInDegrees angleInDegrees: Double,\n                                 backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    \/\/ 1. Convert the specified angle in degrees to radians.\n    let angle = Measurement(value: angleInDegrees,\n                            unit: UnitAngle.degrees)\n    let radians = CGFloat(angle.converted(to: .radians).value)\n    \n    \/\/ 2. Calculate the scale based on the bounding box of the rotated image.\n    let rotatedBoundingBox = CGRect(origin: .zero, size: source.size)\n        .applying(CGAffineTransform(rotationAngle: radians))\n    let scale = min(destination.size.width \/ rotatedBoundingBox.size.width,\n                    destination.size.height \/ rotatedBoundingBox.size.height)\n    \n    \/\/ 3. Create the composite affine transformation.\n    let cgTransform = CGAffineTransform.identity\n        .translatedBy(x: destination.size.width \/ 2,\n                      y: destination.size.height \/ 2)\n        .rotated(by: radians)\n        .scaledBy(x: scale, y: scale)\n        .translatedBy(x: -source.size.width \/ 2,\n                      y: -source.size.height \/ 2)\n    \n    \/\/ 4. Convert the `CGAffineTransform` to a `vImage_CGAffineTransform`.\n    var vImageTransform = vImage_CGAffineTransform(\n        a: Double(cgTransform.a),\n        b: Double(cgTransform.b),\n        c: Double(cgTransform.c),\n        d: Double(cgTransform.d),\n        tx: Double(cgTransform.tx),\n        ty: Double(cgTransform.ty))\n    \n    \/\/ 5. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageAffineWarpCG_ARGB8888(srcPointer,\n                                    &destination,\n                                    nil,\n                                    &vImageTransform,\n                                    backgroundColor,\n                                    vImage_Flags(kvImageBackgroundColorFill))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "static func scaleBuffer(source: vImage_Buffer,\n                        destination: inout vImage_Buffer) {\n    \n    _ = withUnsafePointer(to: source) { sourcePointer in\n        vImageScale_ARGB8888(sourcePointer,\n                             &destination,\n                             nil,\n                             vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "static func scaleBuffer(source: vImage_Buffer,\n                        destination: inout vImage_Buffer) {\n    \n    withUnsafePointer(to: source) { sourcePointer in\n        let bufferSize = vImageScale_ARGB8888(sourcePointer,\n                                              &destination,\n                                              nil,\n                                              vImage_Flags(kvImageGetTempBufferSize))\n        \n        if bufferSize < 0 {\n            fatalError(\"Error calculating buffer size for scale operation (\\(bufferSize)).\")\n        }\n        \n        \/\/ In a real app, you reuse this buffer across multiple calls of `vImageScale_ARGB8888`.\n        let temporaryBuffer = UnsafeMutableRawPointer.allocate(byteCount: bufferSize,\n                                                               alignment: 64)\n        defer {\n            temporaryBuffer.deallocate()\n        }\n        \n        vImageScale_ARGB8888(sourcePointer,\n                             &destination,\n                             temporaryBuffer,\n                             vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "e6a531c54ce316578873c6d24fcb3d9a41c8f699cad71c5cf691ea4a941868e8",
  "crawledAt" : "2025-12-02T15:55:13Z",
  "id" : "3442502E-0EC5-4C73-9882-FD9371F4FD90",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThe vImage library provides a suite of functions to apply different geometric transforms to images. The image below shows examples of reflect, scale, rotate, and composite translate-rotate-scale transforms:\n\n\n\nBy default, vImage uses the Lanczos-3 algorithm when resampling. If you need the higher-quality results of the Lanczos-5 algorithm and don’t mind slightly slower performance, pass the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageHighQualityResampling] flag to the geometric transform operations.\n\nThe vImage geometry operations don’t work in-place, that is, you can’t use the same buffer as the source and destination.\n\nIf you’re applying a geometric transform to an image with premultiplied alpha, you may see artifacts in high-frequency regions of the image. To avoid these artifacts, call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageUnpremultiplyData_ARGB8888(_:_:_:)] to remove the premultiplied alpha value from the image data before the operation. After the operation, call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultiplyData_ARGB8888(_:_:_:)] to premultiply the result.\n\n### Reflect a vImage buffer\n\nThe vImage reflect functions generate either a vertical or a horizontal reflection of the image. The image below shows the original buffer contents and the contents after vertical reflection:\n\n\n\nThe destination buffer you pass to the vImage reflect functions needs to be the same size as the source buffer. The code below uses a precondition to ensure that both buffer sizes match:\n\nTo learn more about reflection functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-reflection].\n\n### Shear a vImage buffer\n\nThe vImage shear functions scale and offset an image in one dimension. These functions accept a resampling filter that you use for fine control over the resampling algorithm. For more information on resampling, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/reducing-artifacts-with-custom-resampling-filters].\n\n\n\nControl the amount of shear by specifying the `shearSlope` parameter. The functions define the shear slope as `deltaᵧ\/deltaₓ` that’s the slope for a linear function `y = slope * x`. The `verticalShearBuffer(source:destination:byAngleInDegrees:verticalScale:backgroundColor:)` function accepts the shear as an angle in degrees and performs the transform.\n\nTo fit the sheared image in a buffer with the same dimensions as the original image, specify a shear angle that’s the arctangent of the image’s height divided by twice its width.\n\nOn return, the destination buffer contains the image below:\n\n\n\nTo learn more about shearing functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-shearing].\n\n### Rotate a vImage buffer by multiples of 90°\n\nThe vImage library provides 90° rotation functions that perform a simple 0°, 90°, 180°, or 270° rotation of an image around its center. The image below shows a buffer’s contents without any rotation, rotated 90° counterclockwise, rotated 180°, and rotated 90° clockwise:\n\n\n\nNote that the 90° and 270° rotations don’t rotate around the true center of the image when the parity (that is, whether an integer is even or odd) of the source width and destination height don’t match. The same is true if the parity of the source height and destination width don’t match.\n\nIf the source and destination buffers are different sizes, the 0° and 180° rotations require that the two heights have the same parity and the two widths have the same parity.\n\nThe 90° rotation function crops source pixels that lie outside the destination buffer and fills destination pixels with the specified background color when source pixels don’t cover them.\n\nThe function below applies a multiple of 90° rotation to a buffer and returns the result in a correctly oriented destination buffer:\n\nTo learn more about rotation functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-rotation].\n\n### Rotate a vImage buffer by an arbitrary angle\n\nThe vImage library provides rotation functions that rotate an image by any angle around its center. The image below shows a buffer rotated 60° counterclockwise:\n\n\n\nThe function below rotates a buffer by the specified angle and writes the result to the destination:\n\n### Scale a vImage buffer\n\nThe vImage library provides functions to scale the contents of an image buffer. The scaling can either be uniform, where the operation preserves the image’s aspect ratio, or nonuniform, where the operation stretches or condenses the image. The image below shows four scaled versions of the same photograph, with the second and third image scaled nonuniformly:\n\n\n\nThe vImage scale functions accept source and destination buffers as parameters and rescale the source to fill the destination buffer. The function below wraps [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageScale_ARGB8888(_:_:_:_:)] to provide a simple interface to the scale operation:\n\nTo learn more about scaling functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-scaling].\n\n### Apply a simple affine transformation to a vImage buffer\n\nUse an affine transformation to apply composite transformation, such as a scale and a translate.\n\nA 3-by-3 matrix represents an affine transformation.\n\n\n\nBecause the third column is always `(0,0,1)`, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGAffineTransform] data structure contains values for only the first two columns.\n\nTo perform a scale transformation, set the *a* and *d* parameters of the matrix to the required scale.\n\n\n\nTo perform the translate transformation, set the *tx* and *ty* parameters of the matrix to the required offset.\n\n\n\nThe `scaleAndCenterBuffer(source:destination:to:backgroundColor:)` function accepts a scale parameter and sets that parameter as the *a* and *d* parameters of the matrix.\n\nThe image below shows the result of applying `scaleAndCenterBuffer(_:to:backgroundColor:)` with a scale of `0.25`:\n\n\n\nTo learn more about affine transformation functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-affine-transformations-to-images].\n\n### Apply a complex affine transformation to a vImage buffer\n\nFor complex transformations, [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CGAffineTransform] allows you to concatenate a series of transformations. For example, to rotate and scale an image to fit within its unrotated bounding box, your code needs to translate, rotate, scale, and translate again.\n\nThe `rotateAndScaleBuffer(source:destination:byAngleInDegrees:backgroundColor:)` function uses [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CGAffineTransform] to build the matrix required to rotate and scale an image to fit inside the bounding box of the destination buffer.\n\nThe image below shows the result of applying `rotateAndScaleBuffer(_:byAngleInDegrees:backgroundColor:)` with an angle of 30°:\n\n\n\n### Optimize performance with temporary buffers\n\nThe vImage rotate, scale, and affine transform functions use multiple-pass algorithms that save intermediate pixel values between passes. In some cases, the destination buffer may not be large enough to store that intermediate data, so the operation requires additional, temporary storage.\n\nPass `nil` to the function to have vImage create and manage this temporary storage for you. For example, the scale function below relies on the operation to manage the temporary buffer:\n\nIn cases where your code calls the function frequently (for example, when processing video), create and manage this temporary buffer yourself and reuse it across function calls. Reusing a buffer avoids vImage allocating the temporary storage with each call. Pass [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageGetTempBufferSize] to your geometry function to calculate the size, in bytes, of the temporary buffer, and use that value to allocate an [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafeMutableRawPointer] structure.\n\nThe version of the `scaleBuffer()` function below shows an example of creating a temporary buffer:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-geometric-transforms-to-images\ncrawled: 2025-12-02T15:55:13Z\n---\n\n# Applying geometric transforms to images\n\n**Article**\n\nReflect, shear, rotate, and scale image buffers using vImage.\n\n## Overview\n\nThe vImage library provides a suite of functions to apply different geometric transforms to images. The image below shows examples of reflect, scale, rotate, and composite translate-rotate-scale transforms:\n\n\n\nBy default, vImage uses the Lanczos-3 algorithm when resampling. If you need the higher-quality results of the Lanczos-5 algorithm and don’t mind slightly slower performance, pass the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageHighQualityResampling] flag to the geometric transform operations.\n\nThe vImage geometry operations don’t work in-place, that is, you can’t use the same buffer as the source and destination.\n\nIf you’re applying a geometric transform to an image with premultiplied alpha, you may see artifacts in high-frequency regions of the image. To avoid these artifacts, call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageUnpremultiplyData_ARGB8888(_:_:_:)] to remove the premultiplied alpha value from the image data before the operation. After the operation, call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultiplyData_ARGB8888(_:_:_:)] to premultiply the result.\n\n### Reflect a vImage buffer\n\nThe vImage reflect functions generate either a vertical or a horizontal reflection of the image. The image below shows the original buffer contents and the contents after vertical reflection:\n\n\n\nThe destination buffer you pass to the vImage reflect functions needs to be the same size as the source buffer. The code below uses a precondition to ensure that both buffer sizes match:\n\n```swift\nstatic func verticalReflectBuffer(source: vImage_Buffer,\n                                  destination: inout vImage_Buffer) {\n    \n    precondition(source.size == destination.size,\n                 \"Source and destination buffers need to have the same size.\")\n    \n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageVerticalReflect_ARGB8888(srcPointer,\n                                       &destination,\n                                       vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\nTo learn more about reflection functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-reflection].\n\n### Shear a vImage buffer\n\nThe vImage shear functions scale and offset an image in one dimension. These functions accept a resampling filter that you use for fine control over the resampling algorithm. For more information on resampling, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/reducing-artifacts-with-custom-resampling-filters].\n\n\n\nControl the amount of shear by specifying the `shearSlope` parameter. The functions define the shear slope as `deltaᵧ\/deltaₓ` that’s the slope for a linear function `y = slope * x`. The `verticalShearBuffer(source:destination:byAngleInDegrees:verticalScale:backgroundColor:)` function accepts the shear as an angle in degrees and performs the transform.\n\n```swift\nstatic func verticalShearBuffer(source: vImage_Buffer,\n                                destination: inout vImage_Buffer,\n                                byAngleInDegrees angleInDegrees: Double,\n                                verticalScale: Float = 1,\n                                backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    \/\/ 1. Ensure the shear angle is valid.\n    precondition(angleInDegrees > -90 && angleInDegrees < 90,\n                 \"The shear angle needs to be greater than -90º and less than 90º.\")\n    \n    \/\/ 2. Calculate `shearSlope` as the tangent of the specified angle.\n    let angle = Measurement(value: angleInDegrees,\n                            unit: UnitAngle.degrees)\n    let radians = Float(angle.converted(to: .radians).value)\n    let shearSlope = tan(radians)\n\n    \/\/ 3. Create a default resampling filter using the specified scale.\n    let resamplingFilter = vImageNewResamplingFilter(verticalScale,\n                                                     vImage_Flags(kvImageNoFlags))\n    defer {\n        vImageDestroyResamplingFilter(resamplingFilter)\n    }\n    \n    \/\/ 4. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageVerticalShear_ARGB8888(srcPointer,\n                                     &destination,\n                                     0, 0,\n                                     0,\n                                     shearSlope,\n                                     resamplingFilter,\n                                     backgroundColor,\n                                     vImage_Flags(kvImageBackgroundColorFill))\n    }\n}\n```\n\nTo fit the sheared image in a buffer with the same dimensions as the original image, specify a shear angle that’s the arctangent of the image’s height divided by twice its width.\n\n```swift\nlet shearAngle = atan(Double(sourceImageBuffer.height) \/\n                      Double(sourceImageBuffer.width * 2)) *\n                      180 \/ .pi\n\nverticalShearBuffer(source: sourceImageBuffer,\n                    destination: &destinationImageBuffer,\n                    byAngleInDegrees: shearAngle,\n                    verticalScale: 0.5)\n```\n\nOn return, the destination buffer contains the image below:\n\n\n\nTo learn more about shearing functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-shearing].\n\n### Rotate a vImage buffer by multiples of 90°\n\nThe vImage library provides 90° rotation functions that perform a simple 0°, 90°, 180°, or 270° rotation of an image around its center. The image below shows a buffer’s contents without any rotation, rotated 90° counterclockwise, rotated 180°, and rotated 90° clockwise:\n\n\n\nNote that the 90° and 270° rotations don’t rotate around the true center of the image when the parity (that is, whether an integer is even or odd) of the source width and destination height don’t match. The same is true if the parity of the source height and destination width don’t match.\n\nIf the source and destination buffers are different sizes, the 0° and 180° rotations require that the two heights have the same parity and the two widths have the same parity.\n\nThe 90° rotation function crops source pixels that lie outside the destination buffer and fills destination pixels with the specified background color when source pixels don’t cover them.\n\nThe function below applies a multiple of 90° rotation to a buffer and returns the result in a correctly oriented destination buffer:\n\n```swift\nstatic func rotateNinety(source: vImage_Buffer,\n                         rotation: Int) -> vImage_Buffer? {\n\n    \/\/ 1. Create the destination buffer.\n    guard var destination: vImage_Buffer = {\n        switch rotation {\n            case kRotate0DegreesClockwise, kRotate180DegreesClockwise:\n                return try? vImage_Buffer(size: source.size,\n                                          bitsPerPixel: 8 * 4)\n            case kRotate90DegreesClockwise, kRotate270DegreesClockwise:\n                return try? vImage_Buffer(width: Int(source.size.height),\n                                          height: Int(source.size.width),\n                                          bitsPerPixel: 8 * 4)\n            default:\n                NSLog(\"Unsupported rotation constant: \\(rotation).\")\n                return nil\n        }\n    }() else {\n        NSLog(\"Unable to initialize destination buffer.\")\n        return nil\n    }\n    \n    \/\/ 2. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { sourcePtr in\n        vImageRotate90_ARGB8888(sourcePtr,\n                                &destination,\n                                UInt8(rotation),\n                                [0],\n                                vImage_Flags(kvImageNoFlags))\n    }\n    \n    return destination\n}\n```\n\nTo learn more about rotation functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-rotation].\n\n### Rotate a vImage buffer by an arbitrary angle\n\nThe vImage library provides rotation functions that rotate an image by any angle around its center. The image below shows a buffer rotated 60° counterclockwise:\n\n\n\nThe function below rotates a buffer by the specified angle and writes the result to the destination:\n\n```swift\nstatic func rotateBuffer(source: vImage_Buffer,\n                         destination: inout vImage_Buffer,\n                         byAngleInDegrees angleInDegrees: Double,\n                         backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    let angle = Measurement(value: angleInDegrees,\n                            unit: UnitAngle.degrees)\n    let radians = Float(angle.converted(to: .radians).value)\n    \n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageRotate_ARGB8888(srcPointer,\n                              &destination,\n                              nil,\n                              radians,\n                              backgroundColor,\n                              vImage_Flags(kvImageBackgroundColorFill))\n    }\n}\n```\n\n### Scale a vImage buffer\n\nThe vImage library provides functions to scale the contents of an image buffer. The scaling can either be uniform, where the operation preserves the image’s aspect ratio, or nonuniform, where the operation stretches or condenses the image. The image below shows four scaled versions of the same photograph, with the second and third image scaled nonuniformly:\n\n\n\nThe vImage scale functions accept source and destination buffers as parameters and rescale the source to fill the destination buffer. The function below wraps [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageScale_ARGB8888(_:_:_:_:)] to provide a simple interface to the scale operation:\n\n```swift\nstatic func scaleBuffer(source: vImage_Buffer,\n                        destination: inout vImage_Buffer) {\n    \n    _ = withUnsafePointer(to: source) { sourcePointer in\n        vImageScale_ARGB8888(sourcePointer,\n                             &destination,\n                             nil,\n                             vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\nTo learn more about scaling functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/image-scaling].\n\n### Apply a simple affine transformation to a vImage buffer\n\nUse an affine transformation to apply composite transformation, such as a scale and a translate.\n\nA 3-by-3 matrix represents an affine transformation.\n\n\n\nBecause the third column is always `(0,0,1)`, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGAffineTransform] data structure contains values for only the first two columns.\n\nTo perform a scale transformation, set the *a* and *d* parameters of the matrix to the required scale.\n\n\n\nTo perform the translate transformation, set the *tx* and *ty* parameters of the matrix to the required offset.\n\n\n\nThe `scaleAndCenterBuffer(source:destination:to:backgroundColor:)` function accepts a scale parameter and sets that parameter as the *a* and *d* parameters of the matrix.\n\n```swift\nstatic func scaleAndCenterBuffer(source: vImage_Buffer,\n                                 destination: inout vImage_Buffer,\n                                 to scale: Double,\n                                 backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    \/\/ 1. Calculate the translate required to center the scaled buffer.\n    let sourceCenter = SIMD2<Double>(\n        x: Double(source.size.width \/ 2),\n        y: Double(source.size.height \/ 2))\n    \n    let desinationCenter = SIMD2<Double>(\n        x: Double(destination.size.width \/ 2),\n        y: Double(destination.size.height \/ 2))\n    \n    let tx = desinationCenter.x - sourceCenter.x * scale\n    let ty = desinationCenter.y - sourceCenter.y * scale\n    \n    \/\/ 2. Create the affine transformation that represents the scale-translate.\n    var vImageTransform = vImage_CGAffineTransform(\n        a: scale, b: 0,\n        c: 0,     d: scale,\n        tx: tx,   ty: ty)\n\n    \/\/ 3. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageAffineWarpCG_ARGB8888(srcPointer,\n                                    &destination,\n                                    nil,\n                                    &vImageTransform,\n                                    backgroundColor,\n                                    vImage_Flags(kvImageBackgroundColorFill))\n    }\n}\n```\n\nThe image below shows the result of applying `scaleAndCenterBuffer(_:to:backgroundColor:)` with a scale of `0.25`:\n\n\n\nTo learn more about affine transformation functions, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/applying-affine-transformations-to-images].\n\n### Apply a complex affine transformation to a vImage buffer\n\nFor complex transformations, [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CGAffineTransform] allows you to concatenate a series of transformations. For example, to rotate and scale an image to fit within its unrotated bounding box, your code needs to translate, rotate, scale, and translate again.\n\nThe `rotateAndScaleBuffer(source:destination:byAngleInDegrees:backgroundColor:)` function uses [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CGAffineTransform] to build the matrix required to rotate and scale an image to fit inside the bounding box of the destination buffer.\n\n```swift\nstatic func rotateAndScaleBuffer(source: vImage_Buffer,\n                                 destination: inout vImage_Buffer,\n                                 byAngleInDegrees angleInDegrees: Double,\n                                 backgroundColor: [Pixel_8] = [0, 127, 127, 127]) {\n    \n    \/\/ 1. Convert the specified angle in degrees to radians.\n    let angle = Measurement(value: angleInDegrees,\n                            unit: UnitAngle.degrees)\n    let radians = CGFloat(angle.converted(to: .radians).value)\n    \n    \/\/ 2. Calculate the scale based on the bounding box of the rotated image.\n    let rotatedBoundingBox = CGRect(origin: .zero, size: source.size)\n        .applying(CGAffineTransform(rotationAngle: radians))\n    let scale = min(destination.size.width \/ rotatedBoundingBox.size.width,\n                    destination.size.height \/ rotatedBoundingBox.size.height)\n    \n    \/\/ 3. Create the composite affine transformation.\n    let cgTransform = CGAffineTransform.identity\n        .translatedBy(x: destination.size.width \/ 2,\n                      y: destination.size.height \/ 2)\n        .rotated(by: radians)\n        .scaledBy(x: scale, y: scale)\n        .translatedBy(x: -source.size.width \/ 2,\n                      y: -source.size.height \/ 2)\n    \n    \/\/ 4. Convert the `CGAffineTransform` to a `vImage_CGAffineTransform`.\n    var vImageTransform = vImage_CGAffineTransform(\n        a: Double(cgTransform.a),\n        b: Double(cgTransform.b),\n        c: Double(cgTransform.c),\n        d: Double(cgTransform.d),\n        tx: Double(cgTransform.tx),\n        ty: Double(cgTransform.ty))\n    \n    \/\/ 5. Apply the transform to `source` and write the result to `destination`.\n    _ = withUnsafePointer(to: source) { srcPointer in\n        vImageAffineWarpCG_ARGB8888(srcPointer,\n                                    &destination,\n                                    nil,\n                                    &vImageTransform,\n                                    backgroundColor,\n                                    vImage_Flags(kvImageBackgroundColorFill))\n    }\n}\n```\n\nThe image below shows the result of applying `rotateAndScaleBuffer(_:byAngleInDegrees:backgroundColor:)` with an angle of 30°:\n\n\n\n### Optimize performance with temporary buffers\n\nThe vImage rotate, scale, and affine transform functions use multiple-pass algorithms that save intermediate pixel values between passes. In some cases, the destination buffer may not be large enough to store that intermediate data, so the operation requires additional, temporary storage.\n\nPass `nil` to the function to have vImage create and manage this temporary storage for you. For example, the scale function below relies on the operation to manage the temporary buffer:\n\n```swift\nstatic func scaleBuffer(source: vImage_Buffer,\n                        destination: inout vImage_Buffer) {\n    \n    _ = withUnsafePointer(to: source) { sourcePointer in\n        vImageScale_ARGB8888(sourcePointer,\n                             &destination,\n                             nil,\n                             vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\nIn cases where your code calls the function frequently (for example, when processing video), create and manage this temporary buffer yourself and reuse it across function calls. Reusing a buffer avoids vImage allocating the temporary storage with each call. Pass [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageGetTempBufferSize] to your geometry function to calculate the size, in bytes, of the temporary buffer, and use that value to allocate an [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafeMutableRawPointer] structure.\n\nThe version of the `scaleBuffer()` function below shows an example of creating a temporary buffer:\n\n```swift\nstatic func scaleBuffer(source: vImage_Buffer,\n                        destination: inout vImage_Buffer) {\n    \n    withUnsafePointer(to: source) { sourcePointer in\n        let bufferSize = vImageScale_ARGB8888(sourcePointer,\n                                              &destination,\n                                              nil,\n                                              vImage_Flags(kvImageGetTempBufferSize))\n        \n        if bufferSize < 0 {\n            fatalError(\"Error calculating buffer size for scale operation (\\(bufferSize)).\")\n        }\n        \n        \/\/ In a real app, you reuse this buffer across multiple calls of `vImageScale_ARGB8888`.\n        let temporaryBuffer = UnsafeMutableRawPointer.allocate(byteCount: bufferSize,\n                                                               alignment: 64)\n        defer {\n            temporaryBuffer.deallocate()\n        }\n        \n        vImageScale_ARGB8888(sourcePointer,\n                             &destination,\n                             temporaryBuffer,\n                             vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\n## Image Processing Essentials\n\n- **Converting bitmap data between Core Graphics images and vImage buffers**: Pass image data between Core Graphics and vImage to create and manipulate images.\n- **Creating and Populating Buffers from Core Graphics Images**: Initialize vImage buffers from Core Graphics images.\n- **Creating a Core Graphics Image from a vImage Buffer**: Create displayable representations of vImage buffers.\n- **Building a Basic Image-Processing Workflow**: Resize an image with vImage.\n- **Compositing images with alpha blending**: Combine two images by using alpha blending to create a single output.\n- **Compositing images with vImage blend modes**: Combine two images by using blend modes to create a single output.\n- **Applying vImage operations to regions of interest**: Limit the effect of vImage operations to rectangular regions of interest.\n- **Optimizing image-processing performance**: Improve your app’s performance by converting image buffer formats from interleaved to planar.\n- **vImage**: Manipulate large images using the CPU’s vector processor.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Pass image data between Core Graphics and vImage to create and manipulate images.",
          "name" : "Converting bitmap data between Core Graphics images and vImage buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/converting-bitmap-data-between-core-graphics-images-and-vimage-buffers"
        },
        {
          "description" : "Initialize vImage buffers from Core Graphics images.",
          "name" : "Creating and Populating Buffers from Core Graphics Images",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-and-populating-buffers-from-core-graphics-images"
        },
        {
          "description" : "Create displayable representations of vImage buffers.",
          "name" : "Creating a Core Graphics Image from a vImage Buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-a-core-graphics-image-from-a-vimage-buffer"
        },
        {
          "description" : "Resize an image with vImage.",
          "name" : "Building a Basic Image-Processing Workflow",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/building-a-basic-image-processing-workflow"
        },
        {
          "description" : "Combine two images by using alpha blending to create a single output.",
          "name" : "Compositing images with alpha blending",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compositing-images-with-alpha-blending"
        },
        {
          "description" : "Combine two images by using blend modes to create a single output.",
          "name" : "Compositing images with vImage blend modes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compositing-images-with-vimage-blend-modes"
        },
        {
          "description" : "Limit the effect of vImage operations to rectangular regions of interest.",
          "name" : "Applying vImage operations to regions of interest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest"
        },
        {
          "description" : "Improve your app’s performance by converting image buffer formats from interleaved to planar.",
          "name" : "Optimizing image-processing performance",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/optimizing-image-processing-performance"
        },
        {
          "description" : "Manipulate large images using the CPU’s vector processor.",
          "name" : "vImage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vimage-library"
        }
      ],
      "title" : "Image Processing Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Applying geometric transforms to images",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-geometric-transforms-to-images"
}