{
  "abstract" : "Format source data for the vDSP Fourier functions, and interpret the results.",
  "codeExamples" : [
    {
      "code" : "let signal: [Float] = [0, 1, 2, 3, 4, 5, 6, 7]\nlet complexValuesCount = signal.count \/ 2\n\nvar complexReals = [Float]()\nvar complexImaginaries = [Float]()\n\nsignal.withUnsafeBytes { signalPtr in\n    complexReals = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n        realBuffer, realInitializedCount in\n        \n        complexImaginaries = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n            imagBuffer, imagInitializedCount in\n            \n            var splitComplex = DSPSplitComplex(realp: realBuffer.baseAddress!,\n                                               imagp: imagBuffer.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n            \n            imagInitializedCount = complexValuesCount\n        }\n        realInitializedCount = complexValuesCount\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Returns an array that contains a composite sine wave from the specified frequency-amplitude pairs.\nstatic func makeCompositeSineWave(from frequencyAmplitudePairs: [(f: Float,\n                                                                  a: Float)],\n                                  count: Int) -> [Float] {\n\n    return [Float](unsafeUninitializedCapacity: count) {\n        buffer, initializedCount in\n        \n        \/\/\/ Fill the buffer with zeros.\n        vDSP.fill(&buffer, with: 0)\n        \/\/\/ Create a reusable array that the function uses to calculate the \n        \/\/\/ sine wave for each iteration.\n        var iterationValues = [Float](repeating: 0, count: count)\n        \n        for frequencyAmplitudePair in frequencyAmplitudePairs {\n            \/\/\/ Fill the working array with a ramp in the range `0 ..< frequency`.\n            vDSP.formRamp(withInitialValue: 0,\n                          increment: frequencyAmplitudePair.f \/ Float(count \/ 2),\n                          result: &iterationValues)\n            \/\/\/ Compute `sin(x * .pi)` for each element.\n            vForce.sinPi(iterationValues, result: &iterationValues)\n            if frequencyAmplitudePair.a != 1 {\n                \/\/\/ Mulitply each element by the specified amplitude.\n                vDSP.multiply(frequencyAmplitudePair.a, iterationValues,\n                              result: &iterationValues)\n            }\n            \/\/\/ Add this sine wave iteration to the composite sine wave accumulator.\n            vDSP.add(iterationValues, buffer, result: &buffer)\n        }\n        \n        initializedCount = count\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let realValuesCount = 32\nlet signal: [Float] = makeCompositeSineWave(from: [(f: 1, a: 1),\n                                                   (f: 5, a: 1),\n                                                   (f: 10, a: 1),\n                                                   (f: 15, a: 1)],\n                                            count: realValuesCount)\n\nlet complexValuesCount = realValuesCount \/ 2\nvar complexReals = [Float](repeating: 0,\n                           count: complexValuesCount)\nvar complexImaginaries = [Float](repeating: 0,\n                                 count: complexValuesCount)",
      "language" : "swift"
    },
    {
      "code" : "signal.withUnsafeBytes { signalPtr in\n    complexReals.withUnsafeMutableBufferPointer { realPtr in\n        complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n            var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n            \n            let log2n = vDSP_Length(log2(Float(realValuesCount)))\n            if let fft = vDSP_create_fftsetup(log2n, FFTRadix(kFFTRadix2)) {\n                vDSP_fft_zrip(fft,\n                              &splitComplex, 1,\n                              log2n,\n                              FFTDirection(kFFTDirection_Forward))\n                \n                vDSP_destroy_fftsetup(fft)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "signal.withUnsafeBytes { signalPtr in\n    complexReals.withUnsafeMutableBufferPointer { realPtr in\n        complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n            var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n\n            if let dft = vDSP_DFT_zrop_CreateSetup(nil,\n                                                   vDSP_Length(realValuesCount),\n                                                   .FORWARD) {\n                vDSP_DFT_Execute(dft,\n                                 realPtr.baseAddress!, imagPtr.baseAddress!,\n                                 realPtr.baseAddress!, imagPtr.baseAddress!)\n                vDSP_DFT_DestroySetup(dft)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let interleavedComplex: [DSPComplex] = [DSPComplex(real: 0, imag: 1),\n                                        DSPComplex(real: 2, imag: 3),\n                                        DSPComplex(real: 4, imag: 5),\n                                        DSPComplex(real: 6, imag: 6)]\n\nlet count = interleavedComplex.count\n\nvar complexImaginaries = [Float]()\nvar complexReals = [Float](unsafeUninitializedCapacity: count) {\n    realBuffer, realInitializedCount in\n    \n    complexImaginaries = [Float](unsafeUninitializedCapacity: count) {\n        imagBuffer, imagInitializedCount in\n        \n        var splitComplex = DSPSplitComplex(realp: realBuffer.baseAddress!,\n                                           imagp: imagBuffer.baseAddress!)\n        \n        vDSP_ctoz(interleavedComplex, 2,\n                  &splitComplex, 1,\n                  vDSP_Length(count))\n\n        imagInitializedCount = count\n    }\n    \n    realInitializedCount = count\n}",
      "language" : "swift"
    },
    {
      "code" : "let complexValuesCount = 16\n\nlet realFrequencyAmplitudePairs: [(f: Float, a: Float)] = [(3, 1), (5, 0.2)]\nvar complexReals = makeCompositeSineWave(from: realFrequencyAmplitudePairs,\n                                         count: complexValuesCount)\n\nlet imaginaryFrequencyAmplitudePairs: [(f: Float, a: Float)] = [(4, 1), (7, 0.25)]\nvar complexImaginaries = makeCompositeSineWave(from: imaginaryFrequencyAmplitudePairs,\n                                               count: complexValuesCount)\n\nif let dft = vDSP_DFT_zop_CreateSetup(nil,\n                                      vDSP_Length(complexValuesCount),\n                                      .FORWARD) {\n    \n    vDSP_DFT_Execute(dft,\n                     complexReals,\n                     complexImaginaries,\n                     &complexReals,\n                     &complexImaginaries)\n    \n    vDSP_DFT_DestroySetup(dft)\n}",
      "language" : "swift"
    },
    {
      "code" : "Reals:\n[ 0.0, 0.0, 0.0,  8.0,  8.0,  1.6,  0.0,  2.0, 0.0,  2.0, 0.0, 1.6,  8.0, 8.0,  0.0, 0.0 ]\nImaginaries:\n[ 0.0, 0.0, 0.0, -8.0, -0.0, -1.6, -0.0, -0.0, 0.0, -0.0, 0.0, 1.6, -0.0, 8.0, -0.0, -0.0]",
      "language" : "swift"
    },
    {
      "code" : "let realDimension = 512\nlet complexValuesWidth = realDimension \/ 2\nlet complexValuesHeight = realDimension",
      "language" : "swift"
    },
    {
      "code" : "let complexElementCount = complexValuesWidth * complexValuesHeight\nvar complexReals = [Float]()\nvar complexImaginaries = [Float]()\n\nimageData.withUnsafeBytes { imageDataPtr in\n    complexReals = [Float](unsafeUninitializedCapacity: complexElementCount) {\n        realBuffer, realInitializedCount in\n        complexImaginaries = [Float](unsafeUninitializedCapacity: complexElementCount) {\n            imagBuffer, imagInitializedCount in\n            \n            var splitComplex = DSPSplitComplex(\n                realp: realBuffer.baseAddress!,\n                imagp: imagBuffer.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](imageDataPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesWidth * complexValuesHeight))\n            \n            \/\/ The binary logarithm of `max(rowCount, columnCount)`.\n            let countLog2n = vDSP_Length(log2(Float(realDimension)))\n            if let fft = vDSP_create_fftsetup(countLog2n, FFTRadix(kFFTRadix2)) {\n       \n                let dimensionLog2n = vDSP_Length(log2(Float(realDimension)))\n                vDSP_fft2d_zrip(fft, &splitComplex,\n                                1, 0,\n                                dimensionLog2n, dimensionLog2n,\n                                FFTDirection(kFFTDirection_Forward))\n                \n                vDSP_destroy_fftsetup(fft)\n            }\n\n            imagInitializedCount = complexElementCount\n        }\n        realInitializedCount = complexElementCount\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let complexDimension = 512\n     \nvar complexReals = [Float](repeating: 0,\n                           count: complexDimension * complexDimension)\nvar complexImaginaries = [Float](repeating: 0,\n                                 count: complexDimension * complexDimension)\n\n\/\/ Populate `complexReals` and `complexImaginaries` with 2D complex data.\n \ncomplexReals.withUnsafeMutableBufferPointer { realPtr in\n    complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n        \n        var splitComplex = DSPSplitComplex(\n            realp: realPtr.baseAddress!,\n            imagp: imagPtr.baseAddress!)\n        \n        \/\/ The binary logarithm of `max(rowCount, columnCount)`.\n        let countLog2n = vDSP_Length(log2(Float(complexDimension)))\n        if let fft = vDSP_create_fftsetup(countLog2n, FFTRadix(kFFTRadix2)) {\n            \n            \/\/ The binary logarithm of the width or height of the 2D matrix.\n            let dimensionLog2n = vDSP_Length(log2(Float(complexDimension)))\n            vDSP_fft2d_zip(fft, &splitComplex,\n                           1, 0,\n                           dimensionLog2n, dimensionLog2n,\n                           FFTDirection(kFFTDirection_Forward))\n            \n            vDSP_destroy_fftsetup(fft)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let realValuesCount = 8\n\n\/\/ The result of `vDSP_ctoz` on `[0, 1, 2, 3, 4, 5, 6, 7]`.\nvar complexReals: [Float] = [0, 2, 4, 6]\nvar complexImaginaries: [Float] = [1, 3, 5, 7]\n\n\/\/ Perform forward transform.\nif let dft = vDSP_DFT_zrop_CreateSetup(nil,\n                                       vDSP_Length(realValuesCount),\n                                       .FORWARD) {\n    vDSP_DFT_Execute(dft,\n                     complexReals, complexImaginaries,\n                     &complexReals, &complexImaginaries)\n    \n    vDSP_DFT_DestroySetup(dft)\n}\n\n\/\/ Apply real forward scaling factor (2).\nvDSP.multiply(1 \/ 2, complexReals, result: &complexReals)\nvDSP.multiply(1 \/ 2, complexImaginaries, result: &complexImaginaries)\n\n\/\/ Perform inverse transform.\nif let dft = vDSP_DFT_zrop_CreateSetup(nil,\n                                       vDSP_Length(realValuesCount),\n                                       .INVERSE) {\n    vDSP_DFT_Execute(dft,\n                     complexReals, complexImaginaries,\n                     &complexReals, &complexImaginaries)\n    \n    vDSP_DFT_DestroySetup(dft)\n}\n\n\/\/ Apply real inverse scaling factor (n).\nvDSP.multiply(1 \/ Float(realValuesCount), complexReals, result: &complexReals)\nvDSP.multiply(1 \/ Float(realValuesCount), complexImaginaries, result: &complexImaginaries)\n\nprint(complexReals) \/\/ Prints \"[0.0, 2.0, 4.0, 6.0]\".\nprint(complexImaginaries) \/\/ Prints \"[1.0, 3.0, 5.0, 7.0]\".",
      "language" : "swift"
    }
  ],
  "contentHash" : "6680f9961d6d9f8f673f176de4006646ac04ca47730157f270027a915250e003",
  "crawledAt" : "2025-12-02T15:37:17Z",
  "id" : "0C424D8E-66C0-468A-A85C-F29B85791B7F",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThe vDSP real-to-complex fast Fourier transform (FFT) and discrete Fourier transform (DFT) functions write their output in a special packed format to conserve memory. Use the code samples below to understand how to format source data for and interpret the results from the vDSP Fourier transform functions.\n\n### Convert real values to the split-complex format\n\nThe vDSP FFT and DFT functions work with data in split-complex format. Split-complex format separates the real and imaginary parts of complex numbers into two separate arrays. Given an array, `signal`, that contains real values, the following code converts the values to split-complex format. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to populate the split collections `complexReals` and `complexImaginaries` with the real values from `signal`:\n\nOn return, `complexReals` contains the values `[0.0, 2.0, 4.0, 6.0]`, and `complexImaginaries` contains the values `[1.0, 3.0, 5.0, 7.0]`. The diagram below illustrates how [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] converts the real values to the even-odd split configuration:\n\n\n\n### Create a composite sine wave\n\nUse the following function to fill an array with values that represent a composite sine wave:\n\nThe following figure visualizes the values of a 1024-element array that `makeCompositeSineWave()` returns with the frequency-amplitude pairs `[(f: 2, a: 1.5), (f: 8, a: 1.0)]:`\n\n\n\n### Perform Fourier transform on 1D real data in split-complex format\n\nUse the following code to populate the real `signal` array with a composite of four sine waves and create empty arrays for the complex values:\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft_zrip] to perform an in-place fast Fourier transform (FFT) on the real values. In this example, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] function uses a `DSPSplitComplex` structure as an intermediary to populate the `complexReals` and `complexImaginaries` arrays:\n\nAlternatively, use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_zrop_CreateSetup] to create an object that performs a discrete Fourier transform on the real values:\n\nThe result of a forward Fourier transform on `n` real values is `n` complex values. The list below describes how the vDSP library structures the result:\n\nvDSP exploits the zeros in the DC and Nyquist elements and the symmetry of the complex conjugates. The Fourier transform routines represent the frequency-domain data in `n\/2` complex values. They achieve this by placing the real Nyquist component in the imaginary part of the DC element and omitting the complex conjugates:\n\n\n\nThe following figure illustrates the frequency-domain result from performing a forward transform on the signal data that contains the four composite sine waves:\n\n\n\nThe indices of the nonzero elements in the frequency-domain data are the sine wave frequencies in the original time-domain signal: `1` , `5`, `10`, and `15`.\n\n### Convert interleaved-complex to the split-complex format\n\nGiven an array, `interleavedComplex`, that contains interleaved complex values, the following code converts the values to split-complex format. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to populate the split collections `complexReals` and `complexImaginaries` with the complex values from `interleavedComplex`:\n\nOn return, `complexReals` contains the values `[0.0, 2.0, 4.0, 6.0]`, and `complexImaginaries` contains the values [`1.0, 3.0, 5.0, 7.0]`. The following diagram illustrates how `vDSP_ctoz(_:_:_:_:_:)` converts the interleaved values to the even-odd split configuration:\n\n\n\n### Perform Fourier transform on 1D complex data\n\nThe following figure shows a representation of time-domain complex data. The real part and imaginary part contain distinct composite sine waves:\n\n\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_zop_CreateSetup] to create a DFT object for a complex transform, or call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft_zip] to perform a complex FFT in place. The following code creates a complex signal and performs a forward DFT:\n\nOn return, `complexReals` and `complexImaginaries` contain the following values:\n\nThe indices of the nonzero magnitudes indicate the component frequencies `3`, `4`, `5`, and `7`.\n\nThe following figure shows the layout of the frequency-domain data. The DC and Nyquist components contain real and imaginary parts. The elements `0` to `n\/2 -1` contain the positive-frequency values, and the elements `n\/2 +` 1 to `n - 1` contain the negative-frequency values.\n\n\n\n### Perform Fourier transform on 2D real data\n\nvDSP provides routines you can use to compute the FFT of 2D real data such as single-channel images. The following figure shows the original, spatial-domain representations of grids of dots with their frequency-domain counterparts:\n\n\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to convert real spatial-domain values like pixel intensities to complex values. The real part of each complex value contains the even pixel values, and the imaginary part of each complex value contains the odd pixel values. The following code defines the width and height of the matrix of complex values for a 512 x 512 real matrix:\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft2d_zrip] to perform the forward FFT in place. In this example, `imageData` is an array that contains `realDimension * realDimension` real pixel values:\n\nThe 2D FFT operates on real data by first transforming each row. This transform generates real values — the DC and Nyquist component of each row — in the first two elements of each row. The second pass of the transform computes the FFT for each column. The first two columns contain real values, and vDSP uses the real transform routines. Subsequent columns contain complex values, and vDSP uses the complex transform routines:\n\n\n\nBecause the complex elements `n\/2 +` 1 to `n - 1` contain the negative-frequency values, for tasks such as visualizing the frequency-domain representation of 2D real data, you may be able to discard the bottom `n\/2` rows.\n\n### Perform Fourier transform on 2D complex data\n\nvDSP provides functions for performing Fourier transforms on 2D complex data, such as two-channel images. The following image shows the spatial-domain representation of 2D complex data with low-frequency data in the red and green channels, and high-frequency data in the blue channel. The frequency-domain representation shows the magnitude of the complex values:\n\n\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft2d_zip] to perform a complex FFT on 2D complex data:\n\nOn return, `complexReals` and `complexImaginaries` contain the frequency-domain representation of the complex data. Because both the horizontal pass and the vertical pass are complex FFTs, the right `n\/2` columns and the bottom `n\/2` rows contain the negative frequencies:\n\n\n\n### Scale time- and frequency-domain data\n\nTo provide the best execution performance, vDSP’s Fourier routines don’t scale transform results. The following table summarizes the scaling factor for the vDSP FFT and DFT operations:\n\nFor example, the following code performs a forward transform and an inverse transform on eight real elements. The code multiplies the frequency-domain data by `1\/2`, and the time-domain data by `1\/n`. The result is identical to the original data:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms\ncrawled: 2025-12-02T15:37:17Z\n---\n\n# Understanding data packing for Fourier transforms\n\n**Article**\n\nFormat source data for the vDSP Fourier functions, and interpret the results.\n\n## Overview\n\nThe vDSP real-to-complex fast Fourier transform (FFT) and discrete Fourier transform (DFT) functions write their output in a special packed format to conserve memory. Use the code samples below to understand how to format source data for and interpret the results from the vDSP Fourier transform functions.\n\n### Convert real values to the split-complex format\n\nThe vDSP FFT and DFT functions work with data in split-complex format. Split-complex format separates the real and imaginary parts of complex numbers into two separate arrays. Given an array, `signal`, that contains real values, the following code converts the values to split-complex format. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to populate the split collections `complexReals` and `complexImaginaries` with the real values from `signal`:\n\n```swift\nlet signal: [Float] = [0, 1, 2, 3, 4, 5, 6, 7]\nlet complexValuesCount = signal.count \/ 2\n\nvar complexReals = [Float]()\nvar complexImaginaries = [Float]()\n\nsignal.withUnsafeBytes { signalPtr in\n    complexReals = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n        realBuffer, realInitializedCount in\n        \n        complexImaginaries = [Float](unsafeUninitializedCapacity: complexValuesCount) {\n            imagBuffer, imagInitializedCount in\n            \n            var splitComplex = DSPSplitComplex(realp: realBuffer.baseAddress!,\n                                               imagp: imagBuffer.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n            \n            imagInitializedCount = complexValuesCount\n        }\n        realInitializedCount = complexValuesCount\n    }\n}\n```\n\nOn return, `complexReals` contains the values `[0.0, 2.0, 4.0, 6.0]`, and `complexImaginaries` contains the values `[1.0, 3.0, 5.0, 7.0]`. The diagram below illustrates how [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] converts the real values to the even-odd split configuration:\n\n\n\n### Create a composite sine wave\n\nUse the following function to fill an array with values that represent a composite sine wave:\n\n```swift\n\/\/\/ Returns an array that contains a composite sine wave from the specified frequency-amplitude pairs.\nstatic func makeCompositeSineWave(from frequencyAmplitudePairs: [(f: Float,\n                                                                  a: Float)],\n                                  count: Int) -> [Float] {\n\n    return [Float](unsafeUninitializedCapacity: count) {\n        buffer, initializedCount in\n        \n        \/\/\/ Fill the buffer with zeros.\n        vDSP.fill(&buffer, with: 0)\n        \/\/\/ Create a reusable array that the function uses to calculate the \n        \/\/\/ sine wave for each iteration.\n        var iterationValues = [Float](repeating: 0, count: count)\n        \n        for frequencyAmplitudePair in frequencyAmplitudePairs {\n            \/\/\/ Fill the working array with a ramp in the range `0 ..< frequency`.\n            vDSP.formRamp(withInitialValue: 0,\n                          increment: frequencyAmplitudePair.f \/ Float(count \/ 2),\n                          result: &iterationValues)\n            \/\/\/ Compute `sin(x * .pi)` for each element.\n            vForce.sinPi(iterationValues, result: &iterationValues)\n            if frequencyAmplitudePair.a != 1 {\n                \/\/\/ Mulitply each element by the specified amplitude.\n                vDSP.multiply(frequencyAmplitudePair.a, iterationValues,\n                              result: &iterationValues)\n            }\n            \/\/\/ Add this sine wave iteration to the composite sine wave accumulator.\n            vDSP.add(iterationValues, buffer, result: &buffer)\n        }\n        \n        initializedCount = count\n    }\n}\n```\n\nThe following figure visualizes the values of a 1024-element array that `makeCompositeSineWave()` returns with the frequency-amplitude pairs `[(f: 2, a: 1.5), (f: 8, a: 1.0)]:`\n\n\n\n### Perform Fourier transform on 1D real data in split-complex format\n\nUse the following code to populate the real `signal` array with a composite of four sine waves and create empty arrays for the complex values:\n\n```swift\nlet realValuesCount = 32\nlet signal: [Float] = makeCompositeSineWave(from: [(f: 1, a: 1),\n                                                   (f: 5, a: 1),\n                                                   (f: 10, a: 1),\n                                                   (f: 15, a: 1)],\n                                            count: realValuesCount)\n\nlet complexValuesCount = realValuesCount \/ 2\nvar complexReals = [Float](repeating: 0,\n                           count: complexValuesCount)\nvar complexImaginaries = [Float](repeating: 0,\n                                 count: complexValuesCount)\n```\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft_zrip] to perform an in-place fast Fourier transform (FFT) on the real values. In this example, the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] function uses a `DSPSplitComplex` structure as an intermediary to populate the `complexReals` and `complexImaginaries` arrays:\n\n```swift\nsignal.withUnsafeBytes { signalPtr in\n    complexReals.withUnsafeMutableBufferPointer { realPtr in\n        complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n            var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n            \n            let log2n = vDSP_Length(log2(Float(realValuesCount)))\n            if let fft = vDSP_create_fftsetup(log2n, FFTRadix(kFFTRadix2)) {\n                vDSP_fft_zrip(fft,\n                              &splitComplex, 1,\n                              log2n,\n                              FFTDirection(kFFTDirection_Forward))\n                \n                vDSP_destroy_fftsetup(fft)\n            }\n        }\n    }\n}\n```\n\nAlternatively, use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_zrop_CreateSetup] to create an object that performs a discrete Fourier transform on the real values:\n\n```swift\nsignal.withUnsafeBytes { signalPtr in\n    complexReals.withUnsafeMutableBufferPointer { realPtr in\n        complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n            var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                               imagp: imagPtr.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](signalPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesCount))\n\n            if let dft = vDSP_DFT_zrop_CreateSetup(nil,\n                                                   vDSP_Length(realValuesCount),\n                                                   .FORWARD) {\n                vDSP_DFT_Execute(dft,\n                                 realPtr.baseAddress!, imagPtr.baseAddress!,\n                                 realPtr.baseAddress!, imagPtr.baseAddress!)\n                vDSP_DFT_DestroySetup(dft)\n            }\n        }\n    }\n}\n```\n\nThe result of a forward Fourier transform on `n` real values is `n` complex values. The list below describes how the vDSP library structures the result:\n\n- Complex element `0` contains the DC component (equal to the sum of the time domain values) in its real part and zero in its imaginary part.\n- Complex elements `1` through `n\/2 - 1` contain the complex frequency-domain values.\n- Complex element `n\/2` contains the Nyquist component (the cosine component coefficient at the Nyquist frequency) in its real part and zero in its imaginary part.\n- The remaining complex elements contain the complex conjugates of the complex frequency-domain values.\n\nvDSP exploits the zeros in the DC and Nyquist elements and the symmetry of the complex conjugates. The Fourier transform routines represent the frequency-domain data in `n\/2` complex values. They achieve this by placing the real Nyquist component in the imaginary part of the DC element and omitting the complex conjugates:\n\n\n\nThe following figure illustrates the frequency-domain result from performing a forward transform on the signal data that contains the four composite sine waves:\n\n\n\nThe indices of the nonzero elements in the frequency-domain data are the sine wave frequencies in the original time-domain signal: `1` , `5`, `10`, and `15`.\n\n### Convert interleaved-complex to the split-complex format\n\nGiven an array, `interleavedComplex`, that contains interleaved complex values, the following code converts the values to split-complex format. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to populate the split collections `complexReals` and `complexImaginaries` with the complex values from `interleavedComplex`:\n\n```swift\nlet interleavedComplex: [DSPComplex] = [DSPComplex(real: 0, imag: 1),\n                                        DSPComplex(real: 2, imag: 3),\n                                        DSPComplex(real: 4, imag: 5),\n                                        DSPComplex(real: 6, imag: 6)]\n\nlet count = interleavedComplex.count\n\nvar complexImaginaries = [Float]()\nvar complexReals = [Float](unsafeUninitializedCapacity: count) {\n    realBuffer, realInitializedCount in\n    \n    complexImaginaries = [Float](unsafeUninitializedCapacity: count) {\n        imagBuffer, imagInitializedCount in\n        \n        var splitComplex = DSPSplitComplex(realp: realBuffer.baseAddress!,\n                                           imagp: imagBuffer.baseAddress!)\n        \n        vDSP_ctoz(interleavedComplex, 2,\n                  &splitComplex, 1,\n                  vDSP_Length(count))\n\n        imagInitializedCount = count\n    }\n    \n    realInitializedCount = count\n}\n```\n\nOn return, `complexReals` contains the values `[0.0, 2.0, 4.0, 6.0]`, and `complexImaginaries` contains the values [`1.0, 3.0, 5.0, 7.0]`. The following diagram illustrates how `vDSP_ctoz(_:_:_:_:_:)` converts the interleaved values to the even-odd split configuration:\n\n\n\n### Perform Fourier transform on 1D complex data\n\nThe following figure shows a representation of time-domain complex data. The real part and imaginary part contain distinct composite sine waves:\n\n\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_DFT_zop_CreateSetup] to create a DFT object for a complex transform, or call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft_zip] to perform a complex FFT in place. The following code creates a complex signal and performs a forward DFT:\n\n```swift\nlet complexValuesCount = 16\n\nlet realFrequencyAmplitudePairs: [(f: Float, a: Float)] = [(3, 1), (5, 0.2)]\nvar complexReals = makeCompositeSineWave(from: realFrequencyAmplitudePairs,\n                                         count: complexValuesCount)\n\nlet imaginaryFrequencyAmplitudePairs: [(f: Float, a: Float)] = [(4, 1), (7, 0.25)]\nvar complexImaginaries = makeCompositeSineWave(from: imaginaryFrequencyAmplitudePairs,\n                                               count: complexValuesCount)\n\nif let dft = vDSP_DFT_zop_CreateSetup(nil,\n                                      vDSP_Length(complexValuesCount),\n                                      .FORWARD) {\n    \n    vDSP_DFT_Execute(dft,\n                     complexReals,\n                     complexImaginaries,\n                     &complexReals,\n                     &complexImaginaries)\n    \n    vDSP_DFT_DestroySetup(dft)\n}\n```\n\nOn return, `complexReals` and `complexImaginaries` contain the following values:\n\n```swift\nReals:\n[ 0.0, 0.0, 0.0,  8.0,  8.0,  1.6,  0.0,  2.0, 0.0,  2.0, 0.0, 1.6,  8.0, 8.0,  0.0, 0.0 ]\nImaginaries:\n[ 0.0, 0.0, 0.0, -8.0, -0.0, -1.6, -0.0, -0.0, 0.0, -0.0, 0.0, 1.6, -0.0, 8.0, -0.0, -0.0]\n```\n\nThe indices of the nonzero magnitudes indicate the component frequencies `3`, `4`, `5`, and `7`.\n\nThe following figure shows the layout of the frequency-domain data. The DC and Nyquist components contain real and imaginary parts. The elements `0` to `n\/2 -1` contain the positive-frequency values, and the elements `n\/2 +` 1 to `n - 1` contain the negative-frequency values.\n\n\n\n### Perform Fourier transform on 2D real data\n\nvDSP provides routines you can use to compute the FFT of 2D real data such as single-channel images. The following figure shows the original, spatial-domain representations of grids of dots with their frequency-domain counterparts:\n\n\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] to convert real spatial-domain values like pixel intensities to complex values. The real part of each complex value contains the even pixel values, and the imaginary part of each complex value contains the odd pixel values. The following code defines the width and height of the matrix of complex values for a 512 x 512 real matrix:\n\n```swift\nlet realDimension = 512\nlet complexValuesWidth = realDimension \/ 2\nlet complexValuesHeight = realDimension\n```\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft2d_zrip] to perform the forward FFT in place. In this example, `imageData` is an array that contains `realDimension * realDimension` real pixel values:\n\n```swift\nlet complexElementCount = complexValuesWidth * complexValuesHeight\nvar complexReals = [Float]()\nvar complexImaginaries = [Float]()\n\nimageData.withUnsafeBytes { imageDataPtr in\n    complexReals = [Float](unsafeUninitializedCapacity: complexElementCount) {\n        realBuffer, realInitializedCount in\n        complexImaginaries = [Float](unsafeUninitializedCapacity: complexElementCount) {\n            imagBuffer, imagInitializedCount in\n            \n            var splitComplex = DSPSplitComplex(\n                realp: realBuffer.baseAddress!,\n                imagp: imagBuffer.baseAddress!)\n            \n            vDSP_ctoz([DSPComplex](imageDataPtr.bindMemory(to: DSPComplex.self)), 2,\n                      &splitComplex, 1,\n                      vDSP_Length(complexValuesWidth * complexValuesHeight))\n            \n            \/\/ The binary logarithm of `max(rowCount, columnCount)`.\n            let countLog2n = vDSP_Length(log2(Float(realDimension)))\n            if let fft = vDSP_create_fftsetup(countLog2n, FFTRadix(kFFTRadix2)) {\n       \n                let dimensionLog2n = vDSP_Length(log2(Float(realDimension)))\n                vDSP_fft2d_zrip(fft, &splitComplex,\n                                1, 0,\n                                dimensionLog2n, dimensionLog2n,\n                                FFTDirection(kFFTDirection_Forward))\n                \n                vDSP_destroy_fftsetup(fft)\n            }\n\n            imagInitializedCount = complexElementCount\n        }\n        realInitializedCount = complexElementCount\n    }\n}\n```\n\nThe 2D FFT operates on real data by first transforming each row. This transform generates real values — the DC and Nyquist component of each row — in the first two elements of each row. The second pass of the transform computes the FFT for each column. The first two columns contain real values, and vDSP uses the real transform routines. Subsequent columns contain complex values, and vDSP uses the complex transform routines:\n\n\n\nBecause the complex elements `n\/2 +` 1 to `n - 1` contain the negative-frequency values, for tasks such as visualizing the frequency-domain representation of 2D real data, you may be able to discard the bottom `n\/2` rows.\n\n### Perform Fourier transform on 2D complex data\n\nvDSP provides functions for performing Fourier transforms on 2D complex data, such as two-channel images. The following image shows the spatial-domain representation of 2D complex data with low-frequency data in the red and green channels, and high-frequency data in the blue channel. The frequency-domain representation shows the magnitude of the complex values:\n\n\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_fft2d_zip] to perform a complex FFT on 2D complex data:\n\n```swift\nlet complexDimension = 512\n     \nvar complexReals = [Float](repeating: 0,\n                           count: complexDimension * complexDimension)\nvar complexImaginaries = [Float](repeating: 0,\n                                 count: complexDimension * complexDimension)\n\n\/\/ Populate `complexReals` and `complexImaginaries` with 2D complex data.\n \ncomplexReals.withUnsafeMutableBufferPointer { realPtr in\n    complexImaginaries.withUnsafeMutableBufferPointer { imagPtr in\n        \n        var splitComplex = DSPSplitComplex(\n            realp: realPtr.baseAddress!,\n            imagp: imagPtr.baseAddress!)\n        \n        \/\/ The binary logarithm of `max(rowCount, columnCount)`.\n        let countLog2n = vDSP_Length(log2(Float(complexDimension)))\n        if let fft = vDSP_create_fftsetup(countLog2n, FFTRadix(kFFTRadix2)) {\n            \n            \/\/ The binary logarithm of the width or height of the 2D matrix.\n            let dimensionLog2n = vDSP_Length(log2(Float(complexDimension)))\n            vDSP_fft2d_zip(fft, &splitComplex,\n                           1, 0,\n                           dimensionLog2n, dimensionLog2n,\n                           FFTDirection(kFFTDirection_Forward))\n            \n            vDSP_destroy_fftsetup(fft)\n        }\n    }\n}\n```\n\nOn return, `complexReals` and `complexImaginaries` contain the frequency-domain representation of the complex data. Because both the horizontal pass and the vertical pass are complex FFTs, the right `n\/2` columns and the bottom `n\/2` rows contain the negative frequencies:\n\n\n\n### Scale time- and frequency-domain data\n\nTo provide the best execution performance, vDSP’s Fourier routines don’t scale transform results. The following table summarizes the scaling factor for the vDSP FFT and DFT operations:\n\n\n\nFor example, the following code performs a forward transform and an inverse transform on eight real elements. The code multiplies the frequency-domain data by `1\/2`, and the time-domain data by `1\/n`. The result is identical to the original data:\n\n```swift\nlet realValuesCount = 8\n\n\/\/ The result of `vDSP_ctoz` on `[0, 1, 2, 3, 4, 5, 6, 7]`.\nvar complexReals: [Float] = [0, 2, 4, 6]\nvar complexImaginaries: [Float] = [1, 3, 5, 7]\n\n\/\/ Perform forward transform.\nif let dft = vDSP_DFT_zrop_CreateSetup(nil,\n                                       vDSP_Length(realValuesCount),\n                                       .FORWARD) {\n    vDSP_DFT_Execute(dft,\n                     complexReals, complexImaginaries,\n                     &complexReals, &complexImaginaries)\n    \n    vDSP_DFT_DestroySetup(dft)\n}\n\n\/\/ Apply real forward scaling factor (2).\nvDSP.multiply(1 \/ 2, complexReals, result: &complexReals)\nvDSP.multiply(1 \/ 2, complexImaginaries, result: &complexImaginaries)\n\n\/\/ Perform inverse transform.\nif let dft = vDSP_DFT_zrop_CreateSetup(nil,\n                                       vDSP_Length(realValuesCount),\n                                       .INVERSE) {\n    vDSP_DFT_Execute(dft,\n                     complexReals, complexImaginaries,\n                     &complexReals, &complexImaginaries)\n    \n    vDSP_DFT_DestroySetup(dft)\n}\n\n\/\/ Apply real inverse scaling factor (n).\nvDSP.multiply(1 \/ Float(realValuesCount), complexReals, result: &complexReals)\nvDSP.multiply(1 \/ Float(realValuesCount), complexImaginaries, result: &complexImaginaries)\n\nprint(complexReals) \/\/ Prints \"[0.0, 2.0, 4.0, 6.0]\".\nprint(complexImaginaries) \/\/ Prints \"[1.0, 3.0, 5.0, 7.0]\".\n```\n\n## Fourier and Cosine Transforms\n\n- **Finding the component frequencies in a composite sine wave**: Use 1D fast Fourier transform to compute the frequency components of a signal.\n- **Performing Fourier transforms on interleaved-complex data**: Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.\n- **Reducing spectral leakage with windowing**: Multiply signal data by window sequence values when performing transforms with noninteger period signals.\n- **Signal extraction from noise**: Use Accelerate’s discrete cosine transform to remove noise from a signal.\n- **Performing Fourier Transforms on Multiple Signals**: Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.\n- **Halftone descreening with 2D fast Fourier transform**: Reduce or remove periodic artifacts from images.\n- **Fast Fourier transforms**: Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Fourier transforms**: Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use 1D fast Fourier transform to compute the frequency components of a signal.",
          "name" : "Finding the component frequencies in a composite sine wave",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave"
        },
        {
          "description" : "Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.",
          "name" : "Performing Fourier transforms on interleaved-complex data",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data"
        },
        {
          "description" : "Multiply signal data by window sequence values when performing transforms with noninteger period signals.",
          "name" : "Reducing spectral leakage with windowing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing"
        },
        {
          "description" : "Use Accelerate’s discrete cosine transform to remove noise from a signal.",
          "name" : "Signal extraction from noise",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise"
        },
        {
          "description" : "Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.",
          "name" : "Performing Fourier Transforms on Multiple Signals",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals"
        },
        {
          "description" : "Reduce or remove periodic artifacts from images.",
          "name" : "Halftone descreening with 2D fast Fourier transform",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform"
        },
        {
          "description" : "Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Fast Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/fast-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Discrete Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Fourier and Cosine Transforms"
    }
  ],
  "source" : "appleJSON",
  "title" : "Understanding data packing for Fourier transforms",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms"
}