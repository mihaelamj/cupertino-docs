{
  "abstract" : "Use vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.",
  "codeExamples" : [
    {
      "code" : "let a = simd_float4(x: 2, y: 4, z: 5, w: 8)\nlet b = simd_float4(x: 5, y: 6, z: 7, w: 8)",
      "language" : "swift"
    },
    {
      "code" : "let c = a + b    \/\/ c = (7.0, 10.0, 12.0, 16.0)",
      "language" : "swift"
    },
    {
      "code" : "func lumaForColor(red: Float, green: Float, blue: Float) -> Float {\n    let luma = (red * 0.2126) +\n               (green * 0.7152) +\n               (blue * 0.0722)\n    \n    return luma\n}",
      "language" : "swift"
    },
    {
      "code" : "let rec709Luma = simd_float3(0.2126, 0.7152, 0.0722)\n\nfunc lumaForColor(red: Float, green: Float, blue: Float) -> Float {\n    let luma = simd_dot(rec709Luma,\n                        simd_float3(red, green, blue))\n    \n    return luma\n}",
      "language" : "swift"
    },
    {
      "code" : "let a = simd_float2(x: 3, y: 4)\nlet b = simd_float2(x: 0, y: 0)\n\n\/\/ Both distance and length = 5\nlet dist = simd_distance(a, b)\nlet len = simd_length(a)",
      "language" : "swift"
    },
    {
      "code" : "let target = simd_float2(x: 5, y: 2)\n\nif simd_distance_squared(a, target) < simd_distance_squared(b, target) {\n    \/\/ `a` is closest to `target`\n} else {\n    \/\/ `b` is closest to `target`\n}",
      "language" : "swift"
    },
    {
      "code" : "let incident = simd_normalize(simd_double2(x: 1.5, y: -1))\nlet normal = simd_normalize(simd_double2(x: 0, y: 1))",
      "language" : "swift"
    },
    {
      "code" : "let reflected = simd_reflect(incident, normal)",
      "language" : "swift"
    },
    {
      "code" : "let air = 1.0       \/\/ refractive index for air\nlet glass = 1.5     \/\/ refractive index for glass\nlet refracted = simd_refract(incident, normal, air \/ glass)",
      "language" : "swift"
    },
    {
      "code" : "let vertex1 = simd_float3(-1.5, 0.5, 0)\nlet vertex2 = simd_float3(1, 0, 3)\nlet vertex3 = simd_float3(0.5, -0.5, -1.5)",
      "language" : "swift"
    },
    {
      "code" : "let vector1 = vertex2 - vertex3\nlet vector2 = vertex2 - vertex1",
      "language" : "swift"
    },
    {
      "code" : "let normal = simd_normalize(simd_cross(vector1, vector2)) ",
      "language" : "swift"
    },
    {
      "code" : "let linear: [Float] = stride(from: 0.0, to: 1.0, by: 1 \/ 1024).map { x in\n    return simd_mix(-100, 100, x)\n}",
      "language" : "swift"
    },
    {
      "code" : "simd_double4 simd_smoothstep(simd_double4 edge0, simd_double4 edge1, simd_double4 x) {\n  simd_double4 t = simd_clamp((x - edge0)\/(edge1 - edge0), 0, 1);\n  return t*t*(3 - 2*t);\n}",
      "language" : "objc"
    },
    {
      "code" : "let smooth: [Float] = (-512 ..< 512).map { x in\n    return simd_smoothstep(-512, 512, Float(x))\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "93763bc51ba87cdcabe7ab5e2f7d516a6ba70b18cef63cf74d4aa9f44640d60c",
  "crawledAt" : "2025-12-02T15:37:24Z",
  "id" : "263373EA-876C-4007-8A17-C5E4CCEF2599",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nA vector is comparable to a fixed-length array containing integer or floating-point values. The simd framework provides support for *small vectors*, that is, vectors that contain up to eight double-precision or sixteen single-precision values.\n\nThe simd framework includes a wide-range of functions to operate on vectors that includes data type conversion, logical and bitwise operations, and mathematical operations.\n\nYou can use vectors to represent data such as color (with the elements containing values for red, green, blue, and alpha), or position (with the elements containing values for coordinates in 2D or 3D space).\n\nYou can use the simd framework to apply a single instruction to each element in the vector. For example, consider two vectors, each containing four elements:\n\nYou can easily find, for example, the elementwise sum of the two vectors by using the + operator:\n\nThe following examples show a few common uses of vectors.\n\n### Calculate Luminance\n\nYou can calculate the luminance of a color by multiplying each of its red, green, and blue color channels by a certain coefficient, and adding the three products together—creating a grayscale representation of the color. The following code uses the Rec. 709 luma coefficients for the color-to-grayscale conversion. Without the simd framework, you could implement this calculation using the following code:\n\nThe simd framework simplifies this code by treating the color and the coefficients as vectors, and returning the dot product (the sum of the elementwise products) of the vectors:\n\n### Calculate Length and Distance\n\nCalculating the distance between two points using the Pythagorean theorem is a common task in games and graphics programming. The simd framework provides functions for calculating length and distance in two, three, and four dimensions.\n\n#### Calculate Length\n\nThe length functions, for example, [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_length-3ob5d], return the length of a vector. The following illustration shows how the length of a vector, *A*, is calculated as the square root of the sum of the squares of its two values.\n\n\n\n#### Calculate Distance\n\nThe distance functions, for example, [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_distance-598wa], return the distance between two vectors:\n\n\n\nThe following code shows how the length function returns the same value as the distance function if one of the vectors contains all zeros:\n\n#### Compare Distances\n\nBecause the distance and length functions both calculate the square root of the sum of the squares of the vectors, they can be computationally expensive. If you don’t need the exact value—for example, if you’re comparing the relative lengths of two vectors—simd provides functions that return the square of the distance and the length.\n\nThe following code shows how you can determine which of the two vectors defined above is closer to a third vector, `target`:\n\n### Calculate Reflection and Refraction Vectors\n\nThe simd framework provides functions for calculating vectors that describe reflections and refractions in two-, three-, and four-dimensional space. The image below shows:\n\n\n\n#### Normalize Vectors\n\nYou normalize the vectors (calculate a vector with the same direction as the original, but with a length of 1) passed to the reflect and refract functions to achieve the correct results. Given the values above, the following code defines normalized vectors for the incident ray and normal:\n\n#### Calculate Reflection\n\nYou get the reflected vector with [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_reflect-7c8f9]:\n\n#### Calculate Refraction\n\nFor the refraction function, you pass an additional parameter (`eta`) that models the index of refraction for physical materials:\n\n### Calculate the Normal of a Triangle\n\nThe normal of a triangle in 3D space is the vector perpendicular to its surface. You can use the simd framework’s cross product function to calculate the normal of a triangle. This is a common task in 3D graphics programming and is used when calculating the shading of surfaces.\n\nIn the image below, the triangle’s normal is shown as a red line that’s perpendicular to the surface of the triangle.\n\n\n\nThe following code defines the three vertices of the triangle:\n\nYour first step in calculating the normal of the triangle is to create two vectors defined by the difference between the vertices—representing two sides of the triangle:\n\nThe `simd_cross` function returns the vector that’s perpendicular to the two vectors you pass it. In this example, the returned vector is the normal of the triangle. Because the normal represents a direction, you can normalize the value to get a unit vector:\n\n### Interpolate Between Values\n\nInterpolation adds new, intermediate data points between known values. The simd framework provides functions to linearly and smoothly interpolate between scalar and vector values. Smooth interpolation is commonly used in animation, and you can, for example, use the functions described below to define the [doc:\/\/com.apple.documentation\/documentation\/SpriteKit\/SKAction\/timingFunction] of a SpriteKit action.\n\nThe following illustration shows how linear interpolation creates a straight line between boundary values (the straight blue line), and how smooth interpolation eases in and out between boundary values (the curved pink line):\n\n\n\n#### Linearly Interpolate\n\nLinear interpolation is provided by the `simd_mix` function. The first two parameters specify the range, and the third parameter specifies the normalized (between `0` and `1`) position in the range. The following code shows how to populate an array with 1024 elements. The first element in the array has a value of -100, and the last element of the array has a value of 100. Intermediate elements linearly interpolate between the first and last values:\n\n#### Smoothly Interpolate\n\nSmooth interpolation is provided by the `simd_smoothstep` function. This function uses Hermite interpolation based on the following code:\n\nThe first two parameters specify the range, and the third parameter specifies the position in the range. Unlike the mix function, the position isn’t normalized, but the return value is.\n\nThe following code shows how to populate an array with 1024 elements. The first element in the array has a value of 0, and the last element of the array has a value of 1. Intermediate elements smoothly interpolate between the first and last values:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-vectors\ncrawled: 2025-12-02T15:37:24Z\n---\n\n# Working with Vectors\n\n**Article**\n\nUse vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.\n\n## Overview\n\nA vector is comparable to a fixed-length array containing integer or floating-point values. The simd framework provides support for *small vectors*, that is, vectors that contain up to eight double-precision or sixteen single-precision values.\n\nThe simd framework includes a wide-range of functions to operate on vectors that includes data type conversion, logical and bitwise operations, and mathematical operations.\n\nYou can use vectors to represent data such as color (with the elements containing values for red, green, blue, and alpha), or position (with the elements containing values for coordinates in 2D or 3D space).\n\nYou can use the simd framework to apply a single instruction to each element in the vector. For example, consider two vectors, each containing four elements:\n\n```swift\nlet a = simd_float4(x: 2, y: 4, z: 5, w: 8)\nlet b = simd_float4(x: 5, y: 6, z: 7, w: 8)\n```\n\nYou can easily find, for example, the elementwise sum of the two vectors by using the + operator:\n\n```swift\nlet c = a + b    \/\/ c = (7.0, 10.0, 12.0, 16.0)\n```\n\nThe following examples show a few common uses of vectors.\n\n### Calculate Luminance\n\nYou can calculate the luminance of a color by multiplying each of its red, green, and blue color channels by a certain coefficient, and adding the three products together—creating a grayscale representation of the color. The following code uses the Rec. 709 luma coefficients for the color-to-grayscale conversion. Without the simd framework, you could implement this calculation using the following code:\n\n```swift\nfunc lumaForColor(red: Float, green: Float, blue: Float) -> Float {\n    let luma = (red * 0.2126) +\n               (green * 0.7152) +\n               (blue * 0.0722)\n    \n    return luma\n}\n```\n\nThe simd framework simplifies this code by treating the color and the coefficients as vectors, and returning the dot product (the sum of the elementwise products) of the vectors:\n\n```swift\nlet rec709Luma = simd_float3(0.2126, 0.7152, 0.0722)\n\nfunc lumaForColor(red: Float, green: Float, blue: Float) -> Float {\n    let luma = simd_dot(rec709Luma,\n                        simd_float3(red, green, blue))\n    \n    return luma\n}\n```\n\n### Calculate Length and Distance\n\nCalculating the distance between two points using the Pythagorean theorem is a common task in games and graphics programming. The simd framework provides functions for calculating length and distance in two, three, and four dimensions.\n\n#### Calculate Length\n\nThe length functions, for example, [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_length-3ob5d], return the length of a vector. The following illustration shows how the length of a vector, *A*, is calculated as the square root of the sum of the squares of its two values.\n\n\n\n#### Calculate Distance\n\nThe distance functions, for example, [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_distance-598wa], return the distance between two vectors:\n\n\n\nThe following code shows how the length function returns the same value as the distance function if one of the vectors contains all zeros:\n\n```swift\nlet a = simd_float2(x: 3, y: 4)\nlet b = simd_float2(x: 0, y: 0)\n\n\/\/ Both distance and length = 5\nlet dist = simd_distance(a, b)\nlet len = simd_length(a)\n```\n\n#### Compare Distances\n\nBecause the distance and length functions both calculate the square root of the sum of the squares of the vectors, they can be computationally expensive. If you don’t need the exact value—for example, if you’re comparing the relative lengths of two vectors—simd provides functions that return the square of the distance and the length.\n\nThe following code shows how you can determine which of the two vectors defined above is closer to a third vector, `target`:\n\n```swift\nlet target = simd_float2(x: 5, y: 2)\n\nif simd_distance_squared(a, target) < simd_distance_squared(b, target) {\n    \/\/ `a` is closest to `target`\n} else {\n    \/\/ `b` is closest to `target`\n}\n```\n\n### Calculate Reflection and Refraction Vectors\n\nThe simd framework provides functions for calculating vectors that describe reflections and refractions in two-, three-, and four-dimensional space. The image below shows:\n\n- An *incident ray*, described by the vector `simd_double2(x: 1.5, y: -1)`, traveling toward the center of the image.\n- A *normal*, described by the vector `simd_double2(x: 0, y: 1)`, that’s perpendicular to the interface between the two media.\n- The *reflected ray*, computed by simd, traveling away from the center of the image.\n- The *refracted ray*, computed by simd, traveling away from the center of the image.\n\n\n\n#### Normalize Vectors\n\nYou normalize the vectors (calculate a vector with the same direction as the original, but with a length of 1) passed to the reflect and refract functions to achieve the correct results. Given the values above, the following code defines normalized vectors for the incident ray and normal:\n\n```swift\nlet incident = simd_normalize(simd_double2(x: 1.5, y: -1))\nlet normal = simd_normalize(simd_double2(x: 0, y: 1))\n```\n\n#### Calculate Reflection\n\nYou get the reflected vector with [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_reflect-7c8f9]:\n\n```swift\nlet reflected = simd_reflect(incident, normal)\n```\n\n#### Calculate Refraction\n\nFor the refraction function, you pass an additional parameter (`eta`) that models the index of refraction for physical materials:\n\n```swift\nlet air = 1.0       \/\/ refractive index for air\nlet glass = 1.5     \/\/ refractive index for glass\nlet refracted = simd_refract(incident, normal, air \/ glass)\n```\n\n### Calculate the Normal of a Triangle\n\nThe normal of a triangle in 3D space is the vector perpendicular to its surface. You can use the simd framework’s cross product function to calculate the normal of a triangle. This is a common task in 3D graphics programming and is used when calculating the shading of surfaces.\n\nIn the image below, the triangle’s normal is shown as a red line that’s perpendicular to the surface of the triangle.\n\n\n\nThe following code defines the three vertices of the triangle:\n\n```swift\nlet vertex1 = simd_float3(-1.5, 0.5, 0)\nlet vertex2 = simd_float3(1, 0, 3)\nlet vertex3 = simd_float3(0.5, -0.5, -1.5)\n```\n\nYour first step in calculating the normal of the triangle is to create two vectors defined by the difference between the vertices—representing two sides of the triangle:\n\n```swift\nlet vector1 = vertex2 - vertex3\nlet vector2 = vertex2 - vertex1\n```\n\nThe `simd_cross` function returns the vector that’s perpendicular to the two vectors you pass it. In this example, the returned vector is the normal of the triangle. Because the normal represents a direction, you can normalize the value to get a unit vector:\n\n```swift\nlet normal = simd_normalize(simd_cross(vector1, vector2)) \n```\n\n### Interpolate Between Values\n\nInterpolation adds new, intermediate data points between known values. The simd framework provides functions to linearly and smoothly interpolate between scalar and vector values. Smooth interpolation is commonly used in animation, and you can, for example, use the functions described below to define the [doc:\/\/com.apple.documentation\/documentation\/SpriteKit\/SKAction\/timingFunction] of a SpriteKit action.\n\nThe following illustration shows how linear interpolation creates a straight line between boundary values (the straight blue line), and how smooth interpolation eases in and out between boundary values (the curved pink line):\n\n\n\n#### Linearly Interpolate\n\nLinear interpolation is provided by the `simd_mix` function. The first two parameters specify the range, and the third parameter specifies the normalized (between `0` and `1`) position in the range. The following code shows how to populate an array with 1024 elements. The first element in the array has a value of -100, and the last element of the array has a value of 100. Intermediate elements linearly interpolate between the first and last values:\n\n```swift\nlet linear: [Float] = stride(from: 0.0, to: 1.0, by: 1 \/ 1024).map { x in\n    return simd_mix(-100, 100, x)\n}\n```\n\n#### Smoothly Interpolate\n\nSmooth interpolation is provided by the `simd_smoothstep` function. This function uses Hermite interpolation based on the following code:\n\n```objc\nsimd_double4 simd_smoothstep(simd_double4 edge0, simd_double4 edge1, simd_double4 x) {\n  simd_double4 t = simd_clamp((x - edge0)\/(edge1 - edge0), 0, 1);\n  return t*t*(3 - 2*t);\n}\n```\n\nThe first two parameters specify the range, and the third parameter specifies the position in the range. Unlike the mix function, the position isn’t normalized, but the return value is.\n\nThe following code shows how to populate an array with 1024 elements. The first element in the array has a value of 0, and the last element of the array has a value of 1. Intermediate elements smoothly interpolate between the first and last values:\n\n```swift\nlet smooth: [Float] = (-512 ..< 512).map { x in\n    return simd_smoothstep(-512, 512, Float(x))\n}\n```\n\n## Vectors, Matrices, and Quaternions\n\n- **Working with Matrices**: Solve simultaneous equations and transform points in space.\n- **Working with Quaternions**: Rotate points around the surface of a sphere, and interpolate between them.\n- **Rotating a cube by transforming its vertices**: Rotate a cube through a series of keyframes using quaternion interpolation to transition between them.\n- **simd**: Perform computations on small vectors and matrices.\n- **vForce**: Perform transcendental and trigonometric functions on vectors of any length.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Solve simultaneous equations and transform points in space.",
          "name" : "Working with Matrices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-matrices"
        },
        {
          "description" : "Rotate points around the surface of a sphere, and interpolate between them.",
          "name" : "Working with Quaternions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-quaternions"
        },
        {
          "description" : "Rotate a cube through a series of keyframes using quaternion interpolation to transition between them.",
          "name" : "Rotating a cube by transforming its vertices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/rotating-a-cube-by-transforming-its-vertices"
        },
        {
          "description" : "Perform computations on small vectors and matrices.",
          "name" : "simd",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/simd-library"
        },
        {
          "description" : "Perform transcendental and trigonometric functions on vectors of any length.",
          "name" : "vForce",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vforce-library"
        }
      ],
      "title" : "Vectors, Matrices, and Quaternions"
    }
  ],
  "source" : "appleJSON",
  "title" : "Working with Vectors",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-vectors"
}