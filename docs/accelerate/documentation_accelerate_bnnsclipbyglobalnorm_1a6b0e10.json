{
  "abstract" : "Clips a tensor’s values to a maximum global Euclidean norm.",
  "codeExamples" : [
    {
      "code" : "static func clipToGlobalNorm() {\n    \n    let inputOneData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    _ = inputOneData.initialize(from: [1, 2, 3, 4])\n    let inputOneDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                   layout: BNNSDataLayoutVector,\n                                                   size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                   data: inputOneData.baseAddress!,\n                                                   data_type: BNNSDataType.float,\n                                                   table_data: nil,\n                                                   table_data_type: BNNSDataType.float,\n                                                   data_scale: 1, data_bias: 0)\n    \n    let inputTwoData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    _ = inputTwoData.initialize(from: [5, 6, 7, 8])\n    let inputTwoDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                   layout: BNNSDataLayoutVector,\n                                                   size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                   data: inputTwoData.baseAddress!,\n                                                   data_type: BNNSDataType.float,\n                                                   table_data: nil,\n                                                   table_data_type: BNNSDataType.float,\n                                                   data_scale: 1, data_bias: 0)\n    \n    let outputOneData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    let outputOneDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                    layout: BNNSDataLayoutVector,\n                                                    size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                    stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                    data: outputOneData.baseAddress!,\n                                                    data_type: BNNSDataType.float,\n                                                    table_data: nil,\n                                                    table_data_type: BNNSDataType.float,\n                                                    data_scale: 1, data_bias: 0)\n    \n    let outputTwoData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    let outputTwoDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                    layout: BNNSDataLayoutVector,\n                                                    size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                    stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                    data: outputTwoData.baseAddress!,\n                                                    data_type: BNNSDataType.float,\n                                                    table_data: nil,\n                                                    table_data_type: BNNSDataType.float,\n                                                    data_scale: 1, data_bias: 0)\n    \n    let inputs = [inputOneDescriptor, inputTwoDescriptor]\n    var inputsPointers: [UnsafePointer<BNNSNDArrayDescriptor>] = inputs.map { input in\n        var descriptor = input\n        \n        let inputPtr = UnsafeMutablePointer<BNNSNDArrayDescriptor>.allocate(capacity: 1)\n        inputPtr.initialize(from: &descriptor, count: 1)\n        \n        return UnsafePointer(inputPtr)\n    }\n    \n    let outputs = [outputOneDescriptor, outputTwoDescriptor]\n    var outputsPointers: [UnsafeMutablePointer<BNNSNDArrayDescriptor>] = outputs.map { output in\n        var descriptor = output\n        \n        let outputPtr = UnsafeMutablePointer<BNNSNDArrayDescriptor>.allocate(capacity: 1)\n        outputPtr.initialize(from: &descriptor, count: 1)\n        \n        return outputPtr\n    }\n    \n    BNNSClipByGlobalNorm(&outputsPointers,\n                         &inputsPointers,\n                         2,\n                         0.5 * 14.2828568570857,\n                         0)\n    \n    \/\/ Prints: `[0.5, 1.0, 1.5, 2.0]`\n    print(Array(outputOneData))\n    \n    \/\/ Prints: `[2.5, 3.0, 3.5, 4.0]`\n    print(Array(outputTwoData))\n    \n    inputOneData.deallocate()\n    inputTwoData.deallocate()\n    outputOneData.deallocate()\n    outputTwoData.deallocate()\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "5c031b516e05a5acc16b226feb643febcd504bc0338503743b9ba07a41a28245",
  "crawledAt" : "2025-12-03T20:37:11Z",
  "declaration" : {
    "code" : "func BNNSClipByGlobalNorm(_ dest: UnsafeMutablePointer<UnsafeMutablePointer<BNNSNDArrayDescriptor>>, _ src: UnsafeMutablePointer<UnsafePointer<BNNSNDArrayDescriptor>>, _ count: Int, _ max_norm: Float, _ use_norm: Float) -> Int32",
    "language" : "swift"
  },
  "id" : "6CBCD14A-3EE3-40FD-BCCF-27F88523B229",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nUse this function to clip the values in an array of input tensors to a maximum Euclidean norm. If you know the global norm of the input tensors, pass this value as the `use_norm`. Otherwise, pass `0` to specify that the function calculates the norm.\n\nThe Euclidean norm is the square root of the sum of squares of the two tensors. The following code clips the Euclidean norm of two input tensors to half of the global Euclidean norm:\n\nOn return, `outputOne` contains the values `[0.5, 1.0, 1.5, 2.0]`, and `outputTwo` contains the values `[2.5, 3.0, 3.5, 4.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSClipByGlobalNorm(_:_:_:_:_:)\ncrawled: 2025-12-03T20:37:11Z\n---\n\n# BNNSClipByGlobalNorm(_:_:_:_:_:)\n\n**Function**\n\nClips a tensor’s values to a maximum global Euclidean norm.\n\n## Declaration\n\n```swift\nfunc BNNSClipByGlobalNorm(_ dest: UnsafeMutablePointer<UnsafeMutablePointer<BNNSNDArrayDescriptor>>, _ src: UnsafeMutablePointer<UnsafePointer<BNNSNDArrayDescriptor>>, _ count: Int, _ max_norm: Float, _ use_norm: Float) -> Int32\n```\n\n## Parameters\n\n- **dest**: An array of output descriptors.\n- **src**: An array of input descriptors.\n- **count**: The number of input and output descriptors.\n- **max_norm**: The maximum global Euclidean norm.\n- **use_norm**: An optional value for a known global Euclidean norm. Set to `0` to specify that the function computes the norm from the input descriptors.\n\n## Discussion\n\nUse this function to clip the values in an array of input tensors to a maximum Euclidean norm. If you know the global norm of the input tensors, pass this value as the `use_norm`. Otherwise, pass `0` to specify that the function calculates the norm.\n\nThe Euclidean norm is the square root of the sum of squares of the two tensors. The following code clips the Euclidean norm of two input tensors to half of the global Euclidean norm:\n\n```swift\nstatic func clipToGlobalNorm() {\n    \n    let inputOneData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    _ = inputOneData.initialize(from: [1, 2, 3, 4])\n    let inputOneDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                   layout: BNNSDataLayoutVector,\n                                                   size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                   data: inputOneData.baseAddress!,\n                                                   data_type: BNNSDataType.float,\n                                                   table_data: nil,\n                                                   table_data_type: BNNSDataType.float,\n                                                   data_scale: 1, data_bias: 0)\n    \n    let inputTwoData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    _ = inputTwoData.initialize(from: [5, 6, 7, 8])\n    let inputTwoDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                   layout: BNNSDataLayoutVector,\n                                                   size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                   data: inputTwoData.baseAddress!,\n                                                   data_type: BNNSDataType.float,\n                                                   table_data: nil,\n                                                   table_data_type: BNNSDataType.float,\n                                                   data_scale: 1, data_bias: 0)\n    \n    let outputOneData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    let outputOneDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                    layout: BNNSDataLayoutVector,\n                                                    size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                    stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                    data: outputOneData.baseAddress!,\n                                                    data_type: BNNSDataType.float,\n                                                    table_data: nil,\n                                                    table_data_type: BNNSDataType.float,\n                                                    data_scale: 1, data_bias: 0)\n    \n    let outputTwoData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 4)\n    let outputTwoDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                    layout: BNNSDataLayoutVector,\n                                                    size: (4, 0, 0, 0, 0, 0, 0, 0),\n                                                    stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                    data: outputTwoData.baseAddress!,\n                                                    data_type: BNNSDataType.float,\n                                                    table_data: nil,\n                                                    table_data_type: BNNSDataType.float,\n                                                    data_scale: 1, data_bias: 0)\n    \n    let inputs = [inputOneDescriptor, inputTwoDescriptor]\n    var inputsPointers: [UnsafePointer<BNNSNDArrayDescriptor>] = inputs.map { input in\n        var descriptor = input\n        \n        let inputPtr = UnsafeMutablePointer<BNNSNDArrayDescriptor>.allocate(capacity: 1)\n        inputPtr.initialize(from: &descriptor, count: 1)\n        \n        return UnsafePointer(inputPtr)\n    }\n    \n    let outputs = [outputOneDescriptor, outputTwoDescriptor]\n    var outputsPointers: [UnsafeMutablePointer<BNNSNDArrayDescriptor>] = outputs.map { output in\n        var descriptor = output\n        \n        let outputPtr = UnsafeMutablePointer<BNNSNDArrayDescriptor>.allocate(capacity: 1)\n        outputPtr.initialize(from: &descriptor, count: 1)\n        \n        return outputPtr\n    }\n    \n    BNNSClipByGlobalNorm(&outputsPointers,\n                         &inputsPointers,\n                         2,\n                         0.5 * 14.2828568570857,\n                         0)\n    \n    \/\/ Prints: `[0.5, 1.0, 1.5, 2.0]`\n    print(Array(outputOneData))\n    \n    \/\/ Prints: `[2.5, 3.0, 3.5, 4.0]`\n    print(Array(outputTwoData))\n    \n    inputOneData.deallocate()\n    inputTwoData.deallocate()\n    outputOneData.deallocate()\n    outputTwoData.deallocate()\n}\n```\n\nOn return, `outputOne` contains the values `[0.5, 1.0, 1.5, 2.0]`, and `outputTwo` contains the values `[2.5, 3.0, 3.5, 4.0]`.\n\n## Utility functions\n\n- **copy(_:to:filterParameters:)**: Copies the contents of an n-dimensional array descriptor to another descriptor of the same shape.\n- **transpose(input:output:firstTransposeAxis:secondTransposeAxis:filterParameters:)**: Transposes a tensor by swapping two of its dimensions.\n- **BNNSCopy(_:_:_:)**: Copies the contents of an n-dimensional array descriptor to another of the same shape.\n- **BNNSTranspose(_:_:_:_:_:)**: Transposes a tensor by swapping two of its dimensions.\n- **BNNSGetPointer(_:_:)**: Returns an n-dimensional array descriptor that contains a reference to a filter-data member.\n- **BNNSPointerSpecifier**: Constants that specify which pointer the BNNS get filter function returns.\n- **BNNS.GramLayer**: A layer object that wraps a Gram matrix filter and manages its deinitialization.\n- **BNNSLayerParametersGram**: A set of parameters that define a Gram matrix layer.\n- **BNNSFilterCreateLayerGram(_:_:)**: Returns a new Gram matrix layer.\n- **clip(to:input:output:)**: Clips the input tensor to a closed range and writes the result to the output tensor.\n- **clipByNorm(threshold:input:output:axes:)**: Clips the input tensor to a Euclidean norm and writes the result to the output tensor.\n- **clipByGlobalNorm(threshold:inputs:outputs:globalNorm:)**: Clips the input tensors to a global Euclidean norm and writes the result to the output tensors.\n- **BNNSClipByValue(_:_:_:_:)**: Clips a tensor’s values to the specified minimum and maximum values.\n- **BNNSClipByNorm(_:_:_:_:)**: Clips a tensor’s values to a maximum Euclidean norm.\n- **copyBandPart(_:to:lowerBandCount:upperBandCount:filterParameters:)**: Copies the specified subdiagonals and superdiagonals of a matrix, and sets other elements to zero.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Copies the contents of an n-dimensional array descriptor to another descriptor of the same shape.",
          "name" : "copy(_:to:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/copy(_:to:filterParameters:)"
        },
        {
          "description" : "Transposes a tensor by swapping two of its dimensions.",
          "name" : "transpose(input:output:firstTransposeAxis:secondTransposeAxis:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/transpose(input:output:firstTransposeAxis:secondTransposeAxis:filterParameters:)"
        },
        {
          "description" : "Copies the contents of an n-dimensional array descriptor to another of the same shape.",
          "name" : "BNNSCopy(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSCopy(_:_:_:)"
        },
        {
          "description" : "Transposes a tensor by swapping two of its dimensions.",
          "name" : "BNNSTranspose(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSTranspose(_:_:_:_:_:)"
        },
        {
          "description" : "Returns an n-dimensional array descriptor that contains a reference to a filter-data member.",
          "name" : "BNNSGetPointer(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSGetPointer(_:_:)"
        },
        {
          "description" : "Constants that specify which pointer the BNNS get filter function returns.",
          "name" : "BNNSPointerSpecifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSPointerSpecifier"
        },
        {
          "description" : "A layer object that wraps a Gram matrix filter and manages its deinitialization.",
          "name" : "BNNS.GramLayer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/GramLayer"
        },
        {
          "description" : "A set of parameters that define a Gram matrix layer.",
          "name" : "BNNSLayerParametersGram",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSLayerParametersGram"
        },
        {
          "description" : "Returns a new Gram matrix layer.",
          "name" : "BNNSFilterCreateLayerGram(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFilterCreateLayerGram(_:_:)"
        },
        {
          "description" : "Clips the input tensor to a closed range and writes the result to the output tensor.",
          "name" : "clip(to:input:output:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/clip(to:input:output:)"
        },
        {
          "description" : "Clips the input tensor to a Euclidean norm and writes the result to the output tensor.",
          "name" : "clipByNorm(threshold:input:output:axes:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/clipByNorm(threshold:input:output:axes:)"
        },
        {
          "description" : "Clips the input tensors to a global Euclidean norm and writes the result to the output tensors.",
          "name" : "clipByGlobalNorm(threshold:inputs:outputs:globalNorm:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/clipByGlobalNorm(threshold:inputs:outputs:globalNorm:)"
        },
        {
          "description" : "Clips a tensor’s values to the specified minimum and maximum values.",
          "name" : "BNNSClipByValue(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSClipByValue(_:_:_:_:)"
        },
        {
          "description" : "Clips a tensor’s values to a maximum Euclidean norm.",
          "name" : "BNNSClipByNorm(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSClipByNorm(_:_:_:_:)"
        },
        {
          "description" : "Copies the specified subdiagonals and superdiagonals of a matrix, and sets other elements to zero.",
          "name" : "copyBandPart(_:to:lowerBandCount:upperBandCount:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/copyBandPart(_:to:lowerBandCount:upperBandCount:filterParameters:)"
        }
      ],
      "title" : "Utility functions"
    }
  ],
  "source" : "appleJSON",
  "title" : "BNNSClipByGlobalNorm(_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSClipByGlobalNorm(_:_:_:_:_:)"
}