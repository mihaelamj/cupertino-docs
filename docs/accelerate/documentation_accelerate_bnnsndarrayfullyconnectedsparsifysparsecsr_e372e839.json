{
  "abstract" : "Converts a sparse tensor from the standardized compressed sparse row (CSR) layout to a device-specific sparse layout that BNNS fully connected layers use.",
  "codeExamples" : [
    {
      "code" : " 1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  2.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  3.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  4.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  5.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  6.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  7.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  8.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  9.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 10.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 11.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 12.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 13.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 14.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 15.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 16.0",
      "language" : "swift"
    },
    {
      "code" : "let weightsData: [Float] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\nlet columnIndices: [Int32] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nlet rowStarts: [Int32] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]",
      "language" : "swift"
    },
    {
      "code" : "let nnz = weightsData.count\n\nvar inputDenseShape = BNNSNDArrayDescriptor(dataType: BNNSDataType.float,\n                                            shape: .matrixRowMajor(16, 16))\nvar inputColumnIndices = BNNSNDArrayDescriptor.allocate(initializingFrom: columnIndices,\n                                                        shape: .vector(nnz))\nvar inputRowStarts = BNNSNDArrayDescriptor.allocate(initializingFrom: rowStarts,\n                                                    shape: .vector(rowStarts.count))\nvar inputWeights = BNNSNDArrayDescriptor.allocate(initializingFrom: weightsData,\n                                                  shape: .vector(nnz))\n\nvar sparsifiedWeights = BNNSNDArrayDescriptor()\n\nvar sparseParams = BNNSSparsityParameters()\n\nBNNSNDArrayFullyConnectedSparsifySparseCSR(&inputDenseShape,\n                                           &inputColumnIndices,\n                                           &inputRowStarts,\n                                           &inputWeights,\n                                           &sparsifiedWeights,\n                                           &sparseParams,\n                                           1,\n                                           nil, nil)",
      "language" : "swift"
    }
  ],
  "contentHash" : "5e7000fb156b4e7887984b4b6162bdd5c33fb67899405e39dfdc92d32df6adc9",
  "crawledAt" : "2025-12-02T21:56:44Z",
  "declaration" : {
    "code" : "func BNNSNDArrayFullyConnectedSparsifySparseCSR(_ in_dense_shape: UnsafePointer<BNNSNDArrayDescriptor>, _ in_column_indices: UnsafePointer<BNNSNDArrayDescriptor>, _ in_row_starts: UnsafePointer<BNNSNDArrayDescriptor>, _ in_values: UnsafePointer<BNNSNDArrayDescriptor>, _ out: UnsafeMutablePointer<BNNSNDArrayDescriptor>, _ sparse_params: UnsafePointer<BNNSSparsityParameters>?, _ batch_size: Int, _ workspace: UnsafeMutableRawPointer?, _ workspace_size: Int, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> Int32",
    "language" : "swift"
  },
  "id" : "2436AF89-0144-476F-83FF-012A94AF9948",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nThe growing energy and performance costs of deep learning are driving its design towards more efficient models to minimize memory footprint and computational overhead. Sparsity is a widely used approach to deliver a significant reduction in model size, and to corresponding gains in computational, storage, and energy efficiency, without significant loss of accuracy.\n\nPruning is a fundamental technique that’s used to make parameters, such as weights, sparse. Pruning a parameter involves setting some of its values to zero and it’s only the nonzero values that are stored and participate in inference.\n\nFrameworks that sparsify parameters prune values based on their magnitude and location. To gain the greatest improvement in performance, chunk pruned values together, to allow the CPU to skip reading an entire tile.\n\nBNNS doesn’t directly support the standard sparse layouts coordinate list (COO) or compressed sparse row (CSR). Instead, BNNS provides functions that convert COO and CSR data to an optimized, opaque layout that you use with the existing machine learning primitives such as fully connected.\n\nFor example, the following diagonal, single-precision matrix requires 1024 bytes of storage:\n\nYou can represent the same values in CSR format as three arrays: the nonzero format as three arrays: the nonzero values, the column indices, and a third array that specifies where each row starts. In the following example, the zeroth item in the values array starts row `0`, the item at element `1` starts column `1`, and so on:\n\nPass the weights data, column indices, and row starts to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSNDArrayFullyConnectedSparsifySparseCSR(_:_:_:_:_:_:_:_:_:_:)] to generate the opaque sparse data for [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersFullyConnected].\n\nOn return, `sparsifiedWeights` contains the weights that you pass to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersFullyConnected]. In this example, the data size of `sparsifiedWeights` is 144 bytes.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/accelerate\/bnnsndarrayfullyconnectedsparsifysparsecsr(_:_:_:_:_:_:_:_:_:_:)\ncrawled: 2025-12-02T21:56:44Z\n---\n\n# BNNSNDArrayFullyConnectedSparsifySparseCSR(_:_:_:_:_:_:_:_:_:_:)\n\n**Function**\n\nConverts a sparse tensor from the standardized compressed sparse row (CSR) layout to a device-specific sparse layout that BNNS fully connected layers use.\n\n## Declaration\n\n```swift\nfunc BNNSNDArrayFullyConnectedSparsifySparseCSR(_ in_dense_shape: UnsafePointer<BNNSNDArrayDescriptor>, _ in_column_indices: UnsafePointer<BNNSNDArrayDescriptor>, _ in_row_starts: UnsafePointer<BNNSNDArrayDescriptor>, _ in_values: UnsafePointer<BNNSNDArrayDescriptor>, _ out: UnsafeMutablePointer<BNNSNDArrayDescriptor>, _ sparse_params: UnsafePointer<BNNSSparsityParameters>?, _ batch_size: Int, _ workspace: UnsafeMutableRawPointer?, _ workspace_size: Int, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> Int32\n```\n\n## Parameters\n\n- **in_dense_shape**: An array descriptor that specifies the dense shape (that is, the size and layout) of the input array.\n- **in_column_indices**: A 1D array descriptor with the shape `[NNZ]` that contains the column indices of the nonzero values.\n- **in_row_starts**: A 1D array descriptor with the shape `[row_size + 1]` that contains pointers to the start of each row. Set location `[0]` to `0`.\n- **in_values**: A 1D array descriptor with the shape `[NNZ]` that contains the nonzero input values.\n- **out**: On return, an array descriptor that contains device optimized BNNS sparse fully connected weights.\n- **sparse_params**: An optional data structure that contains a hint to the sparsity pattern.\n- **batch_size**: The expected batch size.\n- **workspace**: An optional pointer to scratch memory that’s at least twice the size of the dense input. Set to `nil` to specify that BNNS allocates and frees the scratch memory it requires.\n- **workspace_size**: The size, in bytes, of any scratch memory that you pass. If workspace is `nil`, this function ignores the `workspace_size` parameter.\n- **filter_params**: The runtime filter parameters.\n\n## Discussion\n\nThe growing energy and performance costs of deep learning are driving its design towards more efficient models to minimize memory footprint and computational overhead. Sparsity is a widely used approach to deliver a significant reduction in model size, and to corresponding gains in computational, storage, and energy efficiency, without significant loss of accuracy.\n\nPruning is a fundamental technique that’s used to make parameters, such as weights, sparse. Pruning a parameter involves setting some of its values to zero and it’s only the nonzero values that are stored and participate in inference.\n\nFrameworks that sparsify parameters prune values based on their magnitude and location. To gain the greatest improvement in performance, chunk pruned values together, to allow the CPU to skip reading an entire tile.\n\nBNNS doesn’t directly support the standard sparse layouts coordinate list (COO) or compressed sparse row (CSR). Instead, BNNS provides functions that convert COO and CSR data to an optimized, opaque layout that you use with the existing machine learning primitives such as fully connected.\n\nFor example, the following diagonal, single-precision matrix requires 1024 bytes of storage:\n\n```swift\n 1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  2.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  3.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  4.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  5.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  6.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  7.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  8.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  9.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 10.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 11.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 12.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 13.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 14.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 15.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 16.0\n```\n\nYou can represent the same values in CSR format as three arrays: the nonzero format as three arrays: the nonzero values, the column indices, and a third array that specifies where each row starts. In the following example, the zeroth item in the values array starts row `0`, the item at element `1` starts column `1`, and so on:\n\n```swift\nlet weightsData: [Float] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\nlet columnIndices: [Int32] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nlet rowStarts: [Int32] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n```\n\nPass the weights data, column indices, and row starts to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSNDArrayFullyConnectedSparsifySparseCSR(_:_:_:_:_:_:_:_:_:_:)] to generate the opaque sparse data for [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersFullyConnected].\n\n```swift\nlet nnz = weightsData.count\n\nvar inputDenseShape = BNNSNDArrayDescriptor(dataType: BNNSDataType.float,\n                                            shape: .matrixRowMajor(16, 16))\nvar inputColumnIndices = BNNSNDArrayDescriptor.allocate(initializingFrom: columnIndices,\n                                                        shape: .vector(nnz))\nvar inputRowStarts = BNNSNDArrayDescriptor.allocate(initializingFrom: rowStarts,\n                                                    shape: .vector(rowStarts.count))\nvar inputWeights = BNNSNDArrayDescriptor.allocate(initializingFrom: weightsData,\n                                                  shape: .vector(nnz))\n\nvar sparsifiedWeights = BNNSNDArrayDescriptor()\n\nvar sparseParams = BNNSSparsityParameters()\n\nBNNSNDArrayFullyConnectedSparsifySparseCSR(&inputDenseShape,\n                                           &inputColumnIndices,\n                                           &inputRowStarts,\n                                           &inputWeights,\n                                           &sparsifiedWeights,\n                                           &sparseParams,\n                                           1,\n                                           nil, nil)\n```\n\nOn return, `sparsifiedWeights` contains the weights that you pass to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersFullyConnected]. In this example, the data size of `sparsifiedWeights` is 144 bytes.\n\n## Sparse layers\n\n- **BNNSNDArrayGetDataSize(_:)**: Returns the size, in bytes, that an array descriptor requires.\n- **BNNSNDArrayFullyConnectedSparsifySparseCOO(_:_:_:_:_:_:_:_:_:)**: Converts a sparse tensor from the standardized coordinate list (COO) layout to a device-specific sparse layout that BNNS fully connected layers use.\n- **sparsify(batchSize:inputLayout:inputDenseShape:inputValues:output:sparseParameters:workspace:filterParameters:)**: Converts a sparse tensor from a standardized sparse layout to a device-specific sparse layout that Fully Connected uses.\n- **BNNS.SparseParameters**: A data structure that provides a hint to the sparsity function.\n- **BNNS.SparseLayout**: Constants that specify standardized sparse layouts that BNNS can convert to opaque.\n- **BNNS.SparsityType**: Constants that specify patterns in the sparsity.\n- **BNNSSparsityTypeUnstructured**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns the size, in bytes, that an array descriptor requires.",
          "name" : "BNNSNDArrayGetDataSize(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSNDArrayGetDataSize(_:)"
        },
        {
          "description" : "Converts a sparse tensor from the standardized coordinate list (COO) layout to a device-specific sparse layout that BNNS fully connected layers use.",
          "name" : "BNNSNDArrayFullyConnectedSparsifySparseCOO(_:_:_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSNDArrayFullyConnectedSparsifySparseCOO(_:_:_:_:_:_:_:_:_:)"
        },
        {
          "description" : "Converts a sparse tensor from a standardized sparse layout to a device-specific sparse layout that Fully Connected uses.",
          "name" : "sparsify(batchSize:inputLayout:inputDenseShape:inputValues:output:sparseParameters:workspace:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/FullyConnectedLayer\/sparsify(batchSize:inputLayout:inputDenseShape:inputValues:output:sparseParameters:workspace:filterParameters:)"
        },
        {
          "description" : "A data structure that provides a hint to the sparsity function.",
          "name" : "BNNS.SparseParameters",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/SparseParameters"
        },
        {
          "description" : "Constants that specify standardized sparse layouts that BNNS can convert to opaque.",
          "name" : "BNNS.SparseLayout",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/SparseLayout"
        },
        {
          "description" : "Constants that specify patterns in the sparsity.",
          "name" : "BNNS.SparsityType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/SparsityType"
        },
        {
          "description" : "",
          "name" : "BNNSSparsityTypeUnstructured",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSSparsityTypeUnstructured"
        }
      ],
      "title" : "Sparse layers"
    }
  ],
  "source" : "appleJSON",
  "title" : "BNNSNDArrayFullyConnectedSparsifySparseCSR(_:_:_:_:_:_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/accelerate\/bnnsndarrayfullyconnectedsparsifysparsecsr(_:_:_:_:_:_:_:_:_:_:)"
}