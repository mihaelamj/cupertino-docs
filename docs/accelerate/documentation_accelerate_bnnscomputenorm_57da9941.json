{
  "abstract" : "Computes the specified norm over an entire tensor or the specified axes.",
  "codeExamples" : [
    {
      "code" : "let inputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 24)\n_ = inputData.initialize(from: [1, 2, 3,\n                                4, 5, 6,\n                                \n                                10, 20, 30,\n                                40, 50, 60,\n                                \n                                100, 200, 300,\n                                400, 500, 600,\n                                \n                                1000, 2000, 3000,\n                                4000, 5000, 6000])\nvar inputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                            layout: BNNSDataLayoutImageCHW,\n                                            size: (3, 2, 4, 0, 0, 0, 0, 0),\n                                            stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                            data: inputData.baseAddress!,\n                                            data_type: BNNSDataType.float,\n                                            table_data: nil,\n                                            table_data_type: BNNSDataType.float,\n                                            data_scale: 1, data_bias: 0)",
      "language" : "swift"
    },
    {
      "code" : "let outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 1)\nvar outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                             layout: BNNSDataLayoutVector,\n                                             size: (1, 0, 0, 0, 0, 0, 0, 0),\n                                             stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                             data: outputData.baseAddress!,\n                                             data_type: BNNSDataType.float,\n                                             table_data: nil,\n                                             table_data_type: BNNSDataType.float,\n                                             data_scale: 1, data_bias: 0)\n\nBNNSComputeNorm(&outputDescriptor,\n                 &inputDescriptor,\n                 BNNSL2Norm,\n                 0b111)\n\n\/\/ Prints `[9587.45]`\nprint(Array(outputData))",
      "language" : "swift"
    },
    {
      "code" : "let outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 6)\nvar outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                             layout: BNNSDataLayoutColumnMajorMatrix,\n                                             size: (3, 2, 0, 0, 0, 0, 0, 0),\n                                             stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                             data: outputData.baseAddress!,\n                                             data_type: BNNSDataType.float,\n                                             table_data: nil,\n                                             table_data_type: BNNSDataType.float,\n                                             data_scale: 1, data_bias: 0)\n\nBNNSComputeNorm(&outputDescriptor,\n                 &inputDescriptor,\n                 BNNSL2Norm,\n                 0b100)\n\n\/\/ Prints\n\/\/      [1005.0378, 2010.075, 3015.113,\n\/\/       4020.1511, 5025.189, 6030.227]\nprint(Array(outputData))",
      "language" : "swift"
    },
    {
      "code" : "let outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 2)\nvar outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                             layout: BNNSDataLayoutVector,\n                                             size: (2, 0, 0, 0, 0, 0, 0, 0),\n                                             stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                             data: outputData.baseAddress!,\n                                             data_type: BNNSDataType.float,\n                                             table_data: nil,\n                                             table_data_type: BNNSDataType.float,\n                                             data_scale: 1, data_bias: 0)\n\nBNNSComputeNorm(&outputDescriptor,\n                 &inputDescriptor,\n                 BNNSL2Norm,\n                 0b101)\n\n\/\/ Prints `[3760.507, 8819.171]`\nprint(Array(outputData))",
      "language" : "swift"
    }
  ],
  "contentHash" : "c39218124c6c74b04ac049420730cfeb00b8b1c0d9b9642a4435c645c28d99d1",
  "crawledAt" : "2025-12-03T20:40:42Z",
  "declaration" : {
    "code" : "func BNNSComputeNorm(_ dest: UnsafeMutablePointer<BNNSNDArrayDescriptor>, _ src: UnsafePointer<BNNSNDArrayDescriptor>, _ norm_type: BNNSNormType, _ axis_flags: UInt32) -> Int32",
    "language" : "swift"
  },
  "id" : "00EF9907-F6C0-4564-B33A-AB2EE03B3545",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nUse this function to compute the norm of either an entire tensor or the axis or axes of a tensor.\n\nFor example, the following code defines a 3D tensor:\n\nDefine the `axis_flags` parameter as either `0b111` or `0` to specify that the operation computes the norm of the entire tensor. In this case, the norm is a scalar value, and the destination’s data layout must be a `BNNSDataLayoutVector` with a size of `1`.\n\nOn return, the output descriptor contains a single value that is the square root of the sum of squares of each element in the tensor:\n\n\n\nSpecify an `axis_flags` of `0b100` to compute the norm along the second axis. In this case, the destination should be a matrix with a size that matches the zeroth and first dimensions of the source tensor:\n\nOn return, the output descriptor contains six values that are the norms of the slices along the second axis of the input tensor:\n\n\n\nTo compute the norm along more that one dimension, define the destination tensor with a size of the dimensions you’re not calculating over. For example, the following code defines an `axis_flags` with a value of `0b101` to compute the norm of dimensions zero and two:\n\nOn return, the output descriptor contains two values that are the norms of the top and bottom slices of the input tensor:\n\n",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSComputeNorm(_:_:_:_:)\ncrawled: 2025-12-03T20:40:42Z\n---\n\n# BNNSComputeNorm(_:_:_:_:)\n\n**Function**\n\nComputes the specified norm over an entire tensor or the specified axes.\n\n## Declaration\n\n```swift\nfunc BNNSComputeNorm(_ dest: UnsafeMutablePointer<BNNSNDArrayDescriptor>, _ src: UnsafePointer<BNNSNDArrayDescriptor>, _ norm_type: BNNSNormType, _ axis_flags: UInt32) -> Int32\n```\n\n## Parameters\n\n- **dest**: The descriptor of the output.\n- **src**: The descriptor of the input.\n- **norm_type**: The type of the norm. This function supports only [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSL2Norm].\n- **axis_flags**: The dimensions that the function uses to compute the norm. Set to `0` to specify that the function computes the norm over all dimensions.\n\n## Discussion\n\nUse this function to compute the norm of either an entire tensor or the axis or axes of a tensor.\n\nFor example, the following code defines a 3D tensor:\n\n```swift\nlet inputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 24)\n_ = inputData.initialize(from: [1, 2, 3,\n                                4, 5, 6,\n                                \n                                10, 20, 30,\n                                40, 50, 60,\n                                \n                                100, 200, 300,\n                                400, 500, 600,\n                                \n                                1000, 2000, 3000,\n                                4000, 5000, 6000])\nvar inputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                            layout: BNNSDataLayoutImageCHW,\n                                            size: (3, 2, 4, 0, 0, 0, 0, 0),\n                                            stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                            data: inputData.baseAddress!,\n                                            data_type: BNNSDataType.float,\n                                            table_data: nil,\n                                            table_data_type: BNNSDataType.float,\n                                            data_scale: 1, data_bias: 0)\n```\n\nDefine the `axis_flags` parameter as either `0b111` or `0` to specify that the operation computes the norm of the entire tensor. In this case, the norm is a scalar value, and the destination’s data layout must be a `BNNSDataLayoutVector` with a size of `1`.\n\n```swift\nlet outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 1)\nvar outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                             layout: BNNSDataLayoutVector,\n                                             size: (1, 0, 0, 0, 0, 0, 0, 0),\n                                             stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                             data: outputData.baseAddress!,\n                                             data_type: BNNSDataType.float,\n                                             table_data: nil,\n                                             table_data_type: BNNSDataType.float,\n                                             data_scale: 1, data_bias: 0)\n\nBNNSComputeNorm(&outputDescriptor,\n                 &inputDescriptor,\n                 BNNSL2Norm,\n                 0b111)\n\n\/\/ Prints `[9587.45]`\nprint(Array(outputData))\n```\n\nOn return, the output descriptor contains a single value that is the square root of the sum of squares of each element in the tensor:\n\n\n\nSpecify an `axis_flags` of `0b100` to compute the norm along the second axis. In this case, the destination should be a matrix with a size that matches the zeroth and first dimensions of the source tensor:\n\n```swift\nlet outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 6)\nvar outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                             layout: BNNSDataLayoutColumnMajorMatrix,\n                                             size: (3, 2, 0, 0, 0, 0, 0, 0),\n                                             stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                             data: outputData.baseAddress!,\n                                             data_type: BNNSDataType.float,\n                                             table_data: nil,\n                                             table_data_type: BNNSDataType.float,\n                                             data_scale: 1, data_bias: 0)\n\nBNNSComputeNorm(&outputDescriptor,\n                 &inputDescriptor,\n                 BNNSL2Norm,\n                 0b100)\n\n\/\/ Prints\n\/\/      [1005.0378, 2010.075, 3015.113,\n\/\/       4020.1511, 5025.189, 6030.227]\nprint(Array(outputData))\n```\n\nOn return, the output descriptor contains six values that are the norms of the slices along the second axis of the input tensor:\n\n\n\nTo compute the norm along more that one dimension, define the destination tensor with a size of the dimensions you’re not calculating over. For example, the following code defines an `axis_flags` with a value of `0b101` to compute the norm of dimensions zero and two:\n\n```swift\nlet outputData = UnsafeMutableBufferPointer<Float>.allocate(capacity: 2)\nvar outputDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                             layout: BNNSDataLayoutVector,\n                                             size: (2, 0, 0, 0, 0, 0, 0, 0),\n                                             stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                             data: outputData.baseAddress!,\n                                             data_type: BNNSDataType.float,\n                                             table_data: nil,\n                                             table_data_type: BNNSDataType.float,\n                                             data_scale: 1, data_bias: 0)\n\nBNNSComputeNorm(&outputDescriptor,\n                 &inputDescriptor,\n                 BNNSL2Norm,\n                 0b101)\n\n\/\/ Prints `[3760.507, 8819.171]`\nprint(Array(outputData))\n```\n\nOn return, the output descriptor contains two values that are the norms of the top and bottom slices of the input tensor:\n\n\n\n## Compute norm functions\n\n- **computeNorm(input:output:axes:)**: Computes the Euclidean norm and writes the result to the output tensor.\n- **computeNormBackward(input:output:axes:outputGradient:generatingInputGradient:)**: Backpropogates gradients for the compute norm function.\n- **BNNSComputeNormBackward(_:_:_:_:_:_:)**: Backpropogates gradients for the compute norm function.\n- **BNNSNormType**: Constants that describe norm types.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Computes the Euclidean norm and writes the result to the output tensor.",
          "name" : "computeNorm(input:output:axes:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/computeNorm(input:output:axes:)"
        },
        {
          "description" : "Backpropogates gradients for the compute norm function.",
          "name" : "computeNormBackward(input:output:axes:outputGradient:generatingInputGradient:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/computeNormBackward(input:output:axes:outputGradient:generatingInputGradient:)"
        },
        {
          "description" : "Backpropogates gradients for the compute norm function.",
          "name" : "BNNSComputeNormBackward(_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSComputeNormBackward(_:_:_:_:_:_:)"
        },
        {
          "description" : "Constants that describe norm types.",
          "name" : "BNNSNormType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSNormType"
        }
      ],
      "title" : "Compute norm functions"
    }
  ],
  "source" : "appleJSON",
  "title" : "BNNSComputeNorm(_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSComputeNorm(_:_:_:_:)"
}