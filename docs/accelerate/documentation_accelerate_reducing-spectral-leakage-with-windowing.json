{
  "abstract" : "Multiply signal data by window sequence values when performing transforms with noninteger period signals.",
  "codeExamples" : [
    {
      "code" : "static func synthesizeSignal(frequencyAmplitudePairs: [(f: Float, a: Float)],\n                             count: Int) -> [Float] {\n    \n    let tau: Float = .pi * 2\n    let signal: [Float] = (0 ..< count).map { index in\n        frequencyAmplitudePairs.reduce(0) { accumulator, frequenciesAmplitudePair in\n            let normalizedIndex = Float(index) \/ Float(count)\n            return accumulator + sin(normalizedIndex * frequenciesAmplitudePair.f * tau) * frequenciesAmplitudePair.a\n        }\n    }\n    \n    return signal\n}",
      "language" : "swift"
    },
    {
      "code" : "let n = 2048\n\nlet baseFrequency: Float = 5\n\nlet frequencyAmplitudePairs = stride(from: 1, to: 50, by: 2).map { i in\n    return(f: baseFrequency * Float(i), a: (1 \/ Float(i)))\n}\n\nvar signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: n)",
      "language" : "swift"
    },
    {
      "code" : "let count = n \/ 2\nvar realParts = [Float](repeating: 0,\n                        count: count)\nvar imagParts = [Float](repeating: 0,\n                        count: count)\n\nrealParts.withUnsafeMutableBufferPointer { realPtr in\n    imagParts.withUnsafeMutableBufferPointer { imagPtr in\n        \n        var complexSignal = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                            imagp: imagPtr.baseAddress!)\n               \n        signal.withUnsafeBytes {\n            vDSP.convert(interleavedComplexVector: [DSPComplex]($0.bindMemory(to: DSPComplex.self)),\n                         toSplitComplexVector: &complexSignal)\n        }\n        \n        let log2n = vDSP_Length(log2(Float(n)))\n        let fft = vDSP.FFT(log2n: log2n,\n                           radix: .radix2,\n                           ofType: DSPSplitComplex.self)\n        \n        fft?.forward(input: complexSignal,\n                     output: &complexSignal)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let n = 2048\n\nlet baseFrequency: Float = 5.75\n\nlet frequencyAmplitudePairs = stride(from: 1, to: 50, by: 2).map { i in\n    return(f: baseFrequency * Float(i), a: (1 \/ Float(i)))\n}\n\nvar signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: n)",
      "language" : "swift"
    },
    {
      "code" : "let n = 2048\n\nlet baseFrequency: Float = 5.75\n\nlet frequencyAmplitudePairs = stride(from: 1, to: 50, by: 2).map { i in\n    return(f: baseFrequency * Float(i), a: (1 \/ Float(i)))\n}\n\nvar signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: n)\n \nlet window = vDSP.window(ofType: Float.self,\n                         usingSequence: .hanningDenormalized,\n                         count: n, \n                         isHalfWindow: false)\n\nsignal = vDSP.multiply(signal, window)",
      "language" : "swift"
    },
    {
      "code" : "let frequencyAmplitudePairs = [(f: Float(32.25), a: Float(1))]",
      "language" : "swift"
    }
  ],
  "contentHash" : "e0e485a0561d92b72195c96d0e7157ab9ce9e297f30113657788db410737c8de",
  "crawledAt" : "2025-12-02T15:37:20Z",
  "id" : "3CC4DCCD-E320-4DF8-8F30-64102A623A06",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nDiscrete Fourier and cosine transforms, which decompose a signal into its component frequencies and recreate a signal from a component frequency representation, work over vectors of specific lengths. For example, if you’re analyzing audio data, the data might be represented as pages of 1024 samples. Discrete Fourier and cosine transforms can accurately approximate the component frequencies that have an integer number of periods — that is, signals where the start and end points join to form a continuous waveform.\n\nHowever, with noninteger period signals, where the endpoints don’t meet, the discontinuities appear as false frequency components in a forward transform. This smearing of data is called spectral leakage.\n\nYou can use an approach called windowing to reduce spectral leakage when performing transforms over data that includes noninteger period signals. *Windowing* multiplies a signal by a vector that represents a smooth curve with boundary values of zero or near zero. This technique ensures that the endpoints of a signal meet and reduces the discontinuities.\n\n### Synthesize a test signal\n\nThe code examples in this article synthesize the signal data from a series of sine waves. In a real-world app, you’ll most likely acquire signal data from a sensor such as a microphone.\n\nUse the `synthesizeSignal` function to generate a composite sine wave from a supplied array of component frequencies and amplitudes:\n\n### Create a signal with an integer number of periods\n\nUsing the code below, generate  a Fourier series approximation of a square wave that’s built from a series of sine waves. Each component sine wave has an integer number of periods over the length of the data.\n\nUse the vDSP fast Fourier transform (FFT), like in the example below, to compute the component frequencies of `signal`:\n\nTo learn more about computing the frequency components of a signal, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave].\n\nThe FFT treats the data set as a single period of a continuous signal. The visualization below wraps the signal around a virtual cylinder to illustrate how the FFT interprets the data. This figure also shows that the endpoints meet:\n\n\n\nThe illustration below shows a representation of the original signal in blue, and the imaginary parts of the frequency-domain data in yellow:\n\n\n\nThe FFT result shows that the signal is composed of 25 sine waves, represented as spikes in the graph.\n\n### Create a signal with a noninteger number of periods\n\nUse the code below to define a series of sine waves with noninteger periods:\n\nThe visualization below wraps the noninteger-period signal around a virtual cylinder and shows the endpoint discontinuities:\n\n\n\nThe image below shows the results of a transform of this data. The results shows additional, intermediate values that are the result of spectral leakage.\n\n\n\n### Create a windowed signal with a noninteger number of periods\n\nThe code below shows the same noninteger period signal, but in this example, you multiply the signal by the result of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/window(ofType:usingSequence:count:isHalfWindow:)]:\n\nThe illustration below shows the windowed signal in blue, with its boundaries tapered toward zero, and the transformed version with reduced spectral leakage in yellow:\n\n\n\n### Select a window sequence\n\nvDSP provides functions for generating three different windows:\n\nThe image below provides a visual comparison of the different window sequence types:\n\n\n\n### Create a sine wave with a noninteger period\n\nTo understand the different effects of the different windows provided by vDSP, create a signal that’s composed of a signal sine wave with a noninteger period:\n\nThe illustration below shows the sine wave and the frequency-domain result:\n\n\n\nSpectral leakage is apparent throughout the rendered FFT result.\n\n### Reduce the spectral leakage by using a Hann window\n\nThe illustration below shows the time- and frequency-domain representations of the noninteger period sine wave with the Hann window applied:\n\n\n\n### Reduce the spectral leakage by using a Hamming window\n\nCreate a Hamming window by passing [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/WindowSequence\/hamming] to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/window(ofType:usingSequence:count:isHalfWindow:)] function. Unlike the Hann window, the Hamming window doesn’t reach zero at its boundaries.\n\nThe figure below shows the result of multiplying the signal by a Hamming window: high values around the base frequency in the forward FFT are tighter than the Hann-windowed result, but there’s low-level spectral leakage across the entire forward FFT:\n\n\n\n### Reduce the spectral leakage by using a Blackman window\n\nCreate a Blackman window by passing [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/WindowSequence\/blackman] to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/window(ofType:usingSequence:count:isHalfWindow:)] function.\n\nThe illustration below shows the time- and frequency-domain representations of the noninteger period sine wave with the Blackman window applied:\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing\ncrawled: 2025-12-02T15:37:20Z\n---\n\n# Reducing spectral leakage with windowing\n\n**Article**\n\nMultiply signal data by window sequence values when performing transforms with noninteger period signals.\n\n## Overview\n\nDiscrete Fourier and cosine transforms, which decompose a signal into its component frequencies and recreate a signal from a component frequency representation, work over vectors of specific lengths. For example, if you’re analyzing audio data, the data might be represented as pages of 1024 samples. Discrete Fourier and cosine transforms can accurately approximate the component frequencies that have an integer number of periods — that is, signals where the start and end points join to form a continuous waveform.\n\nHowever, with noninteger period signals, where the endpoints don’t meet, the discontinuities appear as false frequency components in a forward transform. This smearing of data is called spectral leakage.\n\nYou can use an approach called windowing to reduce spectral leakage when performing transforms over data that includes noninteger period signals. *Windowing* multiplies a signal by a vector that represents a smooth curve with boundary values of zero or near zero. This technique ensures that the endpoints of a signal meet and reduces the discontinuities.\n\n### Synthesize a test signal\n\nThe code examples in this article synthesize the signal data from a series of sine waves. In a real-world app, you’ll most likely acquire signal data from a sensor such as a microphone.\n\nUse the `synthesizeSignal` function to generate a composite sine wave from a supplied array of component frequencies and amplitudes:\n\n```swift\nstatic func synthesizeSignal(frequencyAmplitudePairs: [(f: Float, a: Float)],\n                             count: Int) -> [Float] {\n    \n    let tau: Float = .pi * 2\n    let signal: [Float] = (0 ..< count).map { index in\n        frequencyAmplitudePairs.reduce(0) { accumulator, frequenciesAmplitudePair in\n            let normalizedIndex = Float(index) \/ Float(count)\n            return accumulator + sin(normalizedIndex * frequenciesAmplitudePair.f * tau) * frequenciesAmplitudePair.a\n        }\n    }\n    \n    return signal\n}\n```\n\n### Create a signal with an integer number of periods\n\nUsing the code below, generate  a Fourier series approximation of a square wave that’s built from a series of sine waves. Each component sine wave has an integer number of periods over the length of the data.\n\n```swift\nlet n = 2048\n\nlet baseFrequency: Float = 5\n\nlet frequencyAmplitudePairs = stride(from: 1, to: 50, by: 2).map { i in\n    return(f: baseFrequency * Float(i), a: (1 \/ Float(i)))\n}\n\nvar signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: n)\n```\n\nUse the vDSP fast Fourier transform (FFT), like in the example below, to compute the component frequencies of `signal`:\n\n```swift\nlet count = n \/ 2\nvar realParts = [Float](repeating: 0,\n                        count: count)\nvar imagParts = [Float](repeating: 0,\n                        count: count)\n\nrealParts.withUnsafeMutableBufferPointer { realPtr in\n    imagParts.withUnsafeMutableBufferPointer { imagPtr in\n        \n        var complexSignal = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                            imagp: imagPtr.baseAddress!)\n               \n        signal.withUnsafeBytes {\n            vDSP.convert(interleavedComplexVector: [DSPComplex]($0.bindMemory(to: DSPComplex.self)),\n                         toSplitComplexVector: &complexSignal)\n        }\n        \n        let log2n = vDSP_Length(log2(Float(n)))\n        let fft = vDSP.FFT(log2n: log2n,\n                           radix: .radix2,\n                           ofType: DSPSplitComplex.self)\n        \n        fft?.forward(input: complexSignal,\n                     output: &complexSignal)\n    }\n}\n```\n\nTo learn more about computing the frequency components of a signal, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave].\n\nThe FFT treats the data set as a single period of a continuous signal. The visualization below wraps the signal around a virtual cylinder to illustrate how the FFT interprets the data. This figure also shows that the endpoints meet:\n\n\n\nThe illustration below shows a representation of the original signal in blue, and the imaginary parts of the frequency-domain data in yellow:\n\n\n\n\n\nThe FFT result shows that the signal is composed of 25 sine waves, represented as spikes in the graph.\n\n### Create a signal with a noninteger number of periods\n\nUse the code below to define a series of sine waves with noninteger periods:\n\n```swift\nlet n = 2048\n\nlet baseFrequency: Float = 5.75\n\nlet frequencyAmplitudePairs = stride(from: 1, to: 50, by: 2).map { i in\n    return(f: baseFrequency * Float(i), a: (1 \/ Float(i)))\n}\n\nvar signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: n)\n```\n\nThe visualization below wraps the noninteger-period signal around a virtual cylinder and shows the endpoint discontinuities:\n\n\n\nThe image below shows the results of a transform of this data. The results shows additional, intermediate values that are the result of spectral leakage.\n\n\n\n### Create a windowed signal with a noninteger number of periods\n\nThe code below shows the same noninteger period signal, but in this example, you multiply the signal by the result of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/window(ofType:usingSequence:count:isHalfWindow:)]:\n\n```swift\nlet n = 2048\n\nlet baseFrequency: Float = 5.75\n\nlet frequencyAmplitudePairs = stride(from: 1, to: 50, by: 2).map { i in\n    return(f: baseFrequency * Float(i), a: (1 \/ Float(i)))\n}\n\nvar signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: n)\n \nlet window = vDSP.window(ofType: Float.self,\n                         usingSequence: .hanningDenormalized,\n                         count: n, \n                         isHalfWindow: false)\n\nsignal = vDSP.multiply(signal, window)\n```\n\nThe illustration below shows the windowed signal in blue, with its boundaries tapered toward zero, and the transformed version with reduced spectral leakage in yellow:\n\n\n\n### Select a window sequence\n\nvDSP provides functions for generating three different windows:\n\n\n\nThe image below provides a visual comparison of the different window sequence types:\n\n\n\n### Create a sine wave with a noninteger period\n\nTo understand the different effects of the different windows provided by vDSP, create a signal that’s composed of a signal sine wave with a noninteger period:\n\n```swift\nlet frequencyAmplitudePairs = [(f: Float(32.25), a: Float(1))]\n```\n\nThe illustration below shows the sine wave and the frequency-domain result:\n\n\n\nSpectral leakage is apparent throughout the rendered FFT result.\n\n### Reduce the spectral leakage by using a Hann window\n\nThe illustration below shows the time- and frequency-domain representations of the noninteger period sine wave with the Hann window applied:\n\n\n\n### Reduce the spectral leakage by using a Hamming window\n\nCreate a Hamming window by passing [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/WindowSequence\/hamming] to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/window(ofType:usingSequence:count:isHalfWindow:)] function. Unlike the Hann window, the Hamming window doesn’t reach zero at its boundaries.\n\nThe figure below shows the result of multiplying the signal by a Hamming window: high values around the base frequency in the forward FFT are tighter than the Hann-windowed result, but there’s low-level spectral leakage across the entire forward FFT:\n\n\n\n### Reduce the spectral leakage by using a Blackman window\n\nCreate a Blackman window by passing [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/WindowSequence\/blackman] to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/window(ofType:usingSequence:count:isHalfWindow:)] function.\n\nThe illustration below shows the time- and frequency-domain representations of the noninteger period sine wave with the Blackman window applied:\n\n\n\n## Fourier and Cosine Transforms\n\n- **Understanding data packing for Fourier transforms**: Format source data for the vDSP Fourier functions, and interpret the results.\n- **Finding the component frequencies in a composite sine wave**: Use 1D fast Fourier transform to compute the frequency components of a signal.\n- **Performing Fourier transforms on interleaved-complex data**: Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.\n- **Signal extraction from noise**: Use Accelerate’s discrete cosine transform to remove noise from a signal.\n- **Performing Fourier Transforms on Multiple Signals**: Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.\n- **Halftone descreening with 2D fast Fourier transform**: Reduce or remove periodic artifacts from images.\n- **Fast Fourier transforms**: Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Fourier transforms**: Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Format source data for the vDSP Fourier functions, and interpret the results.",
          "name" : "Understanding data packing for Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms"
        },
        {
          "description" : "Use 1D fast Fourier transform to compute the frequency components of a signal.",
          "name" : "Finding the component frequencies in a composite sine wave",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave"
        },
        {
          "description" : "Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.",
          "name" : "Performing Fourier transforms on interleaved-complex data",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data"
        },
        {
          "description" : "Use Accelerate’s discrete cosine transform to remove noise from a signal.",
          "name" : "Signal extraction from noise",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise"
        },
        {
          "description" : "Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.",
          "name" : "Performing Fourier Transforms on Multiple Signals",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals"
        },
        {
          "description" : "Reduce or remove periodic artifacts from images.",
          "name" : "Halftone descreening with 2D fast Fourier transform",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform"
        },
        {
          "description" : "Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Fast Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/fast-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Discrete Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Fourier and Cosine Transforms"
    }
  ],
  "source" : "appleJSON",
  "title" : "Reducing spectral leakage with windowing",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing"
}