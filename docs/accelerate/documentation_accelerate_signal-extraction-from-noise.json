{
  "abstract" : "Use Accelerate’s discrete cosine transform to remove noise from a signal.",
  "codeExamples" : [
    {
      "code" : "static func generateSignal(noiseAmount: Double,\n                           sampleCount: Int) -> [Float] {\n    \n    let tau = Float.pi * 2\n    \n    return (0 ..< sampleCount).map { i in\n        let phase = Float(i) \/ Float(sampleCount) * tau\n        \n        var signal = cos(phase * 1) * 1.0\n            signal += cos(phase * 2) * 0.8\n            signal += cos(phase * 4) * 0.4\n            signal += cos(phase * 8) * 0.8\n            signal += cos(phase * 16) * 1.0\n            signal += cos(phase * 32) * 0.8\n        \n        return signal + .random(in: -1...1) * Float(noiseAmount)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "static let forwardDCTSetup = vDSP.DCT(count: sampleCount,\n                               transformType: vDSP.DCTTransformType.II)!",
      "language" : "swift"
    },
    {
      "code" : "static let inverseDCTSetup = vDSP.DCT(count: sampleCount,\n                               transformType: vDSP.DCTTransformType.III)!",
      "language" : "swift"
    },
    {
      "code" : "forwardDCTSetup.transform(noisySignal,\n                          result: &frequencyDomainDestination)",
      "language" : "swift"
    },
    {
      "code" : "vDSP.threshold(frequencyDomainDestination,\n               to: Float(threshold),\n               with: .zeroFill,\n               result: &frequencyDomainDestination)\n",
      "language" : "swift"
    },
    {
      "code" : "inverseDCTSetup.transform(frequencyDomainDestination,\n                          result: &timeDomainDestination)\n",
      "language" : "swift"
    },
    {
      "code" : "let divisor = Float(Self.sampleCount \/ 2)\n\nvDSP.divide(timeDomainDestination,\n            divisor,\n            result: &timeDomainDestination)\n",
      "language" : "swift"
    }
  ],
  "contentHash" : "35697a9b361af221ca57f6ce4c553eb755ccb893abccece24bb9ad061efbe916",
  "crawledAt" : "2025-12-02T15:46:10Z",
  "id" : "0E5D5322-4CEB-4DC5-8174-A33F15F169DA",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nAccelerate’s vDSP module provides functions to perform discrete and fast Fourier transforms (FFTs) on 1D vectors and 2D matrices containing complex numbers. If you want to perform a similar transform on a vector of real numbers, vDSP includes discrete cosine transforms (DCTs).\n\nFFTs and DCTs decompose a signal into its frequency components (known as the *frequency-domain* representation of the signal), and the inverse transform rebuilds a signal into its *time-domain* representation from the frequency components.\n\nBy zeroing low-magnitude data, such as noise, from the frequency-domain data, you can reconstruct a signal, leaving only its dominant frequencies. The meaningful signals that you’re trying to isolate tend to have their energy packed at a few frequencies. Noise, however, has its energy more uniformly spread across the frequency spectrum (that’s what makes it noise). If you zero out low-magnitude frequency components, you can eliminate much of the noise from the spectrum.\n\n### Generate the test signal\n\nThe `noisySignal` array contains the noisy signal from which the sample app extracts the underlying signal. The underlying signal is a series of cosine waves that’s stored as 1024 samples in an array of single-precision values.\n\nThe `static SignalExtractor.generateSignal(noiseAmount:sampleCount:)` function generates a sample at each data point.\n\nWhen the `noiseAmount` parameter is zero, the values that this code generates return a signal like the one in the image below:\n\n\n\nAdding noise to the signal makes it unrecognizable.\n\n\n\n### Prepare the DCT setups\n\nThe sample app creates setup objects that contain all the information required to perform the forward and inverse DCT operations. Because creating these setup objects can be expensive, the sample app creates the DCT setup objects once and reuses them.\n\nThe forward transform is a type II DCT.\n\nThe inverse transform is a type III DCT.\n\n### Perform the DCT\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/DCT\/transform(_:)] function performs the DCT. This function requires a source array that contains the source signal and a destination array that the function overwrites with the frequency-domain data.\n\nThe following visualization of the frequency-domain data shows the component cosine parts. The `cos(phase * 1) * 1.0` component is on the left, and  `cos(phase * 16) * 1.0` is on the right:\n\n\n\nThe frequency-domain visualization of the noisy signal shows the dominant frequencies with the noise spread evenly throughout the frequency range. The sample zeroes the low-magnitude data to generate the noise-free signal.\n\n\n\n### Apply a threshold to the frequency-domain data\n\nRemove the noise from the signal by zeroing all values in the frequency-domain data that are below a specified threshold.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/threshold(_:to:with:result:)-45b58] function sets all values in the frequency-domain array that fall below the threshold to zero.\n\n### Recreate the signal\n\nThe inverse DCT generates a new signal using the cleaned-up frequency-domain data:\n\nThe sample app scales the inverse DCT so that it matches the magnitude of the original signal. The scaling factor for the forward transform is 2, and the scaling factor for the inverse transform is the number of samples (in this case, 1024). The [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/divide(_:_:)-8swnm] function divides the inverse DCT result by `count \/ 2` to return a signal with the correct magnitude.\n\nFor more information on scaling factors for the vDSP FFT and DFT operations, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise\ncrawled: 2025-12-02T15:46:10Z\n---\n\n# Signal extraction from noise\n\n**Sample Code**\n\nUse Accelerate’s discrete cosine transform to remove noise from a signal.\n\n## Overview\n\nAccelerate’s vDSP module provides functions to perform discrete and fast Fourier transforms (FFTs) on 1D vectors and 2D matrices containing complex numbers. If you want to perform a similar transform on a vector of real numbers, vDSP includes discrete cosine transforms (DCTs).\n\nFFTs and DCTs decompose a signal into its frequency components (known as the *frequency-domain* representation of the signal), and the inverse transform rebuilds a signal into its *time-domain* representation from the frequency components.\n\nBy zeroing low-magnitude data, such as noise, from the frequency-domain data, you can reconstruct a signal, leaving only its dominant frequencies. The meaningful signals that you’re trying to isolate tend to have their energy packed at a few frequencies. Noise, however, has its energy more uniformly spread across the frequency spectrum (that’s what makes it noise). If you zero out low-magnitude frequency components, you can eliminate much of the noise from the spectrum.\n\n### Generate the test signal\n\nThe `noisySignal` array contains the noisy signal from which the sample app extracts the underlying signal. The underlying signal is a series of cosine waves that’s stored as 1024 samples in an array of single-precision values.\n\nThe `static SignalExtractor.generateSignal(noiseAmount:sampleCount:)` function generates a sample at each data point.\n\n```swift\nstatic func generateSignal(noiseAmount: Double,\n                           sampleCount: Int) -> [Float] {\n    \n    let tau = Float.pi * 2\n    \n    return (0 ..< sampleCount).map { i in\n        let phase = Float(i) \/ Float(sampleCount) * tau\n        \n        var signal = cos(phase * 1) * 1.0\n            signal += cos(phase * 2) * 0.8\n            signal += cos(phase * 4) * 0.4\n            signal += cos(phase * 8) * 0.8\n            signal += cos(phase * 16) * 1.0\n            signal += cos(phase * 32) * 0.8\n        \n        return signal + .random(in: -1...1) * Float(noiseAmount)\n    }\n}\n```\n\nWhen the `noiseAmount` parameter is zero, the values that this code generates return a signal like the one in the image below:\n\n\n\nAdding noise to the signal makes it unrecognizable.\n\n\n\n### Prepare the DCT setups\n\nThe sample app creates setup objects that contain all the information required to perform the forward and inverse DCT operations. Because creating these setup objects can be expensive, the sample app creates the DCT setup objects once and reuses them.\n\nThe forward transform is a type II DCT.\n\n```swift\nstatic let forwardDCTSetup = vDSP.DCT(count: sampleCount,\n                               transformType: vDSP.DCTTransformType.II)!\n```\n\nThe inverse transform is a type III DCT.\n\n```swift\nstatic let inverseDCTSetup = vDSP.DCT(count: sampleCount,\n                               transformType: vDSP.DCTTransformType.III)!\n```\n\n### Perform the DCT\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/DCT\/transform(_:)] function performs the DCT. This function requires a source array that contains the source signal and a destination array that the function overwrites with the frequency-domain data.\n\n```swift\nforwardDCTSetup.transform(noisySignal,\n                          result: &frequencyDomainDestination)\n```\n\nThe following visualization of the frequency-domain data shows the component cosine parts. The `cos(phase * 1) * 1.0` component is on the left, and  `cos(phase * 16) * 1.0` is on the right:\n\n\n\nThe frequency-domain visualization of the noisy signal shows the dominant frequencies with the noise spread evenly throughout the frequency range. The sample zeroes the low-magnitude data to generate the noise-free signal.\n\n\n\n### Apply a threshold to the frequency-domain data\n\nRemove the noise from the signal by zeroing all values in the frequency-domain data that are below a specified threshold.\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/threshold(_:to:with:result:)-45b58] function sets all values in the frequency-domain array that fall below the threshold to zero.\n\n```swift\nvDSP.threshold(frequencyDomainDestination,\n               to: Float(threshold),\n               with: .zeroFill,\n               result: &frequencyDomainDestination)\n\n```\n\n### Recreate the signal\n\nThe inverse DCT generates a new signal using the cleaned-up frequency-domain data:\n\n```swift\ninverseDCTSetup.transform(frequencyDomainDestination,\n                          result: &timeDomainDestination)\n\n```\n\nThe sample app scales the inverse DCT so that it matches the magnitude of the original signal. The scaling factor for the forward transform is 2, and the scaling factor for the inverse transform is the number of samples (in this case, 1024). The [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/divide(_:_:)-8swnm] function divides the inverse DCT result by `count \/ 2` to return a signal with the correct magnitude.\n\n```swift\nlet divisor = Float(Self.sampleCount \/ 2)\n\nvDSP.divide(timeDomainDestination,\n            divisor,\n            result: &timeDomainDestination)\n\n```\n\nFor more information on scaling factors for the vDSP FFT and DFT operations, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms].\n\n## Fourier and Cosine Transforms\n\n- **Understanding data packing for Fourier transforms**: Format source data for the vDSP Fourier functions, and interpret the results.\n- **Finding the component frequencies in a composite sine wave**: Use 1D fast Fourier transform to compute the frequency components of a signal.\n- **Performing Fourier transforms on interleaved-complex data**: Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.\n- **Reducing spectral leakage with windowing**: Multiply signal data by window sequence values when performing transforms with noninteger period signals.\n- **Performing Fourier Transforms on Multiple Signals**: Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.\n- **Halftone descreening with 2D fast Fourier transform**: Reduce or remove periodic artifacts from images.\n- **Fast Fourier transforms**: Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Fourier transforms**: Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Format source data for the vDSP Fourier functions, and interpret the results.",
          "name" : "Understanding data packing for Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms"
        },
        {
          "description" : "Use 1D fast Fourier transform to compute the frequency components of a signal.",
          "name" : "Finding the component frequencies in a composite sine wave",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave"
        },
        {
          "description" : "Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.",
          "name" : "Performing Fourier transforms on interleaved-complex data",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data"
        },
        {
          "description" : "Multiply signal data by window sequence values when performing transforms with noninteger period signals.",
          "name" : "Reducing spectral leakage with windowing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing"
        },
        {
          "description" : "Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.",
          "name" : "Performing Fourier Transforms on Multiple Signals",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals"
        },
        {
          "description" : "Reduce or remove periodic artifacts from images.",
          "name" : "Halftone descreening with 2D fast Fourier transform",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform"
        },
        {
          "description" : "Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Fast Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/fast-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Discrete Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Fourier and Cosine Transforms"
    }
  ],
  "source" : "appleJSON",
  "title" : "Signal extraction from noise",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise"
}