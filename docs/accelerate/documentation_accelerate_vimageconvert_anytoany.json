{
  "abstract" : "Converts the pixels in a vImage buffer to another format, using the specified converter.",
  "codeExamples" : [

  ],
  "contentHash" : "0780d9d6ec682b2dfabaac6316c708a0d16053b5a1c7239b8dab3a7cebfa6c72",
  "crawledAt" : "2025-12-01T03:48:30Z",
  "declaration" : {
    "code" : "func vImageConvert_AnyToAny(_ converter: vImageConverter, _ srcs: UnsafePointer<vImage_Buffer>, _ dests: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutableRawPointer!, _ flags: vImage_Flags) -> vImage_Error",
    "language" : "swift"
  },
  "id" : "67495ECA-008C-4DFA-8427-4BA0ADBA8345",
  "kind" : "function",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\n[doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageNoError]; otherwise, one of the error codes described in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/data-types-and-constants].\n\n## Discussion\n\nWith an appropriately configured vImage converter, convert the image channels found in `srcs` to the image channels found in `dests`. Whenever possible, conversion passes are vectorized and multithreaded to reduce the time and energy cost of the function.\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_MustOperateOutOfPlace(_:_:_:_:)] to determine whether a particular conversion can operate in place. For an in-place conversion to work, you must ensure that `srcs[i].data = dests[i].data` and `srcs[i].rowBytes = dests[i].rowBytes`.\n\nAll scanlines must start at a byte-aligned address. Some formats have 1, 2, 4, or 12 bits per channel\/pixel and might not start at a byte-aligned address. A single byte can’t span multiple rows of data.\n\nSome formats, particularly YUV422 and YUV420, and those with a pixel size that’s not evenly divisible by 8 bits, operate in chunks containing multiple pixels. For example, a YCbCr422 chunk may have `{Y0, Cb, Y1, Cr}` in the chunk. The chunk contains two pixels, each with an independent Y (luminance) component, but shared chrominance.  Even though the chunk width is two, it’s still possible for an image to have a width that’s not divisible by two. This means that some part of the chunk on the rightmost edge of the scanline must refer to a nonexistent pixel.\n\nWhen reading incomplete chunks, vImage touches only the unused parts of the chunk when it knows it to be safe to do so. When writing incomplete chunks, vImage copies the rightmost valid pixel color into the unused part of the chunk. Thus, on reading, the entire chunk doesn’t have to be there, but on writing, it does. Conventions vary among chunk-using imaging pipelines, and this conservative approach should interoperate with most. However, be careful when writing to chunk-based formats (not to be confused with chunky formats, which merely have several channels interleaved) to make sure that the buffer is large enough to tolerate the write policy.  If you’re tiling chunk-based data, be careful not to run tile boundaries through the middle of a chunk.  Chunks are assumed to be indivisible.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/vImageConvert_AnyToAny(_:_:_:_:_:)\ncrawled: 2025-12-01T03:48:30Z\n---\n\n# vImageConvert_AnyToAny(_:_:_:_:_:)\n\n**Function**\n\nConverts the pixels in a vImage buffer to another format, using the specified converter.\n\n## Declaration\n\n```swift\nfunc vImageConvert_AnyToAny(_ converter: vImageConverter, _ srcs: UnsafePointer<vImage_Buffer>, _ dests: UnsafePointer<vImage_Buffer>, _ tempBuffer: UnsafeMutableRawPointer!, _ flags: vImage_Flags) -> vImage_Error\n```\n\n## Parameters\n\n- **converter**: A valid [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter] instance indicating the conversion to perform. You can use the same converter concurrently in multiple threads. To create a converter, you can use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_CreateWithCGImageFormat(_:_:_:_:_:)], [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_CreateWithColorSyncCodeFragment(_:_:_:_:_:_:)], [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_CreateForCGToCVImageFormat(_:_:_:_:_:)], or [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_CreateForCVToCGImageFormat(_:_:_:_:_:)].\n- **srcs**: A pointer to an array of vImage buffer structs that describe the color planes that make up the input image. For the order and number of input buffers, see the description of the function that created the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter] instance. You can also determine the order manually using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_GetSourceBufferOrder(_:)].\n- **dests**: A pointer to an array of vImage buffer structs that describe the color planes that make up the result image. For the order and number of input buffers, see the description of the function that created the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter] instance. You can also determine the order manually using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_GetDestinationBufferOrder(_:)]. The destination buffer may only alias the `srcs` buffers if [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_MustOperateOutOfPlace(_:_:_:_:)] returns 0 and the respective scanlines of the aliasing buffers start at the same address.\n- **tempBuffer**: If this value isn’t null, the memory that `tempBuffer` points to is used as scratch space by the function. You can determine the buffer size by passing [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageGetTempBufferSize] to the flags parameter. If null is passed here and a temporary buffer is needed, the function allocates one on the heap and frees it before returning. The function may run more slowly, because of both the allocation cost and the cost of virtual memory faults to zero-fill pages as they are used. `nil` is the correct option when the function is used infrequently or convenience is valued.\n- **flags**: The options to use when performing this operation. The following flags are supported:\n\n\n\n## Return Value\n\n[doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageNoError]; otherwise, one of the error codes described in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/data-types-and-constants].\n\n## Discussion\n\nWith an appropriately configured vImage converter, convert the image channels found in `srcs` to the image channels found in `dests`. Whenever possible, conversion passes are vectorized and multithreaded to reduce the time and energy cost of the function.\n\nUse [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConverter_MustOperateOutOfPlace(_:_:_:_:)] to determine whether a particular conversion can operate in place. For an in-place conversion to work, you must ensure that `srcs[i].data = dests[i].data` and `srcs[i].rowBytes = dests[i].rowBytes`.\n\nAll scanlines must start at a byte-aligned address. Some formats have 1, 2, 4, or 12 bits per channel\/pixel and might not start at a byte-aligned address. A single byte can’t span multiple rows of data.\n\nSome formats, particularly YUV422 and YUV420, and those with a pixel size that’s not evenly divisible by 8 bits, operate in chunks containing multiple pixels. For example, a YCbCr422 chunk may have `{Y0, Cb, Y1, Cr}` in the chunk. The chunk contains two pixels, each with an independent Y (luminance) component, but shared chrominance.  Even though the chunk width is two, it’s still possible for an image to have a width that’s not divisible by two. This means that some part of the chunk on the rightmost edge of the scanline must refer to a nonexistent pixel.\n\nWhen reading incomplete chunks, vImage touches only the unused parts of the chunk when it knows it to be safe to do so. When writing incomplete chunks, vImage copies the rightmost valid pixel color into the unused part of the chunk. Thus, on reading, the entire chunk doesn’t have to be there, but on writing, it does. Conventions vary among chunk-using imaging pipelines, and this conservative approach should interoperate with most. However, be careful when writing to chunk-based formats (not to be confused with chunky formats, which merely have several channels interleaved) to make sure that the buffer is large enough to tolerate the write policy.  If you’re tiling chunk-based data, be careful not to run tile boundaries through the middle of a chunk.  Chunks are assumed to be indivisible.\n\n## Performing a conversion\n\n- **vImage Buffer Type Codes**: Constants that specify the contents of vImage buffers.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Constants that specify the contents of vImage buffers.",
          "name" : "vImage Buffer Type Codes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/1399056-vimage-buffer-type-codes"
        }
      ],
      "title" : "Performing a conversion"
    }
  ],
  "source" : "appleJSON",
  "title" : "vImageConvert_AnyToAny(_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vImageConvert_AnyToAny(_:_:_:_:_:)"
}