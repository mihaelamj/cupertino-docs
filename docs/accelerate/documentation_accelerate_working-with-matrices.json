{
  "abstract" : "Solve simultaneous equations and transform points in space.",
  "codeExamples" : [
    {
      "code" : "let x = simd_double4(x: 10, y: 20, z: 30, w: 40)\nlet y = simd_double4(x: 1, y: 2, z: 3, w: 4)\n\n\/*\n A matrix of two columns and four rows:\n \n     10  1\n     20  2\n     30  3\n     40  4\n *\/\nlet a = simd_double2x4([x, y]) \/\/ columns\n\n\/*\n A matrix of four columns and two rows:\n\n    10  20  30  40\n    1   2   3   4\n*\/\nlet b = simd_double4x2(rows: [x, y])",
      "language" : "swift"
    },
    {
      "code" : " 2x + 4y = 2\n-4x + 2y = 14",
      "language" : "c"
    },
    {
      "code" : "let a = simd_double2x2(rows: [\n    simd_double2( 2, 4),\n    simd_double2(-4, 2)\n    ])",
      "language" : "swift"
    },
    {
      "code" : "let b = simd_double2(2, 14)",
      "language" : "swift"
    },
    {
      "code" : "let x = simd_mul(a.inverse, b)",
      "language" : "swift"
    },
    {
      "code" : "let positionVector = simd_float3(x: 3, y: 2, z: 1)",
      "language" : "swift"
    },
    {
      "code" : "func makeTranslationMatrix(tx: Float, ty: Float) -> simd_float3x3 {\n    var matrix = matrix_identity_float3x3\n    \n    matrix[2, 0] = tx\n    matrix[2, 1] = ty\n    \n    return matrix\n}",
      "language" : "swift"
    },
    {
      "code" : "let translationMatrix = makeTranslationMatrix(tx: 1, ty: 3)\nlet translatedVector = translationMatrix * positionVector",
      "language" : "swift"
    },
    {
      "code" : "func makeRotationMatrix(angle: Float) -> simd_float3x3 {\n    let rows = [\n        simd_float3(cos(angle), -sin(angle), 0),\n        simd_float3(sin(angle), cos(angle), 0),\n        simd_float3(0,          0,          1)\n    ]\n    \n    return float3x3(rows: rows)\n}",
      "language" : "swift"
    },
    {
      "code" : "let angle = Measurement(value: 30,\n                        unit: UnitAngle.degrees)\nlet radians = Float(angle.converted(to: .radians).value)\n\nlet rotationMatrix = makeRotationMatrix(angle: radians)\nlet rotatedVector = rotationMatrix * translatedVector",
      "language" : "swift"
    },
    {
      "code" : "func makeScaleMatrix(xScale: Float, yScale: Float) -> simd_float3x3 {\n    let rows = [\n        simd_float3(xScale,      0, 0),\n        simd_float3(     0, yScale, 0),\n        simd_float3(     0,      0, 1)\n    ]\n    \n    return float3x3(rows: rows)\n}",
      "language" : "swift"
    },
    {
      "code" : "let scaleMatrix = makeScaleMatrix(xScale: 8, yScale: 1.25)\nlet scaledVector = scaleMatrix * rotatedVector",
      "language" : "swift"
    },
    {
      "code" : "let transformMatrix = scaleMatrix * rotationMatrix * translationMatrix\nlet transformedVector = transformMatrix * positionVector",
      "language" : "swift"
    }
  ],
  "contentHash" : "5d075da31237a267095da271e17bb17206f7ce62fd18605ccd04ac0336fed098",
  "crawledAt" : "2025-12-02T15:55:32Z",
  "id" : "8DA7DBCD-DD66-43DB-8A91-C28F92CB0E97",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nA matrix is a 2D array of values arranged in rows and columns. The simd library provides support for matrices of up to four rows and four columns, containing 16 elements. It uses a *column major* naming convention; for example, a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_double4x2] is a matrix containing four columns and two rows.\n\nThe simd library provides initializers that include options for creating matrices from either rows or columns from the appropriately sized vectors. For example, the following code uses two vectors of four elements to create a 2 x 4 matrix and a 4 x 2 matrix:\n\nThe following examples show a few common uses of matrices.\n\n### Solve Simultaneous Equations\n\nYou can use matrices to solve simultaneous equations of the form *AX = B*; for example, to find *x* and *y* in the following equations:\n\nYou first create a 2 x 2 matrix containing the left-side coefficients:\n\nThen create a vector containing the right-side values:\n\nTo find the values of *x* and *y*, multiply the inverse of the matrix `a` with the vector `b`:\n\nThe result, `x`, is a two-element vector containing `(x = -2.6, y = 1.8)`.\n\n### Transform Vectors with Matrix Multiplication\n\nMatrices provide a convenient way to transform (translate, rotate, and scale) points in 2D and 3D space.\n\nThe following image shows point *A* translated to *B*, rotated to *C*, and scaled to *D*:\n\n\n\nBy representing 2D coordinates as a three-element vector, you can transform points using matrix multiplication. Typically, the third component of the vector, `z`, is set to 1, which indicates that the vector represents a position in space.\n\nFor example, the vector shown as **A** in the preceding illustration is defined as a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3] with the following code:\n\nTransform matrices for 2D coordinates are represented by 3 x 3 matrices.\n\n#### Translate\n\nA translate matrix takes the following form:\n\nThe simd library provides constants for identity matrices (matrices with ones along the diagonal, and zeros elsewhere). The 3 x 3 [doc:\/\/com.apple.documentation\/documentation\/Swift\/Float] identity matrix is [doc:\/\/com.apple.accelerate\/documentation\/simd\/matrix_identity_float3x3].\n\nThe following function returns a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3x3] matrix using the specified `tx` and `ty` translate values by setting the elements in an identity matrix:\n\nTo apply a translate to the position vector, you multiply the pair together:\n\nThe resulting `translatedVector` has the values `(x: 4.0, y: 5.0, z: 1.0)`, shown as **B** in the illustration above.\n\n#### Rotate\n\nA rotation matrix around the z-axis (that is, on the xy plane) takes the following form:\n\nThe following function returns a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3x3] matrix using the specified rotation angle in radians:\n\nTo apply a rotation to the previously translated vector, you multiply the pair together:\n\nThe resulting `rotatedVector` has the values `(x: 0.964102, y: 6.33013, z: 1.0)`, shown as **C** in the illustration above.\n\n#### Scale\n\nA scale matrix takes the following form:\n\nThe following function returns a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3x3] matrix using the specified x and y scale values:\n\nTo apply a scale to the previously rotated vector, you multiply the pair together:\n\nThe resulting `scaledVector` has the values `(x: 7.71282, y: 7.91266, z: 1.0)`, shown as **D** in the illustration above.\n\nThe three transform matrices can be multiplied together and the product multiplied with the position vector to get the same result:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-matrices\ncrawled: 2025-12-02T15:55:32Z\n---\n\n# Working with Matrices\n\n**Article**\n\nSolve simultaneous equations and transform points in space.\n\n## Overview\n\nA matrix is a 2D array of values arranged in rows and columns. The simd library provides support for matrices of up to four rows and four columns, containing 16 elements. It uses a *column major* naming convention; for example, a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_double4x2] is a matrix containing four columns and two rows.\n\nThe simd library provides initializers that include options for creating matrices from either rows or columns from the appropriately sized vectors. For example, the following code uses two vectors of four elements to create a 2 x 4 matrix and a 4 x 2 matrix:\n\n```swift\nlet x = simd_double4(x: 10, y: 20, z: 30, w: 40)\nlet y = simd_double4(x: 1, y: 2, z: 3, w: 4)\n\n\/*\n A matrix of two columns and four rows:\n \n     10  1\n     20  2\n     30  3\n     40  4\n *\/\nlet a = simd_double2x4([x, y]) \/\/ columns\n\n\/*\n A matrix of four columns and two rows:\n\n    10  20  30  40\n    1   2   3   4\n*\/\nlet b = simd_double4x2(rows: [x, y])\n```\n\nThe following examples show a few common uses of matrices.\n\n### Solve Simultaneous Equations\n\nYou can use matrices to solve simultaneous equations of the form *AX = B*; for example, to find *x* and *y* in the following equations:\n\n```c\n 2x + 4y = 2\n-4x + 2y = 14\n```\n\nYou first create a 2 x 2 matrix containing the left-side coefficients:\n\n```swift\nlet a = simd_double2x2(rows: [\n    simd_double2( 2, 4),\n    simd_double2(-4, 2)\n    ])\n```\n\nThen create a vector containing the right-side values:\n\n```swift\nlet b = simd_double2(2, 14)\n```\n\nTo find the values of *x* and *y*, multiply the inverse of the matrix `a` with the vector `b`:\n\n```swift\nlet x = simd_mul(a.inverse, b)\n```\n\nThe result, `x`, is a two-element vector containing `(x = -2.6, y = 1.8)`.\n\n### Transform Vectors with Matrix Multiplication\n\nMatrices provide a convenient way to transform (translate, rotate, and scale) points in 2D and 3D space.\n\nThe following image shows point *A* translated to *B*, rotated to *C*, and scaled to *D*:\n\n\n\nBy representing 2D coordinates as a three-element vector, you can transform points using matrix multiplication. Typically, the third component of the vector, `z`, is set to 1, which indicates that the vector represents a position in space.\n\nFor example, the vector shown as **A** in the preceding illustration is defined as a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3] with the following code:\n\n```swift\nlet positionVector = simd_float3(x: 3, y: 2, z: 1)\n```\n\nTransform matrices for 2D coordinates are represented by 3 x 3 matrices.\n\n#### Translate\n\nA translate matrix takes the following form:\n\n\n\nThe simd library provides constants for identity matrices (matrices with ones along the diagonal, and zeros elsewhere). The 3 x 3 [doc:\/\/com.apple.documentation\/documentation\/Swift\/Float] identity matrix is [doc:\/\/com.apple.accelerate\/documentation\/simd\/matrix_identity_float3x3].\n\nThe following function returns a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3x3] matrix using the specified `tx` and `ty` translate values by setting the elements in an identity matrix:\n\n```swift\nfunc makeTranslationMatrix(tx: Float, ty: Float) -> simd_float3x3 {\n    var matrix = matrix_identity_float3x3\n    \n    matrix[2, 0] = tx\n    matrix[2, 1] = ty\n    \n    return matrix\n}\n```\n\nTo apply a translate to the position vector, you multiply the pair together:\n\n```swift\nlet translationMatrix = makeTranslationMatrix(tx: 1, ty: 3)\nlet translatedVector = translationMatrix * positionVector\n```\n\nThe resulting `translatedVector` has the values `(x: 4.0, y: 5.0, z: 1.0)`, shown as **B** in the illustration above.\n\n#### Rotate\n\nA rotation matrix around the z-axis (that is, on the xy plane) takes the following form:\n\n\n\nThe following function returns a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3x3] matrix using the specified rotation angle in radians:\n\n```swift\nfunc makeRotationMatrix(angle: Float) -> simd_float3x3 {\n    let rows = [\n        simd_float3(cos(angle), -sin(angle), 0),\n        simd_float3(sin(angle), cos(angle), 0),\n        simd_float3(0,          0,          1)\n    ]\n    \n    return float3x3(rows: rows)\n}\n```\n\nTo apply a rotation to the previously translated vector, you multiply the pair together:\n\n```swift\nlet angle = Measurement(value: 30,\n                        unit: UnitAngle.degrees)\nlet radians = Float(angle.converted(to: .radians).value)\n\nlet rotationMatrix = makeRotationMatrix(angle: radians)\nlet rotatedVector = rotationMatrix * translatedVector\n```\n\nThe resulting `rotatedVector` has the values `(x: 0.964102, y: 6.33013, z: 1.0)`, shown as **C** in the illustration above.\n\n#### Scale\n\nA scale matrix takes the following form:\n\n\n\nThe following function returns a [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_float3x3] matrix using the specified x and y scale values:\n\n```swift\nfunc makeScaleMatrix(xScale: Float, yScale: Float) -> simd_float3x3 {\n    let rows = [\n        simd_float3(xScale,      0, 0),\n        simd_float3(     0, yScale, 0),\n        simd_float3(     0,      0, 1)\n    ]\n    \n    return float3x3(rows: rows)\n}\n```\n\nTo apply a scale to the previously rotated vector, you multiply the pair together:\n\n```swift\nlet scaleMatrix = makeScaleMatrix(xScale: 8, yScale: 1.25)\nlet scaledVector = scaleMatrix * rotatedVector\n```\n\nThe resulting `scaledVector` has the values `(x: 7.71282, y: 7.91266, z: 1.0)`, shown as **D** in the illustration above.\n\nThe three transform matrices can be multiplied together and the product multiplied with the position vector to get the same result:\n\n```swift\nlet transformMatrix = scaleMatrix * rotationMatrix * translationMatrix\nlet transformedVector = transformMatrix * positionVector\n```\n\n## Vectors, Matrices, and Quaternions\n\n- **Working with Vectors**: Use vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.\n- **Working with Quaternions**: Rotate points around the surface of a sphere, and interpolate between them.\n- **Rotating a cube by transforming its vertices**: Rotate a cube through a series of keyframes using quaternion interpolation to transition between them.\n- **simd**: Perform computations on small vectors and matrices.\n- **vForce**: Perform transcendental and trigonometric functions on vectors of any length.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.",
          "name" : "Working with Vectors",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-vectors"
        },
        {
          "description" : "Rotate points around the surface of a sphere, and interpolate between them.",
          "name" : "Working with Quaternions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-quaternions"
        },
        {
          "description" : "Rotate a cube through a series of keyframes using quaternion interpolation to transition between them.",
          "name" : "Rotating a cube by transforming its vertices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/rotating-a-cube-by-transforming-its-vertices"
        },
        {
          "description" : "Perform computations on small vectors and matrices.",
          "name" : "simd",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/simd-library"
        },
        {
          "description" : "Perform transcendental and trigonometric functions on vectors of any length.",
          "name" : "vForce",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vforce-library"
        }
      ],
      "title" : "Vectors, Matrices, and Quaternions"
    }
  ],
  "source" : "appleJSON",
  "title" : "Working with Matrices",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-matrices"
}