{
  "abstract" : "A flag that instructs the filter to use pointers to data you provide at creation time.",
  "codeExamples" : [
    {
      "code" : "let weights: [Float] = [ ... ]\nlet bias: [Float] = [ ... ]\n\nlet convolutionLayer = weights.withUnsafeBufferPointer { weightsPtr -> BNNSFilter? in\n    bias.withUnsafeMutableBufferPointer { biasPtr in\n        \n        let weightsDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                      layout: BNNSDataLayoutConvolutionWeightsOIHW,\n                                                      size: (3, 3, 1, 1, 0, 0, 0, 0),\n                                                      stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                      data: UnsafeMutableRawPointer(mutating: weightsPtr.baseAddress!),\n                                                      data_type: .float,\n                                                      table_data: nil,\n                                                      table_data_type: .float,\n                                                      data_scale: 1,\n                                                      data_bias: 0)\n        \n        let biasDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                   layout: BNNSDataLayoutVector,\n                                                   size: (1, 0, 0, 1, 0, 0, 0, 0),\n                                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                   data: biasPtr.baseAddress,\n                                                   data_type: .float,\n                                                   table_data: nil,\n                                                   table_data_type: .float,\n                                                   data_scale: 1,\n                                                   data_bias: 0)\n        \n        var layerParameters = BNNSLayerParametersConvolution(i_desc: inDescriptor,\n                                                        w_desc: weightsDescriptor,\n                                                        o_desc: outDescriptor,\n                                                        bias: biasDescriptor,\n                                                        activation: .identity,\n                                                        x_stride: 1, y_stride: 1,\n                                                        x_dilation_stride: 0, y_dilation_stride: 0,\n                                                        x_padding: 0, y_padding: 0,\n                                                        groups: 1,\n                                                        pad: (0, 0, 0, 0))\n        \n        var filterParameters = BNNSFilterParameters(flags: BNNSFlags.useClientPointer.rawValue,\n                                                    n_threads: 1,\n                                                    alloc_memory: nil,\n                                                    free_memory: nil)\n        \n        return  BNNSFilterCreateLayerConvolution(&layerParameters, &filterParameters)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "31ae7e972bdefcc352eab2daadc27786fd044bfad58b69e78b00ed3c7e38e4e4",
  "crawledAt" : "2025-12-05T07:36:49Z",
  "declaration" : {
    "code" : "static var useClientPointer: BNNSFlags { get }",
    "language" : "swift"
  },
  "id" : "A4866934-2612-4AFB-8509-3EF07B1D772B",
  "kind" : "property",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nSet this flag to instruct the filter to keep the pointers you provide at creation time and to work directly from this data. In this case, the you must ensure these pointers remain valid through the entire lifetime of the filter.\n\nIf not set, the filter creation function allocates buffers and keeps an internal copy of the data. In that case, you don’t have to keep the pointers valid after the you’ve created the filter.\n\nThe following code returns a convolution layer with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSFlags\/useClientPointer] set:\n\nIf either `weights` or `bias` mutate before calling [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSFilterApplyBatch(_:_:_:_:_:_:)], the filter uses the new values. However, the convolution layer works with its internal copies of weights and bias if you pass a `flags` of `0`, and subsequent changes have no effect.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFlags\/useClientPointer\ncrawled: 2025-12-05T07:36:49Z\n---\n\n# useClientPointer\n\n**Type Property**\n\nA flag that instructs the filter to use pointers to data you provide at creation time.\n\n## Declaration\n\n```swift\nstatic var useClientPointer: BNNSFlags { get }\n```\n\n## Discussion\n\nSet this flag to instruct the filter to keep the pointers you provide at creation time and to work directly from this data. In this case, the you must ensure these pointers remain valid through the entire lifetime of the filter.\n\nIf not set, the filter creation function allocates buffers and keeps an internal copy of the data. In that case, you don’t have to keep the pointers valid after the you’ve created the filter.\n\nThe following code returns a convolution layer with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSFlags\/useClientPointer] set:\n\n```swift\nlet weights: [Float] = [ ... ]\nlet bias: [Float] = [ ... ]\n\nlet convolutionLayer = weights.withUnsafeBufferPointer { weightsPtr -> BNNSFilter? in\n    bias.withUnsafeMutableBufferPointer { biasPtr in\n        \n        let weightsDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                      layout: BNNSDataLayoutConvolutionWeightsOIHW,\n                                                      size: (3, 3, 1, 1, 0, 0, 0, 0),\n                                                      stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                      data: UnsafeMutableRawPointer(mutating: weightsPtr.baseAddress!),\n                                                      data_type: .float,\n                                                      table_data: nil,\n                                                      table_data_type: .float,\n                                                      data_scale: 1,\n                                                      data_bias: 0)\n        \n        let biasDescriptor = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                                   layout: BNNSDataLayoutVector,\n                                                   size: (1, 0, 0, 1, 0, 0, 0, 0),\n                                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                                   data: biasPtr.baseAddress,\n                                                   data_type: .float,\n                                                   table_data: nil,\n                                                   table_data_type: .float,\n                                                   data_scale: 1,\n                                                   data_bias: 0)\n        \n        var layerParameters = BNNSLayerParametersConvolution(i_desc: inDescriptor,\n                                                        w_desc: weightsDescriptor,\n                                                        o_desc: outDescriptor,\n                                                        bias: biasDescriptor,\n                                                        activation: .identity,\n                                                        x_stride: 1, y_stride: 1,\n                                                        x_dilation_stride: 0, y_dilation_stride: 0,\n                                                        x_padding: 0, y_padding: 0,\n                                                        groups: 1,\n                                                        pad: (0, 0, 0, 0))\n        \n        var filterParameters = BNNSFilterParameters(flags: BNNSFlags.useClientPointer.rawValue,\n                                                    n_threads: 1,\n                                                    alloc_memory: nil,\n                                                    free_memory: nil)\n        \n        return  BNNSFilterCreateLayerConvolution(&layerParameters, &filterParameters)\n    }\n}\n```\n\nIf either `weights` or `bias` mutate before calling [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSFilterApplyBatch(_:_:_:_:_:_:)], the filter uses the new values. However, the convolution layer works with its internal copies of weights and bias if you pass a `flags` of `0`, and subsequent changes have no effect.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "useClientPointer",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFlags\/useClientPointer"
}