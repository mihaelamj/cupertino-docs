{
  "abstract" : "Perform fast Fourier transforms out of place on 2D real data.",
  "codeExamples" : [
    {
      "code" : "N0 = 1 << Log2N0;\nN1 = 1 << Log2N1;\n\nif (IA1 == 0) IA1 = IA0*N0\/2;\nif (IC1 == 0) IC1 = IC0*N0\/2;\n\nscale = 2;\n\n\/\/ Define a real matrix, h:\nfor (j1 = 0; j1 < N1  ; ++j1)\nfor (j0 = 0; j0 < N0\/2; ++j0)\n{\n    h[j1][2*j0+0] = A->realp[j1*IA1 + j0*IA0]\n              + i * A->imagp[j1*IA1 + j0*IA0];\n    h[j1][2*j0+1] = A->realp[j1*IA1 + j0*IA0]\n              + i * A->imagp[j1*IA1 + j0*IA0];\n}\n\n\/\/ Perform Discrete Fourier Transform.\nfor (k1 = 0; k1 < N1; ++k1)\nfor (k0 = 0; k0 < N0; ++k0)\n    H[k1][k0] = scale * sum(sum(h[j1][j0]\n        * e**(-Direction*2*pi*i*j0*k0\/N0), 0 <= j0 < N0)\n        * e**(-Direction*2*pi*i*j1*k1\/N1), 0 <= j1 < N1);\n\n\/\/ Pack special pure-real elements into output matrix:\nC->realp[0*IC1][0*IC0] = H[0   ][0   ].\nC->imagp[0*IC1][0*IC0] = H[0   ][N0\/2]\nC->realp[1*IC1][0*IC0] = H[N1\/2][0   ].\nC->imagp[1*IC1][0*IC0] = H[N1\/2][N0\/2]\n\n\/\/ Pack two vectors into output matrix \"vertically\":\n\/\/ (This awkward format is due to a legacy implementation.)\nfor (k1 = 1; k1 < N1\/2; ++k1)\n{\n    C->realp[(2*k1+0)*IC1][0*IC0] = Re(H[k1][0   ]);\n    C->realp[(2*k1+1)*IC1][0*IC0] = Im(H[k1][0   ]);\n    C->imagp[(2*k1+0)*IC1][0*IC0] = Re(H[k1][N0\/2]);\n    C->imagp[(2*k1+1)*IC1][0*IC0] = Im(H[k1][N0\/2]);\n}\n\n\/\/ Store regular elements:\nfor (k1 = 0; k1 < N1  ; ++k1)\nfor (k0 = 1; k0 < N0\/2; ++k0)\n{\n    C->realp[k1*IC1 + k0*IC0] = Re(H[k1][k0]);\n    C->imagp[k1*IC1 + k0*IC0] = Im(H[k1][k0]);\n}\n\n",
      "language" : "c"
    },
    {
      "code" : "N0 = 1 << Log2N0;\nN1 = 1 << Log2N1;\n\nif (IA1 == 0) IA1 = IA0*N0\/2;\nif (IC1 == 0) IC1 = IC0*N0\/2;\n\nscale = 1. \/ (N1*N0);\n\n\/\/ Define a complex matrix, h, in multiple steps:\n\n\/\/ Unpack the special elements:\nh[0   ][0   ] = A->realp[0*IA1][0*IA0];\nh[0   ][N0\/2] = A->imagp[0*IA1][0*IA0];\nh[N1\/2][0   ] = A->realp[1*IA1][0*IA0];\nh[N1\/2][N0\/2] = A->imagp[1*IA1][0*IA0];\n\n\/\/ Unpack the two vectors from \"vertical\" storage:\nfor (j1 = 1; j1 < N1\/2; ++j1)\n{\n    h[j1][0   ] = A->realp[(2*j1+0)*IA1][0*IA0]\n            + i * A->realp[(2*j1+1)*IA1][0*IA0]\n    h[j1][N0\/2] = A->imagp[(2*j1+0)*IA1][0*IA0]\n            + i * A->imagp[(2*j1+1)*IA1][0*IA0]\n}\n\n\/\/ Take regular elements:\nfor (j1 = 0; j1 < N1  ; ++j1)\nfor (j0 = 1; j0 < N0\/2; ++j0)\n{\n    h[j1][j0   ] = A->realp[j1*IA1 + j0*IA0]\n             + i * A->imagp[j1*IA1 + j0*IA0];\n    h[j1][N0-j0] = conj(h[j1][j0]);\n}\n\n\/\/ Perform Discrete Fourier Transform.\nfor (k1 = 0; k1 < N1; ++k1)\nfor (k0 = 0; k0 < N0; ++k0)\n    H[k1][k0] = scale * sum(sum(h[j1][j0]\n        * e**(-Direction*2*pi*i*j0*k0\/N0), 0 <= j0 < N0)\n        * e**(-Direction*2*pi*i*j1*k1\/N1), 0 <= j1 < N1);\n\n\/\/ Store result.\nfor (k1 = 0; k1 < N1  ; ++k1)\nfor (k0 = 0; k0 < N0\/2; ++k0)\n{\n    C->realp[k1*IC1 + k0*IC0] = Re(H[k1][2*k0+0]);\n    C->imagp[k1*IC1 + k0*IC0] = Im(H[k1][2*k0+1]);\n}\n",
      "language" : "c"
    }
  ],
  "contentHash" : "6f4a7f2473ec8650f3a9778b09d54af00fb87dec13c1ef68aa82cc207a915c5f",
  "crawledAt" : "2025-12-02T16:10:04Z",
  "id" : "A8584435-1CED-4EED-A16C-72F3810EA806",
  "kind" : "collection",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThe functions in this group use the following operation for a forward real-to-complex transform:\n\nThe functions in this group use the following operation for an inverse complex-to-real transform:\n\nThe temporary buffer versions perform the same operation but use a temporary buffer for improved performance.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/out-of-place-functions-for-2d-real-fft\ncrawled: 2025-12-02T16:10:04Z\n---\n\n# Out-of-Place Functions for 2D Real FFT\n\n**API Collection**\n\nPerform fast Fourier transforms out of place on 2D real data.\n\n## Overview\n\nThe functions in this group use the following operation for a forward real-to-complex transform:\n\n```c\nN0 = 1 << Log2N0;\nN1 = 1 << Log2N1;\n\nif (IA1 == 0) IA1 = IA0*N0\/2;\nif (IC1 == 0) IC1 = IC0*N0\/2;\n\nscale = 2;\n\n\/\/ Define a real matrix, h:\nfor (j1 = 0; j1 < N1  ; ++j1)\nfor (j0 = 0; j0 < N0\/2; ++j0)\n{\n    h[j1][2*j0+0] = A->realp[j1*IA1 + j0*IA0]\n              + i * A->imagp[j1*IA1 + j0*IA0];\n    h[j1][2*j0+1] = A->realp[j1*IA1 + j0*IA0]\n              + i * A->imagp[j1*IA1 + j0*IA0];\n}\n\n\/\/ Perform Discrete Fourier Transform.\nfor (k1 = 0; k1 < N1; ++k1)\nfor (k0 = 0; k0 < N0; ++k0)\n    H[k1][k0] = scale * sum(sum(h[j1][j0]\n        * e**(-Direction*2*pi*i*j0*k0\/N0), 0 <= j0 < N0)\n        * e**(-Direction*2*pi*i*j1*k1\/N1), 0 <= j1 < N1);\n\n\/\/ Pack special pure-real elements into output matrix:\nC->realp[0*IC1][0*IC0] = H[0   ][0   ].\nC->imagp[0*IC1][0*IC0] = H[0   ][N0\/2]\nC->realp[1*IC1][0*IC0] = H[N1\/2][0   ].\nC->imagp[1*IC1][0*IC0] = H[N1\/2][N0\/2]\n\n\/\/ Pack two vectors into output matrix \"vertically\":\n\/\/ (This awkward format is due to a legacy implementation.)\nfor (k1 = 1; k1 < N1\/2; ++k1)\n{\n    C->realp[(2*k1+0)*IC1][0*IC0] = Re(H[k1][0   ]);\n    C->realp[(2*k1+1)*IC1][0*IC0] = Im(H[k1][0   ]);\n    C->imagp[(2*k1+0)*IC1][0*IC0] = Re(H[k1][N0\/2]);\n    C->imagp[(2*k1+1)*IC1][0*IC0] = Im(H[k1][N0\/2]);\n}\n\n\/\/ Store regular elements:\nfor (k1 = 0; k1 < N1  ; ++k1)\nfor (k0 = 1; k0 < N0\/2; ++k0)\n{\n    C->realp[k1*IC1 + k0*IC0] = Re(H[k1][k0]);\n    C->imagp[k1*IC1 + k0*IC0] = Im(H[k1][k0]);\n}\n\n\n```\n\nThe functions in this group use the following operation for an inverse complex-to-real transform:\n\n```c\nN0 = 1 << Log2N0;\nN1 = 1 << Log2N1;\n\nif (IA1 == 0) IA1 = IA0*N0\/2;\nif (IC1 == 0) IC1 = IC0*N0\/2;\n\nscale = 1. \/ (N1*N0);\n\n\/\/ Define a complex matrix, h, in multiple steps:\n\n\/\/ Unpack the special elements:\nh[0   ][0   ] = A->realp[0*IA1][0*IA0];\nh[0   ][N0\/2] = A->imagp[0*IA1][0*IA0];\nh[N1\/2][0   ] = A->realp[1*IA1][0*IA0];\nh[N1\/2][N0\/2] = A->imagp[1*IA1][0*IA0];\n\n\/\/ Unpack the two vectors from \"vertical\" storage:\nfor (j1 = 1; j1 < N1\/2; ++j1)\n{\n    h[j1][0   ] = A->realp[(2*j1+0)*IA1][0*IA0]\n            + i * A->realp[(2*j1+1)*IA1][0*IA0]\n    h[j1][N0\/2] = A->imagp[(2*j1+0)*IA1][0*IA0]\n            + i * A->imagp[(2*j1+1)*IA1][0*IA0]\n}\n\n\/\/ Take regular elements:\nfor (j1 = 0; j1 < N1  ; ++j1)\nfor (j0 = 1; j0 < N0\/2; ++j0)\n{\n    h[j1][j0   ] = A->realp[j1*IA1 + j0*IA0]\n             + i * A->imagp[j1*IA1 + j0*IA0];\n    h[j1][N0-j0] = conj(h[j1][j0]);\n}\n\n\/\/ Perform Discrete Fourier Transform.\nfor (k1 = 0; k1 < N1; ++k1)\nfor (k0 = 0; k0 < N0; ++k0)\n    H[k1][k0] = scale * sum(sum(h[j1][j0]\n        * e**(-Direction*2*pi*i*j0*k0\/N0), 0 <= j0 < N0)\n        * e**(-Direction*2*pi*i*j1*k1\/N1), 0 <= j1 < N1);\n\n\/\/ Store result.\nfor (k1 = 0; k1 < N1  ; ++k1)\nfor (k0 = 0; k0 < N0\/2; ++k0)\n{\n    C->realp[k1*IC1 + k0*IC0] = Re(H[k1][2*k0+0]);\n    C->imagp[k1*IC1 + k0*IC0] = Im(H[k1][2*k0+1]);\n}\n\n```\n\nThe temporary buffer versions perform the same operation but use a temporary buffer for improved performance.\n\n## Out-of-Place FFT Functions\n\n- **vDSP_fft2d_zrop**: Computes a 2D forward or inverse out-of-place, single-precision real FFT.\n- **vDSP_fft2d_zropD**: Computes a 2D forward or inverse out-of-place, double-precision real FFT.\n\n## Out-of-Place FFT Functions with Temporary Buffer\n\n- **vDSP_fft2d_zropt**: Computes a 2D forward or inverse out-of-place, single-precision real FFT using a temporary buffer.\n- **vDSP_fft2d_zroptD**: Computes a 2D forward or inverse out-of-place, double-precision real FFT using a temporary buffer.\n\n## Functions for 2D Real FFT\n\n- **In-Place Functions for 2D Real FFT**: Perform fast Fourier transforms in place on 2D real data.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Computes a 2D forward or inverse out-of-place, single-precision real FFT.",
          "name" : "vDSP_fft2d_zrop",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP_fft2d_zrop"
        },
        {
          "description" : "Computes a 2D forward or inverse out-of-place, double-precision real FFT.",
          "name" : "vDSP_fft2d_zropD",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP_fft2d_zropD"
        }
      ],
      "title" : "Out-of-Place FFT Functions"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Computes a 2D forward or inverse out-of-place, single-precision real FFT using a temporary buffer.",
          "name" : "vDSP_fft2d_zropt",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP_fft2d_zropt"
        },
        {
          "description" : "Computes a 2D forward or inverse out-of-place, double-precision real FFT using a temporary buffer.",
          "name" : "vDSP_fft2d_zroptD",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vDSP_fft2d_zroptD"
        }
      ],
      "title" : "Out-of-Place FFT Functions with Temporary Buffer"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Perform fast Fourier transforms in place on 2D real data.",
          "name" : "In-Place Functions for 2D Real FFT",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/in-place-functions-for-2d-real-fft"
        }
      ],
      "title" : "Functions for 2D Real FFT"
    }
  ],
  "source" : "appleJSON",
  "title" : "Out-of-Place Functions for 2D Real FFT",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/out-of-place-functions-for-2d-real-fft"
}