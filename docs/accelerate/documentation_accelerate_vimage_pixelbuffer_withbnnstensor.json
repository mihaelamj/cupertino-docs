{
  "abstract" : "Calls the given closure with a pointer to a BNNS tensor that shares memory with the pixel buffer.",
  "codeExamples" : [
    {
      "code" : "let context = try BNNSGraph.makeContext {\n   builder in\n\n   let src = builder.argument(name: \"source\",\n                              dataType: Float16.self,\n                              shape: [<height, width, channels count>])\n\n   let mean = src.mean(axes: [0, 1], keepDimensions: false)\n\n   let thresholded = src .> mean\n\n   let result = thresholded.cast(to: Float16.self)\n\n   return [result]\n}"
    },
    {
      "code" : "let source = vImage.PixelBuffer<vImage.Planar16F>(...)\nlet destination = vImage.PixelBuffer<vImage.Planar16F>(...)\nsource.withBNNSTensor { src in\n    destination.withBNNSTensor { dst in\n\n        var args = [dst, src]\n\n        try! context.executeFunction(arguments: &args)\n    }\n}"
    },
    {
      "code" : "   let sourcePixels: [Float] = [\n       001, 002, 003, 004,     005, 006, 007, 008,     009, 010, 011, 012,\n       013, 014, 015, 016,     017, 018, 019, 020,     021, 022, 023, 024,\n       025, 026, 027, 028,     029, 030, 031, 032,     033, 034, 035, 036,\n       037, 038, 039, 040,     041, 042, 043, 044,     045, 046, 047, 048,\n       049, 050, 051, 052,     053, 054, 055, 056,     057, 058, 059, 060\n   ]\n\n   let source = vImage.PixelBuffer(pixelValues: sourcePixels,\n                                   size: .init(width: 3, height: 5),\n                                   pixelFormat: vImage.InterleavedFx4.self)\n\n   let destination = vImage.PixelBuffer(size: .init(width: 2, height: 3),\n                                        pixelFormat: vImage.InterleavedFx4.self)\n\n   let context = try BNNSGraph.makeContext {\n       builder in\n\n       let src = builder.argument(name: \"source\",\n                                  dataType: Float.self,\n                                  shape: [ -1, -1, -1])\n\n       let result = src[ 0...2,    \/\/ rows 0, 1, 2\n                         1...2,    \/\/ cols 1, 2\n                         0...3 ]   \/\/ channels 0, 1, 2, 3\n\n       return [result]\n   }\n\n   source.withBNNSTensor { src in\n       destination.withBNNSTensor { dst in\n\n           var args = [dst, src]\n           try! context.executeFunction(arguments: &args)\n       }\n   }"
    },
    {
      "code" : "       [\n           005, 006, 007, 008,     009, 010, 011, 012,\n           017, 018, 019, 020,     021, 022, 023, 024,\n           029, 030, 031, 032,     033, 034, 035, 036,\n       ]"
    }
  ],
  "contentHash" : "98e96a195821d991888d479f68a33873f78f84dee6867d6374bf4b8fc8d5319c",
  "crawledAt" : "2025-11-30T22:04:04Z",
  "declaration" : {
    "code" : "func withBNNSTensor<R>(_ body: (BNNSTensor) throws -> R) rethrows -> R",
    "language" : "swift"
  },
  "id" : "411F7677-2540-487E-B4AF-6217DAED23F7",
  "kind" : "method",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nUse this function to pass image data to a `BNNSGraph`. For example, the following code creates a graph that calculates the mean value of an image and apply a threshold based on the mean.\n\nUse `withBNNSTensor()` to pass source and destination pixel buffers to the context:\n\nOn return, `destination` contains the thresholded image data.\n\nNote that the tensor that this function creates has the shape `height, width, channels count`.  If you appy a slice operation to a pixel buffer back tensor, the first dimension is the height and the second dimension is the width.\n\nFor example, given the following code:\n\nThe slice selects rows 0, 1, and 2 and columns 1 and 2. On return, `destination` contains the following values:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/vImage\/PixelBuffer\/withBNNSTensor(_:)\ncrawled: 2025-11-30T22:04:04Z\n---\n\n# withBNNSTensor(_:)\n\n**Instance Method**\n\nCalls the given closure with a pointer to a BNNS tensor that shares memory with the pixel buffer.\n\n## Declaration\n\n```swift\nfunc withBNNSTensor<R>(_ body: (BNNSTensor) throws -> R) rethrows -> R\n```\n\n## Parameters\n\n- **body**: A closure with a `BNNSTensor` parameter\n\n## Discussion\n\nUse this function to pass image data to a `BNNSGraph`. For example, the following code creates a graph that calculates the mean value of an image and apply a threshold based on the mean.\n\n```\nlet context = try BNNSGraph.makeContext {\n   builder in\n\n   let src = builder.argument(name: \"source\",\n                              dataType: Float16.self,\n                              shape: [<height, width, channels count>])\n\n   let mean = src.mean(axes: [0, 1], keepDimensions: false)\n\n   let thresholded = src .> mean\n\n   let result = thresholded.cast(to: Float16.self)\n\n   return [result]\n}\n```\n\nUse `withBNNSTensor()` to pass source and destination pixel buffers to the context:\n\n```\nlet source = vImage.PixelBuffer<vImage.Planar16F>(...)\nlet destination = vImage.PixelBuffer<vImage.Planar16F>(...)\nsource.withBNNSTensor { src in\n    destination.withBNNSTensor { dst in\n\n        var args = [dst, src]\n\n        try! context.executeFunction(arguments: &args)\n    }\n}\n```\n\nOn return, `destination` contains the thresholded image data.\n\nNote that the tensor that this function creates has the shape `height, width, channels count`.  If you appy a slice operation to a pixel buffer back tensor, the first dimension is the height and the second dimension is the width.\n\nFor example, given the following code:\n\n```\n   let sourcePixels: [Float] = [\n       001, 002, 003, 004,     005, 006, 007, 008,     009, 010, 011, 012,\n       013, 014, 015, 016,     017, 018, 019, 020,     021, 022, 023, 024,\n       025, 026, 027, 028,     029, 030, 031, 032,     033, 034, 035, 036,\n       037, 038, 039, 040,     041, 042, 043, 044,     045, 046, 047, 048,\n       049, 050, 051, 052,     053, 054, 055, 056,     057, 058, 059, 060\n   ]\n\n   let source = vImage.PixelBuffer(pixelValues: sourcePixels,\n                                   size: .init(width: 3, height: 5),\n                                   pixelFormat: vImage.InterleavedFx4.self)\n\n   let destination = vImage.PixelBuffer(size: .init(width: 2, height: 3),\n                                        pixelFormat: vImage.InterleavedFx4.self)\n\n   let context = try BNNSGraph.makeContext {\n       builder in\n\n       let src = builder.argument(name: \"source\",\n                                  dataType: Float.self,\n                                  shape: [ -1, -1, -1])\n\n       let result = src[ 0...2,    \/\/ rows 0, 1, 2\n                         1...2,    \/\/ cols 1, 2\n                         0...3 ]   \/\/ channels 0, 1, 2, 3\n\n       return [result]\n   }\n\n   source.withBNNSTensor { src in\n       destination.withBNNSTensor { dst in\n\n           var args = [dst, src]\n           try! context.executeFunction(arguments: &args)\n       }\n   }\n```\n\nThe slice selects rows 0, 1, and 2 and columns 1 and 2. On return, `destination` contains the following values:\n\n```\n       [\n           005, 006, 007, 008,     009, 010, 011, 012,\n           017, 018, 019, 020,     021, 022, 023, 024,\n           029, 030, 031, 032,     033, 034, 035, 036,\n       ]\n```\n\n- Returns The return value, if any, of the body closure parameter.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "withBNNSTensor(_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vImage\/PixelBuffer\/withBNNSTensor(_:)"
}