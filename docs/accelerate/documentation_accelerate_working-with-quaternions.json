{
  "abstract" : "Rotate points around the surface of a sphere, and interpolate between them.",
  "codeExamples" : [
    {
      "code" : "let ix = 1.0\nlet iy = 4.0\nlet iz = 8.0\nlet r = 9.0\n\nlet q = simd_quatd(ix: ix, iy: iy, iz: iz, r: r)",
      "language" : "swift"
    },
    {
      "code" : "let axis = simd_double3(x: -2,\n                        y: 1,\n                        z: 0.5)\n\n\/\/ `q1` length = 2.29128\nlet q1 = simd_quatd(angle: .pi,\n                    axis: axis)\n\n\/\/ `q2` length = 1\nlet q2 = simd_quatd(angle: .pi,\n                    axis: simd_normalize(axis))",
      "language" : "swift"
    },
    {
      "code" : "func degreesToRadians(_ degrees: Float) -> Float {\n    return degrees * .pi \/ 180\n}\n\nlet originVector = simd_float3(x: 0, y: 0, z: 1)\n\nlet quaternion = simd_quatf(angle: degreesToRadians(-60),\n                            axis: simd_float3(x: 1,\n                                              y: 0,\n                                              z: 0))",
      "language" : "swift"
    },
    {
      "code" : "let rotatedVector = quaternion.act(originVector)",
      "language" : "swift"
    },
    {
      "code" : "let origin = simd_float3(0, 0, 1)\n\nlet q0 = simd_quatf(angle: .pi \/ 6,\n                    axis: simd_normalize(simd_float3(x: 0,\n                                                     y: -1,\n                                                     z: 0)))\nlet u0 = simd_act(q0, origin)\n\nlet q1 = simd_quatf(angle: .pi \/ 6,\n                    axis: simd_normalize(simd_float3(x: -1,\n                                                     y: 1,\n                                                     z: 0)))\nlet u1 = simd_act(q1, origin)\n\nlet q2 = simd_quatf(angle: .pi \/ 20,\n                    axis: simd_normalize(simd_float3(x: 1,\n                                                     y: 0,\n                                                     z: -1)))",
      "language" : "swift"
    },
    {
      "code" : "for t: Float in stride(from: 0, to: 1, by: 0.001) {\n    let q = simd_slerp(q0, q1, t)\n    \/\/ code to add line segment at `q.act(origin)`\n}",
      "language" : "swift"
    },
    {
      "code" : "for t: Float in stride(from: 0, to: 1, by: 0.001) {\n    let q = simd_slerp_longest(q1, q2, t)\n    \/\/ code to add line segment at `q.act(origin)`\n}",
      "language" : "swift"
    },
    {
      "code" : "let rotations: [simd_quatf] = ...\n\nfor i in 1 ... rotations.count - 3 {\n    for t: Float in stride(from: 0, to: 1, by: 0.001) {\n        let q = simd_spline(rotations[i - 1],\n                            rotations[i],\n                            rotations[i + 1],\n                            rotations[i + 2],\n                            t)\n        \/\/ code to add line segment at `q.act(origin)`\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "7413dbe47b634899814284cb81ab4dba516c10f17a833fa2351e5baf1586ba2e",
  "crawledAt" : "2025-12-02T15:55:32Z",
  "id" : "CAE6F247-C340-4DF3-B0EB-2CE42E0C1DD9",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nQuaternions are defined by a scalar (*real*) part, and three imaginary parts collectively called the *vector* part. Quaternions are often used in graphics programming as a compact representation of the rotation of an object in three dimensions.\n\nThe length of a quaternion is the square root of the sum of the squares of its components. For example, consider a quaternion specified by the following code:\n\nThe length of the quaternion can be calculated manually with `sqrt(ix*ix + iy*iy + iz*iz + r*r)`, or more simply accessed through its [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_quatd\/length] property. Quaternions with a length of one are called *unit quaternions* and can represent rotations in 3D space. You can easily convert a nonunit quaternion representing a rotation into a unit quaternion by normalizing its axes. The following code shows `q1`, which contains rotations around all three axes with a length greater than 1, and `q2`, which contains the same rotation but has a length of 1 and is, therefore, suitable for applying a rotation to a 3D coordinate:\n\nQuaternions have some advantages over matrices. For example, they’re smaller: A 3 x 3 matrix of floats is 48 bytes, and a single-precision quaternion is 16 bytes. They also can offer better performance: Although a single rotation using a quaternion is a little slower than one using a matrix, when combining actions, quaternions can be up to 30% faster.\n\nThe following examples show a few common uses of quaternions.\n\n### Rotate a Point Around a Sphere\n\nThe following illustration shows a point, defined by `originVector`, rotated over the surface of a sphere by 60º about the x axis.\n\n\n\nTo apply this rotation, you define the vector to be rotated and the quaternion that represents the rotation:\n\nThe rotation of the vector by a quaternion is known as an *action*; to apply the rotation to `originVector`, you call the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_quatf\/act(_:)] method:\n\n`rotatedVector` is now at the position of the blue point in the illustration above.\n\n### Interpolate Between Two Points on a Sphere\n\nOne of the advantages quaternions have over matrices when representing rotations is that they simplify interpolation between rotated coordinates.\n\nThe following image shows the spherical linear interpolation along the shortest arc between `q0` and `q1`, and along the longest arc between `q1` and `q2`.\n\n\n\nThe following code shows how the three points are defined in the preceding image:\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] function linearly interpolates along the shortest arc between two quaternions. The following code calls [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] with small increments to its `t` parameter, adding a line segment at each interpolated value to build the short arc between `q0` and `q1` shown in the preceding image:\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp_longest(_:_:_:)-3qens] function linearly interpolates along the longest arc between two quaternions. The following code calls [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp_longest(_:_:_:)-3qens] with small increments to its `t` parameter, adding a line segment at each interpolated value to build the long arc between `q1` and `q2` shown in the preceding image:\n\n### Interpolate Between Multiple Points on a Sphere\n\nTo interpolate between multiple quaternions that define positions on the surface of a sphere, the simd library provides the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] function.\n\nThe following image illustrates a series of quaternions that define positions on the surface of a sphere, shown as points, and a line that shows the smooth interpolation between them.\n\n\n\nMuch like [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db], [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] accepts the two quaternions to interpolate between, but also requires the surrounding two quaternions. Given an array of quaternions named `rotations`, the following code iterates over each element, adding a line segment at each interpolated value to build the smooth line shown in the preceding image:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-quaternions\ncrawled: 2025-12-02T15:55:32Z\n---\n\n# Working with Quaternions\n\n**Article**\n\nRotate points around the surface of a sphere, and interpolate between them.\n\n## Overview\n\nQuaternions are defined by a scalar (*real*) part, and three imaginary parts collectively called the *vector* part. Quaternions are often used in graphics programming as a compact representation of the rotation of an object in three dimensions.\n\nThe length of a quaternion is the square root of the sum of the squares of its components. For example, consider a quaternion specified by the following code:\n\n```swift\nlet ix = 1.0\nlet iy = 4.0\nlet iz = 8.0\nlet r = 9.0\n\nlet q = simd_quatd(ix: ix, iy: iy, iz: iz, r: r)\n```\n\nThe length of the quaternion can be calculated manually with `sqrt(ix*ix + iy*iy + iz*iz + r*r)`, or more simply accessed through its [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_quatd\/length] property. Quaternions with a length of one are called *unit quaternions* and can represent rotations in 3D space. You can easily convert a nonunit quaternion representing a rotation into a unit quaternion by normalizing its axes. The following code shows `q1`, which contains rotations around all three axes with a length greater than 1, and `q2`, which contains the same rotation but has a length of 1 and is, therefore, suitable for applying a rotation to a 3D coordinate:\n\n```swift\nlet axis = simd_double3(x: -2,\n                        y: 1,\n                        z: 0.5)\n\n\/\/ `q1` length = 2.29128\nlet q1 = simd_quatd(angle: .pi,\n                    axis: axis)\n\n\/\/ `q2` length = 1\nlet q2 = simd_quatd(angle: .pi,\n                    axis: simd_normalize(axis))\n```\n\nQuaternions have some advantages over matrices. For example, they’re smaller: A 3 x 3 matrix of floats is 48 bytes, and a single-precision quaternion is 16 bytes. They also can offer better performance: Although a single rotation using a quaternion is a little slower than one using a matrix, when combining actions, quaternions can be up to 30% faster.\n\nThe following examples show a few common uses of quaternions.\n\n### Rotate a Point Around a Sphere\n\nThe following illustration shows a point, defined by `originVector`, rotated over the surface of a sphere by 60º about the x axis.\n\n\n\nTo apply this rotation, you define the vector to be rotated and the quaternion that represents the rotation:\n\n```swift\nfunc degreesToRadians(_ degrees: Float) -> Float {\n    return degrees * .pi \/ 180\n}\n\nlet originVector = simd_float3(x: 0, y: 0, z: 1)\n\nlet quaternion = simd_quatf(angle: degreesToRadians(-60),\n                            axis: simd_float3(x: 1,\n                                              y: 0,\n                                              z: 0))\n```\n\nThe rotation of the vector by a quaternion is known as an *action*; to apply the rotation to `originVector`, you call the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_quatf\/act(_:)] method:\n\n```swift\nlet rotatedVector = quaternion.act(originVector)\n```\n\n`rotatedVector` is now at the position of the blue point in the illustration above.\n\n### Interpolate Between Two Points on a Sphere\n\nOne of the advantages quaternions have over matrices when representing rotations is that they simplify interpolation between rotated coordinates.\n\nThe following image shows the spherical linear interpolation along the shortest arc between `q0` and `q1`, and along the longest arc between `q1` and `q2`.\n\n\n\nThe following code shows how the three points are defined in the preceding image:\n\n```swift\nlet origin = simd_float3(0, 0, 1)\n\nlet q0 = simd_quatf(angle: .pi \/ 6,\n                    axis: simd_normalize(simd_float3(x: 0,\n                                                     y: -1,\n                                                     z: 0)))\nlet u0 = simd_act(q0, origin)\n\nlet q1 = simd_quatf(angle: .pi \/ 6,\n                    axis: simd_normalize(simd_float3(x: -1,\n                                                     y: 1,\n                                                     z: 0)))\nlet u1 = simd_act(q1, origin)\n\nlet q2 = simd_quatf(angle: .pi \/ 20,\n                    axis: simd_normalize(simd_float3(x: 1,\n                                                     y: 0,\n                                                     z: -1)))\n```\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] function linearly interpolates along the shortest arc between two quaternions. The following code calls [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db] with small increments to its `t` parameter, adding a line segment at each interpolated value to build the short arc between `q0` and `q1` shown in the preceding image:\n\n```swift\nfor t: Float in stride(from: 0, to: 1, by: 0.001) {\n    let q = simd_slerp(q0, q1, t)\n    \/\/ code to add line segment at `q.act(origin)`\n}\n```\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp_longest(_:_:_:)-3qens] function linearly interpolates along the longest arc between two quaternions. The following code calls [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp_longest(_:_:_:)-3qens] with small increments to its `t` parameter, adding a line segment at each interpolated value to build the long arc between `q1` and `q2` shown in the preceding image:\n\n```swift\nfor t: Float in stride(from: 0, to: 1, by: 0.001) {\n    let q = simd_slerp_longest(q1, q2, t)\n    \/\/ code to add line segment at `q.act(origin)`\n}\n```\n\n### Interpolate Between Multiple Points on a Sphere\n\nTo interpolate between multiple quaternions that define positions on the surface of a sphere, the simd library provides the [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] function.\n\nThe following image illustrates a series of quaternions that define positions on the surface of a sphere, shown as points, and a line that shows the smooth interpolation between them.\n\n\n\nMuch like [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_slerp(_:_:_:)-u2db], [doc:\/\/com.apple.accelerate\/documentation\/simd\/simd_spline(_:_:_:_:_:)-1ok51] accepts the two quaternions to interpolate between, but also requires the surrounding two quaternions. Given an array of quaternions named `rotations`, the following code iterates over each element, adding a line segment at each interpolated value to build the smooth line shown in the preceding image:\n\n```swift\nlet rotations: [simd_quatf] = ...\n\nfor i in 1 ... rotations.count - 3 {\n    for t: Float in stride(from: 0, to: 1, by: 0.001) {\n        let q = simd_spline(rotations[i - 1],\n                            rotations[i],\n                            rotations[i + 1],\n                            rotations[i + 2],\n                            t)\n        \/\/ code to add line segment at `q.act(origin)`\n    }\n}\n```\n\n## Vectors, Matrices, and Quaternions\n\n- **Working with Vectors**: Use vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.\n- **Working with Matrices**: Solve simultaneous equations and transform points in space.\n- **Rotating a cube by transforming its vertices**: Rotate a cube through a series of keyframes using quaternion interpolation to transition between them.\n- **simd**: Perform computations on small vectors and matrices.\n- **vForce**: Perform transcendental and trigonometric functions on vectors of any length.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use vectors to calculate geometric values, calculate dot products and cross products, and interpolate between values.",
          "name" : "Working with Vectors",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-vectors"
        },
        {
          "description" : "Solve simultaneous equations and transform points in space.",
          "name" : "Working with Matrices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-matrices"
        },
        {
          "description" : "Rotate a cube through a series of keyframes using quaternion interpolation to transition between them.",
          "name" : "Rotating a cube by transforming its vertices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/rotating-a-cube-by-transforming-its-vertices"
        },
        {
          "description" : "Perform computations on small vectors and matrices.",
          "name" : "simd",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/simd-library"
        },
        {
          "description" : "Perform transcendental and trigonometric functions on vectors of any length.",
          "name" : "vForce",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vforce-library"
        }
      ],
      "title" : "Vectors, Matrices, and Quaternions"
    }
  ],
  "source" : "appleJSON",
  "title" : "Working with Quaternions",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/working-with-quaternions"
}