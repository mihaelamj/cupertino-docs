{
  "abstract" : "Use LAPACK to solve a linear system and find an interpolating polynomial to construct new points between a series of known data points.",
  "codeExamples" : [
    {
      "code" : "import simd\n\nlet points: [simd_double2] = [\n    simd_double2(0,    Double.random(in: -10...10)),\n    simd_double2(256,  Double.random(in: -10...10)),\n    simd_double2(512,  Double.random(in: -10...10)),\n    simd_double2(768,  Double.random(in: -10...10)),\n    simd_double2(1023, Double.random(in: -10...10)),\n    ]",
      "language" : "swift"
    },
    {
      "code" : "import Accelerate\n\nlet exponents = (0 ..< points.count).map {\n    return Double($0)\n}\n\nlet vandermonde: [[Double]] = points.map { point in\n    let bases = [Double](repeating: point.x,\n                         count: points.count)\n    return vForce.pow(bases: bases,\n                      exponents: exponents)\n}",
      "language" : "swift"
    },
    {
      "code" : "let coefficients: [Double] = {\n    var a = vandermonde.flatMap { $0 }\n    var b = points.map { $0.y }\n    \n    do {\n        try ViewController.solveLinearSystem(matrixA: &a,\n                                             matrixB: &b,\n                                             count: points.count)\n    } catch {\n        fatalError(\"Unable to solve linear system.\")\n    }\n    \n    vDSP.reverse(&b)\n    \n    return b\n}()",
      "language" : "swift"
    },
    {
      "code" : "static func solveLinearSystem(matrixA: inout [Double],\n                              matrixB: inout [Double],\n                              count: Int) throws {\n    \n    \/\/\/ By default, LAPACK expects matrices in column-major format. Specify transpose to support\n    \/\/\/ the row-major Vandermonde matrix.\n    let trans = Int8(\"T\".utf8.first!)\n    \n    \/\/\/ Pass `-1` to the `lwork` parameter of `dgels_` to calculate the optimal size for the\n    \/\/\/ workspace array. The function writes the optimal size to the `workDimension` variable.\n    var workspaceCount = Double(0)\n    let err = dgels(transpose: trans,\n                    rowCount: count,\n                    columnCount: count,\n                    rightHandSideCount: 1, \n                    matrixA: &matrixA, leadingDimensionA: count,\n                    matrixB: &matrixB, leadingDimensionB: count,\n                    workspace: &workspaceCount,\n                    workspaceCount: -1)\n    \n    if err != 0 {\n        throw LAPACKError.internalError\n    }\n    \n    \/\/\/  Create the workspace array based on the workspace query result.\n    var workspace = UnsafeMutablePointer<Double>.allocate(\n        capacity: Int(workspaceCount))\n    defer {\n        workspace.deallocate()\n    }\n    \n    \/\/\/ Perform the solve by passing the workspace array size to the `lwork` parameter of `dgels_`.\n    let info = dgels(transpose: trans,\n                     rowCount: count,\n                     columnCount: count,\n                     rightHandSideCount: 1, \n                     matrixA: &matrixA, leadingDimensionA: count,\n                     matrixB: &matrixB, leadingDimensionB: count,\n                     workspace: workspace,\n                     workspaceCount: Int(workspaceCount))\n    \n    if info < 0 {\n        throw LAPACKError.parameterHasIllegalValue(parameterIndex: abs(Int(info)))\n    } else if info > 0 {\n        throw LAPACKError.diagonalElementOfTriangularFactorIsZero(index: Int(info))\n    }\n}\n\npublic enum LAPACKError: Swift.Error {\n    case internalError\n    case parameterHasIllegalValue(parameterIndex: Int)\n    case diagonalElementOfTriangularFactorIsZero(index: Int)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ A wrapper around `dgels_` that accepts values rather than pointers to values.\nstatic func dgels(transpose trans: CChar,\n                  rowCount m: Int,\n                  columnCount n: Int,\n                  rightHandSideCount nrhs: Int,\n                  matrixA a:  UnsafeMutablePointer<Double>,\n                  leadingDimensionA lda: Int,\n                  matrixB b:  UnsafeMutablePointer<Double>,\n                  leadingDimensionB ldb: Int,\n                  workspace work:  UnsafeMutablePointer<Double>,\n                  workspaceCount lwork: Int) -> Int32 {\n    \n    var info = Int32(0)\n    \n    withUnsafePointer(to: trans) { trans in\n        withUnsafePointer(to: __LAPACK_int(m)) { m in\n            withUnsafePointer(to: __LAPACK_int(n)) { n in\n                withUnsafePointer(to: __LAPACK_int(nrhs)) { nrhs in\n                    withUnsafePointer(to: __LAPACK_int(lda)) { lda in\n                        withUnsafePointer(to: __LAPACK_int(ldb)) { ldb in\n                            withUnsafePointer(to: __LAPACK_int(lwork)) { lwork in\n                                dgels_(trans, m, n,\n                                       nrhs,\n                                       a, lda,\n                                       b, ldb,\n                                       work, lwork,\n                                       &info)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return info\n}",
      "language" : "swift"
    },
    {
      "code" : "let coefficients: [Float] = [5, 6, 7] \nlet variables: [Float] = [1, 2, 3]  \n\nvar c = [Float](repeating: .nan,\n                count: variables.count)\n\nlet result = vDSP.evaluatePolynomial(usingCoefficients: coefficients,\n                                     withVariables: variables)",
      "language" : "swift"
    },
    {
      "code" : "let ramp = vDSP.ramp(withInitialValue: 0,\n                     increment: Double(1),\n                     count: 1024)\n\nlet polynomialResult = vDSP.evaluatePolynomial(usingCoefficients: coefficients,\n                                               withVariables: ramp)",
      "language" : "swift"
    }
  ],
  "contentHash" : "b2693011489af4c4707c3e968e13e9cfd50bcdd9fee78fc11c4d10eca1ca5a98",
  "crawledAt" : "2025-12-02T15:55:47Z",
  "id" : "424284CE-76C4-409A-8E25-DAEB2747BF54",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThis article demonstrates how you can generate a continuous curve that passes through a small set of points by computing an *interpolating polynomial*. A polynomial is the sum of a series of terms constructed from variables, coefficients, and exponents (for example, *6x³ + 7x²*, where *6* and *7* and the coefficients, and *x* is the variable); and an interpolating polynomial fills in the gaps between the supplied variables and coefficients.\n\nFor any number of data points, there is a unique interpolating polynomial of order (that is, the largest exponent) which is the number of data points minus one. However, for large numbers of data points, this solution can become numerically unstable.\n\nThe image below shows five known points, as white dots, and the values generated by evaluating the found interpolating polynomial, as a red line:\n\n\n\nThe code in this article determines the polynomial coefficients using a Vandermonde matrix based on the x-components of the known points. The coefficients are the solution to *Ax=b*, where *A* is the Vandermonde matrix and *b* is a vector of the y-components of the known points. You’ll use LAPACK to solve *Ax=b*. LAPACK is an acronym for Linear Algebra Package and is a standard software library for numerical linear algebra.\n\n### Generate known data\n\nCreate an array containing five two-element vectors that describe the known data points between which the code interpolates.\n\nIn a real-world app, you will most likely acquire data points from an external source such as a meteorological or financial data source. For this example, specify x-components that are evenly distributed between 0 and 1023, and generate random y-components:\n\n### Create a Vandermonde matrix\n\nConstruct a Vandermonde matrix where the rows are defined by the elements in a source vector that are successively raised to each integer power up to the source vector’s element count, minus one. For example, in the case of a five-element source vector, *x*, the Vandermonde matrix is of the form:\n\n\n\nThe Vandermonde matrix used in this article derives from the x-components of the points you’re interpolating. For example, given the following points:\n\n\n\nThe resulting Vandermonde matrix contains the following values:\n\n\n\nThe following code constructs a Vandermonde matrix from the `points` array:\n\n### Calculate coefficients\n\nThe coefficients for the polynomial are the solution to *Ax=b*, where *A* is the Vandermonde matrix and *b* is the y-components of the known points. For example, using the matrix created in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/finding-an-interpolating-polynomial-using-the-vandermonde-method#Create-a-Vandermonde-matrix], the coefficients are the *x* in the following:\n\n\n\nCreate the function `solveLinearSystem(a:a_rowCount:a_columnCount:b:b_count:)` to encapsulate the LAPACK routines that solve *Ax=b*. Note that LAPACK overwrites *b* with the solution vector, *x*:\n\nOn return, `coefficients` contains the polynomial coefficients.\n\n### Use LAPACK to solve a linear system\n\nUse the LAPACK `dgels` routine to perform the solve. The `dgels` name derives from **d**ouble-precision, **ge**neral-matrix, **l**east-**s**quares.\n\nThis example calls the `dgels` function that’s a wrapper around the underlying LAPACK function `dgels_(_:_:_:_:_:_:_:_:_:_:_:)`. The wrapper provides a more Swift-friendly way of calling the LAPACK function.\n\n### Evaluate the polynomial\n\nThe vDSP [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/evaluatePolynomial(usingCoefficients:withVariables:)-31vi2] function evaluates a polynomial. For example, the following code evaluates a simple polynomial that consists of three variables and three coefficients:\n\nOn return, `result` contains `[18.0, 39.0, 70.0]` by performing the following:\n\n\n\nNote that the number of elements returned by the polynomial evaluation is the same as the number of elements in the `variables` array.\n\nTo create an interpolation result that contains 1024 elements, use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-744b4] to create the variables:\n\nOn return, `polynomialResult` contains 1024 elements with the indices corresponding to the x-components, and the values corresponding to the interpolated y-components:\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-an-interpolating-polynomial-using-the-vandermonde-method\ncrawled: 2025-12-02T15:55:47Z\n---\n\n# Finding an interpolating polynomial using the Vandermonde method\n\n**Article**\n\nUse LAPACK to solve a linear system and find an interpolating polynomial to construct new points between a series of known data points.\n\n## Overview\n\nThis article demonstrates how you can generate a continuous curve that passes through a small set of points by computing an *interpolating polynomial*. A polynomial is the sum of a series of terms constructed from variables, coefficients, and exponents (for example, *6x³ + 7x²*, where *6* and *7* and the coefficients, and *x* is the variable); and an interpolating polynomial fills in the gaps between the supplied variables and coefficients.\n\nFor any number of data points, there is a unique interpolating polynomial of order (that is, the largest exponent) which is the number of data points minus one. However, for large numbers of data points, this solution can become numerically unstable.\n\nThe image below shows five known points, as white dots, and the values generated by evaluating the found interpolating polynomial, as a red line:\n\n\n\nThe code in this article determines the polynomial coefficients using a Vandermonde matrix based on the x-components of the known points. The coefficients are the solution to *Ax=b*, where *A* is the Vandermonde matrix and *b* is a vector of the y-components of the known points. You’ll use LAPACK to solve *Ax=b*. LAPACK is an acronym for Linear Algebra Package and is a standard software library for numerical linear algebra.\n\n### Generate known data\n\nCreate an array containing five two-element vectors that describe the known data points between which the code interpolates.\n\nIn a real-world app, you will most likely acquire data points from an external source such as a meteorological or financial data source. For this example, specify x-components that are evenly distributed between 0 and 1023, and generate random y-components:\n\n```swift\nimport simd\n\nlet points: [simd_double2] = [\n    simd_double2(0,    Double.random(in: -10...10)),\n    simd_double2(256,  Double.random(in: -10...10)),\n    simd_double2(512,  Double.random(in: -10...10)),\n    simd_double2(768,  Double.random(in: -10...10)),\n    simd_double2(1023, Double.random(in: -10...10)),\n    ]\n```\n\n### Create a Vandermonde matrix\n\nConstruct a Vandermonde matrix where the rows are defined by the elements in a source vector that are successively raised to each integer power up to the source vector’s element count, minus one. For example, in the case of a five-element source vector, *x*, the Vandermonde matrix is of the form:\n\n\n\nThe Vandermonde matrix used in this article derives from the x-components of the points you’re interpolating. For example, given the following points:\n\n\n\nThe resulting Vandermonde matrix contains the following values:\n\n\n\nThe following code constructs a Vandermonde matrix from the `points` array:\n\n```swift\nimport Accelerate\n\nlet exponents = (0 ..< points.count).map {\n    return Double($0)\n}\n\nlet vandermonde: [[Double]] = points.map { point in\n    let bases = [Double](repeating: point.x,\n                         count: points.count)\n    return vForce.pow(bases: bases,\n                      exponents: exponents)\n}\n```\n\n### Calculate coefficients\n\nThe coefficients for the polynomial are the solution to *Ax=b*, where *A* is the Vandermonde matrix and *b* is the y-components of the known points. For example, using the matrix created in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/finding-an-interpolating-polynomial-using-the-vandermonde-method#Create-a-Vandermonde-matrix], the coefficients are the *x* in the following:\n\n\n\nCreate the function `solveLinearSystem(a:a_rowCount:a_columnCount:b:b_count:)` to encapsulate the LAPACK routines that solve *Ax=b*. Note that LAPACK overwrites *b* with the solution vector, *x*:\n\n```swift\nlet coefficients: [Double] = {\n    var a = vandermonde.flatMap { $0 }\n    var b = points.map { $0.y }\n    \n    do {\n        try ViewController.solveLinearSystem(matrixA: &a,\n                                             matrixB: &b,\n                                             count: points.count)\n    } catch {\n        fatalError(\"Unable to solve linear system.\")\n    }\n    \n    vDSP.reverse(&b)\n    \n    return b\n}()\n```\n\nOn return, `coefficients` contains the polynomial coefficients.\n\n### Use LAPACK to solve a linear system\n\n\n\nUse the LAPACK `dgels` routine to perform the solve. The `dgels` name derives from **d**ouble-precision, **ge**neral-matrix, **l**east-**s**quares.\n\n```swift\nstatic func solveLinearSystem(matrixA: inout [Double],\n                              matrixB: inout [Double],\n                              count: Int) throws {\n    \n    \/\/\/ By default, LAPACK expects matrices in column-major format. Specify transpose to support\n    \/\/\/ the row-major Vandermonde matrix.\n    let trans = Int8(\"T\".utf8.first!)\n    \n    \/\/\/ Pass `-1` to the `lwork` parameter of `dgels_` to calculate the optimal size for the\n    \/\/\/ workspace array. The function writes the optimal size to the `workDimension` variable.\n    var workspaceCount = Double(0)\n    let err = dgels(transpose: trans,\n                    rowCount: count,\n                    columnCount: count,\n                    rightHandSideCount: 1, \n                    matrixA: &matrixA, leadingDimensionA: count,\n                    matrixB: &matrixB, leadingDimensionB: count,\n                    workspace: &workspaceCount,\n                    workspaceCount: -1)\n    \n    if err != 0 {\n        throw LAPACKError.internalError\n    }\n    \n    \/\/\/  Create the workspace array based on the workspace query result.\n    var workspace = UnsafeMutablePointer<Double>.allocate(\n        capacity: Int(workspaceCount))\n    defer {\n        workspace.deallocate()\n    }\n    \n    \/\/\/ Perform the solve by passing the workspace array size to the `lwork` parameter of `dgels_`.\n    let info = dgels(transpose: trans,\n                     rowCount: count,\n                     columnCount: count,\n                     rightHandSideCount: 1, \n                     matrixA: &matrixA, leadingDimensionA: count,\n                     matrixB: &matrixB, leadingDimensionB: count,\n                     workspace: workspace,\n                     workspaceCount: Int(workspaceCount))\n    \n    if info < 0 {\n        throw LAPACKError.parameterHasIllegalValue(parameterIndex: abs(Int(info)))\n    } else if info > 0 {\n        throw LAPACKError.diagonalElementOfTriangularFactorIsZero(index: Int(info))\n    }\n}\n\npublic enum LAPACKError: Swift.Error {\n    case internalError\n    case parameterHasIllegalValue(parameterIndex: Int)\n    case diagonalElementOfTriangularFactorIsZero(index: Int)\n}\n```\n\nThis example calls the `dgels` function that’s a wrapper around the underlying LAPACK function `dgels_(_:_:_:_:_:_:_:_:_:_:_:)`. The wrapper provides a more Swift-friendly way of calling the LAPACK function.\n\n```swift\n\/\/\/ A wrapper around `dgels_` that accepts values rather than pointers to values.\nstatic func dgels(transpose trans: CChar,\n                  rowCount m: Int,\n                  columnCount n: Int,\n                  rightHandSideCount nrhs: Int,\n                  matrixA a:  UnsafeMutablePointer<Double>,\n                  leadingDimensionA lda: Int,\n                  matrixB b:  UnsafeMutablePointer<Double>,\n                  leadingDimensionB ldb: Int,\n                  workspace work:  UnsafeMutablePointer<Double>,\n                  workspaceCount lwork: Int) -> Int32 {\n    \n    var info = Int32(0)\n    \n    withUnsafePointer(to: trans) { trans in\n        withUnsafePointer(to: __LAPACK_int(m)) { m in\n            withUnsafePointer(to: __LAPACK_int(n)) { n in\n                withUnsafePointer(to: __LAPACK_int(nrhs)) { nrhs in\n                    withUnsafePointer(to: __LAPACK_int(lda)) { lda in\n                        withUnsafePointer(to: __LAPACK_int(ldb)) { ldb in\n                            withUnsafePointer(to: __LAPACK_int(lwork)) { lwork in\n                                dgels_(trans, m, n,\n                                       nrhs,\n                                       a, lda,\n                                       b, ldb,\n                                       work, lwork,\n                                       &info)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return info\n}\n```\n\n### Evaluate the polynomial\n\nThe vDSP [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/evaluatePolynomial(usingCoefficients:withVariables:)-31vi2] function evaluates a polynomial. For example, the following code evaluates a simple polynomial that consists of three variables and three coefficients:\n\n```swift\nlet coefficients: [Float] = [5, 6, 7] \nlet variables: [Float] = [1, 2, 3]  \n\nvar c = [Float](repeating: .nan,\n                count: variables.count)\n\nlet result = vDSP.evaluatePolynomial(usingCoefficients: coefficients,\n                                     withVariables: variables)\n```\n\nOn return, `result` contains `[18.0, 39.0, 70.0]` by performing the following:\n\n\n\nNote that the number of elements returned by the polynomial evaluation is the same as the number of elements in the `variables` array.\n\nTo create an interpolation result that contains 1024 elements, use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(in:count:)-744b4] to create the variables:\n\n```swift\nlet ramp = vDSP.ramp(withInitialValue: 0,\n                     increment: Double(1),\n                     count: 1024)\n\nlet polynomialResult = vDSP.evaluatePolynomial(usingCoefficients: coefficients,\n                                               withVariables: ramp)\n```\n\nOn return, `polynomialResult` contains 1024 elements with the indices corresponding to the x-components, and the values corresponding to the interpolated y-components:\n\n\n\n## Linear Algebra\n\n- **Solving systems of linear equations with LAPACK**: Select the optimal LAPACK routine to solve a system of linear equations.\n- **Compressing an image using linear algebra**: Reduce the storage size of an image using singular value decomposition (SVD).\n- **BLAS**: Perform common linear algebra operations with Apple’s implementation of the Basic Linear Algebra Subprograms (BLAS).\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Select the optimal LAPACK routine to solve a system of linear equations.",
          "name" : "Solving systems of linear equations with LAPACK",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-of-linear-equations-with-lapack"
        },
        {
          "description" : "Reduce the storage size of an image using singular value decomposition (SVD).",
          "name" : "Compressing an image using linear algebra",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-an-image-using-linear-algebra"
        },
        {
          "description" : "Perform common linear algebra operations with Apple’s implementation of the Basic Linear Algebra Subprograms (BLAS).",
          "name" : "BLAS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/blas-library"
        }
      ],
      "title" : "Linear Algebra"
    }
  ],
  "source" : "appleJSON",
  "title" : "Finding an interpolating polynomial using the Vandermonde method",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-an-interpolating-polynomial-using-the-vandermonde-method"
}