{
  "abstract" : "A layer object that wraps an embedding filter and manages its deinitialization.",
  "codeExamples" : [
    {
      "code" : "let lookupIndices: [Int8] = [1, 5, 2]\nlet input = BNNSNDArrayDescriptor.allocate(initializingFrom: lookupIndices,\n                                           shape: .vector(lookupIndices.count))\n\n\/\/ The dictionary contains 7 embeddings of 5-element vectors\nlet dictionaryData: [Float] = [ 01, 02, 03, 04, 05,     \/\/ Dictionary item 0\n                                11, 12, 13, 14, 15,     \/\/ Dictionary item 1\n                                21, 22, 23, 24, 25,     \/\/ Dictionary item 2\n                                31, 32, 33, 34, 35,     \/\/ Dictionary item 3\n                                41, 42, 43, 44, 45,     \/\/ Dictionary item 4\n                                51, 52, 53, 54, 55,     \/\/ Dictionary item 5\n                                61, 62, 63, 64, 65]     \/\/ Dictionary item 6\n\nlet dictionaryItemSize = 5\nlet dictionaryItemCount = 7\n\nlet dictionary = BNNSNDArrayDescriptor.allocate(\n    initializingFrom: dictionaryData,\n    shape: .matrixLastMajor(dictionaryItemSize,\n                            dictionaryItemCount))\n\nlet output = BNNSNDArrayDescriptor.allocateUninitialized(\n    scalarType: Float.self,\n    shape: .matrixLastMajor(dictionaryItemSize,\n                            lookupIndices.count))\n\nlet layer = BNNS.EmbeddingLayer(input: input,\n                                output: output,\n                                dictionary: dictionary,\n                                paddingIndex: 0,\n                                maximumNorm: 0,\n                                normType: .euclidean,\n                                scalesGradientByFrequency: false)\n\ntry? layer?.apply(batchSize: 1,\n                  input: input,\n                  output: output)\n\n\/\/ Prints:\n\/\/ [11.0, 12.0, 13.0, 14.0, 15.0,\n\/\/ 51.0, 52.0, 53.0, 54.0, 55.0,\n\/\/ 21.0, 22.0, 23.0, 24.0, 25.0]\nprint(output.makeArray(of: Float.self)!)\n\ninput.deallocate()\noutput.deallocate()\ndictionary.deallocate()",
      "language" : "swift"
    },
    {
      "code" : "let lookupIndices: [Int8] = [1, 2]\nlet input = BNNSNDArrayDescriptor.allocate(initializingFrom: lookupIndices,\n                                           shape: .vector(lookupIndices.count))\n\n\n\/\/ The dictionary contains 3 embeddings of 2 x 3 matrices.\nlet dictionaryData: [Float] = [0.1, 0.2, 0.3,\n                               0.4, 0.5, 0.6,\n                               \n                               1, 3, 5,\n                               2, 4, 6,\n                               \n                               60, 50, 40,\n                               30, 20, 10]\n\nlet dictionaryItemRowCount = 2\nlet dictionaryItemColumnCount = 3\nlet dictionaryItemCount = 3\n\nlet dictionary = BNNSNDArrayDescriptor.allocate(\n    initializingFrom: dictionaryData,\n    shape: .tensor3DLastMajor(dictionaryItemRowCount,\n                              dictionaryItemColumnCount,\n                              dictionaryItemCount))\n\nlet output = BNNSNDArrayDescriptor.allocateUninitialized(\n    scalarType: Float.self,\n    shape: .tensor3DLastMajor(dictionaryItemRowCount,\n                              dictionaryItemColumnCount,\n                              lookupIndices.count))\n\nlet layer = BNNS.EmbeddingLayer(input: input,\n                                output: output,\n                                dictionary: dictionary,\n                                paddingIndex: 0,\n                                maximumNorm: 0.6,\n                                normType: .lInfinity,\n                                scalesGradientByFrequency: false)\n\ntry? layer?.apply(batchSize: 1,\n                  input: input,\n                  output: output)\n\n\/\/ Prints:\n\/\/ [0.1, 0.3, 0.5,\n\/\/ 0.2, 0.4, 0.6,\n\/\/\n\/\/ 0.6, 0.5, 0.4,\n\/\/ 0.3, 0.2, 0.1]\nprint(output.makeArray(of: Float.self)!)\n\ninput.deallocate()\noutput.deallocate()\ndictionary.deallocate()",
      "language" : "swift"
    }
  ],
  "contentHash" : "dc8bab40ba55c8059af868da515ddb30a67e2f690765973545de74d8e97d752b",
  "crawledAt" : "2025-12-02T21:54:36Z",
  "declaration" : {
    "code" : "class EmbeddingLayer",
    "language" : "swift"
  },
  "id" : "1E14FE11-0529-4A2C-AAC9-9D60B080444D",
  "kind" : "class",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nUse an embedding layer to access dictionary items based on the integer indices that the input tensor defines.\n\nFor example, the following code shows how to access three dictionary items at indices `1`, `5`, and `2`. The dictionary contains seven items that are five-element vectors. Therefore, the indices descriptor has the shape `(3)`, the dictionary descriptor has the shape `(5, 7)`, and the output descriptor has the shape `(5, 3)`.\n\nThe embedding layer supports clipping to a maximum norm. The following code accesses the second and third items from a dictionary that contains three 2 x 3 matrices. The code initializes the embedding layer with a maximum norm that is the infinity-norm of the first dictionary item.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/accelerate\/bnns\/embeddinglayer\ncrawled: 2025-12-02T21:54:36Z\n---\n\n# BNNS.EmbeddingLayer\n\n**Class**\n\nA layer object that wraps an embedding filter and manages its deinitialization.\n\n## Declaration\n\n```swift\nclass EmbeddingLayer\n```\n\n## Overview\n\nUse an embedding layer to access dictionary items based on the integer indices that the input tensor defines.\n\nFor example, the following code shows how to access three dictionary items at indices `1`, `5`, and `2`. The dictionary contains seven items that are five-element vectors. Therefore, the indices descriptor has the shape `(3)`, the dictionary descriptor has the shape `(5, 7)`, and the output descriptor has the shape `(5, 3)`.\n\n```swift\nlet lookupIndices: [Int8] = [1, 5, 2]\nlet input = BNNSNDArrayDescriptor.allocate(initializingFrom: lookupIndices,\n                                           shape: .vector(lookupIndices.count))\n\n\/\/ The dictionary contains 7 embeddings of 5-element vectors\nlet dictionaryData: [Float] = [ 01, 02, 03, 04, 05,     \/\/ Dictionary item 0\n                                11, 12, 13, 14, 15,     \/\/ Dictionary item 1\n                                21, 22, 23, 24, 25,     \/\/ Dictionary item 2\n                                31, 32, 33, 34, 35,     \/\/ Dictionary item 3\n                                41, 42, 43, 44, 45,     \/\/ Dictionary item 4\n                                51, 52, 53, 54, 55,     \/\/ Dictionary item 5\n                                61, 62, 63, 64, 65]     \/\/ Dictionary item 6\n\nlet dictionaryItemSize = 5\nlet dictionaryItemCount = 7\n\nlet dictionary = BNNSNDArrayDescriptor.allocate(\n    initializingFrom: dictionaryData,\n    shape: .matrixLastMajor(dictionaryItemSize,\n                            dictionaryItemCount))\n\nlet output = BNNSNDArrayDescriptor.allocateUninitialized(\n    scalarType: Float.self,\n    shape: .matrixLastMajor(dictionaryItemSize,\n                            lookupIndices.count))\n\nlet layer = BNNS.EmbeddingLayer(input: input,\n                                output: output,\n                                dictionary: dictionary,\n                                paddingIndex: 0,\n                                maximumNorm: 0,\n                                normType: .euclidean,\n                                scalesGradientByFrequency: false)\n\ntry? layer?.apply(batchSize: 1,\n                  input: input,\n                  output: output)\n\n\/\/ Prints:\n\/\/ [11.0, 12.0, 13.0, 14.0, 15.0,\n\/\/ 51.0, 52.0, 53.0, 54.0, 55.0,\n\/\/ 21.0, 22.0, 23.0, 24.0, 25.0]\nprint(output.makeArray(of: Float.self)!)\n\ninput.deallocate()\noutput.deallocate()\ndictionary.deallocate()\n```\n\nThe embedding layer supports clipping to a maximum norm. The following code accesses the second and third items from a dictionary that contains three 2 x 3 matrices. The code initializes the embedding layer with a maximum norm that is the infinity-norm of the first dictionary item.\n\n```swift\nlet lookupIndices: [Int8] = [1, 2]\nlet input = BNNSNDArrayDescriptor.allocate(initializingFrom: lookupIndices,\n                                           shape: .vector(lookupIndices.count))\n\n\n\/\/ The dictionary contains 3 embeddings of 2 x 3 matrices.\nlet dictionaryData: [Float] = [0.1, 0.2, 0.3,\n                               0.4, 0.5, 0.6,\n                               \n                               1, 3, 5,\n                               2, 4, 6,\n                               \n                               60, 50, 40,\n                               30, 20, 10]\n\nlet dictionaryItemRowCount = 2\nlet dictionaryItemColumnCount = 3\nlet dictionaryItemCount = 3\n\nlet dictionary = BNNSNDArrayDescriptor.allocate(\n    initializingFrom: dictionaryData,\n    shape: .tensor3DLastMajor(dictionaryItemRowCount,\n                              dictionaryItemColumnCount,\n                              dictionaryItemCount))\n\nlet output = BNNSNDArrayDescriptor.allocateUninitialized(\n    scalarType: Float.self,\n    shape: .tensor3DLastMajor(dictionaryItemRowCount,\n                              dictionaryItemColumnCount,\n                              lookupIndices.count))\n\nlet layer = BNNS.EmbeddingLayer(input: input,\n                                output: output,\n                                dictionary: dictionary,\n                                paddingIndex: 0,\n                                maximumNorm: 0.6,\n                                normType: .lInfinity,\n                                scalesGradientByFrequency: false)\n\ntry? layer?.apply(batchSize: 1,\n                  input: input,\n                  output: output)\n\n\/\/ Prints:\n\/\/ [0.1, 0.3, 0.5,\n\/\/ 0.2, 0.4, 0.6,\n\/\/\n\/\/ 0.6, 0.5, 0.4,\n\/\/ 0.3, 0.2, 0.1]\nprint(output.makeArray(of: Float.self)!)\n\ninput.deallocate()\noutput.deallocate()\ndictionary.deallocate()\n```\n\n## Creating an Embedding Layer\n\n- **init(input:output:dictionary:paddingIndex:maximumNorm:normType:scalesGradientByFrequency:filterParameters:)**: Returns a new embedding layer.\n- **BNNS.Norm**: Constants that describe norm types.\n\n## Applying an Embedding Layer\n\n- **apply(batchSize:input:output:)**: Applies the layer to a set of input objects, writing the result to a set of output objects.\n- **applyBackward(batchSize:input:output:outputGradient:generatingWeightsGradient:)**: Applies the layer backward to generate input gradients.\n\n## Embedding layers\n\n- **BNNSLayerParametersEmbedding**: A structure that contains the parameters of an embedding layer.\n- **BNNSFilterCreateLayerEmbedding(_:_:)**: Returns a new embedding layer.\n\n## Inherits From\n\n- BNNS.Layer\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a new embedding layer.",
          "name" : "init(input:output:dictionary:paddingIndex:maximumNorm:normType:scalesGradientByFrequency:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/EmbeddingLayer\/init(input:output:dictionary:paddingIndex:maximumNorm:normType:scalesGradientByFrequency:filterParameters:)"
        },
        {
          "description" : "Constants that describe norm types.",
          "name" : "BNNS.Norm",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/Norm"
        }
      ],
      "title" : "Creating an Embedding Layer"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Applies the layer to a set of input objects, writing the result to a set of output objects.",
          "name" : "apply(batchSize:input:output:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/EmbeddingLayer\/apply(batchSize:input:output:)"
        },
        {
          "description" : "Applies the layer backward to generate input gradients.",
          "name" : "applyBackward(batchSize:input:output:outputGradient:generatingWeightsGradient:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/EmbeddingLayer\/applyBackward(batchSize:input:output:outputGradient:generatingWeightsGradient:)"
        }
      ],
      "title" : "Applying an Embedding Layer"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A structure that contains the parameters of an embedding layer.",
          "name" : "BNNSLayerParametersEmbedding",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSLayerParametersEmbedding"
        },
        {
          "description" : "Returns a new embedding layer.",
          "name" : "BNNSFilterCreateLayerEmbedding(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFilterCreateLayerEmbedding(_:_:)"
        }
      ],
      "title" : "Embedding layers"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "BNNS.Layer"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "BNNS.EmbeddingLayer",
  "url" : "https:\/\/developer.apple.com\/documentation\/accelerate\/bnns\/embeddinglayer"
}