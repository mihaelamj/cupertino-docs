{
  "abstract" : "Converts a sparse tensor from the standardized coordinate list (COO) layout to a device-specific sparse layout that BNNS fully connected layers use.",
  "codeExamples" : [
    {
      "code" : " 1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  2.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  3.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  4.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  5.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  6.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  7.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  8.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  9.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 10.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 11.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 12.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 13.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 14.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 15.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 16.0",
      "language" : "swift"
    },
    {
      "code" : "let weightsData: [Float] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n\nlet columnIndices: [Int32] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nlet rowIndices: [Int32]    = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nlet indices: [Int32] = zip(columnIndices, rowIndices).flatMap { [$0, $1] }\n        \nlet nnz = weightsData.count        \nvar inputWeights = BNNSNDArrayDescriptor.allocate(initializingFrom: weightsData,\n                                                  shape: .vector(nnz))",
      "language" : "swift"
    },
    {
      "code" : "var inputDenseShape = BNNSNDArrayDescriptor(dataType: BNNSDataType.float,\n                                            shape: .matrixRowMajor(16, 16))\nvar inputIndices = BNNSNDArrayDescriptor.allocate(initializingFrom: indices,\n                                                  shape: .matrixRowMajor(nnz, 2))\n\nvar sparsifiedWeights = BNNSNDArrayDescriptor()\n\nvar sparseParams = BNNSSparsityParameters()\nBNNSNDArrayFullyConnectedSparsifySparseCOO(&inputDenseShape,\n                                           &inputIndices,\n                                           &inputWeights,\n                                           &sparsifiedWeights,\n                                           &sparseParams,\n                                           1,\n                                           nil, nil)",
      "language" : "swift"
    }
  ],
  "contentHash" : "74e97f937d82763a5e26bfd237e107059d3197b7141a6871730dac695f667a9f",
  "crawledAt" : "2025-12-02T22:15:42Z",
  "declaration" : {
    "code" : "func BNNSNDArrayFullyConnectedSparsifySparseCOO(_ in_dense_shape: UnsafePointer<BNNSNDArrayDescriptor>, _ in_indices: UnsafePointer<BNNSNDArrayDescriptor>, _ in_values: UnsafePointer<BNNSNDArrayDescriptor>, _ out: UnsafeMutablePointer<BNNSNDArrayDescriptor>, _ sparse_params: UnsafePointer<BNNSSparsityParameters>?, _ batch_size: Int, _ workspace: UnsafeMutableRawPointer?, _ workspace_size: Int, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> Int32",
    "language" : "swift"
  },
  "id" : "6565A01F-BD64-4747-A1D1-8A8A7CA6AB3F",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nThe growing energy and performance costs of deep learning are driving its design towards more efficient models to minimize memory footprint and computational overhead. Sparsity is a widely used approach to deliver a significant reduction in model size, and to corresponding gains in computational, storage, and energy efficiency, without significant loss of accuracy.\n\nPruning is a fundamental technique that’s used to make parameters, such as weights, sparse. Pruning a parameter involves setting some of its values to zero and it’s only the nonzero values that are stored and participate in inference.\n\nFrameworks that sparsify parameters prune values based on their magnitude and location. To gain the greatest improvement in performance, chunk pruned values together, to allow the CPU to skip reading an entire tile.\n\nBNNS doesn’t directly support the standard sparse layouts coordinate list (COO) or compressed sparse row (CSR). Instead, BNNS provides functions that convert COO and CSR data to an optimized, opaque layout that you use with the existing machine learning primitives such as fully connected.\n\nFor example, the following diagonal, single-precision matrix requires 1024 bytes of storage:\n\nYou can represent the same values in COO format as three arrays: the nonzero values, the column indices, and the row indices. Note that BNNS requires interleaved column and row indices.\n\nTo convert the COO weights to the BNNS opaque format for fully connected, create array descriptors for the input weights shape and indices, and call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSNDArrayFullyConnectedSparsifySparseCOO(_:_:_:_:_:_:_:_:_:)].\n\nOn return, `sparsifiedWeights` contains the weights that you pass to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersFullyConnected]. In this example, the data size of `sparsifiedWeights` is 144 bytes.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/accelerate\/bnnsndarrayfullyconnectedsparsifysparsecoo(_:_:_:_:_:_:_:_:_:)\ncrawled: 2025-12-02T22:15:42Z\n---\n\n# BNNSNDArrayFullyConnectedSparsifySparseCOO(_:_:_:_:_:_:_:_:_:)\n\n**Function**\n\nConverts a sparse tensor from the standardized coordinate list (COO) layout to a device-specific sparse layout that BNNS fully connected layers use.\n\n## Declaration\n\n```swift\nfunc BNNSNDArrayFullyConnectedSparsifySparseCOO(_ in_dense_shape: UnsafePointer<BNNSNDArrayDescriptor>, _ in_indices: UnsafePointer<BNNSNDArrayDescriptor>, _ in_values: UnsafePointer<BNNSNDArrayDescriptor>, _ out: UnsafeMutablePointer<BNNSNDArrayDescriptor>, _ sparse_params: UnsafePointer<BNNSSparsityParameters>?, _ batch_size: Int, _ workspace: UnsafeMutableRawPointer?, _ workspace_size: Int, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> Int32\n```\n\n## Parameters\n\n- **in_dense_shape**: An array descriptor that specifies the dense shape (that is, the size and layout) of the input array.\n- **in_indices**: A 2D array descriptor with the shape `[NNZ, rank]` that contains the interleaved indices of the nonzero input values. For row-major ordering, the even elements correspond to the column indices and the odd elements correspond to the row indices. For column-major ordering, the even elements correspond to the row indices and the odd elements correspond to the column indices.\n- **in_values**: A 1D array descriptor with the shape `[NNZ]` that contains the nonzero input values.\n- **out**: On return, an array descriptor that contains device optimized BNNS sparse fully connected weights.\n- **sparse_params**: An optional data structure that contains a hint to the sparsity pattern.\n- **batch_size**: The expected batch size.\n- **workspace**: An optional pointer to scratch memory that’s at least twice the size of the dense input. Set to `nil` to specify that BNNS allocates and frees the scratch memory it requires.\n- **workspace_size**: The size, in bytes, of any scratch memory that you pass. If workspace is `nil`, this function ignores the `workspace_size` parameter.\n- **filter_params**: The runtime filter parameters.\n\n## Discussion\n\nThe growing energy and performance costs of deep learning are driving its design towards more efficient models to minimize memory footprint and computational overhead. Sparsity is a widely used approach to deliver a significant reduction in model size, and to corresponding gains in computational, storage, and energy efficiency, without significant loss of accuracy.\n\nPruning is a fundamental technique that’s used to make parameters, such as weights, sparse. Pruning a parameter involves setting some of its values to zero and it’s only the nonzero values that are stored and participate in inference.\n\nFrameworks that sparsify parameters prune values based on their magnitude and location. To gain the greatest improvement in performance, chunk pruned values together, to allow the CPU to skip reading an entire tile.\n\nBNNS doesn’t directly support the standard sparse layouts coordinate list (COO) or compressed sparse row (CSR). Instead, BNNS provides functions that convert COO and CSR data to an optimized, opaque layout that you use with the existing machine learning primitives such as fully connected.\n\nFor example, the following diagonal, single-precision matrix requires 1024 bytes of storage:\n\n```swift\n 1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  2.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  3.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  4.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  5.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  6.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  7.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  8.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  9.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 10.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 11.0,  0.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 12.0,  0.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 13.0,  0.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 14.0,  0.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 15.0,  0.0\n 0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, 16.0\n```\n\nYou can represent the same values in COO format as three arrays: the nonzero values, the column indices, and the row indices. Note that BNNS requires interleaved column and row indices.\n\n```swift\nlet weightsData: [Float] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n\nlet columnIndices: [Int32] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nlet rowIndices: [Int32]    = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nlet indices: [Int32] = zip(columnIndices, rowIndices).flatMap { [$0, $1] }\n        \nlet nnz = weightsData.count        \nvar inputWeights = BNNSNDArrayDescriptor.allocate(initializingFrom: weightsData,\n                                                  shape: .vector(nnz))\n```\n\nTo convert the COO weights to the BNNS opaque format for fully connected, create array descriptors for the input weights shape and indices, and call [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSNDArrayFullyConnectedSparsifySparseCOO(_:_:_:_:_:_:_:_:_:)].\n\n```swift\nvar inputDenseShape = BNNSNDArrayDescriptor(dataType: BNNSDataType.float,\n                                            shape: .matrixRowMajor(16, 16))\nvar inputIndices = BNNSNDArrayDescriptor.allocate(initializingFrom: indices,\n                                                  shape: .matrixRowMajor(nnz, 2))\n\nvar sparsifiedWeights = BNNSNDArrayDescriptor()\n\nvar sparseParams = BNNSSparsityParameters()\nBNNSNDArrayFullyConnectedSparsifySparseCOO(&inputDenseShape,\n                                           &inputIndices,\n                                           &inputWeights,\n                                           &sparsifiedWeights,\n                                           &sparseParams,\n                                           1,\n                                           nil, nil)\n```\n\nOn return, `sparsifiedWeights` contains the weights that you pass to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersFullyConnected]. In this example, the data size of `sparsifiedWeights` is 144 bytes.\n\n## Sparse layers\n\n- **BNNSNDArrayGetDataSize(_:)**: Returns the size, in bytes, that an array descriptor requires.\n- **BNNSNDArrayFullyConnectedSparsifySparseCSR(_:_:_:_:_:_:_:_:_:_:)**: Converts a sparse tensor from the standardized compressed sparse row (CSR) layout to a device-specific sparse layout that BNNS fully connected layers use.\n- **sparsify(batchSize:inputLayout:inputDenseShape:inputValues:output:sparseParameters:workspace:filterParameters:)**: Converts a sparse tensor from a standardized sparse layout to a device-specific sparse layout that Fully Connected uses.\n- **BNNS.SparseParameters**: A data structure that provides a hint to the sparsity function.\n- **BNNS.SparseLayout**: Constants that specify standardized sparse layouts that BNNS can convert to opaque.\n- **BNNS.SparsityType**: Constants that specify patterns in the sparsity.\n- **BNNSSparsityTypeUnstructured**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns the size, in bytes, that an array descriptor requires.",
          "name" : "BNNSNDArrayGetDataSize(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSNDArrayGetDataSize(_:)"
        },
        {
          "description" : "Converts a sparse tensor from the standardized compressed sparse row (CSR) layout to a device-specific sparse layout that BNNS fully connected layers use.",
          "name" : "BNNSNDArrayFullyConnectedSparsifySparseCSR(_:_:_:_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSNDArrayFullyConnectedSparsifySparseCSR(_:_:_:_:_:_:_:_:_:_:)"
        },
        {
          "description" : "Converts a sparse tensor from a standardized sparse layout to a device-specific sparse layout that Fully Connected uses.",
          "name" : "sparsify(batchSize:inputLayout:inputDenseShape:inputValues:output:sparseParameters:workspace:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/FullyConnectedLayer\/sparsify(batchSize:inputLayout:inputDenseShape:inputValues:output:sparseParameters:workspace:filterParameters:)"
        },
        {
          "description" : "A data structure that provides a hint to the sparsity function.",
          "name" : "BNNS.SparseParameters",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/SparseParameters"
        },
        {
          "description" : "Constants that specify standardized sparse layouts that BNNS can convert to opaque.",
          "name" : "BNNS.SparseLayout",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/SparseLayout"
        },
        {
          "description" : "Constants that specify patterns in the sparsity.",
          "name" : "BNNS.SparsityType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/SparsityType"
        },
        {
          "description" : "",
          "name" : "BNNSSparsityTypeUnstructured",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSSparsityTypeUnstructured"
        }
      ],
      "title" : "Sparse layers"
    }
  ],
  "source" : "appleJSON",
  "title" : "BNNSNDArrayFullyConnectedSparsifySparseCOO(_:_:_:_:_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/accelerate\/bnnsndarrayfullyconnectedsparsifysparsecoo(_:_:_:_:_:_:_:_:_:)"
}