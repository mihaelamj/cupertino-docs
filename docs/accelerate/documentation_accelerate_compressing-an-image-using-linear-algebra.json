{
  "abstract" : "Reduce the storage size of an image using singular value decomposition (SVD).",
  "codeExamples" : [
    {
      "code" : "public struct Matrix {\n    \/\/\/ The number of rows in the matrix.\n    public let rowCount: Int\n    \n    \/\/\/ The number of columns in the matrix.\n    public let columnCount: Int\n    \n    \/\/\/ The total number of elements in the matrix.\n    public var count: Int {\n        return rowCount * columnCount\n    }\n    \n    \/\/\/ A pointer to the matrix's underlying data.\n    public var data: UnsafeMutableBufferPointer<Float> {\n        get {\n            return dataReference.data\n        }\n        set {\n            dataReference.data = newValue\n        }\n    }\n\n    \/\/\/ A pointer to the matrix's underlying data reference.\n    private var dataReference: MatrixDataReference\n    \n    \/\/\/ An object that wraps the structure's data and provides deallocation when the code releases the structure.\n    private class MatrixDataReference {\n        var data: UnsafeMutableBufferPointer<Float>\n        \n        init(data: UnsafeMutableBufferPointer<Float>) {\n            self.data = data\n        }\n        \n        deinit {\n            self.data.deallocate()\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ The 32-bit planar image format that the `Matrix` type uses to\n\/\/\/ consume and produce `CGImage` instances.\nprivate static var imageFormat = vImage_CGImageFormat(\n    bitsPerComponent: 32,\n    bitsPerPixel: 32,\n    colorSpace: CGColorSpaceCreateDeviceGray(),\n    bitmapInfo: CGBitmapInfo(rawValue:\n                             kCGBitmapByteOrder32Host.rawValue |\n                             CGBitmapInfo.floatComponents.rawValue |\n                             CGImageAlphaInfo.none.rawValue))!\n\n\/\/\/ Converts the specified image to 32-bit planar and returns a new matrix\n\/\/\/ that contains that image data.\npublic init?(cgImage: CGImage) {\n    \n    self.init(rowCount: cgImage.height,\n              columnCount: cgImage.width)\n    \n    \/\/ Create a `vImage_Buffer` that shares data with `self`.\n    var tmpBuffer = vImage_Buffer(\n        data: self.data.baseAddress,\n        height: vImagePixelCount(self.rowCount),\n        width: vImagePixelCount(self.columnCount),\n        rowBytes: self.columnCount * MemoryLayout<Float>.stride)\n    \n    let error = vImageBuffer_InitWithCGImage(\n        &tmpBuffer,\n        &Matrix.imageFormat,\n        [0, 0, 0, 0],\n        cgImage,\n        vImage_Flags(kvImageNoAllocate))\n    \n    if error != kvImageNoError {\n        return nil\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "guard\n    let sourceCGImage = image.cgImage(forProposedRect: nil,\n                                      context: nil,\n                                      hints: nil),\n    let sourceImageMatrix = Matrix(cgImage: sourceCGImage)  else {\n    fatalError(\"Error initializing `SVDImageCompressor` instance.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Returns a zero-filled matrix.\npublic init(rowCount: Int,\n            columnCount: Int) {\n    \n    let count = rowCount * columnCount\n    \n    let start = UnsafeMutablePointer<Float>.allocate(capacity: count)\n    \n    let buffer = UnsafeMutableBufferPointer(start: start,\n                                            count: count)\n    buffer.initialize(repeating: 0)\n    \n    self.rowCount = rowCount\n    self.columnCount = columnCount\n    self.dataReference = MatrixDataReference(data: buffer)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ The _U_ in _A = U * Σ * Vᵀ_.\nlet u = Matrix(rowCount: a.rowCount,\n               columnCount: k)\n\n\/\/\/ The diagonal values of _Σ_ in _A = U * Σ * Vᵀ_.\nlet sigma = Matrix(rowCount: min(a.rowCount, a.columnCount),\n                   columnCount: 1)\n\n\/\/\/ The _Vᵀ_ in _A = U * Σ * Vᵀ_.\nlet vt = Matrix(rowCount: k,\n                columnCount: a.columnCount )",
      "language" : "swift"
    },
    {
      "code" : "var JOBU = Int8(\"V\".utf8.first!)\nvar JOBVT = Int8(\"V\".utf8.first!)\nvar RANGE = Int8(\"I\".utf8.first!)",
      "language" : "swift"
    },
    {
      "code" : "var minusOne = __LAPACK_int(-1)\nvar workspaceDimension = Float()\nsgesvdx_(&JOBU,\n         &JOBVT,\n         &RANGE,\n         &m,\n         &n,\n         aCopy.baseAddress,\n         &lda,\n         &vl,\n         &vu,\n         &il,\n         &iu,\n         &ns,\n         sigma.data.baseAddress,\n         u.data.baseAddress,\n         &ldu,\n         vt.data.baseAddress,\n         &ldvt,\n         &workspaceDimension,\n         &minusOne,\n         iwork,\n         &info)",
      "language" : "swift"
    },
    {
      "code" : "var lwork = __LAPACK_int(workspaceDimension)\n \nlet workspace = UnsafeMutablePointer<Float>.allocate(capacity: Int(lwork))\ndefer {\n    workspace.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "var m = __LAPACK_int(a.m)\nvar n = __LAPACK_int(a.n)\nvar lda = __LAPACK_int(a.m)\n\nvar ldu = __LAPACK_int(u.m)\nvar ldvt = __LAPACK_int(vt.m)",
      "language" : "swift"
    },
    {
      "code" : "let iwork = UnsafeMutablePointer<__LAPACK_int>.allocate(capacity: 12 * Int(min(m, n)))\ndefer {\n    iwork.deallocate()\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Compute `iu - il + 1` singular values.\nsgesvdx_(&JOBU,\n         &JOBVT,\n         &RANGE,\n         &m,\n         &n,\n         aCopy.baseAddress,\n         &lda,\n         &vl,\n         &vu,\n         &il,\n         &iu,\n         &ns,\n         sigma.data.baseAddress,\n         u.data.baseAddress,\n         &ldu,\n         vt.data.baseAddress,\n         &ldvt,\n         workspace,\n         &lwork,\n         iwork,\n         &info)",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Returns a column-major matrix with the specified diagonal elements.\npublic init<C>(diagonal: C,\n               rowCount: Int,\n               columnCount: Int)\nwhere\nC: Collection,\nC.Index == Int,\nC.Element == Float {\n    \n    self.init(rowCount: rowCount,\n              columnCount: columnCount)\n    \n    for i in 0 ..< min(rowCount, columnCount, diagonal.count) {\n        self[i * rowCount + i] = diagonal[i]\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let sigma = Matrix(diagonal: svdResult.sigma.data,\n                   rowCount: Int(k),\n                   columnCount: Int(k))\n",
      "language" : "swift"
    },
    {
      "code" : "public static func multiply(a: Matrix,\n                            b: Matrix,\n                            c: Matrix,\n                            k: Int32? = nil) {\n\n    cblas_sgemm(CblasColMajor,\n                CblasNoTrans, CblasNoTrans,\n                a.m,\n                b.n,\n                k ?? b.m,\n                1,\n                a.data.baseAddress, a.m,\n                b.data.baseAddress, b.m,\n                0,\n                c.data.baseAddress, c.m)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ The matrix that receives `u * sigma`.\nlet u_sigma = Matrix(rowCount: svdResult.u.rowCount,\n                     columnCount: sigma.columnCount)\n\nMatrix.multiply(a: svdResult.u,\n                b: sigma,\n                c: u_sigma)\n\n\/\/\/ The matrix that receives `u * sigma * vᵀ`.\nlet u_sigma_vt = Matrix(rowCount: u_sigma.rowCount,\n                        columnCount: svdResult.vt.columnCount)\n\nMatrix.multiply(a: u_sigma,\n                b: svdResult.vt,\n                c: u_sigma_vt)",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Returns a 32-bit per pixel, grayscale `CGImage`instance of the matrix's data.\npublic var cgImage: CGImage? {\n    \n    let tmpBuffer = vImage_Buffer(\n        data: self.data.baseAddress!,\n        height: vImagePixelCount(self.rowCount),\n        width: vImagePixelCount(self.columnCount),\n        rowBytes: self.columnCount * MemoryLayout<Float>.stride)\n    \n    return try? tmpBuffer.createCGImage(format: Matrix.imageFormat)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "f7c2f45f49206ee7da00c41b848236d17267a7a5e7f105888d7cb131495efd2d",
  "crawledAt" : "2025-12-02T15:46:00Z",
  "id" : "295414F6-B01E-4B93-9C0F-C56FA0E4AC91",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThis sample code project decomposes an image into three factors using [https:\/\/mathworld.wolfram.com\/SingularValueDecomposition.html] (SVD). The sample compresses an image by computing the products of the factors submatrices. The image below shows two photographs. The first is the original image, and the second is the same image after the sample applies 10:1 compression:\n\n\n\nAny *m* x *n* matrix, *A*, has an SVD factorization that decomposes it into three factors:\n\nThe sample uses the Linear Algebra Package (LAPACK) function `sgesvdx_` to compute the SVD.\n\nThe figure below shows the SVD of a 5 x 3 matrix:\n\n\n\nWhen matrix *A* contains image information, the magnitude of the singular values correlate to the visual significance of features in the image.\n\nThe sample reduces the storage size of the original image by returning the product of submatrices of *U*, *Σ*, and *Vᵀ*. The sizes of the submatrices derive from the index of the first low singular value. The code in this sample defines that value as `k`.\n\nFor example, if the diagonal elements of *Σ*  are `[2000, 1000, 24]` and you define `k` as `2`, the app keeps `[2000, 1000]` and discards `24`. The following figure shows the matrix multiply function for this example, where the first two singular values contain significant values:\n\n\n\n### Create a matrix from the source image\n\nThe sample defines a `Matrix` structure that simplifies passing image data to Accelerate’s linear algebra libraries.\n\nThe `Matrix` type provides an initializer that returns a new matrix that contains a 32-bit grayscale copy of the pixel values of a vImage buffer. The `init(cgImage:)` function passes `kvImageNoAllocate` to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageBuffer_InitWithCGImage(_:_:_:_:_:)] and uses the matrix’s memory allocation. This ensures that there are no extra bytes at the end of each row. See “Create floating point pixels to use with vDSP” in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/finding-the-sharpest-image-in-a-sequence-of-captured-images] for more information on row byte padding.\n\nThe following code creates a matrix instance from a Core Graphics image:\n\n### Create the factor matrices\n\nThe `Matrix` type provides an initializer that returns a new zero-filled matrix.\n\nThe following code creates the three matrices that represent the factors:\n\n### Define the SVD options\n\nThe sample requires fully populated *U* and *Vᵀ* matrices, and defines the `JOBU` and `JOBVT` parameters that it passes to `sgesvdx_` as `V`. In order to specify that `sgesvdx_` returns a specified number of singular values, the sample defines the `RANGE` parameter as `I`.\n\n### Create the workspaces\n\nBefore computing the SVD, the sample performs a workspace query to calculate the optimal size of the workspace that `sgesvdx_` requires. The following code specifies `LWORK` as `-1` and passes a pointer to a single `Float` to the `WORK` parameter.\n\nOn return, `workspaceDimension` contains the optimal size for the workspace.\n\nThe following code allocates the memory that the SVD routine uses as the workspace:\n\n### Use LAPACK to compute the SVD\n\nTo avoid multiple nested calls to [doc:\/\/com.apple.documentation\/documentation\/Swift\/withUnsafePointer(to:_:)-35wrn], the sample declares variables that shadow some of the matrix properties to pass to the SVD routine as [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafePointer] structures.\n\nThe samples creates the `iwork` integer array with a count of 12 times the minimum dimension of matrix *A*.\n\nThe sample calls the LAPACK function for a second time to compute the SVD.\n\nOn return, the matrices `sigma`, `u`, and `vt` contain the SVD result.\n\n### Convert the singular values vector to a matrix\n\nThe `sgesvdx_` function computes the singular values as a vector. To convert the vector of `k` diagonal values to a `k * k` diagonal matrix, the `Matrix` type provides an initializer that returns a new matrix from diagonal values.\n\nThe following code creates a `k * k` diagonal matrix from the SVD sigma values:\n\n### Multiply the factors\n\nThe `Matrix` type provides a static function that wraps [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)] to multiply two matrices.\n\nThe sample uses the matrix multiply function to recreate matrix *A* from the SVD factors.\n\n### Create a Core Graphics image from the product of the factors\n\nThe `cgImage` computed property returns a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instance from a matrix’s data. The computed property creates a temporary vImage buffer that shares its data with the matrix and uses the same planar 32-bit [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGImageFormat] that the `init(cgImage:)` initializer uses to convert a Core Graphics image to a matrix.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-an-image-using-linear-algebra\ncrawled: 2025-12-02T15:46:00Z\n---\n\n# Compressing an image using linear algebra\n\n**Sample Code**\n\nReduce the storage size of an image using singular value decomposition (SVD).\n\n## Overview\n\nThis sample code project decomposes an image into three factors using [https:\/\/mathworld.wolfram.com\/SingularValueDecomposition.html] (SVD). The sample compresses an image by computing the products of the factors submatrices. The image below shows two photographs. The first is the original image, and the second is the same image after the sample applies 10:1 compression:\n\n\n\nAny *m* x *n* matrix, *A*, has an SVD factorization that decomposes it into three factors:\n\n- The *m* x *m*  matrix *U* that contains the left singular vectors of matrix *A*\n- The *m* x *n*  diagonal matrix *Σ* that contains the [https:\/\/mathworld.wolfram.com\/SingularValue.html] of matrix *A*, arranged in descending order\n- The *n* x *n*  transposed matrix *V* that contains the right singular vectors of matrix *A*\n\nThe sample uses the Linear Algebra Package (LAPACK) function `sgesvdx_` to compute the SVD.\n\nThe figure below shows the SVD of a 5 x 3 matrix:\n\n\n\nWhen matrix *A* contains image information, the magnitude of the singular values correlate to the visual significance of features in the image.\n\nThe sample reduces the storage size of the original image by returning the product of submatrices of *U*, *Σ*, and *Vᵀ*. The sizes of the submatrices derive from the index of the first low singular value. The code in this sample defines that value as `k`.\n\nFor example, if the diagonal elements of *Σ*  are `[2000, 1000, 24]` and you define `k` as `2`, the app keeps `[2000, 1000]` and discards `24`. The following figure shows the matrix multiply function for this example, where the first two singular values contain significant values:\n\n\n\n### Create a matrix from the source image\n\nThe sample defines a `Matrix` structure that simplifies passing image data to Accelerate’s linear algebra libraries.\n\n```swift\npublic struct Matrix {\n    \/\/\/ The number of rows in the matrix.\n    public let rowCount: Int\n    \n    \/\/\/ The number of columns in the matrix.\n    public let columnCount: Int\n    \n    \/\/\/ The total number of elements in the matrix.\n    public var count: Int {\n        return rowCount * columnCount\n    }\n    \n    \/\/\/ A pointer to the matrix's underlying data.\n    public var data: UnsafeMutableBufferPointer<Float> {\n        get {\n            return dataReference.data\n        }\n        set {\n            dataReference.data = newValue\n        }\n    }\n\n    \/\/\/ A pointer to the matrix's underlying data reference.\n    private var dataReference: MatrixDataReference\n    \n    \/\/\/ An object that wraps the structure's data and provides deallocation when the code releases the structure.\n    private class MatrixDataReference {\n        var data: UnsafeMutableBufferPointer<Float>\n        \n        init(data: UnsafeMutableBufferPointer<Float>) {\n            self.data = data\n        }\n        \n        deinit {\n            self.data.deallocate()\n        }\n    }\n}\n```\n\nThe `Matrix` type provides an initializer that returns a new matrix that contains a 32-bit grayscale copy of the pixel values of a vImage buffer. The `init(cgImage:)` function passes `kvImageNoAllocate` to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageBuffer_InitWithCGImage(_:_:_:_:_:)] and uses the matrix’s memory allocation. This ensures that there are no extra bytes at the end of each row. See “Create floating point pixels to use with vDSP” in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/finding-the-sharpest-image-in-a-sequence-of-captured-images] for more information on row byte padding.\n\n```swift\n\/\/\/ The 32-bit planar image format that the `Matrix` type uses to\n\/\/\/ consume and produce `CGImage` instances.\nprivate static var imageFormat = vImage_CGImageFormat(\n    bitsPerComponent: 32,\n    bitsPerPixel: 32,\n    colorSpace: CGColorSpaceCreateDeviceGray(),\n    bitmapInfo: CGBitmapInfo(rawValue:\n                             kCGBitmapByteOrder32Host.rawValue |\n                             CGBitmapInfo.floatComponents.rawValue |\n                             CGImageAlphaInfo.none.rawValue))!\n\n\/\/\/ Converts the specified image to 32-bit planar and returns a new matrix\n\/\/\/ that contains that image data.\npublic init?(cgImage: CGImage) {\n    \n    self.init(rowCount: cgImage.height,\n              columnCount: cgImage.width)\n    \n    \/\/ Create a `vImage_Buffer` that shares data with `self`.\n    var tmpBuffer = vImage_Buffer(\n        data: self.data.baseAddress,\n        height: vImagePixelCount(self.rowCount),\n        width: vImagePixelCount(self.columnCount),\n        rowBytes: self.columnCount * MemoryLayout<Float>.stride)\n    \n    let error = vImageBuffer_InitWithCGImage(\n        &tmpBuffer,\n        &Matrix.imageFormat,\n        [0, 0, 0, 0],\n        cgImage,\n        vImage_Flags(kvImageNoAllocate))\n    \n    if error != kvImageNoError {\n        return nil\n    }\n}\n```\n\nThe following code creates a matrix instance from a Core Graphics image:\n\n```swift\nguard\n    let sourceCGImage = image.cgImage(forProposedRect: nil,\n                                      context: nil,\n                                      hints: nil),\n    let sourceImageMatrix = Matrix(cgImage: sourceCGImage)  else {\n    fatalError(\"Error initializing `SVDImageCompressor` instance.\")\n}\n```\n\n### Create the factor matrices\n\nThe `Matrix` type provides an initializer that returns a new zero-filled matrix.\n\n```swift\n\/\/\/ Returns a zero-filled matrix.\npublic init(rowCount: Int,\n            columnCount: Int) {\n    \n    let count = rowCount * columnCount\n    \n    let start = UnsafeMutablePointer<Float>.allocate(capacity: count)\n    \n    let buffer = UnsafeMutableBufferPointer(start: start,\n                                            count: count)\n    buffer.initialize(repeating: 0)\n    \n    self.rowCount = rowCount\n    self.columnCount = columnCount\n    self.dataReference = MatrixDataReference(data: buffer)\n}\n```\n\nThe following code creates the three matrices that represent the factors:\n\n```swift\n\/\/\/ The _U_ in _A = U * Σ * Vᵀ_.\nlet u = Matrix(rowCount: a.rowCount,\n               columnCount: k)\n\n\/\/\/ The diagonal values of _Σ_ in _A = U * Σ * Vᵀ_.\nlet sigma = Matrix(rowCount: min(a.rowCount, a.columnCount),\n                   columnCount: 1)\n\n\/\/\/ The _Vᵀ_ in _A = U * Σ * Vᵀ_.\nlet vt = Matrix(rowCount: k,\n                columnCount: a.columnCount )\n```\n\n### Define the SVD options\n\nThe sample requires fully populated *U* and *Vᵀ* matrices, and defines the `JOBU` and `JOBVT` parameters that it passes to `sgesvdx_` as `V`. In order to specify that `sgesvdx_` returns a specified number of singular values, the sample defines the `RANGE` parameter as `I`.\n\n```swift\nvar JOBU = Int8(\"V\".utf8.first!)\nvar JOBVT = Int8(\"V\".utf8.first!)\nvar RANGE = Int8(\"I\".utf8.first!)\n```\n\n### Create the workspaces\n\nBefore computing the SVD, the sample performs a workspace query to calculate the optimal size of the workspace that `sgesvdx_` requires. The following code specifies `LWORK` as `-1` and passes a pointer to a single `Float` to the `WORK` parameter.\n\n```swift\nvar minusOne = __LAPACK_int(-1)\nvar workspaceDimension = Float()\nsgesvdx_(&JOBU,\n         &JOBVT,\n         &RANGE,\n         &m,\n         &n,\n         aCopy.baseAddress,\n         &lda,\n         &vl,\n         &vu,\n         &il,\n         &iu,\n         &ns,\n         sigma.data.baseAddress,\n         u.data.baseAddress,\n         &ldu,\n         vt.data.baseAddress,\n         &ldvt,\n         &workspaceDimension,\n         &minusOne,\n         iwork,\n         &info)\n```\n\nOn return, `workspaceDimension` contains the optimal size for the workspace.\n\nThe following code allocates the memory that the SVD routine uses as the workspace:\n\n```swift\nvar lwork = __LAPACK_int(workspaceDimension)\n \nlet workspace = UnsafeMutablePointer<Float>.allocate(capacity: Int(lwork))\ndefer {\n    workspace.deallocate()\n}\n```\n\n### Use LAPACK to compute the SVD\n\nTo avoid multiple nested calls to [doc:\/\/com.apple.documentation\/documentation\/Swift\/withUnsafePointer(to:_:)-35wrn], the sample declares variables that shadow some of the matrix properties to pass to the SVD routine as [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafePointer] structures.\n\n```swift\nvar m = __LAPACK_int(a.m)\nvar n = __LAPACK_int(a.n)\nvar lda = __LAPACK_int(a.m)\n\nvar ldu = __LAPACK_int(u.m)\nvar ldvt = __LAPACK_int(vt.m)\n```\n\nThe samples creates the `iwork` integer array with a count of 12 times the minimum dimension of matrix *A*.\n\n```swift\nlet iwork = UnsafeMutablePointer<__LAPACK_int>.allocate(capacity: 12 * Int(min(m, n)))\ndefer {\n    iwork.deallocate()\n}\n```\n\nThe sample calls the LAPACK function for a second time to compute the SVD.\n\n```swift\n\/\/ Compute `iu - il + 1` singular values.\nsgesvdx_(&JOBU,\n         &JOBVT,\n         &RANGE,\n         &m,\n         &n,\n         aCopy.baseAddress,\n         &lda,\n         &vl,\n         &vu,\n         &il,\n         &iu,\n         &ns,\n         sigma.data.baseAddress,\n         u.data.baseAddress,\n         &ldu,\n         vt.data.baseAddress,\n         &ldvt,\n         workspace,\n         &lwork,\n         iwork,\n         &info)\n```\n\nOn return, the matrices `sigma`, `u`, and `vt` contain the SVD result.\n\n### Convert the singular values vector to a matrix\n\nThe `sgesvdx_` function computes the singular values as a vector. To convert the vector of `k` diagonal values to a `k * k` diagonal matrix, the `Matrix` type provides an initializer that returns a new matrix from diagonal values.\n\n```swift\n\/\/\/ Returns a column-major matrix with the specified diagonal elements.\npublic init<C>(diagonal: C,\n               rowCount: Int,\n               columnCount: Int)\nwhere\nC: Collection,\nC.Index == Int,\nC.Element == Float {\n    \n    self.init(rowCount: rowCount,\n              columnCount: columnCount)\n    \n    for i in 0 ..< min(rowCount, columnCount, diagonal.count) {\n        self[i * rowCount + i] = diagonal[i]\n    }\n}\n```\n\nThe following code creates a `k * k` diagonal matrix from the SVD sigma values:\n\n```swift\nlet sigma = Matrix(diagonal: svdResult.sigma.data,\n                   rowCount: Int(k),\n                   columnCount: Int(k))\n\n```\n\n### Multiply the factors\n\nThe `Matrix` type provides a static function that wraps [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)] to multiply two matrices.\n\n```swift\npublic static func multiply(a: Matrix,\n                            b: Matrix,\n                            c: Matrix,\n                            k: Int32? = nil) {\n\n    cblas_sgemm(CblasColMajor,\n                CblasNoTrans, CblasNoTrans,\n                a.m,\n                b.n,\n                k ?? b.m,\n                1,\n                a.data.baseAddress, a.m,\n                b.data.baseAddress, b.m,\n                0,\n                c.data.baseAddress, c.m)\n}\n```\n\nThe sample uses the matrix multiply function to recreate matrix *A* from the SVD factors.\n\n```swift\n\/\/\/ The matrix that receives `u * sigma`.\nlet u_sigma = Matrix(rowCount: svdResult.u.rowCount,\n                     columnCount: sigma.columnCount)\n\nMatrix.multiply(a: svdResult.u,\n                b: sigma,\n                c: u_sigma)\n\n\/\/\/ The matrix that receives `u * sigma * vᵀ`.\nlet u_sigma_vt = Matrix(rowCount: u_sigma.rowCount,\n                        columnCount: svdResult.vt.columnCount)\n\nMatrix.multiply(a: u_sigma,\n                b: svdResult.vt,\n                c: u_sigma_vt)\n```\n\n### Create a Core Graphics image from the product of the factors\n\nThe `cgImage` computed property returns a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instance from a matrix’s data. The computed property creates a temporary vImage buffer that shares its data with the matrix and uses the same planar 32-bit [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGImageFormat] that the `init(cgImage:)` initializer uses to convert a Core Graphics image to a matrix.\n\n```swift\n\/\/\/ Returns a 32-bit per pixel, grayscale `CGImage`instance of the matrix's data.\npublic var cgImage: CGImage? {\n    \n    let tmpBuffer = vImage_Buffer(\n        data: self.data.baseAddress!,\n        height: vImagePixelCount(self.rowCount),\n        width: vImagePixelCount(self.columnCount),\n        rowBytes: self.columnCount * MemoryLayout<Float>.stride)\n    \n    return try? tmpBuffer.createCGImage(format: Matrix.imageFormat)\n}\n```\n\n## Linear Algebra\n\n- **Solving systems of linear equations with LAPACK**: Select the optimal LAPACK routine to solve a system of linear equations.\n- **Finding an interpolating polynomial using the Vandermonde method**: Use LAPACK to solve a linear system and find an interpolating polynomial to construct new points between a series of known data points.\n- **BLAS**: Perform common linear algebra operations with Apple’s implementation of the Basic Linear Algebra Subprograms (BLAS).\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Select the optimal LAPACK routine to solve a system of linear equations.",
          "name" : "Solving systems of linear equations with LAPACK",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-of-linear-equations-with-lapack"
        },
        {
          "description" : "Use LAPACK to solve a linear system and find an interpolating polynomial to construct new points between a series of known data points.",
          "name" : "Finding an interpolating polynomial using the Vandermonde method",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-an-interpolating-polynomial-using-the-vandermonde-method"
        },
        {
          "description" : "Perform common linear algebra operations with Apple’s implementation of the Basic Linear Algebra Subprograms (BLAS).",
          "name" : "BLAS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/blas-library"
        }
      ],
      "title" : "Linear Algebra"
    }
  ],
  "source" : "appleJSON",
  "title" : "Compressing an image using linear algebra",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-an-image-using-linear-algebra"
}