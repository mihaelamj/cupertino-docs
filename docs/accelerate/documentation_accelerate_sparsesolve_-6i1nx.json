{
  "abstract" : "Solves the equation *Ax = b* for vectors of double-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Double] =      [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\nlet preconditioner = SparseCreatePreconditioner(SparsePreconditionerDiagScaling,\n                                                A)\n\ndefer {\n    SparseCleanup(A)\n    SparseCleanup(preconditioner)\n}\n\n\/\/\/ Create the right-hand-side vector, _b_.\nvar bValues: [Double] = [30, 35, 100]\nvar xValues = [Double](repeating: .nan, count: bValues.count)\n\n\/\/\/ Create the apply operator block.\nfunc applyOperator(accumulate: Bool,\n                   trans: CBLAS_TRANSPOSE,\n                   x: DenseVector_Double,\n                   y: DenseVector_Double) {\n    switch(accumulate, trans == CblasTrans) {\n        case (false, false):\n            SparseMultiply(A, x, y)\n        case (false, true):\n            SparseMultiply(SparseGetTranspose(A), x, y)\n        case (true, false):\n            SparseMultiplyAdd(A, x, y)\n        case (true, true):\n            SparseMultiplyAdd(SparseGetTranspose(A), x, y)\n    }\n}\n\nbValues.withUnsafeMutableBufferPointer { bPtr in\n    xValues.withUnsafeMutableBufferPointer { xPtr in\n        \n        let b = DenseVector_Double(count: 3,\n                                   data: bPtr.baseAddress!)\n        \n        let x = DenseVector_Double(count: 3,\n                                   data: xPtr.baseAddress!)\n        \n        SparseSolve(SparseLSMR(),\n                    applyOperator,\n                    b, x,\n                    preconditioner)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "fa04cf6aab96420cd22e2b3cb9bd7cecf3fb49b0580dba97e2ae534717fca898",
  "crawledAt" : "2025-12-01T03:59:27Z",
  "declaration" : {
    "code" : "func SparseSolve(_ method: SparseIterativeMethod, _ ApplyOperator: @escaping (Bool, CBLAS_TRANSPOSE, DenseVector_Double, DenseVector_Double) -> Void, _ b: DenseVector_Double, _ x: DenseVector_Double, _ Preconditioner: SparseOpaquePreconditioner_Double) -> SparseIterativeStatus_t",
    "language" : "swift"
  },
  "id" : "3B8B60E2-4532-43D1-9CC1-7AAA58E9F25B",
  "kind" : "function",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. Preconditioning the coefficient matrix can reduce the number of iterations the function requires to converge the system. In cases where the matrix *A* isn’t explicitly available or you need control over the multiplication, this function allows you to provide an apply block.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system by applying a diagonal scaling preconditioner and using the least squares minimum residual method:\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-6i1nx\ncrawled: 2025-12-01T03:59:27Z\n---\n\n# SparseSolve(_:_:_:_:_:)\n\n**Function**\n\nSolves the equation *Ax = b* for vectors of double-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.\n\n## Declaration\n\n```swift\nfunc SparseSolve(_ method: SparseIterativeMethod, _ ApplyOperator: @escaping (Bool, CBLAS_TRANSPOSE, DenseVector_Double, DenseVector_Double) -> Void, _ b: DenseVector_Double, _ x: DenseVector_Double, _ Preconditioner: SparseOpaquePreconditioner_Double) -> SparseIterativeStatus_t\n```\n\n## Parameters\n\n- **method**: The iterative method.\n- **ApplyOperator**: The apply operator block to run. The block takes the following parameters:\n\n\n- **b**: The vector `b`.\n- **x**: The matrix `x`.\n- **Preconditioner**: The preconditioner to apply.\n\n## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. Preconditioning the coefficient matrix can reduce the number of iterations the function requires to converge the system. In cases where the matrix *A* isn’t explicitly available or you need control over the multiplication, this function allows you to provide an apply block.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system by applying a diagonal scaling preconditioner and using the least squares minimum residual method:\n\n```swift\n\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Double] =      [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\nlet preconditioner = SparseCreatePreconditioner(SparsePreconditionerDiagScaling,\n                                                A)\n\ndefer {\n    SparseCleanup(A)\n    SparseCleanup(preconditioner)\n}\n\n\/\/\/ Create the right-hand-side vector, _b_.\nvar bValues: [Double] = [30, 35, 100]\nvar xValues = [Double](repeating: .nan, count: bValues.count)\n\n\/\/\/ Create the apply operator block.\nfunc applyOperator(accumulate: Bool,\n                   trans: CBLAS_TRANSPOSE,\n                   x: DenseVector_Double,\n                   y: DenseVector_Double) {\n    switch(accumulate, trans == CblasTrans) {\n        case (false, false):\n            SparseMultiply(A, x, y)\n        case (false, true):\n            SparseMultiply(SparseGetTranspose(A), x, y)\n        case (true, false):\n            SparseMultiplyAdd(A, x, y)\n        case (true, true):\n            SparseMultiplyAdd(SparseGetTranspose(A), x, y)\n    }\n}\n\nbValues.withUnsafeMutableBufferPointer { bPtr in\n    xValues.withUnsafeMutableBufferPointer { xPtr in\n        \n        let b = DenseVector_Double(count: 3,\n                                   data: bPtr.baseAddress!)\n        \n        let x = DenseVector_Double(count: 3,\n                                   data: xPtr.baseAddress!)\n        \n        SparseSolve(SparseLSMR(),\n                    applyOperator,\n                    b, x,\n                    preconditioner)\n    }\n}\n```\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0]`.\n\n## Iterative sparse solve functions with preconditioner\n\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and opaque preconditioner.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and opaque preconditioner.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and preconditioner type.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and preconditioner type.\n- **SparseSolve(_:_:_:_:_:)**: Solves the equation *Ax = b* for vectors of single-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and opaque preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-1qwax"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and opaque preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-3aphv"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of double-precision values using the specified iterative method and preconditioner type.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-5vs11"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of single-precision values using the specified iterative method and preconditioner type.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-9nzvm"
        },
        {
          "description" : "Solves the equation *Ax = b* for vectors of single-precision values, treating *A* as an operator and using the specified iterative method and preconditioner.",
          "name" : "SparseSolve(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-7wnum"
        }
      ],
      "title" : "Iterative sparse solve functions with preconditioner"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseSolve(_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:_:)-6i1nx"
}