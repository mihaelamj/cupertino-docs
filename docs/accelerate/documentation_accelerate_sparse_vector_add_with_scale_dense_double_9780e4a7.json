{
  "abstract" : "Scales the sparse vector *x* by *alpha* and adds the result to the dense vector *y,* with both vectors containing double-precision values.",
  "codeExamples" : [

  ],
  "contentHash" : "67c18a920ac754fb81f25d69b80a5bc425be9008311e6f40098ec790412094bc",
  "crawledAt" : "2025-12-02T23:22:15Z",
  "declaration" : {
    "code" : "func sparse_vector_add_with_scale_dense_double(_ nz: sparse_dimension, _ alpha: Double, _ x: UnsafePointer<Double>!, _ indx: UnsafePointer<sparse_index>!, _ y: UnsafeMutablePointer<Double>!, _ incy: sparse_stride)",
    "language" : "swift"
  },
  "id" : "DCF6B964-8460-4938-8F53-71522EE192A5",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nPerforms the operation *y = alpha * x + y* in place. If `alpha` or `nz` is zero, *y* is unchanged.\n\nScales the sparse vector x by alpha and adds the result to the dense vector y.\n\nIf the desired operation is *y = alpha * x*, then an efficient option is to create the *y* buffer of zeros and then perform the operation with the zero filled *y*.\n\nIndices in `indx` are always assumed to be stored in ascending order. Additionally, indices are assumed to be unique.  The behavior of this function is undefined if either of these assumptions are not met.\n\nAll indices are 0 based (the first element of a pointer is `ptr[0]`).",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_vector_add_with_scale_dense_double(_:_:_:_:_:_:)\ncrawled: 2025-12-02T23:22:15Z\n---\n\n# sparse_vector_add_with_scale_dense_double(_:_:_:_:_:_:)\n\n**Function**\n\nScales the sparse vector *x* by *alpha* and adds the result to the dense vector *y,* with both vectors containing double-precision values.\n\n## Declaration\n\n```swift\nfunc sparse_vector_add_with_scale_dense_double(_ nz: sparse_dimension, _ alpha: Double, _ x: UnsafePointer<Double>!, _ indx: UnsafePointer<sparse_index>!, _ y: UnsafeMutablePointer<Double>!, _ incy: sparse_stride)\n```\n\n## Parameters\n\n- **nz**: The number of nonzero entries in the sparse vector *x*.\n- **alpha**: Scalar multiplier of *x*.\n- **x**: Pointer to the dense storage for the values of the sparse vector *x*. The corresponding entry in `indx` holds the index of the value. Contains `nz` values.\n- **indx**: Pointer to the dense storage for the index values of the sparse vector *x*. The corresponding entry in *x* holds the values of the vector. Contains `nz` values.\n- **y**: Pointer to the dense vector *y*. Accessed as `y[indx[0..nz-1]*incy]`, so dimension must be compatible with largest index value in `indx`. The behavior of this function is undefined if this is not met. Negative strides are supported. Note, unlike dense BLAS routines, the pointer points to the last element when stride is negative.\n- **incy**: Increment between valid values in the dense vector *y*. Negative strides are supported.\n\n## Discussion\n\nPerforms the operation *y = alpha * x + y* in place. If `alpha` or `nz` is zero, *y* is unchanged.\n\nScales the sparse vector x by alpha and adds the result to the dense vector y.\n\nIf the desired operation is *y = alpha * x*, then an efficient option is to create the *y* buffer of zeros and then perform the operation with the zero filled *y*.\n\nIndices in `indx` are always assumed to be stored in ascending order. Additionally, indices are assumed to be unique.  The behavior of this function is undefined if either of these assumptions are not met.\n\nAll indices are 0 based (the first element of a pointer is `ptr[0]`).\n\n\n\n## Vector-Vector Operations\n\n- **sparse_inner_product_dense_double(_:_:_:_:_:)**: Computes the inner product of sparse vector *x* with double-precision *y*, with both vectors containing double-precision values.\n- **sparse_inner_product_dense_float(_:_:_:_:_:)**: Computes the inner product of sparse vector *x* with dense vector *y,* with both vectors containing single-precision values.\n- **sparse_inner_product_sparse_double(_:_:_:_:_:_:)**: Computes the inner product of sparse vector *x* with sparse vector *y,* with both vectors containing double-precision values.\n- **sparse_inner_product_sparse_float(_:_:_:_:_:_:)**: Computes the inner product of sparse vector *x* with sparse vector *y,* with both vectors containing single-precision values.\n- **sparse_vector_add_with_scale_dense_float(_:_:_:_:_:_:)**: Scales the sparse vector *x* by *alpha* and adds the result to the dense vector *y,* with both vectors containing single-precision values.\n- **sparse_vector_norm_double(_:_:_:_:)**: Computes the specified norm of the double-precision sparse vector *x*.\n- **sparse_vector_norm_float(_:_:_:_:)**: Computes the specified norm of the single-precision sparse vector *x*.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Computes the inner product of sparse vector *x* with double-precision *y*, with both vectors containing double-precision values.",
          "name" : "sparse_inner_product_dense_double(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_inner_product_dense_double(_:_:_:_:_:)"
        },
        {
          "description" : "Computes the inner product of sparse vector *x* with dense vector *y,* with both vectors containing single-precision values.",
          "name" : "sparse_inner_product_dense_float(_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_inner_product_dense_float(_:_:_:_:_:)"
        },
        {
          "description" : "Computes the inner product of sparse vector *x* with sparse vector *y,* with both vectors containing double-precision values.",
          "name" : "sparse_inner_product_sparse_double(_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_inner_product_sparse_double(_:_:_:_:_:_:)"
        },
        {
          "description" : "Computes the inner product of sparse vector *x* with sparse vector *y,* with both vectors containing single-precision values.",
          "name" : "sparse_inner_product_sparse_float(_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_inner_product_sparse_float(_:_:_:_:_:_:)"
        },
        {
          "description" : "Scales the sparse vector *x* by *alpha* and adds the result to the dense vector *y,* with both vectors containing single-precision values.",
          "name" : "sparse_vector_add_with_scale_dense_float(_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_vector_add_with_scale_dense_float(_:_:_:_:_:_:)"
        },
        {
          "description" : "Computes the specified norm of the double-precision sparse vector *x*.",
          "name" : "sparse_vector_norm_double(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_vector_norm_double(_:_:_:_:)"
        },
        {
          "description" : "Computes the specified norm of the single-precision sparse vector *x*.",
          "name" : "sparse_vector_norm_float(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_vector_norm_float(_:_:_:_:)"
        }
      ],
      "title" : "Vector-Vector Operations"
    }
  ],
  "source" : "appleJSON",
  "title" : "sparse_vector_add_with_scale_dense_double(_:_:_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse_vector_add_with_scale_dense_double(_:_:_:_:_:_:)"
}