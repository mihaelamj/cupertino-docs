{
  "abstract" : "Use the vImage library’s polynomial transform to apply tone curve adjustments to images.",
  "codeExamples" : [
    {
      "code" : "func populatePlanarSourceBuffers() {\n    srcInterleavedBuffer.deinterleave(destination: srcPlanarBuffers)\n}",
      "language" : "swift"
    },
    {
      "code" : "greenHandleValues = vDSP.ramp(\n    in: 0 ... 1,\n    count: PolynomialTransformer.count)",
      "language" : "swift"
    },
    {
      "code" : "@Published var greenHandleValues: [Double]! {\n    didSet {\n        greenCoefficients = calculateAndApplyPolynomial(\n            forHandleValues: greenHandleValues,\n            at: 1,\n            source: srcPlanarBuffers,\n            destination: destPlanarBuffers)\n        \n        displayPlanarDestinationBuffers()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func calculateAndApplyPolynomial(\n    forHandleValues values: [Double],\n    at planeIndex: Int,\n    source: vImage.PixelBuffer<vImage.PlanarFx4>,\n    destination: vImage.PixelBuffer<vImage.PlanarFx4>) -> [Float] {\n        \n        let coefficients = calculateCoefficients(values: values.map { Float($0) })\n        \n        source.withUnsafePixelBuffer(at: planeIndex) { src in\n            destination.withUnsafePixelBuffer(at: planeIndex) { dest in\n                \n                src.applyPolynomial(\n                    coefficientSegments: [coefficients],\n                    boundaries: [-.infinity, .infinity],\n                    destination: dest)\n            }\n        }\n        \n        return coefficients\n    }",
      "language" : "swift"
    },
    {
      "code" : "static func updatePath(path: inout Path,\n                       size: CGSize,\n                       coefficients: [Float]) {\n    \n    let polynomialResult = [Float](unsafeUninitializedCapacity: ramp.count) {\n        buffer, initializedCount in\n        \n        vDSP.evaluatePolynomial(usingCoefficients: coefficients.reversed(),\n                                withVariables: ramp,\n                                result: &buffer)\n        \n        vDSP.clip(buffer,\n                  to: 0 ... 1,\n                  result: &buffer)\n        \n        initializedCount = ramp.count\n    }\n\n    let cgPath = CGMutablePath()\n    let hScale = size.width \/ 256\n    let points: [CGPoint] = polynomialResult.enumerated().map {\n        CGPoint(x: CGFloat($0.offset) * hScale,\n                y: size.height - (size.height * CGFloat($0.element) ))\n    }\n\n    cgPath.addLines(between: points)\n    \n    path = Path(cgPath)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "f65cf4b007016ed89e9ec8954010cfcddd4ea33720598d52c225640b7d7e09f4",
  "crawledAt" : "2025-12-02T15:27:46Z",
  "id" : "5D31012C-E0C1-4CC9-B17C-4FC57FA63035",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThe vImage library provides a suite of functions for applying polynomials to images. The results of these functions are similar to the [https:\/\/support.apple.com\/en-gb\/guide\/photos\/pht7875d6b19\/7.0\/mac\/12.0] tool in the [https:\/\/www.apple.com\/uk\/macos\/photos\/] app. You can use the polynomial adjustment functions to adjust the overall look of a photo, change the look of specific colors (red, green, and blue), and adjust settings for the black point, midtones, and white point.\n\nThis sample code project calculates the polynomial coefficients from a set of values that the user defines using handles in the user interface. The vImage polynomial functions evaluate the polynomial coefficients to define the tone curve. The technique that calculates the coefficients is the Vandermonde method. To learn more about this technique, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/finding-an-interpolating-polynomial-using-the-vandermonde-method].\n\nTo generate the smooth curves in the user interface, the app passes the same coefficients that the vImage polynomial transform function uses to the vDSP [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/evaluatePolynomial(usingCoefficients:withVariables:)-31vi2] function.\n\nThe following image shows the sample code project’s app. The circles on the curves are the handles that the user can drag vertically, and the image changes to show the effect of the polynomial transform.\n\n\n\n### Convert the interleaved source image to planar buffers\n\nThe sample code project accepts source images that it converts to RGB, 32-bit per channel format. Because the vImage polynomial transform functions work on planar buffers, the code creates a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PlanarFx3] multiple-plane [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] structure that contains the separate red, green, and blue channels.\n\nAfter creating [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] structures that store the interleaved and planar representations of the source image, the `populatePlanarSourceBuffers()` function copies and deinterleaves the interleaved image to the planar buffers.\n\nTo learn more about working with planar buffers in vImage, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/optimizing-image-processing-performance].\n\n### Create the default curve control points\n\nThe sample code project defines five data points for each color channel that control the tone curve. By default, these form a linear ramp from `0` to `1`. The code calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(withInitialValue:increment:count:)-3cast] to populate the `redHandleValues`, `greenHandleValues`, and `blueHandleValues` arrays. The following shows the code that populates the `greenHandleValues` array:\n\nWhen the sample code app first launches, the default values form a linear tone curve that renders as a stright line in the user interface.\n\n\n\nThe default control points create an output image that’s identical to the input image. That is, for each pixel, the transformed output value is equal to the input value.\n\n### Apply the polynomial transform\n\nWhen the user adjusts the control points in the user interface, a `didSet` property observer applies the polynomial to the corresponding planar buffer. For example, the following shows the code for the green values:\n\nThe `calculateAndApplyPolynomial()` function calls `calculateCoefficients()` to calculate the coefficients using the Vandermonde method. It then passes the coefficients to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/applyPolynomial(coefficientSegments:boundaries:destination:)-26zom]. The vImage polynomial function effectively creates a polynomial curve from the specified coefficients and uses that as the tone curve. For each point on the curve, the horizontal position represents the input value, and the vertical position represents the output value.\n\nAfter the transform, the `displayPlanarDestinationBuffers()` function calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/interleave(destination:)-46cgi] to generate an interleaved image that the sample code displays in the user interface.\n\n### Display the tone curve in the user interface\n\nThe `PolynomialEditor` class uses the coefficients that the `applyPolynomial()` function computes to render a representation of the response curve.\n\nThe `updatePath()` function calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/evaluatePolynomial(usingCoefficients:withVariables:result:)-2ncdh] to build a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGPath] instance that the editor uses to render a smooth curve in the user interface.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-tone-curve-adjustments-to-images\ncrawled: 2025-12-02T15:27:46Z\n---\n\n# Applying tone curve adjustments to images\n\n**Sample Code**\n\nUse the vImage library’s polynomial transform to apply tone curve adjustments to images.\n\n## Overview\n\nThe vImage library provides a suite of functions for applying polynomials to images. The results of these functions are similar to the [https:\/\/support.apple.com\/en-gb\/guide\/photos\/pht7875d6b19\/7.0\/mac\/12.0] tool in the [https:\/\/www.apple.com\/uk\/macos\/photos\/] app. You can use the polynomial adjustment functions to adjust the overall look of a photo, change the look of specific colors (red, green, and blue), and adjust settings for the black point, midtones, and white point.\n\nThis sample code project calculates the polynomial coefficients from a set of values that the user defines using handles in the user interface. The vImage polynomial functions evaluate the polynomial coefficients to define the tone curve. The technique that calculates the coefficients is the Vandermonde method. To learn more about this technique, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/finding-an-interpolating-polynomial-using-the-vandermonde-method].\n\nTo generate the smooth curves in the user interface, the app passes the same coefficients that the vImage polynomial transform function uses to the vDSP [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/evaluatePolynomial(usingCoefficients:withVariables:)-31vi2] function.\n\nThe following image shows the sample code project’s app. The circles on the curves are the handles that the user can drag vertically, and the image changes to show the effect of the polynomial transform.\n\n\n\n### Convert the interleaved source image to planar buffers\n\nThe sample code project accepts source images that it converts to RGB, 32-bit per channel format. Because the vImage polynomial transform functions work on planar buffers, the code creates a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PlanarFx3] multiple-plane [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] structure that contains the separate red, green, and blue channels.\n\nAfter creating [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer] structures that store the interleaved and planar representations of the source image, the `populatePlanarSourceBuffers()` function copies and deinterleaves the interleaved image to the planar buffers.\n\n```swift\nfunc populatePlanarSourceBuffers() {\n    srcInterleavedBuffer.deinterleave(destination: srcPlanarBuffers)\n}\n```\n\nTo learn more about working with planar buffers in vImage, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/optimizing-image-processing-performance].\n\n### Create the default curve control points\n\nThe sample code project defines five data points for each color channel that control the tone curve. By default, these form a linear ramp from `0` to `1`. The code calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/ramp(withInitialValue:increment:count:)-3cast] to populate the `redHandleValues`, `greenHandleValues`, and `blueHandleValues` arrays. The following shows the code that populates the `greenHandleValues` array:\n\n```swift\ngreenHandleValues = vDSP.ramp(\n    in: 0 ... 1,\n    count: PolynomialTransformer.count)\n```\n\nWhen the sample code app first launches, the default values form a linear tone curve that renders as a stright line in the user interface.\n\n\n\nThe default control points create an output image that’s identical to the input image. That is, for each pixel, the transformed output value is equal to the input value.\n\n### Apply the polynomial transform\n\nWhen the user adjusts the control points in the user interface, a `didSet` property observer applies the polynomial to the corresponding planar buffer. For example, the following shows the code for the green values:\n\n```swift\n@Published var greenHandleValues: [Double]! {\n    didSet {\n        greenCoefficients = calculateAndApplyPolynomial(\n            forHandleValues: greenHandleValues,\n            at: 1,\n            source: srcPlanarBuffers,\n            destination: destPlanarBuffers)\n        \n        displayPlanarDestinationBuffers()\n    }\n}\n```\n\nThe `calculateAndApplyPolynomial()` function calls `calculateCoefficients()` to calculate the coefficients using the Vandermonde method. It then passes the coefficients to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/applyPolynomial(coefficientSegments:boundaries:destination:)-26zom]. The vImage polynomial function effectively creates a polynomial curve from the specified coefficients and uses that as the tone curve. For each point on the curve, the horizontal position represents the input value, and the vertical position represents the output value.\n\n```swift\nfunc calculateAndApplyPolynomial(\n    forHandleValues values: [Double],\n    at planeIndex: Int,\n    source: vImage.PixelBuffer<vImage.PlanarFx4>,\n    destination: vImage.PixelBuffer<vImage.PlanarFx4>) -> [Float] {\n        \n        let coefficients = calculateCoefficients(values: values.map { Float($0) })\n        \n        source.withUnsafePixelBuffer(at: planeIndex) { src in\n            destination.withUnsafePixelBuffer(at: planeIndex) { dest in\n                \n                src.applyPolynomial(\n                    coefficientSegments: [coefficients],\n                    boundaries: [-.infinity, .infinity],\n                    destination: dest)\n            }\n        }\n        \n        return coefficients\n    }\n```\n\nAfter the transform, the `displayPlanarDestinationBuffers()` function calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/interleave(destination:)-46cgi] to generate an interleaved image that the sample code displays in the user interface.\n\n### Display the tone curve in the user interface\n\nThe `PolynomialEditor` class uses the coefficients that the `applyPolynomial()` function computes to render a representation of the response curve.\n\nThe `updatePath()` function calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/evaluatePolynomial(usingCoefficients:withVariables:result:)-2ncdh] to build a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGPath] instance that the editor uses to render a smooth curve in the user interface.\n\n```swift\nstatic func updatePath(path: inout Path,\n                       size: CGSize,\n                       coefficients: [Float]) {\n    \n    let polynomialResult = [Float](unsafeUninitializedCapacity: ramp.count) {\n        buffer, initializedCount in\n        \n        vDSP.evaluatePolynomial(usingCoefficients: coefficients.reversed(),\n                                withVariables: ramp,\n                                result: &buffer)\n        \n        vDSP.clip(buffer,\n                  to: 0 ... 1,\n                  result: &buffer)\n        \n        initializedCount = ramp.count\n    }\n\n    let cgPath = CGMutablePath()\n    let hScale = size.width \/ 256\n    let points: [CGPoint] = polynomialResult.enumerated().map {\n        CGPoint(x: CGFloat($0.offset) * hScale,\n                y: size.height - (size.height * CGFloat($0.element) ))\n    }\n\n    cgPath.addLines(between: points)\n    \n    path = Path(cgPath)\n}\n```\n\n## Color and Tone Adjustment\n\n- **Adjusting the brightness and contrast of an image**: Use a gamma function to apply a linear or exponential curve.\n- **Adjusting saturation and applying tone mapping**: Convert an RGB image to discrete luminance and chrominance channels, and apply color and contrast treatments.\n- **Adjusting the hue of an image**: Convert an image to L*a*b* color space and apply hue adjustment.\n- **Specifying histograms with vImage**: Calculate the histogram of one image, and apply it to a second image.\n- **Enhancing image contrast with histogram manipulation**: Enhance and adjust the contrast of an image with histogram equalization and contrast stretching.\n- **Histogram**: Calculate or manipulate an image’s histogram.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use a gamma function to apply a linear or exponential curve.",
          "name" : "Adjusting the brightness and contrast of an image",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/adjusting-the-brightness-and-contrast-of-an-image"
        },
        {
          "description" : "Convert an RGB image to discrete luminance and chrominance channels, and apply color and contrast treatments.",
          "name" : "Adjusting saturation and applying tone mapping",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/adjusting-saturation-and-applying-tone-mapping"
        },
        {
          "description" : "Convert an image to L*a*b* color space and apply hue adjustment.",
          "name" : "Adjusting the hue of an image",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/adjusting-the-hue-of-an-image"
        },
        {
          "description" : "Calculate the histogram of one image, and apply it to a second image.",
          "name" : "Specifying histograms with vImage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/specifying-histograms-with-vimage"
        },
        {
          "description" : "Enhance and adjust the contrast of an image with histogram equalization and contrast stretching.",
          "name" : "Enhancing image contrast with histogram manipulation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/enhancing-image-contrast-with-histogram-manipulation"
        },
        {
          "description" : "Calculate or manipulate an image’s histogram.",
          "name" : "Histogram",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/histogram"
        }
      ],
      "title" : "Color and Tone Adjustment"
    }
  ],
  "source" : "appleJSON",
  "title" : "Applying tone curve adjustments to images",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-tone-curve-adjustments-to-images"
}