{
  "abstract" : "Solve systems of equations where the coefficient matrix is sparse.",
  "codeExamples" : [
    {
      "code" : "\/\/ The coefficient matrix, `A`.\nlet A: SparseMatrix_Double! = [ ... ]\n\n\/\/ The right-hand-side vector, `b`.\nlet b: DenseVector_Double! = [ ... ]\n\n\/\/ The factorization of `A` computed by `SparseFactor()`.\nlet factorization: SparseOpaqueFactorization_Double! = [ ... ]\n\n\/\/ The unknowns vector, `x` computed by `SparseSolve()`.\nlet x: DenseVector_Double! = [ ... ]\n\nlet count = Int(x.count)\nlet n = vDSP_Length(count)\n\nlet residualData = UnsafeMutableBufferPointer<Double>.allocate(capacity: count)\nlet residual = DenseVector_Double(count: Int32(count), data: residualData.baseAddress!)\n\nlet correctionData = UnsafeMutableBufferPointer<Double>.allocate(capacity: count)\nlet correction = DenseVector_Double(count: Int32(count), data: correctionData.baseAddress!)\n\ndefer {\n    residualData.deallocate()\n    correctionData.deallocate()\n}\n\nlet maximumIteratons = 3\n\nfor _ in 0 ..< maximumIteratons {\n    \n    \/\/ Calculate residual r = Ax - b.\n    vDSP_vnegD(b.data, 1,\n               residual.data, 1,\n               n)\n    SparseMultiplyAdd(A, x, residual);\n    \n    \/\/ Solve for correction and update x.\n    SparseSolve(factorization, residual, correction);\n    \n    \/\/ vDSP operation that calculates `x[i] -= correction[i]` for\n    \/\/ `i` in `0 ..< n`.\n    vDSP_vsubD(correction.data, 1,\n               x.data, 1,\n               x.data, 1,\n               n)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "02320274a9ad7c1ca4e709ec4c70e03b2f2ce64b1951d9b0d60d4f9ffffa6286",
  "crawledAt" : "2025-12-02T15:37:38Z",
  "id" : "C4E6E2E9-BD84-4D86-999F-7EA747DDA1AA",
  "kind" : "collection",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThe Sparse Solvers library in the Accelerate framework handles the solution of systems of equations where the coefficient matrix is sparse. That is, most of the entries in the matrix are zero. The Sparse Solvers library provides a sparse counterpart to the dense factorizations and linear solvers that LAPACK provides.\n\nMany problems in science and technology require the solution of large systems of simultaneous equations. When these equations are linear, you usually represent them as the matrix equation *Ax = b*. Even when the equations are nonlinear, you often solve the problem as a sequence of linear approximations.\n\n\n\n### Sparse matrices\n\nRoutines from libraries such as BLAS and LAPACK work with matrices that you store as a 2D dense array of floating-point values. However, the algorithms you use to manipulate matrices and solve equations normally require *O(n_Â²*)_ data and *O(n_Â³*)_ operations. As a result, scaling to a large *n* is prohibitive.\n\nTo avoid the expense of these algorithms, you can leverage the fact that in many real-world applications, matrices can contain many entries that are zero. Such matrices are called *sparse* (conversely, nonsparse matrices are called *dense*).\n\nThese zeros arise naturally in these types of situations:\n\nBy exploiting these zero entries, you can often reduce the storage and computational requirements to *O(ðœ*n)* and *O(ðœ*n_Â²*),_ respectively, where *ðœ* is the average number of entries in each column. This reduction makes the solution of large problems (*n* in the millions or larger) tractable on most computers.\n\nFor example, the sparse benchmark matrix *ldoor*, which arises from structural modeling, has 952,200 x 952,200 entries with an average of 25 nonzero [doc:\/\/com.apple.documentation\/documentation\/Swift\/Double] entries per column. The following table shows the number of floating-point operations (1 Tflop is 10Â¹Â² floating-point operations) and the memory necessary to perform Cholesky factorization on that matrix:\n\n### Solution approaches\n\nThe Accelerate framework offers two solution approaches:\n\nThe following table summarizes the differences between direct methods and iterative methods:\n\nIn contrast to direct methods, iterative methods provide a way for expert users to find approximate solutions faster using less memory. You can also use iterative methods when forming the explicit matrix is prohibitively expensive, but performing matrix-vector multiplications is performant. However, to achieve these gains, you need to select an appropriate preconditioner (an operator that approximates the inverse of *A*) thatâ€™s specific to your problem. Itâ€™s best to try a direct method before trying to use iterative methods.\n\n### Iterative refinement\n\nItâ€™s sometimes possible to improve the accuracy of the solution to *Ax = b* using *iterative refinement*. After finding an initial solution, iterative refinement reuses the factorization to find a series of small corrections with the aim of reducing the backward error.\n\nThe following code shows how to refine the values in the unknowns vector, *x*, over a fixed number of iterations:\n\n### Sparse Solvers and multithreading\n\nBy default, the Sparse Solvers library runs in multithreaded mode. Because multithreaded mode may sum child nodes and their ancestors in different orders, the solutions that the library provides may be different â€” although equally valid â€” across different runs.\n\nTo ensure that results are deterministic, set `VECLIB_MAXIMUM_THREADS=1` to specify single-threaded mode.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-solvers-library\ncrawled: 2025-12-02T15:37:38Z\n---\n\n# Sparse Solvers\n\n**API Collection**\n\nSolve systems of equations where the coefficient matrix is sparse.\n\n## Overview\n\nThe Sparse Solvers library in the Accelerate framework handles the solution of systems of equations where the coefficient matrix is sparse. That is, most of the entries in the matrix are zero. The Sparse Solvers library provides a sparse counterpart to the dense factorizations and linear solvers that LAPACK provides.\n\nMany problems in science and technology require the solution of large systems of simultaneous equations. When these equations are linear, you usually represent them as the matrix equation *Ax = b*. Even when the equations are nonlinear, you often solve the problem as a sequence of linear approximations.\n\n\n\n### Sparse matrices\n\nRoutines from libraries such as BLAS and LAPACK work with matrices that you store as a 2D dense array of floating-point values. However, the algorithms you use to manipulate matrices and solve equations normally require *O(n_Â²*)_ data and *O(n_Â³*)_ operations. As a result, scaling to a large *n* is prohibitive.\n\nTo avoid the expense of these algorithms, you can leverage the fact that in many real-world applications, matrices can contain many entries that are zero. Such matrices are called *sparse* (conversely, nonsparse matrices are called *dense*).\n\nThese zeros arise naturally in these types of situations:\n\n\n\nBy exploiting these zero entries, you can often reduce the storage and computational requirements to *O(ðœ*n)* and *O(ðœ*n_Â²*),_ respectively, where *ðœ* is the average number of entries in each column. This reduction makes the solution of large problems (*n* in the millions or larger) tractable on most computers.\n\nFor example, the sparse benchmark matrix *ldoor*, which arises from structural modeling, has 952,200 x 952,200 entries with an average of 25 nonzero [doc:\/\/com.apple.documentation\/documentation\/Swift\/Double] entries per column. The following table shows the number of floating-point operations (1 Tflop is 10Â¹Â² floating-point operations) and the memory necessary to perform Cholesky factorization on that matrix:\n\n\n\n### Solution approaches\n\nThe Accelerate framework offers two solution approaches:\n\n- **Direct methods** perform a factorization such as Cholesky (*A = LLáµ€*) or QR. These methods provide a fast and accurate opaque solution.\n- **Iterative methods** find an approximate solution requiring only repeated multiplication by *A* or *Aáµ€*. Although they require less memory than direct methods, and can be faster for very large problems, they typically require problem-specific preconditioners to be effective.\n\nThe following table summarizes the differences between direct methods and iterative methods:\n\n\n\nIn contrast to direct methods, iterative methods provide a way for expert users to find approximate solutions faster using less memory. You can also use iterative methods when forming the explicit matrix is prohibitively expensive, but performing matrix-vector multiplications is performant. However, to achieve these gains, you need to select an appropriate preconditioner (an operator that approximates the inverse of *A*) thatâ€™s specific to your problem. Itâ€™s best to try a direct method before trying to use iterative methods.\n\n### Iterative refinement\n\nItâ€™s sometimes possible to improve the accuracy of the solution to *Ax = b* using *iterative refinement*. After finding an initial solution, iterative refinement reuses the factorization to find a series of small corrections with the aim of reducing the backward error.\n\nThe following code shows how to refine the values in the unknowns vector, *x*, over a fixed number of iterations:\n\n```swift\n\/\/ The coefficient matrix, `A`.\nlet A: SparseMatrix_Double! = [ ... ]\n\n\/\/ The right-hand-side vector, `b`.\nlet b: DenseVector_Double! = [ ... ]\n\n\/\/ The factorization of `A` computed by `SparseFactor()`.\nlet factorization: SparseOpaqueFactorization_Double! = [ ... ]\n\n\/\/ The unknowns vector, `x` computed by `SparseSolve()`.\nlet x: DenseVector_Double! = [ ... ]\n\nlet count = Int(x.count)\nlet n = vDSP_Length(count)\n\nlet residualData = UnsafeMutableBufferPointer<Double>.allocate(capacity: count)\nlet residual = DenseVector_Double(count: Int32(count), data: residualData.baseAddress!)\n\nlet correctionData = UnsafeMutableBufferPointer<Double>.allocate(capacity: count)\nlet correction = DenseVector_Double(count: Int32(count), data: correctionData.baseAddress!)\n\ndefer {\n    residualData.deallocate()\n    correctionData.deallocate()\n}\n\nlet maximumIteratons = 3\n\nfor _ in 0 ..< maximumIteratons {\n    \n    \/\/ Calculate residual r = Ax - b.\n    vDSP_vnegD(b.data, 1,\n               residual.data, 1,\n               n)\n    SparseMultiplyAdd(A, x, residual);\n    \n    \/\/ Solve for correction and update x.\n    SparseSolve(factorization, residual, correction);\n    \n    \/\/ vDSP operation that calculates `x[i] -= correction[i]` for\n    \/\/ `i` in `0 ..< n`.\n    vDSP_vsubD(correction.data, 1,\n               x.data, 1,\n               x.data, 1,\n               n)\n}\n```\n\n### Sparse Solvers and multithreading\n\nBy default, the Sparse Solvers library runs in multithreaded mode. Because multithreaded mode may sum child nodes and their ancestors in different orders, the solutions that the library provides may be different â€” although equally valid â€” across different runs.\n\nTo ensure that results are deterministic, set `VECLIB_MAXIMUM_THREADS=1` to specify single-threaded mode.\n\n## Creating sparse matrices\n\n- **Creating sparse matrices**: Create sparse matrices for factorization and solving systems.\n- **SparseMatrix_Double**: A structure that contains a sparse matrix of double-precision, floating-point values.\n- **SparseMatrix_Float**: A structure that contains a sparse matrix of single-precision, floating-point values.\n- **Conversion from Other Formats**: Create sparse matrices from coordinate format arrays and BLAS opaque matrices.\n\n## Creating dense matrices and dense vectors\n\n- **DenseMatrix_Double**: A structure that contains a dense matrix of double-precision, floating-point values.\n- **DenseMatrix_Float**: A structure that contains a dense matrix of single-precision, floating-point values.\n- **DenseVector_Double**: A structure that contains a dense vector of double-precision, floating-point values.\n- **DenseVector_Float**: A structure that contains a dense vector of single-precision, floating-point values.\n\n## Creating sparse complex matrices\n\n- **SparseMatrix_Complex_Double**: A type representing a sparse complex matrix.\n- **SparseMatrix_Complex_Float**: A type representing a sparse complex matrix.\n- **SparseAttributesComplex_t**: A type representing the attributes of a matrix.\n- **SparseMatrixStructureComplex**: A type representing the sparsity structure of a sparse complex matrix.\n\n## Creating dense complex matrices and dense complex vectors\n\n- **DenseMatrix_Complex_Double**: Contains a dense `rowCount` x `columnCount` matrix of complex double values stored in column-major order.\n- **DenseMatrix_Complex_Float**: Contains a dense `rowCount` x `columnCount` matrix of complex float values stored in column-major order.\n- **DenseVector_Complex_Double**: Contains a dense vector of double complex values.\n- **DenseVector_Complex_Float**: Contains a dense vector of float complex values.\n\n## Solving systems with direct sparse methods\n\n- **Solving systems using direct methods**: Use direct methods to solve systems of equations where the coefficient matrix is sparse.\n- **SparseOpaqueFactorization_Double**: A structure that represents the factorization of a matrix of double-precision, floating-point values.\n- **SparseOpaqueFactorization_Float**: A structure that represents the factorization of a matrix of single-precision, floating-point values.\n- **SparseOpaqueFactorization_Complex_Double**: A semi-opaque type representing a matrix factorization in complex double.\n- **SparseOpaqueFactorization_Complex_Float**: A semi-opaque type representing a matrix factorization in complex float.\n- **Sparse Matrix Factor Functions**: Compute the factorization of a matrix.\n- **Sparse Direct Solving Functions (Matrix RHS)**: Solve a system with a right-hand-side dense matrix using a factored sparse coefficient matrix.\n- **Sparse Direct Solving Functions (Vector RHS)**: Solve a system with a right-hand-side dense vector using a factored sparse coefficient matrix.\n- **Sparse Symbolic Factorization Functions**: Calculate the symbolic factorization of a matrix, and solve systems using precalculated symbolic factorizations.\n- **Sparse Refactor Functions**: Recompute a factorization using the numerical data from a matrix.\n- **Subfactor Functions**: Extract and work with subfactors.\n\n## Solving systems with iterative sparse methods\n\n- **Solving systems using iterative methods**: Use iterative methods to solve systems of equations where the coefficient matrix is sparse.\n- **Sparse Iterative Solving Functions (Matrix RHS)**: Solve a system with a right-hand-side dense matrix using iterative methods.\n- **Sparse Iterative Solving Functions (Vector RHS)**: Solve a system with a right-hand-side dense vector using iterative methods.\n- **Sparse Iterate Functions**: Perform a single iteration of the specified iterative method.\n- **Sparse Iterative Methods**: Select a suitable iterative method to solve a system.\n- **Preconditioners**: Create preconditioners for iterative solves.\n\n## Multiplying and transposing sparse matrices\n\n- **Sparse Matrix and Dense Matrix Multiplication**: Multiply sparse and dense matrices.\n- **Sparse Matrix and Dense Vector Multiplication**: Multiply sparse matrices and dense vectors.\n- **Transposition**: Transpose matrices, factorizations, and subfactors.\n\n## Retaining and releasing resources\n\n- **Memory Management**: Retain and release sparse objects.\n\n## Macros\n\n- **SPARSE_CHECK_CONSISTENT_DS_MAT_IN_PLACE**\n- **SPARSE_CHECK_CONSISTENT_DS_MAT_OUT_PLACE**\n- **SPARSE_CHECK_CONSISTENT_DS_VEC_IN_PLACE**\n- **SPARSE_CHECK_CONSISTENT_DS_VEC_OUT_PLACE**\n- **SPARSE_CHECK_CONSISTENT_MAT_OUT_PLACE**\n- **SPARSE_CHECK_MATCH_SYMB_FACTOR**\n- **SPARSE_CHECK_VALID_MATRIX_STRUCTURE**\n- **SPARSE_CHECK_VALID_NUMERIC_FACTOR**\n- **SPARSE_CHECK_VALID_SYMBOLIC_FACTOR**\n- **SPARSE_CLOSED_ENUM**\n- **SPARSE_ENUM**\n- **SPARSE_PARAMETER_CHECK**\n- **SPARSE_PUBLIC_INTERFACE**\n- **SPARSE_INCLUDED_VIA_ACCELERATE**\n\n## Sparse Matrices\n\n- **Creating sparse matrices**: Create sparse matrices for factorization and solving systems.\n- **Solving systems using direct methods**: Use direct methods to solve systems of equations where the coefficient matrix is sparse.\n- **Solving systems using iterative methods**: Use iterative methods to solve systems of equations where the coefficient matrix is sparse.\n- **Creating a sparse matrix from coordinate format arrays**: Use separate coordinate format arrays to create sparse matrices.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create sparse matrices for factorization and solving systems.",
          "name" : "Creating sparse matrices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-sparse-matrices"
        },
        {
          "description" : "A structure that contains a sparse matrix of double-precision, floating-point values.",
          "name" : "SparseMatrix_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseMatrix_Double"
        },
        {
          "description" : "A structure that contains a sparse matrix of single-precision, floating-point values.",
          "name" : "SparseMatrix_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseMatrix_Float"
        },
        {
          "description" : "Create sparse matrices from coordinate format arrays and BLAS opaque matrices.",
          "name" : "Conversion from Other Formats",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/conversion-from-other-formats"
        }
      ],
      "title" : "Creating sparse matrices"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A structure that contains a dense matrix of double-precision, floating-point values.",
          "name" : "DenseMatrix_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseMatrix_Double"
        },
        {
          "description" : "A structure that contains a dense matrix of single-precision, floating-point values.",
          "name" : "DenseMatrix_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseMatrix_Float"
        },
        {
          "description" : "A structure that contains a dense vector of double-precision, floating-point values.",
          "name" : "DenseVector_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseVector_Double"
        },
        {
          "description" : "A structure that contains a dense vector of single-precision, floating-point values.",
          "name" : "DenseVector_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseVector_Float"
        }
      ],
      "title" : "Creating dense matrices and dense vectors"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type representing a sparse complex matrix.",
          "name" : "SparseMatrix_Complex_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseMatrix_Complex_Double"
        },
        {
          "description" : "A type representing a sparse complex matrix.",
          "name" : "SparseMatrix_Complex_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseMatrix_Complex_Float"
        },
        {
          "description" : "A type representing the attributes of a matrix.",
          "name" : "SparseAttributesComplex_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseAttributesComplex_t"
        },
        {
          "description" : "A type representing the sparsity structure of a sparse complex matrix.",
          "name" : "SparseMatrixStructureComplex",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseMatrixStructureComplex"
        }
      ],
      "title" : "Creating sparse complex matrices"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Contains a dense `rowCount` x `columnCount` matrix of complex double values stored in column-major order.",
          "name" : "DenseMatrix_Complex_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseMatrix_Complex_Double"
        },
        {
          "description" : "Contains a dense `rowCount` x `columnCount` matrix of complex float values stored in column-major order.",
          "name" : "DenseMatrix_Complex_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseMatrix_Complex_Float"
        },
        {
          "description" : "Contains a dense vector of double complex values.",
          "name" : "DenseVector_Complex_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseVector_Complex_Double"
        },
        {
          "description" : "Contains a dense vector of float complex values.",
          "name" : "DenseVector_Complex_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/DenseVector_Complex_Float"
        }
      ],
      "title" : "Creating dense complex matrices and dense complex vectors"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use direct methods to solve systems of equations where the coefficient matrix is sparse.",
          "name" : "Solving systems using direct methods",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-using-direct-methods"
        },
        {
          "description" : "A structure that represents the factorization of a matrix of double-precision, floating-point values.",
          "name" : "SparseOpaqueFactorization_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseOpaqueFactorization_Double"
        },
        {
          "description" : "A structure that represents the factorization of a matrix of single-precision, floating-point values.",
          "name" : "SparseOpaqueFactorization_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseOpaqueFactorization_Float"
        },
        {
          "description" : "A semi-opaque type representing a matrix factorization in complex double.",
          "name" : "SparseOpaqueFactorization_Complex_Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseOpaqueFactorization_Complex_Double"
        },
        {
          "description" : "A semi-opaque type representing a matrix factorization in complex float.",
          "name" : "SparseOpaqueFactorization_Complex_Float",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseOpaqueFactorization_Complex_Float"
        },
        {
          "description" : "Compute the factorization of a matrix.",
          "name" : "Sparse Matrix Factor Functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-matrix-factor-functions"
        },
        {
          "description" : "Solve a system with a right-hand-side dense matrix using a factored sparse coefficient matrix.",
          "name" : "Sparse Direct Solving Functions (Matrix RHS)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-direct-solving-functions-matrix-rhs"
        },
        {
          "description" : "Solve a system with a right-hand-side dense vector using a factored sparse coefficient matrix.",
          "name" : "Sparse Direct Solving Functions (Vector RHS)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-direct-solving-functions-vector-rhs"
        },
        {
          "description" : "Calculate the symbolic factorization of a matrix, and solve systems using precalculated symbolic factorizations.",
          "name" : "Sparse Symbolic Factorization Functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-symbolic-factorization-functions"
        },
        {
          "description" : "Recompute a factorization using the numerical data from a matrix.",
          "name" : "Sparse Refactor Functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-refactor-functions"
        },
        {
          "description" : "Extract and work with subfactors.",
          "name" : "Subfactor Functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/subfactor-functions"
        }
      ],
      "title" : "Solving systems with direct sparse methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use iterative methods to solve systems of equations where the coefficient matrix is sparse.",
          "name" : "Solving systems using iterative methods",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-using-iterative-methods"
        },
        {
          "description" : "Solve a system with a right-hand-side dense matrix using iterative methods.",
          "name" : "Sparse Iterative Solving Functions (Matrix RHS)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-iterative-solving-functions-matrix-rhs"
        },
        {
          "description" : "Solve a system with a right-hand-side dense vector using iterative methods.",
          "name" : "Sparse Iterative Solving Functions (Vector RHS)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-iterative-solving-functions-vector-rhs"
        },
        {
          "description" : "Perform a single iteration of the specified iterative method.",
          "name" : "Sparse Iterate Functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-iterate-functions"
        },
        {
          "description" : "Select a suitable iterative method to solve a system.",
          "name" : "Sparse Iterative Methods",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-iterative-methods"
        },
        {
          "description" : "Create preconditioners for iterative solves.",
          "name" : "Preconditioners",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/preconditioners"
        }
      ],
      "title" : "Solving systems with iterative sparse methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Multiply sparse and dense matrices.",
          "name" : "Sparse Matrix and Dense Matrix Multiplication",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-matrix-and-dense-matrix-multiplication"
        },
        {
          "description" : "Multiply sparse matrices and dense vectors.",
          "name" : "Sparse Matrix and Dense Vector Multiplication",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-matrix-and-dense-vector-multiplication"
        },
        {
          "description" : "Transpose matrices, factorizations, and subfactors.",
          "name" : "Transposition",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/transposition"
        }
      ],
      "title" : "Multiplying and transposing sparse matrices"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Retain and release sparse objects.",
          "name" : "Memory Management",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/memory-management"
        }
      ],
      "title" : "Retaining and releasing resources"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "SPARSE_CHECK_CONSISTENT_DS_MAT_IN_PLACE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_CONSISTENT_DS_MAT_IN_PLACE"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_CONSISTENT_DS_MAT_OUT_PLACE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_CONSISTENT_DS_MAT_OUT_PLACE"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_CONSISTENT_DS_VEC_IN_PLACE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_CONSISTENT_DS_VEC_IN_PLACE"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_CONSISTENT_DS_VEC_OUT_PLACE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_CONSISTENT_DS_VEC_OUT_PLACE"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_CONSISTENT_MAT_OUT_PLACE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_CONSISTENT_MAT_OUT_PLACE"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_MATCH_SYMB_FACTOR",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_MATCH_SYMB_FACTOR"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_VALID_MATRIX_STRUCTURE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_VALID_MATRIX_STRUCTURE"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_VALID_NUMERIC_FACTOR",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_VALID_NUMERIC_FACTOR"
        },
        {
          "description" : "",
          "name" : "SPARSE_CHECK_VALID_SYMBOLIC_FACTOR",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CHECK_VALID_SYMBOLIC_FACTOR"
        },
        {
          "description" : "",
          "name" : "SPARSE_CLOSED_ENUM",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_CLOSED_ENUM"
        },
        {
          "description" : "",
          "name" : "SPARSE_ENUM",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_ENUM"
        },
        {
          "description" : "",
          "name" : "SPARSE_PARAMETER_CHECK",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_PARAMETER_CHECK"
        },
        {
          "description" : "",
          "name" : "SPARSE_PUBLIC_INTERFACE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_PUBLIC_INTERFACE"
        },
        {
          "description" : "",
          "name" : "SPARSE_INCLUDED_VIA_ACCELERATE",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SPARSE_INCLUDED_VIA_ACCELERATE"
        }
      ],
      "title" : "Macros"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create sparse matrices for factorization and solving systems.",
          "name" : "Creating sparse matrices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-sparse-matrices"
        },
        {
          "description" : "Use direct methods to solve systems of equations where the coefficient matrix is sparse.",
          "name" : "Solving systems using direct methods",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-using-direct-methods"
        },
        {
          "description" : "Use iterative methods to solve systems of equations where the coefficient matrix is sparse.",
          "name" : "Solving systems using iterative methods",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/solving-systems-using-iterative-methods"
        },
        {
          "description" : "Use separate coordinate format arrays to create sparse matrices.",
          "name" : "Creating a sparse matrix from coordinate format arrays",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-a-sparse-matrix-from-coordinate-format-arrays"
        }
      ],
      "title" : "Sparse Matrices"
    }
  ],
  "source" : "appleJSON",
  "title" : "Sparse Solvers",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/sparse-solvers-library"
}