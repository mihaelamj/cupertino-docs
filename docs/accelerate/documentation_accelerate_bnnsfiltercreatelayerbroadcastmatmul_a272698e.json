{
  "abstract" : "Returns a new broadcast matrix multiply layer.",
  "codeExamples" : [
    {
      "code" : "let inputValues: [Float] = [\n    \/\/ Batch 0, channel 0.\n    11, 21,\n    31, 41,\n    51, 61,\n    71, 81,\n\n    \/\/ Batch 0, channel 1.\n    101, 201,\n    301, 401,\n    501, 601,\n    701, 801,\n\n    \/\/ Batch 0, channel 2.\n    1001, 2001,\n    3001, 4001,\n    5001, 6001,\n    7001, 8001,\n\n    \/\/ Batch 1, channel 0.\n    12, 22,\n    32, 42,\n    52, 62,\n    72, 82,\n    \n    \/\/ Batch 1, channel 1.\n    102, 202,\n    302, 402,\n    502, 602,\n    702, 802,\n\n    \/\/ Batch 1, channel 2.\n    1002, 2002,\n    3002, 4002,\n    5002, 6002,\n    7002, 8002\n]",
      "language" : "swift"
    },
    {
      "code" : "var weightsValues: [Float] = [\n    2, 0,\n    0, 2\n]",
      "language" : "swift"
    },
    {
      "code" : "let batchSize = 2\n\nlet i_desc = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                   layout: BNNSDataLayoutImageCHW,\n                                   size: (3, 4, 2, 0, 0, 0, 0, 0),\n                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                   data: nil,\n                                   data_type: .float,\n                                   table_data: nil,\n                                   table_data_type: .float,\n                                   data_scale: 1,\n                                   data_bias: 0)\n\nweightsValues.withUnsafeMutableBufferPointer { weightsPtr in\n    let w_desc = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                       layout: BNNSDataLayoutRowMajorMatrix,\n                                       size: (2, 2, 0, 0, 0, 0, 0, 0),\n                                       stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                       data: weightsPtr.baseAddress,\n                                       data_type: .float,\n                                       table_data: nil,\n                                       table_data_type: .float,\n                                       data_scale: 1,\n                                       data_bias: 0)\n\n    let o_desc = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                       layout: BNNSDataLayoutImageCHW,\n                                       size: (i_desc.size.0, i_desc.size.1, w_desc.size.1, 0, 0, 0, 0, 0),\n                                       stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                       data: nil,\n                                       data_type: .float,\n                                       table_data: nil,\n                                       table_data_type: .float,\n                                       data_scale: 1,\n                                       data_bias: 0)\n    \n    var layer_params = BNNSLayerParametersBroadcastMatMul(alpha: 1,\n                                                          beta: 0,\n                                                          transA: false,\n                                                          transB: false,\n                                                          quadratic: false,\n                                                          a_is_weights: false,\n                                                          b_is_weights: true,\n                                                          iA_desc: i_desc,\n                                                          iB_desc: w_desc,\n                                                          o_desc: o_desc)\n    \n    let filter = BNNSFilterCreateLayerBroadcastMatMul(&layer_params, nil)\n    defer {\n        BNNSFilterDestroy(filter)\n    }\n    \n    var outputValues = [Float](repeating: -1,\n                                 count: o_desc.size.0 * o_desc.size.1 * o_desc.size.2 * batchSize)\n    \n    BNNSFilterApplyBatch(filter, batchSize,\n                         inputValues, i_desc.size.0 * i_desc.size.1 * i_desc.size.2,\n                         &outputValues, o_desc.size.0 * o_desc.size.1 * o_desc.size.2)\n}",
      "language" : "swift"
    },
    {
      "code" : "[ \/\/ Batch 0, channel 0.\n  22.0, 42.0, \n  62.0, 82.0, \n  102.0, 122.0, \n  142.0, 162.0, \n\n  \/\/ Batch 0, channel 1.\n  202.0, 402.0, \n  602.0, 802.0, \n  1002.0, 1202.0, \n  1402.0, 1602.0, \n\n  \/\/ Batch 0, channel 2.\n  2002.0, 4002.0, \n  6002.0, 8002.0, \n  10002.0, 12002.0, \n  14002.0, 16002.0, \n\n  \/\/ Batch 1, channel 0.\n  24.0, 44.0, \n  64.0, 84.0, \n  104.0, 124.0, \n  144.0, 164.0, \n\n  \/\/ Batch 1, channel 1.\n  204.0, 404.0, \n  604.0, 804.0, \n  1004.0, 1204.0, \n  1404.0, 1604.0, \n\n  \/\/ Batch 1, channel 2.\n  2004.0, 4004.0, \n  6004.0, 8004.0, \n  10004.0, 12004.0, \n  14004.0, 16004.0 ]",
      "language" : "swift"
    }
  ],
  "contentHash" : "6fb4b21450b7f8b9130397fed2d29d8319d76d7761974500382a2998b7476dfa",
  "crawledAt" : "2025-12-03T20:16:45Z",
  "declaration" : {
    "code" : "func BNNSFilterCreateLayerBroadcastMatMul(_ layer_params: UnsafePointer<BNNSLayerParametersBroadcastMatMul>, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> BNNSFilter?",
    "language" : "swift"
  },
  "id" : "77F79405-79BC-4C34-9F60-77E48859A25D",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nUse broadcast matrix to perform matrix multiplication on the last two indices of two tensors.\n\nIn a case where one tensor has a higher rank (that is, the number of dimensions) than the other, the lower rank matrix is broadcast in the missing dimensions. The operation broadcasts dimensions with a size of one to match the size of the corresponding dimension in the other tensor. For example, given the following data that describes two 3D matrices of two columns, four rows, and three channels:\n\nBroadcast matrix multiplication provides the functionality to multiply the 3D data in `inputValues` by a 2D matrix by braodcasting it across the missing dimension. In this example, the second matrix contains the following values:\n\nThe following code creates `BNNSNDArrayDescriptor` structures to describe the two inputs and the output. Note that the code passes the second input, `weights`, to the parameters structure with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersBroadcastMatMul\/b_is_weights] set to `true`. This means that the filter stores the data pointer to `weights`, and you don’t need to pass the weights data to the apply call.\n\nOn return, `outputValues` contains each element of the input values, multiplied by 2:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFilterCreateLayerBroadcastMatMul(_:_:)\ncrawled: 2025-12-03T20:16:45Z\n---\n\n# BNNSFilterCreateLayerBroadcastMatMul(_:_:)\n\n**Function**\n\nReturns a new broadcast matrix multiply layer.\n\n## Declaration\n\n```swift\nfunc BNNSFilterCreateLayerBroadcastMatMul(_ layer_params: UnsafePointer<BNNSLayerParametersBroadcastMatMul>, _ filter_params: UnsafePointer<BNNSFilterParameters>?) -> BNNSFilter?\n```\n\n## Parameters\n\n- **layer_params**: Layer parameters.\n- **filter_params**: The filter runtime parameters.\n\n## Discussion\n\nUse broadcast matrix to perform matrix multiplication on the last two indices of two tensors.\n\nIn a case where one tensor has a higher rank (that is, the number of dimensions) than the other, the lower rank matrix is broadcast in the missing dimensions. The operation broadcasts dimensions with a size of one to match the size of the corresponding dimension in the other tensor. For example, given the following data that describes two 3D matrices of two columns, four rows, and three channels:\n\n```swift\nlet inputValues: [Float] = [\n    \/\/ Batch 0, channel 0.\n    11, 21,\n    31, 41,\n    51, 61,\n    71, 81,\n\n    \/\/ Batch 0, channel 1.\n    101, 201,\n    301, 401,\n    501, 601,\n    701, 801,\n\n    \/\/ Batch 0, channel 2.\n    1001, 2001,\n    3001, 4001,\n    5001, 6001,\n    7001, 8001,\n\n    \/\/ Batch 1, channel 0.\n    12, 22,\n    32, 42,\n    52, 62,\n    72, 82,\n    \n    \/\/ Batch 1, channel 1.\n    102, 202,\n    302, 402,\n    502, 602,\n    702, 802,\n\n    \/\/ Batch 1, channel 2.\n    1002, 2002,\n    3002, 4002,\n    5002, 6002,\n    7002, 8002\n]\n```\n\nBroadcast matrix multiplication provides the functionality to multiply the 3D data in `inputValues` by a 2D matrix by braodcasting it across the missing dimension. In this example, the second matrix contains the following values:\n\n```swift\nvar weightsValues: [Float] = [\n    2, 0,\n    0, 2\n]\n```\n\nThe following code creates `BNNSNDArrayDescriptor` structures to describe the two inputs and the output. Note that the code passes the second input, `weights`, to the parameters structure with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/BNNSLayerParametersBroadcastMatMul\/b_is_weights] set to `true`. This means that the filter stores the data pointer to `weights`, and you don’t need to pass the weights data to the apply call.\n\n```swift\nlet batchSize = 2\n\nlet i_desc = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                   layout: BNNSDataLayoutImageCHW,\n                                   size: (3, 4, 2, 0, 0, 0, 0, 0),\n                                   stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                   data: nil,\n                                   data_type: .float,\n                                   table_data: nil,\n                                   table_data_type: .float,\n                                   data_scale: 1,\n                                   data_bias: 0)\n\nweightsValues.withUnsafeMutableBufferPointer { weightsPtr in\n    let w_desc = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                       layout: BNNSDataLayoutRowMajorMatrix,\n                                       size: (2, 2, 0, 0, 0, 0, 0, 0),\n                                       stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                       data: weightsPtr.baseAddress,\n                                       data_type: .float,\n                                       table_data: nil,\n                                       table_data_type: .float,\n                                       data_scale: 1,\n                                       data_bias: 0)\n\n    let o_desc = BNNSNDArrayDescriptor(flags: BNNSNDArrayFlags(0),\n                                       layout: BNNSDataLayoutImageCHW,\n                                       size: (i_desc.size.0, i_desc.size.1, w_desc.size.1, 0, 0, 0, 0, 0),\n                                       stride: (0, 0, 0, 0, 0, 0, 0, 0),\n                                       data: nil,\n                                       data_type: .float,\n                                       table_data: nil,\n                                       table_data_type: .float,\n                                       data_scale: 1,\n                                       data_bias: 0)\n    \n    var layer_params = BNNSLayerParametersBroadcastMatMul(alpha: 1,\n                                                          beta: 0,\n                                                          transA: false,\n                                                          transB: false,\n                                                          quadratic: false,\n                                                          a_is_weights: false,\n                                                          b_is_weights: true,\n                                                          iA_desc: i_desc,\n                                                          iB_desc: w_desc,\n                                                          o_desc: o_desc)\n    \n    let filter = BNNSFilterCreateLayerBroadcastMatMul(&layer_params, nil)\n    defer {\n        BNNSFilterDestroy(filter)\n    }\n    \n    var outputValues = [Float](repeating: -1,\n                                 count: o_desc.size.0 * o_desc.size.1 * o_desc.size.2 * batchSize)\n    \n    BNNSFilterApplyBatch(filter, batchSize,\n                         inputValues, i_desc.size.0 * i_desc.size.1 * i_desc.size.2,\n                         &outputValues, o_desc.size.0 * o_desc.size.1 * o_desc.size.2)\n}\n```\n\nOn return, `outputValues` contains each element of the input values, multiplied by 2:\n\n```swift\n[ \/\/ Batch 0, channel 0.\n  22.0, 42.0, \n  62.0, 82.0, \n  102.0, 122.0, \n  142.0, 162.0, \n\n  \/\/ Batch 0, channel 1.\n  202.0, 402.0, \n  602.0, 802.0, \n  1002.0, 1202.0, \n  1402.0, 1602.0, \n\n  \/\/ Batch 0, channel 2.\n  2002.0, 4002.0, \n  6002.0, 8002.0, \n  10002.0, 12002.0, \n  14002.0, 16002.0, \n\n  \/\/ Batch 1, channel 0.\n  24.0, 44.0, \n  64.0, 84.0, \n  104.0, 124.0, \n  144.0, 164.0, \n\n  \/\/ Batch 1, channel 1.\n  204.0, 404.0, \n  604.0, 804.0, \n  1004.0, 1204.0, \n  1404.0, 1604.0, \n\n  \/\/ Batch 1, channel 2.\n  2004.0, 4004.0, \n  6004.0, 8004.0, \n  10004.0, 12004.0, \n  14004.0, 16004.0 ]\n```\n\n## Matrix multiplication\n\n- **BNNSDirectApplyBroadcastMatMul(_:_:_:_:_:_:_:)**: Applies a broadcast matrix multiplication operation directly to two input matrices.\n- **BNNS.BroadcastMatrixMultiplyLayer**: A layer object that wraps a broadcast matrix multiply filter and manages its deinitialization.\n- **BNNSLayerParametersBroadcastMatMul**: A set of parameters that define a broadcast matrix multiply layer.\n- **BNNSMatMulWorkspaceSize(_:_:_:_:_:_:_:)**: Returns the workspace size that a matrix multiply operation requires.\n- **BNNSMatMul(_:_:_:_:_:_:_:_:)**: Applies a matrix multiplication operation directly to two input matrices.\n- **applyMatrixMultiplication(inputA:transposed:inputB:transposed:output:alpha:workspace:filterParameters:)**: Performs a matrix multiplication operation directly on two input matrices.\n- **matrixMultiplicationWorkspaceSize(inputA:transposed:inputB:transposed:output:alpha:filterParameters:)**: Returns the workspace size that a matrix multiply operation requires.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Applies a broadcast matrix multiplication operation directly to two input matrices.",
          "name" : "BNNSDirectApplyBroadcastMatMul(_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSDirectApplyBroadcastMatMul(_:_:_:_:_:_:_:)"
        },
        {
          "description" : "A layer object that wraps a broadcast matrix multiply filter and manages its deinitialization.",
          "name" : "BNNS.BroadcastMatrixMultiplyLayer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/BroadcastMatrixMultiplyLayer"
        },
        {
          "description" : "A set of parameters that define a broadcast matrix multiply layer.",
          "name" : "BNNSLayerParametersBroadcastMatMul",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSLayerParametersBroadcastMatMul"
        },
        {
          "description" : "Returns the workspace size that a matrix multiply operation requires.",
          "name" : "BNNSMatMulWorkspaceSize(_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSMatMulWorkspaceSize(_:_:_:_:_:_:_:)"
        },
        {
          "description" : "Applies a matrix multiplication operation directly to two input matrices.",
          "name" : "BNNSMatMul(_:_:_:_:_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSMatMul(_:_:_:_:_:_:_:_:)"
        },
        {
          "description" : "Performs a matrix multiplication operation directly on two input matrices.",
          "name" : "applyMatrixMultiplication(inputA:transposed:inputB:transposed:output:alpha:workspace:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/applyMatrixMultiplication(inputA:transposed:inputB:transposed:output:alpha:workspace:filterParameters:)"
        },
        {
          "description" : "Returns the workspace size that a matrix multiply operation requires.",
          "name" : "matrixMultiplicationWorkspaceSize(inputA:transposed:inputB:transposed:output:alpha:filterParameters:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNS\/matrixMultiplicationWorkspaceSize(inputA:transposed:inputB:transposed:output:alpha:filterParameters:)"
        }
      ],
      "title" : "Matrix multiplication"
    }
  ],
  "source" : "appleJSON",
  "title" : "BNNSFilterCreateLayerBroadcastMatMul(_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/BNNSFilterCreateLayerBroadcastMatMul(_:_:)"
}