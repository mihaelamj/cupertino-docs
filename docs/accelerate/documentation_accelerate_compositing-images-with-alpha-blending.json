{
  "abstract" : "Combine two images by using alpha blending to create a single output.",
  "codeExamples" : [
    {
      "code" : "func alphaComposite(topImage: CGImage, bottomImage: CGImage) -> CGImage? {\n    \/\/ Create source and destination vImage buffers.\n    guard\n        let topImageBuffer = try? vImage_Buffer(cgImage: topImage),\n        let bottomImageBuffer = try? vImage_Buffer(cgImage: bottomImage),\n        var destinationImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,\n                                                        bitsPerPixel: 8 * 4)\n    else {\n        return nil\n    }\n    \n    defer {\n        topImageBuffer.free()\n        bottomImageBuffer.free()\n        destinationImageBuffer.free()\n    }\n\n    withUnsafePointer(to: topImageBuffer) { topPtr in\n        withUnsafePointer(to: bottomImageBuffer) { bottomPtr in\n            \n            \/\/ Ensure the bottom image and top image are ARGB.\n            convertToARGB(bottomPtr, alphaInfo: bottomImage.alphaInfo)\n            convertToARGB(topPtr, alphaInfo: topImage.alphaInfo)\n            \n            \/\/ Ensure the top layer is premultiplied.\n            premultiply(topPtr, alphaInfo: topImage.alphaInfo)\n\n            \/\/ Perform the composite operation.\n            vImagePremultipliedAlphaBlend_ARGB8888(topPtr,\n                                                   bottomPtr,\n                                                   &destinationImageBuffer,\n                                                   vImage_Flags(kvImageNoFlags))\n        }\n    }\n    \n    if let destinationFormat = vImage_CGImageFormat(\n        bitsPerComponent: 8,\n        bitsPerPixel: 8 * 4,\n        colorSpace: CGColorSpaceCreateDeviceRGB(),\n        bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue)) {\n        return try? destinationImageBuffer.createCGImage(format: destinationFormat)\n    }\n    return nil\n}\n",
      "language" : "swift"
    },
    {
      "code" : "func convertToARGB(_ buffer: UnsafePointer<vImage_Buffer>,\n                   alphaInfo: CGImageAlphaInfo) {\n    \n    let alphaLasts = [ CGImageAlphaInfo.last,\n                       CGImageAlphaInfo.premultipliedLast,\n                       CGImageAlphaInfo.noneSkipLast ]\n    \n    if alphaLasts.contains(alphaInfo) {\n        vImagePermuteChannels_ARGB8888(buffer,\n                                       buffer,\n                                       [3, 0, 1, 2],\n                                       vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func premultiply(_ buffer: UnsafePointer<vImage_Buffer>,\n                 alphaInfo: CGImageAlphaInfo) {\n    \n    let premultiplieds = [ CGImageAlphaInfo.premultipliedFirst,\n                           CGImageAlphaInfo.premultipliedLast ]\n    \n    if !premultiplieds.contains(alphaInfo) {\n        vImagePremultiplyData_ARGB8888(buffer,\n                                       buffer,\n                                       vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "destColor = (srcTopColor * constAlpha * 255  + (255*255 - srcTopAlpha * constAlpha) * srcBottomColor + 127*255) \/ (255*255);\ndestAlpha =  (srcTopAlpha * constAlpha * 255 + (255*255 - srcTopAlpha * constAlpha) * srcBottomAlpha + 127*255 ) \/ (255*255);",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Perform the composite operation.\nvImagePremultipliedConstAlphaBlend_ARGB8888(topPtr,\n                                            Pixel_8(191),\n                                            bottomPtr,\n                                            &destinationImageBuffer,\n                                            vImage_Flags(kvImageNoFlags))",
      "language" : "swift"
    },
    {
      "code" : "func radialComposite(topImage: CGImage,\n                     bottomImage: CGImage) -> CGImage? {\n    \/\/ Create source and destination vImage buffers.\n    guard\n        let topImageBuffer = try? vImage_Buffer(cgImage: topImage),\n        let bottomImageBuffer = try? vImage_Buffer(cgImage: bottomImage),\n        var gradientImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,\n                                                     bitsPerPixel: 8),\n        var destinationImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,\n                                                        bitsPerPixel: 8 * 4)\n    else {\n        return nil\n    }\n    \n    defer {\n        topImageBuffer.free()\n        bottomImageBuffer.free()\n        gradientImageBuffer.free()\n        destinationImageBuffer.free()\n    }\n    \n    withUnsafePointer(to: topImageBuffer) { topPtr in\n        withUnsafePointer(to: bottomImageBuffer) { bottomPtr in\n            \n            \/\/ Ensure the top image and the bottom image are ARGB.\n            convertToARGB(topPtr, alphaInfo: topImage.alphaInfo)\n            convertToARGB(bottomPtr, alphaInfo: bottomImage.alphaInfo)\n            \n            \/\/ Populate `gradientImageBuffer` with a radial gradient.\n            makeRadialGradient(&gradientImageBuffer)\n            \n            \/\/ Unpremultiply before overwriting, if required.\n            unpremultiply(topPtr, alphaInfo: topImage.alphaInfo)\n            \n            \/\/ Overwrite the top layers's alpha channel with the radial gradient.\n            vImageOverwriteChannels_ARGB8888(&gradientImageBuffer,\n                                             topPtr, topPtr,\n                                             0x8,\n                                             vImage_Flags(kvImageNoFlags))\n            \n            \/\/ Premultiply the top layer.\n            vImagePremultiplyData_ARGB8888(topPtr, topPtr,\n                                           vImage_Flags(kvImageNoFlags))\n            \n            \/\/ Perform the alpha blend of the top layer over the bottom layer.\n            vImagePremultipliedAlphaBlend_ARGB8888(topPtr,\n                                                   bottomPtr,\n                                                   &destinationImageBuffer,\n                                                   vImage_Flags(kvImageNoFlags))\n        }\n    }\n    \n    if let destinationFormat = vImage_CGImageFormat(\n        bitsPerComponent: 8,\n        bitsPerPixel: 8 * 4,\n        colorSpace: CGColorSpaceCreateDeviceRGB(),\n        bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue)) {\n        return try? destinationImageBuffer.createCGImage(format: destinationFormat)\n    }\n    return nil\n}",
      "language" : "swift"
    },
    {
      "code" : "func unpremultiply(_ buffer: UnsafePointer<vImage_Buffer>,\n                   alphaInfo: CGImageAlphaInfo) {\n    \n    let premultiplieds = [ CGImageAlphaInfo.premultipliedFirst,\n                           CGImageAlphaInfo.premultipliedLast ]\n    \n    if premultiplieds.contains(alphaInfo) {\n        vImageUnpremultiplyData_ARGB8888(buffer,\n                                         buffer,\n                                         vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func makeRadialGradient(_ destination: inout vImage_Buffer) {\n    let width = Int(destination.size.width)\n    let height = Int(destination.size.height)\n    \n    var gradientValues = [Float](unsafeUninitializedCapacity: width * height) {\n        buffer, initializedCount in\n        \n        let verticalWindow = vDSP.window(ofType: Float.self,\n                                         usingSequence: .hanningDenormalized,\n                                         count: height,\n                                         isHalfWindow: false)\n        \n        let horizontalWindow = vDSP.window(ofType: Float.self,\n                                           usingSequence: .hanningDenormalized,\n                                           count: width,\n                                           isHalfWindow: false)\n        \n        vDSP_mmul(verticalWindow, 1,\n                  horizontalWindow, 1,\n                  buffer.baseAddress!, 1,\n                  vDSP_Length(height),\n                  vDSP_Length(width), 1)\n        \n        initializedCount = width * height\n    }.map {\n        return Pixel_8($0 * Float(Pixel_8.max))\n    }\n    \n    gradientValues.withUnsafeMutableBufferPointer { gradientPtr in\n        let gradientBuffer = vImage_Buffer(data: gradientPtr.baseAddress,\n                                           height: vImagePixelCount(height),\n                                           width: vImagePixelCount(width),\n                                           rowBytes: width)\n        \n        try? gradientBuffer.copy(destinationBuffer: &destination,\n                                 pixelSize: 1)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "cface93eecef664b64cfe94d8875d5cedb3ad75b7d9ff2b030ef97414df57860",
  "crawledAt" : "2025-12-02T15:37:09Z",
  "id" : "433DA9A6-49C0-4335-A907-4B3A685DBAB9",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nvImage provides a suite of functions for compositing two source images into one output. *Alpha blending* uses the alpha value of each pixel in the top layer to determine the visibility of the bottom layer.\n\nThe figure below shows the alpha composite of an image of a building with a transparent background over an image of a texture. The transparent part of the building image has an alpha of zero, indicating the background layer is fully visible.\n\n\n\n### Perform an alpha composite\n\nUse the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] function to blend two images when the top image contains alpha information (for example, when compositing text over a photograph). The images that you pass to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] need to have the premultiplied alpha information in the first channel.\n\nThe following function performs an alpha composite of two [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instances and returns the result as a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instance:\n\nBecause the blending function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] requires that the alpha channel source buffers are first, the code calls `convertToARGB(_:alphaInfo:)` to ensure the correct ordering. The `convertToARGB(_:alphaInfo:)` function checks the channel ordering from the source image’s alpha information and permutes the channels if the ordering isn’t alpha-first.\n\nThe `premultiply(_:alphaInfo:)` function uses a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instance’s alpha information to determine whether an image contains premultiplied alpha. This function ensures that the top layer that the function passes to the composite operation contains premultiplied pixels.\n\n### Perform an alpha composite with a single alpha value\n\nvImage provides functions to perform an alpha composite using a single alpha value. The functions apply the constant alpha value you supply combined with the top image’s existing alpha to the top layer’s color channels and alpha channels. For each pixel, the constant alpha functions perform the following operation:\n\nTo perform an alpha composite with a constant alpha, replace the call to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] in the code listing in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/compositing-images-with-alpha-blending#Perform-an-alpha-composite] with the following code:\n\nThe following image shows the result of compositing with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)] using a constant alpha with a value of `191`. The background of the building remains transparent, but the parts of the image that were originally opaque now show some of the lower layer.\n\n\n\n### Perform an alpha composite with an overwritten alpha channel\n\nUse the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)] function to overwrite an image’s alpha channel. The following shows an example of setting a radial gradient as the alpha channel of an image to produce a vignette style blend:\n\n\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)] function requires buffers with nonpremultiplied alpha.\n\nThe `radialComposite(topImage:bottomImage:)` function performs an alpha composite of two [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instances with a procedural radial gradient.\n\nThe code calls `unpremultiply(_:alphaInfo:)` to unpremultiply an image if its alpha information indicates it contains premultiplied pixels.\n\nThe `radialComposite(topImage:bottomImage:)` function calls `makeRadialGradient(_:)` to populate the gradient buffer with a radial gradient. The code generates the radial gradient by multiplying a `height * 1` matrix by a `1 * width` matrix. Both factors contain values that follow a bell-shaped curve.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/compositing-images-with-alpha-blending\ncrawled: 2025-12-02T15:37:09Z\n---\n\n# Compositing images with alpha blending\n\n**Article**\n\nCombine two images by using alpha blending to create a single output.\n\n## Overview\n\nvImage provides a suite of functions for compositing two source images into one output. *Alpha blending* uses the alpha value of each pixel in the top layer to determine the visibility of the bottom layer.\n\nThe figure below shows the alpha composite of an image of a building with a transparent background over an image of a texture. The transparent part of the building image has an alpha of zero, indicating the background layer is fully visible.\n\n\n\n### Perform an alpha composite\n\nUse the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] function to blend two images when the top image contains alpha information (for example, when compositing text over a photograph). The images that you pass to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] need to have the premultiplied alpha information in the first channel.\n\nThe following function performs an alpha composite of two [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instances and returns the result as a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instance:\n\n```swift\nfunc alphaComposite(topImage: CGImage, bottomImage: CGImage) -> CGImage? {\n    \/\/ Create source and destination vImage buffers.\n    guard\n        let topImageBuffer = try? vImage_Buffer(cgImage: topImage),\n        let bottomImageBuffer = try? vImage_Buffer(cgImage: bottomImage),\n        var destinationImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,\n                                                        bitsPerPixel: 8 * 4)\n    else {\n        return nil\n    }\n    \n    defer {\n        topImageBuffer.free()\n        bottomImageBuffer.free()\n        destinationImageBuffer.free()\n    }\n\n    withUnsafePointer(to: topImageBuffer) { topPtr in\n        withUnsafePointer(to: bottomImageBuffer) { bottomPtr in\n            \n            \/\/ Ensure the bottom image and top image are ARGB.\n            convertToARGB(bottomPtr, alphaInfo: bottomImage.alphaInfo)\n            convertToARGB(topPtr, alphaInfo: topImage.alphaInfo)\n            \n            \/\/ Ensure the top layer is premultiplied.\n            premultiply(topPtr, alphaInfo: topImage.alphaInfo)\n\n            \/\/ Perform the composite operation.\n            vImagePremultipliedAlphaBlend_ARGB8888(topPtr,\n                                                   bottomPtr,\n                                                   &destinationImageBuffer,\n                                                   vImage_Flags(kvImageNoFlags))\n        }\n    }\n    \n    if let destinationFormat = vImage_CGImageFormat(\n        bitsPerComponent: 8,\n        bitsPerPixel: 8 * 4,\n        colorSpace: CGColorSpaceCreateDeviceRGB(),\n        bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue)) {\n        return try? destinationImageBuffer.createCGImage(format: destinationFormat)\n    }\n    return nil\n}\n\n```\n\nBecause the blending function [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] requires that the alpha channel source buffers are first, the code calls `convertToARGB(_:alphaInfo:)` to ensure the correct ordering. The `convertToARGB(_:alphaInfo:)` function checks the channel ordering from the source image’s alpha information and permutes the channels if the ordering isn’t alpha-first.\n\n```swift\nfunc convertToARGB(_ buffer: UnsafePointer<vImage_Buffer>,\n                   alphaInfo: CGImageAlphaInfo) {\n    \n    let alphaLasts = [ CGImageAlphaInfo.last,\n                       CGImageAlphaInfo.premultipliedLast,\n                       CGImageAlphaInfo.noneSkipLast ]\n    \n    if alphaLasts.contains(alphaInfo) {\n        vImagePermuteChannels_ARGB8888(buffer,\n                                       buffer,\n                                       [3, 0, 1, 2],\n                                       vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\nThe `premultiply(_:alphaInfo:)` function uses a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instance’s alpha information to determine whether an image contains premultiplied alpha. This function ensures that the top layer that the function passes to the composite operation contains premultiplied pixels.\n\n```swift\nfunc premultiply(_ buffer: UnsafePointer<vImage_Buffer>,\n                 alphaInfo: CGImageAlphaInfo) {\n    \n    let premultiplieds = [ CGImageAlphaInfo.premultipliedFirst,\n                           CGImageAlphaInfo.premultipliedLast ]\n    \n    if !premultiplieds.contains(alphaInfo) {\n        vImagePremultiplyData_ARGB8888(buffer,\n                                       buffer,\n                                       vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\n### Perform an alpha composite with a single alpha value\n\nvImage provides functions to perform an alpha composite using a single alpha value. The functions apply the constant alpha value you supply combined with the top image’s existing alpha to the top layer’s color channels and alpha channels. For each pixel, the constant alpha functions perform the following operation:\n\n```swift\ndestColor = (srcTopColor * constAlpha * 255  + (255*255 - srcTopAlpha * constAlpha) * srcBottomColor + 127*255) \/ (255*255);\ndestAlpha =  (srcTopAlpha * constAlpha * 255 + (255*255 - srcTopAlpha * constAlpha) * srcBottomAlpha + 127*255 ) \/ (255*255);\n```\n\nTo perform an alpha composite with a constant alpha, replace the call to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedAlphaBlend_ARGB8888(_:_:_:_:)] in the code listing in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/compositing-images-with-alpha-blending#Perform-an-alpha-composite] with the following code:\n\n```swift\n\/\/ Perform the composite operation.\nvImagePremultipliedConstAlphaBlend_ARGB8888(topPtr,\n                                            Pixel_8(191),\n                                            bottomPtr,\n                                            &destinationImageBuffer,\n                                            vImage_Flags(kvImageNoFlags))\n```\n\nThe following image shows the result of compositing with [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImagePremultipliedConstAlphaBlend_ARGB8888(_:_:_:_:_:)] using a constant alpha with a value of `191`. The background of the building remains transparent, but the parts of the image that were originally opaque now show some of the lower layer.\n\n\n\n### Perform an alpha composite with an overwritten alpha channel\n\nUse the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)] function to overwrite an image’s alpha channel. The following shows an example of setting a radial gradient as the alpha channel of an image to produce a vignette style blend:\n\n\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageOverwriteChannels_ARGB8888(_:_:_:_:_:)] function requires buffers with nonpremultiplied alpha.\n\nThe `radialComposite(topImage:bottomImage:)` function performs an alpha composite of two [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] instances with a procedural radial gradient.\n\n```swift\nfunc radialComposite(topImage: CGImage,\n                     bottomImage: CGImage) -> CGImage? {\n    \/\/ Create source and destination vImage buffers.\n    guard\n        let topImageBuffer = try? vImage_Buffer(cgImage: topImage),\n        let bottomImageBuffer = try? vImage_Buffer(cgImage: bottomImage),\n        var gradientImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,\n                                                     bitsPerPixel: 8),\n        var destinationImageBuffer = try? vImage_Buffer(size: topImageBuffer.size,\n                                                        bitsPerPixel: 8 * 4)\n    else {\n        return nil\n    }\n    \n    defer {\n        topImageBuffer.free()\n        bottomImageBuffer.free()\n        gradientImageBuffer.free()\n        destinationImageBuffer.free()\n    }\n    \n    withUnsafePointer(to: topImageBuffer) { topPtr in\n        withUnsafePointer(to: bottomImageBuffer) { bottomPtr in\n            \n            \/\/ Ensure the top image and the bottom image are ARGB.\n            convertToARGB(topPtr, alphaInfo: topImage.alphaInfo)\n            convertToARGB(bottomPtr, alphaInfo: bottomImage.alphaInfo)\n            \n            \/\/ Populate `gradientImageBuffer` with a radial gradient.\n            makeRadialGradient(&gradientImageBuffer)\n            \n            \/\/ Unpremultiply before overwriting, if required.\n            unpremultiply(topPtr, alphaInfo: topImage.alphaInfo)\n            \n            \/\/ Overwrite the top layers's alpha channel with the radial gradient.\n            vImageOverwriteChannels_ARGB8888(&gradientImageBuffer,\n                                             topPtr, topPtr,\n                                             0x8,\n                                             vImage_Flags(kvImageNoFlags))\n            \n            \/\/ Premultiply the top layer.\n            vImagePremultiplyData_ARGB8888(topPtr, topPtr,\n                                           vImage_Flags(kvImageNoFlags))\n            \n            \/\/ Perform the alpha blend of the top layer over the bottom layer.\n            vImagePremultipliedAlphaBlend_ARGB8888(topPtr,\n                                                   bottomPtr,\n                                                   &destinationImageBuffer,\n                                                   vImage_Flags(kvImageNoFlags))\n        }\n    }\n    \n    if let destinationFormat = vImage_CGImageFormat(\n        bitsPerComponent: 8,\n        bitsPerPixel: 8 * 4,\n        colorSpace: CGColorSpaceCreateDeviceRGB(),\n        bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.first.rawValue)) {\n        return try? destinationImageBuffer.createCGImage(format: destinationFormat)\n    }\n    return nil\n}\n```\n\nThe code calls `unpremultiply(_:alphaInfo:)` to unpremultiply an image if its alpha information indicates it contains premultiplied pixels.\n\n```swift\nfunc unpremultiply(_ buffer: UnsafePointer<vImage_Buffer>,\n                   alphaInfo: CGImageAlphaInfo) {\n    \n    let premultiplieds = [ CGImageAlphaInfo.premultipliedFirst,\n                           CGImageAlphaInfo.premultipliedLast ]\n    \n    if premultiplieds.contains(alphaInfo) {\n        vImageUnpremultiplyData_ARGB8888(buffer,\n                                         buffer,\n                                         vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\nThe `radialComposite(topImage:bottomImage:)` function calls `makeRadialGradient(_:)` to populate the gradient buffer with a radial gradient. The code generates the radial gradient by multiplying a `height * 1` matrix by a `1 * width` matrix. Both factors contain values that follow a bell-shaped curve.\n\n```swift\nfunc makeRadialGradient(_ destination: inout vImage_Buffer) {\n    let width = Int(destination.size.width)\n    let height = Int(destination.size.height)\n    \n    var gradientValues = [Float](unsafeUninitializedCapacity: width * height) {\n        buffer, initializedCount in\n        \n        let verticalWindow = vDSP.window(ofType: Float.self,\n                                         usingSequence: .hanningDenormalized,\n                                         count: height,\n                                         isHalfWindow: false)\n        \n        let horizontalWindow = vDSP.window(ofType: Float.self,\n                                           usingSequence: .hanningDenormalized,\n                                           count: width,\n                                           isHalfWindow: false)\n        \n        vDSP_mmul(verticalWindow, 1,\n                  horizontalWindow, 1,\n                  buffer.baseAddress!, 1,\n                  vDSP_Length(height),\n                  vDSP_Length(width), 1)\n        \n        initializedCount = width * height\n    }.map {\n        return Pixel_8($0 * Float(Pixel_8.max))\n    }\n    \n    gradientValues.withUnsafeMutableBufferPointer { gradientPtr in\n        let gradientBuffer = vImage_Buffer(data: gradientPtr.baseAddress,\n                                           height: vImagePixelCount(height),\n                                           width: vImagePixelCount(width),\n                                           rowBytes: width)\n        \n        try? gradientBuffer.copy(destinationBuffer: &destination,\n                                 pixelSize: 1)\n    }\n}\n```\n\n## Image Processing Essentials\n\n- **Converting bitmap data between Core Graphics images and vImage buffers**: Pass image data between Core Graphics and vImage to create and manipulate images.\n- **Creating and Populating Buffers from Core Graphics Images**: Initialize vImage buffers from Core Graphics images.\n- **Creating a Core Graphics Image from a vImage Buffer**: Create displayable representations of vImage buffers.\n- **Building a Basic Image-Processing Workflow**: Resize an image with vImage.\n- **Applying geometric transforms to images**: Reflect, shear, rotate, and scale image buffers using vImage.\n- **Compositing images with vImage blend modes**: Combine two images by using blend modes to create a single output.\n- **Applying vImage operations to regions of interest**: Limit the effect of vImage operations to rectangular regions of interest.\n- **Optimizing image-processing performance**: Improve your app’s performance by converting image buffer formats from interleaved to planar.\n- **vImage**: Manipulate large images using the CPU’s vector processor.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Pass image data between Core Graphics and vImage to create and manipulate images.",
          "name" : "Converting bitmap data between Core Graphics images and vImage buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/converting-bitmap-data-between-core-graphics-images-and-vimage-buffers"
        },
        {
          "description" : "Initialize vImage buffers from Core Graphics images.",
          "name" : "Creating and Populating Buffers from Core Graphics Images",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-and-populating-buffers-from-core-graphics-images"
        },
        {
          "description" : "Create displayable representations of vImage buffers.",
          "name" : "Creating a Core Graphics Image from a vImage Buffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-a-core-graphics-image-from-a-vimage-buffer"
        },
        {
          "description" : "Resize an image with vImage.",
          "name" : "Building a Basic Image-Processing Workflow",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/building-a-basic-image-processing-workflow"
        },
        {
          "description" : "Reflect, shear, rotate, and scale image buffers using vImage.",
          "name" : "Applying geometric transforms to images",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-geometric-transforms-to-images"
        },
        {
          "description" : "Combine two images by using blend modes to create a single output.",
          "name" : "Compositing images with vImage blend modes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compositing-images-with-vimage-blend-modes"
        },
        {
          "description" : "Limit the effect of vImage operations to rectangular regions of interest.",
          "name" : "Applying vImage operations to regions of interest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-vimage-operations-to-regions-of-interest"
        },
        {
          "description" : "Improve your app’s performance by converting image buffer formats from interleaved to planar.",
          "name" : "Optimizing image-processing performance",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/optimizing-image-processing-performance"
        },
        {
          "description" : "Manipulate large images using the CPU’s vector processor.",
          "name" : "vImage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vimage-library"
        }
      ],
      "title" : "Image Processing Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Compositing images with alpha blending",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compositing-images-with-alpha-blending"
}