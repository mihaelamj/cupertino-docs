{
  "abstract" : "Apply dithering to simulate colors that are unavailable in reduced bit depths.",
  "codeExamples" : [
    {
      "code" : "let sourceFormat = vImage_CGImageFormat(\n    bitsPerComponent: 8,\n    bitsPerPixel: 8,\n    colorSpace: CGColorSpaceCreateDeviceGray(),\n    bitmapInfo: .init(rawValue: CGImageAlphaInfo.none.rawValue))!\n\nlet destinationFormat = vImage_CGImageFormat(\n    bitsPerComponent: 1,\n    bitsPerPixel: 1,\n    colorSpace: CGColorSpaceCreateDeviceGray(),\n    bitmapInfo: .init(rawValue: CGImageAlphaInfo.none.rawValue))!",
      "language" : "swift"
    },
    {
      "code" : "sourceBuffer = try vImage_Buffer(\n    cgImage: sourceImage,\n    format: sourceFormat)\n\ndestinationBuffer = try vImage_Buffer(\n    size: sourceBuffer.size,\n    bitsPerPixel: destinationFormat.bitsPerPixel)",
      "language" : "swift"
    },
    {
      "code" : "enum DitheringType: String, CaseIterable {\n    case none = \"None\"\n    case orderedGaussian = \"Ordered Gaussian\"\n    case orderedUniform = \"Ordered Uniform\"\n    case floydSteinberg = \"Floyd Steinberg\"\n    case atkinson = \"Atkinson\"\n    \n    var dither: Int32 {\n        switch self {\n            case .none:\n                return Int32(kvImageConvert_DitherNone)\n            case .orderedGaussian:\n                return Int32(kvImageConvert_DitherOrdered | kvImageConvert_OrderedGaussianBlue)\n            case .orderedUniform:\n                return Int32(kvImageConvert_DitherOrdered | kvImageConvert_OrderedUniformBlue)\n            case .floydSteinberg:\n                return Int32(kvImageConvert_DitherFloydSteinberg)\n            case .atkinson:\n                return Int32(kvImageConvert_DitherAtkinson)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "withUnsafePointer(to: sourceBuffer) { src in\n    withUnsafePointer(to: destinationBuffer) { dest in\n        _ = vImageConvert_Planar8toPlanar1(\n            src, dest,\n            nil,\n            ditheringType.dither,\n            vImage_Flags(kvImageNoFlags))\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "7ecc2f1801868d5172d62eea07ca6951ec46ba5402c917f4b82861147d4571e0",
  "crawledAt" : "2025-12-02T15:27:58Z",
  "id" : "D56D948E-AEE9-43E0-9A22-13F9FB909841",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nWhen you convert images to lower bit depths, some colors may be unavailable in the destination bit depth. As a solution, the vImage library provides options to apply dithering, a process that uses a pattern of random pixels to simulate unavailable colors. For example, a mid-gray color from an 8-bit grayscale image that’s quantized to 1 bit returns data that contains 50% white pixels and 50% black pixels.\n\nThis sample code app converts an 8-bit grayscale image to a 1-bit dithered image and provides a user interface to select between different dithering types.\n\nThe example below shows an image with continuous tones (left) and the same image with dithering applied (right):\n\n\n\nBefore exploring the code, try building and running the app to familiarize yourself with the effect of the different dithering algorithms on the image.\n\n### Define the source and destination Core Graphics image formats\n\nThe sample code defines two [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGImageFormat] structures that represent the source and destination image formats. The `sourceFormat` structure is an 8-bit grayscale format that supports 256 levels of gray. The `destinationFormat` structure is a 1-bit format with pixels that are either black or white.\n\n### Allocate the source and destination image buffers\n\nThe code populates the contents of the source [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure with a grayscale version of the source image. Because the code passes a populated [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGImageFormat] structure to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer\/init(cgImage:format:flags:)] initializer, vImage converts the source image to an 8-bit grayscale format.\n\nThe call to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer\/init(size:bitsPerPixel:)] creates the destination buffer, which is the same size as the source buffer but with only 1 bit per pixel.\n\n### Create a dither-type enumeration\n\nTo support dither-type selection in the user interface, the sample code includes an enumeration that wraps the available vImage dithering algorithms.\n\nThe sample code app supports the following dithering types:\n\nThe vImage library also includes [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherOrderedReproducible], which returns the same result as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherOrdered] but uses the same offset into the blue noise for each call.\n\n### Apply dithering to the image\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConvert_Planar8toPlanar1(_:_:_:_:_:)] function converts the 8-bit grayscale to a 1-bit image using the dithering type that the user interface defines.\n\nOn return, the destination buffer contains the 1-bit dithered version of the source image.\n\nThe vImage library provides dithering options for many conversion functions, such as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConvert_ARGBFFFFtoARGB8888_dithered(_:_:_:_:_:_:_:)], which converts a 32-bit-per-pixel ARGB image to an 8-bit-per-pixel ARGB image. Refer to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/conversion] for more details.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/improving-the-quality-of-quantized-images-with-dithering\ncrawled: 2025-12-02T15:27:58Z\n---\n\n# Improving the quality of quantized images with dithering\n\n**Sample Code**\n\nApply dithering to simulate colors that are unavailable in reduced bit depths.\n\n## Overview\n\nWhen you convert images to lower bit depths, some colors may be unavailable in the destination bit depth. As a solution, the vImage library provides options to apply dithering, a process that uses a pattern of random pixels to simulate unavailable colors. For example, a mid-gray color from an 8-bit grayscale image that’s quantized to 1 bit returns data that contains 50% white pixels and 50% black pixels.\n\nThis sample code app converts an 8-bit grayscale image to a 1-bit dithered image and provides a user interface to select between different dithering types.\n\nThe example below shows an image with continuous tones (left) and the same image with dithering applied (right):\n\n\n\nBefore exploring the code, try building and running the app to familiarize yourself with the effect of the different dithering algorithms on the image.\n\n### Define the source and destination Core Graphics image formats\n\nThe sample code defines two [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGImageFormat] structures that represent the source and destination image formats. The `sourceFormat` structure is an 8-bit grayscale format that supports 256 levels of gray. The `destinationFormat` structure is a 1-bit format with pixels that are either black or white.\n\n```swift\nlet sourceFormat = vImage_CGImageFormat(\n    bitsPerComponent: 8,\n    bitsPerPixel: 8,\n    colorSpace: CGColorSpaceCreateDeviceGray(),\n    bitmapInfo: .init(rawValue: CGImageAlphaInfo.none.rawValue))!\n\nlet destinationFormat = vImage_CGImageFormat(\n    bitsPerComponent: 1,\n    bitsPerPixel: 1,\n    colorSpace: CGColorSpaceCreateDeviceGray(),\n    bitmapInfo: .init(rawValue: CGImageAlphaInfo.none.rawValue))!\n```\n\n### Allocate the source and destination image buffers\n\nThe code populates the contents of the source [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer] structure with a grayscale version of the source image. Because the code passes a populated [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_CGImageFormat] structure to the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer\/init(cgImage:format:flags:)] initializer, vImage converts the source image to an 8-bit grayscale format.\n\nThe call to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage_Buffer\/init(size:bitsPerPixel:)] creates the destination buffer, which is the same size as the source buffer but with only 1 bit per pixel.\n\n```swift\nsourceBuffer = try vImage_Buffer(\n    cgImage: sourceImage,\n    format: sourceFormat)\n\ndestinationBuffer = try vImage_Buffer(\n    size: sourceBuffer.size,\n    bitsPerPixel: destinationFormat.bitsPerPixel)\n```\n\n### Create a dither-type enumeration\n\nTo support dither-type selection in the user interface, the sample code includes an enumeration that wraps the available vImage dithering algorithms.\n\n```swift\nenum DitheringType: String, CaseIterable {\n    case none = \"None\"\n    case orderedGaussian = \"Ordered Gaussian\"\n    case orderedUniform = \"Ordered Uniform\"\n    case floydSteinberg = \"Floyd Steinberg\"\n    case atkinson = \"Atkinson\"\n    \n    var dither: Int32 {\n        switch self {\n            case .none:\n                return Int32(kvImageConvert_DitherNone)\n            case .orderedGaussian:\n                return Int32(kvImageConvert_DitherOrdered | kvImageConvert_OrderedGaussianBlue)\n            case .orderedUniform:\n                return Int32(kvImageConvert_DitherOrdered | kvImageConvert_OrderedUniformBlue)\n            case .floydSteinberg:\n                return Int32(kvImageConvert_DitherFloydSteinberg)\n            case .atkinson:\n                return Int32(kvImageConvert_DitherAtkinson)\n        }\n    }\n}\n```\n\nThe sample code app supports the following dithering types:\n\n- [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherNone]: Doesn’t apply any dithering. This algorithm rounds the input values to the nearest representable value in the destination format.\n- [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherOrdered]: Adds precomputed blue noise to the source image before it rounds the input values to the nearest representable value in the destination format. The vImage conversion functions support uniform and Gaussian noise by including [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_OrderedUniformBlue] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_OrderedGaussianBlue], respectively.\n- [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherFloydSteinberg]: Applies Floyd-Steinberg dithering to the image.\n- [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherAtkinson] Applies Atkinson dithering to the image.\n\nThe vImage library also includes [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherOrderedReproducible], which returns the same result as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/kvImageConvert_DitherOrdered] but uses the same offset into the blue noise for each call.\n\n### Apply dithering to the image\n\nThe [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConvert_Planar8toPlanar1(_:_:_:_:_:)] function converts the 8-bit grayscale to a 1-bit image using the dithering type that the user interface defines.\n\n```swift\nwithUnsafePointer(to: sourceBuffer) { src in\n    withUnsafePointer(to: destinationBuffer) { dest in\n        _ = vImageConvert_Planar8toPlanar1(\n            src, dest,\n            nil,\n            ditheringType.dither,\n            vImage_Flags(kvImageNoFlags))\n    }\n}\n```\n\nOn return, the destination buffer contains the 1-bit dithered version of the source image.\n\nThe vImage library provides dithering options for many conversion functions, such as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageConvert_ARGBFFFFtoARGB8888_dithered(_:_:_:_:_:_:_:)], which converts a 32-bit-per-pixel ARGB image to an 8-bit-per-pixel ARGB image. Refer to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/conversion] for more details.\n\n## Core Video Interoperation\n\n- **Using vImage pixel buffers to generate video effects**: Render real-time video effects with the vImage Pixel Buffer.\n- **Integrating vImage pixel buffers into a Core Image workflow**: Share image data between Core Video pixel buffers and vImage buffers to integrate vImage operations into a Core Image workflow.\n- **Applying vImage operations to video sample buffers**: Use the vImage convert-any-to-any functionality to perform real-time image processing of video frames streamed from your device’s camera.\n- **Core Video interoperability**: Pass image data between Core Video and vImage.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Render real-time video effects with the vImage Pixel Buffer.",
          "name" : "Using vImage pixel buffers to generate video effects",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-vimage-pixel-buffers-to-generate-video-effects"
        },
        {
          "description" : "Share image data between Core Video pixel buffers and vImage buffers to integrate vImage operations into a Core Image workflow.",
          "name" : "Integrating vImage pixel buffers into a Core Image workflow",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/integrating-vimage-pixel-buffers-into-a-core-image-workflow"
        },
        {
          "description" : "Use the vImage convert-any-to-any functionality to perform real-time image processing of video frames streamed from your device’s camera.",
          "name" : "Applying vImage operations to video sample buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-vimage-operations-to-video-sample-buffers"
        },
        {
          "description" : "Pass image data between Core Video and vImage.",
          "name" : "Core Video interoperability",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/core-video-interoperability"
        }
      ],
      "title" : "Core Video Interoperation"
    }
  ],
  "source" : "appleJSON",
  "title" : "Improving the quality of quantized images with dithering",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/improving-the-quality-of-quantized-images-with-dithering"
}