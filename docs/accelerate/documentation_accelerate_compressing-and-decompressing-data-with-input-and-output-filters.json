{
  "abstract" : "Compress and decompress streamed or from-memory data, using input and output filters.",
  "codeExamples" : [
    {
      "code" : "let sourceData = \"\"\"\n    Lorem ipsum dolor sit amet consectetur adipiscing elit mi\n    nibh ornare proin blandit diam ridiculus, faucibus mus\n    dui eu vehicula nam donec dictumst sed vivamus bibendum\n    aliquet efficitur. Felis imperdiet sodales dictum morbi\n    vivamus augue dis duis aliquet velit ullamcorper porttitor,\n    lobortis dapibus hac purus aliquam natoque iaculis blandit\n    montes nunc pretium.\n    \"\"\".data(using: .utf8)!",
      "language" : "swift"
    },
    {
      "code" : "let pageSize = 128",
      "language" : "swift"
    },
    {
      "code" : "var compressedData = Data()",
      "language" : "swift"
    },
    {
      "code" : "let outputFilter: OutputFilter\ndo {\n    outputFilter = try OutputFilter(.compress,\n                                    using: .lzfse) {\n        (data: Data?) -> Void in\n        \n        if let data = data {\n            compressedData.append(data)\n        }\n    }\n} catch {\n    fatalError(\"Error occurred creating output filter: \\(error.localizedDescription).\")\n}",
      "language" : "swift"
    },
    {
      "code" : "do {\n    var index = 0\n    let bufferSize = sourceData.count\n    \n    while true {\n        let rangeLength = min(pageSize, bufferSize - index)\n        \n        let subdata = sourceData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        \n        try outputFilter.write(subdata)\n        \n        if (rangeLength == 0) {\n            break\n        }\n    }\n} catch {\n    fatalError(\"Error occurred during encoding: \\(error.localizedDescription).\")\n}",
      "language" : "swift"
    },
    {
      "code" : "var decompressedData = Data()",
      "language" : "swift"
    },
    {
      "code" : "let inputFilter: InputFilter<Data>\ndo {\n    var index = 0\n    let bufferSize = compressedData.count\n    \n    inputFilter = try InputFilter(.decompress,\n                                  using: .lzfse) { (length: Int) -> Data? in\n        let rangeLength = min(length, bufferSize - index)\n        let subdata = compressedData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        \n        return subdata\n    }\n} catch {\n    fatalError(\"Error occurred creating input filter: \\(error.localizedDescription).\")\n}",
      "language" : "swift"
    },
    {
      "code" : "do {\n    while let page = try inputFilter.readData(ofLength: pageSize) {\n        decompressedData.append(page)\n    }\n} catch {\n    fatalError(\"Error occurred during decoding: \\(error.localizedDescription).\")\n}",
      "language" : "swift"
    },
    {
      "code" : "let decompressedString = String(data: decompressedData,\n                                encoding: .utf8)",
      "language" : "swift"
    },
    {
      "code" : "var compressedData = Data()\n\ndo {\n    var index = 0\n    let bufferSize = sourceData.count\n    \n    let inputFilter = try InputFilter(.compress,\n                                      using: .lzfse) { (length: Int) -> Data? in\n        let rangeLength = min(length, bufferSize - index)\n        let subdata = sourceData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        \n        return subdata\n    }\n    \n    while let page = try inputFilter.readData(ofLength: pageSize) {\n        compressedData.append(page)\n    }\n} catch {\n    fatalError(\"Error occurred during encoding: \\(error.localizedDescription).\")\n}",
      "language" : "swift"
    },
    {
      "code" : "var decompressedData = Data()\n\ndo {\n    let outputFilter = try OutputFilter(.decompress,\n                                        using: .lzfse) {(data: Data?) -> Void in\n                                            if let data = data {\n                                                decompressedData.append(data)\n                                            }\n    }\n\n    var index = 0\n    let bufferSize = compressedData.count\n    \n    while true {\n        let rangeLength = min(pageSize, bufferSize - index)\n        \n        let subdata = compressedData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        try outputFilter.write(subdata)\n        if (rangeLength == 0) {\n            break\n        }\n    }\n} catch {\n    fatalError(\"Error occurred during decoding: \\(error.localizedDescription).\")\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "1a1d90a57a9d8d9150b1dd8c262f5d0b790932589f5a8b2e5e3187ef88a95847",
  "crawledAt" : "2025-12-02T15:55:09Z",
  "id" : "D7B47A52-BF9E-4DF2-8634-7E86E85C7400",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nThe code in this article uses the [doc:\/\/com.apple.documentation\/documentation\/Compression] framework’s [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] and [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] classes to encode (compress) and decode (decompress) a string. The code writes the encoded result to a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] structure.\n\nThe code in this sample is useful in applications that store or transmit files, such as PDF or text, where saving or sending smaller files can improve performance and reduce storage overhead. This sample app implements *stream compression*, where it reads chunks of data from a source buffer repeatedly to compress or decompress data, and appends each chunk to a destination buffer.\n\nUse the input and output filters API when working with data that’s streamed to or from memory — for example, when reading from or writing to a file. If you’re compressing and decompressing data that’s held entirely in memory, consider using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSData\/compressed(using:)] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSData\/decompressed(using:)]. These functions provide a simple API to compress and decompress data in a single step.\n\n### Create the source data\n\nTypically, your app dynamically generates the source data that it compresses, but for this example, the source data is a hard-coded string.\n\nOn return, `sourceData` contains the UTF-8 representation of the source string.\n\n### Specify the page size\n\n[doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] and [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instances compress and decompress pages of data. Specify the number of bytes in each page to read from or write to a stream. Smaller values allow your app to report progress or perform other tasks at higher frequencies than larger values. However, larger values allow your app to compress or decompress using fewer steps, possibly in less time.\n\nFor this example, use a page size of 128 bytes:\n\n### Create the compression destination buffer\n\nCreate an empty mutable [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] structure to receive the compressed data.\n\n### Create the output filter\n\nCreate an [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instance, and specify the operation as [doc:\/\/com.apple.documentation\/documentation\/Compression\/FilterOperation\/compress] and the compression algorithm as [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/lzfse]. For more information on other compression algorithms, see [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_algorithm].\n\nThe final initializer parameter is a closure that the instance calls as it writes each compressed block of data to `compressedData`.\n\n### Compress the data\n\nIterate over the source data and call the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data\/subdata(in:)] method to copy `pageSize` chunks to `subdata`. The [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter\/write(_:)] method compresses each chunk and uses the closure specified in the [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] initializer to write the result to `compressedData`.\n\nOn return, `compressedData` contains a compressed version of the original source data.\n\n### Create the decompression destination buffer\n\nCreate a mutable, empty [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] structure to receive the decompressed data.\n\n### Create the input filter\n\nCreate an [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] instance, and specify the operation as [doc:\/\/com.apple.documentation\/documentation\/Compression\/FilterOperation\/decompress] and the compression algorithm as [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/lzfse].\n\nThe final initializer parameter is a closure the instance calls as it reads each compressed block of data.\n\n### Decompress the data\n\nYou iterate over the compressed data by repeatedly calling [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter\/readData(ofLength:)], until the function returns nil. With each iteration, append the data returned by the input filter to `decompressedData`.\n\n### Create a string from the decompressed data\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Swift\/String\/init(data:encoding:)] to recreate a string from the decompressed data.\n\nOn return, `decompressedString` contains the original text shown in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/compressing-and-decompressing-data-with-input-and-output-filters#Create-the-source-data].\n\n### Select input and output filters based on requirements\n\nYou’re not tied to using output filters for compression and input filters for decompression. You can select the appropriate compressor-decompressor based on your app’s requirements.\n\nFor example, the code below shows an [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] instance as the compressor:\n\nThe code below shows an [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instance as the decompressor:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-input-and-output-filters\ncrawled: 2025-12-02T15:55:09Z\n---\n\n# Compressing and decompressing data with input and output filters\n\n**Article**\n\nCompress and decompress streamed or from-memory data, using input and output filters.\n\n## Overview\n\nThe code in this article uses the [doc:\/\/com.apple.documentation\/documentation\/Compression] framework’s [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] and [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] classes to encode (compress) and decode (decompress) a string. The code writes the encoded result to a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] structure.\n\nThe code in this sample is useful in applications that store or transmit files, such as PDF or text, where saving or sending smaller files can improve performance and reduce storage overhead. This sample app implements *stream compression*, where it reads chunks of data from a source buffer repeatedly to compress or decompress data, and appends each chunk to a destination buffer.\n\nUse the input and output filters API when working with data that’s streamed to or from memory — for example, when reading from or writing to a file. If you’re compressing and decompressing data that’s held entirely in memory, consider using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSData\/compressed(using:)] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSData\/decompressed(using:)]. These functions provide a simple API to compress and decompress data in a single step.\n\n### Create the source data\n\nTypically, your app dynamically generates the source data that it compresses, but for this example, the source data is a hard-coded string.\n\n```swift\nlet sourceData = \"\"\"\n    Lorem ipsum dolor sit amet consectetur adipiscing elit mi\n    nibh ornare proin blandit diam ridiculus, faucibus mus\n    dui eu vehicula nam donec dictumst sed vivamus bibendum\n    aliquet efficitur. Felis imperdiet sodales dictum morbi\n    vivamus augue dis duis aliquet velit ullamcorper porttitor,\n    lobortis dapibus hac purus aliquam natoque iaculis blandit\n    montes nunc pretium.\n    \"\"\".data(using: .utf8)!\n```\n\nOn return, `sourceData` contains the UTF-8 representation of the source string.\n\n### Specify the page size\n\n[doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] and [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instances compress and decompress pages of data. Specify the number of bytes in each page to read from or write to a stream. Smaller values allow your app to report progress or perform other tasks at higher frequencies than larger values. However, larger values allow your app to compress or decompress using fewer steps, possibly in less time.\n\nFor this example, use a page size of 128 bytes:\n\n```swift\nlet pageSize = 128\n```\n\n### Create the compression destination buffer\n\nCreate an empty mutable [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] structure to receive the compressed data.\n\n```swift\nvar compressedData = Data()\n```\n\n### Create the output filter\n\nCreate an [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instance, and specify the operation as [doc:\/\/com.apple.documentation\/documentation\/Compression\/FilterOperation\/compress] and the compression algorithm as [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/lzfse]. For more information on other compression algorithms, see [doc:\/\/com.apple.documentation\/documentation\/Compression\/compression_algorithm].\n\nThe final initializer parameter is a closure that the instance calls as it writes each compressed block of data to `compressedData`.\n\n```swift\nlet outputFilter: OutputFilter\ndo {\n    outputFilter = try OutputFilter(.compress,\n                                    using: .lzfse) {\n        (data: Data?) -> Void in\n        \n        if let data = data {\n            compressedData.append(data)\n        }\n    }\n} catch {\n    fatalError(\"Error occurred creating output filter: \\(error.localizedDescription).\")\n}\n```\n\n### Compress the data\n\nIterate over the source data and call the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data\/subdata(in:)] method to copy `pageSize` chunks to `subdata`. The [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter\/write(_:)] method compresses each chunk and uses the closure specified in the [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] initializer to write the result to `compressedData`.\n\n```swift\ndo {\n    var index = 0\n    let bufferSize = sourceData.count\n    \n    while true {\n        let rangeLength = min(pageSize, bufferSize - index)\n        \n        let subdata = sourceData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        \n        try outputFilter.write(subdata)\n        \n        if (rangeLength == 0) {\n            break\n        }\n    }\n} catch {\n    fatalError(\"Error occurred during encoding: \\(error.localizedDescription).\")\n}\n```\n\nOn return, `compressedData` contains a compressed version of the original source data.\n\n### Create the decompression destination buffer\n\nCreate a mutable, empty [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] structure to receive the decompressed data.\n\n```swift\nvar decompressedData = Data()\n```\n\n### Create the input filter\n\nCreate an [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] instance, and specify the operation as [doc:\/\/com.apple.documentation\/documentation\/Compression\/FilterOperation\/decompress] and the compression algorithm as [doc:\/\/com.apple.documentation\/documentation\/Compression\/Algorithm\/lzfse].\n\nThe final initializer parameter is a closure the instance calls as it reads each compressed block of data.\n\n```swift\nlet inputFilter: InputFilter<Data>\ndo {\n    var index = 0\n    let bufferSize = compressedData.count\n    \n    inputFilter = try InputFilter(.decompress,\n                                  using: .lzfse) { (length: Int) -> Data? in\n        let rangeLength = min(length, bufferSize - index)\n        let subdata = compressedData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        \n        return subdata\n    }\n} catch {\n    fatalError(\"Error occurred creating input filter: \\(error.localizedDescription).\")\n}\n```\n\n### Decompress the data\n\nYou iterate over the compressed data by repeatedly calling [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter\/readData(ofLength:)], until the function returns nil. With each iteration, append the data returned by the input filter to `decompressedData`.\n\n```swift\ndo {\n    while let page = try inputFilter.readData(ofLength: pageSize) {\n        decompressedData.append(page)\n    }\n} catch {\n    fatalError(\"Error occurred during decoding: \\(error.localizedDescription).\")\n}\n```\n\n### Create a string from the decompressed data\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Swift\/String\/init(data:encoding:)] to recreate a string from the decompressed data.\n\n```swift\nlet decompressedString = String(data: decompressedData,\n                                encoding: .utf8)\n```\n\nOn return, `decompressedString` contains the original text shown in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/compressing-and-decompressing-data-with-input-and-output-filters#Create-the-source-data].\n\n### Select input and output filters based on requirements\n\nYou’re not tied to using output filters for compression and input filters for decompression. You can select the appropriate compressor-decompressor based on your app’s requirements.\n\nFor example, the code below shows an [doc:\/\/com.apple.documentation\/documentation\/Compression\/InputFilter] instance as the compressor:\n\n```swift\nvar compressedData = Data()\n\ndo {\n    var index = 0\n    let bufferSize = sourceData.count\n    \n    let inputFilter = try InputFilter(.compress,\n                                      using: .lzfse) { (length: Int) -> Data? in\n        let rangeLength = min(length, bufferSize - index)\n        let subdata = sourceData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        \n        return subdata\n    }\n    \n    while let page = try inputFilter.readData(ofLength: pageSize) {\n        compressedData.append(page)\n    }\n} catch {\n    fatalError(\"Error occurred during encoding: \\(error.localizedDescription).\")\n}\n```\n\nThe code below shows an [doc:\/\/com.apple.documentation\/documentation\/Compression\/OutputFilter] instance as the decompressor:\n\n```swift\nvar decompressedData = Data()\n\ndo {\n    let outputFilter = try OutputFilter(.decompress,\n                                        using: .lzfse) {(data: Data?) -> Void in\n                                            if let data = data {\n                                                decompressedData.append(data)\n                                            }\n    }\n\n    var index = 0\n    let bufferSize = compressedData.count\n    \n    while true {\n        let rangeLength = min(pageSize, bufferSize - index)\n        \n        let subdata = compressedData.subdata(in: index ..< index + rangeLength)\n        index += rangeLength\n        try outputFilter.write(subdata)\n        if (rangeLength == 0) {\n            break\n        }\n    }\n} catch {\n    fatalError(\"Error occurred during decoding: \\(error.localizedDescription).\")\n}\n```\n\n## Compression\n\n- **Compressing and decompressing files with stream compression**: Perform compression for all files and decompression for files with supported extension types.\n- **Compressing and decompressing data with buffer compression**: Compress a string, write it to the file system, and decompress the same file using buffer compression.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Perform compression for all files and decompression for files with supported extension types.",
          "name" : "Compressing and decompressing files with stream compression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-files-with-stream-compression"
        },
        {
          "description" : "Compress a string, write it to the file system, and decompress the same file using buffer compression.",
          "name" : "Compressing and decompressing data with buffer compression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-buffer-compression"
        }
      ],
      "title" : "Compression"
    }
  ],
  "source" : "appleJSON",
  "title" : "Compressing and decompressing data with input and output filters",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/compressing-and-decompressing-data-with-input-and-output-filters"
}