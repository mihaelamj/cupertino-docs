{
  "abstract" : "Operate selectively on the elements of a vector at regular intervals.",
  "codeExamples" : [
    {
      "code" : "let strideA = vDSP_Stride(1)\nlet strideB = vDSP_Stride(1)\nlet strideC = vDSP_Stride(1)\n\nlet a: [Float] = [10, 20, 30, 40, 50, 60, 70, 80]\nlet b: [Float] = [ 1,  2,  3,  4,  5,  6,  7,  8]\n\nlet n = vDSP_Length(a.count)\n\nvar c = [Float](repeating: .nan,\n                count: a.count)\n\nvDSP_vadd(a, strideA,\n          b, strideB,\n          &c, strideC,\n          n)",
      "language" : "swift"
    },
    {
      "code" : "let strideA = vDSP_Stride(1)\nlet strideB = vDSP_Stride(3)\nlet strideC = vDSP_Stride(1)\n...\nlet n = vDSP_Length(3)",
      "language" : "swift"
    },
    {
      "code" : "let strideA = vDSP_Stride(2)\nlet strideB = vDSP_Stride(1)\nlet strideC = vDSP_Stride(3)\n...\nlet n = vDSP_Length(3)",
      "language" : "swift"
    },
    {
      "code" : "let strideA = vDSP_Stride(-1)\nlet strideB = vDSP_Stride(1)\nlet strideC = vDSP_Stride(1)\n...\na.withUnsafeBufferPointer { buffer in\n    vDSP_vadd(buffer.baseAddress!.advanced(by: buffer.count - 1), strideA,\n              b, strideB,\n              &c, strideC,\n              n)\n}",
      "language" : "swift"
    },
    {
      "code" : "var real: [Float] = [10, 20, 30, 40, 50, 60, 70, 80]\nvar imag: [Float] = [ 1,  2,  3,  4,  5,  6,  7,  8]\n\nlet n = real.count\n\nvar complex = [DSPComplex](repeating: DSPComplex(),\n                           count: n)\n\nreal.withUnsafeMutableBufferPointer { realPtr in\n    imag.withUnsafeMutableBufferPointer { imagPtr in\n        \n        var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                           imagp: imagPtr.baseAddress!)\n        \n        let strideSplitComplex = vDSP_Stride(1)\n        let strideComplex = vDSP_Stride(2)\n        \n        vDSP_ztoc(&splitComplex, strideSplitComplex,\n                  &complex, strideComplex,\n                  vDSP_Length(n))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : " vDSP_ctoz(&complex, strideComplex,\n           &splitComplex, strideSplitComplex,\n           vDSP_Length(n))",
      "language" : "swift"
    }
  ],
  "contentHash" : "026dd5a49e92d9c1051db41bbdd8a4b6c51e7dd2798b0b35ae4d8cef9a954373",
  "crawledAt" : "2025-12-02T15:37:13Z",
  "id" : "5E3209E0-09EC-4AAD-B746-BD331AFEF858",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nMany functions in vDSP provide support for specifying a *stride* (that is, the distance between the elements that functions read from or write to) for a particular vector. For example, if you want to access consecutive elements, use a stride of `1` (referred to as a *unit stride*). If you want to access every third element, for example to work with the red channel in interleaved RGB data, use a stride of `3`. If you want to access every second element, for example to work with a single audio channel in interleaved stereo audio data, use a stride of `2`.\n\nTypically, you use a unit stride. Use other strides to, for example, operate along a column of a matrix, where the stride is the number of elements per row.\n\n### Use a unit stride for the best performance and energy efficiency\n\nFor most of the functions in vDSP, you obtain the best performance when the stride is `1`. Any other stride value generally prevents the use of vectorized code, and reduces both performance and energy efficiency.\n\nThe major exception to this limitation is in functions that support the use of interleaved complex data, such as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ztoc]. In these cases, use a stride of `2`.\n\n### Set the stride for each vector independently\n\nThe code below calls the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vadd] function to add each element in array `a` to the corresponding element in array `b`, and write the result to array `c`. Note that the stride used for each array is `1`.\n\nIn this example, the result is `[11.0, 22.0, 33.0, 44.0, 55.0, 66.0, 77.0, 88.0]`.\n\n\n\n### Use a nonunit stride on inputs\n\nA nonunit stride allows you to, for example, access a particular color channel in interleaved RGB data. If you change `strideB` to 3, the operation adds the first, fourth, and seventh items in array `b` to the first, second, and third items in array `a`.\n\n\n\nNote that vDSP operations always read `n` elements. Therefore, your collections require at least `((n - 1) * stride) + 1` elements.\n\n### Use a nonunit stride on output\n\nIf you change array `c`’s stride to `3`, the calculation writes the result to its first, fourth, and seventh items. Using the example of interleaved RGB data discussed in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/controlling-vdsp-operations-with-stride#Use-a-nonunit-stride-on-inputs], this approach would write the result of an operation to the red channel. The example below defines the stride for the input array, `a`, as `2`, so the operation uses the first, third, and fifth elements:\n\n\n\n### Use a negative stride\n\nUse a negative stride to access a vector in reverse order, for example, define the stride as `−1` when convolving with a filter using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_conv]).\n\nTo use a negative stride, pass the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vadd] function a pointer to the address of the last element in the array. The example below shows the Swift code required to reverse the elements in array `a`:\n\nThe result of adding `a` and `b` with a stride of `-1` for `a` is `[81.0, 72.0, 63.0, 54.0, 45.0, 36.0, 27.0, 18.0]`:\n\n\n\n### Controlling vDSP operations with strides\n\nWith interleaved complex data, vDSP stores alternating real and imaginary components consecutively. Use a stride of `2` for interleaved complex data, counting the individual component elements rather than counting complex numbers.\n\nFor example, use the code below to copy the contents of a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure to an array of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPComplex] values:\n\nOn return, `complex` contains the pairs `[10.0 1.0], [20.0 2.0], [30.0 3.0] ... [80.0 8.0]`.\n\nConversely, use the example below to copy the values of an array of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPComplex] values to a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/controlling-vdsp-operations-with-stride\ncrawled: 2025-12-02T15:37:13Z\n---\n\n# Controlling vDSP operations with stride\n\n**Article**\n\nOperate selectively on the elements of a vector at regular intervals.\n\n## Overview\n\nMany functions in vDSP provide support for specifying a *stride* (that is, the distance between the elements that functions read from or write to) for a particular vector. For example, if you want to access consecutive elements, use a stride of `1` (referred to as a *unit stride*). If you want to access every third element, for example to work with the red channel in interleaved RGB data, use a stride of `3`. If you want to access every second element, for example to work with a single audio channel in interleaved stereo audio data, use a stride of `2`.\n\nTypically, you use a unit stride. Use other strides to, for example, operate along a column of a matrix, where the stride is the number of elements per row.\n\n### Use a unit stride for the best performance and energy efficiency\n\nFor most of the functions in vDSP, you obtain the best performance when the stride is `1`. Any other stride value generally prevents the use of vectorized code, and reduces both performance and energy efficiency.\n\nThe major exception to this limitation is in functions that support the use of interleaved complex data, such as [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ctoz] and [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_ztoc]. In these cases, use a stride of `2`.\n\n### Set the stride for each vector independently\n\nThe code below calls the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vadd] function to add each element in array `a` to the corresponding element in array `b`, and write the result to array `c`. Note that the stride used for each array is `1`.\n\n```swift\nlet strideA = vDSP_Stride(1)\nlet strideB = vDSP_Stride(1)\nlet strideC = vDSP_Stride(1)\n\nlet a: [Float] = [10, 20, 30, 40, 50, 60, 70, 80]\nlet b: [Float] = [ 1,  2,  3,  4,  5,  6,  7,  8]\n\nlet n = vDSP_Length(a.count)\n\nvar c = [Float](repeating: .nan,\n                count: a.count)\n\nvDSP_vadd(a, strideA,\n          b, strideB,\n          &c, strideC,\n          n)\n```\n\nIn this example, the result is `[11.0, 22.0, 33.0, 44.0, 55.0, 66.0, 77.0, 88.0]`.\n\n\n\n### Use a nonunit stride on inputs\n\nA nonunit stride allows you to, for example, access a particular color channel in interleaved RGB data. If you change `strideB` to 3, the operation adds the first, fourth, and seventh items in array `b` to the first, second, and third items in array `a`.\n\n```swift\nlet strideA = vDSP_Stride(1)\nlet strideB = vDSP_Stride(3)\nlet strideC = vDSP_Stride(1)\n...\nlet n = vDSP_Length(3)\n```\n\n\n\nNote that vDSP operations always read `n` elements. Therefore, your collections require at least `((n - 1) * stride) + 1` elements.\n\n### Use a nonunit stride on output\n\nIf you change array `c`’s stride to `3`, the calculation writes the result to its first, fourth, and seventh items. Using the example of interleaved RGB data discussed in [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/controlling-vdsp-operations-with-stride#Use-a-nonunit-stride-on-inputs], this approach would write the result of an operation to the red channel. The example below defines the stride for the input array, `a`, as `2`, so the operation uses the first, third, and fifth elements:\n\n```swift\nlet strideA = vDSP_Stride(2)\nlet strideB = vDSP_Stride(1)\nlet strideC = vDSP_Stride(3)\n...\nlet n = vDSP_Length(3)\n```\n\n\n\n### Use a negative stride\n\nUse a negative stride to access a vector in reverse order, for example, define the stride as `−1` when convolving with a filter using [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_conv]).\n\nTo use a negative stride, pass the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_vadd] function a pointer to the address of the last element in the array. The example below shows the Swift code required to reverse the elements in array `a`:\n\n```swift\nlet strideA = vDSP_Stride(-1)\nlet strideB = vDSP_Stride(1)\nlet strideC = vDSP_Stride(1)\n...\na.withUnsafeBufferPointer { buffer in\n    vDSP_vadd(buffer.baseAddress!.advanced(by: buffer.count - 1), strideA,\n              b, strideB,\n              &c, strideC,\n              n)\n}\n```\n\nThe result of adding `a` and `b` with a stride of `-1` for `a` is `[81.0, 72.0, 63.0, 54.0, 45.0, 36.0, 27.0, 18.0]`:\n\n\n\n### Controlling vDSP operations with strides\n\nWith interleaved complex data, vDSP stores alternating real and imaginary components consecutively. Use a stride of `2` for interleaved complex data, counting the individual component elements rather than counting complex numbers.\n\nFor example, use the code below to copy the contents of a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure to an array of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPComplex] values:\n\n```swift\nvar real: [Float] = [10, 20, 30, 40, 50, 60, 70, 80]\nvar imag: [Float] = [ 1,  2,  3,  4,  5,  6,  7,  8]\n\nlet n = real.count\n\nvar complex = [DSPComplex](repeating: DSPComplex(),\n                           count: n)\n\nreal.withUnsafeMutableBufferPointer { realPtr in\n    imag.withUnsafeMutableBufferPointer { imagPtr in\n        \n        var splitComplex = DSPSplitComplex(realp: realPtr.baseAddress!,\n                                           imagp: imagPtr.baseAddress!)\n        \n        let strideSplitComplex = vDSP_Stride(1)\n        let strideComplex = vDSP_Stride(2)\n        \n        vDSP_ztoc(&splitComplex, strideSplitComplex,\n                  &complex, strideComplex,\n                  vDSP_Length(n))\n    }\n}\n```\n\nOn return, `complex` contains the pairs `[10.0 1.0], [20.0 2.0], [30.0 3.0] ... [80.0 8.0]`.\n\nConversely, use the example below to copy the values of an array of [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPComplex] values to a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure:\n\n```swift\n vDSP_ctoz(&complex, strideComplex,\n           &splitComplex, strideSplitComplex,\n           vDSP_Length(n))\n```\n\n## Signal Processing Essentials\n\n- **Using linear interpolation to construct new data points**: Fill the gaps in arrays of numerical data using linear interpolation.\n- **Using vDSP for vector-based arithmetic**: Increase the performance of common mathematical tasks with vDSP vector-vector and vector-scalar operations.\n- **Resampling a signal with decimation**: Reduce the sample rate of a signal by specifying a decimation factor and applying a custom antialiasing filter.\n- **vDSP**: Perform basic arithmetic operations and common digital signal processing (DSP) routines on large vectors.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Fill the gaps in arrays of numerical data using linear interpolation.",
          "name" : "Using linear interpolation to construct new data points",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-linear-interpolation-to-construct-new-data-points"
        },
        {
          "description" : "Increase the performance of common mathematical tasks with vDSP vector-vector and vector-scalar operations.",
          "name" : "Using vDSP for vector-based arithmetic",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/using-vdsp-for-vector-based-arithmetic"
        },
        {
          "description" : "Reduce the sample rate of a signal by specifying a decimation factor and applying a custom antialiasing filter.",
          "name" : "Resampling a signal with decimation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/resampling-a-signal-with-decimation"
        },
        {
          "description" : "Perform basic arithmetic operations and common digital signal processing (DSP) routines on large vectors.",
          "name" : "vDSP",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/vdsp-library"
        }
      ],
      "title" : "Signal Processing Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Controlling vDSP operations with stride",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/controlling-vdsp-operations-with-stride"
}