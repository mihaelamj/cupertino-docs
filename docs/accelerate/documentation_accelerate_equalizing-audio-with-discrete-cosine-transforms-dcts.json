{
  "abstract" : "Change the frequency response of an audio signal by manipulating frequency-domain data.",
  "codeExamples" : [
    {
      "code" : "guard let samples = try await AudioUtilities.getAudioSamples(\n    forResource: \"Rhythm\",\n    withExtension: \"aif\") else {\n    fatalError(\"Unable to parse the audio resource.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "try? await drumLoopProvider.loadAudioSamples()\ntry? SignalGenerator(signalProvider: drumLoopProvider).start()",
      "language" : "swift"
    },
    {
      "code" : "let start = pageNumber * Self.sampleCount\nlet end = (pageNumber + 1) * Self.sampleCount\n\nlet page = Array(samples[start ..< end])\n\npageNumber += 1\n\nif (pageNumber + 1) * Self.sampleCount >= samples.count {\n    pageNumber = 0\n}",
      "language" : "swift"
    },
    {
      "code" : "let start = Float(startFrequency)\nlet end = Float(endFrequency)\n\nlet indices = [0, start - 2, start, end, end + 2, 1024]\nlet magnitudes: [Float]\n\nswitch mode {\n    case .bandPass:\n        magnitudes = [0, 0, 1, 1, 0, 0]\n    case .bandStop:\n        magnitudes = [1, 1, 0, 0, 1, 1]\n}\n\nenvelope = [Float](unsafeUninitializedCapacity: DrumLoopProvider.sampleCount) {\n    buffer, initializedCount in\n    \n    vDSP.linearInterpolate(values: magnitudes,\n                           atIndices: indices,\n                           result: &buffer)\n    \n    initializedCount = DrumLoopProvider.sampleCount\n}",
      "language" : "swift"
    },
    {
      "code" : "static let forwardDCT = vDSP.DCT(count: sampleCount,\n                                 transformType: .II)!",
      "language" : "swift"
    },
    {
      "code" : "static let inverseDCT = vDSP.DCT(count: sampleCount,\n                                 transformType: .III)!",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Perform forward DCT.\nforwardDCT.transform(source,\n                     result: &frequencyDomainDestination)\n\/\/ Multiply frequency-domain data by `dctMultiplier`.\nvDSP.multiply(dctMultiplier,\n              frequencyDomainDestination,\n              result: &frequencyDomainDestination)\n\n\/\/ Perform inverse DCT.\ninverseDCT.transform(frequencyDomainDestination,\n                     result: &timeDomainDestination)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ In-place scale inverse DCT result by n \/ 2.\n\/\/ Output samples are now in range -1...+1.\nvDSP.divide(timeDomainDestination,\n            Float(DrumLoopProvider.sampleCount \/ 2),\n            result: &timeDomainDestination)",
      "language" : "swift"
    }
  ],
  "contentHash" : "cf4b92ecf5c6bb73792b6f441e0452c8f4b3aa8f7fe4eae16bed1bf90c2049fe",
  "crawledAt" : "2025-12-02T15:27:56Z",
  "id" : "F17F88F6-B3A8-4C8B-8A0B-02089EC524E0",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nYou can use vDSP functions to shape the output of an audio signal; for example, boosting or cutting the bass or treble of a music track.\n\nThis sample app plays a drum loop and allows the user to eliminate frequencies that are either inside or outside a range that two [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Slider] controls define.\n\nBy performing a forward DCT on the drum loop data and zeroing out parts of the audio spectrum, the sample app applies a band-pass or band-stop filter to the audio.\n\nWhen you first launch the app, the drum loop plays with a band-pass filter that eliminates very low and very high frequencies. The user interface displays the frequency-domain representation of the equalized drum loop and the shape of the envelope that defines the frequency response.\n\n\n\nBefore exploring the code, try building and running the app to familiarize yourself with the effect of the different equalizations on the drum loop.\n\nvDSP also provides biquadratic filters that offer an alternative approach for equalizing audio. To learn more about biquadratic filters, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/applying-biquadratic-filters-to-a-music-loop].\n\n### Generate the audio samples\n\nThis sample includes an audio resource, `Rhythm.aif`, that contains a drum loop. The `getAudioSamples(forResource:withExtension:)` function generates an array of single-precision values from the drum loop.\n\nThe `samples` array contains single-precision values that represent the entire content of `Rhythm.aif`. To learn more about the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation] classes that generate the samples, see [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVAssetReader] and [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVAssetReaderTrackOutput].\n\n### Configure audio playback\n\nThe `DrumLoopProvider` class conforms to the `SignalProvider` protocol and vends an array of single-precision values that represent audio data. The `AudioEqualizationApp` application file creates an instance of `SignalGenerator` and specifies an instance of `DrumLoopProvider` as the signal provider. It also specifies the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPartialAsyncProperty\/naturalTimeScale] of the audio asset as the sample rate.\n\nThe `SignalGenerator.start()` function starts the signal generator.\n\nOn return, the signal generator repeatedly calls the `getSignal()` function and renders the returned data as audio. Each call returns a page of length `sampleCount`  from `samples`.\n\nThe sample can render the audio unaltered by returning `page`.\n\nTo learn more about using [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioEngine] to render audio, see [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/building-a-signal-generator].\n\n### Define the DCT-based equalization filter\n\nThe sample app builds the envelope array — that controls which parts of the drum loop’s spectrum it zeroes — from variables that define the start and end frequencies, and a value that specifies either band pass or band stop.\n\nThe following image visualizes the effect of audio equalization that blocks most of the spectrum except low frequencies. The solid, blue line represents the frequency-domain audio data, and the dashed red line represents the values in the band-stop filter.\n\n\n\n### Prepare the DCT setups\n\nThe following code creates setup objects that contain all the information required to perform the forward and inverse DCT operations. Creating these setup objects can be expensive, so the sample only does this once.\n\nThe forward transform is a type II DCT.\n\nThe inverse transform is a type III DCT.\n\n### Equalize the audio with DCT\n\nTo equalize the audio using a DCT-based filter, the sample app applies a forward DCT transform to the time-domain signal data. It then multiplies the frequency-domain data by the envelope values and applies an inverse transform to the multiplied data.\n\nTo ensure the volume of the equalized audio matches the original audio, the sample app scales the result. The scaling factor for the forward transform is `2`, and the scaling factor for the inverse transform is the number of samples (in this case, `1024`). The [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/divide(_:_:)-1uqmz] function divides the inverse DCT result by `sampleCount \/ 2`, and returns the result of the divide operation.\n\nThe app passes the result of the divide operation to the signal generator, and your device plays the DCT-based filtered drum loop.\n\nFor more information on scaling factors for the vDSP FFT and DFT operations, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/equalizing-audio-with-discrete-cosine-transforms-dcts\ncrawled: 2025-12-02T15:27:56Z\n---\n\n# Equalizing audio with discrete cosine transforms (DCTs)\n\n**Sample Code**\n\nChange the frequency response of an audio signal by manipulating frequency-domain data.\n\n## Overview\n\nYou can use vDSP functions to shape the output of an audio signal; for example, boosting or cutting the bass or treble of a music track.\n\nThis sample app plays a drum loop and allows the user to eliminate frequencies that are either inside or outside a range that two [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Slider] controls define.\n\nBy performing a forward DCT on the drum loop data and zeroing out parts of the audio spectrum, the sample app applies a band-pass or band-stop filter to the audio.\n\nWhen you first launch the app, the drum loop plays with a band-pass filter that eliminates very low and very high frequencies. The user interface displays the frequency-domain representation of the equalized drum loop and the shape of the envelope that defines the frequency response.\n\n\n\nBefore exploring the code, try building and running the app to familiarize yourself with the effect of the different equalizations on the drum loop.\n\nvDSP also provides biquadratic filters that offer an alternative approach for equalizing audio. To learn more about biquadratic filters, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/applying-biquadratic-filters-to-a-music-loop].\n\n### Generate the audio samples\n\nThis sample includes an audio resource, `Rhythm.aif`, that contains a drum loop. The `getAudioSamples(forResource:withExtension:)` function generates an array of single-precision values from the drum loop.\n\n```swift\nguard let samples = try await AudioUtilities.getAudioSamples(\n    forResource: \"Rhythm\",\n    withExtension: \"aif\") else {\n    fatalError(\"Unable to parse the audio resource.\")\n}\n```\n\nThe `samples` array contains single-precision values that represent the entire content of `Rhythm.aif`. To learn more about the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation] classes that generate the samples, see [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVAssetReader] and [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVAssetReaderTrackOutput].\n\n### Configure audio playback\n\nThe `DrumLoopProvider` class conforms to the `SignalProvider` protocol and vends an array of single-precision values that represent audio data. The `AudioEqualizationApp` application file creates an instance of `SignalGenerator` and specifies an instance of `DrumLoopProvider` as the signal provider. It also specifies the [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVPartialAsyncProperty\/naturalTimeScale] of the audio asset as the sample rate.\n\nThe `SignalGenerator.start()` function starts the signal generator.\n\n```swift\ntry? await drumLoopProvider.loadAudioSamples()\ntry? SignalGenerator(signalProvider: drumLoopProvider).start()\n```\n\nOn return, the signal generator repeatedly calls the `getSignal()` function and renders the returned data as audio. Each call returns a page of length `sampleCount`  from `samples`.\n\n```swift\nlet start = pageNumber * Self.sampleCount\nlet end = (pageNumber + 1) * Self.sampleCount\n\nlet page = Array(samples[start ..< end])\n\npageNumber += 1\n\nif (pageNumber + 1) * Self.sampleCount >= samples.count {\n    pageNumber = 0\n}\n```\n\nThe sample can render the audio unaltered by returning `page`.\n\nTo learn more about using [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioEngine] to render audio, see [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/building-a-signal-generator].\n\n### Define the DCT-based equalization filter\n\nThe sample app builds the envelope array — that controls which parts of the drum loop’s spectrum it zeroes — from variables that define the start and end frequencies, and a value that specifies either band pass or band stop.\n\n```swift\nlet start = Float(startFrequency)\nlet end = Float(endFrequency)\n\nlet indices = [0, start - 2, start, end, end + 2, 1024]\nlet magnitudes: [Float]\n\nswitch mode {\n    case .bandPass:\n        magnitudes = [0, 0, 1, 1, 0, 0]\n    case .bandStop:\n        magnitudes = [1, 1, 0, 0, 1, 1]\n}\n\nenvelope = [Float](unsafeUninitializedCapacity: DrumLoopProvider.sampleCount) {\n    buffer, initializedCount in\n    \n    vDSP.linearInterpolate(values: magnitudes,\n                           atIndices: indices,\n                           result: &buffer)\n    \n    initializedCount = DrumLoopProvider.sampleCount\n}\n```\n\nThe following image visualizes the effect of audio equalization that blocks most of the spectrum except low frequencies. The solid, blue line represents the frequency-domain audio data, and the dashed red line represents the values in the band-stop filter.\n\n\n\n### Prepare the DCT setups\n\nThe following code creates setup objects that contain all the information required to perform the forward and inverse DCT operations. Creating these setup objects can be expensive, so the sample only does this once.\n\nThe forward transform is a type II DCT.\n\n```swift\nstatic let forwardDCT = vDSP.DCT(count: sampleCount,\n                                 transformType: .II)!\n```\n\nThe inverse transform is a type III DCT.\n\n```swift\nstatic let inverseDCT = vDSP.DCT(count: sampleCount,\n                                 transformType: .III)!\n```\n\n### Equalize the audio with DCT\n\nTo equalize the audio using a DCT-based filter, the sample app applies a forward DCT transform to the time-domain signal data. It then multiplies the frequency-domain data by the envelope values and applies an inverse transform to the multiplied data.\n\n```swift\n\/\/ Perform forward DCT.\nforwardDCT.transform(source,\n                     result: &frequencyDomainDestination)\n\/\/ Multiply frequency-domain data by `dctMultiplier`.\nvDSP.multiply(dctMultiplier,\n              frequencyDomainDestination,\n              result: &frequencyDomainDestination)\n\n\/\/ Perform inverse DCT.\ninverseDCT.transform(frequencyDomainDestination,\n                     result: &timeDomainDestination)\n```\n\nTo ensure the volume of the equalized audio matches the original audio, the sample app scales the result. The scaling factor for the forward transform is `2`, and the scaling factor for the inverse transform is the number of samples (in this case, `1024`). The [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/divide(_:_:)-1uqmz] function divides the inverse DCT result by `sampleCount \/ 2`, and returns the result of the divide operation.\n\n```swift\n\/\/ In-place scale inverse DCT result by n \/ 2.\n\/\/ Output samples are now in range -1...+1.\nvDSP.divide(timeDomainDestination,\n            Float(DrumLoopProvider.sampleCount \/ 2),\n            result: &timeDomainDestination)\n```\n\nThe app passes the result of the divide operation to the signal generator, and your device plays the DCT-based filtered drum loop.\n\nFor more information on scaling factors for the vDSP FFT and DFT operations, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms].\n\n## Audio Processing\n\n- **Visualizing sound as an audio spectrogram**: Share image data between vDSP and vImage to visualize audio that a device microphone captures.\n- **Applying biquadratic filters to a music loop**: Change the frequency response of an audio signal using a cascaded biquadratic filter.\n- **Biquadratic IIR filters**: Apply biquadratic filters to single-channel and multichannel data.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Share image data between vDSP and vImage to visualize audio that a device microphone captures.",
          "name" : "Visualizing sound as an audio spectrogram",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/visualizing-sound-as-an-audio-spectrogram"
        },
        {
          "description" : "Change the frequency response of an audio signal using a cascaded biquadratic filter.",
          "name" : "Applying biquadratic filters to a music loop",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-biquadratic-filters-to-a-music-loop"
        },
        {
          "description" : "Apply biquadratic filters to single-channel and multichannel data.",
          "name" : "Biquadratic IIR filters",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/biquadratic-iir-filters"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Audio Processing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Equalizing audio with discrete cosine transforms (DCTs)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/equalizing-audio-with-discrete-cosine-transforms-dcts"
}