{
  "abstract" : "Implement custom linear interpolation to prevent the ringing effects associated with scaling an image with the default Lanczos algorithm.",
  "codeExamples" : [
    {
      "code" : "let resamplingFilter: ResamplingFilter\n\nlet scale: Float = 30",
      "language" : "swift"
    },
    {
      "code" : "resamplingFilter = vImageNewResamplingFilter(scale,\n                                             vImage_Flags(kvImageHighQualityResampling))",
      "language" : "swift"
    },
    {
      "code" : "let height = Float(sourceBuffer.height)\nlet yTranslate = (height - height * scale) * 0.5\n\nsourceBuffer.shear(direction: .vertical,\n                   translate: yTranslate,\n                   slope: 0,\n                   resamplingFilter: resamplingFilter,\n                   destination: intermediateBuffer)\n\nlet width = Float(sourceBuffer.width)\nlet xTranslate = (width - width * scale) * 0.5\n\nintermediateBuffer.shear(direction: .horizontal,\n                         translate: xTranslate,\n                         slope: 0,\n                         resamplingFilter: resamplingFilter,\n                         destination: destinationBuffer)",
      "language" : "swift"
    },
    {
      "code" : "func kernelFunc(inPointer: UnsafePointer<Float>?,\n                outPointer: UnsafeMutablePointer<Float>?,\n                count: UInt,\n                userData: UnsafeMutableRawPointer?) {\n    if let inPointer = inPointer, let outPointer = outPointer {\n        let absolutePixelPositions =\n        Array(UnsafeBufferPointer(start: inPointer,\n                                  count: Int(count))).map {\n            abs($0)\n        }\n        \n        let kernelValues = absolutePixelPositions.map {\n            (absolutePixelPositions.max()! - $0)\n        }\n        \n        let divisor = vDSP.sum(kernelValues)\n        let normalizedKernelValues = vDSP.multiply(1 \/ divisor, kernelValues)\n        \n        outPointer.update(from: normalizedKernelValues,\n                          count: Int(count))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "[-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0]"
    },
    {
      "code" : "[1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0, 0.0]"
    },
    {
      "code" : "[0.0625, 0.125, 0.1875, 0.25, 0.1875, 0.125, 0.0625, 0.0] \/\/ sum = 1"
    },
    {
      "code" : "let kernelWidth: Float = 1.5\n\nlet size = vImageGetResamplingFilterSize(scale,\n                                         kernelFunc,\n                                         kernelWidth,\n                                         vImage_Flags(kvImageNoFlags))\n\nresamplingFilter = ResamplingFilter.allocate(byteCount: size,\n                                             alignment: 1)",
      "language" : "swift"
    },
    {
      "code" : "vImageNewResamplingFilterForFunctionUsingBuffer(resamplingFilter,\n                                                scale,\n                                                kernelFunc,\n                                                kernelWidth,\n                                                nil,\n                                                vImage_Flags(kvImageNoFlags))",
      "language" : "swift"
    },
    {
      "code" : "let height = Float(sourceBuffer.height)\nlet yTranslate = (height - height * scale) * 0.5\n\nsourceBuffer.shear(direction: .vertical,\n                   translate: yTranslate,\n                   slope: 0,\n                   resamplingFilter: resamplingFilter,\n                   destination: intermediateBuffer)\n\nlet width = Float(sourceBuffer.width)\nlet xTranslate = (width - width * scale) * 0.5\n\nintermediateBuffer.shear(direction: .horizontal,\n                         translate: xTranslate,\n                         slope: 0,\n                         resamplingFilter: resamplingFilter,\n                         destination: destinationBuffer)",
      "language" : "swift"
    },
    {
      "code" : "vImageDestroyResamplingFilter(resamplingFilter)",
      "language" : "swift"
    },
    {
      "code" : "resamplingFilter.deallocate()",
      "language" : "swift"
    }
  ],
  "contentHash" : "3daa9ed3f325a7b3e2ffcd4e082ccb02b79ff2d8e3718afe468a005f4ec36ec8",
  "crawledAt" : "2025-12-02T15:46:08Z",
  "id" : "098FA0FA-B1CE-4E65-A7C1-997AB9C61F21",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nMost vImage geometry operations, such as scale and rotate, use a process known as *resampling* to prevent image artifacts. vImage resamples with kernels that combine data from a target pixel and other nearby pixels to calculate a value for the destination pixel.\n\nBecause resampling involves evaluating the kernel at fractional pixel locations, the process relies on a family of kernel matrices for use at different fractional distances through a given pixel. This sample code app provides a function that generates this family of kernels – unlike operations such as convolution and morphology, which apply a single kernel matrix at the center of each pixel.\n\nFor most vImage geometric operations, vImage supplies a default resampling filter that is an implementation of the Lanczos resampling method. However, the Lanczos method can produce ringing effects near regions of high-frequency signals (that is, regions that contain a lot of pixel variation, such as the hard edges typical of line art). To correct this, this sample code app implements a linear interpolation as a custom resampling filter.\n\n### Declare the resampling filter\n\nThis app allows the user to toggle between the default resampling filter (Lanczos) and the custom resampling filter. The code declares the filter independently of initialization to support that functionality:\n\nThe following code initializes a default Lanczos resampling filter:\n\nOn return, `resamplingFilter` is an initialized Lanczos resampling filter with the specified scale factor.\n\n### Use shear operations to scale an image\n\nThe vImage shear functions accept the resampling filter and perform the scaling. The shear functions operate in one dimension at a time, so to scale an image in both dimensions, the sample code calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/shear(direction:translate:slope:resamplingFilter:backgroundColor:destination:)-5busu] twice. The first call passes [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/ShearDirection\/vertical], and the second call passes [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/ShearDirection\/horizontal].\n\nBecause these functions don’t work in place – that is, they require separate input and output buffers – the code uses an intermediate buffer to pass data from the vertical shear to the horizontal shear.\n\nOn return of the horizontal shear function, `destinationBuffer` contains the source image, scaled about its center. The following shows an image of several small dots, magnified 30 times using the Lanczos resampling filter:\n\n\n\nThe ringing artifacts appear as faint lines between the magnified dots.\n\n### Write a linear resampling filter function\n\nThe shear functions that scale an image are both 1D, and therefore the resampling filter function the sample code project creates is also 1D. The code applies the same filter function for both the vertical and horizontal passes.\n\nThe function generates a set of kernel values based on a set of distances that the pixel being transformed supplies –- read from `inPointer`. The system assigns the generated kernel values to `outPointer`.\n\nIn the following example, the kernel values are inversely proportional to the distance; the further a pixel is from the transformed pixel, the smaller the corresponding kernel value. After calculating the kernel values, the values *scale* (normalize) so that their sum is `1.0`. This normalization step ensures the final image is the same brightness as the original.\n\nFor example, if the system passes the following pixel positions to `inPointer`:\n\nThe values in the `kernelValues` array are:\n\nDividing each of the values in `kernelValues` by its sum returns the normalized kernel values that the code assigns to the resampling function’s `outPointer`:\n\nThe values that the resampling function generates form a 1D convolution kernel that the shear functions use in a similar way to the 1D convolution described in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/blurring-an-image]. However, unlike the kernels used for convolution, the resampling kernel is suitable for use with fractional pixel positions.\n\n### Allocate the resampling filter function memory\n\nThe resampling function, the scale factor, and the kernel width combine to determine the memory that the resampling function requires. The sample code uses the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageGetResamplingFilterSize(_:_:_:_:)] function to calculate the size in bytes, and the [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafeMutableRawPointer\/allocate(byteCount:alignment:)] function to allocate the necessary memory.\n\nOn return, `resamplingFilter` is a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/ResamplingFilter] structure, allocated with the correct amount of uninitialized memory.\n\n### Create a linear resampling filter\n\nThe sample code calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageNewResamplingFilterForFunctionUsingBuffer(_:_:_:_:_:_:)] to create the resampling filter and populate `resamplingFilter`.\n\nScaling using a custom resampling filter is the same process as using the default Lanczos resampling:\n\nThe following shows the same image that the Lanczos example uses, also maginifed 30 times.\n\n\n\nLinear resampling eliminates the ringing artifacts.\n\n### Free the resampling filter memory\n\nAfter the sample app is finished working with the resampling filter, it’s important that it frees the allocated memory. This process will vary depending on whether the code has used the default or a custom filter. The following code frees the memory for the default:\n\nThe following code frees the memory for custom resampling filters:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-artifacts-with-custom-resampling-filters\ncrawled: 2025-12-02T15:46:08Z\n---\n\n# Reducing artifacts with custom resampling filters\n\n**Sample Code**\n\nImplement custom linear interpolation to prevent the ringing effects associated with scaling an image with the default Lanczos algorithm.\n\n## Overview\n\nMost vImage geometry operations, such as scale and rotate, use a process known as *resampling* to prevent image artifacts. vImage resamples with kernels that combine data from a target pixel and other nearby pixels to calculate a value for the destination pixel.\n\nBecause resampling involves evaluating the kernel at fractional pixel locations, the process relies on a family of kernel matrices for use at different fractional distances through a given pixel. This sample code app provides a function that generates this family of kernels – unlike operations such as convolution and morphology, which apply a single kernel matrix at the center of each pixel.\n\nFor most vImage geometric operations, vImage supplies a default resampling filter that is an implementation of the Lanczos resampling method. However, the Lanczos method can produce ringing effects near regions of high-frequency signals (that is, regions that contain a lot of pixel variation, such as the hard edges typical of line art). To correct this, this sample code app implements a linear interpolation as a custom resampling filter.\n\n### Declare the resampling filter\n\nThis app allows the user to toggle between the default resampling filter (Lanczos) and the custom resampling filter. The code declares the filter independently of initialization to support that functionality:\n\n```swift\nlet resamplingFilter: ResamplingFilter\n\nlet scale: Float = 30\n```\n\nThe following code initializes a default Lanczos resampling filter:\n\n```swift\nresamplingFilter = vImageNewResamplingFilter(scale,\n                                             vImage_Flags(kvImageHighQualityResampling))\n```\n\nOn return, `resamplingFilter` is an initialized Lanczos resampling filter with the specified scale factor.\n\n### Use shear operations to scale an image\n\nThe vImage shear functions accept the resampling filter and perform the scaling. The shear functions operate in one dimension at a time, so to scale an image in both dimensions, the sample code calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/PixelBuffer\/shear(direction:translate:slope:resamplingFilter:backgroundColor:destination:)-5busu] twice. The first call passes [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/ShearDirection\/vertical], and the second call passes [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImage\/ShearDirection\/horizontal].\n\nBecause these functions don’t work in place – that is, they require separate input and output buffers – the code uses an intermediate buffer to pass data from the vertical shear to the horizontal shear.\n\n```swift\nlet height = Float(sourceBuffer.height)\nlet yTranslate = (height - height * scale) * 0.5\n\nsourceBuffer.shear(direction: .vertical,\n                   translate: yTranslate,\n                   slope: 0,\n                   resamplingFilter: resamplingFilter,\n                   destination: intermediateBuffer)\n\nlet width = Float(sourceBuffer.width)\nlet xTranslate = (width - width * scale) * 0.5\n\nintermediateBuffer.shear(direction: .horizontal,\n                         translate: xTranslate,\n                         slope: 0,\n                         resamplingFilter: resamplingFilter,\n                         destination: destinationBuffer)\n```\n\nOn return of the horizontal shear function, `destinationBuffer` contains the source image, scaled about its center. The following shows an image of several small dots, magnified 30 times using the Lanczos resampling filter:\n\n\n\nThe ringing artifacts appear as faint lines between the magnified dots.\n\n### Write a linear resampling filter function\n\nThe shear functions that scale an image are both 1D, and therefore the resampling filter function the sample code project creates is also 1D. The code applies the same filter function for both the vertical and horizontal passes.\n\nThe function generates a set of kernel values based on a set of distances that the pixel being transformed supplies –- read from `inPointer`. The system assigns the generated kernel values to `outPointer`.\n\nIn the following example, the kernel values are inversely proportional to the distance; the further a pixel is from the transformed pixel, the smaller the corresponding kernel value. After calculating the kernel values, the values *scale* (normalize) so that their sum is `1.0`. This normalization step ensures the final image is the same brightness as the original.\n\n```swift\nfunc kernelFunc(inPointer: UnsafePointer<Float>?,\n                outPointer: UnsafeMutablePointer<Float>?,\n                count: UInt,\n                userData: UnsafeMutableRawPointer?) {\n    if let inPointer = inPointer, let outPointer = outPointer {\n        let absolutePixelPositions =\n        Array(UnsafeBufferPointer(start: inPointer,\n                                  count: Int(count))).map {\n            abs($0)\n        }\n        \n        let kernelValues = absolutePixelPositions.map {\n            (absolutePixelPositions.max()! - $0)\n        }\n        \n        let divisor = vDSP.sum(kernelValues)\n        let normalizedKernelValues = vDSP.multiply(1 \/ divisor, kernelValues)\n        \n        outPointer.update(from: normalizedKernelValues,\n                          count: Int(count))\n    }\n}\n```\n\nFor example, if the system passes the following pixel positions to `inPointer`:\n\n```\n[-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0]\n```\n\nThe values in the `kernelValues` array are:\n\n```\n[1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0, 0.0]\n```\n\nDividing each of the values in `kernelValues` by its sum returns the normalized kernel values that the code assigns to the resampling function’s `outPointer`:\n\n```\n[0.0625, 0.125, 0.1875, 0.25, 0.1875, 0.125, 0.0625, 0.0] \/\/ sum = 1\n```\n\nThe values that the resampling function generates form a 1D convolution kernel that the shear functions use in a similar way to the 1D convolution described in [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/blurring-an-image]. However, unlike the kernels used for convolution, the resampling kernel is suitable for use with fractional pixel positions.\n\n### Allocate the resampling filter function memory\n\nThe resampling function, the scale factor, and the kernel width combine to determine the memory that the resampling function requires. The sample code uses the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageGetResamplingFilterSize(_:_:_:_:)] function to calculate the size in bytes, and the [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnsafeMutableRawPointer\/allocate(byteCount:alignment:)] function to allocate the necessary memory.\n\n```swift\nlet kernelWidth: Float = 1.5\n\nlet size = vImageGetResamplingFilterSize(scale,\n                                         kernelFunc,\n                                         kernelWidth,\n                                         vImage_Flags(kvImageNoFlags))\n\nresamplingFilter = ResamplingFilter.allocate(byteCount: size,\n                                             alignment: 1)\n```\n\nOn return, `resamplingFilter` is a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/ResamplingFilter] structure, allocated with the correct amount of uninitialized memory.\n\n### Create a linear resampling filter\n\nThe sample code calls [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vImageNewResamplingFilterForFunctionUsingBuffer(_:_:_:_:_:_:)] to create the resampling filter and populate `resamplingFilter`.\n\n```swift\nvImageNewResamplingFilterForFunctionUsingBuffer(resamplingFilter,\n                                                scale,\n                                                kernelFunc,\n                                                kernelWidth,\n                                                nil,\n                                                vImage_Flags(kvImageNoFlags))\n```\n\nScaling using a custom resampling filter is the same process as using the default Lanczos resampling:\n\n```swift\nlet height = Float(sourceBuffer.height)\nlet yTranslate = (height - height * scale) * 0.5\n\nsourceBuffer.shear(direction: .vertical,\n                   translate: yTranslate,\n                   slope: 0,\n                   resamplingFilter: resamplingFilter,\n                   destination: intermediateBuffer)\n\nlet width = Float(sourceBuffer.width)\nlet xTranslate = (width - width * scale) * 0.5\n\nintermediateBuffer.shear(direction: .horizontal,\n                         translate: xTranslate,\n                         slope: 0,\n                         resamplingFilter: resamplingFilter,\n                         destination: destinationBuffer)\n```\n\nThe following shows the same image that the Lanczos example uses, also maginifed 30 times.\n\n\n\nLinear resampling eliminates the ringing artifacts.\n\n### Free the resampling filter memory\n\nAfter the sample app is finished working with the resampling filter, it’s important that it frees the allocated memory. This process will vary depending on whether the code has used the default or a custom filter. The following code frees the memory for the default:\n\n```swift\nvImageDestroyResamplingFilter(resamplingFilter)\n```\n\nThe following code frees the memory for custom resampling filters:\n\n```swift\nresamplingFilter.deallocate()\n```\n\n## Image Resampling\n\n- **Resampling in vImage**: Learn how vImage resamples image data during geometric operations.\n- **Image shearing**: Shear images horizontally and vertically.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn how vImage resamples image data during geometric operations.",
          "name" : "Resampling in vImage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/resampling-in-vimage"
        },
        {
          "description" : "Shear images horizontally and vertically.",
          "name" : "Image shearing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/image-shearing"
        }
      ],
      "title" : "Image Resampling"
    }
  ],
  "source" : "appleJSON",
  "title" : "Reducing artifacts with custom resampling filters",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-artifacts-with-custom-resampling-filters"
}