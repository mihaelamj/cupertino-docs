{
  "abstract" : "Add biquadratic filter audio-effect processing to apps like Logic Pro X and GarageBand with the Accelerate framework.",
  "codeExamples" : [
    {
      "code" : "typedef NS_ENUM(AUParameterAddress, vDSP_audio_unitExtensionParameterAddress) {\n    frequency = 0,\n    Q = 1,\n    dbGain = 2\n};",
      "language" : "objective-c"
    },
    {
      "code" : "ParameterSpec(\n    address: .frequency,\n    identifier: \"frequency\",\n    name: \"Frequency\",\n    units: .hertz,\n    valueRange: 20 ... 20_000,\n    defaultValue: 100.0\n)\n\nParameterSpec(\n    address: .Q,\n    identifier: \"Q\",\n    name: \"Q\",\n    units: .generic,\n    valueRange: 0.1 ... 25,\n    defaultValue: 1\n)\n\nParameterSpec(\n    address: .dbGain,\n    identifier: \"dbGain\",\n    name: \"Decibel Gain\",\n    units: .linearGain,\n    valueRange: -50 ... 50,\n    defaultValue: 15\n)",
      "language" : "swift"
    },
    {
      "code" : "void setParameter(AUParameterAddress address, AUValue value) {\n    switch (address) {\n        case vDSP_audio_unitExtensionParameterAddress::frequency:\n            frequency = value;\n            break;\n        case vDSP_audio_unitExtensionParameterAddress::Q:\n            Q = value;\n            break;\n        case vDSP_audio_unitExtensionParameterAddress::dbGain:\n            dbGain = value;\n            break;\n    }\n}\n\nAUValue getParameter(AUParameterAddress address) {\n    \/\/ Return the goal. It's not thread safe to return the ramping value.\n    \n    switch (address) {\n        case vDSP_audio_unitExtensionParameterAddress::frequency:\n            return (AUValue)frequency;\n        case vDSP_audio_unitExtensionParameterAddress::Q:\n            return (AUValue)Q;\n        case vDSP_audio_unitExtensionParameterAddress::dbGain:\n            return (AUValue)dbGain;\n        default: return 0.f;\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "void initialize(int inputChannelCount, int outputChannelCount, double inSampleRate) {\n    mSampleRate = inSampleRate;\n\n    \/\/ Default coefficients.\n    double coefficients[5] = {1.0, 0.0, 0.0, 1.0, 0.0};\n    \n    for (int i = 0; i < inputChannelCount; i++) {\n        \n        biquads.push_back((Biquad){\n            .setup = vDSP_biquad_CreateSetup(coefficients, 1)\n        });\n        \n        for (int j = 0; j < 4; j++) {\n            biquads[i].delay[j] = 0.0;\n        }\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "void process(std::span<float const*> inputBuffers,\n             std::span<float *> outputBuffers,\n             AUEventSampleTime bufferStartTime,\n             AUAudioFrameCount frameCount) {\n    \n    if (mBypassed) {\n        \/\/ Pass the samples through.\n        for (UInt32 channel = 0; channel < inputBuffers.size(); ++channel) {\n            std::copy_n(inputBuffers[channel], frameCount, outputBuffers[channel]);\n        }\n        return;\n    }\n    \n    double coeffs[5];\n    \/\/ Populate `coeffs` from the parameters.\n    biquadCoefficientsFor(mSampleRate,\n                          frequency,\n                          Q,\n                          dbGain,\n                          coeffs);\n    \n    \/\/ For each channel, calculate and set the coefficients, and apply the\n    \/\/ biquadratic filter.\n    for (UInt32 channel = 0; channel < inputBuffers.size(); ++channel) {\n                    \n        \/\/ Set the coefficients on the biquadratic object.\n        vDSP_biquad_SetCoefficientsDouble(biquads[channel].setup,\n                                          coeffs,\n                                          0, 1);\n        \n        \/\/ Apply the biquadratic filter.\n        vDSP_biquad(biquads[channel].setup,\n                    biquads[channel].delay,\n                    inputBuffers[channel], 1,\n                    outputBuffers[channel], 1,\n                    frameCount);\n    }\n}",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "f8855d41911ad2bbd02370332a2e2046fb023a3c75253fbd77bea1a95ecdd701",
  "crawledAt" : "2025-12-02T15:46:03Z",
  "id" : "8E1EE8FC-F43C-4298-AB3D-BAABE0A6C9F0",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nAn audio unit extension provides a way to create or modify audio and MIDI data in an iOS or macOS app that uses sound — including music-production apps. It contains the audio unit and, optionally, a user interface to control the audio unit. The audio unit is a custom plug-in where you generate audio or implement an audio-processing algorithm.\n\nYou can shape the output of an audio signal, such as by boosting or cutting the bass or treble of a music track, with the single-channel and multichannel biquadratic filters that the vDSP library provides.\n\nThe image below shows an example of a magnitude response curve that boosts low frequencies:\n\n\n\nThis sample code project is a peaking EQ filter implemented with a vDSP biquadratic filter that’s delivered as an audio unit extension. You can use the code in this project as the basis for writing audio units that use the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP] library.\n\nThis project is based on the Audio Unit Extension App Xcode template and uses the *Effect* audio unit type. This type of audio unit accepts an audio input and produces an audio output. The template provides an audio pass-through effect with a signal parameter to adjust the gain of the audio that passes through the audio unit.\n\nFor more information about creating audio unit extensions, see [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/creating-an-audio-unit-extension].\n\n### Add a new parameter address\n\nThe peaking EQ filter requires three parameters: the center frequency, the Q value (which controls the shape of the response curve), and the decibel gain.\n\nThe code below adds enumeration cases for the parameters to the `vDSP_audio_unitExtensionParameterAddresses.h` header:\n\nTo allow the host app to interact with the parameters, the sample code project describes their default value, value range, name, and identifier in `Parameters.swift`. The identifier value you specify is what the audio unit uses to reference the parameter from the host app.\n\nTo expose each parameter for digital signal processing (DSP), the code below adds each custom member variable to the `setParameter` and `getParameter` functions:\n\n### Implement the biquadratic filter\n\nThe audio unit extension applies a peaking EQ filter with the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_biquad_Setup] filter. For more information about using biquadratic filters, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/applying-biquadratic-filters-to-a-music-loop].\n\nThe `vDSP_audio_unitExtensionDSPKernel` class provides the plug-in’s DSP logic, and is written in C++ to ensure real-time safety. The code below initializes the DSP kernel by creating a vector of biquadratic filters with default, pass-though coefficients:\n\nThe `vDSP_audio_unitExtensionDSPKernel::process()` function applies the biquadratic filters to the input channels and writes the result to the output channels:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-an-audio-unit-extension-using-the-vdsp-library\ncrawled: 2025-12-02T15:46:03Z\n---\n\n# Creating an audio unit extension using the vDSP library\n\n**Sample Code**\n\nAdd biquadratic filter audio-effect processing to apps like Logic Pro X and GarageBand with the Accelerate framework.\n\n## Overview\n\nAn audio unit extension provides a way to create or modify audio and MIDI data in an iOS or macOS app that uses sound — including music-production apps. It contains the audio unit and, optionally, a user interface to control the audio unit. The audio unit is a custom plug-in where you generate audio or implement an audio-processing algorithm.\n\nYou can shape the output of an audio signal, such as by boosting or cutting the bass or treble of a music track, with the single-channel and multichannel biquadratic filters that the vDSP library provides.\n\nThe image below shows an example of a magnitude response curve that boosts low frequencies:\n\n\n\nThis sample code project is a peaking EQ filter implemented with a vDSP biquadratic filter that’s delivered as an audio unit extension. You can use the code in this project as the basis for writing audio units that use the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP] library.\n\nThis project is based on the Audio Unit Extension App Xcode template and uses the *Effect* audio unit type. This type of audio unit accepts an audio input and produces an audio output. The template provides an audio pass-through effect with a signal parameter to adjust the gain of the audio that passes through the audio unit.\n\nFor more information about creating audio unit extensions, see [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/creating-an-audio-unit-extension].\n\n### Add a new parameter address\n\nThe peaking EQ filter requires three parameters: the center frequency, the Q value (which controls the shape of the response curve), and the decibel gain.\n\nThe code below adds enumeration cases for the parameters to the `vDSP_audio_unitExtensionParameterAddresses.h` header:\n\n```objective-c\ntypedef NS_ENUM(AUParameterAddress, vDSP_audio_unitExtensionParameterAddress) {\n    frequency = 0,\n    Q = 1,\n    dbGain = 2\n};\n```\n\nTo allow the host app to interact with the parameters, the sample code project describes their default value, value range, name, and identifier in `Parameters.swift`. The identifier value you specify is what the audio unit uses to reference the parameter from the host app.\n\n```swift\nParameterSpec(\n    address: .frequency,\n    identifier: \"frequency\",\n    name: \"Frequency\",\n    units: .hertz,\n    valueRange: 20 ... 20_000,\n    defaultValue: 100.0\n)\n\nParameterSpec(\n    address: .Q,\n    identifier: \"Q\",\n    name: \"Q\",\n    units: .generic,\n    valueRange: 0.1 ... 25,\n    defaultValue: 1\n)\n\nParameterSpec(\n    address: .dbGain,\n    identifier: \"dbGain\",\n    name: \"Decibel Gain\",\n    units: .linearGain,\n    valueRange: -50 ... 50,\n    defaultValue: 15\n)\n```\n\nTo expose each parameter for digital signal processing (DSP), the code below adds each custom member variable to the `setParameter` and `getParameter` functions:\n\n```objective-c\nvoid setParameter(AUParameterAddress address, AUValue value) {\n    switch (address) {\n        case vDSP_audio_unitExtensionParameterAddress::frequency:\n            frequency = value;\n            break;\n        case vDSP_audio_unitExtensionParameterAddress::Q:\n            Q = value;\n            break;\n        case vDSP_audio_unitExtensionParameterAddress::dbGain:\n            dbGain = value;\n            break;\n    }\n}\n\nAUValue getParameter(AUParameterAddress address) {\n    \/\/ Return the goal. It's not thread safe to return the ramping value.\n    \n    switch (address) {\n        case vDSP_audio_unitExtensionParameterAddress::frequency:\n            return (AUValue)frequency;\n        case vDSP_audio_unitExtensionParameterAddress::Q:\n            return (AUValue)Q;\n        case vDSP_audio_unitExtensionParameterAddress::dbGain:\n            return (AUValue)dbGain;\n        default: return 0.f;\n    }\n}\n```\n\n### Implement the biquadratic filter\n\nThe audio unit extension applies a peaking EQ filter with the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_biquad_Setup] filter. For more information about using biquadratic filters, see [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/applying-biquadratic-filters-to-a-music-loop].\n\nThe `vDSP_audio_unitExtensionDSPKernel` class provides the plug-in’s DSP logic, and is written in C++ to ensure real-time safety. The code below initializes the DSP kernel by creating a vector of biquadratic filters with default, pass-though coefficients:\n\n```objective-c\nvoid initialize(int inputChannelCount, int outputChannelCount, double inSampleRate) {\n    mSampleRate = inSampleRate;\n\n    \/\/ Default coefficients.\n    double coefficients[5] = {1.0, 0.0, 0.0, 1.0, 0.0};\n    \n    for (int i = 0; i < inputChannelCount; i++) {\n        \n        biquads.push_back((Biquad){\n            .setup = vDSP_biquad_CreateSetup(coefficients, 1)\n        });\n        \n        for (int j = 0; j < 4; j++) {\n            biquads[i].delay[j] = 0.0;\n        }\n    }\n}\n```\n\nThe `vDSP_audio_unitExtensionDSPKernel::process()` function applies the biquadratic filters to the input channels and writes the result to the output channels:\n\n```objective-c\nvoid process(std::span<float const*> inputBuffers,\n             std::span<float *> outputBuffers,\n             AUEventSampleTime bufferStartTime,\n             AUAudioFrameCount frameCount) {\n    \n    if (mBypassed) {\n        \/\/ Pass the samples through.\n        for (UInt32 channel = 0; channel < inputBuffers.size(); ++channel) {\n            std::copy_n(inputBuffers[channel], frameCount, outputBuffers[channel]);\n        }\n        return;\n    }\n    \n    double coeffs[5];\n    \/\/ Populate `coeffs` from the parameters.\n    biquadCoefficientsFor(mSampleRate,\n                          frequency,\n                          Q,\n                          dbGain,\n                          coeffs);\n    \n    \/\/ For each channel, calculate and set the coefficients, and apply the\n    \/\/ biquadratic filter.\n    for (UInt32 channel = 0; channel < inputBuffers.size(); ++channel) {\n                    \n        \/\/ Set the coefficients on the biquadratic object.\n        vDSP_biquad_SetCoefficientsDouble(biquads[channel].setup,\n                                          coeffs,\n                                          0, 1);\n        \n        \/\/ Apply the biquadratic filter.\n        vDSP_biquad(biquads[channel].setup,\n                    biquads[channel].delay,\n                    inputBuffers[channel], 1,\n                    outputBuffers[channel], 1,\n                    frameCount);\n    }\n}\n```\n\n## Biquadratic filter essentials\n\n- **Applying biquadratic filters to a music loop**: Change the frequency response of an audio signal using a cascaded biquadratic filter.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Change the frequency response of an audio signal using a cascaded biquadratic filter.",
          "name" : "Applying biquadratic filters to a music loop",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/applying-biquadratic-filters-to-a-music-loop"
        }
      ],
      "title" : "Biquadratic filter essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating an audio unit extension using the vDSP library",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/creating-an-audio-unit-extension-using-the-vdsp-library"
}