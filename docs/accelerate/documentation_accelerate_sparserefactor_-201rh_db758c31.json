{
  "abstract" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values, using updated options and without any internal allocations.",
  "codeExamples" : [

  ],
  "contentHash" : "14fdf206fde73354cc7638a75f407ca35065e8c1cebf0c2929f8bbb5720dde46",
  "crawledAt" : "2025-12-02T23:08:15Z",
  "declaration" : {
    "code" : "func SparseRefactor(_ Matrix: SparseMatrix_Complex_Float, _ Factored: UnsafeMutablePointer<SparseOpaqueFactorization_Complex_Float>, _ nfoptions: SparseNumericFactorOptions, _ workspace: UnsafeMutableRawPointer)",
    "language" : "swift"
  },
  "id" : "875FB037-F155-41E0-A62F-4FA1B37D121C",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\n`Matrix` must have the same non-zero structure as that used for the original factorization.\n\nThis call provides very similar behavior to that which can be achieved by reusing explicit storage supplied to `SparseFactor` as the argument `factorStorage`. However, in addition to providing a simplified call sequence, this call can also reuse any additional storage allocated to accomodate delayed pivots.\n\nNote that internal memory allocations may occur in the case of pivoted factorizations that result in delayed pivots. If you require closer control over memory allocations, supply an `sfoptions.malloc` function that implements the required behaviour, or use an alternative non-pivoted factorization returns. Note that if `sfoptions.malloc` returns NULL the factorization will abort immediately.\n\nNote that if the reference count of the underlying object is not exactly one (i.e. if there are any implict copies as a result of calls to `SparseGetTranspose` or `SparseCreateSubfactor()` that have not been destroyed through a call to `SparseCleanup`), then new storage will be allocated regardless.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:_:)-201rh\ncrawled: 2025-12-02T23:08:15Z\n---\n\n# SparseRefactor(_:_:_:_:)\n\n**Function**\n\nReuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values, using updated options and without any internal allocations.\n\n## Declaration\n\n```swift\nfunc SparseRefactor(_ Matrix: SparseMatrix_Complex_Float, _ Factored: UnsafeMutablePointer<SparseOpaqueFactorization_Complex_Float>, _ nfoptions: SparseNumericFactorOptions, _ workspace: UnsafeMutableRawPointer)\n```\n\n## Parameters\n\n- **Matrix**: The matrix to be factorized.\n- **nfoptions**: Numeric factor options, for example pivoting parameters.\n- **workspace**: A pointer to a workspace of size at least `Factorization->symbolicFactorization.workspaceSize_Float * 2` bytes. This memory must be 16-byte aligned (any allocation returned by `malloc` has this property). This workspace may be reused or destroyed by the user as soon as the function returns.\n\n## Discussion\n\n`Matrix` must have the same non-zero structure as that used for the original factorization.\n\nThis call provides very similar behavior to that which can be achieved by reusing explicit storage supplied to `SparseFactor` as the argument `factorStorage`. However, in addition to providing a simplified call sequence, this call can also reuse any additional storage allocated to accomodate delayed pivots.\n\nNote that internal memory allocations may occur in the case of pivoted factorizations that result in delayed pivots. If you require closer control over memory allocations, supply an `sfoptions.malloc` function that implements the required behaviour, or use an alternative non-pivoted factorization returns. Note that if `sfoptions.malloc` returns NULL the factorization will abort immediately.\n\nNote that if the reference count of the underlying object is not exactly one (i.e. if there are any implict copies as a result of calls to `SparseGetTranspose` or `SparseCreateSubfactor()` that have not been destroyed through a call to `SparseCleanup`), then new storage will be allocated regardless.\n\n## Matrix Refactorizations Functions with User-Defined Workspace\n\n- **SparseRefactor(_:_:_:)**: Computes a factorization of the specified double-precision matrix using an existing factorization’s storage, without internal memory allocation.\n- **SparseRefactor(_:_:_:)**: Computes a factorization of the specified single-precision matrix using an existing factorization’s storage, without internal memory allocation.\n- **SparseRefactor(_:_:_:_:)**: Computes a factorization of the specified double-precision matrix using an existing factorization’s storage and specified options, and without internal memory allocation.\n- **SparseRefactor(_:_:_:_:)**: Computes a factorization of the specified single-precision matrix using an existing factorization’s storage and specified options, and without internal memory allocation.\n- **SparseRefactor(_:_:_:)**: Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values, without any internal allocations.\n- **SparseRefactor(_:_:_:)**: Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values, without any internal allocations.\n- **SparseRefactor(_:_:_:_:)**: Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values, using updated options and without any internal allocations.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Computes a factorization of the specified double-precision matrix using an existing factorization’s storage, without internal memory allocation.",
          "name" : "SparseRefactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-9mqeq"
        },
        {
          "description" : "Computes a factorization of the specified single-precision matrix using an existing factorization’s storage, without internal memory allocation.",
          "name" : "SparseRefactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-2dqt8"
        },
        {
          "description" : "Computes a factorization of the specified double-precision matrix using an existing factorization’s storage and specified options, and without internal memory allocation.",
          "name" : "SparseRefactor(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:_:)-59ehf"
        },
        {
          "description" : "Computes a factorization of the specified single-precision matrix using an existing factorization’s storage and specified options, and without internal memory allocation.",
          "name" : "SparseRefactor(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:_:)-8i8vi"
        },
        {
          "description" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values, without any internal allocations.",
          "name" : "SparseRefactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-4ofvz"
        },
        {
          "description" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values, without any internal allocations.",
          "name" : "SparseRefactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-593yb"
        },
        {
          "description" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values, using updated options and without any internal allocations.",
          "name" : "SparseRefactor(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:_:)-20xqc"
        }
      ],
      "title" : "Matrix Refactorizations Functions with User-Defined Workspace"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseRefactor(_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:_:)-201rh"
}