{
  "abstract" : "Solves the equation *AX = B* for matrices of double-precision values, treating *A* as an operator and using the specified iterative method.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Double] =      [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\ndefer {\n    SparseCleanup(A)\n}\n\n\/\/\/ Create the right-hand-side matrix, _B_.\nvar bValues: [Double] = [30, 35, 100,\n                         300, 350, 1000]\n\nvar xValues: [Double] = [0, 0, 0,\n                         0, 0, 0]\n\n\/\/\/ Create the apply operator block.\nfunc applyOperator(accumulate: Bool,\n                   trans: CBLAS_TRANSPOSE,\n                   X: DenseMatrix_Double,\n                   Y: DenseMatrix_Double) {\n    switch(accumulate, trans == CblasTrans) {\n        case (false, false):\n            SparseMultiply(A, X, Y)\n        case (false, true):\n            SparseMultiply(SparseGetTranspose(A), X, Y)\n        case (true, false):\n            SparseMultiplyAdd(A, X, Y)\n        case (true, true):\n            SparseMultiplyAdd(SparseGetTranspose(A), X, Y)\n    }\n}\n\nxValues.withUnsafeMutableBufferPointer { xPtr in\n    bValues.withUnsafeMutableBufferPointer { bPtr in\n        let B = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: bPtr.baseAddress!)\n        \n        let X = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: xPtr.baseAddress!)\n        \n        let status = SparseSolve(SparseLSMR(),\n                                 applyOperator,\n                                 B, X)\n        \n        print(status)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ba795818aa7f9c5299e68c08cc1c5d70921098c25748616241bb5e9af4feb3e9",
  "crawledAt" : "2025-12-01T03:59:03Z",
  "declaration" : {
    "code" : "func SparseSolve(_ method: SparseIterativeMethod, _ ApplyOperator: @escaping (Bool, CBLAS_TRANSPOSE, DenseMatrix_Double, DenseMatrix_Double) -> Void, _ B: DenseMatrix_Double, _ X: DenseMatrix_Double) -> SparseIterativeStatus_t",
    "language" : "swift"
  },
  "id" : "F9B06ABC-C874-4604-8737-4C09C1697C73",
  "kind" : "function",
  "module" : "Accelerate",
  "overview" : "## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. In cases where the matrix *A* isn’t explicitly available or you need control over the multiplication, this function allows you to provide an apply block.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system using the least squares minimum residual method:\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0, 10.0, 20.0, 30.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:)-vewd\ncrawled: 2025-12-01T03:59:03Z\n---\n\n# SparseSolve(_:_:_:_:)\n\n**Function**\n\nSolves the equation *AX = B* for matrices of double-precision values, treating *A* as an operator and using the specified iterative method.\n\n## Declaration\n\n```swift\nfunc SparseSolve(_ method: SparseIterativeMethod, _ ApplyOperator: @escaping (Bool, CBLAS_TRANSPOSE, DenseMatrix_Double, DenseMatrix_Double) -> Void, _ B: DenseMatrix_Double, _ X: DenseMatrix_Double) -> SparseIterativeStatus_t\n```\n\n## Parameters\n\n- **method**: The iterative method.\n- **ApplyOperator**: The apply operator block to run. The block takes the following parameters:\n\n\n- **B**: The matrix *B*.\n- **X**: The matrix *X*.\n\n## Return Value\n\nA [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseIterativeStatus_t] enumeration that represents the status of the iterative solve.\n\n## Discussion\n\nUse this function to solve a system of linear equations using a factored coefficient matrix. In cases where the matrix *A* isn’t explicitly available or you need control over the multiplication, this function allows you to provide an apply block.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves this system using the least squares minimum residual method:\n\n```swift\n\/\/\/ Create the coefficient matrix _A_.\nlet rowIndices: [Int32] =    [ 0,  1, 1,  2]\nlet columnIndices: [Int32] = [ 2,  0, 2,  1]\nlet aValues: [Double] =      [10, 20, 5, 50]\n\nlet A = SparseConvertFromCoordinate(3, 3,\n                                    4, 1,\n                                    SparseAttributes_t(),\n                                    rowIndices, columnIndices,\n                                    aValues)\n\ndefer {\n    SparseCleanup(A)\n}\n\n\/\/\/ Create the right-hand-side matrix, _B_.\nvar bValues: [Double] = [30, 35, 100,\n                         300, 350, 1000]\n\nvar xValues: [Double] = [0, 0, 0,\n                         0, 0, 0]\n\n\/\/\/ Create the apply operator block.\nfunc applyOperator(accumulate: Bool,\n                   trans: CBLAS_TRANSPOSE,\n                   X: DenseMatrix_Double,\n                   Y: DenseMatrix_Double) {\n    switch(accumulate, trans == CblasTrans) {\n        case (false, false):\n            SparseMultiply(A, X, Y)\n        case (false, true):\n            SparseMultiply(SparseGetTranspose(A), X, Y)\n        case (true, false):\n            SparseMultiplyAdd(A, X, Y)\n        case (true, true):\n            SparseMultiplyAdd(SparseGetTranspose(A), X, Y)\n    }\n}\n\nxValues.withUnsafeMutableBufferPointer { xPtr in\n    bValues.withUnsafeMutableBufferPointer { bPtr in\n        let B = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: bPtr.baseAddress!)\n        \n        let X = DenseMatrix_Double(rowCount: 3,\n                                   columnCount: 2,\n                                   columnStride: 3,\n                                   attributes: SparseAttributes_t(),\n                                   data: xPtr.baseAddress!)\n        \n        let status = SparseSolve(SparseLSMR(),\n                                 applyOperator,\n                                 B, X)\n        \n        print(status)\n    }\n}\n```\n\nOn return, x`Values` contains the values `[1.0, 2.0, 3.0, 10.0, 20.0, 30.0]`.\n\n## Iterative sparse solve functions\n\n- **SparseSolve(_:_:_:_:)**: Solves the equation *AX = B* for matrices of double-precision values using the specified iterative method.\n- **SparseSolve(_:_:_:_:)**: Solves the equation *AX = B* for matrices of single-precision values using the specified iterative method.\n- **SparseSolve(_:_:_:_:)**: Solves the equation *AX = B* for matrices of single-precision values, treating *A* as an operator and using the specified iterative method.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Solves the equation *AX = B* for matrices of double-precision values using the specified iterative method.",
          "name" : "SparseSolve(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:)-3ft19"
        },
        {
          "description" : "Solves the equation *AX = B* for matrices of single-precision values using the specified iterative method.",
          "name" : "SparseSolve(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:)-1f00y"
        },
        {
          "description" : "Solves the equation *AX = B* for matrices of single-precision values, treating *A* as an operator and using the specified iterative method.",
          "name" : "SparseSolve(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:)-8mtxu"
        }
      ],
      "title" : "Iterative sparse solve functions"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseSolve(_:_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseSolve(_:_:_:_:)-vewd"
}