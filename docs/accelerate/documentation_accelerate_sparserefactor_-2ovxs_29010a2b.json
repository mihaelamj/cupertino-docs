{
  "abstract" : "Computes a factorization of the specified single-precision matrix using an existing factorization’s storage and specified options.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Define the sparsity structure of matrices `A0` and `A1`.\nlet rowIndices: [Int32] =    [ 0, 1, 1, 2]\nlet columnIndices: [Int32] = [ 2, 0, 2, 1]\n\n\/\/\/ Create the single-precision coefficient matrix _A0_.\nlet a0Values: [Float] = [10, 20, 5, 50]\nlet A0 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a0Values)\n\n\/\/\/ Factorize _A0_.\nvar factorization = SparseFactor(SparseFactorizationQR, A0)\n\n\/\/\/ Solve _A0 · x = b0_ in place.\nvar b0Values: [Float] = [30, 35, 100]\nb0Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Float(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization, xb)\n}\n\nprettyPrint(b0Values) \/\/ Contains `[1.0, 2.0, 3.0]`.\n\n\/\/\/ Create the double-precision coefficient matrix _A1_.\nlet a1Values: [Float] = [5, 10, 2.5, 25]\nlet A1 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a1Values)\n\n\/\/\/ Factorize _A1_ into the existing factorization.\nlet numericFactorOptions = SparseNumericFactorOptions()\nSparseRefactor(A1, &factorization,\n               numericFactorOptions)\n\n\/\/\/ Solve _A1 · x = b1_ in place.\nvar b1Values: [Float] = [60, 70, 200]\nb1Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Float(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization, xb)\n}\n\nprettyPrint(b1Values) \/\/ Contains `[4.0, 8.0, 12.0]`.\n\nSparseCleanup(A0)\nSparseCleanup(A1)\nSparseCleanup(factorization)",
      "language" : "swift"
    }
  ],
  "contentHash" : "6b09d0f4fcb956a01c4c056a7b2af8d69762c35f7fe558c623b9b73b8972feb6",
  "crawledAt" : "2025-12-02T23:08:07Z",
  "declaration" : {
    "code" : "func SparseRefactor(_ Matrix: SparseMatrix_Float, _ Factorization: UnsafeMutablePointer<SparseOpaqueFactorization_Float>, _ nfoptions: SparseNumericFactorOptions)",
    "language" : "swift"
  },
  "id" : "F27A405A-1625-44A0-9DFC-1B837496F550",
  "kind" : "function",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Discussion\n\nUse this function to calculate the factorization of a sparse matrix to pass to the direct solve functions using an existing factorization’s storage. The specified matrix must have the same sparsity structure as the matrix of the original factorization.\n\nThis function provides behavior similar to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:_:_:_:)-68hki] by reusing explicit storage that you supply to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:_:_:_:)-68hki] as the argument `factorStorage`. However, in addition to providing a simplified call sequence, this call can also reuse any additional storage that you allocate to accommodate delayed pivots.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves these two systems with refactoring. After factorizing and solving for the coefficient matrix *A0*, the code refactors and solves for matrix *A1*.\n\nOn return, `b0Values` contains the values `[1.0, 2.0, 3.0]`, and `b1Values` contains the values `[4.0, 8.0, 12.0]`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-2ovxs\ncrawled: 2025-12-02T23:08:07Z\n---\n\n# SparseRefactor(_:_:_:)\n\n**Function**\n\nComputes a factorization of the specified single-precision matrix using an existing factorization’s storage and specified options.\n\n## Declaration\n\n```swift\nfunc SparseRefactor(_ Matrix: SparseMatrix_Float, _ Factorization: UnsafeMutablePointer<SparseOpaqueFactorization_Float>, _ nfoptions: SparseNumericFactorOptions)\n```\n\n## Parameters\n\n- **Matrix**: The matrix that contains numerical data to recompute.\n- **Factorization**: On input, the factorization to recompute. On output, the recomputed result.\n- **nfoptions**: The numeric factor options, such as the scaling method to use.\n\n## Discussion\n\nUse this function to calculate the factorization of a sparse matrix to pass to the direct solve functions using an existing factorization’s storage. The specified matrix must have the same sparsity structure as the matrix of the original factorization.\n\nThis function provides behavior similar to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:_:_:_:)-68hki] by reusing explicit storage that you supply to [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/SparseFactor(_:_:_:_:_:)-68hki] as the argument `factorStorage`. However, in addition to providing a simplified call sequence, this call can also reuse any additional storage that you allocate to accommodate delayed pivots.\n\nThe following figure shows two systems of equations where the coefficient matrix is sparse:\n\n\n\nThe following code solves these two systems with refactoring. After factorizing and solving for the coefficient matrix *A0*, the code refactors and solves for matrix *A1*.\n\n```swift\n\/\/\/ Define the sparsity structure of matrices `A0` and `A1`.\nlet rowIndices: [Int32] =    [ 0, 1, 1, 2]\nlet columnIndices: [Int32] = [ 2, 0, 2, 1]\n\n\/\/\/ Create the single-precision coefficient matrix _A0_.\nlet a0Values: [Float] = [10, 20, 5, 50]\nlet A0 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a0Values)\n\n\/\/\/ Factorize _A0_.\nvar factorization = SparseFactor(SparseFactorizationQR, A0)\n\n\/\/\/ Solve _A0 · x = b0_ in place.\nvar b0Values: [Float] = [30, 35, 100]\nb0Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Float(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization, xb)\n}\n\nprettyPrint(b0Values) \/\/ Contains `[1.0, 2.0, 3.0]`.\n\n\/\/\/ Create the double-precision coefficient matrix _A1_.\nlet a1Values: [Float] = [5, 10, 2.5, 25]\nlet A1 = SparseConvertFromCoordinate(3, 3,\n                                     4, 1,\n                                     SparseAttributes_t(),\n                                     rowIndices, columnIndices,\n                                     a1Values)\n\n\/\/\/ Factorize _A1_ into the existing factorization.\nlet numericFactorOptions = SparseNumericFactorOptions()\nSparseRefactor(A1, &factorization,\n               numericFactorOptions)\n\n\/\/\/ Solve _A1 · x = b1_ in place.\nvar b1Values: [Float] = [60, 70, 200]\nb1Values.withUnsafeMutableBufferPointer { bPtr in\n    let xb = DenseVector_Float(count: 3,\n                               data: bPtr.baseAddress!)\n    \n    SparseSolve(factorization, xb)\n}\n\nprettyPrint(b1Values) \/\/ Contains `[4.0, 8.0, 12.0]`.\n\nSparseCleanup(A0)\nSparseCleanup(A1)\nSparseCleanup(factorization)\n```\n\nOn return, `b0Values` contains the values `[1.0, 2.0, 3.0]`, and `b1Values` contains the values `[4.0, 8.0, 12.0]`.\n\n## Matrix Refactorization Functions\n\n- **SparseRefactor(_:_:)**: Computes a factorization of the specified double-precision matrix using an existing factorization’s storage.\n- **SparseRefactor(_:_:)**: Computes a factorization of the specified single-precision matrix using an existing factorization’s storage.\n- **SparseRefactor(_:_:_:)**: Computes a factorization of the specified double-precision matrix using an existing factorization’s storage and specified options.\n- **SparseRefactor(_:_:)**: Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values.\n- **SparseRefactor(_:_:)**: Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values.\n- **SparseRefactor(_:_:_:)**: Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values, using different options.\n- **SparseRefactor(_:_:_:)**: Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values, using different options.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Computes a factorization of the specified double-precision matrix using an existing factorization’s storage.",
          "name" : "SparseRefactor(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:)-8vrf5"
        },
        {
          "description" : "Computes a factorization of the specified single-precision matrix using an existing factorization’s storage.",
          "name" : "SparseRefactor(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:)-21q4x"
        },
        {
          "description" : "Computes a factorization of the specified double-precision matrix using an existing factorization’s storage and specified options.",
          "name" : "SparseRefactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-6ttkd"
        },
        {
          "description" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values.",
          "name" : "SparseRefactor(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:)-mgni"
        },
        {
          "description" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values.",
          "name" : "SparseRefactor(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:)-zegz"
        },
        {
          "description" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex float values, using different options.",
          "name" : "SparseRefactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-4chx2"
        },
        {
          "description" : "Reuses supplied factorization object’s storage to compute a new factorization of the supplied matrix of complex double values, using different options.",
          "name" : "SparseRefactor(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-q0va"
        }
      ],
      "title" : "Matrix Refactorization Functions"
    }
  ],
  "source" : "appleJSON",
  "title" : "SparseRefactor(_:_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/SparseRefactor(_:_:_:)-2ovxs"
}