{
  "abstract" : "Use 1D fast Fourier transform to compute the frequency components of a signal.",
  "codeExamples" : [
    {
      "code" : "static func synthesizeSignal(frequencyAmplitudePairs: [(f: Float, a: Float)],\n                             count: Int) -> [Float] {\n    \n    let tau: Float = .pi * 2\n    let signal: [Float] = (0 ..< count).map { index in\n        frequencyAmplitudePairs.reduce(0) { accumulator, frequenciesAmplitudePair in\n            let normalizedIndex = Float(index) \/ Float(count)\n            return accumulator + sin(normalizedIndex * frequenciesAmplitudePair.f * tau) * frequenciesAmplitudePair.a\n        }\n    }\n    \n    return signal\n}",
      "language" : "swift"
    },
    {
      "code" : "let n = vDSP_Length(2048)\n\nlet frequencyAmplitudePairs = [(f: Float(2), a: Float(0.8)),\n                               (f: Float(7), a: Float(1.2)),\n                               (f: Float(24), a: Float(0.7)),\n                               (f: Float(50), a: Float(1.0))]\n\nlet signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: Int(n))",
      "language" : "swift"
    },
    {
      "code" : "let log2n = vDSP_Length(log2(Float(n)))\n\nguard let fftSetUp = vDSP.FFT(log2n: log2n,\n                              radix: .radix2,\n                              ofType: DSPSplitComplex.self) else {\n                                fatalError(\"Can't create FFT Setup.\")\n}",
      "language" : "swift"
    },
    {
      "code" : "let halfN = Int(n \/ 2)\n        \nvar forwardInputReal = [Float](repeating: 0,\n                               count: halfN)\nvar forwardInputImag = [Float](repeating: 0,\n                               count: halfN)\nvar forwardOutputReal = [Float](repeating: 0,\n                                count: halfN)\nvar forwardOutputImag = [Float](repeating: 0,\n                                count: halfN)",
      "language" : "swift"
    },
    {
      "code" : "forwardInputReal.withUnsafeMutableBufferPointer { forwardInputRealPtr in\n    forwardInputImag.withUnsafeMutableBufferPointer { forwardInputImagPtr in\n        forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in\n            forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in\n                \n                \/\/ Create a `DSPSplitComplex` to contain the signal.\n                var forwardInput = DSPSplitComplex(realp: forwardInputRealPtr.baseAddress!,\n                                                   imagp: forwardInputImagPtr.baseAddress!)\n                \n                \/\/ Convert the real values in `signal` to complex numbers.\n                signal.withUnsafeBytes {\n                    vDSP.convert(interleavedComplexVector: [DSPComplex]($0.bindMemory(to: DSPComplex.self)),\n                                 toSplitComplexVector: &forwardInput)\n                }\n                \n                \/\/ Create a `DSPSplitComplex` to receive the FFT result.\n                var forwardOutput = DSPSplitComplex(realp: forwardOutputRealPtr.baseAddress!,\n                                                    imagp: forwardOutputImagPtr.baseAddress!)\n                \n                \/\/ Perform the forward FFT.\n                fftSetUp.forward(input: forwardInput,\n                                 output: &forwardOutput)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let autospectrum = [Float](unsafeUninitializedCapacity: halfN) {\n    autospectrumBuffer, initializedCount in\n    \n    \/\/ The `vDSP_zaspec` function accumulates its output. Clear the\n    \/\/ uninitialized `autospectrumBuffer` before computing the spectrum.\n    vDSP.clear(&autospectrumBuffer)\n    \n    forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in\n        forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in\n            \n            var frequencyDomain = DSPSplitComplex(realp: forwardOutputRealPtr.baseAddress!,\n                                                  imagp: forwardOutputImagPtr.baseAddress!)\n            \n            vDSP_zaspec(&frequencyDomain,\n                        autospectrumBuffer.baseAddress!,\n                        vDSP_Length(halfN))\n        }\n    }\n    initializedCount = halfN\n}",
      "language" : "swift"
    },
    {
      "code" : "let componentFrequencyAmplitudePairs = autospectrum.enumerated().filter {\n    $0.element > 1\n}.map {\n    return ($0.offset, sqrt($0.element) \/ Float(n))\n}\n\n\/\/ Prints:\n\/\/     [\"frequency: 2 | amplitude: 0.80\", \"frequency: 7 | amplitude: 1.20\",\n\/\/      \"frequency: 24 | amplitude: 0.70\", \"frequency: 50 | amplitude: 1.00\"]\"\n\nprint(componentFrequencyAmplitudePairs.map {\n    \"frequency: \\($0.0) | amplitude: \\(String(format: \"%.2f\", $0.1))\"\n})",
      "language" : "swift"
    },
    {
      "code" : "var inverseOutputReal = [Float](repeating: 0,\n                                count: halfN)\nvar inverseOutputImag = [Float](repeating: 0,\n                                count: halfN)\n\nlet recreatedSignal: [Float] = forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in\n    forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in\n        inverseOutputReal.withUnsafeMutableBufferPointer { inverseOutputRealPtr in\n            inverseOutputImag.withUnsafeMutableBufferPointer { inverseOutputImagPtr in\n                \n                \/\/ Create a `DSPSplitComplex` that contains the frequency-domain data.\n                let forwardOutput = DSPSplitComplex(realp: forwardOutputRealPtr.baseAddress!,\n                                                    imagp: forwardOutputImagPtr.baseAddress!)\n                \n                \/\/ Create a `DSPSplitComplex` structure to receive the FFT result.\n                var inverseOutput = DSPSplitComplex(realp: inverseOutputRealPtr.baseAddress!,\n                                                    imagp: inverseOutputImagPtr.baseAddress!)\n                \n                \/\/ Perform the inverse FFT.\n                fftSetUp.inverse(input: forwardOutput,\n                                 output: &inverseOutput)\n                \n                \/\/ Return an array of real values from the FFT result.\n                let scale = 1 \/ Float(n * 2)\n                return [Float](fromSplitComplex: inverseOutput,\n                               scale: scale,\n                               count: Int(n))\n            }\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "816bb6a8dfd5b5d2dc47c61bdd522150ec1399e37636895641d9e51f4153f297",
  "crawledAt" : "2025-12-02T15:37:18Z",
  "id" : "C684C68D-D203-429B-8293-49F18B437F85",
  "kind" : "article",
  "language" : "swift",
  "module" : "Accelerate",
  "overview" : "## Overview\n\nAccelerate’s vDSP module provides functions to perform 1D fast Fourier transforms (FFTs) on vectors of data, such as audio signals. The example below shows an input signal (left) and its frequency domain representation (right) after transforming the signal with a forward FFT.\n\n\n\nYou can inspect the frequency-domain data of a forward FFT to compute the individual sine wave components of a composite wave. The technique described in this article is applicable to many digital signal processing applications, for example, finding the dominant frequencies in a dual-tone multi-frequency (DTMF) signal or removing noise from a signal.\n\n### Synthesize a test signal\n\nThe function below generates a composite sine wave from a supplied array of component frequencies and amplitudes:\n\n### Create the composite signal\n\nCreate an array that contains frequency-amplitude tuples. You define the frequencies as the number of cycles per `n`. The highest measurable frequency, known as the Nyquist frequency, is the element with index `n\/2`, which is `1023` in a zero-based array that contains `2048` elements.\n\nThe code below creates the array, `signal`, that contains four component sine waves:\n\nThe image below is a visualization of composite sine waves in `signal`:\n\n\n\n### Create the FFT setup\n\nCreate a setup object that contains a precalculated weights array of complex exponentials required to perform the FFT operations. The values in the weights array simplify the FFT calculation. Creating this setup object can be expensive, so do it only once, for example, when starting your app. After creating the setup object, you can reuse it later.\n\nThe code below creates a setup object suitable for performing forward and inverse 1D FFTs on a signal containing `n` elements:\n\nYou can use this setup object for similarly sized smaller FFTs. However, using a weights array built for an FFT that processes a large number of elements can degrade performance for an FFT that processes a significantly smaller number of elements.\n\n### Create the source and destination arrays for the forward FFT\n\nThe FFT operates on complex numbers. That is, it operates on numbers that contain a real part and an imaginary part. Create two arrays — one for the real parts and one for the imaginary parts — for the input and output to the FFT operation:\n\nBecause each complex value stores two real values, the length of each array is half that of `signal`.\n\n### Perform the forward FFT\n\nYou use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structures to pass the separate real and imaginary arrays of the input and the output data to the FFT transform function.\n\nThe steps below perform the forward FFT:\n\nThe code below shows how to perform the forward FFT using the steps described above:\n\nOn return, `forwardOutputReal` contains the real parts of the forward FFT, and `forwardOutputImag` contains the imaginary parts of the frequency-domain representation of the original signal.\n\n### Compute component frequencies in the frequency-domain data\n\nUse the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_zaspec] function to compute the autospectrum of the frequency-domain data in the `forwardOutputReal` and `forwardOutputImag` arrays. The autospectrum is the sum of squares of the complex and real parts of each complex frequency-domain element. The code below computes the autospectrum:\n\nThe autospectrum of the forward FFT contains a series of high-magnitude items, rendered as vertical lines in the graph below:\n\n\n\nThe autospectrum values correspond to the frequencies and amplitudes you specified in the `frequencies` array. The code below scales the amplitudes to consider the autospectrum calculation and the inverse-transform step. To learn more about scaling time- and frequency-domain data, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms#Scale-time-and-frequency-domain-data].\n\n### Recreate the original signal\n\nUse an inverse FFT to recreate a signal in the time domain, using the frequency-domain data returned by the forward FFT.\n\nThe steps below perform the inverse FFT:\n\nOn return, `recreatedSignal` is approximately equal to `signal`.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave\ncrawled: 2025-12-02T15:37:18Z\n---\n\n# Finding the component frequencies in a composite sine wave\n\n**Article**\n\nUse 1D fast Fourier transform to compute the frequency components of a signal.\n\n## Overview\n\nAccelerate’s vDSP module provides functions to perform 1D fast Fourier transforms (FFTs) on vectors of data, such as audio signals. The example below shows an input signal (left) and its frequency domain representation (right) after transforming the signal with a forward FFT.\n\n\n\nYou can inspect the frequency-domain data of a forward FFT to compute the individual sine wave components of a composite wave. The technique described in this article is applicable to many digital signal processing applications, for example, finding the dominant frequencies in a dual-tone multi-frequency (DTMF) signal or removing noise from a signal.\n\n### Synthesize a test signal\n\nThe function below generates a composite sine wave from a supplied array of component frequencies and amplitudes:\n\n```swift\nstatic func synthesizeSignal(frequencyAmplitudePairs: [(f: Float, a: Float)],\n                             count: Int) -> [Float] {\n    \n    let tau: Float = .pi * 2\n    let signal: [Float] = (0 ..< count).map { index in\n        frequencyAmplitudePairs.reduce(0) { accumulator, frequenciesAmplitudePair in\n            let normalizedIndex = Float(index) \/ Float(count)\n            return accumulator + sin(normalizedIndex * frequenciesAmplitudePair.f * tau) * frequenciesAmplitudePair.a\n        }\n    }\n    \n    return signal\n}\n```\n\n### Create the composite signal\n\nCreate an array that contains frequency-amplitude tuples. You define the frequencies as the number of cycles per `n`. The highest measurable frequency, known as the Nyquist frequency, is the element with index `n\/2`, which is `1023` in a zero-based array that contains `2048` elements.\n\nThe code below creates the array, `signal`, that contains four component sine waves:\n\n```swift\nlet n = vDSP_Length(2048)\n\nlet frequencyAmplitudePairs = [(f: Float(2), a: Float(0.8)),\n                               (f: Float(7), a: Float(1.2)),\n                               (f: Float(24), a: Float(0.7)),\n                               (f: Float(50), a: Float(1.0))]\n\nlet signal = synthesizeSignal(frequencyAmplitudePairs: frequencyAmplitudePairs,\n                              count: Int(n))\n```\n\nThe image below is a visualization of composite sine waves in `signal`:\n\n\n\n### Create the FFT setup\n\nCreate a setup object that contains a precalculated weights array of complex exponentials required to perform the FFT operations. The values in the weights array simplify the FFT calculation. Creating this setup object can be expensive, so do it only once, for example, when starting your app. After creating the setup object, you can reuse it later.\n\nThe code below creates a setup object suitable for performing forward and inverse 1D FFTs on a signal containing `n` elements:\n\n```swift\nlet log2n = vDSP_Length(log2(Float(n)))\n\nguard let fftSetUp = vDSP.FFT(log2n: log2n,\n                              radix: .radix2,\n                              ofType: DSPSplitComplex.self) else {\n                                fatalError(\"Can't create FFT Setup.\")\n}\n```\n\nYou can use this setup object for similarly sized smaller FFTs. However, using a weights array built for an FFT that processes a large number of elements can degrade performance for an FFT that processes a significantly smaller number of elements.\n\n### Create the source and destination arrays for the forward FFT\n\nThe FFT operates on complex numbers. That is, it operates on numbers that contain a real part and an imaginary part. Create two arrays — one for the real parts and one for the imaginary parts — for the input and output to the FFT operation:\n\n```swift\nlet halfN = Int(n \/ 2)\n        \nvar forwardInputReal = [Float](repeating: 0,\n                               count: halfN)\nvar forwardInputImag = [Float](repeating: 0,\n                               count: halfN)\nvar forwardOutputReal = [Float](repeating: 0,\n                                count: halfN)\nvar forwardOutputImag = [Float](repeating: 0,\n                                count: halfN)\n```\n\nBecause each complex value stores two real values, the length of each array is half that of `signal`.\n\n### Perform the forward FFT\n\nYou use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structures to pass the separate real and imaginary arrays of the input and the output data to the FFT transform function.\n\nThe steps below perform the forward FFT:\n\n1. Create a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure to store a copy of `signal` that’s represented as complex numbers.\n2. Use [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP\/convert(interleavedComplexVector:toSplitComplexVector:)-4lnrf] to convert the real values in `signal` to complex numbers. The conversion stores the even values in `signal` as the real components in `forwardInput`, and the odd values in `signal` as the imaginary components in `forwardInput`.\n3. Create a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure with pointers to `forwardOutputReal` and `forwardOutputImag` to receive the FFT result.\n4. Perform the forward FFT.\n\nThe code below shows how to perform the forward FFT using the steps described above:\n\n```swift\nforwardInputReal.withUnsafeMutableBufferPointer { forwardInputRealPtr in\n    forwardInputImag.withUnsafeMutableBufferPointer { forwardInputImagPtr in\n        forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in\n            forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in\n                \n                \/\/ Create a `DSPSplitComplex` to contain the signal.\n                var forwardInput = DSPSplitComplex(realp: forwardInputRealPtr.baseAddress!,\n                                                   imagp: forwardInputImagPtr.baseAddress!)\n                \n                \/\/ Convert the real values in `signal` to complex numbers.\n                signal.withUnsafeBytes {\n                    vDSP.convert(interleavedComplexVector: [DSPComplex]($0.bindMemory(to: DSPComplex.self)),\n                                 toSplitComplexVector: &forwardInput)\n                }\n                \n                \/\/ Create a `DSPSplitComplex` to receive the FFT result.\n                var forwardOutput = DSPSplitComplex(realp: forwardOutputRealPtr.baseAddress!,\n                                                    imagp: forwardOutputImagPtr.baseAddress!)\n                \n                \/\/ Perform the forward FFT.\n                fftSetUp.forward(input: forwardInput,\n                                 output: &forwardOutput)\n            }\n        }\n    }\n}\n```\n\nOn return, `forwardOutputReal` contains the real parts of the forward FFT, and `forwardOutputImag` contains the imaginary parts of the frequency-domain representation of the original signal.\n\n### Compute component frequencies in the frequency-domain data\n\nUse the [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/vDSP_zaspec] function to compute the autospectrum of the frequency-domain data in the `forwardOutputReal` and `forwardOutputImag` arrays. The autospectrum is the sum of squares of the complex and real parts of each complex frequency-domain element. The code below computes the autospectrum:\n\n```swift\nlet autospectrum = [Float](unsafeUninitializedCapacity: halfN) {\n    autospectrumBuffer, initializedCount in\n    \n    \/\/ The `vDSP_zaspec` function accumulates its output. Clear the\n    \/\/ uninitialized `autospectrumBuffer` before computing the spectrum.\n    vDSP.clear(&autospectrumBuffer)\n    \n    forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in\n        forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in\n            \n            var frequencyDomain = DSPSplitComplex(realp: forwardOutputRealPtr.baseAddress!,\n                                                  imagp: forwardOutputImagPtr.baseAddress!)\n            \n            vDSP_zaspec(&frequencyDomain,\n                        autospectrumBuffer.baseAddress!,\n                        vDSP_Length(halfN))\n        }\n    }\n    initializedCount = halfN\n}\n```\n\nThe autospectrum of the forward FFT contains a series of high-magnitude items, rendered as vertical lines in the graph below:\n\n\n\nThe autospectrum values correspond to the frequencies and amplitudes you specified in the `frequencies` array. The code below scales the amplitudes to consider the autospectrum calculation and the inverse-transform step. To learn more about scaling time- and frequency-domain data, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms#Scale-time-and-frequency-domain-data].\n\n```swift\nlet componentFrequencyAmplitudePairs = autospectrum.enumerated().filter {\n    $0.element > 1\n}.map {\n    return ($0.offset, sqrt($0.element) \/ Float(n))\n}\n\n\/\/ Prints:\n\/\/     [\"frequency: 2 | amplitude: 0.80\", \"frequency: 7 | amplitude: 1.20\",\n\/\/      \"frequency: 24 | amplitude: 0.70\", \"frequency: 50 | amplitude: 1.00\"]\"\n\nprint(componentFrequencyAmplitudePairs.map {\n    \"frequency: \\($0.0) | amplitude: \\(String(format: \"%.2f\", $0.1))\"\n})\n```\n\n### Recreate the original signal\n\nUse an inverse FFT to recreate a signal in the time domain, using the frequency-domain data returned by the forward FFT.\n\nThe steps below perform the inverse FFT:\n\n1. Create the source of the inverse FFT, with pointers to `forwardOutputReal` and `forwardOutputImag`.\n2. Create a [doc:\/\/com.apple.accelerate\/documentation\/Accelerate\/DSPSplitComplex] structure to receive the FFT result.\n3. Perform the inverse FFT.\n4. Return an array of real values from the FFT result. Because the forward transform has a scaling factor of `2` and the inverse transform has a scaling factor of the number of items, divide each result by `2 * n`:\n\n```swift\nvar inverseOutputReal = [Float](repeating: 0,\n                                count: halfN)\nvar inverseOutputImag = [Float](repeating: 0,\n                                count: halfN)\n\nlet recreatedSignal: [Float] = forwardOutputReal.withUnsafeMutableBufferPointer { forwardOutputRealPtr in\n    forwardOutputImag.withUnsafeMutableBufferPointer { forwardOutputImagPtr in\n        inverseOutputReal.withUnsafeMutableBufferPointer { inverseOutputRealPtr in\n            inverseOutputImag.withUnsafeMutableBufferPointer { inverseOutputImagPtr in\n                \n                \/\/ Create a `DSPSplitComplex` that contains the frequency-domain data.\n                let forwardOutput = DSPSplitComplex(realp: forwardOutputRealPtr.baseAddress!,\n                                                    imagp: forwardOutputImagPtr.baseAddress!)\n                \n                \/\/ Create a `DSPSplitComplex` structure to receive the FFT result.\n                var inverseOutput = DSPSplitComplex(realp: inverseOutputRealPtr.baseAddress!,\n                                                    imagp: inverseOutputImagPtr.baseAddress!)\n                \n                \/\/ Perform the inverse FFT.\n                fftSetUp.inverse(input: forwardOutput,\n                                 output: &inverseOutput)\n                \n                \/\/ Return an array of real values from the FFT result.\n                let scale = 1 \/ Float(n * 2)\n                return [Float](fromSplitComplex: inverseOutput,\n                               scale: scale,\n                               count: Int(n))\n            }\n        }\n    }\n}\n```\n\nOn return, `recreatedSignal` is approximately equal to `signal`.\n\n## Fourier and Cosine Transforms\n\n- **Understanding data packing for Fourier transforms**: Format source data for the vDSP Fourier functions, and interpret the results.\n- **Performing Fourier transforms on interleaved-complex data**: Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.\n- **Reducing spectral leakage with windowing**: Multiply signal data by window sequence values when performing transforms with noninteger period signals.\n- **Signal extraction from noise**: Use Accelerate’s discrete cosine transform to remove noise from a signal.\n- **Performing Fourier Transforms on Multiple Signals**: Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.\n- **Halftone descreening with 2D fast Fourier transform**: Reduce or remove periodic artifacts from images.\n- **Fast Fourier transforms**: Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Fourier transforms**: Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.\n- **Discrete Cosine transforms**: Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Format source data for the vDSP Fourier functions, and interpret the results.",
          "name" : "Understanding data packing for Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/understanding-data-packing-for-fourier-transforms"
        },
        {
          "description" : "Optimize discrete Fourier transform (DFT) performance with the vDSP interleaved DFT routines.",
          "name" : "Performing Fourier transforms on interleaved-complex data",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-interleaved-complex-data"
        },
        {
          "description" : "Multiply signal data by window sequence values when performing transforms with noninteger period signals.",
          "name" : "Reducing spectral leakage with windowing",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/reducing-spectral-leakage-with-windowing"
        },
        {
          "description" : "Use Accelerate’s discrete cosine transform to remove noise from a signal.",
          "name" : "Signal extraction from noise",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/signal-extraction-from-noise"
        },
        {
          "description" : "Use Accelerate’s multiple-signal fast Fourier transform (FFT) functions to transform multiple signals with a single function call.",
          "name" : "Performing Fourier Transforms on Multiple Signals",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/performing-fourier-transforms-on-multiple-signals"
        },
        {
          "description" : "Reduce or remove periodic artifacts from images.",
          "name" : "Halftone descreening with 2D fast Fourier transform",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/halftone-descreening-with-2d-fast-fourier-transform"
        },
        {
          "description" : "Transform vectors and matrices of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Fast Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/fast-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain complex values to the frequency domain, and vice versa.",
          "name" : "Discrete Fourier transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-fourier-transforms"
        },
        {
          "description" : "Transform vectors of temporal and spatial domain real values to the frequency domain, and vice versa.",
          "name" : "Discrete Cosine transforms",
          "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/discrete-cosine-transforms"
        }
      ],
      "title" : "Fourier and Cosine Transforms"
    }
  ],
  "source" : "appleJSON",
  "title" : "Finding the component frequencies in a composite sine wave",
  "url" : "https:\/\/developer.apple.com\/documentation\/Accelerate\/finding-the-component-frequencies-in-a-composite-sine-wave"
}