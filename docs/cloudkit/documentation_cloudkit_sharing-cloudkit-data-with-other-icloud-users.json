{
  "abstract" : "Create and share private CloudKit data with other users by implementing the sharing UI.",
  "codeExamples" : [
    {
      "code" : "Topic\n    name (String)\nNote\n    title (String)\n    topic (Reference, pointing to the parent topic)"
    },
    {
      "code" : "newNoteRecord.parent = CKRecord.Reference(record: topicRecord, action: .none)",
      "language" : "swift"
    },
    {
      "code" : "if rootRecord.share != nil {\n    newSharingController(sharedRootRecord: rootRecord, database: database,\n                         completionHandler: completionHandler)\n} else {\n    newSharingController(unsharedRootRecord: rootRecord, database: database, zone: zone,\n                         completionHandler: completionHandler)\n}",
      "language" : "swift"
    },
    {
      "code" : "let sharingController = UICloudSharingController(share: share, container: self)",
      "language" : "swift"
    },
    {
      "code" : "let sharingController = UICloudSharingController { (_, prepareCompletionHandler) in",
      "language" : "swift"
    },
    {
      "code" : "let shareID = CKRecord.ID(recordName: UUID().uuidString, zoneID: zone.zoneID)\nvar share = CKShare(rootRecord: unsharedRootRecord, shareID: shareID)\nshare[CKShare.SystemFieldKey.title] = \"A cool topic to share!\" as CKRecordValue\nshare.publicPermission = .readWrite",
      "language" : "swift"
    },
    {
      "code" : "let modifyRecordsOp = CKModifyRecordsOperation(recordsToSave: [share, unsharedRootRecord], recordIDsToDelete: nil)",
      "language" : "swift"
    },
    {
      "code" : "sharingController.popoverPresentationController?.sourceView = sender as? UIView\nself.rootRecord = topicRecord\nsharingController.delegate = self\nsharingController.availablePermissions = [.allowPublic, .allowReadOnly, .allowReadWrite]\nself.present(sharingController, animated: true) { self.spinner.stopAnimating() }",
      "language" : "swift"
    },
    {
      "code" : "let building = appDelegate.buildZoneCacheIfNeed(for: newUserRecordID)",
      "language" : "swift"
    },
    {
      "code" : "let subscription = CKDatabaseSubscription(subscriptionID: subscriptionID)\nlet notificationInfo = CKSubscription.NotificationInfo()\nnotificationInfo.shouldBadge = true\nnotificationInfo.alertBody = \"Database (\\(subscriptionID)) was changed!\"\nsubscription.notificationInfo = notificationInfo\n\nlet operation = CKModifySubscriptionsOperation(subscriptionsToSave: [subscription], subscriptionIDsToDelete: nil)\noperation.modifySubscriptionsCompletionBlock = { _, _, error in\n    completionHandler(error as NSError?)\n}\n\nadd(operation, to: operationQueue)",
      "language" : "swift"
    },
    {
      "code" : "func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification,\n                            withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {\n    print(\"\\(#function)\")\n    updateWithNotificationUserInfo(notification.request.content.userInfo)\n    completionHandler([])\n}",
      "language" : "swift"
    },
    {
      "code" : "operation.changeTokenUpdatedBlock = { serverChangeToken in\n    self.setServerChangeToken(newToken: serverChangeToken, cloudKitDB: cloudKitDB)\n}",
      "language" : "swift"
    },
    {
      "code" : "let serverChangeToken = getServerChangeToken(for: cloudKitDB)\nlet operation = CKFetchDatabaseChangesOperation(previousServerChangeToken: serverChangeToken)",
      "language" : "swift"
    },
    {
      "code" : "let configuration = CKFetchRecordZoneChangesOperation.ZoneConfiguration()\nconfiguration.previousServerChangeToken = getServerChangeToken()\n\nlet operation = CKFetchRecordZoneChangesOperation(\n    recordZoneIDs: [zone.zoneID], configurationsByRecordZoneID: [zone.zoneID: configuration]\n)",
      "language" : "swift"
    }
  ],
  "contentHash" : "e910904577991bbe9033195ca229486bd04d63821120802919663776cca0a225",
  "crawledAt" : "2025-12-02T15:47:09Z",
  "id" : "0C3430A6-A766-4684-91EB-A03B4C3163BD",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "CloudKit",
  "overview" : "## Overview\n\nAs technology advances, people collaborate with others through cloud-based apps more than ever. They can share digital assets with friends, or invite their colleagues living around the world to work together. To support such use cases, apps need to move user data to the cloud and implement a data-sharing flow that includes features like sharing management, data synchronization, and access control.\n\nThis sample demonstrates how to use CloudKit to implement these features by allowing users to create topic and note records in their private databases and share them with other users. With the CloudKit sharing UI, users can send a share link, stop sharing topics, and manage permissions for a shared topic. Users who accept the share, called *participants*, can view or edit the shared record, or stop participating in the share.\n\nThe sample also demonstrates how to create an in-memory cache for a CloudKit record zone. Because of this local cache, the sample doesn’t have to query the server while navigating the UI within the zone.\n\n### Configure the Sample Code Project\n\nBefore building the sample, perform the following steps in Xcode:\n\nBefore running the sample on a device, configure the device as follows:\n\n### Create a CloudKit Schema for the App\n\nCloudKit apps need to create a schema to define the record types and fields, and [http:\/\/icloud.developer.apple.com\/dashboard\/] is the tool for doing that. For more information, see [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/inspecting-and-editing-an-icloud-container-s-schema].\n\nThe sample uses the following record types and fields:\n\nIn this instance, there is no need to manually create the schema before running the sample because:\n\ncloudkit\/designing-and-creating-a-cloudkit-database\n\nFor real-world apps that use record types at an earlier phase, like creating a [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKQuerySubscription] at the beginning of a launch session, the schema must be ready first.\n\n### Create and Share a Topic\n\nTo create and share a topic with another iCloud user using the sample, follow these steps:\n\nTo discover more features in the CloudKit sharing UI:\n\n### Share a Record\n\nThe sample uses [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingController] to implement the sharing flow. Depending on whether the root record is in a shared state, there are different ways to create a sharing controller.\n\nIf the root record is in a shared state, the sample grabs the `recordID` from the [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKRecord\/share] property of the root record, uses it to fetch the share, which is the associated [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKShare] object, from the server, and calls [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingController\/init(share:container:)] to create a sharing controller.\n\nIf the root record isn’t in a shared state, the sample uses [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingController\/init(preparationHandler:)] to create the sharing controller.\n\nIn the preparation handler, the sample sets up a new `CKShare` object using the root record.\n\nThe sample then saves the share and its root record together using [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKModifyRecordsOperation].\n\nAfter creating the sharing controller, the sample uses the following code to present it:\n\nUsing the sharing UI, users can send a link, stop sharing the record, change the permission for a participant, or quit the flow by closing the UI. According to what users do, the sharing controller may change the root record and its share, and notify the app through the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingControllerDelegate] protocol. To ensure the cached data is consistent with the server truth, the sample implements the following delegate methods:\n\n### Maintain a Local Cache of CloudKit Records\n\nTo avoid fetching data from the server each time the zone view and topic view are about to appear, the sample caches the zones in the container, and the topics and notes in the current zone. The caches are both in-memory because the sample doesn’t tend to add more complexity by introducing a persistence layer. Real-world apps can persist their cache to avoid doing an initial fetch on each launch.\n\nThe sample establishes the local caches with two steps: initial fetch and incremental update. In [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneDelegate\/sceneWillEnterForeground(_:)], the sample checks the account status, and then starts the initial fetch if there isn’t a cache for the current account.\n\nCloudKit notifications trigger the incremental updates. The sample uses [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKDatabaseSubscription] to subscribe to CloudKit database changes.\n\nWith the subscriptions, the sample gets push notifications when the database changes, and starts the incremental update from the following [doc:\/\/com.apple.documentation\/documentation\/UserNotifications\/UNUserNotificationCenterDelegate] method:\n\nThe sample uses [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKFetchDatabaseChangesOperation] to fetch the deleted or changed zones. When doing the fetch, CloudKit provides a `serverChangeToken` ([doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKServerChangeToken]) by calling the operation’s [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKFetchDatabaseChangesOperation\/changeTokenUpdatedBlock]. Apps keep the token and use it as `previousServerChangeToken` for the next fetch.\n\nWhen apps use the token to create and run a CloudKit operation, the token tells the server which portions of the zones to return. If the token is `nil`, the server returns all zones.\n\nAfter gathering the deleted and changed zones, the sample updates the zone cache and makes it consistent with the server truth.\n\nSimilarly, the sample uses [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKFetchRecordZoneChangesOperation] to gather the deleted and changed topic and notes, and uses them to maintain the topic cache.\n\nTo avoid blocking an app’s main queue, CloudKit operations and their callbacks must run on a secondary queue, which can be an app-provided operation queue ([doc:\/\/com.apple.documentation\/documentation\/Foundation\/OperationQueue]), or a private operation queue that CloudKit manages. The sample provides an operation queue to run CloudKit operations and update the cached data when the operations complete. This means the system can access the cached data from different queues: the app’s main queue that reads the data and updates the app UI, and a secondary queue that runs CloudKit operations and updates the data.\n\nTo be thread-safe, the sample serializes data access with a dispatch queue ([doc:\/\/com.apple.documentation\/documentation\/Dispatch\/DispatchQueue]). One caveat of this solution is when the main queue needs to read the cached data while the secondary queue is updating it, the main queue must wait until the data update finishes. If the update takes a long time, it blocks the main queue for a long time, which leads to UI unresponsiveness. Real-world apps using the same method to serialize data access need to update the data quickly enough to avoid this issue.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CloudKit\/sharing-cloudkit-data-with-other-icloud-users\ncrawled: 2025-12-02T15:47:09Z\n---\n\n# Sharing CloudKit Data with Other iCloud Users\n\n**Sample Code**\n\nCreate and share private CloudKit data with other users by implementing the sharing UI.\n\n## Overview\n\nAs technology advances, people collaborate with others through cloud-based apps more than ever. They can share digital assets with friends, or invite their colleagues living around the world to work together. To support such use cases, apps need to move user data to the cloud and implement a data-sharing flow that includes features like sharing management, data synchronization, and access control.\n\nThis sample demonstrates how to use CloudKit to implement these features by allowing users to create topic and note records in their private databases and share them with other users. With the CloudKit sharing UI, users can send a share link, stop sharing topics, and manage permissions for a shared topic. Users who accept the share, called *participants*, can view or edit the shared record, or stop participating in the share.\n\nThe sample also demonstrates how to create an in-memory cache for a CloudKit record zone. Because of this local cache, the sample doesn’t have to query the server while navigating the UI within the zone.\n\n### Configure the Sample Code Project\n\nBefore building the sample, perform the following steps in Xcode:\n\n1. In the General pane of the `CloudKitShare` target, update the Bundle Identifier field with a new identifier.\n2. In the Signing & Capabilities pane, select the applicable team from the Team drop-down menu to let Xcode automatically manage the provisioning profile. See [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev23aab79b4] for details.\n3. Make sure the iCloud capability is present and the CloudKit option is in a selected state, then select the iCloud container with your bundle identifier from step 1 from the Containers list. If the container doesn’t exist, click the Add button (+), enter the container name (iCloud.<*bundle identifier*>), and click OK to let Xcode create the container and associate it with the app.\n4. If you prefer to use a different container, select it from the Containers list, and specify the container identifier when creating the `container` variable in the `AppDelegate` class. An iCloud container identifier is case-sensitive and must begin with “`iCloud.`”.\n\nBefore running the sample on a device, configure the device as follows:\n\n1. Log in with an Apple ID. For the CloudKit private database to synchronize across devices, the Apple ID must be the same on the devices.\n2. Choose Settings > Apple ID > iCloud, and turn on iCloud Drive, if it is off.\n\n### Create a CloudKit Schema for the App\n\nCloudKit apps need to create a schema to define the record types and fields, and [http:\/\/icloud.developer.apple.com\/dashboard\/] is the tool for doing that. For more information, see [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/inspecting-and-editing-an-icloud-container-s-schema].\n\nThe sample uses the following record types and fields:\n\n```\nTopic\n    name (String)\nNote\n    title (String)\n    topic (Reference, pointing to the parent topic)\n```\n\nIn this instance, there is no need to manually create the schema before running the sample because:\n\n- When an app saves a record in the development environment, CloudKit automatically creates the corresponding record type if it doesn’t exist. For more information, see [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/designing-and-creating-a-cloudkit-database].\n\ncloudkit\/designing-and-creating-a-cloudkit-database\n\n- Before saving a record, the sample doesn’t use any record-type information.\n\nFor real-world apps that use record types at an earlier phase, like creating a [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKQuerySubscription] at the beginning of a launch session, the schema must be ready first.\n\n### Create and Share a Topic\n\nTo create and share a topic with another iCloud user using the sample, follow these steps:\n\n1. Prepare two devices, A and B, and log in to each device with a different iCloud account.\n2. Use Xcode to build and run the sample app on the devices. If the system shows an alert that requests permission to use notifications, allow it.\n3. On device A, tap the Zones button to show the zone view, then tap the Edit button and add a zone in the private database.\n4. Tap the new zone to navigate to the topic view, then tap the Edit button and add a topic. Each topic has a Share button on the right.\n5. Tap the Share button to show the CloudKit sharing UI, then follow the UI to send a link to the iCloud account for device B. Try to use Messages because it’s easier to set up.\n6. After receiving the link on device B, tap it to accept and open the share. The sample app launches, and then the shared topic and its zone appear in the shared database.\n\n\n\nTo discover more features in the CloudKit sharing UI:\n\n- On device A, find the shared topic and tap the Share button. Because it’s a shared topic, the sharing UI allows users to stop sharing or to change the permission for a participant.\n- On device B, tap the Share button of the accepted topic. On the participant side, the sharing UI allows users to remove their participation from the topic.\n- On device B, navigate to the shared database’s topic view, then tap the Edit button and add a note under the shared topic. The new note synchronizes within seconds to the private database on device A. (This assumes the topic’s “Anyone with this link can make changes” option is in an enabled state. If the topic’s “Anyone with this link can view” option is in an enabled state, participants have read-only permissions, and can’t add a note under the topic.)\n- On device A, add a note under the shared topic. The note synchronizes within seconds to device B. When creating a note, the sample sets its `parent` property to the topic, so the system automatically shares the note with its parent topic.\n\n```swift\nnewNoteRecord.parent = CKRecord.Reference(record: topicRecord, action: .none)\n```\n\n### Share a Record\n\nThe sample uses [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingController] to implement the sharing flow. Depending on whether the root record is in a shared state, there are different ways to create a sharing controller.\n\n```swift\nif rootRecord.share != nil {\n    newSharingController(sharedRootRecord: rootRecord, database: database,\n                         completionHandler: completionHandler)\n} else {\n    newSharingController(unsharedRootRecord: rootRecord, database: database, zone: zone,\n                         completionHandler: completionHandler)\n}\n```\n\nIf the root record is in a shared state, the sample grabs the `recordID` from the [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKRecord\/share] property of the root record, uses it to fetch the share, which is the associated [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKShare] object, from the server, and calls [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingController\/init(share:container:)] to create a sharing controller.\n\n```swift\nlet sharingController = UICloudSharingController(share: share, container: self)\n```\n\nIf the root record isn’t in a shared state, the sample uses [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingController\/init(preparationHandler:)] to create the sharing controller.\n\n```swift\nlet sharingController = UICloudSharingController { (_, prepareCompletionHandler) in\n```\n\nIn the preparation handler, the sample sets up a new `CKShare` object using the root record.\n\n```swift\nlet shareID = CKRecord.ID(recordName: UUID().uuidString, zoneID: zone.zoneID)\nvar share = CKShare(rootRecord: unsharedRootRecord, shareID: shareID)\nshare[CKShare.SystemFieldKey.title] = \"A cool topic to share!\" as CKRecordValue\nshare.publicPermission = .readWrite\n```\n\nThe sample then saves the share and its root record together using [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKModifyRecordsOperation].\n\n```swift\nlet modifyRecordsOp = CKModifyRecordsOperation(recordsToSave: [share, unsharedRootRecord], recordIDsToDelete: nil)\n```\n\nAfter creating the sharing controller, the sample uses the following code to present it:\n\n```swift\nsharingController.popoverPresentationController?.sourceView = sender as? UIView\nself.rootRecord = topicRecord\nsharingController.delegate = self\nsharingController.availablePermissions = [.allowPublic, .allowReadOnly, .allowReadWrite]\nself.present(sharingController, animated: true) { self.spinner.stopAnimating() }\n```\n\nUsing the sharing UI, users can send a link, stop sharing the record, change the permission for a participant, or quit the flow by closing the UI. According to what users do, the sharing controller may change the root record and its share, and notify the app through the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingControllerDelegate] protocol. To ensure the cached data is consistent with the server truth, the sample implements the following delegate methods:\n\n- [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingControllerDelegate\/cloudSharingControllerDidSaveShare(_:)] — CloudKit calls this method when it successfully shares a topic. When this happens, it creates the share and updates the shared topic and notes on the server, so the sample fetches the changes and updates the local cache.\n- [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingControllerDelegate\/cloudSharingControllerDidStopSharing(_:)] — CloudKit calls this method when users stop sharing a record. When this happens, it removes the share and updates the shared topic and notes on the server, so the sample fetches the changes and updates the local cache.\n- [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICloudSharingControllerDelegate\/cloudSharingController(_:failedToSaveShareWithError:)] — CloudKit calls this method when the sharing controller fails to save a share. When this happens, the sample alerts the error and updates the cached root record to avoid an inconsistent status.\n\n### Maintain a Local Cache of CloudKit Records\n\nTo avoid fetching data from the server each time the zone view and topic view are about to appear, the sample caches the zones in the container, and the topics and notes in the current zone. The caches are both in-memory because the sample doesn’t tend to add more complexity by introducing a persistence layer. Real-world apps can persist their cache to avoid doing an initial fetch on each launch.\n\nThe sample establishes the local caches with two steps: initial fetch and incremental update. In [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneDelegate\/sceneWillEnterForeground(_:)], the sample checks the account status, and then starts the initial fetch if there isn’t a cache for the current account.\n\n```swift\nlet building = appDelegate.buildZoneCacheIfNeed(for: newUserRecordID)\n```\n\nCloudKit notifications trigger the incremental updates. The sample uses [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKDatabaseSubscription] to subscribe to CloudKit database changes.\n\n```swift\nlet subscription = CKDatabaseSubscription(subscriptionID: subscriptionID)\nlet notificationInfo = CKSubscription.NotificationInfo()\nnotificationInfo.shouldBadge = true\nnotificationInfo.alertBody = \"Database (\\(subscriptionID)) was changed!\"\nsubscription.notificationInfo = notificationInfo\n\nlet operation = CKModifySubscriptionsOperation(subscriptionsToSave: [subscription], subscriptionIDsToDelete: nil)\noperation.modifySubscriptionsCompletionBlock = { _, _, error in\n    completionHandler(error as NSError?)\n}\n\nadd(operation, to: operationQueue)\n```\n\nWith the subscriptions, the sample gets push notifications when the database changes, and starts the incremental update from the following [doc:\/\/com.apple.documentation\/documentation\/UserNotifications\/UNUserNotificationCenterDelegate] method:\n\n```swift\nfunc userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification,\n                            withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {\n    print(\"\\(#function)\")\n    updateWithNotificationUserInfo(notification.request.content.userInfo)\n    completionHandler([])\n}\n```\n\nThe sample uses [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKFetchDatabaseChangesOperation] to fetch the deleted or changed zones. When doing the fetch, CloudKit provides a `serverChangeToken` ([doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKServerChangeToken]) by calling the operation’s [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKFetchDatabaseChangesOperation\/changeTokenUpdatedBlock]. Apps keep the token and use it as `previousServerChangeToken` for the next fetch.\n\n```swift\noperation.changeTokenUpdatedBlock = { serverChangeToken in\n    self.setServerChangeToken(newToken: serverChangeToken, cloudKitDB: cloudKitDB)\n}\n```\n\nWhen apps use the token to create and run a CloudKit operation, the token tells the server which portions of the zones to return. If the token is `nil`, the server returns all zones.\n\n```swift\nlet serverChangeToken = getServerChangeToken(for: cloudKitDB)\nlet operation = CKFetchDatabaseChangesOperation(previousServerChangeToken: serverChangeToken)\n```\n\nAfter gathering the deleted and changed zones, the sample updates the zone cache and makes it consistent with the server truth.\n\nSimilarly, the sample uses [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKFetchRecordZoneChangesOperation] to gather the deleted and changed topic and notes, and uses them to maintain the topic cache.\n\n```swift\nlet configuration = CKFetchRecordZoneChangesOperation.ZoneConfiguration()\nconfiguration.previousServerChangeToken = getServerChangeToken()\n\nlet operation = CKFetchRecordZoneChangesOperation(\n    recordZoneIDs: [zone.zoneID], configurationsByRecordZoneID: [zone.zoneID: configuration]\n)\n```\n\nTo avoid blocking an app’s main queue, CloudKit operations and their callbacks must run on a secondary queue, which can be an app-provided operation queue ([doc:\/\/com.apple.documentation\/documentation\/Foundation\/OperationQueue]), or a private operation queue that CloudKit manages. The sample provides an operation queue to run CloudKit operations and update the cached data when the operations complete. This means the system can access the cached data from different queues: the app’s main queue that reads the data and updates the app UI, and a secondary queue that runs CloudKit operations and updates the data.\n\nTo be thread-safe, the sample serializes data access with a dispatch queue ([doc:\/\/com.apple.documentation\/documentation\/Dispatch\/DispatchQueue]). One caveat of this solution is when the main queue needs to read the cached data while the secondary queue is updating it, the main queue must wait until the data update finishes. If the update takes a long time, it blocks the main queue for a long time, which leads to UI unresponsiveness. Real-world apps using the same method to serialize data access need to update the data quickly enough to avoid this issue.\n\n## Collaboration\n\n- **Sharing Core Data objects between iCloud users**: Use Core Data and CloudKit to synchronize data between devices of an iCloud user and share data between different iCloud users.\n- **CKShare**: A specialized record type that manages a collection of shared records.\n- **CKShareTransferRepresentation**: A transfer representation the system uses to share an item.\n- **CKAllowedSharingOptions**: An object that controls participant access and permission options.\n- **CKSystemSharingUIObserver**: An object the system uses to monitor changes in sharing.\n- **UICloudSharingController**: A view controller that presents standard screens for adding and removing people from a CloudKit share record.\n- **CKSharingSupported**: A Boolean value that indicates your app supports CloudKit Sharing.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use Core Data and CloudKit to synchronize data between devices of an iCloud user and share data between different iCloud users.",
          "name" : "Sharing Core Data objects between iCloud users",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/sharing-core-data-objects-between-icloud-users"
        },
        {
          "description" : "A specialized record type that manages a collection of shared records.",
          "name" : "CKShare",
          "url" : "https:\/\/developer.apple.com\/documentation\/CloudKit\/CKShare"
        },
        {
          "description" : "A transfer representation the system uses to share an item.",
          "name" : "CKShareTransferRepresentation",
          "url" : "https:\/\/developer.apple.com\/documentation\/CloudKit\/CKShareTransferRepresentation"
        },
        {
          "description" : "An object that controls participant access and permission options.",
          "name" : "CKAllowedSharingOptions",
          "url" : "https:\/\/developer.apple.com\/documentation\/CloudKit\/CKAllowedSharingOptions"
        },
        {
          "description" : "An object the system uses to monitor changes in sharing.",
          "name" : "CKSystemSharingUIObserver",
          "url" : "https:\/\/developer.apple.com\/documentation\/CloudKit\/CKSystemSharingUIObserver"
        },
        {
          "description" : "A view controller that presents standard screens for adding and removing people from a CloudKit share record.",
          "name" : "UICloudSharingController",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICloudSharingController"
        },
        {
          "description" : "A Boolean value that indicates your app supports CloudKit Sharing.",
          "name" : "CKSharingSupported",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/CKSharingSupported"
        }
      ],
      "title" : "Collaboration"
    }
  ],
  "source" : "appleJSON",
  "title" : "Sharing CloudKit Data with Other iCloud Users",
  "url" : "https:\/\/developer.apple.com\/documentation\/CloudKit\/sharing-cloudkit-data-with-other-icloud-users"
}