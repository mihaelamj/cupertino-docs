{
  "abstract" : "An object that manages the record’s encrypted key-value pairs.",
  "codeExamples" : [
    {
      "code" : "let record = CKRecord(recordType: \"Property\")\n\n\/\/ Encrypt the name of the property's owner.\nrecord.encryptedValues[\"ownerName\"] = \"Maria Ruiz\"\n\n\/\/ Decrypt the name of the property's owner, using the\n\/\/ appropriate data type, and assign it to a local variable.\nvar clientName = record.encryptedValues[\"ownerName\"] as? NSString",
      "language" : "swift"
    }
  ],
  "contentHash" : "e3495a06cf2fc3a54180469acef03ee12d5faf9283924fe23dfa29c55453dc83",
  "crawledAt" : "2025-12-02T17:05:18Z",
  "declaration" : {
    "code" : "@NSCopying var encryptedValues: any CKRecordKeyValueSetting & Sendable { get }",
    "language" : "swift"
  },
  "id" : "63DEBE9A-FBB6-43F2-9A3A-0F0FDB0D4942",
  "kind" : "property",
  "language" : "swift",
  "module" : "CloudKit",
  "overview" : "## Discussion\n\nUse the object this property returns to read and write encrypted key-value pairs that you store on the record. You can encrypt values of any data type that CloudKit supports, except [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKAsset], which is encrypted by default, and [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKRecord\/Reference], which isn’t encrypted so it remains available for server-side use. Only encrypt new fields. CloudKit doesn’t allow encryption on fields that already exist in your app’s schema, or on records that you store in the public database.\n\nCloudKit encrypts the fields’ values on-device before saving them to iCloud, and decrypts the values only after fetching them from the server. When you enable Advanced Data Protection, the encryption keys are available exclusively to the record’s owner and, if the user shares the record, that share’s participants.\n\nThe following example shows how to use `encryptedValues` to encrypt and decrypt a string value:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CloudKit\/CKRecord\/encryptedValues\ncrawled: 2025-12-02T17:05:18Z\n---\n\n# encryptedValues\n\n**Instance Property**\n\nAn object that manages the record’s encrypted key-value pairs.\n\n## Declaration\n\n```swift\n@NSCopying var encryptedValues: any CKRecordKeyValueSetting & Sendable { get }\n```\n\n## Discussion\n\nUse the object this property returns to read and write encrypted key-value pairs that you store on the record. You can encrypt values of any data type that CloudKit supports, except [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKAsset], which is encrypted by default, and [doc:\/\/com.apple.cloudkit\/documentation\/CloudKit\/CKRecord\/Reference], which isn’t encrypted so it remains available for server-side use. Only encrypt new fields. CloudKit doesn’t allow encryption on fields that already exist in your app’s schema, or on records that you store in the public database.\n\n\n\nCloudKit encrypts the fields’ values on-device before saving them to iCloud, and decrypts the values only after fetching them from the server. When you enable Advanced Data Protection, the encryption keys are available exclusively to the record’s owner and, if the user shares the record, that share’s participants.\n\nThe following example shows how to use `encryptedValues` to encrypt and decrypt a string value:\n\n```swift\nlet record = CKRecord(recordType: \"Property\")\n\n\/\/ Encrypt the name of the property's owner.\nrecord.encryptedValues[\"ownerName\"] = \"Maria Ruiz\"\n\n\/\/ Decrypt the name of the property's owner, using the\n\/\/ appropriate data type, and assign it to a local variable.\nvar clientName = record.encryptedValues[\"ownerName\"] as? NSString\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "encryptedValues",
  "url" : "https:\/\/developer.apple.com\/documentation\/CloudKit\/CKRecord\/encryptedValues"
}