{
  "abstract" : "Filter store transactions for changes relevant to the current view.",
  "codeExamples" : [
    {
      "code" : "\/\/ Pass the data model filename to the container’s initializer.\nlet container = PersistentContainer(name: \"DataModel\")\n\n\/\/ Get the persistent store description.\nlet description = container.persistentStoreDescriptions.first\n\n\/\/ Set the persistent history tracking key option.\ndescription?.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)",
      "language" : "swift"
    },
    {
      "code" : "description?.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)",
      "language" : "swift"
    },
    {
      "code" : ".onReceive(NotificationCenter.default.publisher(for: .NSPersistentStoreRemoteChange)\n    .receive(on: DispatchQueue.main)) { _ in\n        fetchRemoteChanges()\n        \n        viewContext.perform {\n            do {\n                try viewContext.save()\n            } catch {\n                print(\"Failed to save changes: \\(error.localizedDescription)\")\n            }\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "class PersistentContainer: NSPersistentContainer {\n    override init(name: String, managedObjectModel model: NSManagedObjectModel) {\n        super.init(name: name, managedObjectModel: model)\n        \n        \/\/ Set the context's name.\n        viewContext.name = \"viewContext\"\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let newItem = ShoppingItem(context: viewContext)\n\n\/\/ Set newItem properties.\n\n\/\/ Set the transaction author.\nviewContext.transactionAuthor = \"addItem\"\n\n\/\/ Perform a save.\nviewContext.perform {\n    do {\n        try viewContext.save()\n        \n        \/\/ Reset the transaction author to prevent misattribution of\n        \/\/ future transactions.\n        viewContext.transactionAuthor = nil\n    } catch {\n        print(\"Failed to save changes:\", error.localizedDescription)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var lastToken: NSPersistentHistoryToken?",
      "language" : "swift"
    },
    {
      "code" : "var lastToken: NSPersistentHistoryToken? = nil {\n    didSet {\n        \/\/ Encode the token.\n        guard let lastToken,\n              let data = try? NSKeyedArchiver.archivedData(withRootObject: lastToken,\n                                                           requiringSecureCoding: true) else {\n            return\n        }\n        \n        do {\n            \/\/ Write the token to disk.\n            try data.write(to: tokenFileURL)\n        } catch {\n            print(\"Failed to write token data:\", error.localizedDescription)\n        }\n    }\n}\n\nlazy var tokenFileURL: URL = {\n    \/\/ Get the URL to the persistent store directory.\n    let url = NSPersistentContainer.defaultDirectoryURL().appendingPathComponent(\"ShoppingList\",\n                                                                                 isDirectory: true)\n    \n    \/\/ Create the directory if it doesn't already exist.\n    if FileManager.default.fileExists(atPath: url.path) == false {\n        do {\n            try FileManager.default.createDirectory(at: url,\n                                                    withIntermediateDirectories: true)\n        } catch {\n            print(\"Failed to create persistent container URL:\", error.localizedDescription)\n        }\n    }\n    \n    \/\/ Append the name of the token data file and return the URL.\n    return url.appendingPathComponent(\"token.data\", isDirectory: false)\n}()",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create a fetch history request with the last token.\nlet fetchHistoryRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: lastToken)\n\n\/\/ Get a background context.\nlet backgroundContext = persistentContainer.newBackgroundContext()\n\n\/\/ Perform the fetch.\nguard let historyResult = await backgroundContext.perform({\n    let historyResult = try? backgroundContext.execute(fetchHistoryRequest) as? NSPersistentHistoryResult\n    return historyResult?.result\n}) else {\n    fatalError(\"Failed to fetch history\")\n}\n\n\/\/ Cast the result as an array of history transactions.\nguard let historyTransactions = historyResult as? [NSPersistentHistoryTransaction] else {\n    fatalError(\"Failed to convert history result to history transactions\")\n}",
      "language" : "swift"
    },
    {
      "code" : "for transaction in history.reversed() {\n    \/\/ Token, date, and transaction number.\n    let token = transaction.token\n    let timestamp = transaction.timestamp\n    let transactionNumber = transaction.transactionNumber\n    \n    \/\/ Transaction source details.\n    let store = transaction.storeID\n    let bundle = transaction.bundleID\n    let process = transaction.processID\n    let context = transaction.contextName ?? \"Unknown context\"\n    let author = transaction.author ?? \"Unknown author\"\n    \n    \/\/ Get the transaction's changes.\n    guard let changes = transaction.changes else { continue }\n}",
      "language" : "swift"
    },
    {
      "code" : "for change in changes {\n    let objectID = change.changedObjectID\n    let changeID = change.changeID\n    let transaction = change.transaction\n    let changeType = change.changeType\n    var changedAttributes = [String]()\n    \n    \/\/ Iterate over the change type to get updated or deleted attributes.\n    switch changeType {\n    case .update:\n        guard let updatedProperties = change.updatedProperties else { break }\n        for property in updatedProperties {\n            changedAttributes.append(property.name)\n        }\n    case .delete:\n        guard let tombstone = change.tombstone else { break }\n        changedAttributes.append(tombstone[\"name\"] as? String ?? \"Unknown name\")\n    default:\n        break\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var filteredTransactions = [NSPersistentHistoryTransaction]()\nfor transaction in transactions {\n    guard let changes = transaction.changes else { continue }\n    \n    let filteredChanges = changes.filter { change -> Bool in\n        ShoppingItem.entity().name == change.changedObjectID.entity.name\n    }\n    \n    if filteredChanges.isEmpty == false {\n        filteredTransactions.append(transaction)\n    }\n    \n    lastToken = transaction.token\n}",
      "language" : "swift"
    },
    {
      "code" : "if filteredTransactions.isEmpty == false {\n    \/\/ Iterate over filtered transactions and merge the changes in the\n    \/\/ object ID notification that you specify.\n    for transaction in filteredTransactions {\n        await persistentContainer.viewContext.perform {\n            self.persistentContainer.viewContext.mergeChanges(\n                fromContextDidSave: transaction.objectIDNotification()\n            )\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var deletedAttributes = [String]()\n\nfor transaction in history.reversed() {\n    guard let changes = transaction.changes else { continue }\n    \n    for change in changes where change.changeType == .delete {\n        if let tombstone = change.tombstone {\n            deletedAttributes.append(tombstone[\"name\"] as? String ?? \"Unknown attribute\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Get the point in time seven days ago.\nlet sevenDaysAgo = Calendar.current.date(byAdding: .day,\n                                         value: -7,\n                                         to: Date())!\n\n\/\/ Create a purge history request to delete history before seven days ago.\nlet purgeHistoryRequest = NSPersistentHistoryChangeRequest.deleteHistory(before: sevenDaysAgo)\n\n\/\/ Get a background context.\nlet backgroundContext = persistentContainer.newBackgroundContext()\n\n\/\/ Execute the request.\nawait backgroundContext.perform {\n    do {\n        try backgroundContext.execute(purgeHistoryRequest)\n    } catch {\n        print(\"Failed to purge history:\", error.localizedDescription)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "9c5fad69a2bcd70b84f0132c4f8bd3139c9d1fa55ed536670c682a16c01313a2",
  "crawledAt" : "2025-12-06T03:05:01Z",
  "id" : "19DD45D8-3A5B-4D9A-8004-D0110E3019B5",
  "kind" : "article",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Overview\n\nUse persistent history tracking to determine what changes have occurred in the store, and to update your view context only as needed.\n\nFor example, consider an app that sometimes shows a list of shopping items, and sometimes shows a list of stores. As the user views the `ShoppingItem` objects from the view context, a background context may download additional `Store` data from a remote source. If the import happens through a batch operation, the save to the store doesn’t generate an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/NSManagedObjectContextDidSave] notification, and the view misses these relevant updates. Alternatively, the background context may save changes to the store that don’t affect the current view—for example, inserting, modifying, or deleting `Store` objects. These changes *do* generate context save events, so your view context processes them even though it doesn’t need to.\n\nPersistent history solves the problem by keeping track of every transaction on the store. You can filter this history for relevant changes and decide how or whether to update a view.\n\n### Enable history tracking for your local store\n\nWhen you create a persistent container, set the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTrackingKey] option on the store description to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] to enable history tracking.\n\nCore Data tracks all changes to your local store.\n\n### Listen for remote changes\n\nIn the persistent container, set the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentStoreRemoteChangeNotificationPostOptionKey] option to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] to enable listening for remote change notifications.\n\nIn your view, add an observer to listen for remote change notifications.\n\n### Provide details about a transaction’s source\n\nEach history transaction automatically includes the originating [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/storeID], [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/bundleID] and [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/processID]. You can supply additional information about the source of a change by setting each managed object context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/name] and [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor].\n\nProvide a unique [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/name] for each context to identify it in the persistent history. The context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/name] becomes the persistent history transaction’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/contextName]. You only need to set this once per context.\n\nYou can also set a [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor] before each context save to differentiate among multiple call sites that modify the same context. The context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor] becomes the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/author] of subsequent persistent history transactions.\n\nReset the context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor] to `nil` after saving the context to prevent misattribution of future transactions.\n\n### Keep track of the most recent history\n\nCreate an instance of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryToken] to keep track of the most recent history.\n\nSave the token to disk so you can track history across app launches and fetch history based on the token.\n\n### Request history\n\nTo request history, use the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest\/fetchHistory(after:)-3rmfm] type method on [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest].\n\nThe following example shows a request to fetch new history since the last time you fetched history and convert the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryResult] to an array of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction]:\n\nAlternatively you can use [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest\/fetchHistory(after:)-qi5b] to get history after a particular date, or after a particular a transaction.\n\n### Read history transactions\n\nEach transaction represents a set of changes. Iterate through the array of transactions to learn their details. The following code loops through the results of the `fetchHistoryRequest` to inspect the properties of each transaction.\n\nA transaction’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/changes] array includes information about multiple changes. A single [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange] represents the insertion, update, or deletion of an object.\n\nIterate through a transaction’s changes to identify each object that changed, the type of change that occurred, and any details about the change.\n\nIn the case of an update, the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange\/updatedProperties] set includes any updated attributes and relationships. In the case of a deletion, the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange\/tombstone] dictionary includes key-value pairs for any attributes marked for preservation after deletion.\n\n### Filter for relevant transactions\n\nFilter the history to narrow it to changes that affect the current view. The following code filters for changes to `ShoppingItem` instances, and it updates the last transaction token as it goes.\n\nRelevant changes may include all changes to a given entity, or more selectively, only changes to those properties that are visible on the screen.\n\n### Merge relevant transactions\n\nTo merge the relevant changes into your view context, first obtain a notification by calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/objectIDNotification()] on the transaction. Then, pass the notification to [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/mergeChanges(fromContextDidSave:)].\n\n### Access attributes of deleted objects\n\nAfter you delete an object from the store, its [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject\/objectID] is no longer relevant. Identify a deleted object by recording select properties in its tombstone.\n\nIn the Core Data model editor, select an attribute. In the data model editor, select the Preserve After Deletion checkbox.\n\n\n\nIn the persistent history, [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeType\/delete] changes include a [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange\/tombstone] dictionary with key-value pairs for any attributes marked for preservation after deletion.\n\n### Purge History\n\nBecause persistent history tracking transactions take up space on disk, determine a clean-up strategy to remove them when you no longer need them. Before you purge history, ensure that your app and its clients have consumed the history they need.\n\nSimilar to fetching history, you can use [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest\/deleteHistory(before:)-5kghb] to delete history older than a token, a transaction, or a date. For example, you can delete all transactions older than seven days:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreData\/consuming-relevant-store-changes\ncrawled: 2025-12-06T03:05:01Z\n---\n\n# Consuming relevant store changes\n\n**Article**\n\nFilter store transactions for changes relevant to the current view.\n\n## Overview\n\nUse persistent history tracking to determine what changes have occurred in the store, and to update your view context only as needed.\n\nFor example, consider an app that sometimes shows a list of shopping items, and sometimes shows a list of stores. As the user views the `ShoppingItem` objects from the view context, a background context may download additional `Store` data from a remote source. If the import happens through a batch operation, the save to the store doesn’t generate an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/NSManagedObjectContextDidSave] notification, and the view misses these relevant updates. Alternatively, the background context may save changes to the store that don’t affect the current view—for example, inserting, modifying, or deleting `Store` objects. These changes *do* generate context save events, so your view context processes them even though it doesn’t need to.\n\nPersistent history solves the problem by keeping track of every transaction on the store. You can filter this history for relevant changes and decide how or whether to update a view.\n\n### Enable history tracking for your local store\n\nWhen you create a persistent container, set the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTrackingKey] option on the store description to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] to enable history tracking.\n\n```swift\n\/\/ Pass the data model filename to the container’s initializer.\nlet container = PersistentContainer(name: \"DataModel\")\n\n\/\/ Get the persistent store description.\nlet description = container.persistentStoreDescriptions.first\n\n\/\/ Set the persistent history tracking key option.\ndescription?.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)\n```\n\nCore Data tracks all changes to your local store.\n\n### Listen for remote changes\n\nIn the persistent container, set the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentStoreRemoteChangeNotificationPostOptionKey] option to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] to enable listening for remote change notifications.\n\n```swift\ndescription?.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)\n```\n\nIn your view, add an observer to listen for remote change notifications.\n\n```swift\n.onReceive(NotificationCenter.default.publisher(for: .NSPersistentStoreRemoteChange)\n    .receive(on: DispatchQueue.main)) { _ in\n        fetchRemoteChanges()\n        \n        viewContext.perform {\n            do {\n                try viewContext.save()\n            } catch {\n                print(\"Failed to save changes: \\(error.localizedDescription)\")\n            }\n        }\n    }\n```\n\n### Provide details about a transaction’s source\n\nEach history transaction automatically includes the originating [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/storeID], [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/bundleID] and [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/processID]. You can supply additional information about the source of a change by setting each managed object context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/name] and [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor].\n\nProvide a unique [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/name] for each context to identify it in the persistent history. The context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/name] becomes the persistent history transaction’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/contextName]. You only need to set this once per context.\n\n```swift\nclass PersistentContainer: NSPersistentContainer {\n    override init(name: String, managedObjectModel model: NSManagedObjectModel) {\n        super.init(name: name, managedObjectModel: model)\n        \n        \/\/ Set the context's name.\n        viewContext.name = \"viewContext\"\n    }\n}\n```\n\nYou can also set a [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor] before each context save to differentiate among multiple call sites that modify the same context. The context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor] becomes the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/author] of subsequent persistent history transactions.\n\n```swift\nlet newItem = ShoppingItem(context: viewContext)\n\n\/\/ Set newItem properties.\n\n\/\/ Set the transaction author.\nviewContext.transactionAuthor = \"addItem\"\n\n\/\/ Perform a save.\nviewContext.perform {\n    do {\n        try viewContext.save()\n        \n        \/\/ Reset the transaction author to prevent misattribution of\n        \/\/ future transactions.\n        viewContext.transactionAuthor = nil\n    } catch {\n        print(\"Failed to save changes:\", error.localizedDescription)\n    }\n}\n```\n\nReset the context’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/transactionAuthor] to `nil` after saving the context to prevent misattribution of future transactions.\n\n### Keep track of the most recent history\n\nCreate an instance of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryToken] to keep track of the most recent history.\n\n```swift\nvar lastToken: NSPersistentHistoryToken?\n```\n\nSave the token to disk so you can track history across app launches and fetch history based on the token.\n\n```swift\nvar lastToken: NSPersistentHistoryToken? = nil {\n    didSet {\n        \/\/ Encode the token.\n        guard let lastToken,\n              let data = try? NSKeyedArchiver.archivedData(withRootObject: lastToken,\n                                                           requiringSecureCoding: true) else {\n            return\n        }\n        \n        do {\n            \/\/ Write the token to disk.\n            try data.write(to: tokenFileURL)\n        } catch {\n            print(\"Failed to write token data:\", error.localizedDescription)\n        }\n    }\n}\n\nlazy var tokenFileURL: URL = {\n    \/\/ Get the URL to the persistent store directory.\n    let url = NSPersistentContainer.defaultDirectoryURL().appendingPathComponent(\"ShoppingList\",\n                                                                                 isDirectory: true)\n    \n    \/\/ Create the directory if it doesn't already exist.\n    if FileManager.default.fileExists(atPath: url.path) == false {\n        do {\n            try FileManager.default.createDirectory(at: url,\n                                                    withIntermediateDirectories: true)\n        } catch {\n            print(\"Failed to create persistent container URL:\", error.localizedDescription)\n        }\n    }\n    \n    \/\/ Append the name of the token data file and return the URL.\n    return url.appendingPathComponent(\"token.data\", isDirectory: false)\n}()\n```\n\n### Request history\n\nTo request history, use the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest\/fetchHistory(after:)-3rmfm] type method on [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest].\n\n\n\nThe following example shows a request to fetch new history since the last time you fetched history and convert the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryResult] to an array of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction]:\n\n```swift\n\/\/ Create a fetch history request with the last token.\nlet fetchHistoryRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: lastToken)\n\n\/\/ Get a background context.\nlet backgroundContext = persistentContainer.newBackgroundContext()\n\n\/\/ Perform the fetch.\nguard let historyResult = await backgroundContext.perform({\n    let historyResult = try? backgroundContext.execute(fetchHistoryRequest) as? NSPersistentHistoryResult\n    return historyResult?.result\n}) else {\n    fatalError(\"Failed to fetch history\")\n}\n\n\/\/ Cast the result as an array of history transactions.\nguard let historyTransactions = historyResult as? [NSPersistentHistoryTransaction] else {\n    fatalError(\"Failed to convert history result to history transactions\")\n}\n```\n\nAlternatively you can use [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest\/fetchHistory(after:)-qi5b] to get history after a particular date, or after a particular a transaction.\n\n### Read history transactions\n\nEach transaction represents a set of changes. Iterate through the array of transactions to learn their details. The following code loops through the results of the `fetchHistoryRequest` to inspect the properties of each transaction.\n\n```swift\nfor transaction in history.reversed() {\n    \/\/ Token, date, and transaction number.\n    let token = transaction.token\n    let timestamp = transaction.timestamp\n    let transactionNumber = transaction.transactionNumber\n    \n    \/\/ Transaction source details.\n    let store = transaction.storeID\n    let bundle = transaction.bundleID\n    let process = transaction.processID\n    let context = transaction.contextName ?? \"Unknown context\"\n    let author = transaction.author ?? \"Unknown author\"\n    \n    \/\/ Get the transaction's changes.\n    guard let changes = transaction.changes else { continue }\n}\n```\n\nA transaction’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/changes] array includes information about multiple changes. A single [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange] represents the insertion, update, or deletion of an object.\n\nIterate through a transaction’s changes to identify each object that changed, the type of change that occurred, and any details about the change.\n\nIn the case of an update, the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange\/updatedProperties] set includes any updated attributes and relationships. In the case of a deletion, the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange\/tombstone] dictionary includes key-value pairs for any attributes marked for preservation after deletion.\n\n```swift\nfor change in changes {\n    let objectID = change.changedObjectID\n    let changeID = change.changeID\n    let transaction = change.transaction\n    let changeType = change.changeType\n    var changedAttributes = [String]()\n    \n    \/\/ Iterate over the change type to get updated or deleted attributes.\n    switch changeType {\n    case .update:\n        guard let updatedProperties = change.updatedProperties else { break }\n        for property in updatedProperties {\n            changedAttributes.append(property.name)\n        }\n    case .delete:\n        guard let tombstone = change.tombstone else { break }\n        changedAttributes.append(tombstone[\"name\"] as? String ?? \"Unknown name\")\n    default:\n        break\n    }\n}\n```\n\n### Filter for relevant transactions\n\nFilter the history to narrow it to changes that affect the current view. The following code filters for changes to `ShoppingItem` instances, and it updates the last transaction token as it goes.\n\n```swift\nvar filteredTransactions = [NSPersistentHistoryTransaction]()\nfor transaction in transactions {\n    guard let changes = transaction.changes else { continue }\n    \n    let filteredChanges = changes.filter { change -> Bool in\n        ShoppingItem.entity().name == change.changedObjectID.entity.name\n    }\n    \n    if filteredChanges.isEmpty == false {\n        filteredTransactions.append(transaction)\n    }\n    \n    lastToken = transaction.token\n}\n```\n\nRelevant changes may include all changes to a given entity, or more selectively, only changes to those properties that are visible on the screen.\n\n### Merge relevant transactions\n\nTo merge the relevant changes into your view context, first obtain a notification by calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryTransaction\/objectIDNotification()] on the transaction. Then, pass the notification to [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/mergeChanges(fromContextDidSave:)].\n\n```swift\nif filteredTransactions.isEmpty == false {\n    \/\/ Iterate over filtered transactions and merge the changes in the\n    \/\/ object ID notification that you specify.\n    for transaction in filteredTransactions {\n        await persistentContainer.viewContext.perform {\n            self.persistentContainer.viewContext.mergeChanges(\n                fromContextDidSave: transaction.objectIDNotification()\n            )\n        }\n    }\n}\n```\n\n### Access attributes of deleted objects\n\nAfter you delete an object from the store, its [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject\/objectID] is no longer relevant. Identify a deleted object by recording select properties in its tombstone.\n\nIn the Core Data model editor, select an attribute. In the data model editor, select the Preserve After Deletion checkbox.\n\n\n\nIn the persistent history, [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeType\/delete] changes include a [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChange\/tombstone] dictionary with key-value pairs for any attributes marked for preservation after deletion.\n\n```swift\nvar deletedAttributes = [String]()\n\nfor transaction in history.reversed() {\n    guard let changes = transaction.changes else { continue }\n    \n    for change in changes where change.changeType == .delete {\n        if let tombstone = change.tombstone {\n            deletedAttributes.append(tombstone[\"name\"] as? String ?? \"Unknown attribute\")\n        }\n    }\n}\n```\n\n### Purge History\n\nBecause persistent history tracking transactions take up space on disk, determine a clean-up strategy to remove them when you no longer need them. Before you purge history, ensure that your app and its clients have consumed the history they need.\n\nSimilar to fetching history, you can use [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentHistoryChangeRequest\/deleteHistory(before:)-5kghb] to delete history older than a token, a transaction, or a date. For example, you can delete all transactions older than seven days:\n\n```swift\n\/\/ Get the point in time seven days ago.\nlet sevenDaysAgo = Calendar.current.date(byAdding: .day,\n                                         value: -7,\n                                         to: Date())!\n\n\/\/ Create a purge history request to delete history before seven days ago.\nlet purgeHistoryRequest = NSPersistentHistoryChangeRequest.deleteHistory(before: sevenDaysAgo)\n\n\/\/ Get a background context.\nlet backgroundContext = persistentContainer.newBackgroundContext()\n\n\/\/ Execute the request.\nawait backgroundContext.perform {\n    do {\n        try backgroundContext.execute(purgeHistoryRequest)\n    } catch {\n        print(\"Failed to purge history:\", error.localizedDescription)\n    }\n}\n```\n\n\n\n## Change processing\n\n- **Accessing data when the store changes**: Guarantee that a context won’t see store changes until you tell it to look.\n- **Persistent history**: Use persistent history tracking to determine what changes have occurred in the store since the enabling of persistent history tracking.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Guarantee that a context won’t see store changes until you tell it to look.",
          "name" : "Accessing data when the store changes",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/accessing-data-when-the-store-changes"
        },
        {
          "description" : "Use persistent history tracking to determine what changes have occurred in the store since the enabling of persistent history tracking.",
          "name" : "Persistent history",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/persistent-history"
        }
      ],
      "title" : "Change processing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Consuming relevant store changes",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/consuming-relevant-store-changes"
}