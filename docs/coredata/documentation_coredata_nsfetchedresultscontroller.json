{
  "abstract" : "A controller that you use to manage the results of a Core Data fetch request and to display data to the user.",
  "codeExamples" : [
    {
      "code" : "\/\/ Get the managed object context from the persistent container.\nlet context = coreDataStack.persistentContainer.viewContext\n\n\/\/ Create a fetch request and sort descriptor for the entity to display\n\/\/ in the table view.\nlet fetchRequest: NSFetchRequest<Item> = Item.fetchRequest()\nlet sortDescriptor = NSSortDescriptor(key: \"name\", ascending: true)\nfetchRequest.sortDescriptors = [sortDescriptor]\n\n\/\/ Initialize the fetched results controller with the fetch request and\n\/\/ managed object context.\nfetchedResultsController = NSFetchedResultsController(\n    fetchRequest: fetchRequest,\n    managedObjectContext: context,\n    sectionNameKeyPath: nil,\n    cacheName: nil)\n\n\/\/ Set the controller's delegate.\nfetchedResultsController?.delegate = self\n\n\/\/ Perform a fetch.\ndo {\n    try fetchedResultsController?.performFetch()\n} catch {\n    \/\/ Handle error appropriately. It's useful to use\n    \/\/ `fatalError(_:file:line:)` during development.\n    fatalError(\"Failed to perform fetch: \\(error.localizedDescription)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Get the number of sections in the table view from the fetched results\n\/\/ controller.\noverride func numberOfSections(in tableView: UITableView) -> Int {\n    fetchedResultsController?.sections?.count ?? 0\n}\n\n\/\/ Get the number of rows in each section of the table view from the fetched results controller.\noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    guard let sectionInfo = fetchedResultsController?.sections?[section] else {\n        return 0\n    }\n    \n    return sectionInfo.numberOfObjects\n}\n\n\/\/ Get table view cells for index paths from the fetched results controller.\noverride func tableView(_ tableView: UITableView,\n                        cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"ItemCell\", for: indexPath)\n    let item = fetchedResultsController?.object(at: indexPath)\n    cell.textLabel?.text = item?.name\n    return cell\n}\n\n\/\/ Get the title of the header for the specified table view section from the\n\/\/ fetched results controller.\noverride func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {\n    guard let sectionInfo = fetchedResultsController?.sections?[section] else {\n        return nil\n    }\n    \n    return sectionInfo.name\n}\n\n\/\/ Get the section index titles from the fetched results controller.\noverride func sectionIndexTitles(for tableView: UITableView) -> [String]? {\n    fetchedResultsController?.sectionIndexTitles\n}\n\n\/\/ Get the section for the specified index title from the fetched\n\/\/ results controller.\noverride func tableView(_ tableView: UITableView,\n                        sectionForSectionIndexTitle title: String,\n                        at index: Int) -> Int {\n    guard let result = fetchedResultsController?.section(forSectionIndexTitle: title,\n                                                         at: index) else {\n        fatalError(\"Failed to locate section for \\(title) at index \\(index)\")\n    }\n    \n    return result\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Obtain a managed object from the fetched objects.\nguard let managedObject = fetchedResultsController?.object(at: IndexPath(index: 0)),\n      \/\/ Get the object's index path before changing it.\n      let beforeIndexPath = fetchedResultsController?.indexPath(forObject: managedObject)\nelse {\n    return\n}\n\n\/\/ Change the object.\nmanagedObject.setValue(\"My Item\", forKey: \"name\")\n\n\/\/ Get the object's index path after changing it.\nif let afterIndexPath = fetchedResultsController?.indexPath(forObject: managedObject),\n   \/\/ Compare the index paths before and after the change.\n   beforeIndexPath.compare(afterIndexPath) == .orderedSame {\n    print(\"Same\")\n}",
      "language" : "swift"
    }
  ],
  "conformsTo" : [
    "CVarArg",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Equatable",
    "Hashable",
    "NSObjectProtocol"
  ],
  "contentHash" : "c9b82adf3a86f0eaa25bc76e521780b3fadf21d3be72859b75025b48568f241e",
  "crawledAt" : "2025-12-04T19:07:25Z",
  "declaration" : {
    "code" : "class NSFetchedResultsController<ResultType> where ResultType : NSFetchRequestResult",
    "language" : "swift"
  },
  "id" : "244F374E-60A9-4833-B073-834C081E589B",
  "kind" : "class",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Overview\n\nWhile you can use table views can in several ways, fetched results controllers primarily assist you with a primary list view. [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView] expects its data source to provide cells as an array of sections made up of rows. You configure a fetched results controller using a *fetch request* — an object that specifies what type of entity to fetch and how to sort the results. You can also add criteria for when to include a specific instance of the entity.\n\nThe fetched results controller efficiently analyzes the result of the fetch request and computes all the information about sections in the result set. It also computes all the information for the index based on the result set.\n\nIn addition, fetched results controllers:\n\nA controller thus effectively has three modes of operation, determined by whether it has a delegate and whether you set the cache file name.\n\n### Using NSFetchedResultsController\n\n#### Creating the fetched results controller\n\nYou typically create an instance of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController] as an instance variable of a table view controller. When you initialize the fetch results controller, you provide four parameters:\n\nAfter creating an instance, you invoke [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/performFetch()] to actually execute the fetch:\n\n#### The controller’s delegate\n\nIf you set a delegate for a fetched results controller, the controller registers to receive change notifications from its managed object context. The controller processes any change in the context that affects the result set or section information and updates the results as necessary. The controller notifies the delegate when result objects change location or when changes occur in sections. For more information, see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsControllerDelegate]. You typically use these methods to update the display of the table view.\n\n#### The cache\n\nWhere possible, a controller uses a cache to avoid the need to repeat work performed in setting up any sections and ordering the contents. The system maintains the cache across launches of your application.\n\nWhen you initialize an instance of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController], you typically specify a cache name. If you don’t specify a cache name, the controller doesn’t cache data. When you create a controller, it looks for an existing cache with the given name:\n\nIf the cache is consistent with the current information, the controller reuses the previously-computed information.\n\nIf the cache isn’t consistent with the current information, then the controller recomputes the required information and updates the cache.\n\nAny time the section and ordering information change, the controller updates cache.\n\nIf you create multiple fetched results controllers with different configurations, such as different sort descriptors, give each configuration a different cache name.\n\nYou can purge a cache using [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/deleteCache(withName:)].\n\n#### Implementing the table view datasource methods\n\nYou ask the object to provide relevant information in your implementation of the table view data source methods:\n\n#### Responding to changes\n\nI[doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController] responds to changes at the model layer, and informs its delegate when result objects change location or when sections change.\n\nIf you allow a user to reorder table rows, then your implementation of the delegate methods must take this into account; see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsControllerDelegate].\n\nThe controller doesn’t show changes until after its managed object context receives a [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/processPendingChanges()] message. Therefore, if you change the value of a managed object’s attribute so that its location in a fetched results controller’s results set changes, its index as reported by the controller won’t typically change until the end of the current event cycle, when the system calls [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/processPendingChanges()]. For example, the following code would log `“same”`:\n\n#### Modifying the fetch request\n\nYou can’t change the fetch request to modify the results. Do the following if you want to change the fetch request:\n\n#### Handling object invalidation\n\nWhen a managed object context notifies the fetched results controller of invalidated *individual* objects, the controller treats these as deleted objects and sends the proper delegate calls.\n\nSimultaneous invalidation of *all* the objects in a managed object context is possible, for example, as a result of calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/reset()], or if you remove a store from the persistent store coordinator. When this happens, [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController] doesn’t invalidate all objects, nor does it send individual notifications for object deletions. Instead, you need to call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/performFetch()] to reset the state of the controller then reload the data in the table view ([doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView\/reloadData()]).\n\n### Subclassing notes\n\nYou create a subclass of this class if you want to customize the creation of sections and index titles. You override [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitle(forSectionName:)] if you want the section index title to be something other than the capitalized first letter of the section name. You override [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitles] if you want the index titles to be something other than the array created by calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitle(forSectionName:)] on all the known sections.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\ncrawled: 2025-12-04T19:07:25Z\n---\n\n# NSFetchedResultsController\n\n**Class**\n\nA controller that you use to manage the results of a Core Data fetch request and to display data to the user.\n\n## Declaration\n\n```swift\nclass NSFetchedResultsController<ResultType> where ResultType : NSFetchRequestResult\n```\n\n## Overview\n\nWhile you can use table views can in several ways, fetched results controllers primarily assist you with a primary list view. [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView] expects its data source to provide cells as an array of sections made up of rows. You configure a fetched results controller using a *fetch request* — an object that specifies what type of entity to fetch and how to sort the results. You can also add criteria for when to include a specific instance of the entity.\n\nThe fetched results controller efficiently analyzes the result of the fetch request and computes all the information about sections in the result set. It also computes all the information for the index based on the result set.\n\nIn addition, fetched results controllers:\n\n- Optionally monitor changes to objects in the associated managed object context, and report changes in the results set to its delegate (see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController#The-controllers-delegate]).\n- Optionally cache the results of its computation to enable redisplaying the same data without repeating the work to fetch it. For more information, see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController#The-cache].\n\nA controller thus effectively has three modes of operation, determined by whether it has a delegate and whether you set the cache file name.\n\n- No tracking: The delegate is `nil`. The controller provides access to the data as it was when it fetched it.\n- Memory-only tracking: the delegate is non-`nil` and the file cache name is `nil`. The controller monitors objects in its result set and updates section and ordering information in response to relevant changes.\n- Full persistent tracking: the delegate and the file cache name are non-`nil`. The controller monitors objects in its result set and updates section and ordering information in response to relevant changes. The controller maintains a persistent cache of the results of its computation.\n\n\n\n### Using NSFetchedResultsController\n\n#### Creating the fetched results controller\n\nYou typically create an instance of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController] as an instance variable of a table view controller. When you initialize the fetch results controller, you provide four parameters:\n\n- A fetch request. This must contain at least one sort descriptor to order the results.\n- A managed object context. The controller uses this context to execute the fetch request.\n- Optionally, a key path on result objects that returns the section name. The controller uses the key path to split the results into sections (passing `nil` indicates that the controller should generate a single section).\n- Optionally, the name of the cache file the controller should use (passing `nil` prevents caching). Using a cache can avoid the overhead of computing the section and index information.\n\nAfter creating an instance, you invoke [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/performFetch()] to actually execute the fetch:\n\n```swift\n\/\/ Get the managed object context from the persistent container.\nlet context = coreDataStack.persistentContainer.viewContext\n\n\/\/ Create a fetch request and sort descriptor for the entity to display\n\/\/ in the table view.\nlet fetchRequest: NSFetchRequest<Item> = Item.fetchRequest()\nlet sortDescriptor = NSSortDescriptor(key: \"name\", ascending: true)\nfetchRequest.sortDescriptors = [sortDescriptor]\n\n\/\/ Initialize the fetched results controller with the fetch request and\n\/\/ managed object context.\nfetchedResultsController = NSFetchedResultsController(\n    fetchRequest: fetchRequest,\n    managedObjectContext: context,\n    sectionNameKeyPath: nil,\n    cacheName: nil)\n\n\/\/ Set the controller's delegate.\nfetchedResultsController?.delegate = self\n\n\/\/ Perform a fetch.\ndo {\n    try fetchedResultsController?.performFetch()\n} catch {\n    \/\/ Handle error appropriately. It's useful to use\n    \/\/ `fatalError(_:file:line:)` during development.\n    fatalError(\"Failed to perform fetch: \\(error.localizedDescription)\")\n}\n```\n\n\n\n#### The controller’s delegate\n\nIf you set a delegate for a fetched results controller, the controller registers to receive change notifications from its managed object context. The controller processes any change in the context that affects the result set or section information and updates the results as necessary. The controller notifies the delegate when result objects change location or when changes occur in sections. For more information, see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsControllerDelegate]. You typically use these methods to update the display of the table view.\n\n#### The cache\n\nWhere possible, a controller uses a cache to avoid the need to repeat work performed in setting up any sections and ordering the contents. The system maintains the cache across launches of your application.\n\nWhen you initialize an instance of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController], you typically specify a cache name. If you don’t specify a cache name, the controller doesn’t cache data. When you create a controller, it looks for an existing cache with the given name:\n\n- If the controller can’t find an appropriate cache, it calculates the required sections and the order of objects within sections. It then writes this information to disk.\n- If it finds a cache with the same name, the controller tests the cache to determine whether its contents are still valid. The controller compares the current entity name, entity version hash, sort descriptors, and section key-path with those stored in the cache, as well as the modification date of the cached information file and the persistent store file.\n\nIf the cache is consistent with the current information, the controller reuses the previously-computed information.\n\nIf the cache isn’t consistent with the current information, then the controller recomputes the required information and updates the cache.\n\nAny time the section and ordering information change, the controller updates cache.\n\nIf you create multiple fetched results controllers with different configurations, such as different sort descriptors, give each configuration a different cache name.\n\nYou can purge a cache using [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/deleteCache(withName:)].\n\n#### Implementing the table view datasource methods\n\nYou ask the object to provide relevant information in your implementation of the table view data source methods:\n\n```swift\n\/\/ Get the number of sections in the table view from the fetched results\n\/\/ controller.\noverride func numberOfSections(in tableView: UITableView) -> Int {\n    fetchedResultsController?.sections?.count ?? 0\n}\n\n\/\/ Get the number of rows in each section of the table view from the fetched results controller.\noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    guard let sectionInfo = fetchedResultsController?.sections?[section] else {\n        return 0\n    }\n    \n    return sectionInfo.numberOfObjects\n}\n\n\/\/ Get table view cells for index paths from the fetched results controller.\noverride func tableView(_ tableView: UITableView,\n                        cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"ItemCell\", for: indexPath)\n    let item = fetchedResultsController?.object(at: indexPath)\n    cell.textLabel?.text = item?.name\n    return cell\n}\n\n\/\/ Get the title of the header for the specified table view section from the\n\/\/ fetched results controller.\noverride func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {\n    guard let sectionInfo = fetchedResultsController?.sections?[section] else {\n        return nil\n    }\n    \n    return sectionInfo.name\n}\n\n\/\/ Get the section index titles from the fetched results controller.\noverride func sectionIndexTitles(for tableView: UITableView) -> [String]? {\n    fetchedResultsController?.sectionIndexTitles\n}\n\n\/\/ Get the section for the specified index title from the fetched\n\/\/ results controller.\noverride func tableView(_ tableView: UITableView,\n                        sectionForSectionIndexTitle title: String,\n                        at index: Int) -> Int {\n    guard let result = fetchedResultsController?.section(forSectionIndexTitle: title,\n                                                         at: index) else {\n        fatalError(\"Failed to locate section for \\(title) at index \\(index)\")\n    }\n    \n    return result\n}\n```\n\n#### Responding to changes\n\nI[doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController] responds to changes at the model layer, and informs its delegate when result objects change location or when sections change.\n\nIf you allow a user to reorder table rows, then your implementation of the delegate methods must take this into account; see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsControllerDelegate].\n\nThe controller doesn’t show changes until after its managed object context receives a [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/processPendingChanges()] message. Therefore, if you change the value of a managed object’s attribute so that its location in a fetched results controller’s results set changes, its index as reported by the controller won’t typically change until the end of the current event cycle, when the system calls [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/processPendingChanges()]. For example, the following code would log `“same”`:\n\n```swift\n\/\/ Obtain a managed object from the fetched objects.\nguard let managedObject = fetchedResultsController?.object(at: IndexPath(index: 0)),\n      \/\/ Get the object's index path before changing it.\n      let beforeIndexPath = fetchedResultsController?.indexPath(forObject: managedObject)\nelse {\n    return\n}\n\n\/\/ Change the object.\nmanagedObject.setValue(\"My Item\", forKey: \"name\")\n\n\/\/ Get the object's index path after changing it.\nif let afterIndexPath = fetchedResultsController?.indexPath(forObject: managedObject),\n   \/\/ Compare the index paths before and after the change.\n   beforeIndexPath.compare(afterIndexPath) == .orderedSame {\n    print(\"Same\")\n}\n```\n\n#### Modifying the fetch request\n\nYou can’t change the fetch request to modify the results. Do the following if you want to change the fetch request:\n\n1. Delete the cache if you’re using one, by calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/deleteCache(withName:)].\n2. Change the fetch request.\n3. Call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/performFetch()].\n\n\n\n#### Handling object invalidation\n\nWhen a managed object context notifies the fetched results controller of invalidated *individual* objects, the controller treats these as deleted objects and sends the proper delegate calls.\n\nSimultaneous invalidation of *all* the objects in a managed object context is possible, for example, as a result of calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/reset()], or if you remove a store from the persistent store coordinator. When this happens, [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController] doesn’t invalidate all objects, nor does it send individual notifications for object deletions. Instead, you need to call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/performFetch()] to reset the state of the controller then reload the data in the table view ([doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView\/reloadData()]).\n\n### Subclassing notes\n\nYou create a subclass of this class if you want to customize the creation of sections and index titles. You override [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitle(forSectionName:)] if you want the section index title to be something other than the capitalized first letter of the section name. You override [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitles] if you want the index titles to be something other than the array created by calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitle(forSectionName:)] on all the known sections.\n\n## Initializing a Fetched Results Controller\n\n- **init(fetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:)**: Returns a fetch request controller initialized using the given arguments.\n- **performFetch()**: Executes the controller’s fetch request.\n\n## Getting Configuration Information\n\n- **fetchRequest**: The fetch request used to do the fetching.\n- **managedObjectContext**: The managed object context used to fetch objects.\n- **sectionNameKeyPath**: The key path of the attribute that determines which section the fetched entity belongs to.\n- **cacheName**: The name of the file used to cache section information.\n- **delegate**: The object that is notified when the fetched results changed.\n- **deleteCache(withName:)**: Deletes the cached section information with the given name.\n\n## Accessing Results\n\n- **fetchedObjects**: The results of the fetch.\n- **object(at:)**: Returns the object at the given index path in the fetch results.\n- **indexPath(forObject:)**: Returns the index path of a given object.\n\n## Querying Section Information\n\n- **sections**: The sections for the fetch results.\n- **section(forSectionIndexTitle:at:)**: Returns the section number for a given section title and index in the section index.\n\n## Configuring Section Information\n\n- **sectionIndexTitle(forSectionName:)**: Returns the corresponding section index entry for a given section name.\n- **sectionIndexTitles**: The array of section index titles.\n\n## Responding to Changes\n\n- **NSFetchedResultsControllerDelegate**: A delegate protocol that describes the methods that the associated fetched results controller calls when the fetch results change.\n- **NSFetchedResultsSectionInfo**: A protocol that defines the interface for section objects vended by a fetched results controller.\n- **NSFetchRequestResultType**: Constants that specify the possible result types a fetch request can return.\n- **NSFetchedResultsChangeType**: Constants that specify the possible types of changes that are reported.\n\n## Fetch requests\n\n- **NSFetchRequest**: A description of search criteria used to retrieve data from a persistent store.\n- **NSAsynchronousFetchRequest**: A fetch request that retrieves results asynchronously and supports progress notification.\n- **NSAsynchronousFetchResult**: A fetch result object that encompasses the response from an executed asynchronous fetch request.\n\n## Inherits From\n\n- NSObject\n\n## Conforms To\n\n- CVarArg\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Equatable\n- Hashable\n- NSObjectProtocol\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a fetch request controller initialized using the given arguments.",
          "name" : "init(fetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/init(fetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:)"
        },
        {
          "description" : "Executes the controller’s fetch request.",
          "name" : "performFetch()",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/performFetch()"
        }
      ],
      "title" : "Initializing a Fetched Results Controller"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The fetch request used to do the fetching.",
          "name" : "fetchRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/fetchRequest"
        },
        {
          "description" : "The managed object context used to fetch objects.",
          "name" : "managedObjectContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/managedObjectContext"
        },
        {
          "description" : "The key path of the attribute that determines which section the fetched entity belongs to.",
          "name" : "sectionNameKeyPath",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/sectionNameKeyPath"
        },
        {
          "description" : "The name of the file used to cache section information.",
          "name" : "cacheName",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/cacheName"
        },
        {
          "description" : "The object that is notified when the fetched results changed.",
          "name" : "delegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/delegate"
        },
        {
          "description" : "Deletes the cached section information with the given name.",
          "name" : "deleteCache(withName:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/deleteCache(withName:)"
        }
      ],
      "title" : "Getting Configuration Information"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The results of the fetch.",
          "name" : "fetchedObjects",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/fetchedObjects"
        },
        {
          "description" : "Returns the object at the given index path in the fetch results.",
          "name" : "object(at:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/object(at:)"
        },
        {
          "description" : "Returns the index path of a given object.",
          "name" : "indexPath(forObject:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/indexPath(forObject:)"
        }
      ],
      "title" : "Accessing Results"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The sections for the fetch results.",
          "name" : "sections",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/sections"
        },
        {
          "description" : "Returns the section number for a given section title and index in the section index.",
          "name" : "section(forSectionIndexTitle:at:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/section(forSectionIndexTitle:at:)"
        }
      ],
      "title" : "Querying Section Information"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns the corresponding section index entry for a given section name.",
          "name" : "sectionIndexTitle(forSectionName:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitle(forSectionName:)"
        },
        {
          "description" : "The array of section index titles.",
          "name" : "sectionIndexTitles",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController\/sectionIndexTitles"
        }
      ],
      "title" : "Configuring Section Information"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A delegate protocol that describes the methods that the associated fetched results controller calls when the fetch results change.",
          "name" : "NSFetchedResultsControllerDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsControllerDelegate"
        },
        {
          "description" : "A protocol that defines the interface for section objects vended by a fetched results controller.",
          "name" : "NSFetchedResultsSectionInfo",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsSectionInfo"
        },
        {
          "description" : "Constants that specify the possible result types a fetch request can return.",
          "name" : "NSFetchRequestResultType",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchRequestResultType"
        },
        {
          "description" : "Constants that specify the possible types of changes that are reported.",
          "name" : "NSFetchedResultsChangeType",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsChangeType"
        }
      ],
      "title" : "Responding to Changes"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A description of search criteria used to retrieve data from a persistent store.",
          "name" : "NSFetchRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchRequest"
        },
        {
          "description" : "A fetch request that retrieves results asynchronously and supports progress notification.",
          "name" : "NSAsynchronousFetchRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSAsynchronousFetchRequest"
        },
        {
          "description" : "A fetch result object that encompasses the response from an executed asynchronous fetch request.",
          "name" : "NSAsynchronousFetchResult",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSAsynchronousFetchResult"
        }
      ],
      "title" : "Fetch requests"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "NSObject"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "NSFetchedResultsController",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSFetchedResultsController"
}