{
  "abstract" : "Guarantee that a context won’t see store changes until you tell it to look.",
  "codeExamples" : [
    {
      "code" : "-com.apple.CoreData.SQLDebug 1",
      "language" : "swift"
    },
    {
      "code" : "CoreData: sql: pragma journal_mode=wal",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Pin the context to the generation that corresponds with the most recent\n\/\/ store transaction.\ndo {\n    try persistentContainer.viewContext.setQueryGenerationFrom(.current)\n} catch {\n    \/\/ Handle the error appropriately.\n    print(\"Failed to pin the context:\", error.localizedDescription)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Unpin the context.\ndo {\n    try persistentContainer.viewContext.setQueryGenerationFrom(nil)\n} catch {\n    \/\/ Handle the error appropriately.\n    print(\"Failed to unpin the context:\", error.localizedDescription)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Advance the context to the generation of the most recent store transaction.\ndo {\n    try persistentContainer.viewContext.setQueryGenerationFrom(.current)\n} catch {\n    \/\/ Handle the error appropriately.\n    print(\"Failed to set the query generation:\", error.localizedDescription)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Refresh existing managed objects.\npersistentContainer.viewContext.refreshAllObjects()",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Alternatively, refresh objects by fetching them again.\nlet request = NSFetchRequest<ShoppingItem>(entityName: \"ShoppingItem\")\nrequest.fetchBatchSize = 10\n\n\/\/ Execute the fetch.\nlet results = await persistentContainer.viewContext.perform {\n    do {\n        return try self.persistentContainer.viewContext.fetch(request)\n    } catch {\n        \/\/ Handle the error appropriately. It's useful to use\n        \/\/ `fatalError(_:file:line:)` during development.\n        fatalError(\"Failed to refresh the objects: \\(error.localizedDescription)\")\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "47c58e26062767c4f8ee96827e64ba0f43e8aa5c79bef030530da065693e65e6",
  "crawledAt" : "2025-12-06T03:05:00Z",
  "id" : "7CC26237-2DF0-4422-A4D6-D68297AEC759",
  "kind" : "article",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Overview\n\nQuery generations give your UI a stable view of data in the database, regardless of changes happening to the store underneath. Whenever you read from a context, you see the same generation, or snapshot, of data until you choose to advance it to a later generation.\n\nUse query generations when you want to isolate your view context from any changes made in the store by background threads in your app, app extensions, CloudKit, or other sources.\n\n### Ensure the correct type and mode for the persistent store\n\nTo use query generations, the persistent store must be an [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSSQLiteStoreType] in write-ahead logging (WAL) journal mode. Core Data creates SQLite stores with WAL mode enabled by default.\n\nQuery generations leverage WAL mode to let you query against the historical state of the database. Core Data appends transactions to a `.sqlite-wal` file, or journal, in the same directory as the main store file. When your context reads from the journal, it starts at the transaction associated with a specific generation, instead of at the most recent transaction.\n\nTo confirm whether a custom store has WAL mode enabled, turn on SQL logging. Choose Product > Scheme > Edit Scheme, then choose the Run action, and add the following line under Arguments Passed on Launch:\n\nRun your app, and look for the following output in the console:\n\nIf you try to use query generations with a store that’s not an [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSSQLiteStoreType] in WAL journal mode, your contexts gracefully revert to unpinned behavior.\n\n### Pin the context to a store generation\n\nBy default, contexts are unpinned, and read from the store at the generation of the most recent transaction. Pinned contexts read from the store at the generation of a specific transaction.\n\nTo pin a context, call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/setQueryGenerationFrom(_:)] and pass an opaque [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken]. The context updates to the specified generation lazily on the next read (fetching or faulting) operation.\n\nUse the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] generation token to pin the context to the generation corresponding to the most recent store transaction. For example, pass the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] generation token when setting up your stack to pin the view context to the first generation that it fetches.\n\nAlternatively, use the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/queryGenerationToken] from another pinned context to align both contexts to the same generation.\n\nTo unpin a context, call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/setQueryGenerationFrom(_:)], passing `nil`.\n\nNested contexts inherit their parent’s generation. They’re implicitly unpinned, but they see data as viewed through the generation of their parent with the addition of their parent’s pending changes.\n\nA generation doesn’t include stores added to the store coordinator after the generation’s creation. Additionally, if you remove a store from the coordinator, don’t try to load data from the deleted store into a context.\n\n### Update the view context to the current store generation\n\nAdvance a context to the generation of the most recent transaction, and pin it there, by calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/setQueryGenerationFrom(_:)] and passing the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] token. The context updates to the specified generation lazily on the next read (fetching or faulting) operation.\n\nAlternatively, update a context’s generation by calling any of the following.\n\nUpdate contexts to the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] generation as soon as a specific generation is no longer needed. Query generations hold a file lock open to maintain the integrity of the journal for the duration of a query generation. Once no contexts refer to a query generation, it expires, and the system can reclaim the journal disk space.\n\n### Refresh objects\n\nRefresh any managed objects registered to the context after you change the context’s query generation or unpin the context. Managed objects don’t automatically refresh, as this behavior may not be desirable and is difficult to revert.\n\nCall [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/refreshAllObjects()] on the context to refresh its existing managed objects.\n\nYou can also refresh your objects by fetching them again. Call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/fetch(_:)-4xeoz] on the context to retrieve a fresh set of managed objects matching your request criteria.\n\nThe fetch reads the journal from the context’s query generation if pinned, or from the most recent transaction if unpinned.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreData\/accessing-data-when-the-store-changes\ncrawled: 2025-12-06T03:05:00Z\n---\n\n# Accessing data when the store changes\n\n**Article**\n\nGuarantee that a context won’t see store changes until you tell it to look.\n\n## Overview\n\nQuery generations give your UI a stable view of data in the database, regardless of changes happening to the store underneath. Whenever you read from a context, you see the same generation, or snapshot, of data until you choose to advance it to a later generation.\n\nUse query generations when you want to isolate your view context from any changes made in the store by background threads in your app, app extensions, CloudKit, or other sources.\n\n### Ensure the correct type and mode for the persistent store\n\nTo use query generations, the persistent store must be an [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSSQLiteStoreType] in write-ahead logging (WAL) journal mode. Core Data creates SQLite stores with WAL mode enabled by default.\n\nQuery generations leverage WAL mode to let you query against the historical state of the database. Core Data appends transactions to a `.sqlite-wal` file, or journal, in the same directory as the main store file. When your context reads from the journal, it starts at the transaction associated with a specific generation, instead of at the most recent transaction.\n\nTo confirm whether a custom store has WAL mode enabled, turn on SQL logging. Choose Product > Scheme > Edit Scheme, then choose the Run action, and add the following line under Arguments Passed on Launch:\n\n```swift\n-com.apple.CoreData.SQLDebug 1\n```\n\nRun your app, and look for the following output in the console:\n\n```swift\nCoreData: sql: pragma journal_mode=wal\n```\n\nIf you try to use query generations with a store that’s not an [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSSQLiteStoreType] in WAL journal mode, your contexts gracefully revert to unpinned behavior.\n\n### Pin the context to a store generation\n\nBy default, contexts are unpinned, and read from the store at the generation of the most recent transaction. Pinned contexts read from the store at the generation of a specific transaction.\n\nTo pin a context, call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/setQueryGenerationFrom(_:)] and pass an opaque [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken]. The context updates to the specified generation lazily on the next read (fetching or faulting) operation.\n\nUse the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] generation token to pin the context to the generation corresponding to the most recent store transaction. For example, pass the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] generation token when setting up your stack to pin the view context to the first generation that it fetches.\n\n```swift\n\/\/ Pin the context to the generation that corresponds with the most recent\n\/\/ store transaction.\ndo {\n    try persistentContainer.viewContext.setQueryGenerationFrom(.current)\n} catch {\n    \/\/ Handle the error appropriately.\n    print(\"Failed to pin the context:\", error.localizedDescription)\n}\n```\n\nAlternatively, use the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/queryGenerationToken] from another pinned context to align both contexts to the same generation.\n\nTo unpin a context, call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/setQueryGenerationFrom(_:)], passing `nil`.\n\n```swift\n\/\/ Unpin the context.\ndo {\n    try persistentContainer.viewContext.setQueryGenerationFrom(nil)\n} catch {\n    \/\/ Handle the error appropriately.\n    print(\"Failed to unpin the context:\", error.localizedDescription)\n}\n```\n\nNested contexts inherit their parent’s generation. They’re implicitly unpinned, but they see data as viewed through the generation of their parent with the addition of their parent’s pending changes.\n\nA generation doesn’t include stores added to the store coordinator after the generation’s creation. Additionally, if you remove a store from the coordinator, don’t try to load data from the deleted store into a context.\n\n### Update the view context to the current store generation\n\nAdvance a context to the generation of the most recent transaction, and pin it there, by calling [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/setQueryGenerationFrom(_:)] and passing the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] token. The context updates to the specified generation lazily on the next read (fetching or faulting) operation.\n\n```swift\n\/\/ Advance the context to the generation of the most recent store transaction.\ndo {\n    try persistentContainer.viewContext.setQueryGenerationFrom(.current)\n} catch {\n    \/\/ Handle the error appropriately.\n    print(\"Failed to set the query generation:\", error.localizedDescription)\n}\n```\n\nAlternatively, update a context’s generation by calling any of the following.\n\n- [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/setQueryGenerationFrom(_:)]\n- [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/save()]\n- [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/mergeChanges(fromContextDidSave:)]\n- [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/mergeChanges(fromRemoteContextSave:into:)]\n- [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/reset()]\n\nUpdate contexts to the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSQueryGenerationToken\/current] generation as soon as a specific generation is no longer needed. Query generations hold a file lock open to maintain the integrity of the journal for the duration of a query generation. Once no contexts refer to a query generation, it expires, and the system can reclaim the journal disk space.\n\n### Refresh objects\n\nRefresh any managed objects registered to the context after you change the context’s query generation or unpin the context. Managed objects don’t automatically refresh, as this behavior may not be desirable and is difficult to revert.\n\nCall [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/refreshAllObjects()] on the context to refresh its existing managed objects.\n\n```swift\n\/\/ Refresh existing managed objects.\npersistentContainer.viewContext.refreshAllObjects()\n```\n\nYou can also refresh your objects by fetching them again. Call [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/fetch(_:)-4xeoz] on the context to retrieve a fresh set of managed objects matching your request criteria.\n\n```swift\n\/\/ Alternatively, refresh objects by fetching them again.\nlet request = NSFetchRequest<ShoppingItem>(entityName: \"ShoppingItem\")\nrequest.fetchBatchSize = 10\n\n\/\/ Execute the fetch.\nlet results = await persistentContainer.viewContext.perform {\n    do {\n        return try self.persistentContainer.viewContext.fetch(request)\n    } catch {\n        \/\/ Handle the error appropriately. It's useful to use\n        \/\/ `fatalError(_:file:line:)` during development.\n        fatalError(\"Failed to refresh the objects: \\(error.localizedDescription)\")\n    }\n}\n```\n\nThe fetch reads the journal from the context’s query generation if pinned, or from the most recent transaction if unpinned.\n\n## Change processing\n\n- **Consuming relevant store changes**: Filter store transactions for changes relevant to the current view.\n- **Persistent history**: Use persistent history tracking to determine what changes have occurred in the store since the enabling of persistent history tracking.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Filter store transactions for changes relevant to the current view.",
          "name" : "Consuming relevant store changes",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/consuming-relevant-store-changes"
        },
        {
          "description" : "Use persistent history tracking to determine what changes have occurred in the store since the enabling of persistent history tracking.",
          "name" : "Persistent history",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/persistent-history"
        }
      ],
      "title" : "Change processing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Accessing data when the store changes",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/accessing-data-when-the-store-changes"
}