{
  "abstract" : "The maximum length of time that may have elapsed since the store previously fetched data before fulfilling a fault issues a new fetch.",
  "codeExamples" : [

  ],
  "contentHash" : "f299b29accce2cedd44380b38ba88f41db5db8e90cf6524ad0d3e66ee148d600",
  "crawledAt" : "2025-12-03T09:35:22Z",
  "declaration" : {
    "code" : "var stalenessInterval: TimeInterval { get set }",
    "language" : "swift"
  },
  "id" : "B06D1E2F-0731-4276-9D4F-06EFD8CEF880",
  "kind" : "property",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Discussion\n\nThe staleness interval controls whether *fulfilling a fault* uses data previously fetched by the application, or issues a new fetch (see also [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/refresh(_:mergeChanges:)]). The staleness interval does *not* affect objects currently in use (that is, it is *not* used to automatically update property values from a persistent store after a certain period of time).\n\nThe expiration value is applied on a per object basis. It is the relative time until cached data (snapshots) should be considered stale. For example, a value of 300.0 informs the context to utilize cached information for no more than 5 minutes after an object was originally fetched.\n\nNote that the staleness interval is a hint and may not be supported by all persistent store types. It is not used by XML and binary stores, because these stores maintain all current values in memory.\n\nThe default is a negative value, which represents infinite staleness allowed. `0.0` represents “no staleness acceptable”.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreData\/NSManagedObjectContext\/stalenessInterval\ncrawled: 2025-12-03T09:35:22Z\n---\n\n# stalenessInterval\n\n**Instance Property**\n\nThe maximum length of time that may have elapsed since the store previously fetched data before fulfilling a fault issues a new fetch.\n\n## Declaration\n\n```swift\nvar stalenessInterval: TimeInterval { get set }\n```\n\n## Discussion\n\nThe staleness interval controls whether *fulfilling a fault* uses data previously fetched by the application, or issues a new fetch (see also [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObjectContext\/refresh(_:mergeChanges:)]). The staleness interval does *not* affect objects currently in use (that is, it is *not* used to automatically update property values from a persistent store after a certain period of time).\n\nThe expiration value is applied on a per object basis. It is the relative time until cached data (snapshots) should be considered stale. For example, a value of 300.0 informs the context to utilize cached information for no more than 5 minutes after an object was originally fetched.\n\nNote that the staleness interval is a hint and may not be supported by all persistent store types. It is not used by XML and binary stores, because these stores maintain all current values in memory.\n\nThe default is a negative value, which represents infinite staleness allowed. `0.0` represents “no staleness acceptable”.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "stalenessInterval",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/NSManagedObjectContext\/stalenessInterval"
}