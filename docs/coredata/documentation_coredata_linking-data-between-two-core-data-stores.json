{
  "abstract" : "Organize data in two different stores and implement a link between them.",
  "codeExamples" : [
    {
      "code" : "let container = NSPersistentContainer(name: \"CoreDataFetchedProperty\")\nlet defaultDirectoryURL = NSPersistentContainer.defaultDirectoryURL()\n\nlet bookStoreURL = defaultDirectoryURL.appendingPathComponent(\"Books.sqlite\")\nlet bookStoreDescription = NSPersistentStoreDescription(url: bookStoreURL)\nbookStoreDescription.configuration = \"Book\"\n\nlet feedbackStoreURL = defaultDirectoryURL.appendingPathComponent(\"Feedback.sqlite\")\nlet feedbackStoreDescription = NSPersistentStoreDescription(url: feedbackStoreURL)\nfeedbackStoreDescription.configuration = \"Feedback\"\n\ncontainer.persistentStoreDescriptions = [bookStoreDescription, feedbackStoreDescription]\ncontainer.loadPersistentStores(completionHandler: { (_, error) in\n    guard let error = error as NSError? else { return }\n    fatalError(\"###\\(#function): Failed to load persistent stores:\\(error)\")\n})",
      "language" : "swift"
    },
    {
      "code" : "extension Book {\n    var feedbackList: [Feedback]? { \/\/ The accessor of the feedbackList property.\n        return value(forKey: \"feedbackList\") as? [Feedback]\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let feedback = book.feedbackList?[indexPath.row] else { return cell }\nlet rating = Int(feedback.rating)\nlet comment = feedback.comment ?? \"\"",
      "language" : "swift"
    },
    {
      "code" : "context.refresh(book, mergeChanges: true)",
      "language" : "swift"
    }
  ],
  "contentHash" : "482d6bdec80dac5b2144bc9c3365a8615bab6434d01bf2d73a2293a1a031c42d",
  "crawledAt" : "2025-12-04T19:18:28Z",
  "id" : "EA4D4B23-EB6E-4DD3-B6B1-D663B8B241BE",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Overview\n\nSometimes your app needs to work with multiple Core Data stores. For example, if you need to label data in a read-only store, you must write the labeling result to a different store. If you need to synchronize part of a large data set to iCloud, your app can organize the data in two stores to mirror one to CloudKit and keep the other on the local device.\n\nThis sample app shows how to manage and link data from two different stores with one Core Data stack. The app organizes the records of books and user feedback on the books into two separate stores. It connects two entities from the stores with a fetched property, which enables the app to access a book’s feedback directly. When users add or remove a feedback record and save the change, the app updates the fetched property by refreshing the book object.\n\n### Configure the Data Model\n\nThe sample app creates a `Book` entity and a `Feedback` entity in the Core Data model, and then creates one `Configuration` for each store, named `Book` and `Feedback` as well, to contain the store’s entity.\n\nTo link the entities, the sample app adds a fetched property, `feedbackList`, in the `Book` entity, which is displayed in the entity’s Fetched Properties section in Xcode. The fetched property’s target is set to the `Feedback` entity and its predicate is `bookUUID == $FETCH_SOURCE.uuid`, where `bookUUID` is a key path of the target and `$FETCH_SOURCE` will be replaced with the source of the fetched property, which is the `Book` object in this sample. With this setup, when the app refreshes a `Book` object and accesses its `feedbackList` property, Core Data executes an `NSFetchRequest` with the predicate on the `Feedback` entity, and returns the result to the property.\n\n### Set Up the Core Data Stack\n\nThe sample app creates one `NSPersistentStoreDescription` object for each store with the store’s URL and model configuration, then uses `NSPersistentContainer` to load the stores.\n\nWith this setup, when the app fetches or changes data, Core Data automatically routes the request to the right store based on where the entities are.\n\n### Implement the Fetched Property\n\nXcode currently doesn’t generate code for fetched properties, so the sample app adds the following extension to provide the accessor for `feedbackList`.\n\nWith the `feedbackList` accessor, the app can access the fetched property directly.\n\nUnlike a relationship, a fetched property can’t be used in a predicate for `NSFetchRequest`. It isn’t automatically updated when the managed context is saved either. When the sample app saves changes on the `Feedback` entity, the app must refresh the `book` object to update the `book.feedbackList` property.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/coredata\/linking-data-between-two-core-data-stores\ncrawled: 2025-12-04T19:18:28Z\n---\n\n# Linking Data Between Two Core Data Stores\n\n**Sample Code**\n\nOrganize data in two different stores and implement a link between them.\n\n## Overview\n\nSometimes your app needs to work with multiple Core Data stores. For example, if you need to label data in a read-only store, you must write the labeling result to a different store. If you need to synchronize part of a large data set to iCloud, your app can organize the data in two stores to mirror one to CloudKit and keep the other on the local device.\n\nThis sample app shows how to manage and link data from two different stores with one Core Data stack. The app organizes the records of books and user feedback on the books into two separate stores. It connects two entities from the stores with a fetched property, which enables the app to access a book’s feedback directly. When users add or remove a feedback record and save the change, the app updates the fetched property by refreshing the book object.\n\n### Configure the Data Model\n\nThe sample app creates a `Book` entity and a `Feedback` entity in the Core Data model, and then creates one `Configuration` for each store, named `Book` and `Feedback` as well, to contain the store’s entity.\n\nTo link the entities, the sample app adds a fetched property, `feedbackList`, in the `Book` entity, which is displayed in the entity’s Fetched Properties section in Xcode. The fetched property’s target is set to the `Feedback` entity and its predicate is `bookUUID == $FETCH_SOURCE.uuid`, where `bookUUID` is a key path of the target and `$FETCH_SOURCE` will be replaced with the source of the fetched property, which is the `Book` object in this sample. With this setup, when the app refreshes a `Book` object and accesses its `feedbackList` property, Core Data executes an `NSFetchRequest` with the predicate on the `Feedback` entity, and returns the result to the property.\n\n### Set Up the Core Data Stack\n\nThe sample app creates one `NSPersistentStoreDescription` object for each store with the store’s URL and model configuration, then uses `NSPersistentContainer` to load the stores.\n\n```swift\nlet container = NSPersistentContainer(name: \"CoreDataFetchedProperty\")\nlet defaultDirectoryURL = NSPersistentContainer.defaultDirectoryURL()\n\nlet bookStoreURL = defaultDirectoryURL.appendingPathComponent(\"Books.sqlite\")\nlet bookStoreDescription = NSPersistentStoreDescription(url: bookStoreURL)\nbookStoreDescription.configuration = \"Book\"\n\nlet feedbackStoreURL = defaultDirectoryURL.appendingPathComponent(\"Feedback.sqlite\")\nlet feedbackStoreDescription = NSPersistentStoreDescription(url: feedbackStoreURL)\nfeedbackStoreDescription.configuration = \"Feedback\"\n\ncontainer.persistentStoreDescriptions = [bookStoreDescription, feedbackStoreDescription]\ncontainer.loadPersistentStores(completionHandler: { (_, error) in\n    guard let error = error as NSError? else { return }\n    fatalError(\"###\\(#function): Failed to load persistent stores:\\(error)\")\n})\n```\n\nWith this setup, when the app fetches or changes data, Core Data automatically routes the request to the right store based on where the entities are.\n\n### Implement the Fetched Property\n\nXcode currently doesn’t generate code for fetched properties, so the sample app adds the following extension to provide the accessor for `feedbackList`.\n\n```swift\nextension Book {\n    var feedbackList: [Feedback]? { \/\/ The accessor of the feedbackList property.\n        return value(forKey: \"feedbackList\") as? [Feedback]\n    }\n}\n```\n\nWith the `feedbackList` accessor, the app can access the fetched property directly.\n\n```swift\nguard let feedback = book.feedbackList?[indexPath.row] else { return cell }\nlet rating = Int(feedback.rating)\nlet comment = feedback.comment ?? \"\"\n```\n\nUnlike a relationship, a fetched property can’t be used in a predicate for `NSFetchRequest`. It isn’t automatically updated when the managed context is saved either. When the sample app saves changes on the `Feedback` entity, the app must refresh the `book` object to update the `book.feedbackList` property.\n\n```swift\ncontext.refresh(book, mergeChanges: true)\n```\n\n## Essentials\n\n- **Creating a Core Data model**: Define your app’s object structure with a data model file.\n- **Setting up a Core Data stack**: Set up the classes that manage and persist your app’s objects.\n- **Core Data stack**: Manage and persist your app’s model layer.\n- **Handling Different Data Types in Core Data**: Create, store, and present records for a variety of data types.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Define your app’s object structure with a data model file.",
          "name" : "Creating a Core Data model",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/creating-a-core-data-model"
        },
        {
          "description" : "Set up the classes that manage and persist your app’s objects.",
          "name" : "Setting up a Core Data stack",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/setting-up-a-core-data-stack"
        },
        {
          "description" : "Manage and persist your app’s model layer.",
          "name" : "Core Data stack",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/core-data-stack"
        },
        {
          "description" : "Create, store, and present records for a variety of data types.",
          "name" : "Handling Different Data Types in Core Data",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/handling-different-data-types-in-core-data"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Linking Data Between Two Core Data Stores",
  "url" : "https:\/\/developer.apple.com\/documentation\/coredata\/linking-data-between-two-core-data-stores"
}