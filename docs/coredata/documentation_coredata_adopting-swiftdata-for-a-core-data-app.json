{
  "abstract" : "Persist data in your app intuitively with the Swift native persistence framework.",
  "codeExamples" : [
    {
      "code" : "@Model class Trip {\n    #Index<Trip>([\\.name], [\\.startDate], [\\.endDate], [\\.name, \\.startDate, \\.endDate])\n    #Unique<Trip>([\\.name, \\.startDate, \\.endDate])\n    \n    @Attribute(.preserveValueOnDeletion)\n    var name: String\n    var destination: String\n    \n    @Attribute(.preserveValueOnDeletion)\n    var startDate: Date\n    \n    @Attribute(.preserveValueOnDeletion)\n    var endDate: Date\n\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListItem.trip)\n    var bucketList: [BucketListItem] = [BucketListItem]()\n    \n    @Relationship(deleteRule: .cascade, inverse: \\LivingAccommodation.trip)\n    var livingAccommodation: LivingAccommodation?\n    ...",
      "language" : "swift"
    },
    {
      "code" : ".modelContainer(modelContainer)",
      "language" : "swift"
    },
    {
      "code" : "@Environment(\\.modelContext) private var modelContext",
      "language" : "swift"
    },
    {
      "code" : "if newTripSegment == .personal {\n    newTrip = PersonalTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, reason: reason)\n} else if newTripSegment == .business {\n    newTrip = BusinessTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, perdiem: perdiem)\n} else {\n    newTrip = Trip(name: name, destination: destination, startDate: startDate, endDate: endDate)\n}\nmodelContext.insert(newTrip)",
      "language" : "swift"
    },
    {
      "code" : "modelContext.delete(trip)",
      "language" : "swift"
    },
    {
      "code" : "@Query(sort: \\Trip.startDate, order: .forward)\nvar trips: [Trip]",
      "language" : "swift"
    },
    {
      "code" : "var descriptor = FetchDescriptor<BucketListItem>()\nlet tripName = trip.name\ndescriptor.predicate = #Predicate { item in\n    item.title.contains(searchText) && tripName == item.trip?.name\n}\nlet filteredList = try? modelContext.fetch(descriptor)",
      "language" : "swift"
    },
    {
      "code" : "class PersonalTrip: Trip {...}",
      "language" : "swift"
    },
    {
      "code" : "init(name: String, destination: String, startDate: Date = .now, endDate: Date = .distantFuture, reason: Reason) {\n    self.reason = reason\n    super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)\n}",
      "language" : "swift"
    },
    {
      "code" : "class CDTrip: NSManagedObject {...}",
      "language" : "swift"
    },
    {
      "code" : "let newTrip = CDTrip(context: viewContext)",
      "language" : "swift"
    },
    {
      "code" : "if let description = container.persistentStoreDescriptions.first {\n    description.url = url\n    ...\n}",
      "language" : "swift"
    },
    {
      "code" : "description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)",
      "language" : "swift"
    },
    {
      "code" : "private func findTransactions(after historyToken: DefaultHistoryToken?, author: String) -> [DefaultHistoryTransaction] {...}",
      "language" : "swift"
    },
    {
      "code" : "private func findTrips(in transactions: [DefaultHistoryTransaction]) -> (Set<Trip>, DefaultHistoryToken?) {...}",
      "language" : "swift"
    }
  ],
  "contentHash" : "33134ba8d6bfad54c8747fcca74a5dfc607ad44729ed32772dd747d8588cb050",
  "crawledAt" : "2025-12-02T15:45:20Z",
  "id" : "7BEA6C25-002D-4827-8007-37C1553A2EA0",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Overview\n\nThis sample project is designed to help you understand how to adopt SwiftData in an existing Core Data app. The SampleTrips app fetches and displays all upcoming trips from the store, and allows people to create or remove trips, and to add, update, or remove information from the itinerary for each trip. There are three versions of this app:\n\n### Configure the sample code project\n\nOpen the sample code project in Xcode. Before building it, do the following:\n\n### Adopt SwiftData\n\nThe SwiftData sample sets up the schema with Swift types that conform to the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/PersistentModel] protocol, which captures information about the app’s types, including properties and relationships. Each model file corresponds to an individual entity, with identical entity names, properties, and relationships as its Core Data counterpart.\n\nEach model file in this sample uses the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/Model()] macro to add necessary conformances for the `PersistentModel` and [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable] protocols:\n\nAdditionally, the app sets up the container using [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContainer] to ensure that all views access the same `ModelContainer`.\n\nSetting up the `ModelContainer` also creates and sets a default [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] in the environment. The app can access the `ModelContext` from any scene or view using an environment property.\n\n### Create a persisted data object\n\nThis app creates a new instance of a trip and inserts it into the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] for persistence:\n\n### Persist data\n\nThe app uses the SwiftData implicit save feature to persist data. This implicit save occurs on UI life cycle events and on a timer after the context changes. For more information about enabling autosave, see the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext\/autosaveEnabled] property.\n\nThe app calls [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext\/delete(_:)] on the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] with the instance to delete.\n\n### Fetch persisted data\n\nThis sample app fetches the complete list of upcoming trips by wrapping an array of trips in a [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/Query] macro, which fetches `Trip` objects from the container.\n\nThis sample also fetches data by calling [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext\/fetch(_:)] on the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] and passing in a [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/FetchDescriptor] that specifies both the entity to retrieve data from as well as a corresponding [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate] that specifies the conditions for the object to fetch.\n\n### Inheritance\n\nThe SwiftData-Inheritance version of the app extends the `Trip` class into two distinct kinds of Trips, `PersonalTrip` and `BusinessTrip`, building on the basic `Trip` model to include more specialized properties for different kinds of Trips.\n\nBoth `PersonalTrip` and `BusinessTrip` inherit basic properties from their superclass, `Trip`, while defining their own specialized properties, as shown in the following code. For instance, `PersonalTrip`, has an additional property that describes the reason for the trip.\n\n### Coexistence between Core Data and SwiftData\n\nThe coexistence version of the app has two persistence stacks: a Core Data persistence stack for the host app, and a SwiftData persistence stack for the widget extension. Both stacks write to the same store file.\n\n### Namespace models\n\nThe namespaces in the coexistence sample use the pre-existing [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObject]-based entity subclasses so that they don’t conflict with the SwiftData classes. Note that this refers to the class name, not the entity name.\n\nThe sample then refers to the entity as `CDTrip` when accessing it in the Core Data host app. For instance, when adding a new `Trip`:\n\n### Share the same store file\n\nThis sample ensures that both the Core Data and SwiftData persistent stacks write to the same store file by setting the persistent store URL for the container description:\n\nAdditionally, the coexistence sample must set the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentHistoryTrackingKey]. Although SwiftData enables persistent history tracking automatically, Core Data does not, so the app enables persistent history manually.\n\nBy default, SwiftData behaves in the following way when determining where it persists data:\n\nIn this sample, the main app and widget share the same store via an app group container, and the store is located in the default location in the app group container. To ensure SwiftData accesses the same store, the main app and widget both share the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContainer].\n\n### Detect relevant changes by consuming the SwiftData history\n\nIn the SwiftData version, people can confirm the living accommodation for the current trip by tapping the Accommodation button in the widget. The widget then updates `LivingAccommodation.isConfirmed` in SwiftData, and the main app, when entering the foreground, detects the changes and annotates the trip with a blue dot to indicate that it has unread changes.\n\nThere are multiple options for the main app to detect the changes from the widget:\n\nThe first option introduces a new storage, and hence needs to maintain the consistency between SwiftData and the shared `UserDefaults`. The second option is easier to implement, but introduces and maintains a new attribute, which is redundant and consumes extra storage space; for real-world apps that manage more complicated changes and have larger data set, that may not be the favorite approach.\n\nThis sample chooses to detect the changes with the third option. To do so, it sets up a `HistoryDescriptor<DefaultHistoryTransaction>` with a history token (`DefaultHistoryToken`) and calls `fetchHistory(_:)` to retrieve the history transactions (`DefaultHistoryTransaction`) after the token, as shown in the following code:\n\nAfter getting the transactions, it uses the following code to find the trips that have living accommodation changes:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreData\/adopting-swiftdata-for-a-core-data-app\ncrawled: 2025-12-02T15:45:20Z\n---\n\n# Adopting SwiftData for a Core Data app\n\n**Sample Code**\n\nPersist data in your app intuitively with the Swift native persistence framework.\n\n## Overview\n\nThis sample project is designed to help you understand how to adopt SwiftData in an existing Core Data app. The SampleTrips app fetches and displays all upcoming trips from the store, and allows people to create or remove trips, and to add, update, or remove information from the itinerary for each trip. There are three versions of this app:\n\n- A Core Data version that demonstrates Core Data best practices.\n- A SwiftData version that shows the complete app conversion from Core Data to SwiftData.\n- A coexistence version, where the sample app uses Core Data, and adds a widget extension that uses SwiftData. This version covers a scenario where you might want to adopt SwiftData incrementally, or for certain portions of your app.\n\n### Configure the sample code project\n\nOpen the sample code project in Xcode. Before building it, do the following:\n\n1. Set the developer team for all targets to your team so Xcode automatically manages the provisioning profile. For more information, see [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev23aab79b4].\n2. Replace the App Group container identifier — `group.com.example.apple-samplecode.SampleTrips` — with one specific to your team for the entire project. The identifier points to an App Group container that the app and widget use to share data. You can search for `group.com.example.apple-samplecode.SampleTrips` using the Find navigator in Xcode, and then change all of the occurrences. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/configuring-app-groups].\n\n### Adopt SwiftData\n\nThe SwiftData sample sets up the schema with Swift types that conform to the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/PersistentModel] protocol, which captures information about the app’s types, including properties and relationships. Each model file corresponds to an individual entity, with identical entity names, properties, and relationships as its Core Data counterpart.\n\nEach model file in this sample uses the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/Model()] macro to add necessary conformances for the `PersistentModel` and [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable] protocols:\n\n```swift\n@Model class Trip {\n    #Index<Trip>([\\.name], [\\.startDate], [\\.endDate], [\\.name, \\.startDate, \\.endDate])\n    #Unique<Trip>([\\.name, \\.startDate, \\.endDate])\n    \n    @Attribute(.preserveValueOnDeletion)\n    var name: String\n    var destination: String\n    \n    @Attribute(.preserveValueOnDeletion)\n    var startDate: Date\n    \n    @Attribute(.preserveValueOnDeletion)\n    var endDate: Date\n\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListItem.trip)\n    var bucketList: [BucketListItem] = [BucketListItem]()\n    \n    @Relationship(deleteRule: .cascade, inverse: \\LivingAccommodation.trip)\n    var livingAccommodation: LivingAccommodation?\n    ...\n```\n\nAdditionally, the app sets up the container using [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContainer] to ensure that all views access the same `ModelContainer`.\n\n```swift\n.modelContainer(modelContainer)\n```\n\nSetting up the `ModelContainer` also creates and sets a default [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] in the environment. The app can access the `ModelContext` from any scene or view using an environment property.\n\n```swift\n@Environment(\\.modelContext) private var modelContext\n```\n\n### Create a persisted data object\n\nThis app creates a new instance of a trip and inserts it into the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] for persistence:\n\n```swift\nif newTripSegment == .personal {\n    newTrip = PersonalTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, reason: reason)\n} else if newTripSegment == .business {\n    newTrip = BusinessTrip(name: name, destination: destination, startDate: startDate, endDate: endDate, perdiem: perdiem)\n} else {\n    newTrip = Trip(name: name, destination: destination, startDate: startDate, endDate: endDate)\n}\nmodelContext.insert(newTrip)\n```\n\n### Persist data\n\nThe app uses the SwiftData implicit save feature to persist data. This implicit save occurs on UI life cycle events and on a timer after the context changes. For more information about enabling autosave, see the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext\/autosaveEnabled] property.\n\nThe app calls [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext\/delete(_:)] on the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] with the instance to delete.\n\n```swift\nmodelContext.delete(trip)\n```\n\n### Fetch persisted data\n\nThis sample app fetches the complete list of upcoming trips by wrapping an array of trips in a [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/Query] macro, which fetches `Trip` objects from the container.\n\n```swift\n@Query(sort: \\Trip.startDate, order: .forward)\nvar trips: [Trip]\n```\n\nThis sample also fetches data by calling [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext\/fetch(_:)] on the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContext] and passing in a [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/FetchDescriptor] that specifies both the entity to retrieve data from as well as a corresponding [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate] that specifies the conditions for the object to fetch.\n\n```swift\nvar descriptor = FetchDescriptor<BucketListItem>()\nlet tripName = trip.name\ndescriptor.predicate = #Predicate { item in\n    item.title.contains(searchText) && tripName == item.trip?.name\n}\nlet filteredList = try? modelContext.fetch(descriptor)\n```\n\n### Inheritance\n\nThe SwiftData-Inheritance version of the app extends the `Trip` class into two distinct kinds of Trips, `PersonalTrip` and `BusinessTrip`, building on the basic `Trip` model to include more specialized properties for different kinds of Trips.\n\n```swift\nclass PersonalTrip: Trip {...}\n```\n\nBoth `PersonalTrip` and `BusinessTrip` inherit basic properties from their superclass, `Trip`, while defining their own specialized properties, as shown in the following code. For instance, `PersonalTrip`, has an additional property that describes the reason for the trip.\n\n```swift\ninit(name: String, destination: String, startDate: Date = .now, endDate: Date = .distantFuture, reason: Reason) {\n    self.reason = reason\n    super.init(name: name, destination: destination, startDate: startDate, endDate: endDate)\n}\n```\n\n### Coexistence between Core Data and SwiftData\n\nThe coexistence version of the app has two persistence stacks: a Core Data persistence stack for the host app, and a SwiftData persistence stack for the widget extension. Both stacks write to the same store file.\n\n### Namespace models\n\nThe namespaces in the coexistence sample use the pre-existing [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObject]-based entity subclasses so that they don’t conflict with the SwiftData classes. Note that this refers to the class name, not the entity name.\n\n```swift\nclass CDTrip: NSManagedObject {...}\n```\n\nThe sample then refers to the entity as `CDTrip` when accessing it in the Core Data host app. For instance, when adding a new `Trip`:\n\n```swift\nlet newTrip = CDTrip(context: viewContext)\n```\n\n### Share the same store file\n\nThis sample ensures that both the Core Data and SwiftData persistent stacks write to the same store file by setting the persistent store URL for the container description:\n\n```swift\nif let description = container.persistentStoreDescriptions.first {\n    description.url = url\n    ...\n}\n```\n\nAdditionally, the coexistence sample must set the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentHistoryTrackingKey]. Although SwiftData enables persistent history tracking automatically, Core Data does not, so the app enables persistent history manually.\n\n```swift\ndescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)\n```\n\nBy default, SwiftData behaves in the following way when determining where it persists data:\n\n- It persists data store to the app’s Application Support directory.\n- This sample app uses App Groups to access shared containers and share data between the SwiftData widget extension and the Core Data host app. For an app that has the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.security.application-groups], it persists the data store to the root directory of the app group container. For apps that evolve from a version that doesn’t have any app group container to a version that has one, SwiftData copies the existing store to the app group container.\n\nIn this sample, the main app and widget share the same store via an app group container, and the store is located in the default location in the app group container. To ensure SwiftData accesses the same store, the main app and widget both share the [doc:\/\/com.apple.documentation\/documentation\/SwiftData\/ModelContainer].\n\n### Detect relevant changes by consuming the SwiftData history\n\nIn the SwiftData version, people can confirm the living accommodation for the current trip by tapping the Accommodation button in the widget. The widget then updates `LivingAccommodation.isConfirmed` in SwiftData, and the main app, when entering the foreground, detects the changes and annotates the trip with a blue dot to indicate that it has unread changes.\n\nThere are multiple options for the main app to detect the changes from the widget:\n\n1. Adding a key value pair to the shared `UserDefaults` ([doc:\/\/com.apple.documentation\/documentation\/Foundation\/UserDefaults\/init(suiteName:)] for the widget and the main app to share the changes.\n2. Adding a new attribute in `Trip` so the widget can mark the trip as “unread” when changing the living accommodation status.\n3. Consuming the history of the store, which SwiftData generates by default, and picking up the relevant changes from there.\n\nThe first option introduces a new storage, and hence needs to maintain the consistency between SwiftData and the shared `UserDefaults`. The second option is easier to implement, but introduces and maintains a new attribute, which is redundant and consumes extra storage space; for real-world apps that manage more complicated changes and have larger data set, that may not be the favorite approach.\n\nThis sample chooses to detect the changes with the third option. To do so, it sets up a `HistoryDescriptor<DefaultHistoryTransaction>` with a history token (`DefaultHistoryToken`) and calls `fetchHistory(_:)` to retrieve the history transactions (`DefaultHistoryTransaction`) after the token, as shown in the following code:\n\n```swift\nprivate func findTransactions(after historyToken: DefaultHistoryToken?, author: String) -> [DefaultHistoryTransaction] {...}\n```\n\nAfter getting the transactions, it uses the following code to find the trips that have living accommodation changes:\n\n```swift\nprivate func findTrips(in transactions: [DefaultHistoryTransaction]) -> (Set<Trip>, DefaultHistoryToken?) {...}\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Adopting SwiftData for a Core Data app",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/adopting-swiftdata-for-a-core-data-app"
}