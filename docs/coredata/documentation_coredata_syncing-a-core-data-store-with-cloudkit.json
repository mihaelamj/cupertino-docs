{
  "abstract" : "Synchronize objects between devices, and handle store changes in the user interface.",
  "codeExamples" : [
    {
      "code" : "try? persistentContainer.viewContext.setQueryGenerationFrom(.current)",
      "language" : "swift"
    },
    {
      "code" : "$ log stream --info --debug --predicate 'process = \"cloudd\" and message\ncontains[cd] \"containerID=com.mycontainer\"'",
      "language" : "swift"
    },
    {
      "code" : "$ log stream --info --debug --predicate 'process = \"myprocess\" and \n(subsystem = \"com.apple.coredata\" or subsystem = \"com.apple.cloudkit\")'",
      "language" : "swift"
    },
    {
      "code" : "$ log stream --info --debug --predicate '(process = \"myprocess\" and\n(subsystem = \"com.apple.coredata\" or subsystem = \"com.apple.cloudkit\")) or\n(process = \"cloudd\" and message contains[cd] \"container=com.mycontainer\")'",
      "language" : "swift"
    }
  ],
  "contentHash" : "416a5271acc97c511e8ef954351992c20cce786799b716d09dcbfc0d87a00710",
  "crawledAt" : "2025-12-02T18:49:49Z",
  "id" : "C2B3650B-CD5C-41A3-8B1F-F7975088E726",
  "kind" : "article",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Overview\n\nOnce you set up your Xcode project (see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/setting-up-core-data-with-cloudkit]) and initialize your development schema (see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/creating-a-core-data-model-for-cloudkit]), you’re ready to sync a Core Data store to CloudKit.\n\n### Run Your App and Create Managed Object Instances\n\nRun your app and begin creating [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject] instances. The objects automatically synchronize with the CloudKit database and propagate to other devices logged into the same iCloud account. The tasks that send changes to the cloud and receive remote changes in the local store happen on the system in the background. You don’t need to add any code to your project to synchronize records across devices.\n\nIt can be helpful to think of this process as similar to the water cycle. Water evaporates up and rains down on a natural cadence. Similarly, changes move from Core Data up to CloudKit and across to other devices on a natural rhythm within the system event loop.\n\nGenerally, you can expect data to synchronize a local change within about a minute of the change. Core Data also occasionally syncs CloudKit data in scenarios such as when the app hasn’t synced in a long time.\n\n### Upload Core Data Changes to CloudKit\n\nWhen the user makes a change on one device, Core Data uploads the change to CloudKit before sending it to the user’s other devices.\n\n\n\nFirst, the user creates, updates, or deletes a managed object, such as adding a post or editing a tag. When its managed object context saves changes to the store, Core Data creates a background task for the system to convert the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject] to a [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKRecord]. The system executes the task, creating the record and uploading it to CloudKit.\n\nFor more information about background tasks, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication].\n\n### Download CloudKit Changes into Core Data\n\nAfter CloudKit receives a change and saves it to the CloudKit store, it notifies the user’s other devices about the change.\n\n\n\nFirst, CloudKit periodically sends push notifications to other devices on a user’s account. Then, on each device, the system creates a background task to download all of the changed records since the last fetch and converts them into instances of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject]. Finally, Core Data saves these managed objects into the local store.\n\nFor more information about push notifications, see [doc:\/\/com.apple.documentation\/documentation\/UserNotifications].\n\n### Isolate the Current View from Store Changes\n\nConsider what happens if a user deletes a record from their phone. This change uploads to CloudKit, and later downloads to a laptop and an iPad. The iPad’s current view may still show the record if the UI hasn’t updated with the changes yet. The user taps on the now-deleted record, which is no longer available in the store. This may lead to inconsistent representation of the record, such as missing data, in your UI.\n\nFor this reason, you need to isolate the current view from changes to the store by ensuring that the records the view expects continue to exist. Using query generations, you pin the persistent container’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentContainer\/viewContext] to a specific generation of store data. This allows the context to fulfill faults — placeholder objects whose values haven’t yet been fetched — that existed at the time the view loaded, even if the store changes underneath.\n\nPin a context to a query generation before its first read from the store.\n\nAny time you save, merge, or reset the context, it automatically updates its pin to the current query generation.\n\nFor more information about faults, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/CoreData\/FaultingandUniquing.html#\/\/apple_ref\/doc\/uid\/TP40001075-CH18].\n\nFor more information about query generations, see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/accessing-data-when-the-store-changes].\n\n### Integrate Store Changes Relevant to the Current View\n\nYour app receives remote change notifications when the local store updates from CloudKit. However, it’s unnecessary to update your UI in response to every notification, because some changes may not be relevant to the current view.\n\nAnalyze the persistent history to determine whether the changes are relevant to the current view before consuming them in the user interface. Inspect the details of each transaction, such as the entity name, its updated properties, and the type of change, to decide whether to act.\n\nFor more information about persistent history tracking, see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/consuming-relevant-store-changes].\n\n### Debug Errors in Core Data with CloudKit\n\nMost errors, like those that result from a network failure or a user not being signed in, are transient and don’t require action. You can choose the level of detail that Core Data with CloudKit logs to the system log.\n\nChoose Product > Scheme > Edit Scheme. Select an action such as Run, and select the Arguments tab. Pass the `com.apple.CoreData.CloudKitDebug` user default setting with a debug level value as an argument to the application.\n\n\n\nHigher argument values produce more information; start at `1` and increase if you need more detail. For more information about handling errors, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/CoreData\/TroubleshootingCoreData.html#\/\/apple_ref\/doc\/uid\/TP40001075-CH26].\n\nIf you observe persistent errors that don’t automatically recover, file a bug. For more information about bug reporting, see [https:\/\/developer.apple.com\/bug-reporting\/].\n\n### Inspect Logs to See What Happened\n\nIf Core Data with CloudKit doesn’t appear to be syncing, confirm that you’re testing on two unlocked devices logged into the same iCloud account, with good wireless internet connections.\n\nPush notifications may get dropped or deferred, so don’t rely on them for testing. Watch system logs to observe the status and result of expected activity. Run the `log stream` command from the terminal, filtering by process and container ID. If the logs don’t include the operation, your push may have been dropped. Check the originating device for export activity.\n\nFilter CloudKit logs to see operations on the `cloudd` process for your container.\n\nFilter Core Data logs to see information about the mirroring delegate’s setup, exports, and imports for your process.\n\nOr monitor both CloudKit and Core Data logs at the same time.\n\nFor more information about logging, see [doc:\/\/com.apple.documentation\/documentation\/os\/viewing-log-messages].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreData\/syncing-a-core-data-store-with-cloudkit\ncrawled: 2025-12-02T18:49:49Z\n---\n\n# Syncing a Core Data Store with CloudKit\n\n**Article**\n\nSynchronize objects between devices, and handle store changes in the user interface.\n\n## Overview\n\nOnce you set up your Xcode project (see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/setting-up-core-data-with-cloudkit]) and initialize your development schema (see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/creating-a-core-data-model-for-cloudkit]), you’re ready to sync a Core Data store to CloudKit.\n\n### Run Your App and Create Managed Object Instances\n\nRun your app and begin creating [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject] instances. The objects automatically synchronize with the CloudKit database and propagate to other devices logged into the same iCloud account. The tasks that send changes to the cloud and receive remote changes in the local store happen on the system in the background. You don’t need to add any code to your project to synchronize records across devices.\n\nIt can be helpful to think of this process as similar to the water cycle. Water evaporates up and rains down on a natural cadence. Similarly, changes move from Core Data up to CloudKit and across to other devices on a natural rhythm within the system event loop.\n\nGenerally, you can expect data to synchronize a local change within about a minute of the change. Core Data also occasionally syncs CloudKit data in scenarios such as when the app hasn’t synced in a long time.\n\n### Upload Core Data Changes to CloudKit\n\nWhen the user makes a change on one device, Core Data uploads the change to CloudKit before sending it to the user’s other devices.\n\n\n\nFirst, the user creates, updates, or deletes a managed object, such as adding a post or editing a tag. When its managed object context saves changes to the store, Core Data creates a background task for the system to convert the [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject] to a [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKRecord]. The system executes the task, creating the record and uploading it to CloudKit.\n\nFor more information about background tasks, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication].\n\n### Download CloudKit Changes into Core Data\n\nAfter CloudKit receives a change and saves it to the CloudKit store, it notifies the user’s other devices about the change.\n\n\n\nFirst, CloudKit periodically sends push notifications to other devices on a user’s account. Then, on each device, the system creates a background task to download all of the changed records since the last fetch and converts them into instances of [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSManagedObject]. Finally, Core Data saves these managed objects into the local store.\n\nFor more information about push notifications, see [doc:\/\/com.apple.documentation\/documentation\/UserNotifications].\n\n### Isolate the Current View from Store Changes\n\nConsider what happens if a user deletes a record from their phone. This change uploads to CloudKit, and later downloads to a laptop and an iPad. The iPad’s current view may still show the record if the UI hasn’t updated with the changes yet. The user taps on the now-deleted record, which is no longer available in the store. This may lead to inconsistent representation of the record, such as missing data, in your UI.\n\nFor this reason, you need to isolate the current view from changes to the store by ensuring that the records the view expects continue to exist. Using query generations, you pin the persistent container’s [doc:\/\/com.apple.coredata\/documentation\/CoreData\/NSPersistentContainer\/viewContext] to a specific generation of store data. This allows the context to fulfill faults — placeholder objects whose values haven’t yet been fetched — that existed at the time the view loaded, even if the store changes underneath.\n\nPin a context to a query generation before its first read from the store.\n\n```swift\ntry? persistentContainer.viewContext.setQueryGenerationFrom(.current)\n```\n\nAny time you save, merge, or reset the context, it automatically updates its pin to the current query generation.\n\nFor more information about faults, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/CoreData\/FaultingandUniquing.html#\/\/apple_ref\/doc\/uid\/TP40001075-CH18].\n\nFor more information about query generations, see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/accessing-data-when-the-store-changes].\n\n### Integrate Store Changes Relevant to the Current View\n\nYour app receives remote change notifications when the local store updates from CloudKit. However, it’s unnecessary to update your UI in response to every notification, because some changes may not be relevant to the current view.\n\nAnalyze the persistent history to determine whether the changes are relevant to the current view before consuming them in the user interface. Inspect the details of each transaction, such as the entity name, its updated properties, and the type of change, to decide whether to act.\n\nFor more information about persistent history tracking, see [doc:\/\/com.apple.coredata\/documentation\/CoreData\/consuming-relevant-store-changes].\n\n### Debug Errors in Core Data with CloudKit\n\nMost errors, like those that result from a network failure or a user not being signed in, are transient and don’t require action. You can choose the level of detail that Core Data with CloudKit logs to the system log.\n\nChoose Product > Scheme > Edit Scheme. Select an action such as Run, and select the Arguments tab. Pass the `com.apple.CoreData.CloudKitDebug` user default setting with a debug level value as an argument to the application.\n\n\n\nHigher argument values produce more information; start at `1` and increase if you need more detail. For more information about handling errors, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/CoreData\/TroubleshootingCoreData.html#\/\/apple_ref\/doc\/uid\/TP40001075-CH26].\n\nIf you observe persistent errors that don’t automatically recover, file a bug. For more information about bug reporting, see [https:\/\/developer.apple.com\/bug-reporting\/].\n\n### Inspect Logs to See What Happened\n\nIf Core Data with CloudKit doesn’t appear to be syncing, confirm that you’re testing on two unlocked devices logged into the same iCloud account, with good wireless internet connections.\n\nPush notifications may get dropped or deferred, so don’t rely on them for testing. Watch system logs to observe the status and result of expected activity. Run the `log stream` command from the terminal, filtering by process and container ID. If the logs don’t include the operation, your push may have been dropped. Check the originating device for export activity.\n\nFilter CloudKit logs to see operations on the `cloudd` process for your container.\n\n```swift\n$ log stream --info --debug --predicate 'process = \"cloudd\" and message\ncontains[cd] \"containerID=com.mycontainer\"'\n```\n\nFilter Core Data logs to see information about the mirroring delegate’s setup, exports, and imports for your process.\n\n```swift\n$ log stream --info --debug --predicate 'process = \"myprocess\" and \n(subsystem = \"com.apple.coredata\" or subsystem = \"com.apple.cloudkit\")'\n```\n\nOr monitor both CloudKit and Core Data logs at the same time.\n\n```swift\n$ log stream --info --debug --predicate '(process = \"myprocess\" and\n(subsystem = \"com.apple.coredata\" or subsystem = \"com.apple.cloudkit\")) or\n(process = \"cloudd\" and message contains[cd] \"container=com.mycontainer\")'\n```\n\nFor more information about logging, see [doc:\/\/com.apple.documentation\/documentation\/os\/viewing-log-messages].\n\n## Configuring CloudKit Mirroring\n\n- **Setting Up Core Data with CloudKit**: Set up the classes and capabilities that sync your store to CloudKit.\n- **Creating a Core Data Model for CloudKit**: Design a CloudKit-compatible data model and initialize your CloudKit schema.\n- **Reading CloudKit Records for Core Data**: Access CloudKit records created from Core Data managed objects.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Set up the classes and capabilities that sync your store to CloudKit.",
          "name" : "Setting Up Core Data with CloudKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/setting-up-core-data-with-cloudkit"
        },
        {
          "description" : "Design a CloudKit-compatible data model and initialize your CloudKit schema.",
          "name" : "Creating a Core Data Model for CloudKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/creating-a-core-data-model-for-cloudkit"
        },
        {
          "description" : "Access CloudKit records created from Core Data managed objects.",
          "name" : "Reading CloudKit Records for Core Data",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/reading-cloudkit-records-for-core-data"
        }
      ],
      "title" : "Configuring CloudKit Mirroring"
    }
  ],
  "source" : "appleJSON",
  "title" : "Syncing a Core Data Store with CloudKit",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/syncing-a-core-data-store-with-cloudkit"
}