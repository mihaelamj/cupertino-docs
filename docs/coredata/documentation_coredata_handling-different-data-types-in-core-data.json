{
  "abstract" : "Create, store, and present records for a variety of data types.",
  "codeExamples" : [
    {
      "code" : "@objc public var publishDate: Date? {\n    get {\n        willAccessValue(forKey: Name.publishDate)\n        defer { didAccessValue(forKey: Name.publishDate) }\n        return primitivePublishDate\n    }\n    set {\n        willChangeValue(forKey: Name.publishDate)\n        defer { didChangeValue(forKey: Name.publishDate) }\n        primitivePublishDate = newValue\n        primitivePublishMonthID = nil\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@objc public var publishMonthID: String? {\n    willAccessValue(forKey: Name.publishMonthID)\n    defer { didAccessValue(forKey: Name.publishMonthID) }\n    \n    guard primitivePublishMonthID == nil, let date = primitivePublishDate else {\n        return primitivePublishMonthID\n    }\n    let calendar = Calendar(identifier: .gregorian)\n    let components = calendar.dateComponents([.year, .month], from: date)\n    if let year = components.year, let month = components.month {\n        primitivePublishMonthID = \"\\(year * 1000 + month)\"\n    }\n    return primitivePublishMonthID\n}",
      "language" : "swift"
    },
    {
      "code" : "class func keyPathsForValuesAffectingPublishMonthID() -> Set<String> {\n    return [Name.publishDate]\n}",
      "language" : "swift"
    },
    {
      "code" : "canonical:(title)"
    },
    {
      "code" : "\/\/ Register the transformer at the very beginning.\n\/\/ .colorToDataTransformer is a name defined with an NSValueTransformerName extension.\nValueTransformer.setValueTransformer(ColorToDataTransformer(), forName: .colorToDataTransformer)",
      "language" : "swift"
    },
    {
      "code" : "newBook.price = NSDecimalNumber(mantissa: value, exponent: -2, isNegative: false)",
      "language" : "swift"
    },
    {
      "code" : "cell.price.text = book.price?.description(withLocale: Locale.current)",
      "language" : "swift"
    }
  ],
  "contentHash" : "eb51cb37c802f90a2f9f868068e6915df4dff8e4a85764e4cd42741d2446aaf4",
  "crawledAt" : "2025-12-04T20:48:52Z",
  "id" : "64FC2C3B-FF7C-4547-81DF-5C9D98070188",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Core Data",
  "overview" : "## Overview\n\nMany apps need to persist and present different kinds of information. Core Data provides different attributes, including those common for all databases, such as `Date` or `Decimal` type, and non-standard attributes handled with `Transformable` type. It also provides `Transient` and `Derived` attributes so apps can derive one piece of data from the other.\n\nThis sample shows how to handle all these data types, by creating and presenting a set of book records. After you launch it, this sample automatically generates the records if they don’t already exist, and shows them in a list. The records are grouped by their published month and can be searched with their canonical form of title.\n\n### Derive a Non-Persistent Value Using a Transient Attribute\n\nA `Transient` attribute is derived from one or multiple stored attributes in the same entity. As its name implies, a `Transient` attribute isn’t persisted to the store, so an app can use it to provide a new attribute based on the stored ones, without consuming extra storage space.\n\nTo make an attribute `Transient`, select the Core Data model in Xcode Project Navigator, navigate to the Core Data entity, select the attribute in the attributes list, and check the `Transient` box in the Data Model Inspector.\n\nIn this sample, `publishMonthID` is a `Transient` attribute derived from `publishDate`. To implement the derivation, this sample provides a custom accessor for `publishDate` and `publishMonthID`. The `setter` method of `publishDate` nullifies `primitivePublishMonthID`, which allows the `getter` method of `publishMonthID` to recalculate the value based on the current `publishDate`.\n\nThe `getter` method of `publishMonthID` recalculates the value if `primitivePublishMonthID` is nil.\n\nWith these two methods, `publishMonthID` is associated with `publishDate` and always stays current.\n\nIn the case where `publishMonthID` is [doc:\/\/com.apple.documentation\/documentation\/Swift\/using-key-value-observing-in-swift], the following code ensures that the observations are triggered when `publishDate` changes.\n\n### Derive One Value From Another Using a Derived Attribute\n\nThis sample uses a `Derived` attribute, `canonicalTitle`, to support searching the canonical form of book titles. `canonicalTitle` is configured as the canonical form of  `title` by setting the following expression as the value of the `Derivation` field shown Xcode’s Data Model Inspector.\n\n`Derived` attributes are used in cases where performance is more critical than storage space. In this sample, the app gets the same result by setting up a predicate with  `CONTAINS[cd]` ( where `cd` means case- and diacritic-insensitive ) to search `title` directly. By searching `canonicalTitle` which is persisted, the app performs more quickly because it doesn’t need to do diacritic-insensitive comparison for every book title.\n\n`Derived` attributes are only updated when the user saves the managed context. Concretely, `canonicalTitle` won’t change if the sample app changes the `title` attribute without saving it.\n\n### Configure and Implement a Non-Standard Data Type\n\n`Transformable` attributes store objects with a non-standard type, or a type that isn’t in the attribute type list in Xcode’s Data Model Inspector. To implement a `Transformable` attribute, configure it by setting its type to `Transformable` and specifying the transformer and custom class name in Data Model Inspector, then register a transformer with code before an app loads its Core Data stack.\n\nCore Data requires the transformer be `NSSecureUnarchiveFromData` or its subclass, and that its `transformedValue(_:)` method converts a `Data` object to an instance of the custom class specified in Data Model Inspector and that `reverseTransformedValue(_:)` does the opposite – converts an instance of the custom class to a `Data` object.\n\n### Store and Present a Date Type\n\nIn a Core Data store, a `Date` attribute is a `double` value that represents a number of seconds since 1970. Using a variety of calendars, time zones, and locales, an app can convert a `Date` value to different date strings, or convert a date string to different `Date` values. When parsing a date string, configure the `DateFormatter` with the right calendar, time zone, and locale. Typically, if the string is generated by the current user, the user-perceived calendar, time zone, and locale will be the current system ones, so an app can use a default `DateFormatter` instance. In other cases, configure `DateFormatter` in the same way the app generated the string.\n\n### Store and Present a Decimal Type\n\nThis sample uses a `Decimal` attribute to represent the book price, which is then mapped to a variable of `NSDecimalNumber` type. `NSDecimalNumber` has a convenient method to process a currency value.\n\n`NSDecimalNumber` also provides a convenient way to present a value with locale in mind.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/coredata\/handling-different-data-types-in-core-data\ncrawled: 2025-12-04T20:48:52Z\n---\n\n# Handling Different Data Types in Core Data\n\n**Sample Code**\n\nCreate, store, and present records for a variety of data types.\n\n## Overview\n\nMany apps need to persist and present different kinds of information. Core Data provides different attributes, including those common for all databases, such as `Date` or `Decimal` type, and non-standard attributes handled with `Transformable` type. It also provides `Transient` and `Derived` attributes so apps can derive one piece of data from the other.\n\nThis sample shows how to handle all these data types, by creating and presenting a set of book records. After you launch it, this sample automatically generates the records if they don’t already exist, and shows them in a list. The records are grouped by their published month and can be searched with their canonical form of title.\n\n### Derive a Non-Persistent Value Using a Transient Attribute\n\nA `Transient` attribute is derived from one or multiple stored attributes in the same entity. As its name implies, a `Transient` attribute isn’t persisted to the store, so an app can use it to provide a new attribute based on the stored ones, without consuming extra storage space.\n\nTo make an attribute `Transient`, select the Core Data model in Xcode Project Navigator, navigate to the Core Data entity, select the attribute in the attributes list, and check the `Transient` box in the Data Model Inspector.\n\nIn this sample, `publishMonthID` is a `Transient` attribute derived from `publishDate`. To implement the derivation, this sample provides a custom accessor for `publishDate` and `publishMonthID`. The `setter` method of `publishDate` nullifies `primitivePublishMonthID`, which allows the `getter` method of `publishMonthID` to recalculate the value based on the current `publishDate`.\n\n```swift\n@objc public var publishDate: Date? {\n    get {\n        willAccessValue(forKey: Name.publishDate)\n        defer { didAccessValue(forKey: Name.publishDate) }\n        return primitivePublishDate\n    }\n    set {\n        willChangeValue(forKey: Name.publishDate)\n        defer { didChangeValue(forKey: Name.publishDate) }\n        primitivePublishDate = newValue\n        primitivePublishMonthID = nil\n    }\n}\n```\n\nThe `getter` method of `publishMonthID` recalculates the value if `primitivePublishMonthID` is nil.\n\n```swift\n@objc public var publishMonthID: String? {\n    willAccessValue(forKey: Name.publishMonthID)\n    defer { didAccessValue(forKey: Name.publishMonthID) }\n    \n    guard primitivePublishMonthID == nil, let date = primitivePublishDate else {\n        return primitivePublishMonthID\n    }\n    let calendar = Calendar(identifier: .gregorian)\n    let components = calendar.dateComponents([.year, .month], from: date)\n    if let year = components.year, let month = components.month {\n        primitivePublishMonthID = \"\\(year * 1000 + month)\"\n    }\n    return primitivePublishMonthID\n}\n```\n\nWith these two methods, `publishMonthID` is associated with `publishDate` and always stays current.\n\nIn the case where `publishMonthID` is [doc:\/\/com.apple.documentation\/documentation\/Swift\/using-key-value-observing-in-swift], the following code ensures that the observations are triggered when `publishDate` changes.\n\n```swift\nclass func keyPathsForValuesAffectingPublishMonthID() -> Set<String> {\n    return [Name.publishDate]\n}\n```\n\n### Derive One Value From Another Using a Derived Attribute\n\nThis sample uses a `Derived` attribute, `canonicalTitle`, to support searching the canonical form of book titles. `canonicalTitle` is configured as the canonical form of  `title` by setting the following expression as the value of the `Derivation` field shown Xcode’s Data Model Inspector.\n\n```\ncanonical:(title)\n```\n\n`Derived` attributes are used in cases where performance is more critical than storage space. In this sample, the app gets the same result by setting up a predicate with  `CONTAINS[cd]` ( where `cd` means case- and diacritic-insensitive ) to search `title` directly. By searching `canonicalTitle` which is persisted, the app performs more quickly because it doesn’t need to do diacritic-insensitive comparison for every book title.\n\n`Derived` attributes are only updated when the user saves the managed context. Concretely, `canonicalTitle` won’t change if the sample app changes the `title` attribute without saving it.\n\n### Configure and Implement a Non-Standard Data Type\n\n`Transformable` attributes store objects with a non-standard type, or a type that isn’t in the attribute type list in Xcode’s Data Model Inspector. To implement a `Transformable` attribute, configure it by setting its type to `Transformable` and specifying the transformer and custom class name in Data Model Inspector, then register a transformer with code before an app loads its Core Data stack.\n\n```swift\n\/\/ Register the transformer at the very beginning.\n\/\/ .colorToDataTransformer is a name defined with an NSValueTransformerName extension.\nValueTransformer.setValueTransformer(ColorToDataTransformer(), forName: .colorToDataTransformer)\n```\n\nCore Data requires the transformer be `NSSecureUnarchiveFromData` or its subclass, and that its `transformedValue(_:)` method converts a `Data` object to an instance of the custom class specified in Data Model Inspector and that `reverseTransformedValue(_:)` does the opposite – converts an instance of the custom class to a `Data` object.\n\n### Store and Present a Date Type\n\nIn a Core Data store, a `Date` attribute is a `double` value that represents a number of seconds since 1970. Using a variety of calendars, time zones, and locales, an app can convert a `Date` value to different date strings, or convert a date string to different `Date` values. When parsing a date string, configure the `DateFormatter` with the right calendar, time zone, and locale. Typically, if the string is generated by the current user, the user-perceived calendar, time zone, and locale will be the current system ones, so an app can use a default `DateFormatter` instance. In other cases, configure `DateFormatter` in the same way the app generated the string.\n\n### Store and Present a Decimal Type\n\nThis sample uses a `Decimal` attribute to represent the book price, which is then mapped to a variable of `NSDecimalNumber` type. `NSDecimalNumber` has a convenient method to process a currency value.\n\n```swift\nnewBook.price = NSDecimalNumber(mantissa: value, exponent: -2, isNegative: false)\n```\n\n`NSDecimalNumber` also provides a convenient way to present a value with locale in mind.\n\n```swift\ncell.price.text = book.price?.description(withLocale: Locale.current)\n```\n\n## Essentials\n\n- **Creating a Core Data model**: Define your app’s object structure with a data model file.\n- **Setting up a Core Data stack**: Set up the classes that manage and persist your app’s objects.\n- **Core Data stack**: Manage and persist your app’s model layer.\n- **Linking Data Between Two Core Data Stores**: Organize data in two different stores and implement a link between them.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Define your app’s object structure with a data model file.",
          "name" : "Creating a Core Data model",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/creating-a-core-data-model"
        },
        {
          "description" : "Set up the classes that manage and persist your app’s objects.",
          "name" : "Setting up a Core Data stack",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/setting-up-a-core-data-stack"
        },
        {
          "description" : "Manage and persist your app’s model layer.",
          "name" : "Core Data stack",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/core-data-stack"
        },
        {
          "description" : "Organize data in two different stores and implement a link between them.",
          "name" : "Linking Data Between Two Core Data Stores",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/linking-data-between-two-core-data-stores"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Handling Different Data Types in Core Data",
  "url" : "https:\/\/developer.apple.com\/documentation\/coredata\/handling-different-data-types-in-core-data"
}