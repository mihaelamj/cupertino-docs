{
  "abstract" : "Specify different input parameters to generate multiple test cases from a test function.",
  "codeExamples" : [
    {
      "code" : "enum Food {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\")\nfunc foodsAvailable() async throws {\n  for food: Food in [.burger, .iceCream, .burrito, .noodleBowl, .kebab] {\n    let foodTruck = FoodTruck(selling: food)\n    #expect(await foodTruck.cook(food))\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "enum Food {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\", arguments: [Food.burger, .iceCream, .burrito, .noodleBowl, .kebab])\nfunc foodAvailable(_ food: Food) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food))\n}",
      "language" : "swift"
    },
    {
      "code" : "enum Food: CaseIterable {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\", arguments: Food.allCases)\nfunc foodAvailable(_ food: Food) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food))\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test(\"Can make large orders\", arguments: 1 ... 100)\nfunc makeLargeOrder(count: Int) async throws {\n  let foodTruck = FoodTruck(selling: .burger)\n  #expect(await foodTruck.cook(.burger, quantity: count))\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Food {\n  static var bestSelling: [Food] {\n    get async throws { \/* ... *\/ }\n  }\n}\n\n@Test(arguments: try await Food.bestSelling)\nfunc `Order entree`(food: Food) {\n  let foodTruck = FoodTruck()\n  #expect(foodTruck.order(food))\n}\n\n@Test(arguments: try await Food.bestSelling)\nfunc `Package leftovers`(food: Food) throws {\n  let foodTruck = FoodTruck()\n  let container = try #require(foodTruck.container(fitting: food))\n  try container.add(food)\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test(\"Can make large orders\", arguments: Food.allCases, 1 ... 100)\nfunc makeLargeOrder(of food: Food, count: Int) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food, quantity: count))\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test(\"Can make large orders\", arguments: zip(Food.allCases, 1 ... 100))\nfunc makeLargeOrder(of food: Food, count: Int) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food, quantity: count))\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "591ae059ced65ebdab352278ef46c67ec3215ab9d0414dec7c710f1960d4c07c",
  "crawledAt" : "2025-12-05T12:29:46Z",
  "id" : "30025874-F1E3-4A3A-B385-13DEC297ADB0",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift Testing",
  "overview" : "## Overview\n\nSome tests need to be run over many different inputs. For instance, a test might need to validate all cases of an enumeration. The testing library lets developers specify one or more collections to iterate over during testing, with the elements of those collections being forwarded to a test function. An invocation of a test function with a particular set of argument values is called a test *case*.\n\nBy default, the test cases of a test function run in parallel with each other. For more information about test parallelization, see [doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization].\n\n### Parameterize over an array of values\n\nIt is very common to want to run a test *n* times over an array containing the values that should be tested. Consider the following test function:\n\nIf this test function fails for one of the values in the array, it may be unclear which value failed. Instead, the test function can be *parameterized over* the various inputs:\n\nWhen passing a collection to the `@Test` attribute for parameterization, the testing library passes each element in the collection, one at a time, to the test function as its first (and only) argument. Then, if the test fails for one or more inputs, the corresponding diagnostics can clearly indicate which inputs to examine.\n\n### Parameterize over the cases of an enumeration\n\nThe previous example includes a hard-coded list of `Food` cases to test. If `Food` is an enumeration that conforms to `CaseIterable`, you can instead write:\n\nThis way, if a new case is added to the `Food` enumeration, it’s automatically tested by this function.\n\n### Parameterize over a range of integers\n\nIt is possible to parameterize a test function over a closed range of integers:\n\n### Pass the same arguments to multiple test functions\n\nIf you want to pass the same collection of arguments to two or more parameterized test functions, you can extract the arguments to a separate function or property and pass it to each `@Test` attribute. For example:\n\n### Test with more than one collection\n\nIt’s possible to test more than one collection. Consider the following test function:\n\nElements from the first collection are passed as the first argument to the test function, elements from the second collection are passed as the second argument, and so forth.\n\nAssuming there are five cases in the `Food` enumeration, this test function will, when run, be invoked 500 times (5 x 100) with every possible combination of food and order size. These combinations are referred to as the collections’ Cartesian product.\n\nTo avoid the combinatoric semantics shown above, use [https:\/\/developer.apple.com\/documentation\/swift\/zip(_:_:)]:\n\nThe zipped sequence will be “destructured” into two arguments automatically, then passed to the test function for evaluation.\n\nThis revised test function is invoked once for each tuple in the zipped sequence, for a total of five invocations instead of 500 invocations. In other words, this test function is passed the inputs `(.burger, 1)`, `(.iceCream, 2)`, …, `(.kebab, 5)` instead of `(.burger, 1)`, `(.burger, 2)`, `(.burger, 3)`, …, `(.kebab, 99)`, `(.kebab, 100)`.\n\n### Run selected test cases\n\nIf a parameterized test meets certain requirements, the testing library allows people to run specific test cases it contains. This can be useful when a test has many cases but only some are failing since it enables re-running and debugging the failing cases in isolation.\n\nTo support running selected test cases, it must be possible to deterministically match the test case’s arguments. When someone attempts to run selected test cases of a parameterized test function, the testing library evaluates each argument of the tests’ cases for conformance to one of several known protocols, and if all arguments of a test case conform to one of those protocols, that test case can be run selectively. The following lists the known protocols, in precedence order (highest to lowest):\n\nIf any argument of a test case doesn’t meet one of the above requirements, then the overall test case cannot be run selectively.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/testing\/parameterizedtesting\ncrawled: 2025-12-05T12:29:46Z\n---\n\n# Implementing parameterized tests\n\n**Article**\n\nSpecify different input parameters to generate multiple test cases from a test function.\n\n## Overview\n\nSome tests need to be run over many different inputs. For instance, a test might need to validate all cases of an enumeration. The testing library lets developers specify one or more collections to iterate over during testing, with the elements of those collections being forwarded to a test function. An invocation of a test function with a particular set of argument values is called a test *case*.\n\nBy default, the test cases of a test function run in parallel with each other. For more information about test parallelization, see [doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization].\n\n### Parameterize over an array of values\n\nIt is very common to want to run a test *n* times over an array containing the values that should be tested. Consider the following test function:\n\n```swift\nenum Food {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\")\nfunc foodsAvailable() async throws {\n  for food: Food in [.burger, .iceCream, .burrito, .noodleBowl, .kebab] {\n    let foodTruck = FoodTruck(selling: food)\n    #expect(await foodTruck.cook(food))\n  }\n}\n```\n\nIf this test function fails for one of the values in the array, it may be unclear which value failed. Instead, the test function can be *parameterized over* the various inputs:\n\n```swift\nenum Food {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\", arguments: [Food.burger, .iceCream, .burrito, .noodleBowl, .kebab])\nfunc foodAvailable(_ food: Food) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food))\n}\n```\n\nWhen passing a collection to the `@Test` attribute for parameterization, the testing library passes each element in the collection, one at a time, to the test function as its first (and only) argument. Then, if the test fails for one or more inputs, the corresponding diagnostics can clearly indicate which inputs to examine.\n\n### Parameterize over the cases of an enumeration\n\nThe previous example includes a hard-coded list of `Food` cases to test. If `Food` is an enumeration that conforms to `CaseIterable`, you can instead write:\n\n```swift\nenum Food: CaseIterable {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\", arguments: Food.allCases)\nfunc foodAvailable(_ food: Food) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food))\n}\n```\n\nThis way, if a new case is added to the `Food` enumeration, it’s automatically tested by this function.\n\n### Parameterize over a range of integers\n\nIt is possible to parameterize a test function over a closed range of integers:\n\n```swift\n@Test(\"Can make large orders\", arguments: 1 ... 100)\nfunc makeLargeOrder(count: Int) async throws {\n  let foodTruck = FoodTruck(selling: .burger)\n  #expect(await foodTruck.cook(.burger, quantity: count))\n}\n```\n\n\n\n### Pass the same arguments to multiple test functions\n\nIf you want to pass the same collection of arguments to two or more parameterized test functions, you can extract the arguments to a separate function or property and pass it to each `@Test` attribute. For example:\n\n```swift\nextension Food {\n  static var bestSelling: [Food] {\n    get async throws { \/* ... *\/ }\n  }\n}\n\n@Test(arguments: try await Food.bestSelling)\nfunc `Order entree`(food: Food) {\n  let foodTruck = FoodTruck()\n  #expect(foodTruck.order(food))\n}\n\n@Test(arguments: try await Food.bestSelling)\nfunc `Package leftovers`(food: Food) throws {\n  let foodTruck = FoodTruck()\n  let container = try #require(foodTruck.container(fitting: food))\n  try container.add(food)\n}\n```\n\n\n\n### Test with more than one collection\n\nIt’s possible to test more than one collection. Consider the following test function:\n\n```swift\n@Test(\"Can make large orders\", arguments: Food.allCases, 1 ... 100)\nfunc makeLargeOrder(of food: Food, count: Int) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food, quantity: count))\n}\n```\n\nElements from the first collection are passed as the first argument to the test function, elements from the second collection are passed as the second argument, and so forth.\n\nAssuming there are five cases in the `Food` enumeration, this test function will, when run, be invoked 500 times (5 x 100) with every possible combination of food and order size. These combinations are referred to as the collections’ Cartesian product.\n\nTo avoid the combinatoric semantics shown above, use [https:\/\/developer.apple.com\/documentation\/swift\/zip(_:_:)]:\n\n```swift\n@Test(\"Can make large orders\", arguments: zip(Food.allCases, 1 ... 100))\nfunc makeLargeOrder(of food: Food, count: Int) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food, quantity: count))\n}\n```\n\nThe zipped sequence will be “destructured” into two arguments automatically, then passed to the test function for evaluation.\n\nThis revised test function is invoked once for each tuple in the zipped sequence, for a total of five invocations instead of 500 invocations. In other words, this test function is passed the inputs `(.burger, 1)`, `(.iceCream, 2)`, …, `(.kebab, 5)` instead of `(.burger, 1)`, `(.burger, 2)`, `(.burger, 3)`, …, `(.kebab, 99)`, `(.kebab, 100)`.\n\n### Run selected test cases\n\nIf a parameterized test meets certain requirements, the testing library allows people to run specific test cases it contains. This can be useful when a test has many cases but only some are failing since it enables re-running and debugging the failing cases in isolation.\n\nTo support running selected test cases, it must be possible to deterministically match the test case’s arguments. When someone attempts to run selected test cases of a parameterized test function, the testing library evaluates each argument of the tests’ cases for conformance to one of several known protocols, and if all arguments of a test case conform to one of those protocols, that test case can be run selectively. The following lists the known protocols, in precedence order (highest to lowest):\n\n1. [doc:\/\/org.swift.testing\/documentation\/Testing\/CustomTestArgumentEncodable]\n2. `RawRepresentable`, where `RawValue` conforms to `Encodable`\n3. `Encodable`\n4. `Identifiable`, where `ID` conforms to `Encodable`\n\nIf any argument of a test case doesn’t meet one of the above requirements, then the overall test case cannot be run selectively.\n\n## Test parameterization\n\n- **Test(_:_:arguments:)**: Declare a test parameterized over a collection of values.\n- **Test(_:_:arguments:_:)**: Declare a test parameterized over two collections of values.\n- **Test(_:_:arguments:)**: Declare a test parameterized over two zipped collections of values.\n- **CustomTestArgumentEncodable**: A protocol for customizing how arguments passed to parameterized tests are encoded, which is used to match against when running specific arguments.\n- **Test.Case**: A single test case from a parameterized [doc:\/\/org.swift.testing\/documentation\/Testing\/Test].\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Declare a test parameterized over a collection of values.",
          "name" : "Test(_:_:arguments:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test(_:_:arguments:)-8kn7a"
        },
        {
          "description" : "Declare a test parameterized over two collections of values.",
          "name" : "Test(_:_:arguments:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test(_:_:arguments:_:)"
        },
        {
          "description" : "Declare a test parameterized over two zipped collections of values.",
          "name" : "Test(_:_:arguments:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test(_:_:arguments:)-3rzok"
        },
        {
          "description" : "A protocol for customizing how arguments passed to parameterized tests are encoded, which is used to match against when running specific arguments.",
          "name" : "CustomTestArgumentEncodable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/CustomTestArgumentEncodable"
        },
        {
          "description" : "A single test case from a parameterized [doc:\/\/org.swift.testing\/documentation\/Testing\/Test].",
          "name" : "Test.Case",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test\/Case"
        }
      ],
      "title" : "Test parameterization"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing parameterized tests",
  "url" : "https:\/\/developer.apple.com\/documentation\/testing\/parameterizedtesting"
}