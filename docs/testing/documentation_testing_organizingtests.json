{
  "abstract" : "Organize tests into test suites.",
  "codeExamples" : [
    {
      "code" : "@Suite(\"Food truck tests\") struct FoodTruckTests {\n  @Test func foodTruckExists() { ... }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Suite struct FoodTruckTests {\n  @Test func foodTruckExists() { ... }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Suite struct FoodTruckTests {\n  func foodTruckExists() { ... }\n\n  @Test static func staticFoodTruckExists() {\n    let instance = FoodTruckTests()\n    instance.foodTruckExists()\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Suite struct FoodTruckTests {\n  var batteryLevel = 100\n\n  @Test func foodTruckExists() { ... } \/\/ ✅ OK: The type has an implicit init().\n}\n\n@Suite struct CashRegisterTests {\n  private init(cashOnHand: Decimal = 0.0) async throws { ... }\n\n  @Test func calculateSalesTax() { ... } \/\/ ✅ OK: The type has a callable init().\n}\n\nstruct MenuTests {\n  var foods: [Food]\n  var prices: [Food: Decimal]\n\n  @Test static func specialOfTheDay() { ... } \/\/ ✅ OK: The function is static.\n  @Test func orderAllFoods() { ... } \/\/ ❌ ERROR: The suite type requires init().\n}",
      "language" : "swift"
    },
    {
      "code" : "@Suite struct FoodTruckTests { ... } \/\/ ✅ OK: The type is always available.\n\n@available(macOS 11.0, *) \/\/ ❌ ERROR: The suite type must always be available.\n@Suite struct CashRegisterTests { ... }\n\n@available(macOS 11.0, *) struct MenuItemTests { \/\/ ❌ ERROR: The suite type's\n                                                 \/\/ containing type must always\n                                                 \/\/ be available too.\n  @Suite struct BurgerTests { ... }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ff1368a978271c9ae37d92fdb09689ab1e4790828b4a6c941ffc4839d9f2bebf",
  "crawledAt" : "2025-12-03T04:16:03Z",
  "id" : "6074843F-9755-4A4D-9751-94617C717ABB",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift Testing",
  "overview" : "## Overview\n\nWhen working with a large selection of test functions, it can be helpful to organize them into test suites.\n\nA test function can be added to a test suite in one of two ways:\n\nThe `@Suite` attribute isn’t required for the testing library to recognize that a type contains test functions, but adding it allows customization of a test suite’s appearance in the IDE and at the command line. If a trait such as [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/tags(_:)] or [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/disabled(_:sourceLocation:)] is applied to a test suite, it’s automatically inherited by the tests contained in the suite.\n\nIn addition to containing test functions and any other members that a Swift type might contain, test suite types can also contain additional test suites nested within them. To add a nested test suite type, simply declare an additional type within the scope of the outer test suite type.\n\nBy default, tests contained within a suite run in parallel with each other. For more information about test parallelization, see [doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization].\n\n### Customize a suite’s name\n\nTo customize a test suite’s name, supply a string literal as an argument to the `@Suite` attribute:\n\nTo further customize the appearance and behavior of a test function, use [doc:\/\/org.swift.testing\/documentation\/Testing\/Traits] such as [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/tags(_:)].\n\n## Test functions in test suite types\n\nIf a type contains a test function declared as an instance method (that is, without either the `static` or `class` keyword), the testing library calls that test function at runtime by initializing an instance of the type, then calling the test function on that instance. If a test suite type contains multiple test functions declared as instance methods, each one is called on a distinct instance of the type. Therefore, the following test suite and test function:\n\nAre equivalent to:\n\n### Constraints on test suite types\n\nWhen using a type as a test suite, it’s subject to some constraints that are not otherwise applied to Swift types.\n\n#### An initializer may be required\n\nIf a type contains test functions declared as instance methods, it must be possible to initialize an instance of the type with a zero-argument initializer. The initializer may be any combination of:\n\nFor example:\n\nThe compiler emits an error when presented with a test suite that doesn’t meet this requirement.\n\n#### Test suite types must always be available\n\nAlthough `@available` can be applied to a test function to limit its availability at runtime, a test suite type (and any types that contain it) must *not* be annotated with the `@available` attribute:\n\nThe compiler emits an error when presented with a test suite that doesn’t meet this requirement.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Testing\/OrganizingTests\ncrawled: 2025-12-03T04:16:03Z\n---\n\n# Organizing test functions with suite types\n\n**Article**\n\nOrganize tests into test suites.\n\n## Overview\n\nWhen working with a large selection of test functions, it can be helpful to organize them into test suites.\n\nA test function can be added to a test suite in one of two ways:\n\n- By placing it in a Swift type.\n- By placing it in a Swift type and annotating that type with the `@Suite` attribute.\n\nThe `@Suite` attribute isn’t required for the testing library to recognize that a type contains test functions, but adding it allows customization of a test suite’s appearance in the IDE and at the command line. If a trait such as [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/tags(_:)] or [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/disabled(_:sourceLocation:)] is applied to a test suite, it’s automatically inherited by the tests contained in the suite.\n\nIn addition to containing test functions and any other members that a Swift type might contain, test suite types can also contain additional test suites nested within them. To add a nested test suite type, simply declare an additional type within the scope of the outer test suite type.\n\nBy default, tests contained within a suite run in parallel with each other. For more information about test parallelization, see [doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization].\n\n### Customize a suite’s name\n\nTo customize a test suite’s name, supply a string literal as an argument to the `@Suite` attribute:\n\n```swift\n@Suite(\"Food truck tests\") struct FoodTruckTests {\n  @Test func foodTruckExists() { ... }\n}\n```\n\nTo further customize the appearance and behavior of a test function, use [doc:\/\/org.swift.testing\/documentation\/Testing\/Traits] such as [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/tags(_:)].\n\n## Test functions in test suite types\n\nIf a type contains a test function declared as an instance method (that is, without either the `static` or `class` keyword), the testing library calls that test function at runtime by initializing an instance of the type, then calling the test function on that instance. If a test suite type contains multiple test functions declared as instance methods, each one is called on a distinct instance of the type. Therefore, the following test suite and test function:\n\n```swift\n@Suite struct FoodTruckTests {\n  @Test func foodTruckExists() { ... }\n}\n```\n\nAre equivalent to:\n\n```swift\n@Suite struct FoodTruckTests {\n  func foodTruckExists() { ... }\n\n  @Test static func staticFoodTruckExists() {\n    let instance = FoodTruckTests()\n    instance.foodTruckExists()\n  }\n}\n```\n\n### Constraints on test suite types\n\nWhen using a type as a test suite, it’s subject to some constraints that are not otherwise applied to Swift types.\n\n#### An initializer may be required\n\nIf a type contains test functions declared as instance methods, it must be possible to initialize an instance of the type with a zero-argument initializer. The initializer may be any combination of:\n\n- implicit or explicit\n- synchronous or asynchronous\n- throwing or non-throwing\n- `private`, `fileprivate`, `internal`, `package`, or `public`\n\nFor example:\n\n```swift\n@Suite struct FoodTruckTests {\n  var batteryLevel = 100\n\n  @Test func foodTruckExists() { ... } \/\/ ✅ OK: The type has an implicit init().\n}\n\n@Suite struct CashRegisterTests {\n  private init(cashOnHand: Decimal = 0.0) async throws { ... }\n\n  @Test func calculateSalesTax() { ... } \/\/ ✅ OK: The type has a callable init().\n}\n\nstruct MenuTests {\n  var foods: [Food]\n  var prices: [Food: Decimal]\n\n  @Test static func specialOfTheDay() { ... } \/\/ ✅ OK: The function is static.\n  @Test func orderAllFoods() { ... } \/\/ ❌ ERROR: The suite type requires init().\n}\n```\n\nThe compiler emits an error when presented with a test suite that doesn’t meet this requirement.\n\n#### Test suite types must always be available\n\nAlthough `@available` can be applied to a test function to limit its availability at runtime, a test suite type (and any types that contain it) must *not* be annotated with the `@available` attribute:\n\n```swift\n@Suite struct FoodTruckTests { ... } \/\/ ✅ OK: The type is always available.\n\n@available(macOS 11.0, *) \/\/ ❌ ERROR: The suite type must always be available.\n@Suite struct CashRegisterTests { ... }\n\n@available(macOS 11.0, *) struct MenuItemTests { \/\/ ❌ ERROR: The suite type's\n                                                 \/\/ containing type must always\n                                                 \/\/ be available too.\n  @Suite struct BurgerTests { ... }\n}\n```\n\nThe compiler emits an error when presented with a test suite that doesn’t meet this requirement.\n\n## Essentials\n\n- **Defining test functions**: Define a test function to validate that code is working correctly.\n- **Migrating a test from XCTest**: Migrate an existing test method or test class written using XCTest.\n- **Test(_:_:)**: Declare a test.\n- **Test**: A type representing a test or suite.\n- **Suite(_:_:)**: Declare a test suite.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Define a test function to validate that code is working correctly.",
          "name" : "Defining test functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/DefiningTests"
        },
        {
          "description" : "Migrate an existing test method or test class written using XCTest.",
          "name" : "Migrating a test from XCTest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/MigratingFromXCTest"
        },
        {
          "description" : "Declare a test.",
          "name" : "Test(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test(_:_:)"
        },
        {
          "description" : "A type representing a test or suite.",
          "name" : "Test",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test"
        },
        {
          "description" : "Declare a test suite.",
          "name" : "Suite(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Suite(_:_:)"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Organizing test functions with suite types",
  "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/OrganizingTests"
}