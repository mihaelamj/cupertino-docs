{
  "abstract" : "Mark issues as known when running tests.",
  "codeExamples" : [
    {
      "code" : "@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  #expect(foodTruck.grill.isHeating) \/\/ ❌ Expectation failed\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue(\"Propane tank is empty\") {\n    #expect(foodTruck.grill.isHeating) \/\/ Known issue\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test func grillHeating() {\n  var foodTruck = FoodTruck()\n  withKnownIssue {\n    try foodTruck.startGrill() \/\/ Known issue\n    #expect(foodTruck.grill.isHeating)\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test func batteryLevel() throws {\n  var foodTruck = FoodTruck()\n  try withKnownIssue {\n    let batteryLevel = try #require(foodTruck.batteryLevel) \/\/ Known\n    #expect(batteryLevel >= 0.8) \/\/ Not considered known\n  } matching: { issue in\n    guard case .expectationFailed(let expectation) = issue.kind else {\n      return false\n    }\n    return expectation.isRequired\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue {\n    \/\/ Only considered known when hasPropane == false\n    #expect(foodTruck.grill.isHeating)\n  } when: {\n    !hasPropane\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue(isIntermittent: true) {\n    #expect(foodTruck.grill.isHeating)\n  }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "4e02f80e44989cbfd8ffcf92cca4e0529550b7b95a62e61b0862b84e7c4287ed",
  "crawledAt" : "2025-12-07T16:28:34Z",
  "id" : "42E79764-915A-40F1-B969-1F7C999A3040",
  "kind" : "collection",
  "language" : "swift",
  "module" : "Swift Testing",
  "overview" : "## Overview\n\nThe testing library provides several functions named `withKnownIssue()` that you can use to mark issues as known. Use them to inform the testing library that a test should not be marked as failing if only known issues are recorded.\n\n### Mark an expectation failure as known\n\nConsider a test function with a single expectation:\n\nIf the value of the `isHeating` property is `false`, `#expect` will record an issue. If you cannot fix the underlying problem, you can surround the failing code in a closure passed to `withKnownIssue()`:\n\nThe issue recorded by `#expect` will then be considered “known” and the test will not be marked as a failure. You may include an optional comment to explain the problem or provide context.\n\n### Mark a thrown error as known\n\nIf an `Error` is caught by the closure passed to `withKnownIssue()`, the issue representing that caught error will be marked as known. Continuing the previous example, suppose the problem is that the `startGrill()` function is throwing an error. You can apply `withKnownIssue()` to this situation as well:\n\nBecause all errors thrown from the closure are caught and interpreted as known issues, the `withKnownIssue()` function is not throwing. Consequently, any subsequent code which depends on the throwing call having succeeded (such as the `#expect` after `startGrill()`) must be included in the closure to avoid additional issues.\n\n### Match a specific issue\n\nBy default, `withKnownIssue()` considers all issues recorded while invoking the body closure known. If multiple issues may be recorded, you can pass a trailing closure labeled `matching:` which will be called once for each recorded issue to determine whether it should be treated as known:\n\n### Resolve a known issue\n\nIf there are no issues recorded while calling `function`, `withKnownIssue()` will record a distinct issue about the lack of any issues having been recorded. This notifies you that the underlying problem may have been resolved so that you can investigate and consider removing `withKnownIssue()` if it’s no longer necessary.\n\n### Handle a nondeterministic failure\n\nIf `withKnownIssue()` sometimes succeeds but other times records an issue indicating there were no known issues, this may indicate a nondeterministic failure or a “flaky” test.\n\nThe first step in resolving a nondeterministic test failure is to analyze the code being tested and determine the source of the unpredictable behavior. If you discover a bug such as a race condition, the ideal resolution is to fix the underlying problem so that the code always behaves consistently even if it continues to exhibit the known issue.\n\nIf the underlying problem only occurs in certain circumstances, consider including a precondition. For example, if the grill only fails to heat when there’s no propane, you can pass a trailing closure labeled `when:` which determines whether issues recorded in the body closure should be considered known:\n\nIf the underlying problem is unpredictable and fails at random, you can pass `isIntermittent: true` to let the testing library know that it will not always occur. Then, the testing library will not record an issue when zero known issues are recorded:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/testing\/known-issues\ncrawled: 2025-12-07T16:28:34Z\n---\n\n# Known issues\n\n**API Collection**\n\nMark issues as known when running tests.\n\n## Overview\n\nThe testing library provides several functions named `withKnownIssue()` that you can use to mark issues as known. Use them to inform the testing library that a test should not be marked as failing if only known issues are recorded.\n\n### Mark an expectation failure as known\n\nConsider a test function with a single expectation:\n\n```swift\n@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  #expect(foodTruck.grill.isHeating) \/\/ ❌ Expectation failed\n}\n```\n\nIf the value of the `isHeating` property is `false`, `#expect` will record an issue. If you cannot fix the underlying problem, you can surround the failing code in a closure passed to `withKnownIssue()`:\n\n```swift\n@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue(\"Propane tank is empty\") {\n    #expect(foodTruck.grill.isHeating) \/\/ Known issue\n  }\n}\n```\n\nThe issue recorded by `#expect` will then be considered “known” and the test will not be marked as a failure. You may include an optional comment to explain the problem or provide context.\n\n### Mark a thrown error as known\n\nIf an `Error` is caught by the closure passed to `withKnownIssue()`, the issue representing that caught error will be marked as known. Continuing the previous example, suppose the problem is that the `startGrill()` function is throwing an error. You can apply `withKnownIssue()` to this situation as well:\n\n```swift\n@Test func grillHeating() {\n  var foodTruck = FoodTruck()\n  withKnownIssue {\n    try foodTruck.startGrill() \/\/ Known issue\n    #expect(foodTruck.grill.isHeating)\n  }\n}\n```\n\nBecause all errors thrown from the closure are caught and interpreted as known issues, the `withKnownIssue()` function is not throwing. Consequently, any subsequent code which depends on the throwing call having succeeded (such as the `#expect` after `startGrill()`) must be included in the closure to avoid additional issues.\n\n\n\n### Match a specific issue\n\nBy default, `withKnownIssue()` considers all issues recorded while invoking the body closure known. If multiple issues may be recorded, you can pass a trailing closure labeled `matching:` which will be called once for each recorded issue to determine whether it should be treated as known:\n\n```swift\n@Test func batteryLevel() throws {\n  var foodTruck = FoodTruck()\n  try withKnownIssue {\n    let batteryLevel = try #require(foodTruck.batteryLevel) \/\/ Known\n    #expect(batteryLevel >= 0.8) \/\/ Not considered known\n  } matching: { issue in\n    guard case .expectationFailed(let expectation) = issue.kind else {\n      return false\n    }\n    return expectation.isRequired\n  }\n}\n```\n\n### Resolve a known issue\n\nIf there are no issues recorded while calling `function`, `withKnownIssue()` will record a distinct issue about the lack of any issues having been recorded. This notifies you that the underlying problem may have been resolved so that you can investigate and consider removing `withKnownIssue()` if it’s no longer necessary.\n\n### Handle a nondeterministic failure\n\nIf `withKnownIssue()` sometimes succeeds but other times records an issue indicating there were no known issues, this may indicate a nondeterministic failure or a “flaky” test.\n\nThe first step in resolving a nondeterministic test failure is to analyze the code being tested and determine the source of the unpredictable behavior. If you discover a bug such as a race condition, the ideal resolution is to fix the underlying problem so that the code always behaves consistently even if it continues to exhibit the known issue.\n\nIf the underlying problem only occurs in certain circumstances, consider including a precondition. For example, if the grill only fails to heat when there’s no propane, you can pass a trailing closure labeled `when:` which determines whether issues recorded in the body closure should be considered known:\n\n```swift\n@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue {\n    \/\/ Only considered known when hasPropane == false\n    #expect(foodTruck.grill.isHeating)\n  } when: {\n    !hasPropane\n  }\n}\n```\n\nIf the underlying problem is unpredictable and fails at random, you can pass `isIntermittent: true` to let the testing library know that it will not always occur. Then, the testing library will not record an issue when zero known issues are recorded:\n\n```swift\n@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue(isIntermittent: true) {\n    #expect(foodTruck.grill.isHeating)\n  }\n}\n```\n\n## Recording known issues in tests\n\n- **withKnownIssue(_:isIntermittent:sourceLocation:_:)**: Invoke a function that has a known issue that is expected to occur during its execution.\n- **withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:)**: Invoke a function that has a known issue that is expected to occur during its execution.\n- **withKnownIssue(_:isIntermittent:sourceLocation:_:when:matching:)**: Invoke a function that has a known issue that is expected to occur during its execution.\n- **withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:when:matching:)**: Invoke a function that has a known issue that is expected to occur during its execution.\n- **KnownIssueMatcher**: A function that is used to match known issues.\n\n## Describing a failure or warning\n\n- **Issue**: A type describing a failure or warning which occurred during a test.\n\n## Behavior validation\n\n- **Expectations and confirmations**: Check for expected values, outcomes, and asynchronous events in tests.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Invoke a function that has a known issue that is expected to occur during its execution.",
          "name" : "withKnownIssue(_:isIntermittent:sourceLocation:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/withKnownIssue(_:isIntermittent:sourceLocation:_:)"
        },
        {
          "description" : "Invoke a function that has a known issue that is expected to occur during its execution.",
          "name" : "withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:)"
        },
        {
          "description" : "Invoke a function that has a known issue that is expected to occur during its execution.",
          "name" : "withKnownIssue(_:isIntermittent:sourceLocation:_:when:matching:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/withKnownIssue(_:isIntermittent:sourceLocation:_:when:matching:)"
        },
        {
          "description" : "Invoke a function that has a known issue that is expected to occur during its execution.",
          "name" : "withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:when:matching:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:when:matching:)"
        },
        {
          "description" : "A function that is used to match known issues.",
          "name" : "KnownIssueMatcher",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/KnownIssueMatcher"
        }
      ],
      "title" : "Recording known issues in tests"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type describing a failure or warning which occurred during a test.",
          "name" : "Issue",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Issue"
        }
      ],
      "title" : "Describing a failure or warning"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Check for expected values, outcomes, and asynchronous events in tests.",
          "name" : "Expectations and confirmations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Expectations"
        }
      ],
      "title" : "Behavior validation"
    }
  ],
  "source" : "appleJSON",
  "title" : "Known issues",
  "url" : "https:\/\/developer.apple.com\/documentation\/testing\/known-issues"
}