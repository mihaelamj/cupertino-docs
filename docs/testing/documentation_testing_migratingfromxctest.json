{
  "abstract" : "Migrate an existing test method or test class written using XCTest.",
  "codeExamples" : [

  ],
  "contentHash" : "c4bd9bbbb4389b1ec5ace7abb7b0d10f9b3a9391ed1f9bf79b139b57ee238dc8",
  "crawledAt" : "2025-12-05T10:59:19Z",
  "id" : "479EE614-F23E-4E26-8738-E548C4FA6E78",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift Testing",
  "overview" : "## Overview\n\nThe testing library provides much of the same functionality of XCTest, but uses its own syntax to declare test functions and types. Here, you’ll learn how to convert XCTest-based content to use the testing library instead.\n\n### Import the testing library\n\nXCTest and the testing library are available from different modules. Instead of importing the XCTest module, import the Testing module:\n\nA single source file can contain tests written with XCTest as well as other tests written with the testing library. Import both XCTest and Testing if a source file contains mixed test content.\n\n### Convert test classes\n\nXCTest groups related sets of test methods in test classes: classes that inherit from the [https:\/\/developer.apple.com\/documentation\/xctest\/xctestcase] class provided by the [https:\/\/developer.apple.com\/documentation\/xctest] framework. The testing library doesn’t require that test functions be instance members of types. Instead, they can be *free* or *global* functions, or can be `static` or `class` members of a type.\n\nIf you want to group your test functions together, you can do so by placing them in a Swift type. The testing library refers to such a type as a *suite*. These types do *not* need to be classes, and they don’t inherit from `XCTestCase`.\n\nTo convert a subclass of `XCTestCase` to a suite, remove the `XCTestCase` conformance. It’s also generally recommended that a Swift structure or actor be used instead of a class because it allows the Swift compiler to better-enforce concurrency safety:\n\nFor more information about suites and how to declare and customize them, see [doc:\/\/org.swift.testing\/documentation\/Testing\/OrganizingTests].\n\n### Convert setup and teardown functions\n\nIn XCTest, code can be scheduled to run before and after a test using the [https:\/\/developer.apple.com\/documentation\/xctest\/xctest\/3856481-setup] and [https:\/\/developer.apple.com\/documentation\/xctest\/xctest\/3856482-teardown] family of functions. When writing tests using the testing library, implement `init()` and\/or `deinit` instead:\n\nThe use of `async` and `throws` is optional. If teardown is needed, declare your test suite as a class or as an actor rather than as a structure and implement `deinit`:\n\n### Convert test methods\n\nThe testing library represents individual tests as functions, similar to how they are represented in XCTest. However, the syntax for declaring a test function is different. In XCTest, a test method must be a member of a test class and its name must start with `test`. The testing library doesn’t require a test function to have any particular name. Instead, it identifies a test function by the presence of the `@Test` attribute:\n\nAs with XCTest, the testing library allows test functions to be marked `async`, `throws`, or `async`-`throws`, and to be isolated to a global actor (for example, by using the `@MainActor` attribute.)\n\nFor more information about test functions and how to declare and customize them, see [doc:\/\/org.swift.testing\/documentation\/Testing\/DefiningTests].\n\n### Check for expected values and outcomes\n\nXCTest uses a family of approximately 40 functions to assert test requirements. These functions are collectively referred to as [https:\/\/developer.apple.com\/documentation\/xctest\/1500669-xctassert]. The testing library has two replacements, [doc:\/\/org.swift.testing\/documentation\/Testing\/expect(_:_:sourceLocation:)] and [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q]. They both behave similarly to `XCTAssert()` except that [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q] throws an error if its condition isn’t met:\n\n### Check for optional values\n\nXCTest also has a function, [https:\/\/developer.apple.com\/documentation\/xctest\/3380195-xctunwrap], that tests if an optional value is `nil` and throws an error if it is. When using the testing library, you can use [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-6w9oo] with optional expressions to unwrap them:\n\n### Record issues\n\nXCTest has a function, [https:\/\/developer.apple.com\/documentation\/xctest\/1500970-xctfail], that causes a test to fail immediately and unconditionally. This function is useful when the syntax of the language prevents the use of an `XCTAssert()` function. To record an unconditional issue using the testing library, use the [doc:\/\/org.swift.testing\/documentation\/Testing\/Issue\/record(_:sourceLocation:)] function:\n\nThe following table includes a list of the various `XCTAssert()` functions and their equivalents in the testing library:\n\nThe testing library doesn’t provide an equivalent of [https:\/\/developer.apple.com\/documentation\/xctest\/3551607-xctassertequal]. To compare two numeric values within a specified accuracy, use `isApproximatelyEqual()` from [https:\/\/github.com\/apple\/swift-numerics].\n\n### Continue or halt after test failures\n\nAn instance of an `XCTestCase` subclass can set its [https:\/\/developer.apple.com\/documentation\/xctest\/xctestcase\/1496260-continueafterfailure] property to `false` to cause a test to stop running after a failure occurs. XCTest stops an affected test by throwing an Objective-C exception at the time the failure occurs.\n\nThe behavior of an exception thrown through a Swift stack frame is undefined. If an exception is thrown through an `async` Swift function, it typically causes the process to terminate abnormally, preventing other tests from running.\n\nThe testing library doesn’t use exceptions to stop test functions. Instead, use the [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q] macro, which throws a Swift error on failure:\n\nWhen using either `continueAfterFailure` or [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q], other tests will continue to run after the failed test method or test function.\n\n### Validate asynchronous behaviors\n\nXCTest has a class, [https:\/\/developer.apple.com\/documentation\/xctest\/xctestexpectation], that represents some asynchronous condition. You create an instance of this class (or a subclass like [https:\/\/developer.apple.com\/documentation\/xctest\/xctkeypathexpectation]) using an initializer or a convenience method on `XCTestCase`. When the condition represented by an expectation occurs, the developer *fulfills* the expectation. Concurrently, the developer *waits for* the expectation to be fulfilled using an instance of [https:\/\/developer.apple.com\/documentation\/xctest\/xctwaiter] or using a convenience method on `XCTestCase`.\n\nWherever possible, prefer to use Swift concurrency to validate asynchronous conditions. For example, if it’s necessary to determine the result of an asynchronous Swift function, it can be awaited with `await`. For a function that takes a completion handler but which doesn’t use `await`, a Swift [https:\/\/developer.apple.com\/documentation\/swift\/withcheckedcontinuation(isolation:function:_:)] can be used to convert the call into an `async`-compatible one.\n\nSome tests, especially those that test asynchronously-delivered events, cannot be readily converted to use Swift concurrency. The testing library offers functionality called *confirmations* which can be used to implement these tests. Instances of [doc:\/\/org.swift.testing\/documentation\/Testing\/Confirmation] are created and used within the scope of the functions [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-5mqz2] and [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-l3il].\n\nConfirmations function similarly to the expectations API of XCTest, however, they don’t block or suspend the caller while waiting for a condition to be fulfilled. Instead, the requirement is expected to be *confirmed* (the equivalent of *fulfilling* an expectation) before `confirmation()` returns, and records an issue otherwise:\n\nBy default, `XCTestExpectation` expects to be fulfilled exactly once, and will record an issue in the current test if it is not fulfilled or if it is fulfilled more than once. `Confirmation` behaves the same way and expects to be confirmed exactly once by default. You can configure the number of times an expectation should be fulfilled by setting its [https:\/\/developer.apple.com\/documentation\/xctest\/xctestexpectation\/2806572-expectedfulfillmentcount] property, and you can pass a value for the `expectedCount` argument of [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-5mqz2] for the same purpose.\n\n`XCTestExpectation` has a property, [https:\/\/developer.apple.com\/documentation\/xctest\/xctestexpectation\/2806575-assertforoverfulfill], which when set to `false` allows an expectation to be fulfilled more times than expected without causing a test failure. When using a confirmation, you can pass a range to [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-l3il] as its expected count to indicate that it must be confirmed *at least* some number of times:\n\nAny range expression with a lower bound (that is, whose type conforms to both [https:\/\/developer.apple.com\/documentation\/swift\/rangeexpression] and [https:\/\/developer.apple.com\/documentation\/swift\/sequence]) can be used with [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-l3il]. You must specify a lower bound for the number of confirmations because, without one, the testing library cannot tell if an issue should be recorded when there have been zero confirmations.\n\n### Control whether a test runs\n\nWhen using XCTest, the [https:\/\/developer.apple.com\/documentation\/xctest\/xctskip] error type can be thrown to bypass the remainder of a test function. As well, the [https:\/\/developer.apple.com\/documentation\/xctest\/3521325-xctskipif] and [https:\/\/developer.apple.com\/documentation\/xctest\/3521326-xctskipunless] functions can be used to conditionalize the same action. The testing library allows developers to skip a test function or an entire test suite before it starts running using the [doc:\/\/org.swift.testing\/documentation\/Testing\/ConditionTrait] trait type. Annotate a test suite or test function with an instance of this trait type to control whether it runs:\n\n### Annotate known issues\n\nA test may have a known issue that sometimes or always prevents it from passing. When written using XCTest, such tests can call [https:\/\/developer.apple.com\/documentation\/xctest\/3727246-xctexpectfailure] to tell XCTest and its infrastructure that the issue shouldn’t cause the test to fail. The testing library has an equivalent function with synchronous and asynchronous variants:\n\nThis function can be used to annotate a section of a test as having a known issue:\n\nIf a test may fail intermittently, the call to `XCTExpectFailure(_:options:failingBlock:)` can be marked *non-strict*. When using the testing library, specify that the known issue is *intermittent* instead:\n\nAdditional options can be specified when calling `XCTExpectFailure()`:\n\nThe testing library includes overloads of `withKnownIssue()` that take additional arguments with similar behavior:\n\nTo conditionally enable known-issue matching or to match only certain kinds of issues:\n\n### Run tests sequentially\n\nBy default, the testing library runs all tests in a suite in parallel. The default behavior of XCTest is to run each test in a suite sequentially. If your tests use shared state such as global variables, you may see unexpected behavior including unreliable test outcomes when you run tests in parallel.\n\nAnnotate your test suite with [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/serialized] to run tests within that suite serially:\n\nFor more information, see [doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization].\n\n### Attach values\n\nIn XCTest, you can create an instance of [https:\/\/developer.apple.com\/documentation\/xctest\/xctattachment] representing arbitrary data, files, property lists, encodable objects, images, and other types of information that would be useful to have available if a test fails. Swift Testing has an [doc:\/\/org.swift.testing\/documentation\/Testing\/Attachment] type that serves much the same purpose.\n\nTo attach a value from a test to the output of a test run, that value must conform to the [doc:\/\/org.swift.testing\/documentation\/Testing\/Attachable] protocol. The testing library provides default conformances for various standard library and Foundation types.\n\nIf you want to attach a value of another type, and that type already conforms to [https:\/\/developer.apple.com\/documentation\/swift\/encodable] or to [https:\/\/developer.apple.com\/documentation\/foundation\/nssecurecoding], the testing library automatically provides a default implementation when you import Foundation:\n\nIf you have a type that does not (or cannot) conform to `Encodable` or `NSSecureCoding`, or if you want fine-grained control over how it is serialized when attaching it to a test, you can provide your own implementation of [doc:\/\/org.swift.testing\/documentation\/Testing\/Attachable\/withUnsafeBytes(for:_:)].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/testing\/migratingfromxctest\ncrawled: 2025-12-05T10:59:19Z\n---\n\n# Migrating a test from XCTest\n\n**Article**\n\nMigrate an existing test method or test class written using XCTest.\n\n## Overview\n\nThe testing library provides much of the same functionality of XCTest, but uses its own syntax to declare test functions and types. Here, you’ll learn how to convert XCTest-based content to use the testing library instead.\n\n### Import the testing library\n\nXCTest and the testing library are available from different modules. Instead of importing the XCTest module, import the Testing module:\n\n\n\nA single source file can contain tests written with XCTest as well as other tests written with the testing library. Import both XCTest and Testing if a source file contains mixed test content.\n\n### Convert test classes\n\nXCTest groups related sets of test methods in test classes: classes that inherit from the [https:\/\/developer.apple.com\/documentation\/xctest\/xctestcase] class provided by the [https:\/\/developer.apple.com\/documentation\/xctest] framework. The testing library doesn’t require that test functions be instance members of types. Instead, they can be *free* or *global* functions, or can be `static` or `class` members of a type.\n\nIf you want to group your test functions together, you can do so by placing them in a Swift type. The testing library refers to such a type as a *suite*. These types do *not* need to be classes, and they don’t inherit from `XCTestCase`.\n\nTo convert a subclass of `XCTestCase` to a suite, remove the `XCTestCase` conformance. It’s also generally recommended that a Swift structure or actor be used instead of a class because it allows the Swift compiler to better-enforce concurrency safety:\n\n\n\nFor more information about suites and how to declare and customize them, see [doc:\/\/org.swift.testing\/documentation\/Testing\/OrganizingTests].\n\n### Convert setup and teardown functions\n\nIn XCTest, code can be scheduled to run before and after a test using the [https:\/\/developer.apple.com\/documentation\/xctest\/xctest\/3856481-setup] and [https:\/\/developer.apple.com\/documentation\/xctest\/xctest\/3856482-teardown] family of functions. When writing tests using the testing library, implement `init()` and\/or `deinit` instead:\n\n\n\nThe use of `async` and `throws` is optional. If teardown is needed, declare your test suite as a class or as an actor rather than as a structure and implement `deinit`:\n\n\n\n### Convert test methods\n\nThe testing library represents individual tests as functions, similar to how they are represented in XCTest. However, the syntax for declaring a test function is different. In XCTest, a test method must be a member of a test class and its name must start with `test`. The testing library doesn’t require a test function to have any particular name. Instead, it identifies a test function by the presence of the `@Test` attribute:\n\n\n\nAs with XCTest, the testing library allows test functions to be marked `async`, `throws`, or `async`-`throws`, and to be isolated to a global actor (for example, by using the `@MainActor` attribute.)\n\n\n\nFor more information about test functions and how to declare and customize them, see [doc:\/\/org.swift.testing\/documentation\/Testing\/DefiningTests].\n\n### Check for expected values and outcomes\n\nXCTest uses a family of approximately 40 functions to assert test requirements. These functions are collectively referred to as [https:\/\/developer.apple.com\/documentation\/xctest\/1500669-xctassert]. The testing library has two replacements, [doc:\/\/org.swift.testing\/documentation\/Testing\/expect(_:_:sourceLocation:)] and [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q]. They both behave similarly to `XCTAssert()` except that [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q] throws an error if its condition isn’t met:\n\n\n\n### Check for optional values\n\nXCTest also has a function, [https:\/\/developer.apple.com\/documentation\/xctest\/3380195-xctunwrap], that tests if an optional value is `nil` and throws an error if it is. When using the testing library, you can use [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-6w9oo] with optional expressions to unwrap them:\n\n\n\n### Record issues\n\nXCTest has a function, [https:\/\/developer.apple.com\/documentation\/xctest\/1500970-xctfail], that causes a test to fail immediately and unconditionally. This function is useful when the syntax of the language prevents the use of an `XCTAssert()` function. To record an unconditional issue using the testing library, use the [doc:\/\/org.swift.testing\/documentation\/Testing\/Issue\/record(_:sourceLocation:)] function:\n\n\n\nThe following table includes a list of the various `XCTAssert()` functions and their equivalents in the testing library:\n\n\n\nThe testing library doesn’t provide an equivalent of [https:\/\/developer.apple.com\/documentation\/xctest\/3551607-xctassertequal]. To compare two numeric values within a specified accuracy, use `isApproximatelyEqual()` from [https:\/\/github.com\/apple\/swift-numerics].\n\n### Continue or halt after test failures\n\nAn instance of an `XCTestCase` subclass can set its [https:\/\/developer.apple.com\/documentation\/xctest\/xctestcase\/1496260-continueafterfailure] property to `false` to cause a test to stop running after a failure occurs. XCTest stops an affected test by throwing an Objective-C exception at the time the failure occurs.\n\n\n\nThe behavior of an exception thrown through a Swift stack frame is undefined. If an exception is thrown through an `async` Swift function, it typically causes the process to terminate abnormally, preventing other tests from running.\n\nThe testing library doesn’t use exceptions to stop test functions. Instead, use the [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q] macro, which throws a Swift error on failure:\n\n\n\nWhen using either `continueAfterFailure` or [doc:\/\/org.swift.testing\/documentation\/Testing\/require(_:_:sourceLocation:)-5l63q], other tests will continue to run after the failed test method or test function.\n\n### Validate asynchronous behaviors\n\nXCTest has a class, [https:\/\/developer.apple.com\/documentation\/xctest\/xctestexpectation], that represents some asynchronous condition. You create an instance of this class (or a subclass like [https:\/\/developer.apple.com\/documentation\/xctest\/xctkeypathexpectation]) using an initializer or a convenience method on `XCTestCase`. When the condition represented by an expectation occurs, the developer *fulfills* the expectation. Concurrently, the developer *waits for* the expectation to be fulfilled using an instance of [https:\/\/developer.apple.com\/documentation\/xctest\/xctwaiter] or using a convenience method on `XCTestCase`.\n\nWherever possible, prefer to use Swift concurrency to validate asynchronous conditions. For example, if it’s necessary to determine the result of an asynchronous Swift function, it can be awaited with `await`. For a function that takes a completion handler but which doesn’t use `await`, a Swift [https:\/\/developer.apple.com\/documentation\/swift\/withcheckedcontinuation(isolation:function:_:)] can be used to convert the call into an `async`-compatible one.\n\nSome tests, especially those that test asynchronously-delivered events, cannot be readily converted to use Swift concurrency. The testing library offers functionality called *confirmations* which can be used to implement these tests. Instances of [doc:\/\/org.swift.testing\/documentation\/Testing\/Confirmation] are created and used within the scope of the functions [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-5mqz2] and [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-l3il].\n\nConfirmations function similarly to the expectations API of XCTest, however, they don’t block or suspend the caller while waiting for a condition to be fulfilled. Instead, the requirement is expected to be *confirmed* (the equivalent of *fulfilling* an expectation) before `confirmation()` returns, and records an issue otherwise:\n\n\n\nBy default, `XCTestExpectation` expects to be fulfilled exactly once, and will record an issue in the current test if it is not fulfilled or if it is fulfilled more than once. `Confirmation` behaves the same way and expects to be confirmed exactly once by default. You can configure the number of times an expectation should be fulfilled by setting its [https:\/\/developer.apple.com\/documentation\/xctest\/xctestexpectation\/2806572-expectedfulfillmentcount] property, and you can pass a value for the `expectedCount` argument of [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-5mqz2] for the same purpose.\n\n`XCTestExpectation` has a property, [https:\/\/developer.apple.com\/documentation\/xctest\/xctestexpectation\/2806575-assertforoverfulfill], which when set to `false` allows an expectation to be fulfilled more times than expected without causing a test failure. When using a confirmation, you can pass a range to [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-l3il] as its expected count to indicate that it must be confirmed *at least* some number of times:\n\n\n\nAny range expression with a lower bound (that is, whose type conforms to both [https:\/\/developer.apple.com\/documentation\/swift\/rangeexpression] and [https:\/\/developer.apple.com\/documentation\/swift\/sequence]) can be used with [doc:\/\/org.swift.testing\/documentation\/Testing\/confirmation(_:expectedCount:isolation:sourceLocation:_:)-l3il]. You must specify a lower bound for the number of confirmations because, without one, the testing library cannot tell if an issue should be recorded when there have been zero confirmations.\n\n### Control whether a test runs\n\nWhen using XCTest, the [https:\/\/developer.apple.com\/documentation\/xctest\/xctskip] error type can be thrown to bypass the remainder of a test function. As well, the [https:\/\/developer.apple.com\/documentation\/xctest\/3521325-xctskipif] and [https:\/\/developer.apple.com\/documentation\/xctest\/3521326-xctskipunless] functions can be used to conditionalize the same action. The testing library allows developers to skip a test function or an entire test suite before it starts running using the [doc:\/\/org.swift.testing\/documentation\/Testing\/ConditionTrait] trait type. Annotate a test suite or test function with an instance of this trait type to control whether it runs:\n\n\n\n### Annotate known issues\n\nA test may have a known issue that sometimes or always prevents it from passing. When written using XCTest, such tests can call [https:\/\/developer.apple.com\/documentation\/xctest\/3727246-xctexpectfailure] to tell XCTest and its infrastructure that the issue shouldn’t cause the test to fail. The testing library has an equivalent function with synchronous and asynchronous variants:\n\n- [doc:\/\/org.swift.testing\/documentation\/Testing\/withKnownIssue(_:isIntermittent:sourceLocation:_:)]\n- [doc:\/\/org.swift.testing\/documentation\/Testing\/withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:)]\n\nThis function can be used to annotate a section of a test as having a known issue:\n\n\n\n\n\nIf a test may fail intermittently, the call to `XCTExpectFailure(_:options:failingBlock:)` can be marked *non-strict*. When using the testing library, specify that the known issue is *intermittent* instead:\n\n\n\nAdditional options can be specified when calling `XCTExpectFailure()`:\n\n- [https:\/\/developer.apple.com\/documentation\/xctest\/xctexpectedfailure\/options\/3726085-isenabled] can be set to `false` to skip known-issue matching (for instance, if a particular issue only occurs under certain conditions)\n- [https:\/\/developer.apple.com\/documentation\/xctest\/xctexpectedfailure\/options\/3726086-issuematcher] can be set to a closure to allow marking only certain issues as known and to allow other issues to be recorded as test failures\n\nThe testing library includes overloads of `withKnownIssue()` that take additional arguments with similar behavior:\n\n- [doc:\/\/org.swift.testing\/documentation\/Testing\/withKnownIssue(_:isIntermittent:sourceLocation:_:when:matching:)]\n- [doc:\/\/org.swift.testing\/documentation\/Testing\/withKnownIssue(_:isIntermittent:isolation:sourceLocation:_:when:matching:)]\n\nTo conditionally enable known-issue matching or to match only certain kinds of issues:\n\n\n\n### Run tests sequentially\n\nBy default, the testing library runs all tests in a suite in parallel. The default behavior of XCTest is to run each test in a suite sequentially. If your tests use shared state such as global variables, you may see unexpected behavior including unreliable test outcomes when you run tests in parallel.\n\nAnnotate your test suite with [doc:\/\/org.swift.testing\/documentation\/Testing\/Trait\/serialized] to run tests within that suite serially:\n\n\n\nFor more information, see [doc:\/\/org.swift.testing\/documentation\/Testing\/Parallelization].\n\n### Attach values\n\nIn XCTest, you can create an instance of [https:\/\/developer.apple.com\/documentation\/xctest\/xctattachment] representing arbitrary data, files, property lists, encodable objects, images, and other types of information that would be useful to have available if a test fails. Swift Testing has an [doc:\/\/org.swift.testing\/documentation\/Testing\/Attachment] type that serves much the same purpose.\n\nTo attach a value from a test to the output of a test run, that value must conform to the [doc:\/\/org.swift.testing\/documentation\/Testing\/Attachable] protocol. The testing library provides default conformances for various standard library and Foundation types.\n\nIf you want to attach a value of another type, and that type already conforms to [https:\/\/developer.apple.com\/documentation\/swift\/encodable] or to [https:\/\/developer.apple.com\/documentation\/foundation\/nssecurecoding], the testing library automatically provides a default implementation when you import Foundation:\n\n\n\nIf you have a type that does not (or cannot) conform to `Encodable` or `NSSecureCoding`, or if you want fine-grained control over how it is serialized when attaching it to a test, you can provide your own implementation of [doc:\/\/org.swift.testing\/documentation\/Testing\/Attachable\/withUnsafeBytes(for:_:)].\n\n## Related Documentation\n\n- **Defining test functions**: Define a test function to validate that code is working correctly.\n- **Organizing test functions with suite types**: Organize tests into test suites.\n- **Expectations and confirmations**: Check for expected values, outcomes, and asynchronous events in tests.\n- **Known issues**: Mark issues as known when running tests.\n\n## Essentials\n\n- **Defining test functions**: Define a test function to validate that code is working correctly.\n- **Organizing test functions with suite types**: Organize tests into test suites.\n- **Test(_:_:)**: Declare a test.\n- **Test**: A type representing a test or suite.\n- **Suite(_:_:)**: Declare a test suite.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Define a test function to validate that code is working correctly.",
          "name" : "Defining test functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/DefiningTests"
        },
        {
          "description" : "Organize tests into test suites.",
          "name" : "Organizing test functions with suite types",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/OrganizingTests"
        },
        {
          "description" : "Check for expected values, outcomes, and asynchronous events in tests.",
          "name" : "Expectations and confirmations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Expectations"
        },
        {
          "description" : "Mark issues as known when running tests.",
          "name" : "Known issues",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/known-issues"
        }
      ],
      "title" : "Related Documentation"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Define a test function to validate that code is working correctly.",
          "name" : "Defining test functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/DefiningTests"
        },
        {
          "description" : "Organize tests into test suites.",
          "name" : "Organizing test functions with suite types",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/OrganizingTests"
        },
        {
          "description" : "Declare a test.",
          "name" : "Test(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test(_:_:)"
        },
        {
          "description" : "A type representing a test or suite.",
          "name" : "Test",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Test"
        },
        {
          "description" : "Declare a test suite.",
          "name" : "Suite(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Testing\/Suite(_:_:)"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Migrating a test from XCTest",
  "url" : "https:\/\/developer.apple.com\/documentation\/testing\/migratingfromxctest"
}