{
  "abstract" : "Add precision and improve musical control for your MIDI apps.",
  "codeExamples" : [
    {
      "code" : "private func setupMIDI() -> Bool {\n    let status = MIDIClientCreateWithBlock(\"Packet Sender\" as CFString, &client, { [weak self] notification in\n        self?.handleMIDI(notification)\n    })\n    guard status == noErr else {\n        print(\"Failed to create the MIDI client.\")\n        return false\n    }\n\n    if midiAdapter.openMIDIPort(client, named: \"MIDI Output Port\" as CFString, port: &port) != noErr {\n        print(\"Failed to create the MIDI port.\")\n        return false\n    }\n    return true\n}",
      "language" : "swift"
    },
    {
      "code" : "case .noteOn(._1_0):\n    guard let noteNumber = packetModel.getChunk(PacketChunkDescription.noteNumber)?.uint8Value,\n          let velocity = packetModel.getChunk(PacketChunkDescription.velocity)?.uint8Value else {\n                return\n            }\n\n    result = midiAdapter.sendMIDI1UPMessage(MIDI1UPNoteOn(group,\n                                                          channel,\n                                                          noteNumber,\n                                                          velocity),\n                                            port: port,\n                                            destination: destination)\n\ncase .noteOn(._2_0):\n    guard let noteNumber = packetModel.getChunk(PacketChunkDescription.noteNumber)?.uint8Value,\n          let attributeType = packetModel.getChunk(PacketChunkDescription.attributeType)?.uint8Value,\n          let attributeData = packetModel.getChunk(PacketChunkDescription.attribute)?.uint16Value,\n          let velocity = packetModel.getChunk(PacketChunkDescription.velocity)?.uint16Value else {\n                return\n            }\n    \n    result = midiAdapter.sendMIDI2Message(MIDI2NoteOn(group,\n                                                      channel,\n                                                      noteNumber,\n                                                      attributeType,\n                                                      attributeData,\n                                                      velocity),\n                                          port: port,\n                                          destination: destination)",
      "language" : "swift"
    },
    {
      "code" : "-(OSStatus)sendMIDI1UPMessage:(MIDIMessage_32)message port:(MIDIPortRef)port destination:(MIDIEndpointRef)destination {\n    MIDIEventList eventList = {};\n    MIDIEventPacket *packet = MIDIEventListInit(&eventList, kMIDIProtocol_1_0);\n    packet = MIDIEventListAdd(&eventList, sizeof(MIDIEventList), packet, 0, 1, (UInt32 *)&message);\n    return MIDISendEventList(port, destination, &eventList);\n}",
      "language" : "objective-c"
    },
    {
      "code" : "-(OSStatus)createMIDIDestination:(MIDIClientRef)client named:(CFStringRef)name protocol:(MIDIProtocolID)protocol dest:(MIDIEndpointRef *)outDest {\n    __block MIDIMessageFIFO *msgQueue = messageQueue.get();\n    const auto status = MIDIDestinationCreateWithProtocol(client, name, protocol, outDest, ^(const MIDIEventList * _Nonnull evtlist, void * _Nullable srcConnRefCon) {\n        \n        if (evtlist->numPackets > 0 && msgQueue) {\n            auto pkt = &evtlist->packet[0];\n\n            for (int i = 0; i < evtlist->numPackets; ++i) {\n                if (!msgQueue->push(evtlist->packet[i])) {\n                    msgQueue->push(evtlist->packet[i]);\n                }\n                pkt = MIDIEventPacketNext(pkt);\n            }\n        }\n    });\n    return status;\n}",
      "language" : "objective-c"
    }
  ],
  "contentHash" : "ef5cb4ba784b25a9a3d1e7865f439ef8f7c826fd13c2929057a21b5b0d4594c9",
  "crawledAt" : "2025-12-04T20:12:37Z",
  "id" : "53FB4F34-2B0D-4F18-A086-6DAAA3FD7871",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Core MIDI",
  "overview" : "## Overview\n\nThe MIDI 2 standard defines the Universal MIDI Packet (UMP) structure for the MIDI protocol transfer. Both MIDI 1 and 2 use the same structure. The framework expresses a MIDI 1 packet as MIDI-1UP, and the group field in UMP allows you to send up to 16 combined MIDI streams at the same time.\n\nThe MIDI 1 specification includes only the MIDI 1 protocol. The MIDI 2 specification includes the protocols MIDI 1, MIDI-1UP, MIDI 2, and the MIDI Capability Inquiry (MIDI-CI). The only requirement for you to provide a MIDI 2 device is bidirectional communication, which is necessary for MIDI-CI.\n\nThis sample code project shows how to use Core MIDI in [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/midi-services]. The sample consists of two targets built in Mac Catalyst that you use to send or receive MIDI events. Use the targets on the same device to show the transmission of UMP MIDI data.\n\n### Configure the sample code project\n\nTo run this sample app in macOS or iPadOS:\n\n### Understand MIDI-1UP and MIDI 2\n\nBy default, Core MIDI adopts the MIDI 2 specification and transparently converts sent MIDI data into the packet format and protocol a MIDI destination specifies. Regardless of the source packet format and protocol, legacy MIDI destinations receive [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIPacketList]. MIDI 2 destinations receive [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventList].\n\n### Build a Universal MIDI Packet\n\nThe UMP send target shows how to build and send UMP events to a MIDI destination a person selects. The user interface allows for selecting the type of MIDI message to send before customizing the different elements of the packet. The visualizer provides a tabular view of the contents of the packet in decimal, binary, and hexadecimal form.\n\nThe app stores the packet state in `PacketModel`, and it contains an array of `PacketChunk` objects describing the individual elements of the UMP message.\n\nAfter the app launches, it creates a `PacketSender` object that the app uses to construct and send MIDI packets. The first step of initialization is creating the Core MIDI client the app maintains as a strong reference throughout its lifetime. Next, the app creates an output port by calling  [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIOutputPortCreate(_:_:_:)].\n\nAfter the user presses the Send button, the sample gets the current values for each `PacketModel` and — depending on the MIDI protocol — creates a `MIDIMessage_32` or `MIDIMessage_64` by using one of the [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/midi-messages].\n\nThe code below shows how the app sends a note on an event for the MIDI-1UP and MIDI 2 protocols. In the `noteOn(._1_0)` case, the app calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDI1UPNoteOn(_:_:_:_:)] to create a 32-bit message, and passes in a MIDI group, channel, note number, and velocity. In the `noteOn(._2_0)` case, the app calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDI2NoteOn(_:_:_:_:_:_:)] to create a 64-bit message, and passes in a MIDI group, channel, note number, attribute type, attribute data, and velocity.\n\n### Send a MIDI event to a destination\n\nThe sample sends data by initializing a [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventList] and passing the event by reference, supplying the MIDI protocol as the second argument. Finally, the sample calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventListAdd(_:_:_:_:_:_:)] to add the event to the list, and calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDISendEventList(_:_:_:)] with a port, destination, and the event list.\n\n### Receive a MIDI event from a destination\n\nThe receiver target demonstrates how to create a Core MIDI destination with a protocol, and consumes incoming MIDI events, displaying them in a MIDI log.\n\nThe sample provides a text box to enter a custom destination name, a picker for protocol selection, and a log to view the incoming MIDI events.\n\nThe receiver target creates a Core MIDI client, and when the user presses the Create Destination button, the sample uses [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIDestinationCreateWithProtocol(_:_:_:_:_:)] to create a destination with a name, a MIDI protocol, and a callback block. When the system receives events, the sample iterates the [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventList] and pushes them onto a queue to consume on the main thread.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/coremidi\/incorporating-midi-2-into-your-apps\ncrawled: 2025-12-04T20:12:37Z\n---\n\n# Incorporating MIDI 2 into your apps\n\n**Sample Code**\n\nAdd precision and improve musical control for your MIDI apps.\n\n## Overview\n\nThe MIDI 2 standard defines the Universal MIDI Packet (UMP) structure for the MIDI protocol transfer. Both MIDI 1 and 2 use the same structure. The framework expresses a MIDI 1 packet as MIDI-1UP, and the group field in UMP allows you to send up to 16 combined MIDI streams at the same time.\n\nThe MIDI 1 specification includes only the MIDI 1 protocol. The MIDI 2 specification includes the protocols MIDI 1, MIDI-1UP, MIDI 2, and the MIDI Capability Inquiry (MIDI-CI). The only requirement for you to provide a MIDI 2 device is bidirectional communication, which is necessary for MIDI-CI.\n\nThis sample code project shows how to use Core MIDI in [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/midi-services]. The sample consists of two targets built in Mac Catalyst that you use to send or receive MIDI events. Use the targets on the same device to show the transmission of UMP MIDI data.\n\n### Configure the sample code project\n\nTo run this sample app in macOS or iPadOS:\n\n1. Build and launch the UMP Receiver target in Xcode.\n2. In the UMP Receiver app, create a MIDI destination by providing a name for the destination and clicking or tapping the Create Destination button.\n3. If the app is running on iPad, switch the receiver app to a Slide Over window.\n4. Build and launch the UMP Send target in Xcode.\n5. In the UMP Send app, select a MIDI message type to send, select a destination, and click or tap the Send button.\n\n### Understand MIDI-1UP and MIDI 2\n\nBy default, Core MIDI adopts the MIDI 2 specification and transparently converts sent MIDI data into the packet format and protocol a MIDI destination specifies. Regardless of the source packet format and protocol, legacy MIDI destinations receive [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIPacketList]. MIDI 2 destinations receive [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventList].\n\n### Build a Universal MIDI Packet\n\nThe UMP send target shows how to build and send UMP events to a MIDI destination a person selects. The user interface allows for selecting the type of MIDI message to send before customizing the different elements of the packet. The visualizer provides a tabular view of the contents of the packet in decimal, binary, and hexadecimal form.\n\nThe app stores the packet state in `PacketModel`, and it contains an array of `PacketChunk` objects describing the individual elements of the UMP message.\n\nAfter the app launches, it creates a `PacketSender` object that the app uses to construct and send MIDI packets. The first step of initialization is creating the Core MIDI client the app maintains as a strong reference throughout its lifetime. Next, the app creates an output port by calling  [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIOutputPortCreate(_:_:_:)].\n\n```swift\nprivate func setupMIDI() -> Bool {\n    let status = MIDIClientCreateWithBlock(\"Packet Sender\" as CFString, &client, { [weak self] notification in\n        self?.handleMIDI(notification)\n    })\n    guard status == noErr else {\n        print(\"Failed to create the MIDI client.\")\n        return false\n    }\n\n    if midiAdapter.openMIDIPort(client, named: \"MIDI Output Port\" as CFString, port: &port) != noErr {\n        print(\"Failed to create the MIDI port.\")\n        return false\n    }\n    return true\n}\n```\n\nAfter the user presses the Send button, the sample gets the current values for each `PacketModel` and — depending on the MIDI protocol — creates a `MIDIMessage_32` or `MIDIMessage_64` by using one of the [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/midi-messages].\n\nThe code below shows how the app sends a note on an event for the MIDI-1UP and MIDI 2 protocols. In the `noteOn(._1_0)` case, the app calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDI1UPNoteOn(_:_:_:_:)] to create a 32-bit message, and passes in a MIDI group, channel, note number, and velocity. In the `noteOn(._2_0)` case, the app calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDI2NoteOn(_:_:_:_:_:_:)] to create a 64-bit message, and passes in a MIDI group, channel, note number, attribute type, attribute data, and velocity.\n\n```swift\ncase .noteOn(._1_0):\n    guard let noteNumber = packetModel.getChunk(PacketChunkDescription.noteNumber)?.uint8Value,\n          let velocity = packetModel.getChunk(PacketChunkDescription.velocity)?.uint8Value else {\n                return\n            }\n\n    result = midiAdapter.sendMIDI1UPMessage(MIDI1UPNoteOn(group,\n                                                          channel,\n                                                          noteNumber,\n                                                          velocity),\n                                            port: port,\n                                            destination: destination)\n\ncase .noteOn(._2_0):\n    guard let noteNumber = packetModel.getChunk(PacketChunkDescription.noteNumber)?.uint8Value,\n          let attributeType = packetModel.getChunk(PacketChunkDescription.attributeType)?.uint8Value,\n          let attributeData = packetModel.getChunk(PacketChunkDescription.attribute)?.uint16Value,\n          let velocity = packetModel.getChunk(PacketChunkDescription.velocity)?.uint16Value else {\n                return\n            }\n    \n    result = midiAdapter.sendMIDI2Message(MIDI2NoteOn(group,\n                                                      channel,\n                                                      noteNumber,\n                                                      attributeType,\n                                                      attributeData,\n                                                      velocity),\n                                          port: port,\n                                          destination: destination)\n```\n\n### Send a MIDI event to a destination\n\nThe sample sends data by initializing a [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventList] and passing the event by reference, supplying the MIDI protocol as the second argument. Finally, the sample calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventListAdd(_:_:_:_:_:_:)] to add the event to the list, and calls [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDISendEventList(_:_:_:)] with a port, destination, and the event list.\n\n```objective-c\n-(OSStatus)sendMIDI1UPMessage:(MIDIMessage_32)message port:(MIDIPortRef)port destination:(MIDIEndpointRef)destination {\n    MIDIEventList eventList = {};\n    MIDIEventPacket *packet = MIDIEventListInit(&eventList, kMIDIProtocol_1_0);\n    packet = MIDIEventListAdd(&eventList, sizeof(MIDIEventList), packet, 0, 1, (UInt32 *)&message);\n    return MIDISendEventList(port, destination, &eventList);\n}\n```\n\n### Receive a MIDI event from a destination\n\nThe receiver target demonstrates how to create a Core MIDI destination with a protocol, and consumes incoming MIDI events, displaying them in a MIDI log.\n\nThe sample provides a text box to enter a custom destination name, a picker for protocol selection, and a log to view the incoming MIDI events.\n\nThe receiver target creates a Core MIDI client, and when the user presses the Create Destination button, the sample uses [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIDestinationCreateWithProtocol(_:_:_:_:_:)] to create a destination with a name, a MIDI protocol, and a callback block. When the system receives events, the sample iterates the [doc:\/\/com.apple.coremidi\/documentation\/CoreMIDI\/MIDIEventList] and pushes them onto a queue to consume on the main thread.\n\n```objective-c\n-(OSStatus)createMIDIDestination:(MIDIClientRef)client named:(CFStringRef)name protocol:(MIDIProtocolID)protocol dest:(MIDIEndpointRef *)outDest {\n    __block MIDIMessageFIFO *msgQueue = messageQueue.get();\n    const auto status = MIDIDestinationCreateWithProtocol(client, name, protocol, outDest, ^(const MIDIEventList * _Nonnull evtlist, void * _Nullable srcConnRefCon) {\n        \n        if (evtlist->numPackets > 0 && msgQueue) {\n            auto pkt = &evtlist->packet[0];\n\n            for (int i = 0; i < evtlist->numPackets; ++i) {\n                if (!msgQueue->push(evtlist->packet[i])) {\n                    msgQueue->push(evtlist->packet[i]);\n                }\n                pkt = MIDIEventPacketNext(pkt);\n            }\n        }\n    });\n    return status;\n}\n```\n\n\n\n## Client management\n\n- **MIDIClientCreate(_:_:_:_:)**: Creates a MIDI client.\n- **MIDIClientCreateWithBlock(_:_:_:)**: Creates a MIDI client with a callback block.\n- **MIDIClientDispose(_:)**: Disposes of a MIDI client.\n- **MIDIClientRef**: An object that maintains per-client state.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a MIDI client.",
          "name" : "MIDIClientCreate(_:_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMIDI\/MIDIClientCreate(_:_:_:_:)"
        },
        {
          "description" : "Creates a MIDI client with a callback block.",
          "name" : "MIDIClientCreateWithBlock(_:_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMIDI\/MIDIClientCreateWithBlock(_:_:_:)"
        },
        {
          "description" : "Disposes of a MIDI client.",
          "name" : "MIDIClientDispose(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMIDI\/MIDIClientDispose(_:)"
        },
        {
          "description" : "An object that maintains per-client state.",
          "name" : "MIDIClientRef",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMIDI\/MIDIClientRef"
        }
      ],
      "title" : "Client management"
    }
  ],
  "source" : "appleJSON",
  "title" : "Incorporating MIDI 2 into your apps",
  "url" : "https:\/\/developer.apple.com\/documentation\/coremidi\/incorporating-midi-2-into-your-apps"
}