{
  "abstract" : "Store fundamental types of data, and discover the key behaviors that make using those types easier.",
  "codeExamples" : [
    {
      "code" : "let maximumNumberOfLoginAttempts = 10\nvar currentLoginAttempt = 0",
      "language" : "swift"
    },
    {
      "code" : "let messagePredicate = #Predicate<Message> { message in\n    message.length < 100 && message.sender == \"Shelly\"\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "11e6c9eb416fbf9a62336640333580da1e8a7309ce0aedbb884b92b90d2e0df1",
  "crawledAt" : "2025-12-02T17:01:41Z",
  "id" : "F77B2D3A-C817-4091-B360-FC6A108A4BD3",
  "kind" : "article",
  "language" : "swift",
  "module" : "Technology Overviews",
  "overview" : "All apps use basic data structures to manage information. To manage simple types of data, use the types in [doc:\/\/com.apple.documentation\/documentation\/Swift\/swift-standard-library] and the [doc:\/\/com.apple.documentation\/documentation\/Foundation] framework. The types in these framework are offer are more capable than most primitive types like `int` and are also portable between Apple platforms. Use the types in these frameworks to manage:\n\nThe benefit of using the framework-provided types is they automatically adapt to the programming language you’re using. In Swift, types like `Int` and `Float` are actually structures you can include in collections. They also adopt standard behaviors like being [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Comparable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Copyable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable], and more. You can even extend them to support custom behaviors you define.\n\nIn Objective-C, integers, floating-point values, and other primitive types map to the language’s built-in representation, but you can still use the types in object-oriented ways. For example, you can include numerical and simple types in collections by wrapping them in an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNumber] or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSValue] object.\n\n## Choose the best configuration for variables\n\nThe variables you create are either *mutable* or *immutable*, meaning you can change their values after initialization or you can’t. Mutability is an important consideration when designing data structures because it impacts how you move data around your app. A structure with only immutable data values doesn’t change, so multiple tasks can safely access that structure at the same time. The same isn’t true if the structure contains a mutable value. Tasks must synchronize access to a mutable structure to avoid corrupting the data inside it.\n\n[doc:\/\/com.apple.documentation\/documentation\/Swift] types are inherently mutable, but you specify their actual mutability when you declare them as variables. In Swift, you declare variables using either the `let` or `var` keyword. The `let` keyword creates a variable with an immutable version of the type, and the `var` keyword creates a variable with a mutable type. The compiler enforces the mutability of variables you declare. In the following code listing, you can change the value of the `currentLoginAttempt` variable, but the compiler reports an error if you attempt to change the value in `maximumNumberOfLoginAttempts`.\n\nIn Objective-C, the mutability of a type depends on the type itself. Integers and other primitive types are inherently mutable in Objective-C unless you declare them as constants. However, the mutability of most object types depends on the type itself. The [doc:\/\/com.apple.documentation\/documentation\/Foundation] framework defines mutable and immutable variants of most object types, with types being immutable unless they contain the word “mutable” in the type name. For example, the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSString] type stores an immutable string, and the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSMutableString] contains the mutable version.\n\nChoose immutable types to represent your data whenever possible. Because their values don’t change, you can pass immutable types safely around your app and access them from any task or thread. As needed, create a mutable copy of a variable to perform intermediate tasks. In Swift, copy the immutable value into a mutable variable. In Objective-C, you can create mutable versions of many immutable types using the methods of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSMutableCopying] protocol.\n\n## Prepare to save your app’s data to disk\n\nAt some point, you’re going to want to save your app’s data to disk. The first step of this process is to convert your structured data into a serial stream of bytes that you can write to a file, which you do using the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/archives-and-serialization] process. This process converts your in-memory data structures to a stream of bytes that you can then write to disk. When reading content from disk, you reverse this process by recreating your data structures from the serialized stream of bytes.\n\nMost [doc:\/\/com.apple.documentation\/documentation\/Swift] and [doc:\/\/com.apple.documentation\/documentation\/Foundation] types have built-in support for serialization. For custom Swift types, you [doc:\/\/com.apple.documentation\/documentation\/Foundation\/encoding-and-decoding-custom-types], by adopting the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols. The default implementation of these protocols automatically encode and decode the properties you specify, but you can also encode and decode properties manually if you prefer.\n\nTo serialize types in Objective-C, adopt the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSCoding] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSSecureCoding] protocols to specify which properties you want to save. To generate a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] object with the stream of bytes from your data structure, use a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedArchiver] object to encode one or more objects. To recreate your objects later, reverse the process using an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedUnarchiver] object.\n\n## Format data for different audiences\n\nBringing your app to other countries involves localizing text and other content to match a person’s language, but it also involves formatting data according to the person’s regional settings. Different countries and regions have rules for how to format numbers, dates, currencies, and other types of data. For example, one country might separate the fractional part of a currency using a comma, and another might use a period. Formatting data for the current [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Locale] is one step in the [doc:\/\/com.apple.documentation\/documentation\/Xcode\/supporting-multiple-languages-in-your-app], which you use to make your app available globally.\n\nBefore displaying data values in your app’s interface, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/data-formatting] for the current region. Most Swift types have built-in methods for formatting their contents using the contents of a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FormatStyle] type. For example, apply the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/IntegerFormatStyle] type to format a value as an integer. Format styles use the current [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Locale] and other information to format values appropriately for the current device. You can also configure format style types with custom formatting behaviors.\n\nTo format values in Objective-C, use an instance of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Formatter] class to generate strings from your data. Foundation defines specific subclasses to format [doc:\/\/com.apple.documentation\/documentation\/Foundation\/DateFormatter], [doc:\/\/com.apple.documentation\/documentation\/Foundation\/DateFormatter] such as distances, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter], and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/PersonNameComponentsFormatter], among others.\n\n## Filter, sort, and compare items\n\nWorking on large amounts of data can make it difficult to organize and find that data. As the number of items in an array increases, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/filters-and-sorting#Filltering] to locate the items you want. You can also [doc:\/\/com.apple.documentation\/documentation\/Foundation\/filters-and-sorting#Sorting] the contents of an array using rules you supply.\n\nAt the center of all filter and sort operations are *predicates*, which are logical tests to apply during the operation. A typical predicate compares a property from a data structure against a value you specify. For example, a predicate might match the name field of a structure to a name string someone specified in your interface. Build predicates in your app using the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate] or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSPredicate] type. You can also combine predicates to specify match multiple values. The following code uses a macro to create a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate] structure that matches two fields of a `Message` structure against specific values.\n\nSome types support the use of predicates to generate a filtered list of results. For example, the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array] type contains methods to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array#Finding-Elements] using predicates. Other collection types offer similar methods.\n\nOnce you have a filtered list of results, apply sort descriptors to arrange them in a preferred order. Build a sort descriptor from the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/SortDescriptor] or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSSortDescriptor] type, and pass them to methods of your collection types. The sort descriptors arrange elements according to the specified criteria and return a new or modified version of your collection.\n\n## Secure your data\n\nProtect your app’s data, and store any data you write to disk securely. People’s devices contain a lot of personal information, and even information that might not seem personal can expose details about someone’s habits or choices. Apple platforms make it easy to encrypt and decrypt the data and files you create. In addition, make sure you adopt [doc:\/\/com.apple.documentation\/documentation\/Security] for handling data to reduce the likelihood of a malicious attack gaining access to that data.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/TechnologyOverviews\/standard-data-types-and-processes\ncrawled: 2025-12-02T17:01:41Z\n---\n\n# Standard data types and processes\n\nStore fundamental types of data, and discover the key behaviors that make using those types easier.\n\nAll apps use basic data structures to manage information. To manage simple types of data, use the types in [doc:\/\/com.apple.documentation\/documentation\/Swift\/swift-standard-library] and the [doc:\/\/com.apple.documentation\/documentation\/Foundation] framework. The types in these framework are offer are more capable than most primitive types like `int` and are also portable between Apple platforms. Use the types in these frameworks to manage:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Float] [doc:\/\/com.apple.documentation\/documentation\/Swift\/Double], and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Bool] values\n- [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Character], and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/AttributedString]\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation\/dates-and-times], and other [doc:\/\/com.apple.documentation\/documentation\/Foundation\/units-and-measurement]\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSPoint], [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSRect], and other [doc:\/\/com.apple.documentation\/documentation\/Foundation\/numbers-data-and-basic-values#2877874]\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URL] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UUID]\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data]\n- [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Dictionary], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Set], and other [doc:\/\/com.apple.documentation\/documentation\/Foundation\/collections]\n\nThe benefit of using the framework-provided types is they automatically adapt to the programming language you’re using. In Swift, types like `Int` and `Float` are actually structures you can include in collections. They also adopt standard behaviors like being [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Comparable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Copyable], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable], and more. You can even extend them to support custom behaviors you define.\n\nIn Objective-C, integers, floating-point values, and other primitive types map to the language’s built-in representation, but you can still use the types in object-oriented ways. For example, you can include numerical and simple types in collections by wrapping them in an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNumber] or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSValue] object.\n\n\n\n## Choose the best configuration for variables\n\nThe variables you create are either *mutable* or *immutable*, meaning you can change their values after initialization or you can’t. Mutability is an important consideration when designing data structures because it impacts how you move data around your app. A structure with only immutable data values doesn’t change, so multiple tasks can safely access that structure at the same time. The same isn’t true if the structure contains a mutable value. Tasks must synchronize access to a mutable structure to avoid corrupting the data inside it.\n\n[doc:\/\/com.apple.documentation\/documentation\/Swift] types are inherently mutable, but you specify their actual mutability when you declare them as variables. In Swift, you declare variables using either the `let` or `var` keyword. The `let` keyword creates a variable with an immutable version of the type, and the `var` keyword creates a variable with a mutable type. The compiler enforces the mutability of variables you declare. In the following code listing, you can change the value of the `currentLoginAttempt` variable, but the compiler reports an error if you attempt to change the value in `maximumNumberOfLoginAttempts`.\n\n```swift\nlet maximumNumberOfLoginAttempts = 10\nvar currentLoginAttempt = 0\n```\n\nIn Objective-C, the mutability of a type depends on the type itself. Integers and other primitive types are inherently mutable in Objective-C unless you declare them as constants. However, the mutability of most object types depends on the type itself. The [doc:\/\/com.apple.documentation\/documentation\/Foundation] framework defines mutable and immutable variants of most object types, with types being immutable unless they contain the word “mutable” in the type name. For example, the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSString] type stores an immutable string, and the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSMutableString] contains the mutable version.\n\nChoose immutable types to represent your data whenever possible. Because their values don’t change, you can pass immutable types safely around your app and access them from any task or thread. As needed, create a mutable copy of a variable to perform intermediate tasks. In Swift, copy the immutable value into a mutable variable. In Objective-C, you can create mutable versions of many immutable types using the methods of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSMutableCopying] protocol.\n\n\n\n## Prepare to save your app’s data to disk\n\nAt some point, you’re going to want to save your app’s data to disk. The first step of this process is to convert your structured data into a serial stream of bytes that you can write to a file, which you do using the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/archives-and-serialization] process. This process converts your in-memory data structures to a stream of bytes that you can then write to disk. When reading content from disk, you reverse this process by recreating your data structures from the serialized stream of bytes.\n\nMost [doc:\/\/com.apple.documentation\/documentation\/Swift] and [doc:\/\/com.apple.documentation\/documentation\/Foundation] types have built-in support for serialization. For custom Swift types, you [doc:\/\/com.apple.documentation\/documentation\/Foundation\/encoding-and-decoding-custom-types], by adopting the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols. The default implementation of these protocols automatically encode and decode the properties you specify, but you can also encode and decode properties manually if you prefer.\n\nTo serialize types in Objective-C, adopt the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSCoding] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSSecureCoding] protocols to specify which properties you want to save. To generate a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Data] object with the stream of bytes from your data structure, use a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedArchiver] object to encode one or more objects. To recreate your objects later, reverse the process using an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSKeyedUnarchiver] object.\n\n\n\n## Format data for different audiences\n\nBringing your app to other countries involves localizing text and other content to match a person’s language, but it also involves formatting data according to the person’s regional settings. Different countries and regions have rules for how to format numbers, dates, currencies, and other types of data. For example, one country might separate the fractional part of a currency using a comma, and another might use a period. Formatting data for the current [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Locale] is one step in the [doc:\/\/com.apple.documentation\/documentation\/Xcode\/supporting-multiple-languages-in-your-app], which you use to make your app available globally.\n\nBefore displaying data values in your app’s interface, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/data-formatting] for the current region. Most Swift types have built-in methods for formatting their contents using the contents of a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FormatStyle] type. For example, apply the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/IntegerFormatStyle] type to format a value as an integer. Format styles use the current [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Locale] and other information to format values appropriately for the current device. You can also configure format style types with custom formatting behaviors.\n\nTo format values in Objective-C, use an instance of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Formatter] class to generate strings from your data. Foundation defines specific subclasses to format [doc:\/\/com.apple.documentation\/documentation\/Foundation\/DateFormatter], [doc:\/\/com.apple.documentation\/documentation\/Foundation\/DateFormatter] such as distances, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter], and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/PersonNameComponentsFormatter], among others.\n\n\n\n## Filter, sort, and compare items\n\nWorking on large amounts of data can make it difficult to organize and find that data. As the number of items in an array increases, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/filters-and-sorting#Filltering] to locate the items you want. You can also [doc:\/\/com.apple.documentation\/documentation\/Foundation\/filters-and-sorting#Sorting] the contents of an array using rules you supply.\n\nAt the center of all filter and sort operations are *predicates*, which are logical tests to apply during the operation. A typical predicate compares a property from a data structure against a value you specify. For example, a predicate might match the name field of a structure to a name string someone specified in your interface. Build predicates in your app using the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate] or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSPredicate] type. You can also combine predicates to specify match multiple values. The following code uses a macro to create a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate] structure that matches two fields of a `Message` structure against specific values.\n\n```swift\nlet messagePredicate = #Predicate<Message> { message in\n    message.length < 100 && message.sender == \"Shelly\"\n}\n```\n\nSome types support the use of predicates to generate a filtered list of results. For example, the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array] type contains methods to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array#Finding-Elements] using predicates. Other collection types offer similar methods.\n\nOnce you have a filtered list of results, apply sort descriptors to arrange them in a preferred order. Build a sort descriptor from the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/SortDescriptor] or [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSSortDescriptor] type, and pass them to methods of your collection types. The sort descriptors arrange elements according to the specified criteria and return a new or modified version of your collection.\n\n\n\n## Secure your data\n\nProtect your app’s data, and store any data you write to disk securely. People’s devices contain a lot of personal information, and even information that might not seem personal can expose details about someone’s habits or choices. Apple platforms make it easy to encrypt and decrypt the data and files you create. In addition, make sure you adopt [doc:\/\/com.apple.documentation\/documentation\/Security] for handling data to reduce the likelihood of a malicious attack gaining access to that data.\n\n- When serializing data, adopt [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSSecureCoding] for all of your custom data types.\n- [doc:\/\/com.apple.documentation\/documentation\/CryptoKit] before you save it to disk, or apply [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileProtectionType] to the files you write to disk.\n- Store passwords, cryptographic keys, certificates, secret information, and other small chunks of sensitive data in the device [doc:\/\/com.apple.documentation\/documentation\/Security\/keychain-services].\n- Store data files in your app’s container directory, which other apps can’t access by default.\n- Validate all data you receive from external sources before incorporating it into your data structures.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Standard data types and processes",
  "url" : "https:\/\/developer.apple.com\/documentation\/TechnologyOverviews\/standard-data-types-and-processes"
}