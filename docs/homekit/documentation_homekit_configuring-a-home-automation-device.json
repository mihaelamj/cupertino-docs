{
  "abstract" : "Give users a familiar experience when they manage HomeKit accessories.",
  "codeExamples" : [
    {
      "code" : "class HomeStore: NSObject {\n    \/\/\/ A singleton that can be used anywhere in the app to access the home manager.\n    static var shared = HomeStore()\n    \n    \/\/\/ The one and only home manager that belongs to the home store singleton.\n    let homeManager = HMHomeManager()\n    \n    \/\/\/ A set of objects that want to receive home delegate callbacks.\n    var homeDelegates = Set<NSObject>()\n    \n    \/\/\/ A set of objects that want to receive accessory delegate callbacks.\n    var accessoryDelegates = Set<NSObject>()\n}",
      "language" : "swift"
    },
    {
      "code" : "HomeStore.shared.homeManager.delegate = self",
      "language" : "swift"
    },
    {
      "code" : "home?.addAndSetupAccessories(completionHandler: { error in\n    if let error = error {\n        print(error)\n    } else {\n        \/\/ Make no assumption about changes; just reload everything.\n        self.reloadData()\n    }\n})",
      "language" : "swift"
    },
    {
      "code" : "var kilgoServices = [HMService]()    \/\/ These are called \"accessories\" in the UI.",
      "language" : "swift"
    },
    {
      "code" : "for accessory in home.accessories.filter({ $0.manufacturer == \"Kilgo Devices, Inc.\" }) {\n    accessory.delegate = HomeStore.shared\n    \n    for service in accessory.services.filter({ $0.isUserInteractive }) {\n        kilgoServices.append(service)\n        \n        \/\/ Ask for notifications from any characteristics that support them.\n        for characteristic in service.characteristics.filter({\n            $0.properties.contains(HMCharacteristicPropertySupportsEventNotification)\n        }) {\n            characteristic.enableNotification(true) { _ in }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var primaryControlCharacteristicType: String? {\n    switch kilgoServiceType {\n    case .lightBulb: return HMCharacteristicTypePowerState\n    case .garageDoor: return HMCharacteristicTypeTargetDoorState\n    case .unknown: return nil\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var primaryControlCharacteristic: HMCharacteristic? {\n    return characteristics.first { $0.characteristicType == primaryControlCharacteristicType }\n}",
      "language" : "swift"
    },
    {
      "code" : "func tap() {\n    if let characteristic = service?.primaryControlCharacteristic,\n        let value = characteristic.value as? Bool {\n\n        \/\/ Provide visual feedback that the item was tapped.\n        bounce()\n        \n        \/\/ Write the new value to HomeKit.\n        characteristic.writeValue(!value) { error in\n            self.redrawState(error: error)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var displayableCharacteristics: [HMCharacteristic] {\n    let characteristicTypes = [HMCharacteristicTypePowerState,\n                               HMCharacteristicTypeBrightness,\n                               HMCharacteristicTypeHue,\n                               HMCharacteristicTypeSaturation,\n                               HMCharacteristicTypeTargetDoorState,\n                               HMCharacteristicTypeCurrentDoorState,\n                               HMCharacteristicTypeObstructionDetected,\n                               HMCharacteristicTypeTargetLockMechanismState,\n                               HMCharacteristicTypeCurrentLockMechanismState,\n                               KilgoCharacteristicTypes.fadeRate.rawValue]\n    \n    return characteristics.filter { characteristicTypes.contains($0.characteristicType) }\n}",
      "language" : "swift"
    },
    {
      "code" : "enum KilgoCharacteristicTypes: String {\n    case fadeRate = \"7E536242-341C-4862-BE90-272CE15BD633\"\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ed452da5df040128580f9566706fee7c06e2c5ce9f8b7c298954758200bf9bc2",
  "crawledAt" : "2025-12-03T09:19:08Z",
  "id" : "56497F96-ABAF-4DF5-81ED-5BBD14454F58",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "HomeKit",
  "overview" : "## Overview\n\nThis sample presents a simplified version of the kind of app a HomeKit-enabled accessory manufacturer might provide. You use the app to configure and control a specific device—a garage door opener from a fictional manufacturer, Kilgo Devices. The app offers access to secondary and custom characteristics that Apple’s Home app doesn’t expose. It provides a user experience that’s consistent with the Home app’s approach and terminology, but doesn’t attempt to replicate every feature of the Home app.\n\n\n\nFor more information about user interface considerations for HomeKit-enabled apps, see the [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/homekit\/overview\/introduction\/] section of the [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/].\n\n### Configure the sample code project\n\nTo be able to use HomeKit, you enable the HomeKit capability and include the [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/nshomekitusagedescription] key in your app’s `Info.plist` file, as described in [https:\/\/developer.apple.com\/documentation\/homekit\/enabling_homekit_in_your_app]. In this sample app, the capability is already enabled and a usage description is provided.\n\nPerform the following steps before building and running the app:\n\nThe import creates a single accessory with a hidden accessory information service that all accessories have, and two user-interactive services: one that controls a garage door and another to control an attached light bulb. Most of the associated characteristics are standard for their service. Only one—the light bulb’s fade rate—is custom. You can use HAS to inspect and manipulate all of these items.\n\n### Create a home manager and get the primary home\n\nYou always use an instance of [https:\/\/developer.apple.com\/documentation\/homekit\/hmhomemanager] as the root HomeKit object. The home manager contains an array of homes, each of which has a collection of accessories. The sample app defines a `HomeStore` class for use as a singleton that holds the one and only home manager for the app:\n\nYou create an accessory list collection view controller to present the list of connected accessories. Because this root view controller never gets deallocated, it can safely assign itself as the [https:\/\/developer.apple.com\/documentation\/homekit\/hmhomemanagerdelegate] protocol delegate:\n\nThe manager tells its delegate when the list of homes changes, including the first time the home manager loads data from the HomeKit database during initialization. When this happens, the accessory list reloads to show the accessories in the primary home, or prompts the user to create a new home if none exists.\n\nYou can extend the app to allow the user to select among all known homes instead of always choosing the primary home. You can also allow users to add, remove, or rename homes, although the user performs these tasks infrequently, and typically relies on the Home app to do so.\n\n### Add new accessories\n\nThe first time you run the app, the accessory list is empty, because you haven’t associated any accessories from Kilgo Devices. The app’s UI presents a `+` button in the navigation bar that you tap to initiate a search for accessories on the local network. The button’s tap handler calls the home’s [https:\/\/developer.apple.com\/documentation\/homekit\/hmhome\/1771427-addandsetupaccessories] method.\n\nThis presents the standard HomeKit UI for locating and adding new accessories to a given home. On success, the completion handler refreshes the app’s copy of the HomeKit data and redraws the display.\n\nWhen your app enters the standard accessory association flow, which is the same one that the Home app uses, the user follows these steps:\n\nEach item that the user names in step 4 appears in the Home app as an “accessory”. However, in HomeKit, these are [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] instances. They are owned by an [https:\/\/developer.apple.com\/documentation\/homekit\/hmaccessory] instance that represents the physical device that you selected in step 2. To maintain a user experience consistent with the Home app, the sample app UI (and the rest of this article) also refers to each [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] instance as an accessory.\n\n### Show only accessories relevant to your app\n\nYou draw the display based on a copy of data from HomeKit captured into an array of Kilgo services:\n\nWhen the accessory list reloads, either because a new home is set or because the accessory-add flow completes, you populate the above array, filtering out [https:\/\/developer.apple.com\/documentation\/homekit\/hmaccessory] instances from manufacturers other than Kilgo, and [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] instances that aren’t user interactive. Also while gathering the list, you request notifications for changes on any of the corresponding characteristics, which are the individual points of status and control for a given service:\n\nAs a result, the display shows only the accessories relevant to this particular app.\n\n### Tailor common interactions to specific accessories\n\nAccessories (like light bulbs) have characteristics (like power state, color temperature, brightness, and so on) that users control or observe. Users typically care about one of these characteristics above the others, because they change or read that characteristic most often. This is the primary characteristic, and you should give users quick access to it. For a light bulb, users most often want to switch it on or off, so the power state is the primary characteristic.\n\nIt’s up to you to define what the primary charactersitc is for the accessories you control. You can do that by creating a computed property on [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] in an extension that returns the type of primary characteristic:\n\nThen use this primary characteristic type to locate and return the characteristic that has that type:\n\nFor Kilgo Devices, both the light bulb and garage door have binary primary state. The bulb is on or off. The target state of the door is open or closed. This lends itself to an interface where a toggle switch is sufficient to control all primary characteristics. You can implement this as the tap handler on each item in the accessory list collection view. When the user taps the accessory, you read the current characteristic value and then write the opposite:\n\nThe write involves network access, so HomeKit calls a completion handler when the write completes. Use this opportunity to update the state of the interface, as shown in the snippet above.\n\n### Enable custom configuration\n\nWhen the user taps an accessory’s information button, the app reveals details about the accessory. From the detail view, the user can rename the accessory, assign it to a room, remove it from the home, and see device information, like the firmware version. The user can also tap Settings to reveal a list of secondary characteristics for that accessory.\n\nControl the user experience by presenting only relevant characteristic types. The `KilgoService` extension of [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] defines a computed property that limits the list of displayable characteristics to those in a curated list:\n\nThese are mostly HomeKit standard types, all of which are applicable to Kilgo devices. There’s also one custom type—fade rate—defined earlier in the same extension:\n\nCharacteristic types are stored as UUID strings. The value specified in the code for fade rate matches the value found in the accessory simulator, which you can inspect in HAS. If you also build a real Kilgo device, the value used there would have to match as well.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/homekit\/configuring-a-home-automation-device\ncrawled: 2025-12-03T09:19:08Z\n---\n\n# Configuring a home automation device\n\n**Sample Code**\n\nGive users a familiar experience when they manage HomeKit accessories.\n\n## Overview\n\nThis sample presents a simplified version of the kind of app a HomeKit-enabled accessory manufacturer might provide. You use the app to configure and control a specific device—a garage door opener from a fictional manufacturer, Kilgo Devices. The app offers access to secondary and custom characteristics that Apple’s Home app doesn’t expose. It provides a user experience that’s consistent with the Home app’s approach and terminology, but doesn’t attempt to replicate every feature of the Home app.\n\n\n\nFor more information about user interface considerations for HomeKit-enabled apps, see the [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/homekit\/overview\/introduction\/] section of the [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/].\n\n### Configure the sample code project\n\nTo be able to use HomeKit, you enable the HomeKit capability and include the [https:\/\/developer.apple.com\/documentation\/bundleresources\/information_property_list\/nshomekitusagedescription] key in your app’s `Info.plist` file, as described in [https:\/\/developer.apple.com\/documentation\/homekit\/enabling_homekit_in_your_app]. In this sample app, the capability is already enabled and a usage description is provided.\n\nPerform the following steps before building and running the app:\n\n1. Set a valid signing team in the target’s General pane so that Xcode can create a provisioning profile containing the HomeKit entitlement when you build for the first time.\n2. Download and install the Home Accessory Simulator (HAS) on your Mac to be able to emulate HomeKit-enabled accessories. See [https:\/\/developer.apple.com\/documentation\/homekit\/testing_your_app_with_the_homekit_accessory_simulator].\n3. Import the `hasaccessory` file that the sample app bundles to define the specific garage door opener accessory that the app controls. Choose `File > Import Accessory` from the HAS menu. In the dialog that appears, navigate to the downloaded sample code project’s `Documentation` folder, and select the `garage.hasaccessory` file.\n\nThe import creates a single accessory with a hidden accessory information service that all accessories have, and two user-interactive services: one that controls a garage door and another to control an attached light bulb. Most of the associated characteristics are standard for their service. Only one—the light bulb’s fade rate—is custom. You can use HAS to inspect and manipulate all of these items.\n\n### Create a home manager and get the primary home\n\nYou always use an instance of [https:\/\/developer.apple.com\/documentation\/homekit\/hmhomemanager] as the root HomeKit object. The home manager contains an array of homes, each of which has a collection of accessories. The sample app defines a `HomeStore` class for use as a singleton that holds the one and only home manager for the app:\n\n```swift\nclass HomeStore: NSObject {\n    \/\/\/ A singleton that can be used anywhere in the app to access the home manager.\n    static var shared = HomeStore()\n    \n    \/\/\/ The one and only home manager that belongs to the home store singleton.\n    let homeManager = HMHomeManager()\n    \n    \/\/\/ A set of objects that want to receive home delegate callbacks.\n    var homeDelegates = Set<NSObject>()\n    \n    \/\/\/ A set of objects that want to receive accessory delegate callbacks.\n    var accessoryDelegates = Set<NSObject>()\n}\n```\n\nYou create an accessory list collection view controller to present the list of connected accessories. Because this root view controller never gets deallocated, it can safely assign itself as the [https:\/\/developer.apple.com\/documentation\/homekit\/hmhomemanagerdelegate] protocol delegate:\n\n```swift\nHomeStore.shared.homeManager.delegate = self\n```\n\nThe manager tells its delegate when the list of homes changes, including the first time the home manager loads data from the HomeKit database during initialization. When this happens, the accessory list reloads to show the accessories in the primary home, or prompts the user to create a new home if none exists.\n\nYou can extend the app to allow the user to select among all known homes instead of always choosing the primary home. You can also allow users to add, remove, or rename homes, although the user performs these tasks infrequently, and typically relies on the Home app to do so.\n\n### Add new accessories\n\nThe first time you run the app, the accessory list is empty, because you haven’t associated any accessories from Kilgo Devices. The app’s UI presents a `+` button in the navigation bar that you tap to initiate a search for accessories on the local network. The button’s tap handler calls the home’s [https:\/\/developer.apple.com\/documentation\/homekit\/hmhome\/1771427-addandsetupaccessories] method.\n\n```swift\nhome?.addAndSetupAccessories(completionHandler: { error in\n    if let error = error {\n        print(error)\n    } else {\n        \/\/ Make no assumption about changes; just reload everything.\n        self.reloadData()\n    }\n})\n```\n\nThis presents the standard HomeKit UI for locating and adding new accessories to a given home. On success, the completion handler refreshes the app’s copy of the HomeKit data and redraws the display.\n\nWhen your app enters the standard accessory association flow, which is the same one that the Home app uses, the user follows these steps:\n\n1. **Scan or enter the new device’s HomeKit setup code.** This code comes packaged with the device, or is available in the HAS display for the accessory.\n2. **Select from a list of devices on the network that don’t already have an existing HomeKit association.** This includes both real and simulated devices that can access the local area network.\n3. **Wait for HomeKit to verify that the setup code entered in step 1 matches the device’s code.**\n4. **Assign a name and room to each service associated with the device.** HomeKit provides a default name and room for each service, one page per service, that the user can accept or change.\n\nEach item that the user names in step 4 appears in the Home app as an “accessory”. However, in HomeKit, these are [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] instances. They are owned by an [https:\/\/developer.apple.com\/documentation\/homekit\/hmaccessory] instance that represents the physical device that you selected in step 2. To maintain a user experience consistent with the Home app, the sample app UI (and the rest of this article) also refers to each [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] instance as an accessory.\n\n### Show only accessories relevant to your app\n\nYou draw the display based on a copy of data from HomeKit captured into an array of Kilgo services:\n\n```swift\nvar kilgoServices = [HMService]()    \/\/ These are called \"accessories\" in the UI.\n```\n\nWhen the accessory list reloads, either because a new home is set or because the accessory-add flow completes, you populate the above array, filtering out [https:\/\/developer.apple.com\/documentation\/homekit\/hmaccessory] instances from manufacturers other than Kilgo, and [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] instances that aren’t user interactive. Also while gathering the list, you request notifications for changes on any of the corresponding characteristics, which are the individual points of status and control for a given service:\n\n```swift\nfor accessory in home.accessories.filter({ $0.manufacturer == \"Kilgo Devices, Inc.\" }) {\n    accessory.delegate = HomeStore.shared\n    \n    for service in accessory.services.filter({ $0.isUserInteractive }) {\n        kilgoServices.append(service)\n        \n        \/\/ Ask for notifications from any characteristics that support them.\n        for characteristic in service.characteristics.filter({\n            $0.properties.contains(HMCharacteristicPropertySupportsEventNotification)\n        }) {\n            characteristic.enableNotification(true) { _ in }\n        }\n    }\n}\n```\n\nAs a result, the display shows only the accessories relevant to this particular app.\n\n\n\n### Tailor common interactions to specific accessories\n\nAccessories (like light bulbs) have characteristics (like power state, color temperature, brightness, and so on) that users control or observe. Users typically care about one of these characteristics above the others, because they change or read that characteristic most often. This is the primary characteristic, and you should give users quick access to it. For a light bulb, users most often want to switch it on or off, so the power state is the primary characteristic.\n\nIt’s up to you to define what the primary charactersitc is for the accessories you control. You can do that by creating a computed property on [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] in an extension that returns the type of primary characteristic:\n\n```swift\nvar primaryControlCharacteristicType: String? {\n    switch kilgoServiceType {\n    case .lightBulb: return HMCharacteristicTypePowerState\n    case .garageDoor: return HMCharacteristicTypeTargetDoorState\n    case .unknown: return nil\n    }\n}\n```\n\nThen use this primary characteristic type to locate and return the characteristic that has that type:\n\n```swift\nvar primaryControlCharacteristic: HMCharacteristic? {\n    return characteristics.first { $0.characteristicType == primaryControlCharacteristicType }\n}\n```\n\nFor Kilgo Devices, both the light bulb and garage door have binary primary state. The bulb is on or off. The target state of the door is open or closed. This lends itself to an interface where a toggle switch is sufficient to control all primary characteristics. You can implement this as the tap handler on each item in the accessory list collection view. When the user taps the accessory, you read the current characteristic value and then write the opposite:\n\n```swift\nfunc tap() {\n    if let characteristic = service?.primaryControlCharacteristic,\n        let value = characteristic.value as? Bool {\n\n        \/\/ Provide visual feedback that the item was tapped.\n        bounce()\n        \n        \/\/ Write the new value to HomeKit.\n        characteristic.writeValue(!value) { error in\n            self.redrawState(error: error)\n        }\n    }\n}\n```\n\nThe write involves network access, so HomeKit calls a completion handler when the write completes. Use this opportunity to update the state of the interface, as shown in the snippet above.\n\n### Enable custom configuration\n\nWhen the user taps an accessory’s information button, the app reveals details about the accessory. From the detail view, the user can rename the accessory, assign it to a room, remove it from the home, and see device information, like the firmware version. The user can also tap Settings to reveal a list of secondary characteristics for that accessory.\n\nControl the user experience by presenting only relevant characteristic types. The `KilgoService` extension of [https:\/\/developer.apple.com\/documentation\/homekit\/hmservice] defines a computed property that limits the list of displayable characteristics to those in a curated list:\n\n```swift\nvar displayableCharacteristics: [HMCharacteristic] {\n    let characteristicTypes = [HMCharacteristicTypePowerState,\n                               HMCharacteristicTypeBrightness,\n                               HMCharacteristicTypeHue,\n                               HMCharacteristicTypeSaturation,\n                               HMCharacteristicTypeTargetDoorState,\n                               HMCharacteristicTypeCurrentDoorState,\n                               HMCharacteristicTypeObstructionDetected,\n                               HMCharacteristicTypeTargetLockMechanismState,\n                               HMCharacteristicTypeCurrentLockMechanismState,\n                               KilgoCharacteristicTypes.fadeRate.rawValue]\n    \n    return characteristics.filter { characteristicTypes.contains($0.characteristicType) }\n}\n```\n\nThese are mostly HomeKit standard types, all of which are applicable to Kilgo devices. There’s also one custom type—fade rate—defined earlier in the same extension:\n\n```swift\nenum KilgoCharacteristicTypes: String {\n    case fadeRate = \"7E536242-341C-4862-BE90-272CE15BD633\"\n}\n```\n\nCharacteristic types are stored as UUID strings. The value specified in the code for fade rate matches the value found in the accessory simulator, which you can inspect in HAS. If you also build a real Kilgo device, the value used there would have to match as well.\n\n## Home Manager\n\n- **Testing your app with the HomeKit Accessory Simulator**: Install the HomeKit Accessory Simulator to help you debug your HomeKit-enabled app.\n- **HMHomeManager**: The manager for a collection of one or more of a user’s homes.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Install the HomeKit Accessory Simulator to help you debug your HomeKit-enabled app.",
          "name" : "Testing your app with the HomeKit Accessory Simulator",
          "url" : "https:\/\/developer.apple.com\/documentation\/HomeKit\/testing-your-app-with-the-homekit-accessory-simulator"
        },
        {
          "description" : "The manager for a collection of one or more of a user’s homes.",
          "name" : "HMHomeManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/HomeKit\/HMHomeManager"
        }
      ],
      "title" : "Home Manager"
    }
  ],
  "source" : "appleJSON",
  "title" : "Configuring a home automation device",
  "url" : "https:\/\/developer.apple.com\/documentation\/homekit\/configuring-a-home-automation-device"
}