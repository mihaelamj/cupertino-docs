{
  "abstract" : "Describe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime.",
  "codeExamples" : [
    {
      "code" : "import SwiftData\n\n\/\/ Annotate new or existing model classes with the @Model macro.\n@Model\nclass Trip {\n    var name: String\n    var destination: String\n    var startDate: Date\n    var endDate: Date\n    var accommodation: Accommodation?\n}",
      "language" : "swift"
    },
    {
      "code" : "@Attribute(.unique) var name: String",
      "language" : "swift"
    },
    {
      "code" : "@Relationship(.cascade) var accommodation: Accommodation?",
      "language" : "swift"
    },
    {
      "code" : "@Transient var destinationWeather = Weather.current()",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport SwiftData\n\n@main\nstruct TripsApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .modelContainer(for: [\n                    Trip.self,\n                    Accommodation.self\n                ])\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftData\n\nlet container = try ModelContainer([\n    Trip.self, \n    Accommodation.self\n])",
      "language" : "swift"
    },
    {
      "code" : "let configuration = ModelConfiguration(isStoredInMemoryOnly: true, allowsSave: false)\n\nlet container = try ModelContainer(\n    for: Trip.self, Accommodation.self, \n    configurations: configuration\n)",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport SwiftData\n\nstruct ContentView: View {\n    @Environment(\\.modelContext) private var context\n}",
      "language" : "swift"
    },
    {
      "code" : "let context = container.mainContext",
      "language" : "swift"
    },
    {
      "code" : "var trip = Trip(name: name, \n                destination: destination, \n                startDate: startDate, \n                endDate: endDate)\n\ncontext.insert(trip)",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport SwiftData\n\nstruct ContentView: View {\n    @Query(sort: \\.startDate, order: .reverse) var allTrips: [Trip]\n    \n    var body: some View {\n        List {\n            ForEach(allTrips) {\n                TripView(for: $0)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let context = container.mainContext\n\nlet upcomingTrips = FetchDescriptor<Trip>(\n    predicate: #Predicate { $0.startDate > Date.now },\n    sortBy: [\n        .init(\\.startDate)\n    ]\n)\nupcomingTrips.fetchLimit = 50\nupcomingTrips.includePendingChanges = true\n\nlet results = context.fetch(upcomingTrips)",
      "language" : "swift"
    }
  ],
  "contentHash" : "705065fc1fe13433d8481fef8406a162c1ad088d684c3bba9141fb91a83513a2",
  "crawledAt" : "2025-12-03T15:56:42Z",
  "id" : "5E48EA1D-BFA5-4B56-8BD2-D6F484EB3F5D",
  "kind" : "article",
  "language" : "swift",
  "module" : "SwiftData",
  "overview" : "## Overview\n\nMost apps define a number of custom types that model the data it creates or consumes. For example, a travel app might define classes that represent trips, flights, and booked accommodations. Using SwiftData, you can quickly and efficiently persist that data so it’s available across app launches, and leverage the framework’s integration with SwiftUI to refetch that data and display it onscreen.\n\nBy design, SwiftData supplements your existing model classes. The framework provides tools such as macros and property wrappers that enable you to expressively describe your app’s schema in Swift code, removing any reliance on external dependencies such as model and migration mapping files.\n\n### Turn classes into models to make them persistable\n\nTo let SwiftData save instances of a model class, import the framework and annotate that class with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro. The macro updates the class with conformance to the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel] protocol, which SwiftData uses to examine the class and generate an internal schema. Additionally, the macro enables change tracking for the class by adding conformance to the [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable] protocol.\n\nBy default, SwiftData includes all noncomputed properties of a class as long as they use compatible types. The framework supports primitive types such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/Bool], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], and [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], as well as complex value types such as structures, enumerations, and other value types that conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol.\n\nThe code you write to define your model classes now serves as the source of truth for your app’s model layer, and the framework uses that to keep the persisted data in a consistent state.\n\n### Customize the persistence behavior of model attributes\n\nAn *attribute* is a property of a model class that SwiftData manages. In most cases, the framework’s default behavior for attributes is sufficient. However, if you need to alter how SwiftData handles the persistence of a particular attribute, use one of the provided schema macros. For example, you may want to avoid conflicts in your model data by specifying that an attribute’s value is unique across all instances of that model.\n\nTo customize an attribute’s behavior, annotate the property with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Attribute(_:originalName:hashModifier:)] macro and specify values for the options that drive the desired behavior:\n\nAside from enforcing unique constraints, `@Attribute` supports, among others, preserving deleted values, Spotlight indexing, and encryption. You can also use the `@Attribute` macro to correctly handle renamed attributes if you want to preserve the original name in the underlying model data.\n\nWhen a model contains an attribute whose type is also a model (or a collection of models), SwiftData implicitly manages the relationship between those models for you. By default, the framework sets relationship attributes to `nil` after you delete a related model instance. To specify a different deletion rule, annotate the property with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)] macro. For example, you may want to delete any related accommodations when deleting a trip. For more information about delete rules, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum].\n\nSwiftData persists all noncomputed attributes of a model by default, but you may not always want this to happen. For example, one or more properties on a class may only ever contain temporary data that doesn’t need saving, such as the current weather at an upcoming trip’s destination. In such scenarios, annotate those properties with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Transient()] macro and SwiftData won’t write their values to disk.\n\n### Configure the model storage\n\nBefore SwiftData can examine your models and generate the required schema, you need to tell it — at runtime — which models to persist, and optionally, the configuration to use for the underlying storage. For example, you may want the storage to exist only in memory when running tests, or to use a specific CloudKit container when syncing model data across devices.\n\nTo set up the default storage, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)-18hhy] view modifier (or the scene equivalent) and specify the array of model types to persist. If you use the view modifier, add it at the very top of the view hierarchy so all nested views inherit the properly configured environment:\n\nIf you’re not using SwiftUI, create a model container manually using the appropriate initializer:\n\nAlternatively, use [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration] to create custom storage. The type provides a number of options to configure including whether:\n\n### Save models for later use\n\nTo manage instances of your model classes at runtime, use a *model context* — the object responsible for the in-memory model data and coordination with the model container to successfully persist that data. To get a context for your model container that’s bound to the main actor, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/modelContext] environment variable:\n\nOutside of a view, or if you’re not using SwiftUI, access the same actor-bound context directly using the model container:\n\nIn both instances, the returned context periodically checks whether it contains unsaved changes, and if so, implicitly saves those changes on your behalf. For contexts you create manually, set the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/autosaveEnabled] property to `true` to get the same behavior.\n\nTo enable SwiftData to persist a model instance and begin tracking changes to it, insert the instance into the context:\n\nFollowing the insert, you can save immediately by invoking the context’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/save()] method, or rely on the context’s implicit save behavior instead. Contexts automatically track changes to their known model instances and include those changes in subsequent saves. In addition to saving, you can use a context to fetch, enumerate, and delete model instances. For more information, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext].\n\n### Fetch models for display or additional processing\n\nAfter you begin persisting model data, you’ll likely want to retrieve that data, materialized as model instances, and display those instances in a view or take some other action on them. SwiftData provides the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Query] property wrapper and the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/FetchDescriptor] type for performing fetches.\n\nTo fetch model instances, and optionally apply search criteria and a preferred sort order, use `@Query` in your SwiftUI view. The `@Model` macro adds `Observable` conformance to your model classes, enabling SwiftUI to refresh the containing view whenever changes occur to any of the fetched instances.\n\nOutside of a view, or if you’re not using SwiftUI, use one of the two fetch methods on [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext]. Each method expects an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/FetchDescriptor] containing a predicate and a sort order. The fetch descriptor allows for additional configuration that influences batching, offsets, and prefetching, among others.\n\nFor more information about predicates, see [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swiftdata\/preserving-your-apps-model-data-across-launches\ncrawled: 2025-12-03T15:56:42Z\n---\n\n# Preserving your app’s model data across launches\n\n**Article**\n\nDescribe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime.\n\n## Overview\n\nMost apps define a number of custom types that model the data it creates or consumes. For example, a travel app might define classes that represent trips, flights, and booked accommodations. Using SwiftData, you can quickly and efficiently persist that data so it’s available across app launches, and leverage the framework’s integration with SwiftUI to refetch that data and display it onscreen.\n\nBy design, SwiftData supplements your existing model classes. The framework provides tools such as macros and property wrappers that enable you to expressively describe your app’s schema in Swift code, removing any reliance on external dependencies such as model and migration mapping files.\n\n### Turn classes into models to make them persistable\n\nTo let SwiftData save instances of a model class, import the framework and annotate that class with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro. The macro updates the class with conformance to the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel] protocol, which SwiftData uses to examine the class and generate an internal schema. Additionally, the macro enables change tracking for the class by adding conformance to the [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable] protocol.\n\n```swift\nimport SwiftData\n\n\/\/ Annotate new or existing model classes with the @Model macro.\n@Model\nclass Trip {\n    var name: String\n    var destination: String\n    var startDate: Date\n    var endDate: Date\n    var accommodation: Accommodation?\n}\n```\n\nBy default, SwiftData includes all noncomputed properties of a class as long as they use compatible types. The framework supports primitive types such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/Bool], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], and [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], as well as complex value types such as structures, enumerations, and other value types that conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol.\n\nThe code you write to define your model classes now serves as the source of truth for your app’s model layer, and the framework uses that to keep the persisted data in a consistent state.\n\n### Customize the persistence behavior of model attributes\n\nAn *attribute* is a property of a model class that SwiftData manages. In most cases, the framework’s default behavior for attributes is sufficient. However, if you need to alter how SwiftData handles the persistence of a particular attribute, use one of the provided schema macros. For example, you may want to avoid conflicts in your model data by specifying that an attribute’s value is unique across all instances of that model.\n\nTo customize an attribute’s behavior, annotate the property with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Attribute(_:originalName:hashModifier:)] macro and specify values for the options that drive the desired behavior:\n\n```swift\n@Attribute(.unique) var name: String\n```\n\nAside from enforcing unique constraints, `@Attribute` supports, among others, preserving deleted values, Spotlight indexing, and encryption. You can also use the `@Attribute` macro to correctly handle renamed attributes if you want to preserve the original name in the underlying model data.\n\nWhen a model contains an attribute whose type is also a model (or a collection of models), SwiftData implicitly manages the relationship between those models for you. By default, the framework sets relationship attributes to `nil` after you delete a related model instance. To specify a different deletion rule, annotate the property with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)] macro. For example, you may want to delete any related accommodations when deleting a trip. For more information about delete rules, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum].\n\n```swift\n@Relationship(.cascade) var accommodation: Accommodation?\n```\n\nSwiftData persists all noncomputed attributes of a model by default, but you may not always want this to happen. For example, one or more properties on a class may only ever contain temporary data that doesn’t need saving, such as the current weather at an upcoming trip’s destination. In such scenarios, annotate those properties with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Transient()] macro and SwiftData won’t write their values to disk.\n\n```swift\n@Transient var destinationWeather = Weather.current()\n```\n\n### Configure the model storage\n\nBefore SwiftData can examine your models and generate the required schema, you need to tell it — at runtime — which models to persist, and optionally, the configuration to use for the underlying storage. For example, you may want the storage to exist only in memory when running tests, or to use a specific CloudKit container when syncing model data across devices.\n\nTo set up the default storage, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)-18hhy] view modifier (or the scene equivalent) and specify the array of model types to persist. If you use the view modifier, add it at the very top of the view hierarchy so all nested views inherit the properly configured environment:\n\n```swift\nimport SwiftUI\nimport SwiftData\n\n@main\nstruct TripsApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .modelContainer(for: [\n                    Trip.self,\n                    Accommodation.self\n                ])\n        }\n    }\n}\n```\n\nIf you’re not using SwiftUI, create a model container manually using the appropriate initializer:\n\n```swift\nimport SwiftData\n\nlet container = try ModelContainer([\n    Trip.self, \n    Accommodation.self\n])\n```\n\n\n\nAlternatively, use [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration] to create custom storage. The type provides a number of options to configure including whether:\n\n- the storage exists only in memory.\n- the storage is read-only.\n- the app uses a specific App Group to store its model data.\n\n```swift\nlet configuration = ModelConfiguration(isStoredInMemoryOnly: true, allowsSave: false)\n\nlet container = try ModelContainer(\n    for: Trip.self, Accommodation.self, \n    configurations: configuration\n)\n```\n\n\n\n### Save models for later use\n\nTo manage instances of your model classes at runtime, use a *model context* — the object responsible for the in-memory model data and coordination with the model container to successfully persist that data. To get a context for your model container that’s bound to the main actor, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/modelContext] environment variable:\n\n```swift\nimport SwiftUI\nimport SwiftData\n\nstruct ContentView: View {\n    @Environment(\\.modelContext) private var context\n}\n```\n\nOutside of a view, or if you’re not using SwiftUI, access the same actor-bound context directly using the model container:\n\n```swift\nlet context = container.mainContext\n```\n\nIn both instances, the returned context periodically checks whether it contains unsaved changes, and if so, implicitly saves those changes on your behalf. For contexts you create manually, set the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/autosaveEnabled] property to `true` to get the same behavior.\n\nTo enable SwiftData to persist a model instance and begin tracking changes to it, insert the instance into the context:\n\n```swift\nvar trip = Trip(name: name, \n                destination: destination, \n                startDate: startDate, \n                endDate: endDate)\n\ncontext.insert(trip)\n```\n\nFollowing the insert, you can save immediately by invoking the context’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/save()] method, or rely on the context’s implicit save behavior instead. Contexts automatically track changes to their known model instances and include those changes in subsequent saves. In addition to saving, you can use a context to fetch, enumerate, and delete model instances. For more information, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext].\n\n### Fetch models for display or additional processing\n\nAfter you begin persisting model data, you’ll likely want to retrieve that data, materialized as model instances, and display those instances in a view or take some other action on them. SwiftData provides the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Query] property wrapper and the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/FetchDescriptor] type for performing fetches.\n\nTo fetch model instances, and optionally apply search criteria and a preferred sort order, use `@Query` in your SwiftUI view. The `@Model` macro adds `Observable` conformance to your model classes, enabling SwiftUI to refresh the containing view whenever changes occur to any of the fetched instances.\n\n```swift\nimport SwiftUI\nimport SwiftData\n\nstruct ContentView: View {\n    @Query(sort: \\.startDate, order: .reverse) var allTrips: [Trip]\n    \n    var body: some View {\n        List {\n            ForEach(allTrips) {\n                TripView(for: $0)\n            }\n        }\n    }\n}\n```\n\nOutside of a view, or if you’re not using SwiftUI, use one of the two fetch methods on [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext]. Each method expects an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/FetchDescriptor] containing a predicate and a sort order. The fetch descriptor allows for additional configuration that influences batching, offsets, and prefetching, among others.\n\n```swift\nlet context = container.mainContext\n\nlet upcomingTrips = FetchDescriptor<Trip>(\n    predicate: #Predicate { $0.startDate > Date.now },\n    sortBy: [\n        .init(\\.startDate)\n    ]\n)\nupcomingTrips.fetchLimit = 50\nupcomingTrips.includePendingChanges = true\n\nlet results = context.fetch(upcomingTrips)\n```\n\nFor more information about predicates, see [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Predicate].\n\n## Essentials\n\n- **Adding and editing persistent data in your app**: Create a data entry form for collecting and changing data managed by SwiftData.\n- **Adopting SwiftData for a Core Data app**: Persist data in your app intuitively with the Swift native persistence framework.\n- **SwiftData updates**: Learn about important changes to SwiftData.\n- **Adopting inheritance in SwiftData**: Add flexibility to your models using class inheritance.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a data entry form for collecting and changing data managed by SwiftData.",
          "name" : "Adding and editing persistent data in your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Adding-and-editing-persistent-data-in-your-app"
        },
        {
          "description" : "Persist data in your app intuitively with the Swift native persistence framework.",
          "name" : "Adopting SwiftData for a Core Data app",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/adopting-swiftdata-for-a-core-data-app"
        },
        {
          "description" : "Learn about important changes to SwiftData.",
          "name" : "SwiftData updates",
          "url" : "https:\/\/developer.apple.com\/documentation\/Updates\/SwiftData"
        },
        {
          "description" : "Add flexibility to your models using class inheritance.",
          "name" : "Adopting inheritance in SwiftData",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Adopting-inheritance-in-SwiftData"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Preserving your app’s model data across launches",
  "url" : "https:\/\/developer.apple.com\/documentation\/swiftdata\/preserving-your-apps-model-data-across-launches"
}