{
  "abstract" : "Create and update a persistent store to cache read-only network data.",
  "codeExamples" : [
    {
      "code" : "import SwiftData\n\n@Model\nclass Quake {\n    @Attribute(.unique) var code: String\n    var magnitude: Double\n    var time: Date\n    var location: Location\n}",
      "language" : "swift"
    },
    {
      "code" : "struct GeoFeatureCollection: Decodable {\n    let features: [Feature]\n\n    struct Feature: Decodable {\n        let properties: Properties\n        let geometry: Geometry\n        \n        struct Properties: Decodable {\n            let mag: Double\n            let place: String\n            let time: Date\n            let code: String\n        }\n\n        struct Geometry: Decodable {\n            let coordinates: [Double]\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let session = URLSession.shared\nguard let (data, response) = try? await session.data(from: url),\n      let httpResponse = response as? HTTPURLResponse,\n      httpResponse.statusCode == 200\nelse {\n    throw DownloadError.missingData\n}",
      "language" : "swift"
    },
    {
      "code" : "do {\n    let jsonDecoder = JSONDecoder()\n    jsonDecoder.dateDecodingStrategy = .millisecondsSince1970\n    return try jsonDecoder.decode(GeoFeatureCollection.self, from: data)\n} catch {\n    throw DownloadError.wrongDataFormat(error: error)\n}",
      "language" : "swift"
    },
    {
      "code" : "convenience init(from feature: GeoFeatureCollection.Feature) {\n    self.init(\n        code: feature.properties.code,\n        magnitude: feature.properties.mag,\n        time: feature.properties.time,\n        name: feature.properties.place,\n        longitude: feature.geometry.coordinates[0],\n        latitude: feature.geometry.coordinates[1]\n    )\n}",
      "language" : "swift"
    },
    {
      "code" : "for feature in featureCollection.features {\n    let quake = Quake(from: feature)\n\n    if quake.magnitude > 0 {\n        modelContext.insert(quake)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "c6f4a256a8476f4b92b6d2234d79fb828adcb2b1c55f6018ebcf506043d2781c",
  "crawledAt" : "2025-12-02T15:50:47Z",
  "id" : "0A7481C8-F939-40A2-A515-EC57803AC1A2",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftData",
  "overview" : "## Overview\n\nThis sample app displays a list that contains a day’s worth of earthquakes, showing their time, location, and size. To help people visualize the list, the app also pinpoints each earthquake on a map. You can select an earthquake in the list to highlight it on the map.\n\n\n\nThe app downloads earthquake data from the network under the following assumptions:\n\nThe app uses SwiftData to persistently store the data that it downloads. By caching the data locally, the app reduces its need to access the server. SwiftData also makes it easy for the app to manage updates when downloading new data.\n\n### Define the app’s data model\n\nThe app represents the information it needs for its interface by defining a `Quake` class. The class definition includes the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro to tell the system to store the data persistently using SwiftData:\n\nThe model includes the following fields:\n\nThe `Quake` model can embed a location instance because the `Location` structure conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol.\n\n### Model the server data\n\nThe app loads data from a U.S. Geological Survey (USGS) server, which provides earthquake data in [https:\/\/earthquake.usgs.gov\/earthquakes\/feed\/v1.0\/geojson.php] format. To interpret this data, the app defines a `GeoFeatureCollection` structure with property names that match the names of relevant JSON properties:\n\nThe structure and its substructures include elements relevant to this app, namely magnitude, time, and location information. They omit many other fields that the server provides because the app doesn’t need them. The structure also conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocol so the app can use the structure to decode the downloaded data.\n\n### Download data from the server\n\nTo retrieve data, the app defines a `fetchFeatures()` method that uses a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] to store the earthquake JSON in a `data` property:\n\nThe method then parses the data with a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/JSONDecoder] instance, according to the definition provided by the decodable `GeoFeatureCollection` structure:\n\nFor other examples of decoding JSON data, see [doc:\/\/com.apple.documentation\/documentation\/foundation\/archives_and_serialization\/using_json_with_custom_types].\n\n### Translate server data into model data\n\nAfter retrieving a collection of features, the app interprets each feature as an earthquake. The `Quake` class defines a convenience initializer that creates a new earthquake from a feature instance:\n\nThis enables the app to translate the data from a format that the server provides to a format that’s convenient for the app. For example, the initializer converts longitude and latitude coordinates that appear as anonymous elements in the feature’s `geometry.coordinates` array into named parameters.\n\n### Insert or update new earthquake data\n\nAs the app creates new earthquake instances, it persistently stores any that have a magnitude greater than zero by calling the model context’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/insert(_:)] method for each one:\n\nThe app runs this loop for both the initial download and later refresh operations. When the app saves the changes — which happens automatically in this case because the context’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/autosaveEnabled] property has the default value of `true` — SwiftData checks if the specified earthquake’s `code` parameter matches the code of an earthquake that’s already in the store. If so, the framework updates the stored earthquake’s other parameters using the values in the specified one. Otherwise, the framework adds a new earthquake to the store.\n\nThe insert method works for both creating and updating earthquake model instances because the model indicates that the `code` parameter is unique. This relies on the fact that the server ensures a unique, stable code for each earthquake event.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftData\/Maintaining-a-local-copy-of-server-data\ncrawled: 2025-12-02T15:50:47Z\n---\n\n# Maintaining a local copy of server data\n\n**Sample Code**\n\nCreate and update a persistent store to cache read-only network data.\n\n## Overview\n\nThis sample app displays a list that contains a day’s worth of earthquakes, showing their time, location, and size. To help people visualize the list, the app also pinpoints each earthquake on a map. You can select an earthquake in the list to highlight it on the map.\n\n\n\nThe app downloads earthquake data from the network under the following assumptions:\n\n- **Earthquake data is read-only** — The app doesn’t need to synchronize local and remote changes. The server is always the source of truth.\n- **New earthquakes happen on a regular basis** — The app needs to provide a way to get an initial list of earthquakes and to periodically refresh that list.\n- **Existing earthquake records can change** — For example, the reported magnitude of an earthquake might change as additional measurements become available. The app needs to distinguish between new earthquakes and updates to previously downloaded ones.\n\nThe app uses SwiftData to persistently store the data that it downloads. By caching the data locally, the app reduces its need to access the server. SwiftData also makes it easy for the app to manage updates when downloading new data.\n\n\n\n### Define the app’s data model\n\nThe app represents the information it needs for its interface by defining a `Quake` class. The class definition includes the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro to tell the system to store the data persistently using SwiftData:\n\n```swift\nimport SwiftData\n\n@Model\nclass Quake {\n    @Attribute(.unique) var code: String\n    var magnitude: Double\n    var time: Date\n    var location: Location\n}\n```\n\nThe model includes the following fields:\n\n- **A unique code** — By including the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Attribute(_:originalName:hashModifier:)] macro with the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Attribute\/Option\/unique] property option, the app ensures that SwiftData stores only one earthquake with a particular value for this field.\n- **A magnitude** — The size of the earthquake.\n- **A timestamp** — The moment in time when the earthquake happened, stored as a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Date] instance.\n- **A location** — A custom `Location` instance that contains a location name and map coordinates:\n\n```swift\nstruct Location: Codable {\n    var name: String\n    var longitude: Double\n    var latitude: Double\n}\n```\n\nThe `Quake` model can embed a location instance because the `Location` structure conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol.\n\n### Model the server data\n\nThe app loads data from a U.S. Geological Survey (USGS) server, which provides earthquake data in [https:\/\/earthquake.usgs.gov\/earthquakes\/feed\/v1.0\/geojson.php] format. To interpret this data, the app defines a `GeoFeatureCollection` structure with property names that match the names of relevant JSON properties:\n\n```swift\nstruct GeoFeatureCollection: Decodable {\n    let features: [Feature]\n\n    struct Feature: Decodable {\n        let properties: Properties\n        let geometry: Geometry\n        \n        struct Properties: Decodable {\n            let mag: Double\n            let place: String\n            let time: Date\n            let code: String\n        }\n\n        struct Geometry: Decodable {\n            let coordinates: [Double]\n        }\n    }\n}\n```\n\nThe structure and its substructures include elements relevant to this app, namely magnitude, time, and location information. They omit many other fields that the server provides because the app doesn’t need them. The structure also conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocol so the app can use the structure to decode the downloaded data.\n\n### Download data from the server\n\nTo retrieve data, the app defines a `fetchFeatures()` method that uses a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] to store the earthquake JSON in a `data` property:\n\n```swift\nlet session = URLSession.shared\nguard let (data, response) = try? await session.data(from: url),\n      let httpResponse = response as? HTTPURLResponse,\n      httpResponse.statusCode == 200\nelse {\n    throw DownloadError.missingData\n}\n```\n\nThe method then parses the data with a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/JSONDecoder] instance, according to the definition provided by the decodable `GeoFeatureCollection` structure:\n\n```swift\ndo {\n    let jsonDecoder = JSONDecoder()\n    jsonDecoder.dateDecodingStrategy = .millisecondsSince1970\n    return try jsonDecoder.decode(GeoFeatureCollection.self, from: data)\n} catch {\n    throw DownloadError.wrongDataFormat(error: error)\n}\n```\n\nFor other examples of decoding JSON data, see [doc:\/\/com.apple.documentation\/documentation\/foundation\/archives_and_serialization\/using_json_with_custom_types].\n\n### Translate server data into model data\n\nAfter retrieving a collection of features, the app interprets each feature as an earthquake. The `Quake` class defines a convenience initializer that creates a new earthquake from a feature instance:\n\n```swift\nconvenience init(from feature: GeoFeatureCollection.Feature) {\n    self.init(\n        code: feature.properties.code,\n        magnitude: feature.properties.mag,\n        time: feature.properties.time,\n        name: feature.properties.place,\n        longitude: feature.geometry.coordinates[0],\n        latitude: feature.geometry.coordinates[1]\n    )\n}\n```\n\nThis enables the app to translate the data from a format that the server provides to a format that’s convenient for the app. For example, the initializer converts longitude and latitude coordinates that appear as anonymous elements in the feature’s `geometry.coordinates` array into named parameters.\n\n### Insert or update new earthquake data\n\nAs the app creates new earthquake instances, it persistently stores any that have a magnitude greater than zero by calling the model context’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/insert(_:)] method for each one:\n\n```swift\nfor feature in featureCollection.features {\n    let quake = Quake(from: feature)\n\n    if quake.magnitude > 0 {\n        modelContext.insert(quake)\n    }\n}\n```\n\nThe app runs this loop for both the initial download and later refresh operations. When the app saves the changes — which happens automatically in this case because the context’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/autosaveEnabled] property has the default value of `true` — SwiftData checks if the specified earthquake’s `code` parameter matches the code of an earthquake that’s already in the store. If so, the framework updates the stored earthquake’s other parameters using the values in the specified one. Otherwise, the framework adds a new earthquake to the store.\n\nThe insert method works for both creating and updating earthquake model instances because the model indicates that the `code` parameter is unique. This relies on the fact that the server ensures a unique, stable code for each earthquake event.\n\n## Model storage\n\n- **DefaultStore**: A data store that uses Core Data as its undelying storage mechanism.\n- **DataStore**: An interface that enables SwiftData to read and write model data without knowledge of the underlying storage mechanism.\n- **DataStoreBatching**: An interface that enables a custom data store to support batch requests.\n- **HistoryProviding**: An interface that enables a custom data store to provide the history of changes for its persisted models.\n- **Building a document-based app using SwiftData**: Code along with the WWDC presenter to transform an app with SwiftData.\n- **ModelDocument**: A document type that uses SwiftData to manage its storage.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A data store that uses Core Data as its undelying storage mechanism.",
          "name" : "DefaultStore",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/DefaultStore"
        },
        {
          "description" : "An interface that enables SwiftData to read and write model data without knowledge of the underlying storage mechanism.",
          "name" : "DataStore",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/DataStore"
        },
        {
          "description" : "An interface that enables a custom data store to support batch requests.",
          "name" : "DataStoreBatching",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/DataStoreBatching"
        },
        {
          "description" : "An interface that enables a custom data store to provide the history of changes for its persisted models.",
          "name" : "HistoryProviding",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/HistoryProviding"
        },
        {
          "description" : "Code along with the WWDC presenter to transform an app with SwiftData.",
          "name" : "Building a document-based app using SwiftData",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Building-a-document-based-app-using-SwiftData"
        },
        {
          "description" : "A document type that uses SwiftData to manage its storage.",
          "name" : "ModelDocument",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/ModelDocument"
        }
      ],
      "title" : "Model storage"
    }
  ],
  "source" : "appleJSON",
  "title" : "Maintaining a local copy of server data",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Maintaining-a-local-copy-of-server-data"
}