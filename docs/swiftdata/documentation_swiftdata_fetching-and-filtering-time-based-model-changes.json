{
  "abstract" : "Track all inserts, updates, and deletes that occur in a data store and process them as a series of chronological transactions.",
  "codeExamples" : [
    {
      "code" : "func fetchWidgetTransactions(after tokenData: Data) -> Result<[DefaultHistoryTransaction], Error> {\n    do {\n        \/\/ Decode the given token data.\n        let token = try JSONDecoder().decode(History.DefaultToken.self, from: tokenData)\n        \/\/ Create a history descriptor and specify the predicate.\n        var descriptor = History.HistoryDescriptor<History.DefaultTransaction>()\n        descriptor.predicate = #Predicate {\n            ($0.token > token) && ($0.author == \"widget\")\n        }\n        \/\/ Fetch the matching history transactions.\n        let context = ModelContext(modelContainer)\n        let txns = try context.fetchHistory(descriptor)\n        return .success(txns)\n    } catch {\n        return .failure(error)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let context = ModelContext(modelContainer)\nvar updatedTrips = Set<Trip>()\n\nfor txn in transactions {\n    \/\/ Filter out any change that isn't an update.\n    for change in txn.changes where change is History.DefaultUpdateChange<Trip> {\n        \/\/ Proceed only when there's a single change, and that change \n        \/\/ is to the `flightTime` attribute.\n        guard change.updatedAttributes.count == 1, \n              change.updatedAttributes.contains(\\.flightTime)\n        else { continue }\n        \/\/ Use the model ID from the change to fetch the actual model.\n        let changedModelID = change.changedModelID\n        var fetchDescriptor = FetchDescriptor<Trip>(predicate: #Predicate { \n            $0.persistentModelID == changedModelID\n        })\n        if let trip = try? taskContext.fetch(fetchDescriptor).first {\n            updatedTrips.insert(trip)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Model\nfinal class Trip {\n    @Attribute(.preserveValueOnDeletion)\n    var airlineBookingRef: String\n    \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "if let deletion = change as? History.DefaultDeleteChange<Trip> {\n   bookingRef = deletion.tombstone[\\.airlineBookingRef]\n}",
      "language" : "swift"
    },
    {
      "code" : "func deleteTransactions(before token: History.DefaultToken) -> Result<Void, Error> {\n    do {\n        \/\/ Create a history descriptor and specify the predicate.\n        var descriptor = History.HistoryDescriptor<History.DefaultTransaction>()\n        descriptor.predicate = #Predicate {\n            $0.token < token\n        }\n        \/\/ Delete the matching history transactions.\n        let context = ModelContext(modelContainer)\n        try context.deleteHistory(descriptor)\n        return .success\n    } catch {\n        return .failure(error)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "5a445d5e5d83d20363a6ef2c577762a38d20fd50275e4367d87326042309de60",
  "crawledAt" : "2025-12-05T00:09:40Z",
  "id" : "120FC93D-C184-4FB0-AA9D-69BC7FD28F7A",
  "kind" : "article",
  "language" : "swift",
  "module" : "SwiftData",
  "overview" : "## Overview\n\nAs people interact with your app, the app’s persisted model data may change over time. For example, a person (or process) may create, update, or delete model instances. When the app fetches data from the data store, those results represent only the current state of that model data; there’s no straightforward way to determine if there’s been any changes to that data since the last fetch.\n\nSwiftData History enables your app to track changes in its data store over time. The data store organizes changes as a series of chronological transactions, where each transaction contains information about one or more persisted changes. Your app can fetch these transactions and react accordingly. For example, your app may need to determine changes made by another process such as a Widget or App Intent and reflect those changes in its user interface.\n\nTo use SwiftData History in your app, create a history descriptor and use a model context to fetch the corresponding chronological transactions. After the fetch completes, determine which of those fetched transactions relate to the current view or task and process them accordingly. After you finish processing them, delete the transactions from the store to reclaim the disk space.\n\n## Fetch a store’s change transactions\n\nTransactions group together one or more changes that occur on a specific boundary — such as when a model context writes pending changes to the store — and are identifiable by their associated history token. SwiftData stores transactions in the order they occur, and a model context fetches them in that same order. The group of changes that a transaction contains (inserts, updates, deletes) are also ordered chronologically.\n\nUsing a model context, you can fetch all transactions from the persistent store, or just a subset by specifying a history token, an author, or both. Tokens are opaque objects that conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Comparable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocols, enabling you to store the most recent token on-disk and use it in the next fetch to receive only newer changes. An author is a short string that your app uses to identify the origin of a transaction, which you specify on the model context that writes those changes to the store.\n\nFor example, you may want to fetch all new transactions that originate from your app’s widget.\n\nAfter processing the fetched transactions, make sure that you write the most recent transaction’s token to disk so you can use it in the next fetch.\n\n## Identify relevant model changes\n\nAs transactions represent points in time, they’re heterogenous — a single transaction can (and often will) contain changes for several different model types. Because of this, transactions aren’t bound to a specific model type. When you fetch them from a data store, the results will likely contain transactions, and changes within those transactions, that are unrelated to the current view or task. Filter each transaction’s changes and identify only those that are relevant.\n\nThe following example shows how you might identify trips with updated flight times:\n\n## Preserve important attributes of deleted models\n\nAfter deleting a model from the data store, its values are gone with no way to recover them. In most situations, this is the preferred behavior. However, there may be occasions where your app needs to retain one or more attribute values from a deleted model. For example, using a model’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel\/persistentModelID] as a means of identifying that model is only relevant within the scope of the local data store, and a different attribute may provide a stable identity across different devices and services. By retaining that attribute’s value, you’re able to reliably identify the deleted model after it’s gone.\n\nTo retain a value, use the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Attribute(_:originalName:hashModifier:)] macro and specify the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Attribute\/Option\/preserveValueOnDeletion] option:\n\nThen, when processing a transaction’s changes, use the `tombstone` property to retrieve the preserved value. `History\/Tombstone` is a generic sequence type that lets you iterate over the preserved values, or access a specific value directly using the corresponding model key path.\n\n## Delete stale change transactions\n\nSwiftData writes transactions to the data store alongside the model data, and as such, transactions require additional disk space. To make sure the store doesn’t consume more space than necessary, determine a suitable clean-up strategy to remove stale transactions when your app no longer needs them.\n\nSimilar to fetching, use a model context to delete transactions and provide a predicate to narrow the scope. For example, you may want to delete all transactions that occur before a given token:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swiftdata\/fetching-and-filtering-time-based-model-changes\ncrawled: 2025-12-05T00:09:40Z\n---\n\n# Fetching and filtering time-based model changes\n\n**Article**\n\nTrack all inserts, updates, and deletes that occur in a data store and process them as a series of chronological transactions.\n\n## Overview\n\nAs people interact with your app, the app’s persisted model data may change over time. For example, a person (or process) may create, update, or delete model instances. When the app fetches data from the data store, those results represent only the current state of that model data; there’s no straightforward way to determine if there’s been any changes to that data since the last fetch.\n\nSwiftData History enables your app to track changes in its data store over time. The data store organizes changes as a series of chronological transactions, where each transaction contains information about one or more persisted changes. Your app can fetch these transactions and react accordingly. For example, your app may need to determine changes made by another process such as a Widget or App Intent and reflect those changes in its user interface.\n\nTo use SwiftData History in your app, create a history descriptor and use a model context to fetch the corresponding chronological transactions. After the fetch completes, determine which of those fetched transactions relate to the current view or task and process them accordingly. After you finish processing them, delete the transactions from the store to reclaim the disk space.\n\n\n\n## Fetch a store’s change transactions\n\nTransactions group together one or more changes that occur on a specific boundary — such as when a model context writes pending changes to the store — and are identifiable by their associated history token. SwiftData stores transactions in the order they occur, and a model context fetches them in that same order. The group of changes that a transaction contains (inserts, updates, deletes) are also ordered chronologically.\n\nUsing a model context, you can fetch all transactions from the persistent store, or just a subset by specifying a history token, an author, or both. Tokens are opaque objects that conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Comparable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocols, enabling you to store the most recent token on-disk and use it in the next fetch to receive only newer changes. An author is a short string that your app uses to identify the origin of a transaction, which you specify on the model context that writes those changes to the store.\n\nFor example, you may want to fetch all new transactions that originate from your app’s widget.\n\n```swift\nfunc fetchWidgetTransactions(after tokenData: Data) -> Result<[DefaultHistoryTransaction], Error> {\n    do {\n        \/\/ Decode the given token data.\n        let token = try JSONDecoder().decode(History.DefaultToken.self, from: tokenData)\n        \/\/ Create a history descriptor and specify the predicate.\n        var descriptor = History.HistoryDescriptor<History.DefaultTransaction>()\n        descriptor.predicate = #Predicate {\n            ($0.token > token) && ($0.author == \"widget\")\n        }\n        \/\/ Fetch the matching history transactions.\n        let context = ModelContext(modelContainer)\n        let txns = try context.fetchHistory(descriptor)\n        return .success(txns)\n    } catch {\n        return .failure(error)\n    }\n}\n```\n\nAfter processing the fetched transactions, make sure that you write the most recent transaction’s token to disk so you can use it in the next fetch.\n\n## Identify relevant model changes\n\nAs transactions represent points in time, they’re heterogenous — a single transaction can (and often will) contain changes for several different model types. Because of this, transactions aren’t bound to a specific model type. When you fetch them from a data store, the results will likely contain transactions, and changes within those transactions, that are unrelated to the current view or task. Filter each transaction’s changes and identify only those that are relevant.\n\nThe following example shows how you might identify trips with updated flight times:\n\n```swift\nlet context = ModelContext(modelContainer)\nvar updatedTrips = Set<Trip>()\n\nfor txn in transactions {\n    \/\/ Filter out any change that isn't an update.\n    for change in txn.changes where change is History.DefaultUpdateChange<Trip> {\n        \/\/ Proceed only when there's a single change, and that change \n        \/\/ is to the `flightTime` attribute.\n        guard change.updatedAttributes.count == 1, \n              change.updatedAttributes.contains(\\.flightTime)\n        else { continue }\n        \/\/ Use the model ID from the change to fetch the actual model.\n        let changedModelID = change.changedModelID\n        var fetchDescriptor = FetchDescriptor<Trip>(predicate: #Predicate { \n            $0.persistentModelID == changedModelID\n        })\n        if let trip = try? taskContext.fetch(fetchDescriptor).first {\n            updatedTrips.insert(trip)\n        }\n    }\n}\n```\n\n## Preserve important attributes of deleted models\n\nAfter deleting a model from the data store, its values are gone with no way to recover them. In most situations, this is the preferred behavior. However, there may be occasions where your app needs to retain one or more attribute values from a deleted model. For example, using a model’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel\/persistentModelID] as a means of identifying that model is only relevant within the scope of the local data store, and a different attribute may provide a stable identity across different devices and services. By retaining that attribute’s value, you’re able to reliably identify the deleted model after it’s gone.\n\nTo retain a value, use the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Attribute(_:originalName:hashModifier:)] macro and specify the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Attribute\/Option\/preserveValueOnDeletion] option:\n\n```swift\n@Model\nfinal class Trip {\n    @Attribute(.preserveValueOnDeletion)\n    var airlineBookingRef: String\n    \/\/ ...\n}\n```\n\nThen, when processing a transaction’s changes, use the `tombstone` property to retrieve the preserved value. `History\/Tombstone` is a generic sequence type that lets you iterate over the preserved values, or access a specific value directly using the corresponding model key path.\n\n```swift\nif let deletion = change as? History.DefaultDeleteChange<Trip> {\n   bookingRef = deletion.tombstone[\\.airlineBookingRef]\n}\n```\n\n## Delete stale change transactions\n\nSwiftData writes transactions to the data store alongside the model data, and as such, transactions require additional disk space. To make sure the store doesn’t consume more space than necessary, determine a suitable clean-up strategy to remove stale transactions when your app no longer needs them.\n\n\n\nSimilar to fetching, use a model context to delete transactions and provide a predicate to narrow the scope. For example, you may want to delete all transactions that occur before a given token:\n\n```swift\nfunc deleteTransactions(before token: History.DefaultToken) -> Result<Void, Error> {\n    do {\n        \/\/ Create a history descriptor and specify the predicate.\n        var descriptor = History.HistoryDescriptor<History.DefaultTransaction>()\n        descriptor.predicate = #Predicate {\n            $0.token < token\n        }\n        \/\/ Delete the matching history transactions.\n        let context = ModelContext(modelContainer)\n        try context.deleteHistory(descriptor)\n        return .success\n    } catch {\n        return .failure(error)\n    }\n}\n```\n\n## Model life cycle\n\n- **ModelContainer**: An object that manages an app’s schema and model storage configuration.\n- **ModelContext**: An object that enables you to fetch, insert, and delete models, and save any changes to disk.\n- **HistoryDescriptor**: A type that describes the criteria, and, optionally, sort order, to use when fetching history data\n- **Deleting persistent data from your app**: Explore different ways to use SwiftData to delete persistent data.\n- **Reverting data changes using the undo manager**: Automatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.\n- **Syncing model data across a person’s devices**: Add the required capabilities and define a compatible schema to enable SwiftData to automatically sync your app’s model data using iCloud.\n- **Concurrency support**: Types you use to access model attributes and perform storage-related tasks in a safe and isolated way.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object that manages an app’s schema and model storage configuration.",
          "name" : "ModelContainer",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/ModelContainer"
        },
        {
          "description" : "An object that enables you to fetch, insert, and delete models, and save any changes to disk.",
          "name" : "ModelContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/ModelContext"
        },
        {
          "description" : "A type that describes the criteria, and, optionally, sort order, to use when fetching history data",
          "name" : "HistoryDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/HistoryDescriptor"
        },
        {
          "description" : "Explore different ways to use SwiftData to delete persistent data.",
          "name" : "Deleting persistent data from your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Deleting-persistent-data-from-your-app"
        },
        {
          "description" : "Automatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.",
          "name" : "Reverting data changes using the undo manager",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Reverting-data-changes-using-the-undo-manager"
        },
        {
          "description" : "Add the required capabilities and define a compatible schema to enable SwiftData to automatically sync your app’s model data using iCloud.",
          "name" : "Syncing model data across a person’s devices",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Syncing-model-data-across-a-persons-devices"
        },
        {
          "description" : "Types you use to access model attributes and perform storage-related tasks in a safe and isolated way.",
          "name" : "Concurrency support",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/ConcurrencySupport"
        }
      ],
      "title" : "Model life cycle"
    }
  ],
  "source" : "appleJSON",
  "title" : "Fetching and filtering time-based model changes",
  "url" : "https:\/\/developer.apple.com\/documentation\/swiftdata\/fetching-and-filtering-time-based-model-changes"
}