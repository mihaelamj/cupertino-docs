{
  "abstract" : "Add the required capabilities and define a compatible schema to enable SwiftData to automatically sync your app’s model data using iCloud.",
  "codeExamples" : [
    {
      "code" : "let config = ModelConfiguration()\n\ndo {\n#if DEBUG\n    \/\/ Use an autorelease pool to make sure Swift deallocates the persistent \n    \/\/ container before setting up the SwiftData stack.\n    try autoreleasepool {\n        let desc = NSPersistentStoreDescription(url: config.url)\n        let opts = NSPersistentCloudKitContainerOptions(containerIdentifier: \"iCloud.com.example.Trips\")\n        desc.cloudKitContainerOptions = opts\n        \/\/ Load the store synchronously so it completes before initializing the \n        \/\/ CloudKit schema.\n        desc.shouldAddStoreAsynchronously = false\n        if let mom = NSManagedObjectModel.makeManagedObjectModel(for: [Trip.self, Accommodation.self]) {\n            let container = NSPersistentCloudKitContainer(name: \"Trips\", managedObjectModel: mom)\n            container.persistentStoreDescriptions = [desc]\n            container.loadPersistentStores {_, err in\n                if let err {\n                    fatalError(err.localizedDescription)\n                }\n            }\n            \/\/ Initialize the CloudKit schema after the store finishes loading.\n            try container.initializeCloudKitSchema()\n            \/\/ Remove and unload the store from the persistent container.\n            if let store = container.persistentStoreCoordinator.persistentStores.first {\n                try container.persistentStoreCoordinator.remove(store)\n            }\n        }\n    }\n#endif\n    modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)\n} catch {\n    fatalError(error.localizedDescription)\n}",
      "language" : "swift"
    },
    {
      "code" : "let config = ModelConfiguration(cloudKitDatabase: .private(\"iCloud.com.example.Trips\"))\nlet modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)",
      "language" : "swift"
    },
    {
      "code" : "let config = ModelConfiguration(cloudKitDatabase: .none)\nlet modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)",
      "language" : "swift"
    }
  ],
  "contentHash" : "057e8d926189d560dd7df61d2599b64405fe6aafc3548dca94f317b4b03e4747",
  "crawledAt" : "2025-12-02T15:56:37Z",
  "id" : "00FCE292-DEDF-45F7-B07C-A85B643A1C0D",
  "kind" : "article",
  "language" : "swift",
  "module" : "SwiftData",
  "overview" : "## Overview\n\nPeople who use your app to create content expect that content to be available on all of their devices. SwiftData makes it possible to synchronize content by abstracting away the associated complexities. To adopt the framework’s automatic sync functionality, add two Xcode capabilities to your app. The system operates with a set of predictable behaviors, such as using your app’s `Entitlements.plist` file to infer the CloudKit configuration.\n\nSwiftData uses the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentCloudKitContainer] class from Core Data to handle CloudKit synchronization. For more information about how your models become instances of [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKRecord], see [doc:\/\/com.apple.documentation\/documentation\/CoreData\/reading-cloudkit-records-for-core-data].\n\n### Add the iCloud and Background Modes capabilities\n\nSwiftData requires two separate capabilities to perform automatic iCloud sync: the iCloud capability, which lets you configure CloudKit, and the Background Modes capability, which lets your app receive remote notifications from CloudKit that contain information about new changes on the server.\n\nTo add the iCloud and Background Modes capabilities:\n\n### Define a CloudKit compatible schema\n\nA model layer described using macros in SwiftData will, in many cases, generate a schema already compatible with CloudKit. However, the SwiftData framework does include a small number of features that CloudKit doesn’t support natively, such as unique constraints and nonoptional relationships. It’s important you consider these limitations as you design your app’s model layer (or adapt an existing one) to ensure it remains compatible with CloudKit.\n\nYou manually initialize your app’s CloudKit schema during development — as the following section describes — but you need to promote that schema to production before releasing your app. CloudKit schemas are additive only, which means you’re unable to delete model types or change existing model attributes after you promote a schema to production.\n\n### Initialize the CloudKit development schema\n\nAfter you define a model layer that’s compatible with CloudKit, use the existing integration from Core Data with CloudKit to initialize a copy of that model layer on the iCloud servers. For example, you might do this during app launch by adding the necessary code to the `init()` function of the type in your app that adopts the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App] protocol from SwiftUI.\n\nFollow these steps to ensure proper CloudKit schema initialization:\n\nTo ensure that schema initialization runs only in nonproduction builds, wrap your code with the `#if` compiler directive and specify the `DEBUG` compiler flag.\n\nGo to the [https:\/\/icloud.developer.apple.com] to verify the initialized schema. If you’re unable to see your schema’s record types or data, you may need to enable querying support. For more information, see [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/inspecting-and-editing-an-icloud-container-s-schema].\n\n### Configure SwiftData to use an existing CloudKit container\n\nBy default, SwiftData inspects your app’s `Entitlements.plist` file to determine which CloudKit container to use, and selects the first identifier it finds in that file. If your app uses multiple CloudKit containers, you may need to configure SwiftData to use a specific identifier instead of relying on the default behavior.\n\nTo opt out of automatic container discovery in SwiftData, create an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration] and use the initializer’s `cloudKitDatabase` parameter to specify your preferred identifier:\n\n### Disable automatic sync in apps already using CloudKit\n\nSwiftData uses CloudKit to provide automatic iCloud sync and therefore requires the same Xcode-managed capabilities as those found in traditional CloudKit apps. This sharing of capabilities may lead to issues in apps already using CloudKit, because SwiftData assumes the presence of those capabilities as an indication that it handles sync. For example, automatic sync isn’t possible if there are incompatibilities between a SwiftData schema and an existing CloudKit schema.\n\nIn such scenarios, opt out of automatic iCloud sync by creating an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration] and explicitly pass [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration\/CloudKitDatabase-swift.struct\/none] for the `cloudKitDatabase` parameter:\n\nSpecifying `none` overrides any automatically discovered identifiers and disables SwiftData’s automatic iCloud sync.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftData\/Syncing-model-data-across-a-persons-devices\ncrawled: 2025-12-02T15:56:37Z\n---\n\n# Syncing model data across a person’s devices\n\n**Article**\n\nAdd the required capabilities and define a compatible schema to enable SwiftData to automatically sync your app’s model data using iCloud.\n\n## Overview\n\nPeople who use your app to create content expect that content to be available on all of their devices. SwiftData makes it possible to synchronize content by abstracting away the associated complexities. To adopt the framework’s automatic sync functionality, add two Xcode capabilities to your app. The system operates with a set of predictable behaviors, such as using your app’s `Entitlements.plist` file to infer the CloudKit configuration.\n\nSwiftData uses the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentCloudKitContainer] class from Core Data to handle CloudKit synchronization. For more information about how your models become instances of [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/CKRecord], see [doc:\/\/com.apple.documentation\/documentation\/CoreData\/reading-cloudkit-records-for-core-data].\n\n### Add the iCloud and Background Modes capabilities\n\nSwiftData requires two separate capabilities to perform automatic iCloud sync: the iCloud capability, which lets you configure CloudKit, and the Background Modes capability, which lets your app receive remote notifications from CloudKit that contain information about new changes on the server.\n\n\n\nTo add the iCloud and Background Modes capabilities:\n\n1. Follow the steps in [doc:\/\/com.apple.documentation\/documentation\/Xcode\/configuring-icloud-services] to add the iCloud capability to your Xcode project, enable CloudKit, and create or choose an existing *container* — an object that CloudKit uses to isolate your app’s databases on the iCloud servers and manage their access and operations.\n2. Follow the steps in [doc:\/\/com.apple.documentation\/documentation\/Xcode\/configuring-background-execution-modes] to add the Background Modes capability, enabling the Remote notifications option. The system delivers remote notifications silently to your app, allowing SwiftData to process the changes they describe and keep your local model data in sync with the iCloud servers.\n\n### Define a CloudKit compatible schema\n\nA model layer described using macros in SwiftData will, in many cases, generate a schema already compatible with CloudKit. However, the SwiftData framework does include a small number of features that CloudKit doesn’t support natively, such as unique constraints and nonoptional relationships. It’s important you consider these limitations as you design your app’s model layer (or adapt an existing one) to ensure it remains compatible with CloudKit.\n\n\n\nYou manually initialize your app’s CloudKit schema during development — as the following section describes — but you need to promote that schema to production before releasing your app. CloudKit schemas are additive only, which means you’re unable to delete model types or change existing model attributes after you promote a schema to production.\n\n### Initialize the CloudKit development schema\n\nAfter you define a model layer that’s compatible with CloudKit, use the existing integration from Core Data with CloudKit to initialize a copy of that model layer on the iCloud servers. For example, you might do this during app launch by adding the necessary code to the `init()` function of the type in your app that adopts the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/App] protocol from SwiftUI.\n\nFollow these steps to ensure proper CloudKit schema initialization:\n\n1. Create an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration], which provides some basic information about the app’s SwiftData stack.\n2. Use the configuration’s [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration\/url] property to create an instance of [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentStoreDescription], enabling SwiftData and Core Data to reference the same store on disk.\n3. Configure the store description with your app’s CloudKit container identifier.\n4. Request Core Data load the store synchronously, to guarantee that the load finishes before you attempt to initialize the CloudKit schema.\n5. Create a managed object model that contains the same model types as the `ModelConfiguration` instance.\n6. Use [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentCloudKitContainer] to load the store from the description and to initialize the CloudKit schema.\n7. Unload the persistent store before creating an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContainer] to avoid both frameworks attempting to sync data to CloudKit.\n\n```swift\nlet config = ModelConfiguration()\n\ndo {\n#if DEBUG\n    \/\/ Use an autorelease pool to make sure Swift deallocates the persistent \n    \/\/ container before setting up the SwiftData stack.\n    try autoreleasepool {\n        let desc = NSPersistentStoreDescription(url: config.url)\n        let opts = NSPersistentCloudKitContainerOptions(containerIdentifier: \"iCloud.com.example.Trips\")\n        desc.cloudKitContainerOptions = opts\n        \/\/ Load the store synchronously so it completes before initializing the \n        \/\/ CloudKit schema.\n        desc.shouldAddStoreAsynchronously = false\n        if let mom = NSManagedObjectModel.makeManagedObjectModel(for: [Trip.self, Accommodation.self]) {\n            let container = NSPersistentCloudKitContainer(name: \"Trips\", managedObjectModel: mom)\n            container.persistentStoreDescriptions = [desc]\n            container.loadPersistentStores {_, err in\n                if let err {\n                    fatalError(err.localizedDescription)\n                }\n            }\n            \/\/ Initialize the CloudKit schema after the store finishes loading.\n            try container.initializeCloudKitSchema()\n            \/\/ Remove and unload the store from the persistent container.\n            if let store = container.persistentStoreCoordinator.persistentStores.first {\n                try container.persistentStoreCoordinator.remove(store)\n            }\n        }\n    }\n#endif\n    modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)\n} catch {\n    fatalError(error.localizedDescription)\n}\n```\n\nTo ensure that schema initialization runs only in nonproduction builds, wrap your code with the `#if` compiler directive and specify the `DEBUG` compiler flag.\n\nGo to the [https:\/\/icloud.developer.apple.com] to verify the initialized schema. If you’re unable to see your schema’s record types or data, you may need to enable querying support. For more information, see [doc:\/\/com.apple.documentation\/documentation\/CloudKit\/inspecting-and-editing-an-icloud-container-s-schema].\n\n### Configure SwiftData to use an existing CloudKit container\n\nBy default, SwiftData inspects your app’s `Entitlements.plist` file to determine which CloudKit container to use, and selects the first identifier it finds in that file. If your app uses multiple CloudKit containers, you may need to configure SwiftData to use a specific identifier instead of relying on the default behavior.\n\n\n\nTo opt out of automatic container discovery in SwiftData, create an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration] and use the initializer’s `cloudKitDatabase` parameter to specify your preferred identifier:\n\n```swift\nlet config = ModelConfiguration(cloudKitDatabase: .private(\"iCloud.com.example.Trips\"))\nlet modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)\n```\n\n### Disable automatic sync in apps already using CloudKit\n\nSwiftData uses CloudKit to provide automatic iCloud sync and therefore requires the same Xcode-managed capabilities as those found in traditional CloudKit apps. This sharing of capabilities may lead to issues in apps already using CloudKit, because SwiftData assumes the presence of those capabilities as an indication that it handles sync. For example, automatic sync isn’t possible if there are incompatibilities between a SwiftData schema and an existing CloudKit schema.\n\nIn such scenarios, opt out of automatic iCloud sync by creating an instance of [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration] and explicitly pass [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelConfiguration\/CloudKitDatabase-swift.struct\/none] for the `cloudKitDatabase` parameter:\n\n```swift\nlet config = ModelConfiguration(cloudKitDatabase: .none)\nlet modelContainer = try ModelContainer(for: Trip.self, Accommodation.self,\n                                        configurations: config)\n```\n\nSpecifying `none` overrides any automatically discovered identifiers and disables SwiftData’s automatic iCloud sync.\n\n## Model life cycle\n\n- **ModelContainer**: An object that manages an app’s schema and model storage configuration.\n- **ModelContext**: An object that enables you to fetch, insert, and delete models, and save any changes to disk.\n- **Fetching and filtering time-based model changes**: Track all inserts, updates, and deletes that occur in a data store and process them as a series of chronological transactions.\n- **HistoryDescriptor**: A type that describes the criteria, and, optionally, sort order, to use when fetching history data\n- **Deleting persistent data from your app**: Explore different ways to use SwiftData to delete persistent data.\n- **Reverting data changes using the undo manager**: Automatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.\n- **Concurrency support**: Types you use to access model attributes and perform storage-related tasks in a safe and isolated way.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object that manages an app’s schema and model storage configuration.",
          "name" : "ModelContainer",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/ModelContainer"
        },
        {
          "description" : "An object that enables you to fetch, insert, and delete models, and save any changes to disk.",
          "name" : "ModelContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/ModelContext"
        },
        {
          "description" : "Track all inserts, updates, and deletes that occur in a data store and process them as a series of chronological transactions.",
          "name" : "Fetching and filtering time-based model changes",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Fetching-and-filtering-time-based-model-changes"
        },
        {
          "description" : "A type that describes the criteria, and, optionally, sort order, to use when fetching history data",
          "name" : "HistoryDescriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/HistoryDescriptor"
        },
        {
          "description" : "Explore different ways to use SwiftData to delete persistent data.",
          "name" : "Deleting persistent data from your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Deleting-persistent-data-from-your-app"
        },
        {
          "description" : "Automatically record data change operations that people perform in your SwiftUI app, and let them undo and redo those changes.",
          "name" : "Reverting data changes using the undo manager",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Reverting-data-changes-using-the-undo-manager"
        },
        {
          "description" : "Types you use to access model attributes and perform storage-related tasks in a safe and isolated way.",
          "name" : "Concurrency support",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/ConcurrencySupport"
        }
      ],
      "title" : "Model life cycle"
    }
  ],
  "source" : "appleJSON",
  "title" : "Syncing model data across a person’s devices",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Syncing-model-data-across-a-persons-devices"
}