{
  "abstract" : "Create a data entry form for collecting and changing data managed by SwiftData.",
  "codeExamples" : [
    {
      "code" : "import SwiftData\n\n@Model\nfinal class Animal {\n    var name: String\n    var diet: Diet\n    var category: AnimalCategory?\n    \n    init(name: String, diet: Diet) {\n        self.name = name\n        self.diet = diet\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftData\n\n@Model\nfinal class AnimalCategory {\n    @Attribute(.unique) var name: String\n    \/\/ `.cascade` tells SwiftData to delete all animals contained in the \n    \/\/ category when deleting it.\n    @Relationship(deleteRule: .cascade, inverse: \\Animal.category)\n    var animals = [Animal]()\n    \n    init(name: String) {\n        self.name = name\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct AnimalEditor: View {\n    let animal: Animal?\n    \n    private var editorTitle: String {\n        animal == nil ? \"Add Animal\" : \"Edit Animal\"\n    }\n    \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "@State private var name = \"\"\n@State private var selectedDiet = Animal.Diet.herbivorous\n@State private var selectedCategory: AnimalCategory?\n\nvar body: some View {\n    NavigationStack {\n        Form {\n            TextField(\"Name\", text: $name)\n            \n            Picker(\"Category\", selection: $selectedCategory) {\n                Text(\"Select a category\").tag(nil as AnimalCategory?)\n                ForEach(categories) { category in\n                    Text(category.name).tag(category as AnimalCategory?)\n                }\n            }\n            \n            Picker(\"Diet\", selection: $selectedDiet) {\n                ForEach(Animal.Diet.allCases, id: \\.self) { diet in\n                    Text(diet.rawValue).tag(diet)\n                }\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : ".toolbar {\n    ToolbarItem(placement: .principal) {\n        Text(editorTitle)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : ".onAppear {\n    if let animal {\n        \/\/ Edit the incoming animal.\n        name = animal.name\n        selectedDiet = animal.diet\n        selectedCategory = animal.category\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "ToolbarItem(placement: .confirmationAction) {\n    Button(\"Save\") {\n        withAnimation {\n            save()\n            dismiss()\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func save() {\n    if let animal {\n        \/\/ Edit the animal.\n        animal.name = name\n        animal.diet = selectedDiet\n        animal.category = selectedCategory\n    } else {\n        \/\/ Add an animal.\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func save() {\n    if let animal {\n        \/\/ Edit the animal.\n        \/\/ ...\n    } else {\n        \/\/ Add an animal.\n        let newAnimal = Animal(name: name, diet: selectedDiet)\n        newAnimal.category = selectedCategory\n        modelContext.insert(newAnimal)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "ToolbarItem(placement: .cancellationAction) {\n    Button(\"Cancel\", role: .cancel) {\n        dismiss()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "5fed928e2f5bb05b7d5216baaa29deacaf1af2d8f8c98a71346b3336355830de",
  "crawledAt" : "2025-12-03T15:37:34Z",
  "id" : "CECDFD80-CEE0-421A-A80B-00555F2AF874",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftData",
  "overview" : "## Overview\n\nAdding and editing data are fundamental features of data-driven apps, but how an app provides these features is unique to the app. This sample shows one approach, which is to use a data-entry form with SwiftData that lets someone add, edit, and store data about animals.\n\n### Define the data model\n\nBefore SwiftData can store data from your app, the app must define the data model that represents the data. SwiftData uses model classes to construct the schema of the data model. For example, the sample app stores data about animals, and groups those animals into categories. To define the schema for this data model, the sample defines two model classes: `Animal` and `AnimalCategory`.\n\nThe `Animal` model class stores information about an animal, like its name and diet. To persist instances of `Animal`, the class definition applies the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro. This macro generates code at compile time that ensures the class conforms to the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel] protocol and makes it possible for SwiftData to save animal data to a model container.\n\nThe `AnimalCategory` model class stores information about an animal category, such as mammal or reptile. As with `Animal`, the `AnimalCategory` definition applies the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro to ensure the class conforms to [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel] and to save the animal category data to a model container.\n\nThe model class also has two properties:\n\n### Design the data editor\n\nWhen deciding how people add and edit data in your app, consider the user experience. The sample app, for instance, lets someone add and edit information about animals using a custom data entry view, named `AnimalEditor`.\n\nThe design of `AnimalEditor` allows the app to use the same view for both adding new animals and editing existing ones. To provide this behavior, the editor declares the `animal` property as an optional `Animal` type. If `animal` is `nil`, a person using the editor is adding an animal; otherwise, the person is editing an existing animal. The editor makes the intention obvious by determining the title of the editor based on the value of `animal` in a computed property.\n\nTo enable editing the values of a new or existing animal, the editor defines state variables for each editable value. These state variables store the data that a person enters into the editor, separating what they enter from the data stored in `animal`. This separation ensures that SwiftData doesn’t save changes that a person makes until they’re ready to save those changes. This also gives them an opportunity to discard any changes they may have made to the data in the editor.\n\nThe sample app takes this approach because it uses the autosave feature from SwiftData. The autosave feature automatically saves data changes made to model class instances, such as `animal`, instead of relying on the app to make explicit calls to the model context [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/save()] method. For more information about autosave, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/autosaveEnabled].\n\nFinally, to make the purpose of the editor clear to the person using it, `AnimalEditor` uses the `editorTitle` computed property to displays the title in the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ToolbarItemPlacement\/principal] item section of the toolbar:\n\n### Set default values\n\nThe `AnimalEditor` view declares its state variables with default values for a new animal, setting `name` to an empty string, `selectedDiet` to `herbivorous`, and leaving `selectedCategory` as `nil`. But the editor also supports editing an existing animal.\n\nIf someone edits an animal, the editor needs to show the values of the animal to edit, not the default values for the new animal. The view stores the animal to edit in the `animal` property. To show the current values of that animal, the editor applies the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/onAppear(perform:)] modifier and copies the editable values from `animal` to the state variables:\n\n### Save the data changes\n\nTo allow a person to save the changes they made in the editor, the editor provides a Save button in the toolbar:\n\nWhen a person clicks the Save button, it calls the editor’s `save` method. If the person is editing an existing animal, `save` copies the values from the state variables to the instance of `Animal`. This directly updates the data that SwiftData manages, and because the app uses the autosave feature, SwiftData automatically saves the changes without calling the model context [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/save()] method.\n\nWhen adding a new animal, the `save` function creates a new `Animal` instance, initializing it with the name and diet from the state variables. Then it sets the category and inserts the animal into the model context by calling the model context [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/insert(_:)] method:\n\nAfter saving the data, the Save button’s action closes the editor by calling [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/dismiss].\n\n### Discard the data changes\n\nTo discard changes that someone made, the editor provides a Cancel button in the toolbar:\n\nWhen a person clicks the Cancel button, the editor discards any changes made to the data by calling [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/dismiss] in the button’s action. This closes the editor without saving the changes.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swiftdata\/adding-and-editing-persistent-data-in-your-app\ncrawled: 2025-12-03T15:37:34Z\n---\n\n# Adding and editing persistent data in your app\n\n**Sample Code**\n\nCreate a data entry form for collecting and changing data managed by SwiftData.\n\n## Overview\n\nAdding and editing data are fundamental features of data-driven apps, but how an app provides these features is unique to the app. This sample shows one approach, which is to use a data-entry form with SwiftData that lets someone add, edit, and store data about animals.\n\n### Define the data model\n\nBefore SwiftData can store data from your app, the app must define the data model that represents the data. SwiftData uses model classes to construct the schema of the data model. For example, the sample app stores data about animals, and groups those animals into categories. To define the schema for this data model, the sample defines two model classes: `Animal` and `AnimalCategory`.\n\nThe `Animal` model class stores information about an animal, like its name and diet. To persist instances of `Animal`, the class definition applies the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro. This macro generates code at compile time that ensures the class conforms to the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel] protocol and makes it possible for SwiftData to save animal data to a model container.\n\n```swift\nimport SwiftData\n\n@Model\nfinal class Animal {\n    var name: String\n    var diet: Diet\n    var category: AnimalCategory?\n    \n    init(name: String, diet: Diet) {\n        self.name = name\n        self.diet = diet\n    }\n}\n```\n\nThe `AnimalCategory` model class stores information about an animal category, such as mammal or reptile. As with `Animal`, the `AnimalCategory` definition applies the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Model()] macro to ensure the class conforms to [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/PersistentModel] and to save the animal category data to a model container.\n\n```swift\nimport SwiftData\n\n@Model\nfinal class AnimalCategory {\n    @Attribute(.unique) var name: String\n    \/\/ `.cascade` tells SwiftData to delete all animals contained in the \n    \/\/ category when deleting it.\n    @Relationship(deleteRule: .cascade, inverse: \\Animal.category)\n    var animals = [Animal]()\n    \n    init(name: String) {\n        self.name = name\n    }\n}\n```\n\nThe model class also has two properties:\n\n\n\n### Design the data editor\n\nWhen deciding how people add and edit data in your app, consider the user experience. The sample app, for instance, lets someone add and edit information about animals using a custom data entry view, named `AnimalEditor`.\n\n\n\nThe design of `AnimalEditor` allows the app to use the same view for both adding new animals and editing existing ones. To provide this behavior, the editor declares the `animal` property as an optional `Animal` type. If `animal` is `nil`, a person using the editor is adding an animal; otherwise, the person is editing an existing animal. The editor makes the intention obvious by determining the title of the editor based on the value of `animal` in a computed property.\n\n```swift\nstruct AnimalEditor: View {\n    let animal: Animal?\n    \n    private var editorTitle: String {\n        animal == nil ? \"Add Animal\" : \"Edit Animal\"\n    }\n    \/\/ ...\n}\n```\n\nTo enable editing the values of a new or existing animal, the editor defines state variables for each editable value. These state variables store the data that a person enters into the editor, separating what they enter from the data stored in `animal`. This separation ensures that SwiftData doesn’t save changes that a person makes until they’re ready to save those changes. This also gives them an opportunity to discard any changes they may have made to the data in the editor.\n\n```swift\n@State private var name = \"\"\n@State private var selectedDiet = Animal.Diet.herbivorous\n@State private var selectedCategory: AnimalCategory?\n\nvar body: some View {\n    NavigationStack {\n        Form {\n            TextField(\"Name\", text: $name)\n            \n            Picker(\"Category\", selection: $selectedCategory) {\n                Text(\"Select a category\").tag(nil as AnimalCategory?)\n                ForEach(categories) { category in\n                    Text(category.name).tag(category as AnimalCategory?)\n                }\n            }\n            \n            Picker(\"Diet\", selection: $selectedDiet) {\n                ForEach(Animal.Diet.allCases, id: \\.self) { diet in\n                    Text(diet.rawValue).tag(diet)\n                }\n            }\n        }\n    }\n}\n```\n\nThe sample app takes this approach because it uses the autosave feature from SwiftData. The autosave feature automatically saves data changes made to model class instances, such as `animal`, instead of relying on the app to make explicit calls to the model context [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/save()] method. For more information about autosave, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/autosaveEnabled].\n\nFinally, to make the purpose of the editor clear to the person using it, `AnimalEditor` uses the `editorTitle` computed property to displays the title in the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ToolbarItemPlacement\/principal] item section of the toolbar:\n\n```swift\n.toolbar {\n    ToolbarItem(placement: .principal) {\n        Text(editorTitle)\n    }\n}\n```\n\n### Set default values\n\nThe `AnimalEditor` view declares its state variables with default values for a new animal, setting `name` to an empty string, `selectedDiet` to `herbivorous`, and leaving `selectedCategory` as `nil`. But the editor also supports editing an existing animal.\n\nIf someone edits an animal, the editor needs to show the values of the animal to edit, not the default values for the new animal. The view stores the animal to edit in the `animal` property. To show the current values of that animal, the editor applies the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/onAppear(perform:)] modifier and copies the editable values from `animal` to the state variables:\n\n```swift\n.onAppear {\n    if let animal {\n        \/\/ Edit the incoming animal.\n        name = animal.name\n        selectedDiet = animal.diet\n        selectedCategory = animal.category\n    }\n}\n```\n\n### Save the data changes\n\nTo allow a person to save the changes they made in the editor, the editor provides a Save button in the toolbar:\n\n```swift\nToolbarItem(placement: .confirmationAction) {\n    Button(\"Save\") {\n        withAnimation {\n            save()\n            dismiss()\n        }\n    }\n}\n```\n\nWhen a person clicks the Save button, it calls the editor’s `save` method. If the person is editing an existing animal, `save` copies the values from the state variables to the instance of `Animal`. This directly updates the data that SwiftData manages, and because the app uses the autosave feature, SwiftData automatically saves the changes without calling the model context [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/save()] method.\n\n```swift\nprivate func save() {\n    if let animal {\n        \/\/ Edit the animal.\n        animal.name = name\n        animal.diet = selectedDiet\n        animal.category = selectedCategory\n    } else {\n        \/\/ Add an animal.\n        \/\/ ...\n    }\n}\n```\n\nWhen adding a new animal, the `save` function creates a new `Animal` instance, initializing it with the name and diet from the state variables. Then it sets the category and inserts the animal into the model context by calling the model context [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/ModelContext\/insert(_:)] method:\n\n```swift\nprivate func save() {\n    if let animal {\n        \/\/ Edit the animal.\n        \/\/ ...\n    } else {\n        \/\/ Add an animal.\n        let newAnimal = Animal(name: name, diet: selectedDiet)\n        newAnimal.category = selectedCategory\n        modelContext.insert(newAnimal)\n    }\n}\n```\n\nAfter saving the data, the Save button’s action closes the editor by calling [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/dismiss].\n\n\n\n### Discard the data changes\n\nTo discard changes that someone made, the editor provides a Cancel button in the toolbar:\n\n```swift\nToolbarItem(placement: .cancellationAction) {\n    Button(\"Cancel\", role: .cancel) {\n        dismiss()\n    }\n}\n```\n\nWhen a person clicks the Cancel button, the editor discards any changes made to the data by calling [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/dismiss] in the button’s action. This closes the editor without saving the changes.\n\n## Essentials\n\n- **Preserving your app’s model data across launches**: Describe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime.\n- **Adopting SwiftData for a Core Data app**: Persist data in your app intuitively with the Swift native persistence framework.\n- **SwiftData updates**: Learn about important changes to SwiftData.\n- **Adopting inheritance in SwiftData**: Add flexibility to your models using class inheritance.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Describe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime.",
          "name" : "Preserving your app’s model data across launches",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Preserving-your-apps-model-data-across-launches"
        },
        {
          "description" : "Persist data in your app intuitively with the Swift native persistence framework.",
          "name" : "Adopting SwiftData for a Core Data app",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/adopting-swiftdata-for-a-core-data-app"
        },
        {
          "description" : "Learn about important changes to SwiftData.",
          "name" : "SwiftData updates",
          "url" : "https:\/\/developer.apple.com\/documentation\/Updates\/SwiftData"
        },
        {
          "description" : "Add flexibility to your models using class inheritance.",
          "name" : "Adopting inheritance in SwiftData",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Adopting-inheritance-in-SwiftData"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding and editing persistent data in your app",
  "url" : "https:\/\/developer.apple.com\/documentation\/swiftdata\/adding-and-editing-persistent-data-in-your-app"
}