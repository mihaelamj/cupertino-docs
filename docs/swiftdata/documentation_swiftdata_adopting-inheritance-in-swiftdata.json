{
  "abstract" : "Add flexibility to your models using class inheritance.",
  "codeExamples" : [
    {
      "code" : "@Model LivingAccommodation { ... }\n\n@Model class Trip {\n    @Attribute(.preserveValueOnDeletion)\n    var name: String\n    var destination: String\n    \n    @Attribute(.preserveValueOnDeletion)\n    var startDate: Date\n    \n    @Attribute(.preserveValueOnDeletion)\n    var endDate: Date\n\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListItem.trip)\n    var bucketList: [BucketListItem] = [BucketListItem]()\n\n    @Relationship(deleteRule: .cascade, inverse: \\LivingAccommodation.trip)\n    var livingAccommodation: LivingAccommodation?\n    \n    var isBusinessTrip: Boolean = false\n}\n",
      "language" : "swift"
    },
    {
      "code" : "import SwiftData\n\n@Model BucketListActivity { ... }\n\n@Model class Trip {\n    @Attribute(.preserveValueOnDeletion)\n    var name: String\n    var destination: String\n    \n    @Attribute(.preserveValueOnDeletion)\n    var startDate: Date\n    \n    @Attribute(.preserveValueOnDeletion)\n    var endDate: Date\n\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListItem.trip)\n    var bucketList: [BucketListItem] = [BucketListItem]()\n\n    @Relationship(deleteRule: .cascade, inverse: \\LivingAccommodation.trip)\n    var livingAccommodation: LivingAccommodation?\n}",
      "language" : "swift"
    },
    {
      "code" : "\n@available(iOS 26, *)\n@Model class BusinessTrip: Trip {\n    var purpose: String\n    var itinerary: MeetingItinerary\n    var expenseCode: String\n    var perDiemRate: Double\n    var mileageRate: Double\n    \n    @Relationship(deleteRule: .cascade, inverse: \\DailyMilageRecord.trip)\n    var milesDriven: [DailyMilageRecord]\n    \n    @Relationship(deleteRule: .cascade, inverse: \\BusinessMeal.trip)\n    var businessMeals: [BusinessMeal]\n    \n    @Relationship(deleteRule: .cascade, inverse: \\ConferenceSession.trip)\n    var sessionsAttended: [ConferenceSession]\n}",
      "language" : "swift"
    },
    {
      "code" : "\n@Model Attraction { ... }\n@Model FamilyMember { ... }\n\n@available(iOS 26, *)\n@Model class PersonalTrip: Trip {\n    enum Reason: String, CaseIterable, Codable, Identifiable {\n        case family\n        case reunion\n        case wellness\n        case unknown\n        \n        var id: Self { self }\n    }\n\n    var reason: Reason\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListActivities.trip)\n    var bucketList: [BucketListActivity]\n    var attractionsToVisit: [Attraction]\n    var familyMembers: [FamilyMember]\n}",
      "language" : "swift"
    },
    {
      "code" : "    enum Category: Codable {\n        case personal(Reason)​​​​​​​​​​​​\n        case business(perdiem: Double)​​​​​​​​​​​​\n    }",
      "language" : "swift"
    },
    {
      "code" : "struct TripListView: View {\n    @Environment(\\.modelContext) private var modelContext\n    \/\/ All trips, in ascending order, by start date.\n    @Query(sort: \\Trip.startDate, order: .forward)\n    var trips: [Trip]\n    \n    init(searchText: String) {\n        let searchPredicate = #Predicate<Trip> {\n            searchText.isEmpty ? true : $0.name.localizedStandardContains(searchText) || $0.destination.localizedStandardContains(searchText)\n        }\n        \/\/ Filter the trips array using predicate, which searches the trip name and destination for the provided `searchText`.\n        _trips = Query(filter: searchPredicate, sort: \\.startDate, order: .forward) \n    }\n    \n    var body: some View {\n        \/* View body contents *\/\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "enum TripKind: String, CaseIterable {\n    case all = \"All\"\n    case personal = \"Personal\"\n    case business = \"Business\"\n}\n\n\nstruct TripListView: View {\n        @Environment(\\.modelContext) private var modelContext\n        \/\/\/ All trips, in ascending order, by start date.\n        @Query(sort: \\Trip.startDate, order: .forward)\n        var trips: [Trip]\n    \n        init(tripKind: Binding<ContentView.TripKind>) {            \n            \/\/ Create a predicate, selected by the provided enumeration \n            \/\/ case, that examines the object's class to determine if it's \n            \/\/ a `BusinessTrip`, `PersonalTrip`, or `Trip`.\n            let classPredicate: Predicate<Trip>? = {\n                switch tripKind.wrappedValue {\n                \/\/ Returns a `nil` predicate representing all trips.\n                case .all:\n                    return nil \n                \/\/ Returns a predicate that matches on `PersonalTrip` objects.\n                case .personal:\n                    return #Predicate { $0 is PersonalTrip }\n                \/\/ Returns a predicate that matches on `BusinessTrip` objects.\n                case .business:\n                    return #Predicate { $0 is BusinessTrip }\n                }\n            }()\n            \n                        \n           \/\/ Filter the trips array using predicate, which matches on trips of a specific class.\n           _trips = Query(filter: classPredicate, sort: \\.startDate, order: .forward) \n        }\n    \n        var body: some View {\n            \/\/ View body contents that displays the matching trips. \n        }\n }\n ",
      "language" : "swift"
    },
    {
      "code" : "\nenum TripKind: String, CaseIterable {\n    case all = \"All\"\n    case personal = \"Personal\"\n    case business = \"Business\"\n}\n\n\nstruct TripListView: View {\n    @Environment(\\.modelContext) private var modelContext\n    \/\/\/ All trips, ordered by start date.\n    @Query(sort: \\Trip.startDate, order: .forward)\n    var trips: [Trip]\n\n    init(searchString: String, tripKind: Binding<ContentView.TripKind>) {     \n        \/\/ Create a predicate that examines the object's class to determine\n        \/\/ if it's a `BusinessType`, `Personal`, or `Trip` (\"all trips\").\n        let classPredicate: Predicate<Trip>? = {\n            switch tripKind.wrappedValue {\n            \/\/ Returns a `nil` predicate representing all trips.\n            case .all:\n                return nil \n            \/\/ Returns a predicate that matches on `PersonalTrip` objects.\n            case .personal:\n                return #Predicate { $0 is PersonalTrip }\n            \/\/ Returns a predicate that matches on `BusinessTrip` objects.\n            case .business:\n                return #Predicate { $0 is BusinessTrip }\n            }\n        }()\n        \n        \/\/ If there's search text, create a predicate than can search the trip's name and destination.        \n        let searchPredicate = #Predicate<Trip> {\n            searchText.isEmpty ? true : $0.name.localizedStandardContains(searchText) || $0.destination.localizedStandardContains(searchText)\n        }   \n    \n        let fullPredicate: Predicate<Trip>\n        if let classPredicate {\n            fullPredicate = #Predicate { classPredicate.evaluate($0) && searchPredicate.evaluate($0) }\n        } else {\n            fullPredicate = searchPredicate\n        }                                                          \n        \/\/ Filter trips on other `searchText` or trip type, or both.\n        _trips = Query(filter: fullPredicate, sort: \\.startDate, order: .forward) \n    }\n\n    var body: some View {\n        \/\/ View body contents that displays the matching trips. \n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "7804939147a78461d8df53c1a07055755a316df232c345f47cc88024bb09b9bc",
  "crawledAt" : "2025-12-03T15:37:36Z",
  "id" : "2F202446-AA2F-4B35-B07F-98A0C0706DF0",
  "kind" : "article",
  "language" : "swift",
  "module" : "SwiftData",
  "overview" : "## Overview\n\nSwiftData supports class inheritance, an object-oriented programming feature that enables you to expand the kinds of use cases your models can support by creating new subclasses that add properties and capabilities to an existing base class.\n\nLike other Swift subclasses, SwiftData models can inherit the properties and capabilities of a parent or superclass. In SwiftData this allows you to add new properties and behaviors that extend the capabilities of your models by creating a hierarchical relationship between them that you can operating on using query, predicate, and history operations. This enables you to build in more flexibility into your app as your models become more specialized and able to serve more diverse use cases.\n\nAn example of such an app might one that tracks trips: both personal trips, such as family vacations, and business trips.  At a high level, a trip might be captured in a very concise model, like the one shown here.\n\nA name, a destination, start and end dates, living accommodations, and `true` or `false` values that indicate a business or personal trip: this is functional, but as the capabilities for a trip tracking app grow, it might expand to track more kinds of information, and this is where inheritance can provide more flexibility.\n\n## Design for specialization\n\nAs described above, inheritance allows you to develop models that share fundamental properties but that diverge as use cases become more specialized. For example, a more expansive view of business and personal trips may include the  addition of new elements depending upon the specific use case. The following table shows a few more elements that these trips this might record.\n\nSubclasses that build upon the base `Trip` model make use of its properties and any common behavior, but keep these new behaviors isolated. For example, a `PersonalTrip` doesn’t have to have a state or behavior for calculating the cumulative miles traveled in a reimbursement calculation: that’s more relevant to a `BusinessTrip`.\n\nGiven the outline of personal and business trip specialization above, you’d create model subclasses for SwiftData subclasses as you would in Swift, but with the addition of the `@Model` macro, to indicate the new class is a model to SwiftData. A refactoring of our trip classes into a parent (base) class and two subclasses could resemble these classes:\n\nHere, an expanded `Trip` base class no longer uses the Boolean value that previously indicated the kind of trip. The following `BusinessTrip` and `PersonalTrip` subclasses describe additional properties and behaviors that could define these specialized trip types and create a hierarchical relationship between the parent and the subclasses.\n\nThe `PersonalTrip` subclass may have  a very different set of properties, its design and use case shares very little with a business trip, beside the name, place, optional transportation, and duration, as shown here.\n\n## Determine whether inheritance is right for your use case\n\nInheritance is useful when defining class hierarchies where you need to specialize a model representation that derives from a common base. For example `Trip`, `PersonalTrip`, and `BusinessTrip` form a natural hierarchy: a business trip and a personal trip extend the basic concept of a “trip” and create, in the language of Object Oriented design, an “IS-A” relationship. A `BusinessTrip` IS-A `Trip`. and a `PersonalTrip` also IS-A `Trip`.\n\nAvoid using inheritance in scenarios where the specialized subclass would center on common properties, such as a trip’s name, or starting or ending dates; subclassing at this level of granularity, the class hierarchy would contain many subdomains that only share a single property. In these cases if common properties need some kind of specialized behavior, protocol conformance is a better tool.\n\nAvoid using inheritance if your querying model would depend on fetching all of the model data all the time and then filtering the results, — this is known as a *deep query*. It’s possible the specialization (here the difference between personal and business trips) is something that a Boolean type could represent as it did in the initial `Trip` model where a Boolean value differentiated the type of trip. Another method to keep models “flatter,” reduce the number of properties, and avoid inheritance is to add an enumeration type that has a value which captures the type of trip and it’s value, here the personal trip’s reason or the business trip’s per diem value instead of an `isBusinessTrip` Boolean property, as shown here:\n\nAs your model’s and use cases expand, adding more properties may become impractical or difficult to maintain.\n\nConversely, if your app’s query strategy *only* focuses on the specialization — specific properties that define a business trip or a personal trip and never on the properties of the base trip model — known as a *shallow query* — then using two models might be a better approach, even though each individual model might contain some apparent duplication.\n\nLastly, If the query strategy for your app involves allowing a person to perform elements of both deep and shallow searches, in order find and return information from both a base and the subclasses, then inheritance may be a good fit for your app’s model and use case.\n\n## Fetch and Query Data\n\nCombining inheritance and customized predicates it’s possible to create any number of customized searching and filtering mechanisms that can select from any of the properties available in your parent or subclasses.\n\nFor example, to search for text in both `BusinessTrip` and `PersonalTrip` types, perform a deep search on properties using the base class `Trip`, as this the outline demonstrates:\n\nSelecting trips based on type, or all trips is a similar predicate: this example uses a simple enumeration and a switch to indicate which kind of trips to select.\n\nThe following example demonstrates how to combine both of these predicates to search for text in the trip’s’ `name` and `destination` properties, as well as by trips or by type of trip, if specified:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swiftdata\/adopting-inheritance-in-swiftdata\ncrawled: 2025-12-03T15:37:36Z\n---\n\n# Adopting inheritance in SwiftData\n\n**Article**\n\nAdd flexibility to your models using class inheritance.\n\n## Overview\n\nSwiftData supports class inheritance, an object-oriented programming feature that enables you to expand the kinds of use cases your models can support by creating new subclasses that add properties and capabilities to an existing base class.\n\nLike other Swift subclasses, SwiftData models can inherit the properties and capabilities of a parent or superclass. In SwiftData this allows you to add new properties and behaviors that extend the capabilities of your models by creating a hierarchical relationship between them that you can operating on using query, predicate, and history operations. This enables you to build in more flexibility into your app as your models become more specialized and able to serve more diverse use cases.\n\nAn example of such an app might one that tracks trips: both personal trips, such as family vacations, and business trips.  At a high level, a trip might be captured in a very concise model, like the one shown here.\n\n```swift\n@Model LivingAccommodation { ... }\n\n@Model class Trip {\n    @Attribute(.preserveValueOnDeletion)\n    var name: String\n    var destination: String\n    \n    @Attribute(.preserveValueOnDeletion)\n    var startDate: Date\n    \n    @Attribute(.preserveValueOnDeletion)\n    var endDate: Date\n\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListItem.trip)\n    var bucketList: [BucketListItem] = [BucketListItem]()\n\n    @Relationship(deleteRule: .cascade, inverse: \\LivingAccommodation.trip)\n    var livingAccommodation: LivingAccommodation?\n    \n    var isBusinessTrip: Boolean = false\n}\n\n```\n\nA name, a destination, start and end dates, living accommodations, and `true` or `false` values that indicate a business or personal trip: this is functional, but as the capabilities for a trip tracking app grow, it might expand to track more kinds of information, and this is where inheritance can provide more flexibility.\n\n## Design for specialization\n\nAs described above, inheritance allows you to develop models that share fundamental properties but that diverge as use cases become more specialized. For example, a more expansive view of business and personal trips may include the  addition of new elements depending upon the specific use case. The following table shows a few more elements that these trips this might record.\n\n\n\nSubclasses that build upon the base `Trip` model make use of its properties and any common behavior, but keep these new behaviors isolated. For example, a `PersonalTrip` doesn’t have to have a state or behavior for calculating the cumulative miles traveled in a reimbursement calculation: that’s more relevant to a `BusinessTrip`.\n\nGiven the outline of personal and business trip specialization above, you’d create model subclasses for SwiftData subclasses as you would in Swift, but with the addition of the `@Model` macro, to indicate the new class is a model to SwiftData. A refactoring of our trip classes into a parent (base) class and two subclasses could resemble these classes:\n\n```swift\nimport SwiftData\n\n@Model BucketListActivity { ... }\n\n@Model class Trip {\n    @Attribute(.preserveValueOnDeletion)\n    var name: String\n    var destination: String\n    \n    @Attribute(.preserveValueOnDeletion)\n    var startDate: Date\n    \n    @Attribute(.preserveValueOnDeletion)\n    var endDate: Date\n\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListItem.trip)\n    var bucketList: [BucketListItem] = [BucketListItem]()\n\n    @Relationship(deleteRule: .cascade, inverse: \\LivingAccommodation.trip)\n    var livingAccommodation: LivingAccommodation?\n}\n```\n\nHere, an expanded `Trip` base class no longer uses the Boolean value that previously indicated the kind of trip. The following `BusinessTrip` and `PersonalTrip` subclasses describe additional properties and behaviors that could define these specialized trip types and create a hierarchical relationship between the parent and the subclasses.\n\n```swift\n\n@available(iOS 26, *)\n@Model class BusinessTrip: Trip {\n    var purpose: String\n    var itinerary: MeetingItinerary\n    var expenseCode: String\n    var perDiemRate: Double\n    var mileageRate: Double\n    \n    @Relationship(deleteRule: .cascade, inverse: \\DailyMilageRecord.trip)\n    var milesDriven: [DailyMilageRecord]\n    \n    @Relationship(deleteRule: .cascade, inverse: \\BusinessMeal.trip)\n    var businessMeals: [BusinessMeal]\n    \n    @Relationship(deleteRule: .cascade, inverse: \\ConferenceSession.trip)\n    var sessionsAttended: [ConferenceSession]\n}\n```\n\nThe `PersonalTrip` subclass may have  a very different set of properties, its design and use case shares very little with a business trip, beside the name, place, optional transportation, and duration, as shown here.\n\n```swift\n\n@Model Attraction { ... }\n@Model FamilyMember { ... }\n\n@available(iOS 26, *)\n@Model class PersonalTrip: Trip {\n    enum Reason: String, CaseIterable, Codable, Identifiable {\n        case family\n        case reunion\n        case wellness\n        case unknown\n        \n        var id: Self { self }\n    }\n\n    var reason: Reason\n    @Relationship(deleteRule: .cascade, inverse: \\BucketListActivities.trip)\n    var bucketList: [BucketListActivity]\n    var attractionsToVisit: [Attraction]\n    var familyMembers: [FamilyMember]\n}\n```\n\n## Determine whether inheritance is right for your use case\n\nInheritance is useful when defining class hierarchies where you need to specialize a model representation that derives from a common base. For example `Trip`, `PersonalTrip`, and `BusinessTrip` form a natural hierarchy: a business trip and a personal trip extend the basic concept of a “trip” and create, in the language of Object Oriented design, an “IS-A” relationship. A `BusinessTrip` IS-A `Trip`. and a `PersonalTrip` also IS-A `Trip`.\n\nAvoid using inheritance in scenarios where the specialized subclass would center on common properties, such as a trip’s name, or starting or ending dates; subclassing at this level of granularity, the class hierarchy would contain many subdomains that only share a single property. In these cases if common properties need some kind of specialized behavior, protocol conformance is a better tool.\n\nAvoid using inheritance if your querying model would depend on fetching all of the model data all the time and then filtering the results, — this is known as a *deep query*. It’s possible the specialization (here the difference between personal and business trips) is something that a Boolean type could represent as it did in the initial `Trip` model where a Boolean value differentiated the type of trip. Another method to keep models “flatter,” reduce the number of properties, and avoid inheritance is to add an enumeration type that has a value which captures the type of trip and it’s value, here the personal trip’s reason or the business trip’s per diem value instead of an `isBusinessTrip` Boolean property, as shown here:\n\n```swift\n    enum Category: Codable {\n        case personal(Reason)​​​​​​​​​​​​\n        case business(perdiem: Double)​​​​​​​​​​​​\n    }\n```\n\nAs your model’s and use cases expand, adding more properties may become impractical or difficult to maintain.\n\nConversely, if your app’s query strategy *only* focuses on the specialization — specific properties that define a business trip or a personal trip and never on the properties of the base trip model — known as a *shallow query* — then using two models might be a better approach, even though each individual model might contain some apparent duplication.\n\nLastly, If the query strategy for your app involves allowing a person to perform elements of both deep and shallow searches, in order find and return information from both a base and the subclasses, then inheritance may be a good fit for your app’s model and use case.\n\n## Fetch and Query Data\n\n\n\nCombining inheritance and customized predicates it’s possible to create any number of customized searching and filtering mechanisms that can select from any of the properties available in your parent or subclasses.\n\nFor example, to search for text in both `BusinessTrip` and `PersonalTrip` types, perform a deep search on properties using the base class `Trip`, as this the outline demonstrates:\n\n```swift\nstruct TripListView: View {\n    @Environment(\\.modelContext) private var modelContext\n    \/\/ All trips, in ascending order, by start date.\n    @Query(sort: \\Trip.startDate, order: .forward)\n    var trips: [Trip]\n    \n    init(searchText: String) {\n        let searchPredicate = #Predicate<Trip> {\n            searchText.isEmpty ? true : $0.name.localizedStandardContains(searchText) || $0.destination.localizedStandardContains(searchText)\n        }\n        \/\/ Filter the trips array using predicate, which searches the trip name and destination for the provided `searchText`.\n        _trips = Query(filter: searchPredicate, sort: \\.startDate, order: .forward) \n    }\n    \n    var body: some View {\n        \/* View body contents *\/\n    }\n}\n```\n\nSelecting trips based on type, or all trips is a similar predicate: this example uses a simple enumeration and a switch to indicate which kind of trips to select.\n\n```swift\nenum TripKind: String, CaseIterable {\n    case all = \"All\"\n    case personal = \"Personal\"\n    case business = \"Business\"\n}\n\n\nstruct TripListView: View {\n        @Environment(\\.modelContext) private var modelContext\n        \/\/\/ All trips, in ascending order, by start date.\n        @Query(sort: \\Trip.startDate, order: .forward)\n        var trips: [Trip]\n    \n        init(tripKind: Binding<ContentView.TripKind>) {            \n            \/\/ Create a predicate, selected by the provided enumeration \n            \/\/ case, that examines the object's class to determine if it's \n            \/\/ a `BusinessTrip`, `PersonalTrip`, or `Trip`.\n            let classPredicate: Predicate<Trip>? = {\n                switch tripKind.wrappedValue {\n                \/\/ Returns a `nil` predicate representing all trips.\n                case .all:\n                    return nil \n                \/\/ Returns a predicate that matches on `PersonalTrip` objects.\n                case .personal:\n                    return #Predicate { $0 is PersonalTrip }\n                \/\/ Returns a predicate that matches on `BusinessTrip` objects.\n                case .business:\n                    return #Predicate { $0 is BusinessTrip }\n                }\n            }()\n            \n                        \n           \/\/ Filter the trips array using predicate, which matches on trips of a specific class.\n           _trips = Query(filter: classPredicate, sort: \\.startDate, order: .forward) \n        }\n    \n        var body: some View {\n            \/\/ View body contents that displays the matching trips. \n        }\n }\n \n```\n\nThe following example demonstrates how to combine both of these predicates to search for text in the trip’s’ `name` and `destination` properties, as well as by trips or by type of trip, if specified:\n\n```swift\n\nenum TripKind: String, CaseIterable {\n    case all = \"All\"\n    case personal = \"Personal\"\n    case business = \"Business\"\n}\n\n\nstruct TripListView: View {\n    @Environment(\\.modelContext) private var modelContext\n    \/\/\/ All trips, ordered by start date.\n    @Query(sort: \\Trip.startDate, order: .forward)\n    var trips: [Trip]\n\n    init(searchString: String, tripKind: Binding<ContentView.TripKind>) {     \n        \/\/ Create a predicate that examines the object's class to determine\n        \/\/ if it's a `BusinessType`, `Personal`, or `Trip` (\"all trips\").\n        let classPredicate: Predicate<Trip>? = {\n            switch tripKind.wrappedValue {\n            \/\/ Returns a `nil` predicate representing all trips.\n            case .all:\n                return nil \n            \/\/ Returns a predicate that matches on `PersonalTrip` objects.\n            case .personal:\n                return #Predicate { $0 is PersonalTrip }\n            \/\/ Returns a predicate that matches on `BusinessTrip` objects.\n            case .business:\n                return #Predicate { $0 is BusinessTrip }\n            }\n        }()\n        \n        \/\/ If there's search text, create a predicate than can search the trip's name and destination.        \n        let searchPredicate = #Predicate<Trip> {\n            searchText.isEmpty ? true : $0.name.localizedStandardContains(searchText) || $0.destination.localizedStandardContains(searchText)\n        }   \n    \n        let fullPredicate: Predicate<Trip>\n        if let classPredicate {\n            fullPredicate = #Predicate { classPredicate.evaluate($0) && searchPredicate.evaluate($0) }\n        } else {\n            fullPredicate = searchPredicate\n        }                                                          \n        \/\/ Filter trips on other `searchText` or trip type, or both.\n        _trips = Query(filter: fullPredicate, sort: \\.startDate, order: .forward) \n    }\n\n    var body: some View {\n        \/\/ View body contents that displays the matching trips. \n    }\n}\n```\n\n## Essentials\n\n- **Preserving your app’s model data across launches**: Describe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime.\n- **Adding and editing persistent data in your app**: Create a data entry form for collecting and changing data managed by SwiftData.\n- **Adopting SwiftData for a Core Data app**: Persist data in your app intuitively with the Swift native persistence framework.\n- **SwiftData updates**: Learn about important changes to SwiftData.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Describe your model classes to SwiftData using the framework’s macros, and store instances of those models so they exist beyond the app’s runtime.",
          "name" : "Preserving your app’s model data across launches",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Preserving-your-apps-model-data-across-launches"
        },
        {
          "description" : "Create a data entry form for collecting and changing data managed by SwiftData.",
          "name" : "Adding and editing persistent data in your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Adding-and-editing-persistent-data-in-your-app"
        },
        {
          "description" : "Persist data in your app intuitively with the Swift native persistence framework.",
          "name" : "Adopting SwiftData for a Core Data app",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreData\/adopting-swiftdata-for-a-core-data-app"
        },
        {
          "description" : "Learn about important changes to SwiftData.",
          "name" : "SwiftData updates",
          "url" : "https:\/\/developer.apple.com\/documentation\/Updates\/SwiftData"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adopting inheritance in SwiftData",
  "url" : "https:\/\/developer.apple.com\/documentation\/swiftdata\/adopting-inheritance-in-swiftdata"
}