{
  "abstract" : "Create relationships for static and dynamic data stored in your app.",
  "codeExamples" : [
    {
      "code" : "extension Animal {\n    enum Diet: String, CaseIterable, Codable {\n        case herbivorous = \"Herbivore\"\n        case carnivorous = \"Carnivore\"\n        case omnivorous = \"Omnivore\"\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Model\nfinal class Animal {\n    var name: String\n    var diet: Diet\n    var category: AnimalCategory?\n    \n    init(name: String, diet: Diet) {\n        self.name = name\n        self.diet = diet\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "Picker(\"Diet\", selection: $selectedDiet) {\n    ForEach(Animal.Diet.allCases, id: \\.self) { diet in\n        Text(diet.rawValue).tag(diet)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Model\nfinal class AnimalCategory {\n    @Attribute(.unique) var name: String\n    \/\/ `.cascade` tells SwiftData to delete all animals contained in the \n    \/\/ category when deleting it.\n    @Relationship(deleteRule: .cascade, inverse: \\Animal.category)\n    var animals = [Animal]()\n    \n    init(name: String) {\n        self.name = name\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Relationship(deleteRule: .cascade, inverse: \\Animal.category)\nvar animals = [Animal]()",
      "language" : "swift"
    },
    {
      "code" : "@Relationship(inverse: \\Animal.category)\nvar animals = [Animal]()",
      "language" : "swift"
    },
    {
      "code" : "@main\nstruct SwiftDataAnimalsApp: App {\n    var body: some Scene {\n        WindowGroup() {\n            ContentView()\n        }\n        .modelContainer(for: AnimalCategory.self)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "1e8306a477b41a00f9748a056dc4a72c9cc8279ca0f106614d08ac3bd58c8079",
  "crawledAt" : "2025-12-02T15:32:35Z",
  "id" : "BB5C0100-1ED9-4619-90D5-8D56EA033D70",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftData",
  "overview" : "## Overview\n\nThere are two ways to define data relationships in your app: using enumerations and using the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)] macro in a model class. Which one to use depends on the unique circumstances of your app. This article explains how to apply both approaches to the sample [doc:\/\/com.apple.documentation\/documentation\/SwiftUI] app that persist data using SwiftData.\n\n### Relate a model class to static data\n\nEnumerations are a convenient way to form relationships between a model class and static data — data that the app defines and doesn’t change. To define the static data, create an enumeration and ensure it conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol. SwiftData requires this conformance to persist any data that is of the enumeration type. The following code, for example, declares a `Codable` conforming enumeration that specify the animal type based on their diets:\n\nThe `Animal` model class declares the property `diet` as a type of `Diet`. Because this property is non-optional, its value must be set to one of the `Diet` cases: `herbivore`, `carnivore`, and `ominvore`.\n\nA person using the sample app can set the diet of an animal by choosing one of the available `Diet` cases from a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Picker]; for example:\n\nTo learn more about how the sample app saves data changes, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Adding-and-editing-persistent-data-in-your-app].\n\n### Relate a model class to dynamic data\n\nIf the related data is dynamic and unknown to the app — data that comes from an external source such as someone using the app or a remote server — then form a relationship between two model classes instead of a class and enumeration. For instance, the dynamic data in the sample app includes animals and animal categories. An animal can belong to no more than one animal category, and a category can contain zero, one, or more animals.\n\nTo declare this relationship, the `AnimalCategory` class defines the property `animals`, which represents the animals contained in the category. The class also applies the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)] macro to the `animals` property. This macro defines the relationship between the `AnimalCategory` and `Animal` model classes.\n\nSet the parameter values of this macro to configure the relationship. For example, the `deleteRule` parameter specifies how SwiftData handles related data during delete operations. The `inverse` parameter is a key path to the store property, `category`, declared in the related model class, `Animal`. The inverse parameter forms the relationship between the two classes, `AnimalCategory` and `Animal`, and the `category` property declared in `Animal` provides a reference to an animal category.\n\n### Set a relationship’s delete rule\n\nThe `deleteRule` parameter specifies how SwiftData handles delete operations with regards to the related data. The [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum\/cascade] delete rule tells SwiftData to delete all related data when deleting the primary object. For example, deleting an `AnimalCategory` in the sample app causes SwiftData to also delete all animals contained in that category.\n\nIf you don’t want to delete the animals within a category, you can use the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum\/nullify] delete rule. This rule tells SwiftData to set the animal’s `category` property to `nil` for each animal contained in the animal category when deleting the category. Because the default value for the `deleteRule` parameter is `nullify`, you can create the relationship without explicitly specifying the delete rule, like so:\n\nFor a complete list of delete rules, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum].\n\n### Create a model container\n\nWhether your data model includes relationships, you must always create a model container for your app when using SwiftData. The sample app creates a model container using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)-18hhy] modifier, passing in the model type `AnimalCategory.self`:\n\nSwiftData uses the model type to construct the schema that determines the structure of the persistent storage area. The schema also includes all related types that form the object graph of the provided model type. For instance, `AnimalCategory` is a root model type of an object graph. `AnimalCategory` contains a relationship to the model type `Animal`, which means that the schema includes `Animal` along with `AnimalCategory`. If `Animal` had a relationship to another model type, the schema would also include that type.\n\nIf your app defines multiple root model types, use the\n[doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)-8oc48] modifier, passing in an array that contains each root model type used in your app.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftData\/Defining-data-relationships-with-enumerations-and-model-classes\ncrawled: 2025-12-02T15:32:35Z\n---\n\n# Defining data relationships with enumerations and model classes\n\n**Sample Code**\n\nCreate relationships for static and dynamic data stored in your app.\n\n## Overview\n\nThere are two ways to define data relationships in your app: using enumerations and using the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)] macro in a model class. Which one to use depends on the unique circumstances of your app. This article explains how to apply both approaches to the sample [doc:\/\/com.apple.documentation\/documentation\/SwiftUI] app that persist data using SwiftData.\n\n### Relate a model class to static data\n\nEnumerations are a convenient way to form relationships between a model class and static data — data that the app defines and doesn’t change. To define the static data, create an enumeration and ensure it conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol. SwiftData requires this conformance to persist any data that is of the enumeration type. The following code, for example, declares a `Codable` conforming enumeration that specify the animal type based on their diets:\n\n```swift\nextension Animal {\n    enum Diet: String, CaseIterable, Codable {\n        case herbivorous = \"Herbivore\"\n        case carnivorous = \"Carnivore\"\n        case omnivorous = \"Omnivore\"\n    }\n}\n```\n\nThe `Animal` model class declares the property `diet` as a type of `Diet`. Because this property is non-optional, its value must be set to one of the `Diet` cases: `herbivore`, `carnivore`, and `ominvore`.\n\n```swift\n@Model\nfinal class Animal {\n    var name: String\n    var diet: Diet\n    var category: AnimalCategory?\n    \n    init(name: String, diet: Diet) {\n        self.name = name\n        self.diet = diet\n    }\n}\n```\n\nA person using the sample app can set the diet of an animal by choosing one of the available `Diet` cases from a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Picker]; for example:\n\n```swift\nPicker(\"Diet\", selection: $selectedDiet) {\n    ForEach(Animal.Diet.allCases, id: \\.self) { diet in\n        Text(diet.rawValue).tag(diet)\n    }\n}\n```\n\nTo learn more about how the sample app saves data changes, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Adding-and-editing-persistent-data-in-your-app].\n\n### Relate a model class to dynamic data\n\nIf the related data is dynamic and unknown to the app — data that comes from an external source such as someone using the app or a remote server — then form a relationship between two model classes instead of a class and enumeration. For instance, the dynamic data in the sample app includes animals and animal categories. An animal can belong to no more than one animal category, and a category can contain zero, one, or more animals.\n\n\n\nTo declare this relationship, the `AnimalCategory` class defines the property `animals`, which represents the animals contained in the category. The class also applies the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)] macro to the `animals` property. This macro defines the relationship between the `AnimalCategory` and `Animal` model classes.\n\n```swift\n@Model\nfinal class AnimalCategory {\n    @Attribute(.unique) var name: String\n    \/\/ `.cascade` tells SwiftData to delete all animals contained in the \n    \/\/ category when deleting it.\n    @Relationship(deleteRule: .cascade, inverse: \\Animal.category)\n    var animals = [Animal]()\n    \n    init(name: String) {\n        self.name = name\n    }\n}\n```\n\nSet the parameter values of this macro to configure the relationship. For example, the `deleteRule` parameter specifies how SwiftData handles related data during delete operations. The `inverse` parameter is a key path to the store property, `category`, declared in the related model class, `Animal`. The inverse parameter forms the relationship between the two classes, `AnimalCategory` and `Animal`, and the `category` property declared in `Animal` provides a reference to an animal category.\n\n### Set a relationship’s delete rule\n\nThe `deleteRule` parameter specifies how SwiftData handles delete operations with regards to the related data. The [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum\/cascade] delete rule tells SwiftData to delete all related data when deleting the primary object. For example, deleting an `AnimalCategory` in the sample app causes SwiftData to also delete all animals contained in that category.\n\n```swift\n@Relationship(deleteRule: .cascade, inverse: \\Animal.category)\nvar animals = [Animal]()\n```\n\nIf you don’t want to delete the animals within a category, you can use the [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum\/nullify] delete rule. This rule tells SwiftData to set the animal’s `category` property to `nil` for each animal contained in the animal category when deleting the category. Because the default value for the `deleteRule` parameter is `nullify`, you can create the relationship without explicitly specifying the delete rule, like so:\n\n```swift\n@Relationship(inverse: \\Animal.category)\nvar animals = [Animal]()\n```\n\nFor a complete list of delete rules, see [doc:\/\/com.apple.SwiftData\/documentation\/SwiftData\/Schema\/Relationship\/DeleteRule-swift.enum].\n\n### Create a model container\n\nWhether your data model includes relationships, you must always create a model container for your app when using SwiftData. The sample app creates a model container using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)-18hhy] modifier, passing in the model type `AnimalCategory.self`:\n\n```swift\n@main\nstruct SwiftDataAnimalsApp: App {\n    var body: some Scene {\n        WindowGroup() {\n            ContentView()\n        }\n        .modelContainer(for: AnimalCategory.self)\n    }\n}\n```\n\nSwiftData uses the model type to construct the schema that determines the structure of the persistent storage area. The schema also includes all related types that form the object graph of the provided model type. For instance, `AnimalCategory` is a root model type of an object graph. `AnimalCategory` contains a relationship to the model type `Animal`, which means that the schema includes `Animal` along with `AnimalCategory`. If `Animal` had a relationship to another model type, the schema would also include that type.\n\nIf your app defines multiple root model types, use the\n[doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/modelContainer(for:inMemory:isAutosaveEnabled:isUndoEnabled:onSetup:)-8oc48] modifier, passing in an array that contains each root model type used in your app.\n\n## Model definition\n\n- **Model()**: Converts a Swift class into a stored model that’s managed by SwiftData.\n- **Attribute(_:originalName:hashModifier:)**: Specifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.\n- **Unique(_:)**: Specifies the key-paths that SwiftData uses to enforce the uniqueness of model instances.\n- **Index(_:)**: Specifies the key-paths that SwiftData uses to create one or more binary indices for the associated model.\n- **Index(_:)**: Specifies the key-paths that SwiftData uses to create one or more indicies for the associated model, where each index is either binary or R-tree.\n- **Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)**: Specifies the options that SwiftData needs to manage the annotated property as a relationship between two models.\n- **Transient()**: Tells SwiftData not to persist the annotated property when managing the owning class.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Converts a Swift class into a stored model that’s managed by SwiftData.",
          "name" : "Model()",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Model()"
        },
        {
          "description" : "Specifies the custom behavior that SwiftData applies to the annotated property when managing the owning class.",
          "name" : "Attribute(_:originalName:hashModifier:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Attribute(_:originalName:hashModifier:)"
        },
        {
          "description" : "Specifies the key-paths that SwiftData uses to enforce the uniqueness of model instances.",
          "name" : "Unique(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Unique(_:)"
        },
        {
          "description" : "Specifies the key-paths that SwiftData uses to create one or more binary indices for the associated model.",
          "name" : "Index(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Index(_:)-74ia2"
        },
        {
          "description" : "Specifies the key-paths that SwiftData uses to create one or more indicies for the associated model, where each index is either binary or R-tree.",
          "name" : "Index(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Index(_:)-7d4z0"
        },
        {
          "description" : "Specifies the options that SwiftData needs to manage the annotated property as a relationship between two models.",
          "name" : "Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Relationship(_:deleteRule:minimumModelCount:maximumModelCount:originalName:inverse:hashModifier:)"
        },
        {
          "description" : "Tells SwiftData not to persist the annotated property when managing the owning class.",
          "name" : "Transient()",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Transient()"
        }
      ],
      "title" : "Model definition"
    }
  ],
  "source" : "appleJSON",
  "title" : "Defining data relationships with enumerations and model classes",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftData\/Defining-data-relationships-with-enumerations-and-model-classes"
}