{
  "abstract" : "This method attempts to apply a kernel in place on a texture.",
  "codeExamples" : [
    {
      "code" : "id <MTLTexture> inPlaceTex = ...;\nMPSImageSobel *sobelFiler = [[MPSImageSobel alloc] initWithDevice: my_device];\n \n\/\/ With a fallback MPSCopyAllocator, failure should only occur in exceptional conditions such as MTLTexture allocation failure or programmer error.\n\/\/ That is, the operation is roughly as robust as the MPSCopyAllocator.\n\/\/ Depending on the quality of that, we might decide we are justified here in not checking the return value.\n[sobelFilter encodeToCommandBuffer: my_command_buffer inPlaceTexture: &inPlaceTex fallbackCopyAllocator: myAllocator];\n\/\/ inPlaceTex may be replaced!\n \n\/\/ If myAllocator was not called:\n\/\/      inPlaceTex holds the original texture with the result pixels in it.\n\/\/ Else:\n\/\/      1) myAllocator creates a new texture.\n\/\/      2) The new texture pixel data is overwritten by MPSUnaryImageKernel.\n\/\/      3) The old texture passed in *inPlaceTex is released once.\n\/\/      4) *inPlaceTex = the new texture\n\/\/\n\/\/ In either case, the caller should now hold one reference to the texture now held in inPlaceTex, whether it was replaced or not. Most of the time that means that nothing further needs to be done here, and you can proceed to the next image encoding operation. However, if other agents held references to the original texture, they still hold them and may need to be alerted that the texture has been replaced so that they can retain the new texture and release the old one.\n \n[sobelFilter release];  \/\/ if not ARC, clean up the MPSImageSobel object",
      "language" : "objc"
    }
  ],
  "contentHash" : "969bcadb80dd2f9ad25875932e24b51c0337578e87f39694eb369996faa66b0b",
  "crawledAt" : "2025-12-06T12:05:02Z",
  "declaration" : {
    "code" : "func encode(commandBuffer: any MTLCommandBuffer, inPlaceTexture texture: UnsafeMutablePointer<any MTLTexture>, fallbackCopyAllocator copyAllocator: MPSCopyAllocator? = nil) -> Bool",
    "language" : "swift"
  },
  "id" : "0480319E-7591-4135-84AA-763043F001E8",
  "kind" : "method",
  "language" : "swift",
  "module" : "Metal Performance Shaders",
  "overview" : "## Return Value\n\n[doc:\/\/com.apple.documentation\/documentation\/Swift\/true] if the operation succeeded (the texture may have been replaced with a new texture if a copy allocator was provided). [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] if the operation failed (the texture is unmodified).\n\n## Discussion\n\nThis method attempts to apply the kernel in place on a texture. In-place operation means that the same texture is used both to hold the input image and the results. Operating in-place can be an excellent way to reduce resource utilization, and save time and energy. While simple Metal kernels can not operate in place because textures can not be readable and writable at the same time, some Metal Performance Shaders kernels can operate in place because they use multi-pass algorithms. Whether a kernel can operate in-place can depend on current hardware, OS version, and the parameters and properties passed to it. You should never assume that a kernel will continue to work in place, even if you have observed it doing so before.\n\nIf the in-place operation succeeds, this method returns [doc:\/\/com.apple.documentation\/documentation\/Swift\/true].  If the in-place operation fails and no copy allocator is provided, then this method returns [doc:\/\/com.apple.documentation\/documentation\/Swift\/false]. Without a fallback copy allocator, in neither case is the pointer held at `texture` modified.\n\nFailure during in-place operation is very common and will occur inconsistently across different hardware platforms and OS versions. Without a fallback copy allocator, operating in place may require significant error handling code to accompany each call to this method, further complicating your code.\n\nYou may find it simplifies your code to provide a fallback copy allocator so that the operation can proceed reliably even when it can not complete in-place. When an in-place filter fails, the copy allocator will be invoked to create a new texture in which to write the results, allowing the filter to proceed reliably out-of-place. The original texture will be released, replaced with a pointer to the new texture and [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] will be returned. If the copy allocator returns an invalid texture, it is released, `texture` remains unmodified, and [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] is returned.\n\nListing 1. In-Place Operation Example",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/MetalPerformanceShaders\/MPSUnaryImageKernel\/encode(commandBuffer:inPlaceTexture:fallbackCopyAllocator:)\ncrawled: 2025-12-06T12:05:02Z\n---\n\n# encode(commandBuffer:inPlaceTexture:fallbackCopyAllocator:)\n\n**Instance Method**\n\nThis method attempts to apply a kernel in place on a texture.\n\n## Declaration\n\n```swift\nfunc encode(commandBuffer: any MTLCommandBuffer, inPlaceTexture texture: UnsafeMutablePointer<any MTLTexture>, fallbackCopyAllocator copyAllocator: MPSCopyAllocator? = nil) -> Bool\n```\n\n## Parameters\n\n- **commandBuffer**: A valid command buffer to receive the encoded kernel.\n- **texture**: A pointer to a valid texture containing the source image. On success, the image contents and possibly the texture itself will be replaced with the result image.\n- **copyAllocator**: An optional block to allocate a new texture to hold the operation results, in case in-place operation is not possible. The allocator may use a different pixel format or size than the original texture. You may enqueue operations on the provided command buffer using the provided compute command encoder to initialize the texture contents.\n\n## Return Value\n\n[doc:\/\/com.apple.documentation\/documentation\/Swift\/true] if the operation succeeded (the texture may have been replaced with a new texture if a copy allocator was provided). [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] if the operation failed (the texture is unmodified).\n\n## Discussion\n\nThis method attempts to apply the kernel in place on a texture. In-place operation means that the same texture is used both to hold the input image and the results. Operating in-place can be an excellent way to reduce resource utilization, and save time and energy. While simple Metal kernels can not operate in place because textures can not be readable and writable at the same time, some Metal Performance Shaders kernels can operate in place because they use multi-pass algorithms. Whether a kernel can operate in-place can depend on current hardware, OS version, and the parameters and properties passed to it. You should never assume that a kernel will continue to work in place, even if you have observed it doing so before.\n\nIf the in-place operation succeeds, this method returns [doc:\/\/com.apple.documentation\/documentation\/Swift\/true].  If the in-place operation fails and no copy allocator is provided, then this method returns [doc:\/\/com.apple.documentation\/documentation\/Swift\/false]. Without a fallback copy allocator, in neither case is the pointer held at `texture` modified.\n\nFailure during in-place operation is very common and will occur inconsistently across different hardware platforms and OS versions. Without a fallback copy allocator, operating in place may require significant error handling code to accompany each call to this method, further complicating your code.\n\nYou may find it simplifies your code to provide a fallback copy allocator so that the operation can proceed reliably even when it can not complete in-place. When an in-place filter fails, the copy allocator will be invoked to create a new texture in which to write the results, allowing the filter to proceed reliably out-of-place. The original texture will be released, replaced with a pointer to the new texture and [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] will be returned. If the copy allocator returns an invalid texture, it is released, `texture` remains unmodified, and [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] is returned.\n\nListing 1. In-Place Operation Example\n\n```objc\nid <MTLTexture> inPlaceTex = ...;\nMPSImageSobel *sobelFiler = [[MPSImageSobel alloc] initWithDevice: my_device];\n \n\/\/ With a fallback MPSCopyAllocator, failure should only occur in exceptional conditions such as MTLTexture allocation failure or programmer error.\n\/\/ That is, the operation is roughly as robust as the MPSCopyAllocator.\n\/\/ Depending on the quality of that, we might decide we are justified here in not checking the return value.\n[sobelFilter encodeToCommandBuffer: my_command_buffer inPlaceTexture: &inPlaceTex fallbackCopyAllocator: myAllocator];\n\/\/ inPlaceTex may be replaced!\n \n\/\/ If myAllocator was not called:\n\/\/      inPlaceTex holds the original texture with the result pixels in it.\n\/\/ Else:\n\/\/      1) myAllocator creates a new texture.\n\/\/      2) The new texture pixel data is overwritten by MPSUnaryImageKernel.\n\/\/      3) The old texture passed in *inPlaceTex is released once.\n\/\/      4) *inPlaceTex = the new texture\n\/\/\n\/\/ In either case, the caller should now hold one reference to the texture now held in inPlaceTex, whether it was replaced or not. Most of the time that means that nothing further needs to be done here, and you can proceed to the next image encoding operation. However, if other agents held references to the original texture, they still hold them and may need to be alerted that the texture has been replaced so that they can retain the new texture and release the old one.\n \n[sobelFilter release];  \/\/ if not ARC, clean up the MPSImageSobel object\n```\n\n## Methods\n\n- **MPSCopyAllocator**: A block to make a copy of a source texture for filters that can only execute out of place.\n- **encode(commandBuffer:sourceImage:destinationImage:)**\n- **encode(commandBuffer:sourceTexture:destinationTexture:)**: Encodes a kernel into a command buffer, out of place.\n- **sourceRegion(destinationSize:)**: Determines the region of the source texture that will be read for an encode operation.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A block to make a copy of a source texture for filters that can only execute out of place.",
          "name" : "MPSCopyAllocator",
          "url" : "https:\/\/developer.apple.com\/documentation\/MetalPerformanceShaders\/MPSCopyAllocator"
        },
        {
          "description" : "",
          "name" : "encode(commandBuffer:sourceImage:destinationImage:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/MetalPerformanceShaders\/MPSUnaryImageKernel\/encode(commandBuffer:sourceImage:destinationImage:)"
        },
        {
          "description" : "Encodes a kernel into a command buffer, out of place.",
          "name" : "encode(commandBuffer:sourceTexture:destinationTexture:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/MetalPerformanceShaders\/MPSUnaryImageKernel\/encode(commandBuffer:sourceTexture:destinationTexture:)"
        },
        {
          "description" : "Determines the region of the source texture that will be read for an encode operation.",
          "name" : "sourceRegion(destinationSize:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/MetalPerformanceShaders\/MPSUnaryImageKernel\/sourceRegion(destinationSize:)"
        }
      ],
      "title" : "Methods"
    }
  ],
  "source" : "appleJSON",
  "title" : "encode(commandBuffer:inPlaceTexture:fallbackCopyAllocator:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/MetalPerformanceShaders\/MPSUnaryImageKernel\/encode(commandBuffer:inPlaceTexture:fallbackCopyAllocator:)"
}