{
  "abstract" : "Run a Linux operating system on your Mac using the Virtualization framework.",
  "codeExamples" : [
    {
      "code" : "% LinuxVirtualMachine <pathToKernelImage> <pathToRAMDiskImage>"
    },
    {
      "code" : "let configuration = VZVirtualMachineConfiguration()\nconfiguration.cpuCount = 2\nconfiguration.memorySize = 2 * 1024 * 1024 * 1024 \/\/ 2 GiB\nconfiguration.serialPorts = [ createConsoleConfiguration() ]\nconfiguration.bootLoader = createBootLoader(kernelURL: kernelURL, initialRamdiskURL: initialRamdiskURL)\n\ndo {\n    try configuration.validate()\n} catch {\n    print(\"Failed to validate the virtual machine configuration. \\(error)\")\n    exit(EXIT_FAILURE)\n}",
      "language" : "swift"
    },
    {
      "code" : "func createBootLoader(kernelURL: URL, initialRamdiskURL: URL) -> VZBootLoader {\n    let bootLoader = VZLinuxBootLoader(kernelURL: kernelURL)\n    bootLoader.initialRamdiskURL = initialRamdiskURL\n\n    let kernelCommandLineArguments = [\n        \/\/ Use the first virtio console device as system console.\n        \"console=hvc0\",\n        \/\/ Stop in the initial ramdisk before attempting to transition to the root file system.\n        \"rd.break=initqueue\"\n    ]\n\n    bootLoader.commandLine = kernelCommandLineArguments.joined(separator: \" \")\n\n    return bootLoader\n}",
      "language" : "swift"
    },
    {
      "code" : "func createConsoleConfiguration() -> VZSerialPortConfiguration {\n    let consoleConfiguration = VZVirtioConsoleDeviceSerialPortConfiguration()\n\n    let inputFileHandle = FileHandle.standardInput\n    let outputFileHandle = FileHandle.standardOutput\n\n    \/\/ Put stdin into raw mode, disabling local echo, input canonicalization,\n    \/\/ and CR-NL mapping.\n    var attributes = termios()\n    tcgetattr(inputFileHandle.fileDescriptor, &attributes)\n    attributes.c_iflag &= ~tcflag_t(ICRNL)\n    attributes.c_lflag &= ~tcflag_t(ICANON | ECHO)\n    tcsetattr(inputFileHandle.fileDescriptor, TCSANOW, &attributes)\n\n    let stdioAttachment = VZFileHandleSerialPortAttachment(fileHandleForReading: inputFileHandle,\n                                                           fileHandleForWriting: outputFileHandle)\n\n    consoleConfiguration.attachment = stdioAttachment\n\n    return consoleConfiguration\n}",
      "language" : "swift"
    },
    {
      "code" : "let virtualMachine = VZVirtualMachine(configuration: configuration)\n\nlet delegate = Delegate()\nvirtualMachine.delegate = delegate\n\nvirtualMachine.start { (result) in\n    if case let .failure(error) = result {\n        print(\"Failed to start the virtual machine. \\(error)\")\n        exit(EXIT_FAILURE)\n    }\n}\n\nRunLoop.main.run(until: Date.distantFuture)",
      "language" : "swift"
    }
  ],
  "contentHash" : "7eeb1fb5a70d8b8263d30f9bfea7929072fdc93dcdb82a1344d7ac7075d4ec12",
  "crawledAt" : "2025-12-02T15:51:40Z",
  "id" : "E28C5DB2-823C-408C-9A5C-E070C82254D6",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Virtualization",
  "overview" : "## Overview\n\nThis sample configures a virtual machine for a Linux-based operating system. You run the sample from the command line, and you specify the locations of the Linux kernel to run and initial RAM disk to load as command-line parameters. The sample configures the boot loader that the virtual machine requires to run the guest operating system, and it configures a console device to handle standard input and output. It then starts the virtual machine and exits when the Linux kernel shuts down.\n\n### Configure the Sample Code Project\n\nBefore you run the sample program:\n\nYou may obtain a kernel image and the corresponding initial RAM disk image for a given release of the Fedora Linux distribution from `https:\/\/download.fedoraproject.org\/pub\/fedora\/linux\/releases\/<release>\/Everything\/<architecture>\/os\/images\/pxeboot`, where `<release>` is the Fedora release number and `<architecture>` is `x86_64` for Intel Macs and `aarch64` for Apple silicon Macs.\n\nTo launch the virtual machine, run the sample’s executable from Xcode or in Terminal. You’ll need to specify the path to the kernel image and initial RAM disk image as parameters. The parameters are position-dependent, so use the following the order:\n\n### Configure the Boot Parameters for the Virtual Machine\n\nThe executable uses a [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachineConfiguration] object and adds some basic information. The sample configures the virtual machine to use two CPUs and 2 GB of RAM. It also configures a serial port using the custom `createConsoleConfiguration` function.\n\nIn addition to the resource allocations, the sample configures a [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZLinuxBootLoader] object with details about the Linux kernel to run in the virtual machine. The sample’s `createBootLoader` function configures the object using the kernel path and RAM-disk path you specified as command-line parameters. It also sets the object’s [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZLinuxBootLoader\/commandLine] property with additional information about how to use the RAM disk and console information. Finally, the sample validates the configuration.\n\n### Configure the Serial Port Device for Standard In and Out\n\nDuring the configuration process, the sample specifies the devices that the virtual machine makes available to the guest operating system. Device types can include network devices, virtual storage devices, sockets, and others.\n\nThe sample’s `createConsoleConfiguration` function configures a serial port device that the guest operating system uses for standard input and output. The function creates a [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtioConsoleDeviceSerialPortConfiguration] object, which the virtual machine uses to create a Virtio console device for the guest operating system. The [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZFileHandleSerialPortAttachment] object specifies information that the host operating system uses to configure the device. In this case, the attachment contains file handles for the host’s standard input and standard output. The sample configures the standard input in raw mode, which passes user input unmodified to the virtual machine.\n\n### Instantiate and Start the Virtual Machine\n\nAfter building the configuration data for the virtual machine, the sample uses the [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachine] object to start the execution of the guest operating system.\n\nBefore calling the virtual machine’s [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachine\/start(completionHandler:)] method, the sample configures a delegate object to receive messages about the state of the virtual machine. When the Linux operating system shuts down, the virtual machine calls the delegate’s [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachineDelegate\/guestDidStop(_:)] method. In response, the delegate method prints a message and exits the sample.\n\nThe [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachine\/start(completionHandler:)] method starts the virtual machine asynchronously in the background. The virtual machine loads the initial RAM disk and executes the Linux kernel. After the kernel loads, the user interacts with the Linux system using the sample program’s controlling terminal, because the `createConsoleConfiguration` attaches the virtual console to standard input and standard output.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Virtualization\/running-linux-in-a-virtual-machine\ncrawled: 2025-12-02T15:51:40Z\n---\n\n# Running Linux in a Virtual Machine\n\n**Sample Code**\n\nRun a Linux operating system on your Mac using the Virtualization framework.\n\n## Overview\n\nThis sample configures a virtual machine for a Linux-based operating system. You run the sample from the command line, and you specify the locations of the Linux kernel to run and initial RAM disk to load as command-line parameters. The sample configures the boot loader that the virtual machine requires to run the guest operating system, and it configures a console device to handle standard input and output. It then starts the virtual machine and exits when the Linux kernel shuts down.\n\n### Configure the Sample Code Project\n\nBefore you run the sample program:\n\n1. Download a Linux kernel image.\n2. Download an initial RAM disk image to load into memory.\n\n\n\nYou may obtain a kernel image and the corresponding initial RAM disk image for a given release of the Fedora Linux distribution from `https:\/\/download.fedoraproject.org\/pub\/fedora\/linux\/releases\/<release>\/Everything\/<architecture>\/os\/images\/pxeboot`, where `<release>` is the Fedora release number and `<architecture>` is `x86_64` for Intel Macs and `aarch64` for Apple silicon Macs.\n\nTo launch the virtual machine, run the sample’s executable from Xcode or in Terminal. You’ll need to specify the path to the kernel image and initial RAM disk image as parameters. The parameters are position-dependent, so use the following the order:\n\n```\n% LinuxVirtualMachine <pathToKernelImage> <pathToRAMDiskImage>\n```\n\n### Configure the Boot Parameters for the Virtual Machine\n\nThe executable uses a [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachineConfiguration] object and adds some basic information. The sample configures the virtual machine to use two CPUs and 2 GB of RAM. It also configures a serial port using the custom `createConsoleConfiguration` function.\n\n```swift\nlet configuration = VZVirtualMachineConfiguration()\nconfiguration.cpuCount = 2\nconfiguration.memorySize = 2 * 1024 * 1024 * 1024 \/\/ 2 GiB\nconfiguration.serialPorts = [ createConsoleConfiguration() ]\nconfiguration.bootLoader = createBootLoader(kernelURL: kernelURL, initialRamdiskURL: initialRamdiskURL)\n\ndo {\n    try configuration.validate()\n} catch {\n    print(\"Failed to validate the virtual machine configuration. \\(error)\")\n    exit(EXIT_FAILURE)\n}\n```\n\nIn addition to the resource allocations, the sample configures a [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZLinuxBootLoader] object with details about the Linux kernel to run in the virtual machine. The sample’s `createBootLoader` function configures the object using the kernel path and RAM-disk path you specified as command-line parameters. It also sets the object’s [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZLinuxBootLoader\/commandLine] property with additional information about how to use the RAM disk and console information. Finally, the sample validates the configuration.\n\n```swift\nfunc createBootLoader(kernelURL: URL, initialRamdiskURL: URL) -> VZBootLoader {\n    let bootLoader = VZLinuxBootLoader(kernelURL: kernelURL)\n    bootLoader.initialRamdiskURL = initialRamdiskURL\n\n    let kernelCommandLineArguments = [\n        \/\/ Use the first virtio console device as system console.\n        \"console=hvc0\",\n        \/\/ Stop in the initial ramdisk before attempting to transition to the root file system.\n        \"rd.break=initqueue\"\n    ]\n\n    bootLoader.commandLine = kernelCommandLineArguments.joined(separator: \" \")\n\n    return bootLoader\n}\n```\n\n### Configure the Serial Port Device for Standard In and Out\n\nDuring the configuration process, the sample specifies the devices that the virtual machine makes available to the guest operating system. Device types can include network devices, virtual storage devices, sockets, and others.\n\nThe sample’s `createConsoleConfiguration` function configures a serial port device that the guest operating system uses for standard input and output. The function creates a [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtioConsoleDeviceSerialPortConfiguration] object, which the virtual machine uses to create a Virtio console device for the guest operating system. The [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZFileHandleSerialPortAttachment] object specifies information that the host operating system uses to configure the device. In this case, the attachment contains file handles for the host’s standard input and standard output. The sample configures the standard input in raw mode, which passes user input unmodified to the virtual machine.\n\n```swift\nfunc createConsoleConfiguration() -> VZSerialPortConfiguration {\n    let consoleConfiguration = VZVirtioConsoleDeviceSerialPortConfiguration()\n\n    let inputFileHandle = FileHandle.standardInput\n    let outputFileHandle = FileHandle.standardOutput\n\n    \/\/ Put stdin into raw mode, disabling local echo, input canonicalization,\n    \/\/ and CR-NL mapping.\n    var attributes = termios()\n    tcgetattr(inputFileHandle.fileDescriptor, &attributes)\n    attributes.c_iflag &= ~tcflag_t(ICRNL)\n    attributes.c_lflag &= ~tcflag_t(ICANON | ECHO)\n    tcsetattr(inputFileHandle.fileDescriptor, TCSANOW, &attributes)\n\n    let stdioAttachment = VZFileHandleSerialPortAttachment(fileHandleForReading: inputFileHandle,\n                                                           fileHandleForWriting: outputFileHandle)\n\n    consoleConfiguration.attachment = stdioAttachment\n\n    return consoleConfiguration\n}\n```\n\n### Instantiate and Start the Virtual Machine\n\nAfter building the configuration data for the virtual machine, the sample uses the [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachine] object to start the execution of the guest operating system.\n\nBefore calling the virtual machine’s [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachine\/start(completionHandler:)] method, the sample configures a delegate object to receive messages about the state of the virtual machine. When the Linux operating system shuts down, the virtual machine calls the delegate’s [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachineDelegate\/guestDidStop(_:)] method. In response, the delegate method prints a message and exits the sample.\n\n```swift\nlet virtualMachine = VZVirtualMachine(configuration: configuration)\n\nlet delegate = Delegate()\nvirtualMachine.delegate = delegate\n\nvirtualMachine.start { (result) in\n    if case let .failure(error) = result {\n        print(\"Failed to start the virtual machine. \\(error)\")\n        exit(EXIT_FAILURE)\n    }\n}\n\nRunLoop.main.run(until: Date.distantFuture)\n```\n\nThe [doc:\/\/com.apple.virtualization\/documentation\/Virtualization\/VZVirtualMachine\/start(completionHandler:)] method starts the virtual machine asynchronously in the background. The virtual machine loads the initial RAM disk and executes the Linux kernel. After the kernel loads, the user interacts with the Linux system using the sample program’s controlling terminal, because the `createConsoleConfiguration` attaches the virtual console to standard input and standard output.\n\n## Virtual machine setup\n\n- **Running macOS in a virtual machine on Apple silicon**: Install and run macOS in a virtual machine using the Virtualization framework.\n- **Running GUI Linux in a virtual machine on a Mac**: Install and run GUI Linux in a virtual machine using the Virtualization framework.\n- **Installing macOS on a Virtual Machine**: Download a macOS restore image and install it in a new VM.\n- **Creating and Running a Linux Virtual Machine**: Design and run custom Linux guests on Apple silicon or Intel-based Mac Computers.\n- **Virtualize macOS on a Mac**: Configure and run macOS guests on Apple silicon.\n- **Virtualize Linux on a Mac**: Configure and run Linux guests on Apple silicon and Intel-based Mac computers.\n- **Running Intel Binaries in Linux VMs with Rosetta**: Run x86_64 Linux binaries under ARM Linux on Apple silicon.\n- **Accelerating the performance of Rosetta**: Improve Rosetta performance by adding support for the total store ordering (TSO) memory model to your Linux kernel.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Install and run macOS in a virtual machine using the Virtualization framework.",
          "name" : "Running macOS in a virtual machine on Apple silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/running-macos-in-a-virtual-machine-on-apple-silicon"
        },
        {
          "description" : "Install and run GUI Linux in a virtual machine using the Virtualization framework.",
          "name" : "Running GUI Linux in a virtual machine on a Mac",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/running-gui-linux-in-a-virtual-machine-on-a-mac"
        },
        {
          "description" : "Download a macOS restore image and install it in a new VM.",
          "name" : "Installing macOS on a Virtual Machine",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/installing-macos-on-a-virtual-machine"
        },
        {
          "description" : "Design and run custom Linux guests on Apple silicon or Intel-based Mac Computers.",
          "name" : "Creating and Running a Linux Virtual Machine",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/creating-and-running-a-linux-virtual-machine"
        },
        {
          "description" : "Configure and run macOS guests on Apple silicon.",
          "name" : "Virtualize macOS on a Mac",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/virtualize-macos-on-a-mac"
        },
        {
          "description" : "Configure and run Linux guests on Apple silicon and Intel-based Mac computers.",
          "name" : "Virtualize Linux on a Mac",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/virtualize-linux-on-a-mac"
        },
        {
          "description" : "Run x86_64 Linux binaries under ARM Linux on Apple silicon.",
          "name" : "Running Intel Binaries in Linux VMs with Rosetta",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/running-intel-binaries-in-linux-vms-with-rosetta"
        },
        {
          "description" : "Improve Rosetta performance by adding support for the total store ordering (TSO) memory model to your Linux kernel.",
          "name" : "Accelerating the performance of Rosetta",
          "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/accelerating-the-performance-of-rosetta"
        }
      ],
      "title" : "Virtual machine setup"
    }
  ],
  "source" : "appleJSON",
  "title" : "Running Linux in a Virtual Machine",
  "url" : "https:\/\/developer.apple.com\/documentation\/Virtualization\/running-linux-in-a-virtual-machine"
}