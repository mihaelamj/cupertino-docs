{
  "abstract" : "Display content options with document view controllers and fetch and populate content with TVMLKit JS.",
  "codeExamples" : [
    {
      "code" : "func appController(_ appController: TVApplicationController, didFinishLaunching options: [String: Any]?) {\n    \/\/ Specify the context for the initial document request.\n    let contextDictionary = [\"url\": \"templates\/Index.xml\"]\n    \/\/ This URL is sent over to application.js and is part of the request in App.onDocumentRequest\n    let documentController = TVDocumentViewController(context: contextDictionary, for: appController)\n    documentController.delegate = self\n    \/\/ Push it onto the navigation stack to start the loading of the document.\n    appController.navigationController.pushViewController(documentController, animated: false)\n}",
      "language" : "swift"
    },
    {
      "code" : "App.onDocumentRequest = (request, response) => {\n    if (request.requestType == \"document\") {\n        \/\/ Setup a document load to update the link.\n        new DocumentLoader(gHostController.getRemoteURL(request.url)).load((document, errorStr) => {\n            let processor = documentProcessor[request.url];\n            if (processor != null) {\n                processor(request, document);\n            }\n            response.document = document;\n            response.close(errorStr ? { 'errorStr' : errorStr } : null);\n        });\n    }\n    else {\n        response.close();\n    }\n};",
      "language" : "javascript"
    },
    {
      "code" : "let documentProcessor = {\n    \"templates\/Index.xml\": (request, document) => {\n        let data = {\n            movies : [\n                {\n                    artworkURL : gHostController.getRemoteURL('resources\/images\/square_1.jpg'),\n                    backgroundURL : gHostController.getRemoteURL('resources\/images\/product_bg_1.jpg'),\n                    logoURL : gHostController.getRemoteURL('resources\/images\/product_logo.png'),\n                    title : \"Movie Title\",\n                    theme : \"dark\",\n                    url : \"templates\/ProductSingle.xml\"\n                },\n                ...\n            ]\n        };\n        \/\/ Set on the template element.\n        let templateElement = document.getElementsByTagName('stackTemplate').item(0);\n        templateElement.dataItem = data;\n    },\n    \"templates\/ProductSingle.xml\": (request, document) => {\n        let extraInfo = request;\n        \/\/ Set data on the template element.\n        let templateElement = document.getElementsByTagName('stackTemplate').item(0);\n        templateElement.dataItem = extraInfo;\n    }\n}\n",
      "language" : "javascript"
    },
    {
      "code" : "<section binding=\"items:{movies};\">\n    <prototypes>\n        <lockup useBrowser=\"false\">\n            <img binding=\"@src:{artworkURL};\" contentsMode=\"aspectFill\" width=\"410\" height=\"231\"\/>\n            <title binding=\"textContent:{title};\" class=\"hidden_text\"\/>\n        <\/lockup>\n    <\/prototypes>                   \n<\/section>",
      "language" : "xml"
    },
    {
      "code" : "if event == .select {\n    if let useBrowser = element.attributes![\"useBrowser\"], useBrowser == \"true\" {\n        \/\/ Handle the select event that might lead to loading documents in a browser.\n        let superParent: TVViewElement? = element.parent?.parent?.name == \"shelf\" ? element.parent?.parent : nil\n        if let shelfElement = superParent, let browserController = TVBrowserViewController(viewElement: shelfElement) {\n            browserController.dataSource = self\n            appController.navigationController.pushViewController(browserController, animated: true)\n            handled = true\n        }\n    } else {\n        let documentController = TVDocumentViewController(context: element.elementData, for: appController)\n        documentController.delegate = self\n        appController.navigationController.pushViewController(documentController, animated: true)\n        handled = true\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "9424ca1166629a5af7d7aa99d88344704691cde406142a932fcfe8b3e3f121da",
  "crawledAt" : "2025-12-02T15:33:43Z",
  "id" : "2FB7E4EE-043A-4233-8527-6F1F5B29B8B2",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "TVMLKit",
  "overview" : "## Overview\n\nThis hybrid app consists of a server built with TVMLKit JS and a client built with TVMLKit. The app uses native TVMLKit Swift code to take content from the server and build the user interface on screen, and uses TVMLKit JS to provide the requested data.\n\nTraditionally, hybrid tvOS apps depend on TVMLKit JS to initialize view controllers, push view controllers to the navigation stack, and handle events, such as a selection or play event. This app demonstrates the stateless JavaScript design pattern, in which native TVMLKit, instead of TVMLKit JS, takes on these tasks.\n\nBecause the TV content resides in JavaScript in the server, the app uses `TVDocumentViewController` objects to allow TVMLKit to communicate with TVMLKit JS. TVMLKit JS is responsible for fetching data and populating the native UI. Building your app with the stateless model is useful if you want to use the functionalities provided by Swift or if you are more familiar with native development.\n\n### Configure the Sample Code Project\n\nThe sample relies on a running server containing JavaScript files, image assets, and templates that specify the app’s content. The app takes the content from the server and builds the user interface on screen. Before running the app, start the server as follows:\n\n### Create and Display a Document View Controller\n\nXML files provide the structure of a TVMLKit app. The files contain TVML elements such as [doc:\/\/com.apple.documentation\/documentation\/TVML\/button] and [doc:\/\/com.apple.documentation\/documentation\/TVML\/lockup], and lay out the elements on screen. In this app, the templates folder in the server directory contains two XML files: Index.xml, and ProductSingle.xml. These files contain the structure of the two primary views used in this app. Index.xml is responsible for providing the structure of the initial page, which consists of a grid of items to select. When the user selects an item from the main page, the ProductSingle.xml file displays the content for the selected item.\n\nAt launch time, create a `TVApplicationController` object in the `application(_:didFinishLaunching:)` method. That object provides the infrastructure your app needs to display content. You then use the app controller’s delegate method to specify the initial page’s content by creating a new `TVDocumentViewController` object.\n\nThe `TVDocumentViewController`‘s initializer accepts a context dictionary, which provides TVMLKit JS with a route to the new document’s data. It then pushes the `TVDocumentViewController` onto the app controller’s navigation stack. TVMLKit apps use this navigation controller to manage navigation between pages. When this method returns, TVMLKit builds the app’s UI from the Index.xml file. It then queries your server for the data needed to fill that structure.\n\nFor more information about how to build the structure of your app, see [doc:\/\/com.apple.documentation\/documentation\/TVML].\n\n### Fetch and Populate TV Content\n\nThe structure of the interface is empty until the TVMLKit JS provides the data for the TV content. When you create a `TVDocumentViewController` object in  `appController(_:didFinishLaunching:)`, TVMLKit determines that it needs data, which causes TVMLKit JS to trigger the `onDocumentRequest` event in `application.js`. This event creates a new `DocumentLoader` object, which grabs data from a `documentProcessor` based on the URL of the request. The URL of the request used is the context used to construct the `TVDocumentViewController` object (templates\/Index.xml).\n\nThe `documentProcessor`‘s `data` variable contains a dictionary of URLs mapped to JSON content. This JSON content includes an artwork URL, background URL, URL path, and other metadata. The app uses this JSON to fill in the UI structure from Index.xml with presentable content, including the images and titles associated with each lockup. To insert the data into the TVML template, the processor retrieves the initial template’s top level stack template, and sets its `dataItem` to the JSON data. This inserts the JSON into the template and maps the JSON content to the right variables.\n\nFor example, the processor passes its movies into the section’s binding attribute, populating four sections with the four movie elements. The sample fills in the image binding with the `{artworkURL}` from the data, as well as the `{title}` binding’s text content.\n\n### Handle Selection Events\n\nThe app triggers a selection event when the user selects a lockup. Because this app follows the stateless JavaScript model, you handle that selection event natively in the `documentViewController(_:handleEvent:with:)` method.\n\nWhen you trigger the `select` event on a lockup with the `useBrowser` attribute set to `true`, the app creates and pushes a `TVBrowserViewController` to the top of the navigation stack. When you trigger the `select` event on a lockup with the `useBrowser` attribute set to `false`, the app pushes a standard document conforming to the ProductSingle.xml template to the top of the navigation stack. After the app pushes the appropriate view, it will set the `handled` variable to `true` and return it. This signals that the app natively handled the event, and that it needs no more work on the JavaScript end.\n\nWhen TVMLKit determines that there are unpopulated views that need data, TVMLKit triggers the `onDocumentRequest` event to request data for that document. The app references a `documentProcessor` again, except this time it presents data that corresponds to the ProductSingle.xml template instead of the Index.xml template. This is because the URL from the lockup points to templates\/ProductSingle.xml. The new data populated into the ProductSingle template presents a full screen view with the selected image.\n\nTo learn more about the different `TVDocumentViewController` events, see [doc:\/\/com.apple.documentation\/documentation\/TVMLKit\/TVDocumentViewController\/Event].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/TVMLKit\/implementing-a-hybrid-tv-app-with-tvmlkit\ncrawled: 2025-12-02T15:33:43Z\n---\n\n# Implementing a Hybrid TV App with TVMLKit\n\n**Sample Code**\n\nDisplay content options with document view controllers and fetch and populate content with TVMLKit JS.\n\n## Overview\n\nThis hybrid app consists of a server built with TVMLKit JS and a client built with TVMLKit. The app uses native TVMLKit Swift code to take content from the server and build the user interface on screen, and uses TVMLKit JS to provide the requested data.\n\nTraditionally, hybrid tvOS apps depend on TVMLKit JS to initialize view controllers, push view controllers to the navigation stack, and handle events, such as a selection or play event. This app demonstrates the stateless JavaScript design pattern, in which native TVMLKit, instead of TVMLKit JS, takes on these tasks.\n\nBecause the TV content resides in JavaScript in the server, the app uses `TVDocumentViewController` objects to allow TVMLKit to communicate with TVMLKit JS. TVMLKit JS is responsible for fetching data and populating the native UI. Building your app with the stateless model is useful if you want to use the functionalities provided by Swift or if you are more familiar with native development.\n\n### Configure the Sample Code Project\n\nThe sample relies on a running server containing JavaScript files, image assets, and templates that specify the app’s content. The app takes the content from the server and builds the user interface on screen. Before running the app, start the server as follows:\n\n1. In Finder, navigate to this project’s folder.\n2. In Terminal, enter `cd`, followed by a space.\n3. Drag the Server folder from inside the Finder window into your Terminal window. Execute the `cd` command in terminal to change the directory to the Server folder.\n4. In Terminal, enter `ruby -run -ehttpd . -p9001` to start the server.\n5. Build and run the app.\n\n### Create and Display a Document View Controller\n\nXML files provide the structure of a TVMLKit app. The files contain TVML elements such as [doc:\/\/com.apple.documentation\/documentation\/TVML\/button] and [doc:\/\/com.apple.documentation\/documentation\/TVML\/lockup], and lay out the elements on screen. In this app, the templates folder in the server directory contains two XML files: Index.xml, and ProductSingle.xml. These files contain the structure of the two primary views used in this app. Index.xml is responsible for providing the structure of the initial page, which consists of a grid of items to select. When the user selects an item from the main page, the ProductSingle.xml file displays the content for the selected item.\n\nAt launch time, create a `TVApplicationController` object in the `application(_:didFinishLaunching:)` method. That object provides the infrastructure your app needs to display content. You then use the app controller’s delegate method to specify the initial page’s content by creating a new `TVDocumentViewController` object.\n\nThe `TVDocumentViewController`‘s initializer accepts a context dictionary, which provides TVMLKit JS with a route to the new document’s data. It then pushes the `TVDocumentViewController` onto the app controller’s navigation stack. TVMLKit apps use this navigation controller to manage navigation between pages. When this method returns, TVMLKit builds the app’s UI from the Index.xml file. It then queries your server for the data needed to fill that structure.\n\n```swift\nfunc appController(_ appController: TVApplicationController, didFinishLaunching options: [String: Any]?) {\n    \/\/ Specify the context for the initial document request.\n    let contextDictionary = [\"url\": \"templates\/Index.xml\"]\n    \/\/ This URL is sent over to application.js and is part of the request in App.onDocumentRequest\n    let documentController = TVDocumentViewController(context: contextDictionary, for: appController)\n    documentController.delegate = self\n    \/\/ Push it onto the navigation stack to start the loading of the document.\n    appController.navigationController.pushViewController(documentController, animated: false)\n}\n```\n\nFor more information about how to build the structure of your app, see [doc:\/\/com.apple.documentation\/documentation\/TVML].\n\n### Fetch and Populate TV Content\n\nThe structure of the interface is empty until the TVMLKit JS provides the data for the TV content. When you create a `TVDocumentViewController` object in  `appController(_:didFinishLaunching:)`, TVMLKit determines that it needs data, which causes TVMLKit JS to trigger the `onDocumentRequest` event in `application.js`. This event creates a new `DocumentLoader` object, which grabs data from a `documentProcessor` based on the URL of the request. The URL of the request used is the context used to construct the `TVDocumentViewController` object (templates\/Index.xml).\n\n```javascript\nApp.onDocumentRequest = (request, response) => {\n    if (request.requestType == \"document\") {\n        \/\/ Setup a document load to update the link.\n        new DocumentLoader(gHostController.getRemoteURL(request.url)).load((document, errorStr) => {\n            let processor = documentProcessor[request.url];\n            if (processor != null) {\n                processor(request, document);\n            }\n            response.document = document;\n            response.close(errorStr ? { 'errorStr' : errorStr } : null);\n        });\n    }\n    else {\n        response.close();\n    }\n};\n```\n\nThe `documentProcessor`‘s `data` variable contains a dictionary of URLs mapped to JSON content. This JSON content includes an artwork URL, background URL, URL path, and other metadata. The app uses this JSON to fill in the UI structure from Index.xml with presentable content, including the images and titles associated with each lockup. To insert the data into the TVML template, the processor retrieves the initial template’s top level stack template, and sets its `dataItem` to the JSON data. This inserts the JSON into the template and maps the JSON content to the right variables.\n\n```javascript\nlet documentProcessor = {\n    \"templates\/Index.xml\": (request, document) => {\n        let data = {\n            movies : [\n                {\n                    artworkURL : gHostController.getRemoteURL('resources\/images\/square_1.jpg'),\n                    backgroundURL : gHostController.getRemoteURL('resources\/images\/product_bg_1.jpg'),\n                    logoURL : gHostController.getRemoteURL('resources\/images\/product_logo.png'),\n                    title : \"Movie Title\",\n                    theme : \"dark\",\n                    url : \"templates\/ProductSingle.xml\"\n                },\n                ...\n            ]\n        };\n        \/\/ Set on the template element.\n        let templateElement = document.getElementsByTagName('stackTemplate').item(0);\n        templateElement.dataItem = data;\n    },\n    \"templates\/ProductSingle.xml\": (request, document) => {\n        let extraInfo = request;\n        \/\/ Set data on the template element.\n        let templateElement = document.getElementsByTagName('stackTemplate').item(0);\n        templateElement.dataItem = extraInfo;\n    }\n}\n\n```\n\nFor example, the processor passes its movies into the section’s binding attribute, populating four sections with the four movie elements. The sample fills in the image binding with the `{artworkURL}` from the data, as well as the `{title}` binding’s text content.\n\n```xml\n<section binding=\"items:{movies};\">\n    <prototypes>\n        <lockup useBrowser=\"false\">\n            <img binding=\"@src:{artworkURL};\" contentsMode=\"aspectFill\" width=\"410\" height=\"231\"\/>\n            <title binding=\"textContent:{title};\" class=\"hidden_text\"\/>\n        <\/lockup>\n    <\/prototypes>                   \n<\/section>\n```\n\n### Handle Selection Events\n\nThe app triggers a selection event when the user selects a lockup. Because this app follows the stateless JavaScript model, you handle that selection event natively in the `documentViewController(_:handleEvent:with:)` method.\n\nWhen you trigger the `select` event on a lockup with the `useBrowser` attribute set to `true`, the app creates and pushes a `TVBrowserViewController` to the top of the navigation stack. When you trigger the `select` event on a lockup with the `useBrowser` attribute set to `false`, the app pushes a standard document conforming to the ProductSingle.xml template to the top of the navigation stack. After the app pushes the appropriate view, it will set the `handled` variable to `true` and return it. This signals that the app natively handled the event, and that it needs no more work on the JavaScript end.\n\n```swift\nif event == .select {\n    if let useBrowser = element.attributes![\"useBrowser\"], useBrowser == \"true\" {\n        \/\/ Handle the select event that might lead to loading documents in a browser.\n        let superParent: TVViewElement? = element.parent?.parent?.name == \"shelf\" ? element.parent?.parent : nil\n        if let shelfElement = superParent, let browserController = TVBrowserViewController(viewElement: shelfElement) {\n            browserController.dataSource = self\n            appController.navigationController.pushViewController(browserController, animated: true)\n            handled = true\n        }\n    } else {\n        let documentController = TVDocumentViewController(context: element.elementData, for: appController)\n        documentController.delegate = self\n        appController.navigationController.pushViewController(documentController, animated: true)\n        handled = true\n    }\n}\n```\n\nWhen TVMLKit determines that there are unpopulated views that need data, TVMLKit triggers the `onDocumentRequest` event to request data for that document. The app references a `documentProcessor` again, except this time it presents data that corresponds to the ProductSingle.xml template instead of the Index.xml template. This is because the URL from the lockup points to templates\/ProductSingle.xml. The new data populated into the ProductSingle template presents a full screen view with the selected image.\n\nTo learn more about the different `TVDocumentViewController` events, see [doc:\/\/com.apple.documentation\/documentation\/TVMLKit\/TVDocumentViewController\/Event].\n\n## JavaScript Environment\n\n- **TVApplicationController**: An object that bridges the UI, navigation stack, storage, and event handling from JavaScript.\n- **TVApplicationControllerContext**: Launch information provided to the TV application controller.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object that bridges the UI, navigation stack, storage, and event handling from JavaScript.",
          "name" : "TVApplicationController",
          "url" : "https:\/\/developer.apple.com\/documentation\/TVMLKit\/TVApplicationController"
        },
        {
          "description" : "Launch information provided to the TV application controller.",
          "name" : "TVApplicationControllerContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/TVMLKit\/TVApplicationControllerContext"
        }
      ],
      "title" : "JavaScript Environment"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing a Hybrid TV App with TVMLKit",
  "url" : "https:\/\/developer.apple.com\/documentation\/TVMLKit\/implementing-a-hybrid-tv-app-with-tvmlkit"
}