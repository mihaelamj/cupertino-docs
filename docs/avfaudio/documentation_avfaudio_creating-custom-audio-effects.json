{
  "abstract" : "Add custom audio-effect processing to apps like Logic Pro X and GarageBand by creating Audio Unit (AU) plug-ins.",
  "codeExamples" : [
    {
      "code" : "extension AUv3FilterDemoViewController: AUAudioUnitFactory {\n    public func createAudioUnit(with componentDescription: AudioComponentDescription) throws -> AUAudioUnit {\n        audioUnit = try AUv3FilterDemo(componentDescription: componentDescription, options: [])\n        return audioUnit!\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private enum AUv3FilterParam: AUParameterAddress {\n    case cutoff, resonance\n}\n\n\/\/\/ The parameter to control the cutoff frequency (12 Hz - 20 kHz).\nvar cutoffParam: AUParameter = {\n    let parameter =\n        AUParameterTree.createParameter(withIdentifier: \"cutoff\",\n                                        name: \"Cutoff\",\n                                        address: AUv3FilterParam.cutoff.rawValue,\n                                        min: 12.0,\n                                        max: 20_000.0,\n                                        unit: .hertz,\n                                        unitName: nil,\n                                        flags: [.flag_IsReadable,\n                                                .flag_IsWritable,\n                                                .flag_CanRamp],\n                                        valueStrings: nil,\n                                        dependentParameters: nil)\n    \/\/ Set default value\n    parameter.value = 0.0\n\n    return parameter\n}()\n\n\/\/\/ The parameter to control the cutoff frequency's resonance (+\/-20 dB).\nvar resonanceParam: AUParameter = {\n    let parameter =\n        AUParameterTree.createParameter(withIdentifier: \"resonance\",\n                                        name: \"Resonance\",\n                                        address: AUv3FilterParam.resonance.rawValue,\n                                        min: -20.0,\n                                        max: 20.0,\n                                        unit: .decibels,\n                                        unitName: nil,\n                                        flags: [.flag_IsReadable,\n                                                .flag_IsWritable,\n                                                .flag_CanRamp],\n                                        valueStrings: nil,\n                                        dependentParameters: nil)\n    \/\/ Set the default value.\n    parameter.value = 20_000.0\n\n    return parameter\n}()",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create the audio unit's tree of parameters.\nparameterTree = AUParameterTree.createTree(withChildren: [cutoffParam,\n                                                          resonanceParam])",
      "language" : "swift"
    },
    {
      "code" : "\/\/ A closure for observing all externally generated parameter value changes.\nparameterTree.implementorValueObserver = { param, value in\n    kernelAdapter.setParameter(param, value: value)\n}\n\n\/\/ A closure for returning state of the requested parameter.\nparameterTree.implementorValueProvider = { param in\n    return kernelAdapter.value(for: param)\n}\n\n\/\/ A closure for returning the string representation of the requested parameter value.\nparameterTree.implementorStringFromValueCallback = { param, value in\n    switch param.address {\n    case AUv3FilterParam.cutoff.rawValue:\n        return String(format: \"%.f\", value ?? param.value)\n    case AUv3FilterParam.resonance.rawValue:\n        return String(format: \"%.2f\", value ?? param.value)\n    default:\n        return \"?\"\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func connectViewToAU() {\n    guard needsConnection, let paramTree = audioUnit?.parameterTree else { return }\n\n    \/\/ Find the cutoff and resonance parameters in the parameter tree.\n    guard let cutoff = paramTree.value(forKey: \"cutoff\") as? AUParameter,\n        let resonance = paramTree.value(forKey: \"resonance\") as? AUParameter else {\n            fatalError(\"Required AU parameters not found.\")\n    }\n\n    \/\/ Set the instance variables.\n    cutoffParameter = cutoff\n    resonanceParameter = resonance\n\n    \/\/ Observe major state changes like a user selecting a user preset.\n    observer = audioUnit?.observe(\\.allParameterValues) { object, change in\n        DispatchQueue.main.async {\n            self.updateUI()\n        }\n    }\n\n    \/\/ Observe value changes to the cutoff and resonance parameters.\n    parameterObserverToken =\n        paramTree.token(byAddingParameterObserver: { [weak self] address, value in\n            guard let self = self else { return }\n\n            \/\/ An arbitrary queue is calling this closure. Ensure\n            \/\/ all UI updates dispatch back to the main thread.\n            if [cutoff.address, resonance.address].contains(address) {\n                DispatchQueue.main.async {\n                    self.updateUI()\n                }\n            }\n        })\n\n    \/\/ Indicate the view and the audio unit have a connection.\n    needsConnection = false\n\n    \/\/ Sync the UI with the parameter state.\n    updateUI()\n}",
      "language" : "swift"
    },
    {
      "code" : "public override var factoryPresets: [AUAudioUnitPreset] {\n    return [\n        AUAudioUnitPreset(number: 0, name: \"Prominent\"),\n        AUAudioUnitPreset(number: 1, name: \"Bright\"),\n        AUAudioUnitPreset(number: 2, name: \"Warm\")\n    ]\n}\n\nprivate let factoryPresetValues:[(cutoff: AUValue, resonance: AUValue)] = [\n    (2500.0, 5.0),    \/\/ \"Prominent\"\n    (14_000.0, 12.0), \/\/ \"Bright\"\n    (384.0, -3.0)     \/\/ \"Warm\"\n]",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Indicates that this audio unit supports persisting user presets.\npublic override var supportsUserPresets: Bool {\n    return true\n}",
      "language" : "swift"
    },
    {
      "code" : "private var _currentPreset: AUAudioUnitPreset?\n\n\/\/\/ The currently selected preset.\npublic override var currentPreset: AUAudioUnitPreset? {\n    get { return _currentPreset }\n    set {\n        \/\/ If the newValue is nil, return.\n        guard let preset = newValue else {\n            _currentPreset = nil\n            return\n        }\n        \n        \/\/ Factory presets need to always have a number >= 0.\n        if preset.number >= 0 {\n            let values = factoryPresetValues[preset.number]\n            parameters!.setParameterValues(cutoff: values.cutoff, resonance: values.resonance)\n            _currentPreset = preset\n        }\n        \/\/ User presets are always negative.\n        else {\n            \/\/ Attempt to restore the archived state for this user preset.\n            do {\n                fullStateForDocument = try presetState(for: preset)\n                \/\/ Set the currentPreset after successfully restoring the state.\n                _currentPreset = preset\n            } catch {\n                print(\"Unable to restore set for preset \\(preset.name)\")\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import AUv3FilterFramework\n\nfunc placeholder() {\n    \/\/ This placeholder function ensures the extension loads correctly.\n}",
      "language" : "swift"
    },
    {
      "code" : "<key>NSExtension<\/key>\n<dict>\n    <key>NSExtensionAttributes<\/key>\n    <dict>\n        <key>AudioComponentBundle<\/key>\n        <string>com.example.apple-samplecode.AUv3FilterFramework<\/string>\n        ...\n    <\/dict>\n    ...\n<\/dict>"
    },
    {
      "code" : "public override init(nibName: NSNib.Name?, bundle: Bundle?) {\n    \/\/ Pass a reference to the owning framework bundle.\n    super.init(nibName: nibName, bundle: Bundle(for: type(of: self)))\n}",
      "language" : "swift"
    },
    {
      "code" : "<key>NSExtension<\/key>\n<dict>\n    <key>NSExtensionPrincipalClass<\/key>\n    <string>AUv3FilterFramework.AUv3FilterDemoViewController<\/string>\n    ...\n<\/dict>"
    }
  ],
  "contentHash" : "de003b69996c7abbcee5d3644ff5de79bd92b709cec054439c5784a6c2baddc2",
  "crawledAt" : "2025-12-02T15:47:43Z",
  "id" : "75ED2A89-E7E0-46AF-9D69-E713770F85DA",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "AVFAudio",
  "overview" : "## Overview\n\nThis sample app shows you how to create a custom audio effect plug-in using the latest Audio Unit standard (AUv3). The AUv3 standard builds on the [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/ExtensibilityPG] model, which means you deliver your plug-in as an extension that’s contained in an app distributed through the App Store or your own store.\n\nThe sample Audio Unit is a low-pass filter that allows frequencies at or below the cutoff frequency to pass through to the output. It attenuates frequencies above this point. It also lets you change the filter’s resonance, which boosts or attenuates a narrow band of frequencies around the cutoff point. You set these values by moving the draggable point around the plug-in’s user interface, as shown in the figure below.\n\n\n\nThe project has targets for both iOS and macOS. Each platform’s main app target has two supporting targets: `AUv3FilterExtension`, which contains the plug-in packaged as an Audio Unit extension, and `AUv3FilterFramework`, which bundles the plug-in’s code and resources.\n\n### Create a Custom Audio Effect Plug-In\n\nThe extension itself contains two primary pieces: an Audio Unit proper and a factory object that creates it.\n\nThe sample app’s Audio Unit is `AUv3FilterDemo`. This is a Swift class that subclasses [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit] and defines the plug-in’s interface, including key features like its parameters, presets, and I\/O busses. A class called `FilterDSPKernel` provides the plug-in’s digital signal processing (DSP) logic, and is written in C++ to ensure real-time safety. Because Swift can’t talk directly to C++, the sample project also includes an Objective-C++ adapter class called `FilterDSPKernelAdapter` to act as an intermediary.\n\n`AUv3FilterDemoViewController` is the Audio Unit’s main view controller. It adopts the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnitFactory] protocol and is responsible for creating new instances of your plug-in. You implement the protocol’s [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnitFactory\/createAudioUnit(with:)] factory method to return a new instance of `AUv3FilterDemo` when a host app requests it.\n\n### Add Custom Parameters to Your Audio Unit\n\nIn most Audio Units, you’ll provide one or more parameters to configure the audio processing. Your Audio Unit arranges its parameters into a tree structure, provided by an instance of [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterTree]. This object represents the root node of the plug-in’s tree of parameters and parameter groupings.\n\n`AUv3FilterDemo` has parameters to control the filter’s cutoff frequency and resonance. You create its parameters using a factory method on `AUParameterTree`.\n\nThe cutoff parameter defines a frequency range between 12 Hz and 20 kHz, and the resonance parameter defines a decibel range between -20 dB and 20 dB. Each parameter is readable and writeable, and also supports ramping, which means you can modify its value over time.\n\nYou arrange the parameters into a tree by creating an `AUParameterTree` instance and setting them as the tree’s children.\n\nNext, you bind handlers to the parameter tree’s readable and writeable values by installing closures for its [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterNode\/implementorValueObserver], [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterNode\/implementorValueProvider], and [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterNode\/implementorStringFromValueCallback] properties. These closures delegate to the filter adapter instance, which in turn communicates with the underlying DSP logic.\n\n### Connect the Parameters to Your User Interface\n\nThe sample app’s iOS and macOS targets each provide a platform-specific user interface. You use a shared view controller called `AUv3FilterDemoViewController` to coordinate the communication between the user interface and the Audio Unit. Connect your user interface to the Audio Unit’s parameters in the `connectViewToAU()` method.\n\nAs shown above, in the `connectViewToAU()` method, you find the Audio Unit’s parameter tree and retrieve its cutoff and resonance parameters. You also add an observer closure to update the user interface as the plug-in’s parameter values change.\n\n### Add Factory Presets\n\nMost audio plug-ins provide a collection of preset values known as *factory presets*. A factory preset is a preconfigured arrangement of the plug-in’s parameter values that provide a useful starting point for further customization. A host app presents these presets in its user interface so the user can select them.\n\nThe following code example shows how to define the factory presets and their associated values.\n\n### Support User Presets\n\nFactory presets provide a useful starting point for further user customization, but users also want the ability to save their changes and create their own custom presets. `AUAudioUnit` provides built-in support for user presets. To enable this support in your Audio Unit, override the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/supportsUserPresets] property to return `true`.\n\nOpting in to support for user presets automatically enables your Audio Unit to load, save, and delete user presets. The default implementation of the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/userPresets], [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/saveUserPreset(_:)], and [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/deleteUserPreset(_:)] API reads from and writes to an internal store, but you’re free to override this property and methods if you want to directly manage the persistence behavior. For example, you can override the default behavior to persist user presets to an iCloud container or some other remote location.\n\n### Select Factory and User Presets\n\nA host app selects a factory or user preset by setting the plug-in’s `currentPreset` property. You override this property and take the appropriate action depending on the preset type selected. If the user selected a factory preset (a preset `number` greater than `0`), look up its associated values and set the parameter values accordingly. If the user selected a user preset (a preset `number` less than `0`), restore the preset’s parameter state by calling the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/presetState(for:)] method and setting the returned data as the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/fullStateForDocument] property.\n\n### Package Your Plug-In to Run In-Process\n\nLike all App Extensions, AUv3 plug-ins run *out-of-process* by default, which means the extension runs in a separate process from the host app, and all communication between the two occurs over interprocess communication (IPC). This model provides increased security and stability for the host app. For example, if an AUv3 plug-in crashes, the host app won’t crash. However, the IPC communication adds a small amount of overhead to each render cycle, which may be unacceptable depending on the needs of a given application. In macOS only, you can package your plug-in to run *in-process*, which eliminates the IPC communication as your Audio Unit runs as part of the host’s process.\n\nRunning an in-process plug-in requires an agreement between the host and the Audio Unit. The host requests in-process instantiation by passing the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AudioComponentInstantiationOptions\/loadInProcess] option during the plug-in’s creation, and you need to package your Audio Unit as described and shown below.\n\nYour extension’s main binary can’t be dynamically loaded into another app, which means all executable code needs to reside in a separate framework bundle. However, the extension target still needs to contain at least one source file for the extension binary to be created, properly loaded, and linked with the framework bundle. To ensure the extension is created, add some unused placeholder code in your extension target, like that found in `AUv3FilterExtension.swift`.\n\nThe macOS sample packages all of the Audio Unit’s code into the `AUv3FilterFramework` target. You indicate that the extension’s code exists in a separate bundle by adding an `AudioComponentBundle` extension attribute to the target’s `Info.plist` file.\n\nIf you’re using a xib or Storyboard for your user interface, override your view controller’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSViewController\/init(nibName:bundle:)] initializer and pass the framework bundle to the superclass initializer. This ensures your user interface properly loads when the system requests your Audio Unit extension.\n\nFinally, in the extension’s `Info.plist` file, set the Audio Unit’s factory object, `AUv3FilterDemoViewController`, as the extension’s principal class.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AVFAudio\/creating-custom-audio-effects\ncrawled: 2025-12-02T15:47:43Z\n---\n\n# Creating custom audio effects\n\n**Sample Code**\n\nAdd custom audio-effect processing to apps like Logic Pro X and GarageBand by creating Audio Unit (AU) plug-ins.\n\n## Overview\n\nThis sample app shows you how to create a custom audio effect plug-in using the latest Audio Unit standard (AUv3). The AUv3 standard builds on the [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/ExtensibilityPG] model, which means you deliver your plug-in as an extension that’s contained in an app distributed through the App Store or your own store.\n\nThe sample Audio Unit is a low-pass filter that allows frequencies at or below the cutoff frequency to pass through to the output. It attenuates frequencies above this point. It also lets you change the filter’s resonance, which boosts or attenuates a narrow band of frequencies around the cutoff point. You set these values by moving the draggable point around the plug-in’s user interface, as shown in the figure below.\n\n\n\nThe project has targets for both iOS and macOS. Each platform’s main app target has two supporting targets: `AUv3FilterExtension`, which contains the plug-in packaged as an Audio Unit extension, and `AUv3FilterFramework`, which bundles the plug-in’s code and resources.\n\n\n\n### Create a Custom Audio Effect Plug-In\n\nThe extension itself contains two primary pieces: an Audio Unit proper and a factory object that creates it.\n\nThe sample app’s Audio Unit is `AUv3FilterDemo`. This is a Swift class that subclasses [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit] and defines the plug-in’s interface, including key features like its parameters, presets, and I\/O busses. A class called `FilterDSPKernel` provides the plug-in’s digital signal processing (DSP) logic, and is written in C++ to ensure real-time safety. Because Swift can’t talk directly to C++, the sample project also includes an Objective-C++ adapter class called `FilterDSPKernelAdapter` to act as an intermediary.\n\n`AUv3FilterDemoViewController` is the Audio Unit’s main view controller. It adopts the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnitFactory] protocol and is responsible for creating new instances of your plug-in. You implement the protocol’s [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnitFactory\/createAudioUnit(with:)] factory method to return a new instance of `AUv3FilterDemo` when a host app requests it.\n\n```swift\nextension AUv3FilterDemoViewController: AUAudioUnitFactory {\n    public func createAudioUnit(with componentDescription: AudioComponentDescription) throws -> AUAudioUnit {\n        audioUnit = try AUv3FilterDemo(componentDescription: componentDescription, options: [])\n        return audioUnit!\n    }\n}\n```\n\n\n\n### Add Custom Parameters to Your Audio Unit\n\nIn most Audio Units, you’ll provide one or more parameters to configure the audio processing. Your Audio Unit arranges its parameters into a tree structure, provided by an instance of [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterTree]. This object represents the root node of the plug-in’s tree of parameters and parameter groupings.\n\n`AUv3FilterDemo` has parameters to control the filter’s cutoff frequency and resonance. You create its parameters using a factory method on `AUParameterTree`.\n\n```swift\nprivate enum AUv3FilterParam: AUParameterAddress {\n    case cutoff, resonance\n}\n\n\/\/\/ The parameter to control the cutoff frequency (12 Hz - 20 kHz).\nvar cutoffParam: AUParameter = {\n    let parameter =\n        AUParameterTree.createParameter(withIdentifier: \"cutoff\",\n                                        name: \"Cutoff\",\n                                        address: AUv3FilterParam.cutoff.rawValue,\n                                        min: 12.0,\n                                        max: 20_000.0,\n                                        unit: .hertz,\n                                        unitName: nil,\n                                        flags: [.flag_IsReadable,\n                                                .flag_IsWritable,\n                                                .flag_CanRamp],\n                                        valueStrings: nil,\n                                        dependentParameters: nil)\n    \/\/ Set default value\n    parameter.value = 0.0\n\n    return parameter\n}()\n\n\/\/\/ The parameter to control the cutoff frequency's resonance (+\/-20 dB).\nvar resonanceParam: AUParameter = {\n    let parameter =\n        AUParameterTree.createParameter(withIdentifier: \"resonance\",\n                                        name: \"Resonance\",\n                                        address: AUv3FilterParam.resonance.rawValue,\n                                        min: -20.0,\n                                        max: 20.0,\n                                        unit: .decibels,\n                                        unitName: nil,\n                                        flags: [.flag_IsReadable,\n                                                .flag_IsWritable,\n                                                .flag_CanRamp],\n                                        valueStrings: nil,\n                                        dependentParameters: nil)\n    \/\/ Set the default value.\n    parameter.value = 20_000.0\n\n    return parameter\n}()\n```\n\nThe cutoff parameter defines a frequency range between 12 Hz and 20 kHz, and the resonance parameter defines a decibel range between -20 dB and 20 dB. Each parameter is readable and writeable, and also supports ramping, which means you can modify its value over time.\n\nYou arrange the parameters into a tree by creating an `AUParameterTree` instance and setting them as the tree’s children.\n\n```swift\n\/\/ Create the audio unit's tree of parameters.\nparameterTree = AUParameterTree.createTree(withChildren: [cutoffParam,\n                                                          resonanceParam])\n```\n\nNext, you bind handlers to the parameter tree’s readable and writeable values by installing closures for its [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterNode\/implementorValueObserver], [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterNode\/implementorValueProvider], and [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUParameterNode\/implementorStringFromValueCallback] properties. These closures delegate to the filter adapter instance, which in turn communicates with the underlying DSP logic.\n\n```swift\n\/\/ A closure for observing all externally generated parameter value changes.\nparameterTree.implementorValueObserver = { param, value in\n    kernelAdapter.setParameter(param, value: value)\n}\n\n\/\/ A closure for returning state of the requested parameter.\nparameterTree.implementorValueProvider = { param in\n    return kernelAdapter.value(for: param)\n}\n\n\/\/ A closure for returning the string representation of the requested parameter value.\nparameterTree.implementorStringFromValueCallback = { param, value in\n    switch param.address {\n    case AUv3FilterParam.cutoff.rawValue:\n        return String(format: \"%.f\", value ?? param.value)\n    case AUv3FilterParam.resonance.rawValue:\n        return String(format: \"%.2f\", value ?? param.value)\n    default:\n        return \"?\"\n    }\n}\n```\n\n### Connect the Parameters to Your User Interface\n\nThe sample app’s iOS and macOS targets each provide a platform-specific user interface. You use a shared view controller called `AUv3FilterDemoViewController` to coordinate the communication between the user interface and the Audio Unit. Connect your user interface to the Audio Unit’s parameters in the `connectViewToAU()` method.\n\n```swift\nprivate func connectViewToAU() {\n    guard needsConnection, let paramTree = audioUnit?.parameterTree else { return }\n\n    \/\/ Find the cutoff and resonance parameters in the parameter tree.\n    guard let cutoff = paramTree.value(forKey: \"cutoff\") as? AUParameter,\n        let resonance = paramTree.value(forKey: \"resonance\") as? AUParameter else {\n            fatalError(\"Required AU parameters not found.\")\n    }\n\n    \/\/ Set the instance variables.\n    cutoffParameter = cutoff\n    resonanceParameter = resonance\n\n    \/\/ Observe major state changes like a user selecting a user preset.\n    observer = audioUnit?.observe(\\.allParameterValues) { object, change in\n        DispatchQueue.main.async {\n            self.updateUI()\n        }\n    }\n\n    \/\/ Observe value changes to the cutoff and resonance parameters.\n    parameterObserverToken =\n        paramTree.token(byAddingParameterObserver: { [weak self] address, value in\n            guard let self = self else { return }\n\n            \/\/ An arbitrary queue is calling this closure. Ensure\n            \/\/ all UI updates dispatch back to the main thread.\n            if [cutoff.address, resonance.address].contains(address) {\n                DispatchQueue.main.async {\n                    self.updateUI()\n                }\n            }\n        })\n\n    \/\/ Indicate the view and the audio unit have a connection.\n    needsConnection = false\n\n    \/\/ Sync the UI with the parameter state.\n    updateUI()\n}\n```\n\nAs shown above, in the `connectViewToAU()` method, you find the Audio Unit’s parameter tree and retrieve its cutoff and resonance parameters. You also add an observer closure to update the user interface as the plug-in’s parameter values change.\n\n### Add Factory Presets\n\nMost audio plug-ins provide a collection of preset values known as *factory presets*. A factory preset is a preconfigured arrangement of the plug-in’s parameter values that provide a useful starting point for further customization. A host app presents these presets in its user interface so the user can select them.\n\nThe following code example shows how to define the factory presets and their associated values.\n\n```swift\npublic override var factoryPresets: [AUAudioUnitPreset] {\n    return [\n        AUAudioUnitPreset(number: 0, name: \"Prominent\"),\n        AUAudioUnitPreset(number: 1, name: \"Bright\"),\n        AUAudioUnitPreset(number: 2, name: \"Warm\")\n    ]\n}\n\nprivate let factoryPresetValues:[(cutoff: AUValue, resonance: AUValue)] = [\n    (2500.0, 5.0),    \/\/ \"Prominent\"\n    (14_000.0, 12.0), \/\/ \"Bright\"\n    (384.0, -3.0)     \/\/ \"Warm\"\n]\n```\n\n### Support User Presets\n\nFactory presets provide a useful starting point for further user customization, but users also want the ability to save their changes and create their own custom presets. `AUAudioUnit` provides built-in support for user presets. To enable this support in your Audio Unit, override the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/supportsUserPresets] property to return `true`.\n\n```swift\n\/\/\/ Indicates that this audio unit supports persisting user presets.\npublic override var supportsUserPresets: Bool {\n    return true\n}\n```\n\nOpting in to support for user presets automatically enables your Audio Unit to load, save, and delete user presets. The default implementation of the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/userPresets], [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/saveUserPreset(_:)], and [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/deleteUserPreset(_:)] API reads from and writes to an internal store, but you’re free to override this property and methods if you want to directly manage the persistence behavior. For example, you can override the default behavior to persist user presets to an iCloud container or some other remote location.\n\n### Select Factory and User Presets\n\nA host app selects a factory or user preset by setting the plug-in’s `currentPreset` property. You override this property and take the appropriate action depending on the preset type selected. If the user selected a factory preset (a preset `number` greater than `0`), look up its associated values and set the parameter values accordingly. If the user selected a user preset (a preset `number` less than `0`), restore the preset’s parameter state by calling the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/presetState(for:)] method and setting the returned data as the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit\/fullStateForDocument] property.\n\n```swift\nprivate var _currentPreset: AUAudioUnitPreset?\n\n\/\/\/ The currently selected preset.\npublic override var currentPreset: AUAudioUnitPreset? {\n    get { return _currentPreset }\n    set {\n        \/\/ If the newValue is nil, return.\n        guard let preset = newValue else {\n            _currentPreset = nil\n            return\n        }\n        \n        \/\/ Factory presets need to always have a number >= 0.\n        if preset.number >= 0 {\n            let values = factoryPresetValues[preset.number]\n            parameters!.setParameterValues(cutoff: values.cutoff, resonance: values.resonance)\n            _currentPreset = preset\n        }\n        \/\/ User presets are always negative.\n        else {\n            \/\/ Attempt to restore the archived state for this user preset.\n            do {\n                fullStateForDocument = try presetState(for: preset)\n                \/\/ Set the currentPreset after successfully restoring the state.\n                _currentPreset = preset\n            } catch {\n                print(\"Unable to restore set for preset \\(preset.name)\")\n            }\n        }\n    }\n}\n```\n\n### Package Your Plug-In to Run In-Process\n\nLike all App Extensions, AUv3 plug-ins run *out-of-process* by default, which means the extension runs in a separate process from the host app, and all communication between the two occurs over interprocess communication (IPC). This model provides increased security and stability for the host app. For example, if an AUv3 plug-in crashes, the host app won’t crash. However, the IPC communication adds a small amount of overhead to each render cycle, which may be unacceptable depending on the needs of a given application. In macOS only, you can package your plug-in to run *in-process*, which eliminates the IPC communication as your Audio Unit runs as part of the host’s process.\n\nRunning an in-process plug-in requires an agreement between the host and the Audio Unit. The host requests in-process instantiation by passing the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AudioComponentInstantiationOptions\/loadInProcess] option during the plug-in’s creation, and you need to package your Audio Unit as described and shown below.\n\nYour extension’s main binary can’t be dynamically loaded into another app, which means all executable code needs to reside in a separate framework bundle. However, the extension target still needs to contain at least one source file for the extension binary to be created, properly loaded, and linked with the framework bundle. To ensure the extension is created, add some unused placeholder code in your extension target, like that found in `AUv3FilterExtension.swift`.\n\n```swift\nimport AUv3FilterFramework\n\nfunc placeholder() {\n    \/\/ This placeholder function ensures the extension loads correctly.\n}\n```\n\nThe macOS sample packages all of the Audio Unit’s code into the `AUv3FilterFramework` target. You indicate that the extension’s code exists in a separate bundle by adding an `AudioComponentBundle` extension attribute to the target’s `Info.plist` file.\n\n```\n<key>NSExtension<\/key>\n<dict>\n    <key>NSExtensionAttributes<\/key>\n    <dict>\n        <key>AudioComponentBundle<\/key>\n        <string>com.example.apple-samplecode.AUv3FilterFramework<\/string>\n        ...\n    <\/dict>\n    ...\n<\/dict>\n```\n\nIf you’re using a xib or Storyboard for your user interface, override your view controller’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSViewController\/init(nibName:bundle:)] initializer and pass the framework bundle to the superclass initializer. This ensures your user interface properly loads when the system requests your Audio Unit extension.\n\n```swift\npublic override init(nibName: NSNib.Name?, bundle: Bundle?) {\n    \/\/ Pass a reference to the owning framework bundle.\n    super.init(nibName: nibName, bundle: Bundle(for: type(of: self)))\n}\n```\n\nFinally, in the extension’s `Info.plist` file, set the Audio Unit’s factory object, `AUv3FilterDemoViewController`, as the extension’s principal class.\n\n```\n<key>NSExtension<\/key>\n<dict>\n    <key>NSExtensionPrincipalClass<\/key>\n    <string>AUv3FilterFramework.AUv3FilterDemoViewController<\/string>\n    ...\n<\/dict>\n```\n\n\n\n## Effects\n\n- **Audio Units**: The data type for a plug-in component that provides audio processing or audio data generation.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The data type for a plug-in component that provides audio processing or audio data generation.",
          "name" : "Audio Units",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFAudio\/audio-units"
        }
      ],
      "title" : "Effects"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating custom audio effects",
  "url" : "https:\/\/developer.apple.com\/documentation\/AVFAudio\/creating-custom-audio-effects"
}