{
  "abstract" : "Verify the contents of app receipts by decoding and parsing the receipt on the device.",
  "codeExamples" : [
    {
      "code" : "ReceiptModule DEFINITIONS ::=\nBEGIN\n\nReceiptAttribute ::= SEQUENCE {\n    type    INTEGER,\n    version INTEGER,\n    value   OCTET STRING\n}\n\nPayload ::= SET OF ReceiptAttribute\n\nEND",
      "language" : "other"
    },
    {
      "code" : "import IOKit\nimport Foundation\n\n\/\/ Returns an object with a +1 retain count; the caller needs to release.\nfunc io_service(named name: String, wantBuiltIn: Bool) -> io_service_t? {\n    let default_port = kIOMasterPortDefault\n    var iterator = io_iterator_t()\n    defer {\n        if iterator != IO_OBJECT_NULL {\n            IOObjectRelease(iterator)\n        }\n    }\n\n    guard let matchingDict = IOBSDNameMatching(default_port, 0, name),\n        IOServiceGetMatchingServices(default_port,\n                                     matchingDict as CFDictionary,\n                                     &iterator) == KERN_SUCCESS,\n        iterator != IO_OBJECT_NULL\n    else {\n        return nil\n    }\n\n    var candidate = IOIteratorNext(iterator)\n    while candidate != IO_OBJECT_NULL {\n        if let cftype = IORegistryEntryCreateCFProperty(candidate,\n                                                        \"IOBuiltin\" as CFString,\n                                                        kCFAllocatorDefault,\n                                                        0) {\n            let isBuiltIn = cftype.takeRetainedValue() as! CFBoolean\n            if wantBuiltIn == CFBooleanGetValue(isBuiltIn) {\n                return candidate\n            }\n        }\n\n        IOObjectRelease(candidate)\n        candidate = IOIteratorNext(iterator)\n    }\n\n    return nil\n}\n\nfunc copy_mac_address() -> CFData? {\n    \/\/ Prefer built-in network interfaces.\n    \/\/ For example, an external Ethernet adaptor can displace\n    \/\/ the built-in Wi-Fi as en0.\n    guard let service = io_service(named: \"en0\", wantBuiltIn: true)\n            ?? io_service(named: \"en1\", wantBuiltIn: true)\n            ?? io_service(named: \"en0\", wantBuiltIn: false)\n        else { return nil }\n    defer { IOObjectRelease(service) }\n\n    if let cftype = IORegistryEntrySearchCFProperty(\n        service,\n        kIOServicePlane,\n        \"IOMACAddress\" as CFString,\n        kCFAllocatorDefault,\n        IOOptionBits(kIORegistryIterateRecursively | kIORegistryIterateParents)) {\n            return (cftype as! CFData)\n    }\n\n    return nil\n}",
      "language" : "swift"
    },
    {
      "code" : "#import <Foundation\/Foundation.h>\n#import <IOKit\/network\/IONetworkLib.h>\n\nio_service_t io_service(const char *name, BOOL wantBuiltIn) {\n    io_iterator_t iterator = IO_OBJECT_NULL;\n    mach_port_t default_port = kIOMasterPortDefault;\n    io_service_t service = IO_OBJECT_NULL;\n\n    if (KERN_SUCCESS != IOMasterPort(MACH_PORT_NULL, &default_port)) {\n        return IO_OBJECT_NULL;\n    }\n\n    CFMutableDictionaryRef matchingDict = IOBSDNameMatching(default_port,\n                                                            0,\n                                                            name);\n    if (matchingDict == NULL) {\n        return IO_OBJECT_NULL;\n    }\n\n    if (KERN_SUCCESS != IOServiceGetMatchingServices(default_port,\n                                                     matchingDict,\n                                                     &iterator)) {\n        return IO_OBJECT_NULL;\n    }\n\n    if (iterator != IO_OBJECT_NULL) {\n        io_service_t candidate = IOIteratorNext(iterator);\n        while (candidate != IO_OBJECT_NULL) {\n            CFTypeRef isBuiltIn =\n            IORegistryEntryCreateCFProperty(candidate,\n                                            CFSTR(kIOBuiltin),\n                                            kCFAllocatorDefault,\n                                            0);\n            if (isBuiltIn != NULL && CFGetTypeID(isBuiltIn) == CFBooleanGetTypeID()) {\n                if (wantBuiltIn == CFBooleanGetValue(isBuiltIn)) {\n                    service = candidate;\n                    break;\n                }\n            }\n\n            IOObjectRelease(candidate);\n            candidate = IOIteratorNext(iterator);\n        }\n        IOObjectRelease(iterator);\n    }\n\n    return service;\n}\n\nCFDataRef copy_mac_address() {\n    CFDataRef macAddress = NULL;\n    io_service_t service = io_service(\"en0\", true);\n\n    if (service == IO_OBJECT_NULL) {\n        service = io_service(\"en1\", true);\n    }\n\n    if (service == IO_OBJECT_NULL) {\n        service = io_service(\"en0\", false);\n    }\n\n    if (service != IO_OBJECT_NULL) {\n        CFTypeRef property =\n        IORegistryEntrySearchCFProperty(service,\n                                        kIOServicePlane,\n                                        CFSTR(kIOMACAddress),\n                                        kCFAllocatorDefault,\n                                        kIORegistryIterateRecursively | kIORegistryIterateParents);\n        if (property != NULL) {\n            if (CFGetTypeID(property) == CFDataGetTypeID()) {\n                macAddress = property;\n            }\n            else {\n                CFRelease(property);\n            }\n        }\n\n        IOObjectRelease(service);\n    }\n\n    return macAddress;\n}",
      "language" : "objc"
    }
  ],
  "contentHash" : "b8134784d4f5ee615af5f567d7974490c6b93693e3fca724b70eb1a9e9006e23",
  "crawledAt" : "2025-12-04T03:02:52Z",
  "id" : "C0B4DB17-F827-4733-9771-706A2B70D1AB",
  "kind" : "article",
  "language" : "data",
  "module" : "App Store Receipts",
  "overview" : "## Overview\n\nWhen users install apps from the App Store, the app contains a cryptographically signed receipt that Apple creates and stores inside the app bundle, which you can then validate.\n\nValidating the receipt locally requires you to develop or use code to read and decode the receipt as a PKCS #7 container, as defined by [https:\/\/www.rfc-editor.org\/rfc\/rfc2315]. The App Store encodes the payload of the container using Abstract Syntax Notation One (ASN.1), as defined by [https:\/\/www.itu.int\/rec\/T-REC-X.690\/]. The payload contains a set of receipt attributes. Each receipt attribute contains a type, a version, and a value.\n\nThe App Store defines the structure of the payload with the following ASN.1 notation:\n\n### Validate the receipt\n\nIn macOS and Mac apps built with Mac Catalyst, implement receipt validation in the main function, before the app calls [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationMain(_:_:)].\n\nTo validate the app receipt, perform the following tests in order:\n\nThe validation passes if all of the tests pass. If any test fails, the validation fails.\n\nFor information about the keys in a receipt, see [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1].\n\n### Verify the certificate chain of trust\n\nDecode the app receipt as a PKCS #7 container and verify that the chain of trust for the container’s signature traces back to the Apple Inc. Root certificate, available from [https:\/\/www.apple.com\/certificateauthority\/].\n\nMake sure your app uses the date from the `receipt_creation_date` field, identified as [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1], to validate the receipt’s signature. Many cryptographic libraries default to using the device’s current time and date when validating a PKCS #7 package, but this may not produce the correct results when validating a receipt’s signature. For example, if the receipt was signed with a valid certificate, but the certificate has since expired, using the device’s current date incorrectly returns an invalid result.\n\n### Compute the SHA-1 hash\n\nCompute the SHA-1 hash to match the local device with the device hash inside the App Store reciept. When computing the SHA-1 hash, use the platform-specific data source. The source of bytes for each platform is:\n\nThe following two code examples illustrate how to retrieve an identifier in macOS, as the `copy_mac_address` function shows, for validating an App Store receipt.\n\nIn the following Swift code, the `io_service` function uses [doc:\/\/com.apple.documentation\/documentation\/iokit] to retrieve network interfaces as an optional [doc:\/\/com.apple.documentation\/documentation\/iokit] object. The `copy_mac_address` function looks up an appropriate network interface and returns the hardware address from the [doc:\/\/com.apple.documentation\/documentation\/iokit] object as optional `CFData`.\n\nThe following Objective-C code works in the same fashion. This example uses [doc:\/\/com.apple.documentation\/documentation\/iokit] to look up the relevant network interface, and returns the bytes that identify the built-in network interface:\n\n### Respond to validation failures\n\nIf your app receipt validation fails, respond to that failure as follows:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AppStoreReceipts\/validating-receipts-on-the-device\ncrawled: 2025-12-04T03:02:52Z\n---\n\n# Validating receipts on the device\n\n**Article**\n\nVerify the contents of app receipts by decoding and parsing the receipt on the device.\n\n## Overview\n\nWhen users install apps from the App Store, the app contains a cryptographically signed receipt that Apple creates and stores inside the app bundle, which you can then validate.\n\n\n\nValidating the receipt locally requires you to develop or use code to read and decode the receipt as a PKCS #7 container, as defined by [https:\/\/www.rfc-editor.org\/rfc\/rfc2315]. The App Store encodes the payload of the container using Abstract Syntax Notation One (ASN.1), as defined by [https:\/\/www.itu.int\/rec\/T-REC-X.690\/]. The payload contains a set of receipt attributes. Each receipt attribute contains a type, a version, and a value.\n\nThe App Store defines the structure of the payload with the following ASN.1 notation:\n\n```other\nReceiptModule DEFINITIONS ::=\nBEGIN\n\nReceiptAttribute ::= SEQUENCE {\n    type    INTEGER,\n    version INTEGER,\n    value   OCTET STRING\n}\n\nPayload ::= SET OF ReceiptAttribute\n\nEND\n```\n\n### Validate the receipt\n\nIn macOS and Mac apps built with Mac Catalyst, implement receipt validation in the main function, before the app calls [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationMain(_:_:)].\n\nTo validate the app receipt, perform the following tests in order:\n\n1. Locate and load the app receipt from the app’s bundle. The class [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Bundle] provides the location of the receipt with the property [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Bundle\/appStoreReceiptURL].\n2. Decode the app receipt as a PKCS #7 container and verify that the chain of trust for the container’s signature traces back to the Apple Inc. Root certificate, available from [https:\/\/www.apple.com\/certificateauthority\/]. Use the `receipt_creation_date`, identified as [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1] when validating the receipt signature.\n3. Verify that the bundle identifier, identified as [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1], matches your app’s bundle identifier.\n4. Verify that the version identifier string, identified as [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1], matches the version string in your app’s bundle.\n5. Compute a SHA-1 hash for the device that installs the app and verify that it matches the receipt’s hash, identified as [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1].\n\nThe validation passes if all of the tests pass. If any test fails, the validation fails.\n\nFor information about the keys in a receipt, see [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1].\n\n### Verify the certificate chain of trust\n\nDecode the app receipt as a PKCS #7 container and verify that the chain of trust for the container’s signature traces back to the Apple Inc. Root certificate, available from [https:\/\/www.apple.com\/certificateauthority\/].\n\n\n\nMake sure your app uses the date from the `receipt_creation_date` field, identified as [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/General\/ValidateAppStoreReceipt\/Chapters\/ReceiptFields.html#\/\/apple_ref\/doc\/uid\/TP40010573-CH106-SW1], to validate the receipt’s signature. Many cryptographic libraries default to using the device’s current time and date when validating a PKCS #7 package, but this may not produce the correct results when validating a receipt’s signature. For example, if the receipt was signed with a valid certificate, but the certificate has since expired, using the device’s current date incorrectly returns an invalid result.\n\n### Compute the SHA-1 hash\n\nCompute the SHA-1 hash to match the local device with the device hash inside the App Store reciept. When computing the SHA-1 hash, use the platform-specific data source. The source of bytes for each platform is:\n\n- watchOS: Use the raw bytes from the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UUID\/uuid] property of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UUID] that [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKInterfaceDevice\/identifierForVendor] provides.\n- iOS, iPadOS, tvOS, and iOS apps running on a Mac with Apple silicon: Use the raw bytes from the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UUID\/uuid] property of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UUID] that [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIDevice\/identifierForVendor] provides.\n- macOS and apps built with Mac Catalyst: Use the data that returns from `copy_mac_address` from the example code below.\n\nThe following two code examples illustrate how to retrieve an identifier in macOS, as the `copy_mac_address` function shows, for validating an App Store receipt.\n\nIn the following Swift code, the `io_service` function uses [doc:\/\/com.apple.documentation\/documentation\/iokit] to retrieve network interfaces as an optional [doc:\/\/com.apple.documentation\/documentation\/iokit] object. The `copy_mac_address` function looks up an appropriate network interface and returns the hardware address from the [doc:\/\/com.apple.documentation\/documentation\/iokit] object as optional `CFData`.\n\n```swift\nimport IOKit\nimport Foundation\n\n\/\/ Returns an object with a +1 retain count; the caller needs to release.\nfunc io_service(named name: String, wantBuiltIn: Bool) -> io_service_t? {\n    let default_port = kIOMasterPortDefault\n    var iterator = io_iterator_t()\n    defer {\n        if iterator != IO_OBJECT_NULL {\n            IOObjectRelease(iterator)\n        }\n    }\n\n    guard let matchingDict = IOBSDNameMatching(default_port, 0, name),\n        IOServiceGetMatchingServices(default_port,\n                                     matchingDict as CFDictionary,\n                                     &iterator) == KERN_SUCCESS,\n        iterator != IO_OBJECT_NULL\n    else {\n        return nil\n    }\n\n    var candidate = IOIteratorNext(iterator)\n    while candidate != IO_OBJECT_NULL {\n        if let cftype = IORegistryEntryCreateCFProperty(candidate,\n                                                        \"IOBuiltin\" as CFString,\n                                                        kCFAllocatorDefault,\n                                                        0) {\n            let isBuiltIn = cftype.takeRetainedValue() as! CFBoolean\n            if wantBuiltIn == CFBooleanGetValue(isBuiltIn) {\n                return candidate\n            }\n        }\n\n        IOObjectRelease(candidate)\n        candidate = IOIteratorNext(iterator)\n    }\n\n    return nil\n}\n\nfunc copy_mac_address() -> CFData? {\n    \/\/ Prefer built-in network interfaces.\n    \/\/ For example, an external Ethernet adaptor can displace\n    \/\/ the built-in Wi-Fi as en0.\n    guard let service = io_service(named: \"en0\", wantBuiltIn: true)\n            ?? io_service(named: \"en1\", wantBuiltIn: true)\n            ?? io_service(named: \"en0\", wantBuiltIn: false)\n        else { return nil }\n    defer { IOObjectRelease(service) }\n\n    if let cftype = IORegistryEntrySearchCFProperty(\n        service,\n        kIOServicePlane,\n        \"IOMACAddress\" as CFString,\n        kCFAllocatorDefault,\n        IOOptionBits(kIORegistryIterateRecursively | kIORegistryIterateParents)) {\n            return (cftype as! CFData)\n    }\n\n    return nil\n}\n```\n\nThe following Objective-C code works in the same fashion. This example uses [doc:\/\/com.apple.documentation\/documentation\/iokit] to look up the relevant network interface, and returns the bytes that identify the built-in network interface:\n\n```objc\n#import <Foundation\/Foundation.h>\n#import <IOKit\/network\/IONetworkLib.h>\n\nio_service_t io_service(const char *name, BOOL wantBuiltIn) {\n    io_iterator_t iterator = IO_OBJECT_NULL;\n    mach_port_t default_port = kIOMasterPortDefault;\n    io_service_t service = IO_OBJECT_NULL;\n\n    if (KERN_SUCCESS != IOMasterPort(MACH_PORT_NULL, &default_port)) {\n        return IO_OBJECT_NULL;\n    }\n\n    CFMutableDictionaryRef matchingDict = IOBSDNameMatching(default_port,\n                                                            0,\n                                                            name);\n    if (matchingDict == NULL) {\n        return IO_OBJECT_NULL;\n    }\n\n    if (KERN_SUCCESS != IOServiceGetMatchingServices(default_port,\n                                                     matchingDict,\n                                                     &iterator)) {\n        return IO_OBJECT_NULL;\n    }\n\n    if (iterator != IO_OBJECT_NULL) {\n        io_service_t candidate = IOIteratorNext(iterator);\n        while (candidate != IO_OBJECT_NULL) {\n            CFTypeRef isBuiltIn =\n            IORegistryEntryCreateCFProperty(candidate,\n                                            CFSTR(kIOBuiltin),\n                                            kCFAllocatorDefault,\n                                            0);\n            if (isBuiltIn != NULL && CFGetTypeID(isBuiltIn) == CFBooleanGetTypeID()) {\n                if (wantBuiltIn == CFBooleanGetValue(isBuiltIn)) {\n                    service = candidate;\n                    break;\n                }\n            }\n\n            IOObjectRelease(candidate);\n            candidate = IOIteratorNext(iterator);\n        }\n        IOObjectRelease(iterator);\n    }\n\n    return service;\n}\n\nCFDataRef copy_mac_address() {\n    CFDataRef macAddress = NULL;\n    io_service_t service = io_service(\"en0\", true);\n\n    if (service == IO_OBJECT_NULL) {\n        service = io_service(\"en1\", true);\n    }\n\n    if (service == IO_OBJECT_NULL) {\n        service = io_service(\"en0\", false);\n    }\n\n    if (service != IO_OBJECT_NULL) {\n        CFTypeRef property =\n        IORegistryEntrySearchCFProperty(service,\n                                        kIOServicePlane,\n                                        CFSTR(kIOMACAddress),\n                                        kCFAllocatorDefault,\n                                        kIORegistryIterateRecursively | kIORegistryIterateParents);\n        if (property != NULL) {\n            if (CFGetTypeID(property) == CFDataGetTypeID()) {\n                macAddress = property;\n            }\n            else {\n                CFRelease(property);\n            }\n        }\n\n        IOObjectRelease(service);\n    }\n\n    return macAddress;\n}\n```\n\n### Respond to validation failures\n\nIf your app receipt validation fails, respond to that failure as follows:\n\n- Don’t try to terminate the app. Without a validated receipt, assume the user doesn’t have access to premium content. Provide a user interface to gracefully handle this case and inform the user what they can do to get full access to your app’s features.\n- If the app receipt is missing or corrupt, use the [doc:\/\/com.apple.documentation\/documentation\/StoreKit\/SKReceiptRefreshRequest] object to refresh the app receipt.\n- In the sandbox environment, if the app receipt is missing, assume the tester is a new customer and doesn’t have access to premium content.\n\n\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Validating receipts on the device",
  "url" : "https:\/\/developer.apple.com\/documentation\/AppStoreReceipts\/validating-receipts-on-the-device"
}