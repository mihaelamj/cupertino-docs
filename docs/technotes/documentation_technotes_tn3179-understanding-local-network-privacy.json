{
  "abstract" : "Learn how local network privacy affects your software.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Attempts to trigger the local network privacy alert.\n\/\/\/ \n\/\/\/ This builds a list of link-local IPv6 addresses and then creates a connected\n\/\/\/ UDP socket to each in turn.  Connecting a UDP socket triggers the local\n\/\/\/ network alert without actually sending any traffic.\n\/\/\/ \n\/\/\/ This is a ‘best effort’ approach, and it handles errors by ignoring them.\n\/\/\/ There’s no guarantee that it’ll actually trigger the alert (FB8711182).\n\nfunc triggerLocalNetworkPrivacyAlert() {\n    let addresses = selectedLinkLocalIPv6Addresses()\n    for address in addresses {\n        let sock6 = socket(AF_INET6, SOCK_DGRAM, 0)\n        guard sock6 >= 0 else { return }\n        defer { close(sock6) }\n\n        withUnsafePointer(to: address) { sa6 in\n            sa6.withMemoryRebound(to: sockaddr.self, capacity: 1) { sa in\n                _ = connect(sock6, sa, socklen_t(sa.pointee.sa_len)) >= 0\n            }\n        }\n    }\n}\n\n\/\/\/ Returns a selection of IPv6 addresses to connect to.\n\/\/\/\n\/\/\/ To build this list it:\n\/\/\/\n\/\/\/ 1. Finds the IPv6 address of every broadcast-capable interface.\n\/\/\/\n\/\/\/ 2. Filters out all the ones that aren’t link-local.\n\/\/\/\n\/\/\/ 3. Sets the port number to port 9, that is, the discard service.  Even\n\/\/\/    though the caller won’t actually send any traffic, this ensures that it\n\/\/\/    would be discarded if it were sent.\n\/\/\/\n\/\/\/ 4. Creates two copies of each address, and replaces the host part with a\n\/\/\/    random number.\n\nprivate func selectedLinkLocalIPv6Addresses() -> [sockaddr_in6]\n{\n    let r1 = (0..<8).map { _ in UInt8.random(in: 0...255) }\n    let r2 = (0..<8).map { _ in UInt8.random(in: 0...255) }\n    return Array(ipv6AddressesOfBroadcastCapableInterfaces()\n        .filter { isIPv6AddressLinkLocal($0) }\n        .map { var addr = $0 ; addr.sin6_port = UInt16(9).bigEndian ; return addr }\n        .map { [setIPv6LinkLocalAddressHostPart(of: $0, to: r1), setIPv6LinkLocalAddressHostPart(of: $0, to: r2)] }\n        .joined())\n}\n\n\/\/\/ Replaces the host part of an IPv6 link-local address with the supplied\n\/\/\/ value.\n\/\/\/\n\/\/\/ In this context, _host part_ refers to the bottom 64-bits of the address,\n\/\/\/ that is, the `interface ID` as defined in Section 2.5.6 of [RFC\n\/\/\/ 4291](https:\/\/tools.ietf.org\/html\/rfc4291)).  Thus, the host part parameter\n\/\/\/ must be exactly 8 bytes.\n\nprivate func setIPv6LinkLocalAddressHostPart(of address: sockaddr_in6, to hostPart: [UInt8]) -> sockaddr_in6 {\n    precondition(hostPart.count == 8)\n    var result = address\n    withUnsafeMutableBytes(of: &result.sin6_addr) { buf in\n        buf[8...].copyBytes(from: hostPart)\n    }\n    return result\n}\n\n\/\/\/ Returns whether the supplied IPv6 address is link-local.\n\/\/\/\n\/\/\/ Link-local address have the fe:c0\/10 prefix.\n\nprivate func isIPv6AddressLinkLocal(_ address: sockaddr_in6) -> Bool {\n    address.sin6_addr.__u6_addr.__u6_addr8.0 == 0xfe\n        && (address.sin6_addr.__u6_addr.__u6_addr8.1 & 0xc0) == 0x80\n}\n\n\/\/\/ Returns the IPv6 address of every broadcast-capable interface.\n\nprivate func ipv6AddressesOfBroadcastCapableInterfaces() -> [sockaddr_in6] {\n    var addrList: UnsafeMutablePointer<ifaddrs>? = nil\n    let err = getifaddrs(&addrList)\n    guard err == 0, let start = addrList else { return [] }\n    defer { freeifaddrs(start) }\n    return sequence(first: start, next: { $0.pointee.ifa_next })\n        .compactMap { i -> sockaddr_in6? in\n            guard\n                (i.pointee.ifa_flags & UInt32(bitPattern: IFF_BROADCAST)) != 0,\n                let sa = i.pointee.ifa_addr,\n                sa.pointee.sa_family == AF_INET6,\n                sa.pointee.sa_len >= MemoryLayout<sockaddr_in6>.size\n            else { return nil }\n            return UnsafeRawPointer(sa).load(as: sockaddr_in6.self)\n        }\n}",
      "language" : "swift"
    },
    {
      "code" : " browser.stateUpdateHandler = { state in\n    switch state {\n    case .waiting(let error):\n        switch error {\n        case .dns(let code):\n            switch Int(code) {\n            case kDNSServiceErr_PolicyDenied:\n                … no local network access …\n            …\n            }\n        …\n        }\n    …\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let connection: NWConnection = … your existing logic …\nconnection.stateUpdateHandler = { state in\n    switch state {\n    case .waiting(_):\n        if case .localNetworkDenied? = connection.currentPath?.unsatisfiedReason {\n            … no local network access …\n        }\n    … other states …\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "b4aa8e291ed3f71634dd9785aa5c15d884ed5e9648fc7920304de625f15643fb",
  "crawledAt" : "2025-12-05T10:31:41Z",
  "id" : "07436220-28CC-4BC0-85DB-8F96D0D8B350",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nLocal network privacy puts people in control of which programs can interact with devices on their network.  The first time a program accesses the local network, the system displays an alert asking the user to approve that access.  The system records their decision, so future accesses don’t prompt.\n\nTo learn more, see:\n\nUsers configure local network privacy in Settings > Privacy & Security > Local Network (System Settings on macOS).  The OS adds an app to this list after it attempts to access a local network.\n\nDevice managers aren’t able to configure local network privacy using MDM.\n\nThe following platforms support local network privacy:\n\nLocal network privacy works the same on iOS, iPadOS, and visionOS.  Unless otherwise noted, assume that any info about iOS applies to all three platforms.  See [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#iOS-considerations] for information specific to these three platforms.\n\nLocal network privacy on macOS shares all of the same core concepts, but there are platform-specific differences.  See [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#macOS-considerations] for more on this.\n\n## Essentials\n\nLocal network privacy regulates your program’s ability to perform local network operations.  If your program has local network access, the system allows the operation.  If not, the system blocks it.\n\nIn most cases, the user controls local network access by way of the Local Network privilege.  This has three states:\n\nYour program starts in the undetermined state.  The first time it performs a local network operation, the system presents the local network alert.  The user chooses to either allow or deny the access.  The system records the user’s choice and applies it to subsequent operations.  The user can change this state at any time in Settings.\n\nIf your app accesses the local network, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] property to its `Info.plist` to explain its behavior to the user.\n\nIf your app allows people to enter an arbitrary network address, consider what happens if they enter a local network address.  For example, if you’re building an email client, check that it behaves correctly when the email server is on a local network.\n\nIf your app’s local network usage involves registering or browsing for specific Bonjour services, add a list of service types to the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property in your app’s `Info.plist`.  For more information about the Bonjour operations that require this, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#Bonjour-operations] below.\n\nAdditionally, if your iOS app performs multicast operations, sign it with the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.networking.multicast] entitlement.  For information about what constitutes a multicast operation, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#Multicast-operations] below.  If you use Xcode’s automatic code signing, use the [doc:\/\/com.apple.documentation\/documentation\/Xcode\/capabilities] editor to enable this capability.  If not, see [https:\/\/developer.apple.com\/help\/account\/reference\/provisioning-with-managed-capabilities].\n\nIf you’re building an app extension, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#App-extension-considerations].\n\nIf you’re building some other sort of program for macOS—a `launchd` daemon or agent, a system extension, and so on—see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#macOS-considerations].\n\nIf the system presents a local network alert in response to one of your local network operations, it may deny the operation immediately, before the user has responded to the alert.  To handle this smoothly, use an API that supports waiting for connectivity, like Network framework or `URLSession` with [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionConfiguration\/waitsForConnectivity] enabled.  If you can’t use one of these preferred APIs, add appropriate retry logic.\n\nFor an overview of the networking APIs on Apple platforms, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api].\n\n## Local network operations\n\nA local network is an IP network associated with a broadcast-capable network interface.  Such interfaces include Wi-Fi and Ethernet, but not cellular (WWAN) or VPN.  A local network address is any address on a local network.  Traffic to a local network address goes directly; it’s not forwarded by a router.\n\nIn addition, all multicast addresses (224.0.0.0\/4, ff00::\/8) and the IPv4 broadcast address (255.255.255.255) are local network addresses.\n\nOutgoing traffic to a local network address requires local network access.  The following table lists some common cases:\n\nThe system implements these TCP and UDP checks deep in the networking stack, and thus they apply to all networking APIs.  This includes [doc:\/\/com.apple.documentation\/documentation\/Network] framework, BSD Sockets, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/url-loading-system], and any APIs implemented on top of those.\n\nNote these exceptions to the rules above:\n\n## DNS operations\n\nCertain DNS operations also require local network access.  The following table lists some common cases:\n\nThis check applies to a wide variety of APIs including [doc:\/\/com.apple.documentation\/documentation\/dnssd], `<net_db.h>`, and any APIs that use them.\n\nIn this context, a local DNS name is one ending with `.local` (or `.local.`), per [https:\/\/tools.ietf.org\/html\/rfc6762].\n\nAdditionally, Bonjour operations require local network access, as described in the next section.\n\n## Bonjour operations\n\nAll Bonjour operations require local network access.\n\nThese checks apply to all APIs that use Bonjour, including [doc:\/\/com.apple.documentation\/documentation\/dnssd], [doc:\/\/com.apple.documentation\/documentation\/Network] framework, and Multipeer Connectivity.\n\nHigh-level services that use Bonjour internally don’t require local network access.  That’s because these services isolate your app from any details about the local network.  Such services include:\n\nSome specific Bonjour operations require the multicast entitlement as well.   See the next section for the details.\n\n## Multicast operations\n\nSending or receiving multicast or broadcast traffic is a local network operation on all platforms, as described in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#Local-network-operations].  However, iOS puts additional restrictions on these operations.  To send or receive multicast or broadcast traffic, sign your app with the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.networking.multicast] entitlement.\n\nThe following table lists some common cases.\n\nSome uncommon Bonjour operations also require the multicast entitlement.\n\nFor information on how to browse for all advertised service types using a `_services._dns-sd._udp.local.` query, see QA1337 [https:\/\/developer.apple.com\/library\/archive\/qa\/qa1337\/_index.html].\n\n## Multipeer Connectivity considerations\n\n[doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity] uses Bonjour internally.  If your app uses Multipeer Connectivity, follow all the Bonjour guidance in this technote.\n\nSpecifically, list your Multipeer Connectivity service type in the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property.  To format that entry, take your Multipeer Connectivity service type and add a leading underscore (`_`) and a trailing `._tcp`.  For example, if you pass `waffle-varnish` to the `serviceType` parameter of [doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity\/MCAdvertiserAssistant\/init(serviceType:discoveryInfo:session:)], add `_waffle-varnish._tcp` to the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property.\n\n## App extension considerations\n\nIn general, app extensions share the Local Network privilege state of their container app.\n\nSome app extension types are assumed to be running in the background.  If such an extension performs a local network operation while its Local Network privilege is undetermined, the system denies that operation as it would for an iOS app running in the background.  For more on that, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#iOS-considerations].\n\nNetwork Extension packet tunnel provider, app proxy provider, and DNS proxy provider app extensions have local network access regardless of the Local Network privilege state of their container app.\n\nIf your app has app extensions, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] and [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] properties to the app’s `Info.plist`, not to the app extension’s.\n\n## iOS considerations\n\nIf an iOS app is in the background and performs a local network operation while its Local Network privilege is undetermined, the system denies that operation without presenting the local network alert.  The system doesn’t record that decision.  If, later on, the app performs a local network operation while in the foreground, the system presents the alert to the user as if this were the first local network operation.\n\nApp Clips can’t perform local network operations.  See [doc:\/\/com.apple.documentation\/documentation\/AppClip\/choosing-the-right-functionality-for-your-app-clip].\n\nThe simulator doesn’t support local network privacy.  Test your local network privacy behavior on a real device.\n\nOn Shared iPad, all users share the same local network privacy state.\n\nIt *is* possible for your app to trigger the local network alert when the device is “off Wi-Fi”, that is, when there’s no Wi-Fi symbol in the status bar.  An easy way to demonstrate this is to perform a Bonjour operation with peer-to-peer Wi-Fi enabled, but there lots of other ways this can happen.\n\nThe above is true regardless of whether the device has cellular networking or not.\n\nFor more information about peer-to-peer Wi-Fi, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api].\n\niOS 18 has a bug (FB14321888) that can cause the in-memory and persistent state of local network privacy to get out of sync after changing the user preference multiple times.  This bug was fixed in iOS 18.6.  If you encounter unexpected behavior on iOS 18, update to iOS 18.6 or later.\n\n## macOS considerations\n\nmacOS maintains separate local network privacy state for each user account.\n\nmacOS automatically allows local network access by:\n\nIf you’re creating some other type of program, expect the system to block its local network operations until the user grants it the Local Network privilege.\n\nWhen a process performs a local network operation, macOS tries to track down the responsible code.  For example, if your app spawns a helper tool and the helper tool performs a local network operation, macOS considers the app to be the responsible code.\n\nmacOS uses the responsible code to:\n\nIf you ship a `launchd` agent that’s not installed using `SMAppService`, make macOS aware of the responsible code by setting the `AssociatedBundleIdentifiers` property in your `launchd` property list.  See the `launchd.plist` man page for details.  For information on how to access that documentation, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].\n\nMost standalone executables—that is, executables that aren’t the main executable for a bundle—don’t need the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] property because they’re either:\n\nIf you manage to create a standalone executable that does need the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] property, add it to an `Info.plist` that’s embedded in your executable.  In Xcode, set this up using the  [doc:\/\/com.apple.documentation\/documentation\/Xcode\/build-settings-reference#Create-Infoplist-Section-in-Binary] build setting.\n\nmacOS 15.1 fixed a number of local network privacy bugs.  If you encounter local network privacy problems on macOS 15.0, retest on macOS 15.1 or later.\n\nPeople might see unexpected behavior in System Settings > Privacy & Security if they have multiple versions of the same app installed (FB15568200).\n\nmacOS fails to display the local network alert when a process with a very short lifespan performs a local network operation (FB16131937).  For example, if you create a `launchd` agent that performs a local network operation and immediately exits when that fails, macOS won’t display the local network alert.  To work around this, update your code to not exit immediately after a local network operation fails.\n\nFor the latest news about local network privacy, see the [doc:\/\/com.apple.documentation\/documentation\/macos-release-notes].\n\n## Build-time considerations\n\nLocal network privacy tracks the identity of your program using its code signature.  This presents a challenge on macOS, which allows for unsigned code and ad hoc signed code (Xcode displays this as Sign to Run Locally).  To ensure that local network privacy reliably tracks the identity of your macOS program, sign it with an Apple-issued code-signing identity.  To learn more about code-signing identities, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3161-inside-code-signing-certificates].  To learn more about how macOS tracks a program’s identity, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3127-inside-code-signing-requirements].\n\nLocal network privacy uses your main executable UUID as part of its implementation.  If your main executable has no UUID, or shares a UUID with other programs, local network privacy may behave weirdly.  To fix that, make sure your main executable has a UUID and that it’s unique.  For more about this, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3178-checking-for-and-resolving-build-uuid-problems].\n\n## Reset local network state\n\nDuring testing, you might want to reset your program’s Local Network privilege to the undetermined state.  Your options for this vary by platform.\n\nOn iOS, the easiest option is to delete your app.\n\nAlternatively, if you don’t want to delete your app for some reason, reset the entire privacy subsystem using Settings > General > Transfer or Reset > Reset > Reset Location & Privacy.\n\nOn macOS there’s no way to reset your program’s Local Network privilege to the undetermined state (FB14944392).  One alternative is to run your program in a virtual machine (VM).  To retest, restore the VM from a snapshot taken before you installed your program.\n\nAlternatively, create a new user account and run your test there.  Remember that macOS maintains separate local network privacy state for each user account.\n\n## Trigger the local network alert\n\nYou don’t need to do anything special to bring up the local network alert.  The system displays it automatically when your program performs a local network operation.  In most cases that’s the correct behavior.  The user is more likely to grant your program the Local Network privilege if they understand the context of the request.\n\nHowever, in specific circumstances it may be necessary to manually bring up the local network privacy alert.  For example, the user might have configured your program to perform a local network operation at some point in the future, when they’re not able to respond to the alert.\n\nThere’s no API to explicitly bring up the local network alert (FB8711182), but you can do this implicitly by performing a local network operation.  One approach that works well is to connect a UDP socket to a local network address.  This triggers the local network alert without generating any network traffic.\n\nThe following code shows how to do this in a general fashion:\n\n## Check for local network access\n\nThere’s no general API that returns whether the current process has local network access (FB8711182).  There are, however, a couple of techniques you can use in specific circumstances.\n\nIf you’re using Bonjour, check whether your operation is waiting with the `kDNSServiceErr_PolicyDenied` (-65570) error.  For example, for an `NWBrowser` object, your state update handler might look like this:\n\nIf your goal is to make a TCP connection to a local network address, manage that connection with [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection].  If your program doesn’t have local network access, the connection enters the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/waiting(_:)] state and the current path lists an unsatisfied reason of [doc:\/\/com.apple.documentation\/documentation\/Network\/NWPath\/UnsatisfiedReason-swift.enum\/localNetworkDenied].  To check for that:\n\nIf the user subsequently changes the Local Network privilege to grant your program local network access, the system automatically retries the connection.\n\nIf your program successfully made a TCP connection to a local network address and then the user changed the Local Network privilege to deny it local network access, the connection closes.  When you open a new connection, it enters the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/waiting(_:)] state as described above.\n\nIf these techniques don’t meet all of your requirements, file an [https:\/\/developer.apple.com\/bug-reporting\/] with the details.\n\n## Unexpected local network alert\n\nIn most cases it’s easy to understand why you’re seeing the local network alert.  You do something in your program that performs a local network operation, and the system presents the alert.\n\nHowever, in some cases the local network alert shows up unexpectedly.  A common cause of this is third-party libraries, where a library performs a local network operation for no obvious reason.  For example, a library might access the local network as soon as you initialize it.\n\nThere’s no direct way to track down unexpected local network operations.  Your best option is to remove code from your program until it stops presenting the local network alert.  Once that happens, add smaller chunks of code back into your program to home in on the cause.\n\nThat process might lead to a third-party library for which you don’t have the source code.  If that happens, raise this issue with the library’s vendor.\n\n## Identify the Wi-Fi interface correctly\n\nSome iOS apps assume that the Wi-Fi interface name is always `en0`.  This isn’t a valid assumption.  BSD interface names, like `en0`, aren’t considered API on any Apple platform.  If you write code based on this false assumption and deploy your app to a wide range of users, your app will fail for a small fraction of those users.\n\nThe reports from these users might suggest that local network privacy is misbehaving.  For example, a user might report that they did a local network operation and no local network alert showed up.  However, local network privacy is working correctly.  The real problem is that you’re assuming that `en0` is the Wi-Fi interface, and it isn’t.\n\nIn many cases you can avoid this problem by reworking your code.  For example, if you’re building a custom service discovery protocol on top of UDP broadcasts, life will be easier if you use Bonjour instead.  For more information about Bonjour, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api].\n\nIf you can’t use Bonjour—perhaps you’re working with an accessory with legacy firmware—run your service discovery code on *all* broadcast-capable interfaces.  Not only does that avoid this problem, but folks who have their devices plugged into Ethernet will love you forever!\n\nIf you must work with a specific type of interface, call `getifaddrs` to get the full interface list and then filter that list by the interface type.  Get the functional type of the interface using the `SIOCGIFFUNCTIONALTYPE` ioctl.\n\n## Revision History",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Technotes\/tn3179-understanding-local-network-privacy\ncrawled: 2025-12-05T10:31:41Z\n---\n\n# TN3179: Understanding local network privacy\n\n**Article**\n\nLearn how local network privacy affects your software.\n\n## Overview\n\nLocal network privacy puts people in control of which programs can interact with devices on their network.  The first time a program accesses the local network, the system displays an alert asking the user to approve that access.  The system records their decision, so future accesses don’t prompt.\n\nTo learn more, see:\n\n- WWDC 2020 Session 10110: [https:\/\/developer.apple.com\/videos\/play\/wwdc2020\/10110\/], which introduced the feature on iOS\n- WWDC 2024 Session 10123: [https:\/\/developer.apple.com\/videos\/play\/wwdc2024\/10123\/], which introduced the feature on macOS\n- [https:\/\/support.apple.com\/en-us\/102229], which explains local network privacy to people who use iOS\n\nUsers configure local network privacy in Settings > Privacy & Security > Local Network (System Settings on macOS).  The OS adds an app to this list after it attempts to access a local network.\n\nDevice managers aren’t able to configure local network privacy using MDM.\n\nThe following platforms support local network privacy:\n\n\n\nLocal network privacy works the same on iOS, iPadOS, and visionOS.  Unless otherwise noted, assume that any info about iOS applies to all three platforms.  See [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#iOS-considerations] for information specific to these three platforms.\n\nLocal network privacy on macOS shares all of the same core concepts, but there are platform-specific differences.  See [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#macOS-considerations] for more on this.\n\n## Essentials\n\nLocal network privacy regulates your program’s ability to perform local network operations.  If your program has local network access, the system allows the operation.  If not, the system blocks it.\n\n\n\nIn most cases, the user controls local network access by way of the Local Network privilege.  This has three states:\n\n- Undetermined\n- Allowed\n- Denied\n\nYour program starts in the undetermined state.  The first time it performs a local network operation, the system presents the local network alert.  The user chooses to either allow or deny the access.  The system records the user’s choice and applies it to subsequent operations.  The user can change this state at any time in Settings.\n\n\n\nIf your app accesses the local network, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] property to its `Info.plist` to explain its behavior to the user.\n\nIf your app allows people to enter an arbitrary network address, consider what happens if they enter a local network address.  For example, if you’re building an email client, check that it behaves correctly when the email server is on a local network.\n\nIf your app’s local network usage involves registering or browsing for specific Bonjour services, add a list of service types to the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property in your app’s `Info.plist`.  For more information about the Bonjour operations that require this, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#Bonjour-operations] below.\n\nAdditionally, if your iOS app performs multicast operations, sign it with the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.networking.multicast] entitlement.  For information about what constitutes a multicast operation, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#Multicast-operations] below.  If you use Xcode’s automatic code signing, use the [doc:\/\/com.apple.documentation\/documentation\/Xcode\/capabilities] editor to enable this capability.  If not, see [https:\/\/developer.apple.com\/help\/account\/reference\/provisioning-with-managed-capabilities].\n\n\n\nIf you’re building an app extension, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#App-extension-considerations].\n\nIf you’re building some other sort of program for macOS—a `launchd` daemon or agent, a system extension, and so on—see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#macOS-considerations].\n\nIf the system presents a local network alert in response to one of your local network operations, it may deny the operation immediately, before the user has responded to the alert.  To handle this smoothly, use an API that supports waiting for connectivity, like Network framework or `URLSession` with [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionConfiguration\/waitsForConnectivity] enabled.  If you can’t use one of these preferred APIs, add appropriate retry logic.\n\nFor an overview of the networking APIs on Apple platforms, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api].\n\n## Local network operations\n\nA local network is an IP network associated with a broadcast-capable network interface.  Such interfaces include Wi-Fi and Ethernet, but not cellular (WWAN) or VPN.  A local network address is any address on a local network.  Traffic to a local network address goes directly; it’s not forwarded by a router.\n\nIn addition, all multicast addresses (224.0.0.0\/4, ff00::\/8) and the IPv4 broadcast address (255.255.255.255) are local network addresses.\n\nOutgoing traffic to a local network address requires local network access.  The following table lists some common cases:\n\n\n\nThe system implements these TCP and UDP checks deep in the networking stack, and thus they apply to all networking APIs.  This includes [doc:\/\/com.apple.documentation\/documentation\/Network] framework, BSD Sockets, [doc:\/\/com.apple.documentation\/documentation\/Foundation\/url-loading-system], and any APIs implemented on top of those.\n\nNote these exceptions to the rules above:\n\n- If your device’s DNS server is on a local network, traffic to it doesn’t require local network access.\n- If your device uses a network proxy and that proxy is on a local network, traffic to it doesn’t require local network access.\n- Traffic originating from [doc:\/\/com.apple.documentation\/documentation\/WebKit\/WKWebView], [doc:\/\/com.apple.documentation\/documentation\/SafariServices\/SFSafariViewController], and Safari doesn’t require local network access.\n\n## DNS operations\n\nCertain DNS operations also require local network access.  The following table lists some common cases:\n\n\n\nThis check applies to a wide variety of APIs including [doc:\/\/com.apple.documentation\/documentation\/dnssd], `<net_db.h>`, and any APIs that use them.\n\nIn this context, a local DNS name is one ending with `.local` (or `.local.`), per [https:\/\/tools.ietf.org\/html\/rfc6762].\n\nAdditionally, Bonjour operations require local network access, as described in the next section.\n\n## Bonjour operations\n\nAll Bonjour operations require local network access.\n\n\n\nThese checks apply to all APIs that use Bonjour, including [doc:\/\/com.apple.documentation\/documentation\/dnssd], [doc:\/\/com.apple.documentation\/documentation\/Network] framework, and Multipeer Connectivity.\n\n\n\nHigh-level services that use Bonjour internally don’t require local network access.  That’s because these services isolate your app from any details about the local network.  Such services include:\n\n\n\nSome specific Bonjour operations require the multicast entitlement as well.   See the next section for the details.\n\n## Multicast operations\n\nSending or receiving multicast or broadcast traffic is a local network operation on all platforms, as described in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#Local-network-operations].  However, iOS puts additional restrictions on these operations.  To send or receive multicast or broadcast traffic, sign your app with the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.networking.multicast] entitlement.\n\nThe following table lists some common cases.\n\n\n\nSome uncommon Bonjour operations also require the multicast entitlement.\n\n\n\nFor information on how to browse for all advertised service types using a `_services._dns-sd._udp.local.` query, see QA1337 [https:\/\/developer.apple.com\/library\/archive\/qa\/qa1337\/_index.html].\n\n## Multipeer Connectivity considerations\n\n[doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity] uses Bonjour internally.  If your app uses Multipeer Connectivity, follow all the Bonjour guidance in this technote.\n\nSpecifically, list your Multipeer Connectivity service type in the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property.  To format that entry, take your Multipeer Connectivity service type and add a leading underscore (`_`) and a trailing `._tcp`.  For example, if you pass `waffle-varnish` to the `serviceType` parameter of [doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity\/MCAdvertiserAssistant\/init(serviceType:discoveryInfo:session:)], add `_waffle-varnish._tcp` to the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property.\n\n## App extension considerations\n\nIn general, app extensions share the Local Network privilege state of their container app.\n\nSome app extension types are assumed to be running in the background.  If such an extension performs a local network operation while its Local Network privilege is undetermined, the system denies that operation as it would for an iOS app running in the background.  For more on that, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy#iOS-considerations].\n\nNetwork Extension packet tunnel provider, app proxy provider, and DNS proxy provider app extensions have local network access regardless of the Local Network privilege state of their container app.\n\nIf your app has app extensions, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] and [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] properties to the app’s `Info.plist`, not to the app extension’s.\n\n## iOS considerations\n\nIf an iOS app is in the background and performs a local network operation while its Local Network privilege is undetermined, the system denies that operation without presenting the local network alert.  The system doesn’t record that decision.  If, later on, the app performs a local network operation while in the foreground, the system presents the alert to the user as if this were the first local network operation.\n\nApp Clips can’t perform local network operations.  See [doc:\/\/com.apple.documentation\/documentation\/AppClip\/choosing-the-right-functionality-for-your-app-clip].\n\nThe simulator doesn’t support local network privacy.  Test your local network privacy behavior on a real device.\n\nOn Shared iPad, all users share the same local network privacy state.\n\nIt *is* possible for your app to trigger the local network alert when the device is “off Wi-Fi”, that is, when there’s no Wi-Fi symbol in the status bar.  An easy way to demonstrate this is to perform a Bonjour operation with peer-to-peer Wi-Fi enabled, but there lots of other ways this can happen.\n\nThe above is true regardless of whether the device has cellular networking or not.\n\nFor more information about peer-to-peer Wi-Fi, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api].\n\niOS 18 has a bug (FB14321888) that can cause the in-memory and persistent state of local network privacy to get out of sync after changing the user preference multiple times.  This bug was fixed in iOS 18.6.  If you encounter unexpected behavior on iOS 18, update to iOS 18.6 or later.\n\n## macOS considerations\n\nmacOS maintains separate local network privacy state for each user account.\n\nmacOS automatically allows local network access by:\n\n- Any daemon started by `launchd`\n- Any program running as root\n- Command-line tools run from Terminal or over SSH, including any child processes they spawn\n\n\n\nIf you’re creating some other type of program, expect the system to block its local network operations until the user grants it the Local Network privilege.\n\nWhen a process performs a local network operation, macOS tries to track down the responsible code.  For example, if your app spawns a helper tool and the helper tool performs a local network operation, macOS considers the app to be the responsible code.\n\nmacOS uses the responsible code to:\n\n- Show a meaningful app name and usage description in the local network alert\n- Record the user’s choice for the whole app, not just that specific helper tool\n- Present that choice in System Settings\n\nIf you ship a `launchd` agent that’s not installed using `SMAppService`, make macOS aware of the responsible code by setting the `AssociatedBundleIdentifiers` property in your `launchd` property list.  See the `launchd.plist` man page for details.  For information on how to access that documentation, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].\n\nMost standalone executables—that is, executables that aren’t the main executable for a bundle—don’t need the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] property because they’re either:\n\n- Automatically allowed local network access, for example, daemons and command-line tools\n- Have an app that acts as their responsible code, for example, a helper tool\n\nIf you manage to create a standalone executable that does need the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSLocalNetworkUsageDescription] property, add it to an `Info.plist` that’s embedded in your executable.  In Xcode, set this up using the  [doc:\/\/com.apple.documentation\/documentation\/Xcode\/build-settings-reference#Create-Infoplist-Section-in-Binary] build setting.\n\nmacOS 15.1 fixed a number of local network privacy bugs.  If you encounter local network privacy problems on macOS 15.0, retest on macOS 15.1 or later.\n\nPeople might see unexpected behavior in System Settings > Privacy & Security if they have multiple versions of the same app installed (FB15568200).\n\nmacOS fails to display the local network alert when a process with a very short lifespan performs a local network operation (FB16131937).  For example, if you create a `launchd` agent that performs a local network operation and immediately exits when that fails, macOS won’t display the local network alert.  To work around this, update your code to not exit immediately after a local network operation fails.\n\nFor the latest news about local network privacy, see the [doc:\/\/com.apple.documentation\/documentation\/macos-release-notes].\n\n## Build-time considerations\n\nLocal network privacy tracks the identity of your program using its code signature.  This presents a challenge on macOS, which allows for unsigned code and ad hoc signed code (Xcode displays this as Sign to Run Locally).  To ensure that local network privacy reliably tracks the identity of your macOS program, sign it with an Apple-issued code-signing identity.  To learn more about code-signing identities, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3161-inside-code-signing-certificates].  To learn more about how macOS tracks a program’s identity, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3127-inside-code-signing-requirements].\n\nLocal network privacy uses your main executable UUID as part of its implementation.  If your main executable has no UUID, or shares a UUID with other programs, local network privacy may behave weirdly.  To fix that, make sure your main executable has a UUID and that it’s unique.  For more about this, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3178-checking-for-and-resolving-build-uuid-problems].\n\n## Reset local network state\n\nDuring testing, you might want to reset your program’s Local Network privilege to the undetermined state.  Your options for this vary by platform.\n\nOn iOS, the easiest option is to delete your app.\n\nAlternatively, if you don’t want to delete your app for some reason, reset the entire privacy subsystem using Settings > General > Transfer or Reset > Reset > Reset Location & Privacy.\n\nOn macOS there’s no way to reset your program’s Local Network privilege to the undetermined state (FB14944392).  One alternative is to run your program in a virtual machine (VM).  To retest, restore the VM from a snapshot taken before you installed your program.\n\nAlternatively, create a new user account and run your test there.  Remember that macOS maintains separate local network privacy state for each user account.\n\n## Trigger the local network alert\n\nYou don’t need to do anything special to bring up the local network alert.  The system displays it automatically when your program performs a local network operation.  In most cases that’s the correct behavior.  The user is more likely to grant your program the Local Network privilege if they understand the context of the request.\n\nHowever, in specific circumstances it may be necessary to manually bring up the local network privacy alert.  For example, the user might have configured your program to perform a local network operation at some point in the future, when they’re not able to respond to the alert.\n\nThere’s no API to explicitly bring up the local network alert (FB8711182), but you can do this implicitly by performing a local network operation.  One approach that works well is to connect a UDP socket to a local network address.  This triggers the local network alert without generating any network traffic.\n\nThe following code shows how to do this in a general fashion:\n\n```swift\n\/\/\/ Attempts to trigger the local network privacy alert.\n\/\/\/ \n\/\/\/ This builds a list of link-local IPv6 addresses and then creates a connected\n\/\/\/ UDP socket to each in turn.  Connecting a UDP socket triggers the local\n\/\/\/ network alert without actually sending any traffic.\n\/\/\/ \n\/\/\/ This is a ‘best effort’ approach, and it handles errors by ignoring them.\n\/\/\/ There’s no guarantee that it’ll actually trigger the alert (FB8711182).\n\nfunc triggerLocalNetworkPrivacyAlert() {\n    let addresses = selectedLinkLocalIPv6Addresses()\n    for address in addresses {\n        let sock6 = socket(AF_INET6, SOCK_DGRAM, 0)\n        guard sock6 >= 0 else { return }\n        defer { close(sock6) }\n\n        withUnsafePointer(to: address) { sa6 in\n            sa6.withMemoryRebound(to: sockaddr.self, capacity: 1) { sa in\n                _ = connect(sock6, sa, socklen_t(sa.pointee.sa_len)) >= 0\n            }\n        }\n    }\n}\n\n\/\/\/ Returns a selection of IPv6 addresses to connect to.\n\/\/\/\n\/\/\/ To build this list it:\n\/\/\/\n\/\/\/ 1. Finds the IPv6 address of every broadcast-capable interface.\n\/\/\/\n\/\/\/ 2. Filters out all the ones that aren’t link-local.\n\/\/\/\n\/\/\/ 3. Sets the port number to port 9, that is, the discard service.  Even\n\/\/\/    though the caller won’t actually send any traffic, this ensures that it\n\/\/\/    would be discarded if it were sent.\n\/\/\/\n\/\/\/ 4. Creates two copies of each address, and replaces the host part with a\n\/\/\/    random number.\n\nprivate func selectedLinkLocalIPv6Addresses() -> [sockaddr_in6]\n{\n    let r1 = (0..<8).map { _ in UInt8.random(in: 0...255) }\n    let r2 = (0..<8).map { _ in UInt8.random(in: 0...255) }\n    return Array(ipv6AddressesOfBroadcastCapableInterfaces()\n        .filter { isIPv6AddressLinkLocal($0) }\n        .map { var addr = $0 ; addr.sin6_port = UInt16(9).bigEndian ; return addr }\n        .map { [setIPv6LinkLocalAddressHostPart(of: $0, to: r1), setIPv6LinkLocalAddressHostPart(of: $0, to: r2)] }\n        .joined())\n}\n\n\/\/\/ Replaces the host part of an IPv6 link-local address with the supplied\n\/\/\/ value.\n\/\/\/\n\/\/\/ In this context, _host part_ refers to the bottom 64-bits of the address,\n\/\/\/ that is, the `interface ID` as defined in Section 2.5.6 of [RFC\n\/\/\/ 4291](https:\/\/tools.ietf.org\/html\/rfc4291)).  Thus, the host part parameter\n\/\/\/ must be exactly 8 bytes.\n\nprivate func setIPv6LinkLocalAddressHostPart(of address: sockaddr_in6, to hostPart: [UInt8]) -> sockaddr_in6 {\n    precondition(hostPart.count == 8)\n    var result = address\n    withUnsafeMutableBytes(of: &result.sin6_addr) { buf in\n        buf[8...].copyBytes(from: hostPart)\n    }\n    return result\n}\n\n\/\/\/ Returns whether the supplied IPv6 address is link-local.\n\/\/\/\n\/\/\/ Link-local address have the fe:c0\/10 prefix.\n\nprivate func isIPv6AddressLinkLocal(_ address: sockaddr_in6) -> Bool {\n    address.sin6_addr.__u6_addr.__u6_addr8.0 == 0xfe\n        && (address.sin6_addr.__u6_addr.__u6_addr8.1 & 0xc0) == 0x80\n}\n\n\/\/\/ Returns the IPv6 address of every broadcast-capable interface.\n\nprivate func ipv6AddressesOfBroadcastCapableInterfaces() -> [sockaddr_in6] {\n    var addrList: UnsafeMutablePointer<ifaddrs>? = nil\n    let err = getifaddrs(&addrList)\n    guard err == 0, let start = addrList else { return [] }\n    defer { freeifaddrs(start) }\n    return sequence(first: start, next: { $0.pointee.ifa_next })\n        .compactMap { i -> sockaddr_in6? in\n            guard\n                (i.pointee.ifa_flags & UInt32(bitPattern: IFF_BROADCAST)) != 0,\n                let sa = i.pointee.ifa_addr,\n                sa.pointee.sa_family == AF_INET6,\n                sa.pointee.sa_len >= MemoryLayout<sockaddr_in6>.size\n            else { return nil }\n            return UnsafeRawPointer(sa).load(as: sockaddr_in6.self)\n        }\n}\n```\n\n## Check for local network access\n\nThere’s no general API that returns whether the current process has local network access (FB8711182).  There are, however, a couple of techniques you can use in specific circumstances.\n\nIf you’re using Bonjour, check whether your operation is waiting with the `kDNSServiceErr_PolicyDenied` (-65570) error.  For example, for an `NWBrowser` object, your state update handler might look like this:\n\n```swift\n browser.stateUpdateHandler = { state in\n    switch state {\n    case .waiting(let error):\n        switch error {\n        case .dns(let code):\n            switch Int(code) {\n            case kDNSServiceErr_PolicyDenied:\n                … no local network access …\n            …\n            }\n        …\n        }\n    …\n    }\n}\n```\n\nIf your goal is to make a TCP connection to a local network address, manage that connection with [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection].  If your program doesn’t have local network access, the connection enters the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/waiting(_:)] state and the current path lists an unsatisfied reason of [doc:\/\/com.apple.documentation\/documentation\/Network\/NWPath\/UnsatisfiedReason-swift.enum\/localNetworkDenied].  To check for that:\n\n```swift\nlet connection: NWConnection = … your existing logic …\nconnection.stateUpdateHandler = { state in\n    switch state {\n    case .waiting(_):\n        if case .localNetworkDenied? = connection.currentPath?.unsatisfiedReason {\n            … no local network access …\n        }\n    … other states …\n    }\n}\n```\n\nIf the user subsequently changes the Local Network privilege to grant your program local network access, the system automatically retries the connection.\n\nIf your program successfully made a TCP connection to a local network address and then the user changed the Local Network privilege to deny it local network access, the connection closes.  When you open a new connection, it enters the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/waiting(_:)] state as described above.\n\nIf these techniques don’t meet all of your requirements, file an [https:\/\/developer.apple.com\/bug-reporting\/] with the details.\n\n## Unexpected local network alert\n\nIn most cases it’s easy to understand why you’re seeing the local network alert.  You do something in your program that performs a local network operation, and the system presents the alert.\n\nHowever, in some cases the local network alert shows up unexpectedly.  A common cause of this is third-party libraries, where a library performs a local network operation for no obvious reason.  For example, a library might access the local network as soon as you initialize it.\n\nThere’s no direct way to track down unexpected local network operations.  Your best option is to remove code from your program until it stops presenting the local network alert.  Once that happens, add smaller chunks of code back into your program to home in on the cause.\n\nThat process might lead to a third-party library for which you don’t have the source code.  If that happens, raise this issue with the library’s vendor.\n\n## Identify the Wi-Fi interface correctly\n\nSome iOS apps assume that the Wi-Fi interface name is always `en0`.  This isn’t a valid assumption.  BSD interface names, like `en0`, aren’t considered API on any Apple platform.  If you write code based on this false assumption and deploy your app to a wide range of users, your app will fail for a small fraction of those users.\n\nThe reports from these users might suggest that local network privacy is misbehaving.  For example, a user might report that they did a local network operation and no local network alert showed up.  However, local network privacy is working correctly.  The real problem is that you’re assuming that `en0` is the Wi-Fi interface, and it isn’t.\n\n\n\nIn many cases you can avoid this problem by reworking your code.  For example, if you’re building a custom service discovery protocol on top of UDP broadcasts, life will be easier if you use Bonjour instead.  For more information about Bonjour, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api].\n\nIf you can’t use Bonjour—perhaps you’re working with an accessory with legacy firmware—run your service discovery code on *all* broadcast-capable interfaces.  Not only does that avoid this problem, but folks who have their devices plugged into Ethernet will love you forever!\n\nIf you must work with a specific type of interface, call `getifaddrs` to get the full interface list and then filter that list by the interface type.  Get the functional type of the interface using the `SIOCGIFFUNCTIONALTYPE` ioctl.\n\n## Revision History\n\n- **2025-07-18** Added information about two bugs (FB14321888, FB16131937). Updated the *Build-time considerations* section to cover macOS code signing.\n- **2024-10-31** Rewritten and republished as TN3179.\n- **2020-10-16** First posted as the *Local Network Privacy FAQ* on the Apple Developer Forums.\n\n## Latest\n\n- **TN3190: USB audio device design considerations**: Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.\n- **TN3194: Handling account deletions and revoking tokens for Sign in with Apple**: Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.\n- **TN3193: Managing the on-device foundation model’s context window**: Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.\n- **TN3115: Bluetooth State Restoration app relaunch rules**: Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.\n- **TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key**: Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.\n- **TN3151: Choosing the right networking API**: Learn which networking API is best for you.\n- **TN3111: iOS Wi-Fi API overview**: Explore the various Wi-Fi APIs available on iOS and their expected use cases.\n- **TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS**: Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.\n- **TN3134: Network Extension provider deployment**: Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.\n- **TN3189: Managing Mail background traffic load**: Identify iOS Mail background traffic and manage its impact on your IMAP server.\n- **TN3187: Migrating to the UIKit scene-based life cycle**: Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.\n- **TN3188: Troubleshooting In-App Purchases availability in the App Store**: Verify your In-App Purchases are approved and available for sale in the App Store.\n- **TN3186: Troubleshooting In-App Purchases availability in the sandbox**: Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.\n- **TN3185: Troubleshooting In-App Purchases availability in Xcode**: Inspect your active StoreKit configuration file for unexpected configurations.\n- **TN3182: Adding privacy tracking keys to your privacy manifest**: Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.",
          "name" : "TN3190: USB audio device design considerations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3190-USB-audio-device-design-considerations"
        },
        {
          "description" : "Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.",
          "name" : "TN3194: Handling account deletions and revoking tokens for Sign in with Apple",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3194-handling-account-deletions-and-revoking-tokens-for-sign-in-with-apple"
        },
        {
          "description" : "Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.",
          "name" : "TN3193: Managing the on-device foundation model’s context window",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3193-managing-the-on-device-foundation-model-s-context-window"
        },
        {
          "description" : "Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.",
          "name" : "TN3115: Bluetooth State Restoration app relaunch rules",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3115-bluetooth-state-restoration-app-relaunch-rules"
        },
        {
          "description" : "Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.",
          "name" : "TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3192-Migrating-your-app-from-the-deprecated-UIRequiresFullScreen-key"
        },
        {
          "description" : "Learn which networking API is best for you.",
          "name" : "TN3151: Choosing the right networking API",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api"
        },
        {
          "description" : "Explore the various Wi-Fi APIs available on iOS and their expected use cases.",
          "name" : "TN3111: iOS Wi-Fi API overview",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3111-ios-wifi-api-overview"
        },
        {
          "description" : "Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.",
          "name" : "TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3191-imap-extensions-supported-by-mail"
        },
        {
          "description" : "Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.",
          "name" : "TN3134: Network Extension provider deployment",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3134-network-extension-provider-deployment"
        },
        {
          "description" : "Identify iOS Mail background traffic and manage its impact on your IMAP server.",
          "name" : "TN3189: Managing Mail background traffic load",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3189-managing-mail-background-traffic-load"
        },
        {
          "description" : "Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.",
          "name" : "TN3187: Migrating to the UIKit scene-based life cycle",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle"
        },
        {
          "description" : "Verify your In-App Purchases are approved and available for sale in the App Store.",
          "name" : "TN3188: Troubleshooting In-App Purchases availability in the App Store",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3188-troubleshooting-in-app-purchases-availability-in-the-app-store"
        },
        {
          "description" : "Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.",
          "name" : "TN3186: Troubleshooting In-App Purchases availability in the sandbox",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3186-troubleshooting-in-app-purchases-availability-in-the-sandbox"
        },
        {
          "description" : "Inspect your active StoreKit configuration file for unexpected configurations.",
          "name" : "TN3185: Troubleshooting In-App Purchases availability in Xcode",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3185-troubleshooting-in-app-purchases-availability-in-xcode"
        },
        {
          "description" : "Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.",
          "name" : "TN3182: Adding privacy tracking keys to your privacy manifest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3182-adding-privacy-tracking-keys-to-your-privacy-manifest"
        }
      ],
      "title" : "Latest"
    }
  ],
  "source" : "appleJSON",
  "title" : "TN3179: Understanding local network privacy",
  "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3179-understanding-local-network-privacy"
}