{
  "abstract" : "Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.",
  "codeExamples" : [
    {
      "code" : "<key>IOAudioDeviceConfigurationApplication<\/key>\n<string>com.example.configuration.application.bundleid<\/string>",
      "language" : "xml"
    },
    {
      "code" : "<key>IOAudioEngineInputSampleLatency<\/key>\n<dict>\n    <key>192000<\/key>\n    <integer>100<\/integer>\n    <key>176400<\/key>\n    <integer>100<\/integer>\n    <key>96000<\/key>\n    <integer>50<\/integer>\n    <key>88200<\/key>\n    <integer>50<\/integer>\n    <key>48000<\/key>\n    <integer>25<\/integer>\n    <key>44100<\/key>\n    <integer>25<\/integer>\n<\/dict>",
      "language" : "xml"
    },
    {
      "code" : "<key>IOAudioEngineOutputSampleLatency<\/key>\n<dict>\n    <key>192000<\/key>\n    <integer>100<\/integer>\n    <key>176400<\/key>\n    <integer>100<\/integer>\n    <key>96000<\/key>\n    <integer>50<\/integer>\n    <key>88200<\/key>\n    <integer>50<\/integer>\n    <key>48000<\/key>\n    <integer>25<\/integer>\n    <key>44100<\/key>\n    <integer>25<\/integer>\n<\/dict>",
      "language" : "xml"
    },
    {
      "code" : "<key>InhibitAudioClassDriver<\/key>\n<true\/>",
      "language" : "xml"
    },
    {
      "code" : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>CFBundleDevelopmentRegion<\/key>\n    <string>$(DEVELOPMENT_LANGUAGE)<\/string>\n    <key>CFBundleExecutable<\/key>\n    <string>$(EXECUTABLE_NAME)<\/string>\n    <key>CFBundleIdentifier<\/key>\n    <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n    <key>CFBundleInfoDictionaryVersion<\/key>\n    <string>6.0<\/string>\n    <key>CFBundleName<\/key>\n    <string>$(PRODUCT_NAME)<\/string>\n    <key>CFBundlePackageType<\/key>\n    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)<\/string>\n    <key>CFBundleShortVersionString<\/key>\n    <string>1.0<\/string>\n    <key>CFBundleVersion<\/key>\n    <string>1<\/string>\n    <key>IOKitPersonalities<\/key>\n    <dict>\n        <key>Example_Override_IOUSBHostDevice<\/key>\n        <dict>\n            <key>CFBundleIdentifier<\/key>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n            <key>CFBundleIdentifierKernel<\/key>\n            <string>com.apple.driver.AppleUSBMergeNub<\/string>\n            <key>IOClass<\/key>\n            <string>AppleUSBMergeNub<\/string>\n            <key>IOProviderClass<\/key>\n            <string>IOUSBHostDevice<\/string>\n            <key>IOProviderMergeProperties<\/key>\n            <dict>\n                <key>USB Product Name<\/key>\n                <string>Example Overridden Product Name<\/string>\n                <key>IOAudioDeviceConfigurationApplication<\/key>\n                <string>com.example.configuration.application.bundleid<\/string>\n                <key>InhibitAudioClassDriver<\/key>\n                <true\/>\n            <\/dict>\n            <key>IOUserClass<\/key>\n            <string>ExampleUACOverridesCodelessDext<\/string>\n            <key>idProduct<\/key>\n            <integer>XXXX<\/integer>\n            <key>idVendor<\/key>\n            <integer>XXXX<\/integer>\n        <\/dict>\n        <key>Example_Override_IOUSBHostInterface_Streaming_In<\/key>\n        <dict>\n            <key>CFBundleIdentifier<\/key>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n            <key>CFBundleIdentifierKernel<\/key>\n            <string>com.apple.driver.AppleUSBMergeNub<\/string>\n            <key>IOClass<\/key>\n            <string>AppleUSBMergeNub<\/string>\n            <key>IOProviderClass<\/key>\n            <string>IOUSBHostInterface<\/string>\n            <key>IOProviderMergeProperties<\/key>\n            <dict>\n                <key>IOAudioEngineInputSampleLatency<\/key>\n                <dict>\n                    <key>192000<\/key>\n                    <integer>100<\/integer>\n                    <key>176400<\/key>\n                    <integer>100<\/integer>\n                    <key>96000<\/key>\n                    <integer>50<\/integer>\n                    <key>88200<\/key>\n                    <integer>50<\/integer>\n                    <key>48000<\/key>\n                    <integer>25<\/integer>\n                    <key>44100<\/key>\n                    <integer>25<\/integer>\n                <\/dict>\n                <key>USB Interface Name<\/key>\n                <string>Example Overridden Interface Name<\/string>\n            <\/dict>\n            <key>IOUserClass<\/key>\n            <string>ExampleUACOverridesCodelessDext<\/string>\n            <key>bConfigurationValue<\/key>\n            <integer>1<\/integer>\n            <key>bInterfaceNumber<\/key>\n            <integer>2<\/integer>\n            <key>idProduct<\/key>\n            <integer>XXXX<\/integer>\n            <key>idVendor<\/key>\n            <integer>XXXX<\/integer>\n        <\/dict>\n        <key>Example_Override_IOUSBHostInterface_Streaming_Out<\/key>\n        <dict>\n            <key>CFBundleIdentifier<\/key>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n            <key>CFBundleIdentifierKernel<\/key>\n            <string>com.apple.driver.AppleUSBMergeNub<\/string>\n            <key>IOClass<\/key>\n            <string>AppleUSBMergeNub<\/string>\n            <key>IOProviderClass<\/key>\n            <string>IOUSBHostInterface<\/string>\n            <key>IOProviderMergeProperties<\/key>\n            <dict>\n                <key>IOAudioEngineOutputSampleLatency<\/key>\n                <dict>\n                    <key>192000<\/key>\n                    <integer>100<\/integer>\n                    <key>176400<\/key>\n                    <integer>100<\/integer>\n                    <key>96000<\/key>\n                    <integer>50<\/integer>\n                    <key>88200<\/key>\n                    <integer>50<\/integer>\n                    <key>48000<\/key>\n                    <integer>25<\/integer>\n                    <key>44100<\/key>\n                    <integer>25<\/integer>\n                <\/dict>\n                <key>USB Interface Name<\/key>\n                <string>Example Overridden Interface Name<\/string>\n            <\/dict>\n            <key>IOUserClass<\/key>\n            <string>ExampleUACOverridesCodelessDext<\/string>\n            <key>bConfigurationValue<\/key>\n            <integer>1<\/integer>\n            <key>bInterfaceNumber<\/key>\n            <integer>1<\/integer>\n            <key>idProduct<\/key>\n            <integer>XXXX<\/integer>\n            <key>idVendor<\/key>\n            <integer>XXXX<\/integer>\n        <\/dict>\n    <\/dict>\n    <key>OSBundleUsageDescription<\/key>\n    <string><\/string>\n<\/dict>\n<\/plist>",
      "language" : "xml"
    }
  ],
  "contentHash" : "2bc58438770b92bb8895a6102416feceb9c68b3f87ee2c67201066c0c0b2ccd5",
  "crawledAt" : "2025-12-05T10:31:35Z",
  "id" : "CBEB2DE8-247F-400F-9D5A-AC48CB847FEC",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nThis document helps you design audio devices that connect to Mac, iPad, and iPhone over USB. Such devices must conform to the *Universal Serial Bus Class Definition for Audio Devices* published by USB Implementers Forum, Inc., also known as the USB-IF ([https:\/\/www.usb.org]).\n\n## Choosing a version of the USB Audio Device Class specification\n\nThere are four versions of the USB Audio Device Class (ADC) specification:\n\n### Audio Device Class 1 (ADC1)\n\nADC1 introduced the concepts you need to design a compliant audio device. It includes all of the building blocks for describing data flow within your device. However, there are some limitations that you should consider before implementing a new device using ADC1:\n\nA Full Speed bus can transfer a maximum of 1500 bytes (12000 bits) per millisecond including bus overhead, so a 96 kHz 2 in\/2 out device is not possible with ADC1.\n\n### Audio Device Class 2 (ADC2)\n\nADC2 inherits all components from ADC1 and adds the Clock Source and Clock Selector descriptors to address shortcomings describing the clocking model in ADC1. In ADC2, device descriptors can specify which clock is attached to which stream. Other characteristics of the clock can be specified, such as whether it is internal or external to the device, whether it is synchronized to the USB Start Of Frame (SOF) clock, or if the clock is valid.\n\nADC2 is designed to support all bus speeds of the USB transport; Full Speed, High Speed and SuperSpeed. You can build audio devices with significantly increased channel counts and sample rates at High and SuperSpeeds. For example, a High Speed ADC2 device operating with a polling interval of 125 µs can transfer up to 24kB of audio data every millisecond in each direction without saturating the bus.\n\nThe following table illustrates how it is possible to achieve significantly higher sampling rates and channel counts with an ADC2 device operating at High Speed with a *bInterval* of 1 (125 µs service interval).\n\nOn a High Speed bus, a 192 kHz, 32 channel device using a bit width of 32 bits (4 bytes) needs to be implemented as a Synchronous device and must transfer exactly the maximum number of bytes every service interval. This device is allowed to transfer that amount of data in each direction without saturating the High Speed bus.\n\n### Audio Device Class 3 (ADC3)\n\nADC3 adds several improvements for Audio Device Class devices, notably Cluster and Connector descriptors:\n\nADC3 introduces Power Domains which allow a device to save energy. Power domains describe groups of elements which can switch into low power mode. The Apple USB audio driver does not support this functionality.\n\nADC3 introduced new Audio Function Category codes (compare ADC2, **Table A.7** with ADC3, **Table A.7**). The *HEADPHONE* and *HEADSET_ADAPTER* Audio Function Category codes are used to inform audio routing layers on iOS and iPadOS that a headphone or headset adapter USB device is connected.\n\nADC3 has a backwards compatibility protocol that requires the first Configuration Descriptor to support an ADC1 or ADC2 Audio Function. The ADC3 Audio Function must be supported by a different USB configuration. The Apple USB audio driver supports ADC3 configurations. However, ADC3 has not been widely adopted by other operating systems and it has been superseded by Audio Device Class 4.\n\n### Audio Device Class 4 (ADC4)\n\nAudio Device Class 4, introduced in 2023, resolves the channel count and string limitations of previous versions of the specification:\n\nIn ADC4, audio building blocks can be grouped and the state of all of the blocks in a group can be modified simultaneously. This has performance benefits for complex devices, as state changes do not need to be set on each block in the group.\n\n## Channel counts with ADC1-3\n\nVersions 1-3 of the Audio Device Class Specification have channel count limitations that you should be aware of, in addition to the bandwidth limitations of ADC1:\n\n## Endpoint Synchronization types\n\nThe *Universal Serial Bus Specification, Revision 2.0* and the *Universal Serial Bus 3.n Specifications* specify that USB Isochronous endpoints have one of four Synchronization Types:\n\n### Adaptive data endpoints\n\nYour device can use an Adaptive data endpoint to adapt to the data rate the host sends or receives.\n\nFor example, some early ADC1 USB Audio speakers indicate that they can receive output data at any rate from 5 to 50 kHz. The OUT endpoint does not have to be programmed to receive a specific rate. If the host sends data at 48 kHz, the device must render it at 48 kHz. If the host sends data at 12 kHz, the device must render it at 12 kHz etc.\n\nPer the USB Core Specification 5.12.4.1, a device that uses an Adaptive IN streaming endpoint should also provide an explicit feedback endpoint. The Apple USB Audio driver does not support adaptive feedback endpoints. Adaptive IN streaming endpoints are treated the same as asynchronous IN streaming endpoints.\n\nADC2 introduced Clock Source entities to address some of the shortcomings with Adaptive Data Endpoints. The Audio Device Class 4 specification, **Section 3.11.4.2** specifically states that this type of endpoint is not recommended for implementation.\n\n### Synchronous data endpoints\n\nIf your device specifies a Synchronous data endpoint, the audio data transferred on that endpoint must be synchronous with the USB SOF clock. Your device must use the USB SOF to discipline and lock the audio clock to the SOF, or implement an Asynchronous Sample Rate Converter (ASRC) to adjust the rate of audio data to match the SOF rate.\n\nFor example, if a device is using a sample rate of 48 kHz, it should transfer exactly 48 audio samples every millisecond as defined by the SOF tokens on the bus. If it is on a High Speed bus with a polling interval of 125 µs, it should transfer exactly 6 samples every 125 µs.\n\nThe *USB Audio* specification does allow for a Virtual Frame Packet (VFP) of the nominal rate ±1 but a carefully designed device should be able to transfer exactly the nominal sample rate if that sample rate is divisible by the transfer interval timing. See section **2.3.1.1 USB Packets** in *Universal Serial Bus Device Class Definition for Audio Data Formats, Release 2.0*.\n\n#### Asynchronous data endpoints\n\nIf your device specifies an Asynchronous data endpoint, then the data flow will be asynchronous to the USB SOF clock.\n\nFor audio input streams (from device to host), the host adapts to the incoming data rate within the tolerance required by the ADC specification. For example, if an input stream is clocked at 48 kHz, your device must provide between 47 and 49 audio samples every millisecond. If the polling interval is 125 µs, your device must deliver between 5 and 7 samples every microframe, and the total number of samples in 8 microframes must remain between 47 and 49. See section **2.3.1.1 USB Packets** in *Universal Serial Bus Device Class Definition for Audio Data Formats, Release 2.0* for more information on this requirement.\n\nFor audio output streams (from host to device), your device must provide a way for the device to provide feedback to the host for the desired sample rate. There are two types of feedback:\n\n#### Explicit feedback\n\nExplicit Feedback uses an Isochronous IN Endpoint with a Synchronization Type of No Synchronization. This is an IN endpoint which is part of the same Interface as the data OUT endpoint. The maxPacketSize of the explicit feedback endpoint depends on the speed of the bus and is not related to the version of the ADC specification.\n\nFeedback reporting for Full Speed and High Speed buses must comply with section **5.12.4.2 Feedback** of the *Universal Serial Bus Specification, Revision 2.0*\n\nFeedback reporting for a SuperSpeed endpoint must comply with section **4.4.8.4.1 Explicit Feedback** of the *Universal Serial Bus 3.2 Specification, Revision 1.0*\n\n### Implicit feedback\n\nYour device can support implicit feedback if it has input and output streams and both are on the same clock. If the data endpoint on the input stream has a Usage Type of Implicit feedback Data endpoint, the host uses the data rate on the audio input stream to provide the data rate on the audio output stream. It is important that your device produces input data at a consistent rate as quickly as possible after the stream starts. The Apple USB Audio driver does not begin transmitting data on the output stream until it has received consistent clock data from the input stream.\n\n## Audio Device Class entity support\n\nThe following section outlines Audio Device Class entities, the version of the specification that describes them, and the Apple operating system support.\n\n### Input and Output Terminals\n\nTerminals are the interface between the physical world and the logical audio function. Terminals are fully supported by macOS, iOS and iPadOS.\n\n### Terminal Controls\n\n### Terminal Connector Control\n\nIf your audio device has a headset connector with jack detection, use this control to indicate to the OS that input or output channels are in use by the customer. This is used by the operating system to automatically route audio to or from the device.\n\n### Input Terminal Phantom Power Control\n\nInput Terminals only. Your device can expose phantom power control to macOS. Customers can enable or disable this control through apps like Audio MIDI Setup or Logic Pro for Mac. This is implemented using the Core Audio control `kAudioPhantomPowerControlClassID`.\n\n### Feature Units\n\nFeature Units describe signal processing capabilities on channels in an audio cluster.\n\n### Feature Unit Controls\n\n### Mute Control\n\nThe user interface on macOS, iOS, and iPadOS exposes the Mute control on the Feature Unit closest to the physical output of the audio function. If a Feature Unit is immediately upstream of a Mixer Unit, between a physical input (for example, a microphone) and a physical output (for example, speakers), it is used to create a control to enable mixing of audio from the input with other audio flowing to the output. This is published to customers as a **Thru** control in Audio MIDI Setup on macOS, or as a programmable side tone control with no user interface on iOS.\n\n### Volume Control\n\nThe user interface on macOS, iOS, and iPadOS exposes the Volume control on the Feature Unit closest to the physical output of the audio function. If a Feature Unit is immediately upstream of a Mixer Unit, between a physical input (for example, a microphone) and a physical output (for example, speakers), it controls the gain on the physical input signal going into the Mixer Unit. macOS, iOS, or iPadOS does not provide a user interface for sidetone gain.\n\n### Phase Inverter Control\n\nSupported on macOS for ADC2 and ADC3 devices only. Supported on macOS Tahoe 26 and later, and can be accessed by applications using the Core Audio control  `kAudioPhaseInvertControlClassID`.\n\n### High-Pass Filter Control\n\nSupported on macOS for ADC2 devices only. Support is new with macOS Tahoe 26 and can be implemented by applications using the Core Audio control `kAudioHighPassFilterControlClassID`.\n\n### Mixer Unit\n\nMixer Units mix multiple input cluster channels into a single output cluster. Given *N* input channels and *M* output channels, a Mixer Unit provides *N × M* controls to describe how each input channel is mixed to an output channel.\n\nApple operating systems will not manipulate Mixer Units in your device and they will remain in their default state.\n\n### Mixer Unit Controls\n\n### Selector Unit\n\nSelector Units have multiple input clusters and a single output cluster. The Selector Unit selects one of the input clusters to be sent on the output cluster. On macOS, you can make a selection in the Audio MIDI Setup app. If you use this functionality in your USB audio device, provide a name for each of the clusters entering the Selector Unit by naming the entity, usually the Input Terminal, from which the cluster originates.\n\n### Selector Unit Controls\n\n### Selector Unit Selector Control\n\nThe Selector Control determines which of the input clusters is presented on the output cluster.\n\n### Processing Unit\n\nApple operating systems do not support Processing Units or controls on them. Processing Units in an active data path will remain in their default state, which should be disabled. There are multiple Processing Units defined in the ADC specifications (Up\/Down Mix, Dolby Prologic, etc.).\n\n### Extension Unit\n\nApple operating systems do not support Extension Units. Extension Units in an active data path will remain in their default state, which should be disabled. Extension Units cannot be enabled through the Apple USB Audio driver.\n\n### Effect Unit\n\nApple operating systems do not support Effect Units or controls on them. Effect Units in an active data path will remain in their default state, which should be disabled. There are multiple Effect Units defined in the ADC specifications (Parametric Equalizer, Reverberation, etc.).\n\n### Clock Source\n\nClock Sources were introduced in the ADC2 specification and describe the behavior of a clock. They are fully supported by Apple operating systems.\n\n### Clock Source controls\n\n### Clock Source Frequency Control\n\nSets the frequency of the Clock Source. For Read Only clocks (for example, an external SPDIF clock), use this control to report the current frequency setting of the Clock Source.\n\n### Clock Source Validity Control\n\nUse the Validity control to describe if a Clock Source has a valid clock on its output pin.\n\n### Clock Selector\n\nClock Selectors were introduced in the ADC2 specification and provide a selection between different Clock Source entities and a Terminal. On macOS, you can make a selection in the Audio MIDI Setup app.\n\n### Clock Selector Controls\n\n### Clock Selector Selector Control\n\nUse a Selector control to select one of the input pins on the Clock Selector of your device. Changing a selection removes and recreates the Core Audio formats associated with the Core Audio device.\n\n### Clock Multiplier\n\nThe Clock Multplier is described in ADC1-3 and has been deprecated in ADC4. Apple operating systems do not support Clock Multipliers.\n\n### Sampling Rate Converter\n\nApple operating systems do not support Sample Rate Converter (SRC) entities. SRC entities provide a mechanism to describe that data is being converted in your device from one clock domain to another.\n\n### Connectors descriptor (ADC3) and Connector Entity Descriptor (ADC4)\n\nApple operating systems do not support these descriptors.\n\n### Power Domain\n\nApple operating systems do not support Power Domains. This concept was introduced in the ADC3 specification, to allow for entities to be grouped into Power Domains which can be placed into a low power mode.\n\n## Audio Streaming Interface Class Specific Descriptors\n\nThe USB Audio Device Class Specification describes the following descriptors.\n\n### Class-Specific AS Encoder Descriptor\n\nThe Class-Specific AS Encoder Descriptor is not supported by Apple operating systems. If present, it will be ignored.\n\n### Class-Specific AS Decoder Descriptor\n\nThe Class-Specific AS Decoder Descriptor is not supported by Apple operating systems. If present, it will be ignored.\n\n### Class-Specific AS Valid Frequency Range Descriptor\n\nThe Class-Specific AS Valid Frequency Range Descriptor is not supported by Apple operating systems. This descriptor, introduced in ADC3, allows your device to specify available *Clock Source* frequency ranges on each Alternate Setting of a Streaming Interface.\n\n## Audio Streaming Interface Controls\n\nThe USB Audio Device Class Specification describes the following controls.\n\n### Active Alternate Setting Control\n\nThe Active Alternate Setting Control was introduced in ADC2 and is fully supported by Apple operating systems.\n\n### Valid Alternate Settings Control\n\nThe Valid Alternate Settings Control was introduced in ADC2 and is fully supported by Apple operating systems.\n\n### Audio Data Format Control\n\nThe Audio Data Format Control is not supported by Apple operating systems.\n\n## Device Naming\n\nEach audio device attached to an Apple host has two name properties associated with it:\n\nThe construction of these properties is described further below.\n\n### Device UID (kAudioDevicePropertyDeviceUID)\n\nFor USB audio devices, the `kAudioDevicePropertyDeviceUID` property conforms to the following layout:\n\nAppleUSBAudioEngine:<Company Name>:<Device Name>:<Serial # or LocationID>:N[,M]\n\n### Customer visible name (kAudioDevicePropertyDeviceName)\n\nThe Apple USB audio driver determines the name string of your devices using the following sequence:\n\nYou should avoid generic names like “USB Audio Device”.\n\n## Supported audio formats\n\nThe Apple USB Audio driver supports the following audio data formats.\n\n## Specifying channel locations to Core Audio\n\n### ADC1\/ADC2 spatial designations to Core Audio Channel Labels\n\nADC1 provides 12 spatial location positions for Clusters. ADC2 preserves those same 12 locations and provides 15 more, for a total of 27 spatial locations. The following table shows the mapping between USB ADC1 and ADC2 spatial locations and the Audio Channel Labels used in Core Audio.\n\n### Designing a device to meet predefined layouts in Core Audio\n\nCore Audio has predefined Layout Tags (see *AudioChannelLayoutTag*). Your device can specify its output channels such that it will automatically be recognized as one of the following predefined layouts.\n\n### kAudioChannelLayoutTag_Atmos_5_1_2\n\n### kAudioChannelLayoutTag_Atmos_5_1_4\n\n### kAudioChannelLayoutTag_Atmos_7_1_2\n\n### kAudioChannelLayoutTag_Atmos_7_1_4\n\n### kAudioChannelLayoutTag_Atmos_9_1_6\n\n## Extending the Apple USB Audio class driver\n\nYou can augment the Apple USB Audio class driver by providing a codeless driver extension (dext) with a property list file that uses the `com.apple.driver.AppleUSBMergeNub` driver in the kernel to add one or more of these properties to the [https:\/\/developer.apple.com\/documentation\/usbdriverkit\/iousbhostdevice] service or the [https:\/\/developer.apple.com\/documentation\/usbdriverkit\/iousbhostinterface] service for your device:\n\n### IOAudioDeviceConfigurationApplication\n\nThis property, attached to the `IOUSBHostDevice` service, specifies the Bundle ID of your device’s configuration app. Customers can use this to launch your app via Audio MIDI Setup’s “*Configure device…*” pop-up menu.\n\n### Latency Controls\n\nThe Apple USB audio driver supports the standard Latency Control defined in ADC2 **Section 5.2.4.8**. Your device should report latency using the Latency Control instead of the following mechanism. For existing devices that do not support the Latency Control, you can specify your device’s latency using the `IOAudioEngineInputSampleLatency` and `IOAudioEngineOutputSampleLatency` properties.\n\n### IOAudioEngineInputSampleLatency\n\nThis property, attached to the `IOUSBHostInterface` service, specifies the time delay, in samples, between an audio signal being received on a device physical input connector and the sample being transferred to the host over USB. It should be specified for each sample rate that the device supports.\n\n### IOAudioEngineOutputSampleLatency\n\nThis property, attached to the `IOUSBHostInterface` service, specifies the time delay, in samples, between an audio sample being received on the device over USB to the signal being presented on a device physical output connector. It should be specified for each sample rate that the device supports.\n\n### IOAudioEngineIsHidden\n\nThis legacy property is deprecated and will be removed in a future operating system release.\n\n### InhibitAudioClassDriver\n\nApple recommends using the built-in audio class driver provided with macOS, iOS, and iPadOS. If your device requires a custom driver, a driver extension (dext) can inhibit the loading of Apple’s USB Audio class driver using standard driver matching. If your driver is an AudioServerPlugin with no dext, you must provide and install a codeless dext to inhibit loading of the Apple USB audio driver.\n\nThis property is attached to the `IOUSBHostDevice` service. The Apple USB Audio driver will not load or provide audio services for the device if this key is set to true.\n\n### Example codeless dext plist\n\n## Other matching considerations\n\nBeginning on macOS Tahoe 26, Apple no longer publishes kernel IOServices based on the deprecated IOAudioFamily. If your audio device provides additional, non-class USB interfaces for control, you may need to update your software.\n\nThe following IOServices previously published by AppleUSBAudio.kext are no longer created on macOS Tahoe 26:\n\nAny properties previously published by those services in the [https:\/\/developer.apple.com\/documentation\/installer_js\/ioregistry] are no longer available.\n\nIf your application depends on AppleUSBAudio.kext IOAudioFamily services, it will need to be updated.\n\nPlease see Developer support below if you need further guidance on making associations between a Core Audio device AudioObjectID and its corresponding USB io_service_t.\n\n## Developer support\n\nIf you have questions regarding USB Audio Class support, please contact Apple through [applefeedback:\/\/new?form_identifier=dev.tech&answers%5B%3Aarea%5D=seedmacos%3Ausbaudio] selecting the following option:\n\nDeveloper Technologies & SDKs > USB Audio\n\nTo learn more about how to use Feedback Assistant, see [https:\/\/developer.apple.com\/bug-reporting\/].\n\n## Revision History",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Technotes\/tn3190-USB-audio-device-design-considerations\ncrawled: 2025-12-05T10:31:35Z\n---\n\n# TN3190: USB audio device design considerations\n\n**Article**\n\nLearn the best techniques for designing devices that conform to the USB Audio Device Class specifications.\n\n## Overview\n\nThis document helps you design audio devices that connect to Mac, iPad, and iPhone over USB. Such devices must conform to the *Universal Serial Bus Class Definition for Audio Devices* published by USB Implementers Forum, Inc., also known as the USB-IF ([https:\/\/www.usb.org]).\n\n## Choosing a version of the USB Audio Device Class specification\n\nThere are four versions of the USB Audio Device Class (ADC) specification:\n\n- [https:\/\/usb.org\/document-library\/audio-device-document-10] was published on March 18, 1998.\n- [https:\/\/usb.org\/document-library\/usb-device-class-definition-audio-devices-release-20-errata-and-ecn-through-april] was first published on May 31, 2006. The most recent version has ECN and errata through April 2, 2025.\n- Release 3.0 was published on September 22, 2016 and has been replaced by Release 4.0.\n- [https:\/\/usb.org\/document-library\/usb-audio-devices-release-40-and-adopters-agreement] was first published in April 2023. The most recent version has ECN and errata through April 2, 2025.\n\n### Audio Device Class 1 (ADC1)\n\nADC1 introduced the concepts you need to design a compliant audio device. It includes all of the building blocks for describing data flow within your device. However, there are some limitations that you should consider before implementing a new device using ADC1:\n\n1. The ADC1 specification was published prior to the existence of USB 2, and therefore the ADC1 specification assumes that the device is operating on a Full Speed bus. ADC1 is limited to a data transfer polling interval of 1 ms.\n2. ADC1 does not provide a robust way to describe and resolve clocks to individual audio streams. Clocking information is encapsulated in the Format Type descriptor in the stream, and the clock is programmed using the data endpoint on that stream. This introduces ambiguity in whether two or more streams are using the same clock. The Apple USB audio driver attempts to determine the clocking model based on the list of sample rates supported by each stream and the synchronization type of the data endpoints, but it isn’t always possible to deduce the intended clocking architecture of an ADC1 device.\n3. ADC1 devices have a lower channel count and sample rate limit, as they are limited to data transfer sizes of 1023 bytes per millisecond for Full Speed devices, and 1024 bytes per millisecond for High Speed devices.\n4. ADC1 only defines 12 spatial locations for channels, which does not meet the requirements of the latest surround and spatial audio systems.\n5. ADC1 does not have a function latency control. Your devices do not have the ability to advertise the internal latency of the audio function to Apple operating systems for synchronization purposes.\n6. ADC1 does not have a Connector control in Terminal entities. On iOS and iPadOS, this is used by the operating system to automatically route audio to or from the device when a physical connection is made by the customer. For example when a headset is attached to a USB to 3.5mm adapter.\n7. It is possible to build a High Speed USB Audio device which uses ADC1, but it is a violation of the ADC1 specification section **4.6.1.1, Table 4-20**, which requires that the standard Endpoint Descriptor have a *bInterval* of 1. To build a High Speed device which operates as ADC1, the *bInterval* must be set to 4, which is the 1 ms polling interval for a High Speed device. This significantly limits the ability of the audio function to support higher channel counts, sampling rates, and bit depths, as shown in the following table:\n\n\n\nA Full Speed bus can transfer a maximum of 1500 bytes (12000 bits) per millisecond including bus overhead, so a 96 kHz 2 in\/2 out device is not possible with ADC1.\n\n### Audio Device Class 2 (ADC2)\n\nADC2 inherits all components from ADC1 and adds the Clock Source and Clock Selector descriptors to address shortcomings describing the clocking model in ADC1. In ADC2, device descriptors can specify which clock is attached to which stream. Other characteristics of the clock can be specified, such as whether it is internal or external to the device, whether it is synchronized to the USB Start Of Frame (SOF) clock, or if the clock is valid.\n\nADC2 is designed to support all bus speeds of the USB transport; Full Speed, High Speed and SuperSpeed. You can build audio devices with significantly increased channel counts and sample rates at High and SuperSpeeds. For example, a High Speed ADC2 device operating with a polling interval of 125 µs can transfer up to 24kB of audio data every millisecond in each direction without saturating the bus.\n\nThe following table illustrates how it is possible to achieve significantly higher sampling rates and channel counts with an ADC2 device operating at High Speed with a *bInterval* of 1 (125 µs service interval).\n\n\n\nOn a High Speed bus, a 192 kHz, 32 channel device using a bit width of 32 bits (4 bytes) needs to be implemented as a Synchronous device and must transfer exactly the maximum number of bytes every service interval. This device is allowed to transfer that amount of data in each direction without saturating the High Speed bus.\n\n### Audio Device Class 3 (ADC3)\n\nADC3 adds several improvements for Audio Device Class devices, notably Cluster and Connector descriptors:\n\n- Cluster descriptors provide more detailed information about each channel in a channel cluster. This information can include location or ambisonic information.\n- Connector descriptors specify the connector type and other connector attributes.\n\nADC3 introduces Power Domains which allow a device to save energy. Power domains describe groups of elements which can switch into low power mode. The Apple USB audio driver does not support this functionality.\n\nADC3 introduced new Audio Function Category codes (compare ADC2, **Table A.7** with ADC3, **Table A.7**). The *HEADPHONE* and *HEADSET_ADAPTER* Audio Function Category codes are used to inform audio routing layers on iOS and iPadOS that a headphone or headset adapter USB device is connected.\n\nADC3 has a backwards compatibility protocol that requires the first Configuration Descriptor to support an ADC1 or ADC2 Audio Function. The ADC3 Audio Function must be supported by a different USB configuration. The Apple USB audio driver supports ADC3 configurations. However, ADC3 has not been widely adopted by other operating systems and it has been superseded by Audio Device Class 4.\n\n### Audio Device Class 4 (ADC4)\n\nAudio Device Class 4, introduced in 2023, resolves the channel count and string limitations of previous versions of the specification:\n\n- Every cluster in a device can support up to 65,535 channels.\n- The audio device contains its own string descriptor domain with up to 65,535 string descriptors.\n- A Feature Unit Descriptor can support up to 16,378 channels (plus cluster channel 0).\n\nIn ADC4, audio building blocks can be grouped and the state of all of the blocks in a group can be modified simultaneously. This has performance benefits for complex devices, as state changes do not need to be set on each block in the group.\n\n\n\n## Channel counts with ADC1-3\n\nVersions 1-3 of the Audio Device Class Specification have channel count limitations that you should be aware of, in addition to the bandwidth limitations of ADC1:\n\n- Clusters in any of these implementations are limited to a maximum of 255 channels.\n- If a cluster is transported through a Feature Unit, only a maximum of 61 channels + “cluster channel 0” can be controlled by the Feature Unit.\n- On a standard USB device there are a maximum of 255 total strings available to the entire device. A device cannot provide names for 255 channels in addition to common strings like device name, manufacturer name, and serial number.\n\n## Endpoint Synchronization types\n\nThe *Universal Serial Bus Specification, Revision 2.0* and the *Universal Serial Bus 3.n Specifications* specify that USB Isochronous endpoints have one of four Synchronization Types:\n\n\n\n### Adaptive data endpoints\n\nYour device can use an Adaptive data endpoint to adapt to the data rate the host sends or receives.\n\nFor example, some early ADC1 USB Audio speakers indicate that they can receive output data at any rate from 5 to 50 kHz. The OUT endpoint does not have to be programmed to receive a specific rate. If the host sends data at 48 kHz, the device must render it at 48 kHz. If the host sends data at 12 kHz, the device must render it at 12 kHz etc.\n\nPer the USB Core Specification 5.12.4.1, a device that uses an Adaptive IN streaming endpoint should also provide an explicit feedback endpoint. The Apple USB Audio driver does not support adaptive feedback endpoints. Adaptive IN streaming endpoints are treated the same as asynchronous IN streaming endpoints.\n\nADC2 introduced Clock Source entities to address some of the shortcomings with Adaptive Data Endpoints. The Audio Device Class 4 specification, **Section 3.11.4.2** specifically states that this type of endpoint is not recommended for implementation.\n\n### Synchronous data endpoints\n\nIf your device specifies a Synchronous data endpoint, the audio data transferred on that endpoint must be synchronous with the USB SOF clock. Your device must use the USB SOF to discipline and lock the audio clock to the SOF, or implement an Asynchronous Sample Rate Converter (ASRC) to adjust the rate of audio data to match the SOF rate.\n\nFor example, if a device is using a sample rate of 48 kHz, it should transfer exactly 48 audio samples every millisecond as defined by the SOF tokens on the bus. If it is on a High Speed bus with a polling interval of 125 µs, it should transfer exactly 6 samples every 125 µs.\n\nThe *USB Audio* specification does allow for a Virtual Frame Packet (VFP) of the nominal rate ±1 but a carefully designed device should be able to transfer exactly the nominal sample rate if that sample rate is divisible by the transfer interval timing. See section **2.3.1.1 USB Packets** in *Universal Serial Bus Device Class Definition for Audio Data Formats, Release 2.0*.\n\n#### Asynchronous data endpoints\n\nIf your device specifies an Asynchronous data endpoint, then the data flow will be asynchronous to the USB SOF clock.\n\nFor audio input streams (from device to host), the host adapts to the incoming data rate within the tolerance required by the ADC specification. For example, if an input stream is clocked at 48 kHz, your device must provide between 47 and 49 audio samples every millisecond. If the polling interval is 125 µs, your device must deliver between 5 and 7 samples every microframe, and the total number of samples in 8 microframes must remain between 47 and 49. See section **2.3.1.1 USB Packets** in *Universal Serial Bus Device Class Definition for Audio Data Formats, Release 2.0* for more information on this requirement.\n\nFor audio output streams (from host to device), your device must provide a way for the device to provide feedback to the host for the desired sample rate. There are two types of feedback:\n\n\n\n#### Explicit feedback\n\nExplicit Feedback uses an Isochronous IN Endpoint with a Synchronization Type of No Synchronization. This is an IN endpoint which is part of the same Interface as the data OUT endpoint. The maxPacketSize of the explicit feedback endpoint depends on the speed of the bus and is not related to the version of the ADC specification.\n\nFeedback reporting for Full Speed and High Speed buses must comply with section **5.12.4.2 Feedback** of the *Universal Serial Bus Specification, Revision 2.0*\n\n\n\nFeedback reporting for a SuperSpeed endpoint must comply with section **4.4.8.4.1 Explicit Feedback** of the *Universal Serial Bus 3.2 Specification, Revision 1.0*\n\n\n\n### Implicit feedback\n\nYour device can support implicit feedback if it has input and output streams and both are on the same clock. If the data endpoint on the input stream has a Usage Type of Implicit feedback Data endpoint, the host uses the data rate on the audio input stream to provide the data rate on the audio output stream. It is important that your device produces input data at a consistent rate as quickly as possible after the stream starts. The Apple USB Audio driver does not begin transmitting data on the output stream until it has received consistent clock data from the input stream.\n\n## Audio Device Class entity support\n\nThe following section outlines Audio Device Class entities, the version of the specification that describes them, and the Apple operating system support.\n\n### Input and Output Terminals\n\nTerminals are the interface between the physical world and the logical audio function. Terminals are fully supported by macOS, iOS and iPadOS.\n\n### Terminal Controls\n\n\n\n### Terminal Connector Control\n\nIf your audio device has a headset connector with jack detection, use this control to indicate to the OS that input or output channels are in use by the customer. This is used by the operating system to automatically route audio to or from the device.\n\n\n\n### Input Terminal Phantom Power Control\n\nInput Terminals only. Your device can expose phantom power control to macOS. Customers can enable or disable this control through apps like Audio MIDI Setup or Logic Pro for Mac. This is implemented using the Core Audio control `kAudioPhantomPowerControlClassID`.\n\n### Feature Units\n\nFeature Units describe signal processing capabilities on channels in an audio cluster.\n\n### Feature Unit Controls\n\n\n\n### Mute Control\n\nThe user interface on macOS, iOS, and iPadOS exposes the Mute control on the Feature Unit closest to the physical output of the audio function. If a Feature Unit is immediately upstream of a Mixer Unit, between a physical input (for example, a microphone) and a physical output (for example, speakers), it is used to create a control to enable mixing of audio from the input with other audio flowing to the output. This is published to customers as a **Thru** control in Audio MIDI Setup on macOS, or as a programmable side tone control with no user interface on iOS.\n\n### Volume Control\n\nThe user interface on macOS, iOS, and iPadOS exposes the Volume control on the Feature Unit closest to the physical output of the audio function. If a Feature Unit is immediately upstream of a Mixer Unit, between a physical input (for example, a microphone) and a physical output (for example, speakers), it controls the gain on the physical input signal going into the Mixer Unit. macOS, iOS, or iPadOS does not provide a user interface for sidetone gain.\n\n### Phase Inverter Control\n\nSupported on macOS for ADC2 and ADC3 devices only. Supported on macOS Tahoe 26 and later, and can be accessed by applications using the Core Audio control  `kAudioPhaseInvertControlClassID`.\n\n### High-Pass Filter Control\n\nSupported on macOS for ADC2 devices only. Support is new with macOS Tahoe 26 and can be implemented by applications using the Core Audio control `kAudioHighPassFilterControlClassID`.\n\n### Mixer Unit\n\nMixer Units mix multiple input cluster channels into a single output cluster. Given *N* input channels and *M* output channels, a Mixer Unit provides *N × M* controls to describe how each input channel is mixed to an output channel.\n\nApple operating systems will not manipulate Mixer Units in your device and they will remain in their default state.\n\n### Mixer Unit Controls\n\n\n\n### Selector Unit\n\nSelector Units have multiple input clusters and a single output cluster. The Selector Unit selects one of the input clusters to be sent on the output cluster. On macOS, you can make a selection in the Audio MIDI Setup app. If you use this functionality in your USB audio device, provide a name for each of the clusters entering the Selector Unit by naming the entity, usually the Input Terminal, from which the cluster originates.\n\n### Selector Unit Controls\n\n\n\n### Selector Unit Selector Control\n\nThe Selector Control determines which of the input clusters is presented on the output cluster.\n\n\n\n### Processing Unit\n\nApple operating systems do not support Processing Units or controls on them. Processing Units in an active data path will remain in their default state, which should be disabled. There are multiple Processing Units defined in the ADC specifications (Up\/Down Mix, Dolby Prologic, etc.).\n\n### Extension Unit\n\nApple operating systems do not support Extension Units. Extension Units in an active data path will remain in their default state, which should be disabled. Extension Units cannot be enabled through the Apple USB Audio driver.\n\n### Effect Unit\n\nApple operating systems do not support Effect Units or controls on them. Effect Units in an active data path will remain in their default state, which should be disabled. There are multiple Effect Units defined in the ADC specifications (Parametric Equalizer, Reverberation, etc.).\n\n### Clock Source\n\nClock Sources were introduced in the ADC2 specification and describe the behavior of a clock. They are fully supported by Apple operating systems.\n\n### Clock Source controls\n\n\n\n### Clock Source Frequency Control\n\nSets the frequency of the Clock Source. For Read Only clocks (for example, an external SPDIF clock), use this control to report the current frequency setting of the Clock Source.\n\n### Clock Source Validity Control\n\nUse the Validity control to describe if a Clock Source has a valid clock on its output pin.\n\n\n\n### Clock Selector\n\nClock Selectors were introduced in the ADC2 specification and provide a selection between different Clock Source entities and a Terminal. On macOS, you can make a selection in the Audio MIDI Setup app.\n\n### Clock Selector Controls\n\n\n\n### Clock Selector Selector Control\n\nUse a Selector control to select one of the input pins on the Clock Selector of your device. Changing a selection removes and recreates the Core Audio formats associated with the Core Audio device.\n\n### Clock Multiplier\n\nThe Clock Multplier is described in ADC1-3 and has been deprecated in ADC4. Apple operating systems do not support Clock Multipliers.\n\n### Sampling Rate Converter\n\nApple operating systems do not support Sample Rate Converter (SRC) entities. SRC entities provide a mechanism to describe that data is being converted in your device from one clock domain to another.\n\n### Connectors descriptor (ADC3) and Connector Entity Descriptor (ADC4)\n\nApple operating systems do not support these descriptors.\n\n\n\n### Power Domain\n\nApple operating systems do not support Power Domains. This concept was introduced in the ADC3 specification, to allow for entities to be grouped into Power Domains which can be placed into a low power mode.\n\n## Audio Streaming Interface Class Specific Descriptors\n\nThe USB Audio Device Class Specification describes the following descriptors.\n\n### Class-Specific AS Encoder Descriptor\n\nThe Class-Specific AS Encoder Descriptor is not supported by Apple operating systems. If present, it will be ignored.\n\n### Class-Specific AS Decoder Descriptor\n\nThe Class-Specific AS Decoder Descriptor is not supported by Apple operating systems. If present, it will be ignored.\n\n### Class-Specific AS Valid Frequency Range Descriptor\n\nThe Class-Specific AS Valid Frequency Range Descriptor is not supported by Apple operating systems. This descriptor, introduced in ADC3, allows your device to specify available *Clock Source* frequency ranges on each Alternate Setting of a Streaming Interface.\n\n## Audio Streaming Interface Controls\n\nThe USB Audio Device Class Specification describes the following controls.\n\n### Active Alternate Setting Control\n\nThe Active Alternate Setting Control was introduced in ADC2 and is fully supported by Apple operating systems.\n\n### Valid Alternate Settings Control\n\nThe Valid Alternate Settings Control was introduced in ADC2 and is fully supported by Apple operating systems.\n\n### Audio Data Format Control\n\nThe Audio Data Format Control is not supported by Apple operating systems.\n\n## Device Naming\n\nEach audio device attached to an Apple host has two name properties associated with it:\n\n\n\nThe construction of these properties is described further below.\n\n### Device UID (kAudioDevicePropertyDeviceUID)\n\nFor USB audio devices, the `kAudioDevicePropertyDeviceUID` property conforms to the following layout:\n\nAppleUSBAudioEngine:<Company Name>:<Device Name>:<Serial # or LocationID>:N[,M]\n\n\n\n\n\n\n\n### Customer visible name (kAudioDevicePropertyDeviceName)\n\nThe Apple USB audio driver determines the name string of your devices using the following sequence:\n\n1. If all of the streaming interfaces in an audio function are on the same clock, **and** there is more than one streaming interface, **and** the Control Interface has a string represented in the *iInterface* field of that Control Interface, then that string is used to name the device.\n2. If that fails, and there is at least one Output Streaming Interface, then the *iInterface* string of the **first** Output Streaming Interface is used.\n3. If that fails, and there is at least one Input Streaming Interface, then the *iInterface* string of the **first** Input Streaming Interface is used.\n4. If that fails and the Control Interface has an *iInterface* string, it is used.\n5. If that fails, the *iProduct* name from the Device Descriptor is used.\n6. If all of the above fails, the name “USB Audio Device” is used.\n\nYou should avoid generic names like “USB Audio Device”.\n\n## Supported audio formats\n\nThe Apple USB Audio driver supports the following audio data formats.\n\n\n\n## Specifying channel locations to Core Audio\n\n### ADC1\/ADC2 spatial designations to Core Audio Channel Labels\n\nADC1 provides 12 spatial location positions for Clusters. ADC2 preserves those same 12 locations and provides 15 more, for a total of 27 spatial locations. The following table shows the mapping between USB ADC1 and ADC2 spatial locations and the Audio Channel Labels used in Core Audio.\n\n\n\n\n\n### Designing a device to meet predefined layouts in Core Audio\n\nCore Audio has predefined Layout Tags (see *AudioChannelLayoutTag*). Your device can specify its output channels such that it will automatically be recognized as one of the following predefined layouts.\n\n### kAudioChannelLayoutTag_Atmos_5_1_2\n\n\n\n### kAudioChannelLayoutTag_Atmos_5_1_4\n\n\n\n### kAudioChannelLayoutTag_Atmos_7_1_2\n\n\n\n### kAudioChannelLayoutTag_Atmos_7_1_4\n\n\n\n### kAudioChannelLayoutTag_Atmos_9_1_6\n\n\n\n## Extending the Apple USB Audio class driver\n\nYou can augment the Apple USB Audio class driver by providing a codeless driver extension (dext) with a property list file that uses the `com.apple.driver.AppleUSBMergeNub` driver in the kernel to add one or more of these properties to the [https:\/\/developer.apple.com\/documentation\/usbdriverkit\/iousbhostdevice] service or the [https:\/\/developer.apple.com\/documentation\/usbdriverkit\/iousbhostinterface] service for your device:\n\n- `IOAudioDeviceConfigurationApplication`\n- `IOAudioEngineInputSampleLatency`\n- `IOAudioEngineOutputSampleLatency`\n- `IOAudioEngineIsHidden`\n- `InhibitAudioClassDriver`\n\n### IOAudioDeviceConfigurationApplication\n\nThis property, attached to the `IOUSBHostDevice` service, specifies the Bundle ID of your device’s configuration app. Customers can use this to launch your app via Audio MIDI Setup’s “*Configure device…*” pop-up menu.\n\n```xml\n<key>IOAudioDeviceConfigurationApplication<\/key>\n<string>com.example.configuration.application.bundleid<\/string>\n```\n\n### Latency Controls\n\nThe Apple USB audio driver supports the standard Latency Control defined in ADC2 **Section 5.2.4.8**. Your device should report latency using the Latency Control instead of the following mechanism. For existing devices that do not support the Latency Control, you can specify your device’s latency using the `IOAudioEngineInputSampleLatency` and `IOAudioEngineOutputSampleLatency` properties.\n\n### IOAudioEngineInputSampleLatency\n\nThis property, attached to the `IOUSBHostInterface` service, specifies the time delay, in samples, between an audio signal being received on a device physical input connector and the sample being transferred to the host over USB. It should be specified for each sample rate that the device supports.\n\n```xml\n<key>IOAudioEngineInputSampleLatency<\/key>\n<dict>\n    <key>192000<\/key>\n    <integer>100<\/integer>\n    <key>176400<\/key>\n    <integer>100<\/integer>\n    <key>96000<\/key>\n    <integer>50<\/integer>\n    <key>88200<\/key>\n    <integer>50<\/integer>\n    <key>48000<\/key>\n    <integer>25<\/integer>\n    <key>44100<\/key>\n    <integer>25<\/integer>\n<\/dict>\n```\n\n### IOAudioEngineOutputSampleLatency\n\nThis property, attached to the `IOUSBHostInterface` service, specifies the time delay, in samples, between an audio sample being received on the device over USB to the signal being presented on a device physical output connector. It should be specified for each sample rate that the device supports.\n\n```xml\n<key>IOAudioEngineOutputSampleLatency<\/key>\n<dict>\n    <key>192000<\/key>\n    <integer>100<\/integer>\n    <key>176400<\/key>\n    <integer>100<\/integer>\n    <key>96000<\/key>\n    <integer>50<\/integer>\n    <key>88200<\/key>\n    <integer>50<\/integer>\n    <key>48000<\/key>\n    <integer>25<\/integer>\n    <key>44100<\/key>\n    <integer>25<\/integer>\n<\/dict>\n```\n\n### IOAudioEngineIsHidden\n\nThis legacy property is deprecated and will be removed in a future operating system release.\n\n### InhibitAudioClassDriver\n\nApple recommends using the built-in audio class driver provided with macOS, iOS, and iPadOS. If your device requires a custom driver, a driver extension (dext) can inhibit the loading of Apple’s USB Audio class driver using standard driver matching. If your driver is an AudioServerPlugin with no dext, you must provide and install a codeless dext to inhibit loading of the Apple USB audio driver.\n\nThis property is attached to the `IOUSBHostDevice` service. The Apple USB Audio driver will not load or provide audio services for the device if this key is set to true.\n\n```xml\n<key>InhibitAudioClassDriver<\/key>\n<true\/>\n```\n\n### Example codeless dext plist\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>CFBundleDevelopmentRegion<\/key>\n    <string>$(DEVELOPMENT_LANGUAGE)<\/string>\n    <key>CFBundleExecutable<\/key>\n    <string>$(EXECUTABLE_NAME)<\/string>\n    <key>CFBundleIdentifier<\/key>\n    <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n    <key>CFBundleInfoDictionaryVersion<\/key>\n    <string>6.0<\/string>\n    <key>CFBundleName<\/key>\n    <string>$(PRODUCT_NAME)<\/string>\n    <key>CFBundlePackageType<\/key>\n    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)<\/string>\n    <key>CFBundleShortVersionString<\/key>\n    <string>1.0<\/string>\n    <key>CFBundleVersion<\/key>\n    <string>1<\/string>\n    <key>IOKitPersonalities<\/key>\n    <dict>\n        <key>Example_Override_IOUSBHostDevice<\/key>\n        <dict>\n            <key>CFBundleIdentifier<\/key>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n            <key>CFBundleIdentifierKernel<\/key>\n            <string>com.apple.driver.AppleUSBMergeNub<\/string>\n            <key>IOClass<\/key>\n            <string>AppleUSBMergeNub<\/string>\n            <key>IOProviderClass<\/key>\n            <string>IOUSBHostDevice<\/string>\n            <key>IOProviderMergeProperties<\/key>\n            <dict>\n                <key>USB Product Name<\/key>\n                <string>Example Overridden Product Name<\/string>\n                <key>IOAudioDeviceConfigurationApplication<\/key>\n                <string>com.example.configuration.application.bundleid<\/string>\n                <key>InhibitAudioClassDriver<\/key>\n                <true\/>\n            <\/dict>\n            <key>IOUserClass<\/key>\n            <string>ExampleUACOverridesCodelessDext<\/string>\n            <key>idProduct<\/key>\n            <integer>XXXX<\/integer>\n            <key>idVendor<\/key>\n            <integer>XXXX<\/integer>\n        <\/dict>\n        <key>Example_Override_IOUSBHostInterface_Streaming_In<\/key>\n        <dict>\n            <key>CFBundleIdentifier<\/key>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n            <key>CFBundleIdentifierKernel<\/key>\n            <string>com.apple.driver.AppleUSBMergeNub<\/string>\n            <key>IOClass<\/key>\n            <string>AppleUSBMergeNub<\/string>\n            <key>IOProviderClass<\/key>\n            <string>IOUSBHostInterface<\/string>\n            <key>IOProviderMergeProperties<\/key>\n            <dict>\n                <key>IOAudioEngineInputSampleLatency<\/key>\n                <dict>\n                    <key>192000<\/key>\n                    <integer>100<\/integer>\n                    <key>176400<\/key>\n                    <integer>100<\/integer>\n                    <key>96000<\/key>\n                    <integer>50<\/integer>\n                    <key>88200<\/key>\n                    <integer>50<\/integer>\n                    <key>48000<\/key>\n                    <integer>25<\/integer>\n                    <key>44100<\/key>\n                    <integer>25<\/integer>\n                <\/dict>\n                <key>USB Interface Name<\/key>\n                <string>Example Overridden Interface Name<\/string>\n            <\/dict>\n            <key>IOUserClass<\/key>\n            <string>ExampleUACOverridesCodelessDext<\/string>\n            <key>bConfigurationValue<\/key>\n            <integer>1<\/integer>\n            <key>bInterfaceNumber<\/key>\n            <integer>2<\/integer>\n            <key>idProduct<\/key>\n            <integer>XXXX<\/integer>\n            <key>idVendor<\/key>\n            <integer>XXXX<\/integer>\n        <\/dict>\n        <key>Example_Override_IOUSBHostInterface_Streaming_Out<\/key>\n        <dict>\n            <key>CFBundleIdentifier<\/key>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER)<\/string>\n            <key>CFBundleIdentifierKernel<\/key>\n            <string>com.apple.driver.AppleUSBMergeNub<\/string>\n            <key>IOClass<\/key>\n            <string>AppleUSBMergeNub<\/string>\n            <key>IOProviderClass<\/key>\n            <string>IOUSBHostInterface<\/string>\n            <key>IOProviderMergeProperties<\/key>\n            <dict>\n                <key>IOAudioEngineOutputSampleLatency<\/key>\n                <dict>\n                    <key>192000<\/key>\n                    <integer>100<\/integer>\n                    <key>176400<\/key>\n                    <integer>100<\/integer>\n                    <key>96000<\/key>\n                    <integer>50<\/integer>\n                    <key>88200<\/key>\n                    <integer>50<\/integer>\n                    <key>48000<\/key>\n                    <integer>25<\/integer>\n                    <key>44100<\/key>\n                    <integer>25<\/integer>\n                <\/dict>\n                <key>USB Interface Name<\/key>\n                <string>Example Overridden Interface Name<\/string>\n            <\/dict>\n            <key>IOUserClass<\/key>\n            <string>ExampleUACOverridesCodelessDext<\/string>\n            <key>bConfigurationValue<\/key>\n            <integer>1<\/integer>\n            <key>bInterfaceNumber<\/key>\n            <integer>1<\/integer>\n            <key>idProduct<\/key>\n            <integer>XXXX<\/integer>\n            <key>idVendor<\/key>\n            <integer>XXXX<\/integer>\n        <\/dict>\n    <\/dict>\n    <key>OSBundleUsageDescription<\/key>\n    <string><\/string>\n<\/dict>\n<\/plist>\n```\n\n## Other matching considerations\n\nBeginning on macOS Tahoe 26, Apple no longer publishes kernel IOServices based on the deprecated IOAudioFamily. If your audio device provides additional, non-class USB interfaces for control, you may need to update your software.\n\nThe following IOServices previously published by AppleUSBAudio.kext are no longer created on macOS Tahoe 26:\n\n- `AppleUSBAudioEngine`\n- `AppleUSBAudioDevice`\n- `AppleUSBAudioStream`\n\nAny properties previously published by those services in the [https:\/\/developer.apple.com\/documentation\/installer_js\/ioregistry] are no longer available.\n\nIf your application depends on AppleUSBAudio.kext IOAudioFamily services, it will need to be updated.\n\nPlease see Developer support below if you need further guidance on making associations between a Core Audio device AudioObjectID and its corresponding USB io_service_t.\n\n## Developer support\n\nIf you have questions regarding USB Audio Class support, please contact Apple through [applefeedback:\/\/new?form_identifier=dev.tech&answers%5B%3Aarea%5D=seedmacos%3Ausbaudio] selecting the following option:\n\nDeveloper Technologies & SDKs > USB Audio\n\nTo learn more about how to use Feedback Assistant, see [https:\/\/developer.apple.com\/bug-reporting\/].\n\n## Revision History\n\n- **2025-10-07** First published. Obsoletes TN2274.\n\n## Latest\n\n- **TN3194: Handling account deletions and revoking tokens for Sign in with Apple**: Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.\n- **TN3193: Managing the on-device foundation model’s context window**: Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.\n- **TN3115: Bluetooth State Restoration app relaunch rules**: Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.\n- **TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key**: Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.\n- **TN3151: Choosing the right networking API**: Learn which networking API is best for you.\n- **TN3111: iOS Wi-Fi API overview**: Explore the various Wi-Fi APIs available on iOS and their expected use cases.\n- **TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS**: Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.\n- **TN3134: Network Extension provider deployment**: Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.\n- **TN3179: Understanding local network privacy**: Learn how local network privacy affects your software.\n- **TN3189: Managing Mail background traffic load**: Identify iOS Mail background traffic and manage its impact on your IMAP server.\n- **TN3187: Migrating to the UIKit scene-based life cycle**: Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.\n- **TN3188: Troubleshooting In-App Purchases availability in the App Store**: Verify your In-App Purchases are approved and available for sale in the App Store.\n- **TN3186: Troubleshooting In-App Purchases availability in the sandbox**: Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.\n- **TN3185: Troubleshooting In-App Purchases availability in Xcode**: Inspect your active StoreKit configuration file for unexpected configurations.\n- **TN3182: Adding privacy tracking keys to your privacy manifest**: Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.",
          "name" : "TN3194: Handling account deletions and revoking tokens for Sign in with Apple",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3194-handling-account-deletions-and-revoking-tokens-for-sign-in-with-apple"
        },
        {
          "description" : "Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.",
          "name" : "TN3193: Managing the on-device foundation model’s context window",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3193-managing-the-on-device-foundation-model-s-context-window"
        },
        {
          "description" : "Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.",
          "name" : "TN3115: Bluetooth State Restoration app relaunch rules",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3115-bluetooth-state-restoration-app-relaunch-rules"
        },
        {
          "description" : "Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.",
          "name" : "TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3192-Migrating-your-app-from-the-deprecated-UIRequiresFullScreen-key"
        },
        {
          "description" : "Learn which networking API is best for you.",
          "name" : "TN3151: Choosing the right networking API",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api"
        },
        {
          "description" : "Explore the various Wi-Fi APIs available on iOS and their expected use cases.",
          "name" : "TN3111: iOS Wi-Fi API overview",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3111-ios-wifi-api-overview"
        },
        {
          "description" : "Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.",
          "name" : "TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3191-imap-extensions-supported-by-mail"
        },
        {
          "description" : "Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.",
          "name" : "TN3134: Network Extension provider deployment",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3134-network-extension-provider-deployment"
        },
        {
          "description" : "Learn how local network privacy affects your software.",
          "name" : "TN3179: Understanding local network privacy",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3179-understanding-local-network-privacy"
        },
        {
          "description" : "Identify iOS Mail background traffic and manage its impact on your IMAP server.",
          "name" : "TN3189: Managing Mail background traffic load",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3189-managing-mail-background-traffic-load"
        },
        {
          "description" : "Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.",
          "name" : "TN3187: Migrating to the UIKit scene-based life cycle",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle"
        },
        {
          "description" : "Verify your In-App Purchases are approved and available for sale in the App Store.",
          "name" : "TN3188: Troubleshooting In-App Purchases availability in the App Store",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3188-troubleshooting-in-app-purchases-availability-in-the-app-store"
        },
        {
          "description" : "Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.",
          "name" : "TN3186: Troubleshooting In-App Purchases availability in the sandbox",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3186-troubleshooting-in-app-purchases-availability-in-the-sandbox"
        },
        {
          "description" : "Inspect your active StoreKit configuration file for unexpected configurations.",
          "name" : "TN3185: Troubleshooting In-App Purchases availability in Xcode",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3185-troubleshooting-in-app-purchases-availability-in-xcode"
        },
        {
          "description" : "Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.",
          "name" : "TN3182: Adding privacy tracking keys to your privacy manifest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3182-adding-privacy-tracking-keys-to-your-privacy-manifest"
        }
      ],
      "title" : "Latest"
    }
  ],
  "source" : "appleJSON",
  "title" : "TN3190: USB audio device design considerations",
  "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3190-USB-audio-device-design-considerations"
}