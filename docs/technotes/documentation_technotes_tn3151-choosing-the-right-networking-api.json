{
  "abstract" : "Learn which networking API is best for you.",
  "codeExamples" : [

  ],
  "contentHash" : "0eb3485c2c7590646454ab37e83e34d36c34a5c29e066a44ec522d2af6909379",
  "crawledAt" : "2025-12-05T09:00:35Z",
  "id" : "CB441D19-4F0C-4D8A-964C-38D95AE6D4AE",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nApple platforms have a wide range of networking APIs, spanning many different frameworks:\n\nWith all that choice, it’s hard to know where to start.  This technote aims to clarify that.  It makes specific recommendations as to which API to use for a given network protocol.  It then discusses [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Alternative-APIs] and some [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Best-practices].\n\nThe focus here is on APIs that allow you to *use* the networking stack.  If you want to *extend* the networking stack—for example, to add support for a custom VPN protocol—implement a Network Extension provider.  For the details, see [doc:\/\/com.apple.documentation\/documentation\/NetworkExtension].\n\n## Recommendations by protocol\n\nThis section lists API recommendations for common network protocols.  Follow the advice for the protocol you’re using:\n\n### HTTP\n\nFor HTTP, including HTTPS, there is one really good choice: Foundation’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/url-loading-system], commonly known as `URLSession`.  It supports all the latest features, including Swift concurrency and the HTTP\/2 and HTTP\/3 protocols.\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#HTTP-alternatives].\n\n`URLSession` background sessions allow your app to run an HTTP transfer that continues even if the app stops running.  This is most important on iOS, tvOS, and watchOS, where the system suspends your app shortly after the user moves it to the background.  To learn more about this feature, see [doc:\/\/com.apple.documentation\/documentation\/Foundation\/downloading-files-in-the-background].  Alternative HTTP APIs don’t support this feature.\n\n### WebSocket\n\nFor WebSocket you have two choices:\n\nUnless you have a specific reason to use `URLSession`, use Network framework for new WebSocket code.\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#WebSocket-alternatives].\n\n### FTP\n\nFTP is a very old and dilapidated protocol.  FTP is inappropriate to use on the modern internet because it provides *no* security.  Because of this, Apple has no supported FTP APIs.\n\nYour best option here is to switch to a newer protocol, like HTTP.  It may require some coordination with your server folks, but that will pay off in the long term.\n\nFor other options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#FTP-alternatives].\n\n### QUIC\n\n[doc:\/\/com.apple.documentation\/documentation\/Network] framework introduced QUIC support in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  It supports both QUIC client and QUIC server development.\n\nThe QUIC protocol has significant advantages over TCP.  If you’re building a custom network protocol, consider using QUIC instead of TCP.\n\n### TCP\n\nFor TCP you have two reasonable options:\n\nNetwork framework is by far the best choice.  BSD Sockets is an acceptable choice if you have compatibility constraints, for example:\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#TCP-alternatives].  If you decide to use BSD Sockets, read [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#BSD-Sockets-best-practices].\n\n### UDP\n\nFor UDP you have two reasonable options:\n\nFor UDP flows—where you have a stream of unicast datagrams flowing between two peers—Network framework is the best choice.  If you use BSD Sockets for this case, you’ll have to do a bunch of extra work.\n\nHowever, not all UDP communication is that straightforward.  UDP also supports multicast, broadcast, and other asymmetric designs.  Network framework supports UDP multicast using the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnectionGroup] class, but that support has limits and, specifically, it does not support UDP broadcast.  If you need something that’s not supported by Network framework, use BSD Sockets.\n\nRegardless of the API you use, if you work with multicast or broadcast UDP on iOS, iPadOS, or visionOS, you must have the multicast networking entitlement.  For the details, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.networking.multicast].\n\nIf your target platform supports local network privacy, multicast and broadcast require local network access.  For more on local network privacy, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy].\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#UDP-alternatives].  If you decide to use BSD Sockets, read [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#BSD-Sockets-best-practices].\n\n### Bonjour service discovery\n\nBonjour is an Apple term for three industry standard technologies: link-local addresses ([http:\/\/www.ietf.org\/rfc\/rfc3927.txt]), multicast DNS ([http:\/\/www.ietf.org\/rfc\/rfc6762.txt]), and DNS-based service discovery ([http:\/\/www.ietf.org\/rfc\/rfc6763.txt]).  Use Bonjour to create network features that work well even if there’s no network infrastructure.  For example, when you browse for network servers using Finder > Go > Connect to Server, you’re using Bonjour.\n\nBonjour enables three fundamental operations:\n\n[doc:\/\/com.apple.documentation\/documentation\/Network] framework is your best option for all three of these operations.\n\nIf you have specialist needs that aren’t covered by Network framework—for example, you want to resolve a service without connecting to it—use the low-level [doc:\/\/com.apple.documentation\/documentation\/dnssd] API.\n\nIf your target platform supports local network privacy, declare your Bonjour service types in the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property.  For more on local network privacy, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy].\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Bonjour-alternatives].\n\n### Peer-to-peer networking\n\nPeer-to-peer Wi-Fi allows you to communicate with nearby devices and accessories without configuring a Wi-Fi network.  Apple platforms support two peer-to-peer Wi-Fi technologies:\n\nTo get started with Wi-Fi Aware, see the [doc:\/\/com.apple.documentation\/documentation\/WiFiAware] framework documentation.  Use this API to set up a peer-to-peer data path and then use a [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Network-framework-API-choices] for the actual data transfer.\n\nApple peer-to-peer Wi-Fi is directly supported by [doc:\/\/com.apple.documentation\/documentation\/Network] framework.  Opt in to peer-to-peer Wi-Fi by setting the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWParameters\/includePeerToPeer] property of the parameters object you use to create your [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Network-framework-API-choices].\n\nTo communicate between a watchOS app and its companion iOS app, use [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity].  In many cases, however, it might be better to have your watchOS app operate independently, using `URLSession` to communicate directly with your server.\n\nTo connect a tvOS app to a mobile device on the local network, use [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI].\n\nIf you’re developing a network-based accessory, consider using Thread.  For more background on this, see [doc:\/\/com.apple.documentation\/documentation\/ThreadNetwork].\n\nSome platforms limit access to the local network; for the details, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy].\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Peer-to-peer-alternatives].\n\n### DNS\n\nIn most cases you don’t need to resolve a DNS address manually.  Rather, use an API with connect-by-name semantics.  For more details, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Connect-by-name].\n\nTo perform advanced DNS operations using the system resolver, use the low-level [doc:\/\/com.apple.documentation\/documentation\/dnssd] API.\n\nTo perform DNS queries without using the system resolver—for example, if you’re building a DNS debugging tool—use the `<dns.h>` and `<dns_util.h>` APIs.\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#DNS-alternatives].\n\n### Wi-Fi\n\niOS supports a number of special-purpose Wi-Fi APIs.  For a summary, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3111-ios-wifi-api-overview].\n\nTo scan for and configure Wi-Fi networks on macOS, use [doc:\/\/com.apple.documentation\/documentation\/CoreWLAN].\n\n## Alternative APIs\n\nMany protocols have alternative APIs, ones that are either deprecated or limited to some specific task.\n\n### HTTP alternatives\n\nApple has two alternative HTTP APIs:\n\nIn some very specific cases, you might find that `URLSession` doesn’t meet your needs.  In such cases, you might be able to work around that limitation using `CFHTTPStream`, or perhaps by building a simplistic HTTP client using `CFHTTPMessage` on top of a TCP API.  However, building a general-purpose HTTP client is hard.  If you need a general-purpose HTTP client and `URLSession` doesn’t work for you, look for a third-party HTTP library.  One good option is the [https:\/\/github.com\/swift-server\/async-http-client] Swift library.\n\n### WebSocket alternatives\n\nBoth of the recommended WebSocket APIs were introduced in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  If you need to support older OS releases, there are a variety of good quality third-party WebSocket libraries available for Apple platforms.\n\nIf you’re currently using a third-party WebSocket library, and your deployment target allows for it, consider moving to [doc:\/\/com.apple.documentation\/documentation\/Network] framework.\n\n### FTP alternatives\n\nApple has two FTP APIs:\n\nDon’t write new code using them.  If you have existing code, you have two options.  The first, and by far the best, is to switch to a newer protocol, like HTTP.\n\nIn some circumstances that may not be possible.  Perhaps you’re working with an accessory that only supports FTP, and you’re unable to convince the vendor to update its firmware.  In that case, you have two options:\n\nIn `URLSession`, FTP downloads are only supported by the classic loading mode, as controlled by [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionConfiguration\/usesClassicLoadingMode].\n\n### TCP alternatives\n\nApple platforms support a variety of alternative TCP APIs:\n\n### UDP alternatives\n\nNetwork Extension in-provider networking includes `NWUDPSession`.  While there are some very limited circumstances where this is still useful, in most cases it’s better to use Network framework.  For more details, see [doc:\/\/com.apple.documentation\/documentation\/NetworkExtension\/in-provider-networking].\n\n### Bonjour alternatives\n\nThere are two older Bonjour APIs:\n\nIn [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions] both of these were marked as to-be-deprecated in favor of Network framework.\n\n### Peer-to-peer alternatives\n\n[doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity] is a high-level API that supports Apple peer-to-peer Wi-Fi.  It includes:\n\nUse it when your requirements are aligned with those features.  Don’t use it if your program uses a client\/server architecture; Network framework works better in that case.  For an example, see [doc:\/\/com.apple.documentation\/documentation\/Network\/building-a-custom-peer-to-peer-protocol].\n\nFoundation also supports Apple peer-to-peer Wi-Fi:\n\nThese APIs were marked as to-be-deprecated in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  If you have existing code that uses them, make a plan to migrate to [doc:\/\/com.apple.documentation\/documentation\/Network] framework.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/dnssd] API supports Apple peer-to-peer Wi-Fi but with an important caveat: If you advertise a service on peer-to-peer Wi-Fi using dnssd, the service’s listener must be run by a peer-to-peer aware API, like `NWListener` or `NSNetService`.  Given that those APIs already have a facility to opt in to Apple peer-to-peer Wi-Fi, there’s very little point using dnssd for this.\n\n### DNS alternatives\n\n`NSHost` supports synchronous DNS name-to-address and address-to-name translation.  It was only ever supported on macOS.\n\n`CFHost` supports DNS name-to-address and address-to-name translation, both synchronously and asynchronously.\n\nBoth of these APIs were marked as to-be-deprecated in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  If you have existing code that uses them, make a plan to migrate to a preferred API.  In many cases that means switching to a connect-by-name API.  See [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Connect-by-name].  For other cases, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#DNS].\n\n## Best practices\n\nApple’s preferred networking APIs, including [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] and [doc:\/\/com.apple.documentation\/documentation\/Network] framework, implement various best practices by default.  If you choose to use an alternative API, you take on the responsibility of implementing these best practices yourself.  This section addresses some of the more common issues.\n\n### Connect by name\n\nTraditionally, you connect to a TCP service using two steps:\n\nThis two-step approach is an anti-pattern on Apple platforms for two reasons:\n\nApple’s preferred networking APIs support connect-by-name semantics, where you pass the API a DNS name and it takes care of all the details.  If you can use a connect-by-name API, do that.  If you can’t—and the prime offender here is BSD Sockets—you’ll have to implement Happy Eyeballs yourself.\n\nSadly, even with all of that extra code, your program will still be incompatible with VPN On Demand.\n\n### BSD Sockets best practices\n\nBSD Sockets has a number of limitations.  Your life will be easier if you use [doc:\/\/com.apple.documentation\/documentation\/Network] framework rather than BSD Sockets.  If that’s not possible—say you’re working on a cross-platform codebase that mandates the use of sockets—apply the following best practices:\n\nIf your primary reason for using BSD Sockets is cross-platform support, consider using a network abstraction layer that adapts to the target platform.  One such option is [https:\/\/github.com\/apple\/swift-nio-transport-services], which makes it straightforward to use Network framework on Apple platforms and BSD Sockets elsewhere.\n\nApple’s BSD Sockets implementation is documented in the man pages.  If you’re unfamiliar with that term, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].  Man pages are notoriously succinct.  If you’re getting started with BSD Sockets, take advantage of the wide range of non-Apple resources out there.  A classic work in the field is the book *UNIX Network Programming* by Stevens et al.\n\nOne traditional challenge with BSD Sockets is how best to handle nonblocking sockets.  For cross-platform code you have all the usual options (`select`, `poll`, `kqueue`).  For Apple-specific code you have one more: a Dispatch read source.  Use this to integrate a nonblocking socket into existing code that uses Dispatch queues.  For more details, see [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/dispatch-source].\n\n### DNS best practices\n\nUse the system DNS resolver.  Implementing your own DNS resolver is extra work, wastes resources, and causes problems in specific network environments.\n\nIf you’re using BSD Sockets, use the `getaddrinfo` and `getnameinfo` APIs.  BSD Sockets has a range of legacy DNS APIs, like `gethostbyname`, that embody known anti-patterns.  For example, `gethostbyname` doesn’t support IPv6 and relies on thread-local storage.\n\nAlso use `getaddrinfo` and `getnameinfo` to convert between strings and IP addresses.  Again, the legacy APIs for this have various problems.  For example, `inet_addr` doesn’t support IPv6 and relies on thread-local storage.  When converting an IP address to a string, pass `AI_NUMERICHOST` and `AI_NUMERICSERV` to `getaddrinfo` to ensure that it doesn’t generate any network traffic.  Likewise, when going the other way, pass `NI_NUMERICHOST` and `NI_NUMERICSERV` to `getnameinfo`.\n\nIf you’re using BSD Sockets and want to resolve a DNS address asynchronously, use [doc:\/\/com.apple.documentation\/documentation\/dnssd\/DNSServiceGetAddrInfo(_:_:_:_:_:_:_:)].\n\n### TLS best practices\n\nApple’s preferred networking APIs, including [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] and [doc:\/\/com.apple.documentation\/documentation\/Network] framework, use a built-in, modern TLS stack.  That’s not available if you use BSD Sockets.  To use TLS in that case, add your own TLS implementation.\n\nMake sure your TLS implementation uses Apple’s trust evaluation infrastructure.  If you implement your own trust evaluation, it won’t match that of the built-in apps, like Safari and Mail.  For more about Apple’s trust evaluation APIs, see [doc:\/\/com.apple.documentation\/documentation\/Security\/trust].\n\nDon’t use [doc:\/\/com.apple.documentation\/documentation\/Security\/secure-transport] for your TLS implementation.  It’s been deprecated since [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions] and doesn’t support TLS 1.3.  If you have existing code that uses Secure Transport, make a plan to migrate off it.\n\n### Network framework API choices\n\nNetwork framework supports three APIs:\n\nUse the C API for all C-based languages, including C, Objective-C, and C++.\n\nThe new Swift API is tightly integrated with the Swift type system and fully supports structured concurrency.\n\n## Versions\n\nNetworking is fundamental to all Apple platforms.  When Apple introduces a new networking API, or adds new support to an existing API, it typically does so on all platforms.  Likewise when Apple deprecates an API.  When this technote covers such topics, it references the year of the OS release.  The following table maps years to OS version numbers:\n\n## Revision History",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api\ncrawled: 2025-12-05T09:00:35Z\n---\n\n# TN3151: Choosing the right networking API\n\n**Article**\n\nLearn which networking API is best for you.\n\n## Overview\n\nApple platforms have a wide range of networking APIs, spanning many different frameworks:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation]\n- [doc:\/\/com.apple.documentation\/documentation\/Network]\n- BSD Sockets in the System framework\n- And more\n\nWith all that choice, it’s hard to know where to start.  This technote aims to clarify that.  It makes specific recommendations as to which API to use for a given network protocol.  It then discusses [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Alternative-APIs] and some [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Best-practices].\n\n\n\nThe focus here is on APIs that allow you to *use* the networking stack.  If you want to *extend* the networking stack—for example, to add support for a custom VPN protocol—implement a Network Extension provider.  For the details, see [doc:\/\/com.apple.documentation\/documentation\/NetworkExtension].\n\n## Recommendations by protocol\n\nThis section lists API recommendations for common network protocols.  Follow the advice for the protocol you’re using:\n\n- **Application Layer:** [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#HTTP], [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#WebSocket], [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#FTP]\n- **Transport Layer:** [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#QUIC], [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#TCP], [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#UDP]\n- **Other:** [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Bonjour-service-discovery], [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#DNS], [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Peer-to-peer-networking], [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Wi-Fi]\n\n### HTTP\n\nFor HTTP, including HTTPS, there is one really good choice: Foundation’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/url-loading-system], commonly known as `URLSession`.  It supports all the latest features, including Swift concurrency and the HTTP\/2 and HTTP\/3 protocols.\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#HTTP-alternatives].\n\n`URLSession` background sessions allow your app to run an HTTP transfer that continues even if the app stops running.  This is most important on iOS, tvOS, and watchOS, where the system suspends your app shortly after the user moves it to the background.  To learn more about this feature, see [doc:\/\/com.apple.documentation\/documentation\/Foundation\/downloading-files-in-the-background].  Alternative HTTP APIs don’t support this feature.\n\n### WebSocket\n\nFor WebSocket you have two choices:\n\n- `URLSession` using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionWebSocketTask]\n- [doc:\/\/com.apple.documentation\/documentation\/Network] framework using a [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Network-framework-API-choices]\n\nUnless you have a specific reason to use `URLSession`, use Network framework for new WebSocket code.\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#WebSocket-alternatives].\n\n### FTP\n\nFTP is a very old and dilapidated protocol.  FTP is inappropriate to use on the modern internet because it provides *no* security.  Because of this, Apple has no supported FTP APIs.\n\nYour best option here is to switch to a newer protocol, like HTTP.  It may require some coordination with your server folks, but that will pay off in the long term.\n\nFor other options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#FTP-alternatives].\n\n### QUIC\n\n[doc:\/\/com.apple.documentation\/documentation\/Network] framework introduced QUIC support in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  It supports both QUIC client and QUIC server development.\n\nThe QUIC protocol has significant advantages over TCP.  If you’re building a custom network protocol, consider using QUIC instead of TCP.\n\n\n\n### TCP\n\nFor TCP you have two reasonable options:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Network] framework using a [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Network-framework-API-choices]\n- BSD Sockets\n\nNetwork framework is by far the best choice.  BSD Sockets is an acceptable choice if you have compatibility constraints, for example:\n\n- When writing cross-platform code\n- When using an existing library that’s based on BSD Sockets\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#TCP-alternatives].  If you decide to use BSD Sockets, read [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#BSD-Sockets-best-practices].\n\n### UDP\n\nFor UDP you have two reasonable options:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Network] framework using a [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Network-framework-API-choices]\n- BSD Sockets\n\nFor UDP flows—where you have a stream of unicast datagrams flowing between two peers—Network framework is the best choice.  If you use BSD Sockets for this case, you’ll have to do a bunch of extra work.\n\nHowever, not all UDP communication is that straightforward.  UDP also supports multicast, broadcast, and other asymmetric designs.  Network framework supports UDP multicast using the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnectionGroup] class, but that support has limits and, specifically, it does not support UDP broadcast.  If you need something that’s not supported by Network framework, use BSD Sockets.\n\n\n\nRegardless of the API you use, if you work with multicast or broadcast UDP on iOS, iPadOS, or visionOS, you must have the multicast networking entitlement.  For the details, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.networking.multicast].\n\nIf your target platform supports local network privacy, multicast and broadcast require local network access.  For more on local network privacy, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy].\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#UDP-alternatives].  If you decide to use BSD Sockets, read [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#BSD-Sockets-best-practices].\n\n### Bonjour service discovery\n\nBonjour is an Apple term for three industry standard technologies: link-local addresses ([http:\/\/www.ietf.org\/rfc\/rfc3927.txt]), multicast DNS ([http:\/\/www.ietf.org\/rfc\/rfc6762.txt]), and DNS-based service discovery ([http:\/\/www.ietf.org\/rfc\/rfc6763.txt]).  Use Bonjour to create network features that work well even if there’s no network infrastructure.  For example, when you browse for network servers using Finder > Go > Connect to Server, you’re using Bonjour.\n\nBonjour enables three fundamental operations:\n\n- Advertise, to publish a service on the network so that clients can find it by browsing\n- Browse, to browse for services on a network so that the user can choose a service\n- Connect, to connect to a service chosen by the user\n\n[doc:\/\/com.apple.documentation\/documentation\/Network] framework is your best option for all three of these operations.\n\nIf you have specialist needs that aren’t covered by Network framework—for example, you want to resolve a service without connecting to it—use the low-level [doc:\/\/com.apple.documentation\/documentation\/dnssd] API.\n\nIf your target platform supports local network privacy, declare your Bonjour service types in the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSBonjourServices] property.  For more on local network privacy, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy].\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Bonjour-alternatives].\n\n### Peer-to-peer networking\n\nPeer-to-peer Wi-Fi allows you to communicate with nearby devices and accessories without configuring a Wi-Fi network.  Apple platforms support two peer-to-peer Wi-Fi technologies:\n\n- Wi-Fi Aware™ (also known as Neighbor Awareness Networking or NAN)\n- Apple peer-to-peer Wi-Fi\n\nTo get started with Wi-Fi Aware, see the [doc:\/\/com.apple.documentation\/documentation\/WiFiAware] framework documentation.  Use this API to set up a peer-to-peer data path and then use a [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Network-framework-API-choices] for the actual data transfer.\n\nApple peer-to-peer Wi-Fi is directly supported by [doc:\/\/com.apple.documentation\/documentation\/Network] framework.  Opt in to peer-to-peer Wi-Fi by setting the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWParameters\/includePeerToPeer] property of the parameters object you use to create your [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Network-framework-API-choices].\n\n\n\nTo communicate between a watchOS app and its companion iOS app, use [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity].  In many cases, however, it might be better to have your watchOS app operate independently, using `URLSession` to communicate directly with your server.\n\nTo connect a tvOS app to a mobile device on the local network, use [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI].\n\nIf you’re developing a network-based accessory, consider using Thread.  For more background on this, see [doc:\/\/com.apple.documentation\/documentation\/ThreadNetwork].\n\nSome platforms limit access to the local network; for the details, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy].\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Peer-to-peer-alternatives].\n\n### DNS\n\nIn most cases you don’t need to resolve a DNS address manually.  Rather, use an API with connect-by-name semantics.  For more details, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Connect-by-name].\n\nTo perform advanced DNS operations using the system resolver, use the low-level [doc:\/\/com.apple.documentation\/documentation\/dnssd] API.\n\nTo perform DNS queries without using the system resolver—for example, if you’re building a DNS debugging tool—use the `<dns.h>` and `<dns_util.h>` APIs.\n\n\n\nFor more options, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#DNS-alternatives].\n\n### Wi-Fi\n\niOS supports a number of special-purpose Wi-Fi APIs.  For a summary, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3111-ios-wifi-api-overview].\n\nTo scan for and configure Wi-Fi networks on macOS, use [doc:\/\/com.apple.documentation\/documentation\/CoreWLAN].\n\n## Alternative APIs\n\nMany protocols have alternative APIs, ones that are either deprecated or limited to some specific task.\n\n### HTTP alternatives\n\nApple has two alternative HTTP APIs:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSURLConnection] is the predecessor to `URLSession`.  It’s been redundant since the introduction of `URLSession` in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  It was formally deprecated in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  Don’t use it for new code.  If you have existing `NSURLConnection` code, make a plan to migrate to `URLSession`.\n- `CFHTTPStream`, part of the CFNetwork framework, has been deprecated since [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  Avoid using it in new code.  If you have existing `CFHTTPStream` code, make a plan to migrate to something more modern.  Typically, that’s `URLSession`.\n\nIn some very specific cases, you might find that `URLSession` doesn’t meet your needs.  In such cases, you might be able to work around that limitation using `CFHTTPStream`, or perhaps by building a simplistic HTTP client using `CFHTTPMessage` on top of a TCP API.  However, building a general-purpose HTTP client is hard.  If you need a general-purpose HTTP client and `URLSession` doesn’t work for you, look for a third-party HTTP library.  One good option is the [https:\/\/github.com\/swift-server\/async-http-client] Swift library.\n\n\n\n### WebSocket alternatives\n\nBoth of the recommended WebSocket APIs were introduced in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  If you need to support older OS releases, there are a variety of good quality third-party WebSocket libraries available for Apple platforms.\n\nIf you’re currently using a third-party WebSocket library, and your deployment target allows for it, consider moving to [doc:\/\/com.apple.documentation\/documentation\/Network] framework.\n\n### FTP alternatives\n\nApple has two FTP APIs:\n\n- `URLSession` for FTP downloads, deprecated since [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions]\n- `CFFTPStream`, deprecated since [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions]\n\nDon’t write new code using them.  If you have existing code, you have two options.  The first, and by far the best, is to switch to a newer protocol, like HTTP.\n\nIn some circumstances that may not be possible.  Perhaps you’re working with an accessory that only supports FTP, and you’re unable to convince the vendor to update its firmware.  In that case, you have two options:\n\n- Write your own FTP protocol implementation.\n- Adopt a third-party FTP library.\n\n\n\nIn `URLSession`, FTP downloads are only supported by the classic loading mode, as controlled by [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionConfiguration\/usesClassicLoadingMode].\n\n### TCP alternatives\n\nApple platforms support a variety of alternative TCP APIs:\n\n- `CFSocketStream` was marked as to-be-deprecated in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  Apple will not enhance it to support new features.  For example, Apple added TLS 1.3 support to Network framework in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions], but has not added it to `CFSocketStream`.\n- The TCP networking support in `NSStream`, most notably [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Stream\/getStreamsToHost(withName:port:inputStream:outputStream:)], is layered on top of `CFSocketStream` and is on the same deprecation path.\n- It’s possible to use [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle] for networking in conjunction with BSD Sockets.  While this is still supported, it’s not recommended for all the same reasons that BSD Sockets is not recommended.  See [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#BSD-Sockets-best-practices].\n- [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CFSocket] is much like `FileHandle`: It’s possible to use it to run a TCP connection, but it has all the same limitations as BSD Sockets.\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionStreamTask] is much like `URLSessionWebSocketTask`: Unless you have a specific reason to use `URLSession`, use Network framework instead.\n- Network Extension in-provider networking includes `NWTCPConnection`.  While there are some very limited circumstances where this is still useful, in most cases it’s better to use Network framework.  For more details, see [doc:\/\/com.apple.documentation\/documentation\/NetworkExtension\/in-provider-networking].\n- Foundation has a number of classes, like `NSConnection` and `NSSocketPort`, that *seem* like they might be useful for TCP networking.  They are not.  These are part of Foundation’s legacy Distributed Objects (DO) system.  DO was never a good choice for networking; moreover, it was formally deprecated in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].\n\n### UDP alternatives\n\nNetwork Extension in-provider networking includes `NWUDPSession`.  While there are some very limited circumstances where this is still useful, in most cases it’s better to use Network framework.  For more details, see [doc:\/\/com.apple.documentation\/documentation\/NetworkExtension\/in-provider-networking].\n\n### Bonjour alternatives\n\nThere are two older Bonjour APIs:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NetService]\n- [doc:\/\/com.apple.documentation\/documentation\/CFNetwork\/CFNetService]\n\nIn [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions] both of these were marked as to-be-deprecated in favor of Network framework.\n\n### Peer-to-peer alternatives\n\n[doc:\/\/com.apple.documentation\/documentation\/MultipeerConnectivity] is a high-level API that supports Apple peer-to-peer Wi-Fi.  It includes:\n\n- A very opinionated networking model, where every participant in a session is a symmetric peer\n- User interface components for advertising and joining a session\n\nUse it when your requirements are aligned with those features.  Don’t use it if your program uses a client\/server architecture; Network framework works better in that case.  For an example, see [doc:\/\/com.apple.documentation\/documentation\/Network\/building-a-custom-peer-to-peer-protocol].\n\n\n\nFoundation also supports Apple peer-to-peer Wi-Fi:\n\n- When advertising a service using `NSNetService`, set the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NetService\/includesPeerToPeer] property.\n- To accept connections, set the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NetService\/Options\/listenForConnections] flag and implement the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NetServiceDelegate\/netService(_:didAcceptConnectionWith:outputStream:)] delegate callback.\n- When browsing for services using `NSNetServiceBrowser`, set the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NetServiceBrowser\/includesPeerToPeer] property.\n- After discovering a service with a peer-to-peer enabled browser, connect to that service using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NetService\/getInputStream(_:outputStream:)].\n\nThese APIs were marked as to-be-deprecated in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  If you have existing code that uses them, make a plan to migrate to [doc:\/\/com.apple.documentation\/documentation\/Network] framework.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/dnssd] API supports Apple peer-to-peer Wi-Fi but with an important caveat: If you advertise a service on peer-to-peer Wi-Fi using dnssd, the service’s listener must be run by a peer-to-peer aware API, like `NWListener` or `NSNetService`.  Given that those APIs already have a facility to opt in to Apple peer-to-peer Wi-Fi, there’s very little point using dnssd for this.\n\n### DNS alternatives\n\n`NSHost` supports synchronous DNS name-to-address and address-to-name translation.  It was only ever supported on macOS.\n\n`CFHost` supports DNS name-to-address and address-to-name translation, both synchronously and asynchronously.\n\nBoth of these APIs were marked as to-be-deprecated in [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions].  If you have existing code that uses them, make a plan to migrate to a preferred API.  In many cases that means switching to a connect-by-name API.  See [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Connect-by-name].  For other cases, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#DNS].\n\n## Best practices\n\nApple’s preferred networking APIs, including [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] and [doc:\/\/com.apple.documentation\/documentation\/Network] framework, implement various best practices by default.  If you choose to use an alternative API, you take on the responsibility of implementing these best practices yourself.  This section addresses some of the more common issues.\n\n### Connect by name\n\nTraditionally, you connect to a TCP service using two steps:\n\n1. Resolve the DNS name to a set of IPv4 and IPv6 addresses.\n2. Connect to one of those addresses.\n\nThis two-step approach is an anti-pattern on Apple platforms for two reasons:\n\n- It doesn’t support on-demand connections, such as VPN On Demand.\n- It’s hard to implement the second step correctly.  The industry standard for this is called the *Happy Eyeballs* algorithm ([https:\/\/tools.ietf.org\/html\/rfc8305]).  It’s a non-trivial amount of work.\n\nApple’s preferred networking APIs support connect-by-name semantics, where you pass the API a DNS name and it takes care of all the details.  If you can use a connect-by-name API, do that.  If you can’t—and the prime offender here is BSD Sockets—you’ll have to implement Happy Eyeballs yourself.\n\nSadly, even with all of that extra code, your program will still be incompatible with VPN On Demand.\n\n### BSD Sockets best practices\n\nBSD Sockets has a number of limitations.  Your life will be easier if you use [doc:\/\/com.apple.documentation\/documentation\/Network] framework rather than BSD Sockets.  If that’s not possible—say you’re working on a cross-platform codebase that mandates the use of sockets—apply the following best practices:\n\n- If you’re using BSD Sockets to implement a URL loading library, think about whether it should be subject to URL filtering.  If so, call [doc:\/\/com.apple.documentation\/documentation\/NetworkExtension\/NEURLFilter] to determine whether to load the URL or not.\n- Implement your own connect-by-name semantics.  If you don’t do this, your program might fail to connect, or connect very slowly, in adverse network conditions.  For more details, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Connect-by-name].\n- For each socket that makes on outgoing connection, call `ne_socket_set_domains`, declared in `<networkext\/ne_socket.h>`, to associated the socket with its original DNS name.  This gives network infrastructure, like content filters, more information about the context of the connection.\n- Write code that supports both IPv4 and IPv6.  Test that code on an IPv6-only network.  See [https:\/\/developer.apple.com\/library\/archive\/documentation\/NetworkingInternetWeb\/Conceptual\/NetworkingOverview\/UnderstandingandPreparingfortheIPv6Transition\/UnderstandingandPreparingfortheIPv6Transition.html#\/\/apple_ref\/doc\/uid\/TP40010220-CH213-SW16].\n- Use the system DNS resolver.  For more on this, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#DNS-best-practices].\n- BSD Sockets does not support TLS directly.  If you want secure connections, and really you should, add your own TLS implementation.  For more on this, see [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#TLS-best-practices].\n- Once you’ve established a connection, use [doc:\/\/com.apple.documentation\/documentation\/SystemConfiguration\/SCNetworkReachabilityCreateWithAddressPair(_:_:_:)] to monitor its viability.  Without this, your program won’t notice that a connection is stuck due to a TCP\/IP stack reconfiguration.\n\n\n\n\n\nIf your primary reason for using BSD Sockets is cross-platform support, consider using a network abstraction layer that adapts to the target platform.  One such option is [https:\/\/github.com\/apple\/swift-nio-transport-services], which makes it straightforward to use Network framework on Apple platforms and BSD Sockets elsewhere.\n\nApple’s BSD Sockets implementation is documented in the man pages.  If you’re unfamiliar with that term, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].  Man pages are notoriously succinct.  If you’re getting started with BSD Sockets, take advantage of the wide range of non-Apple resources out there.  A classic work in the field is the book *UNIX Network Programming* by Stevens et al.\n\nOne traditional challenge with BSD Sockets is how best to handle nonblocking sockets.  For cross-platform code you have all the usual options (`select`, `poll`, `kqueue`).  For Apple-specific code you have one more: a Dispatch read source.  Use this to integrate a nonblocking socket into existing code that uses Dispatch queues.  For more details, see [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/dispatch-source].\n\n\n\n### DNS best practices\n\nUse the system DNS resolver.  Implementing your own DNS resolver is extra work, wastes resources, and causes problems in specific network environments.\n\nIf you’re using BSD Sockets, use the `getaddrinfo` and `getnameinfo` APIs.  BSD Sockets has a range of legacy DNS APIs, like `gethostbyname`, that embody known anti-patterns.  For example, `gethostbyname` doesn’t support IPv6 and relies on thread-local storage.\n\nAlso use `getaddrinfo` and `getnameinfo` to convert between strings and IP addresses.  Again, the legacy APIs for this have various problems.  For example, `inet_addr` doesn’t support IPv6 and relies on thread-local storage.  When converting an IP address to a string, pass `AI_NUMERICHOST` and `AI_NUMERICSERV` to `getaddrinfo` to ensure that it doesn’t generate any network traffic.  Likewise, when going the other way, pass `NI_NUMERICHOST` and `NI_NUMERICSERV` to `getnameinfo`.\n\nIf you’re using BSD Sockets and want to resolve a DNS address asynchronously, use [doc:\/\/com.apple.documentation\/documentation\/dnssd\/DNSServiceGetAddrInfo(_:_:_:_:_:_:_:)].\n\n### TLS best practices\n\nApple’s preferred networking APIs, including [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] and [doc:\/\/com.apple.documentation\/documentation\/Network] framework, use a built-in, modern TLS stack.  That’s not available if you use BSD Sockets.  To use TLS in that case, add your own TLS implementation.\n\nMake sure your TLS implementation uses Apple’s trust evaluation infrastructure.  If you implement your own trust evaluation, it won’t match that of the built-in apps, like Safari and Mail.  For more about Apple’s trust evaluation APIs, see [doc:\/\/com.apple.documentation\/documentation\/Security\/trust].\n\nDon’t use [doc:\/\/com.apple.documentation\/documentation\/Security\/secure-transport] for your TLS implementation.  It’s been deprecated since [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api#Versions] and doesn’t support TLS 1.3.  If you have existing code that uses Secure Transport, make a plan to migrate off it.\n\n### Network framework API choices\n\nNetwork framework supports three APIs:\n\n\n\nUse the C API for all C-based languages, including C, Objective-C, and C++.\n\nThe new Swift API is tightly integrated with the Swift type system and fully supports structured concurrency.\n\n## Versions\n\nNetworking is fundamental to all Apple platforms.  When Apple introduces a new networking API, or adds new support to an existing API, it typically does so on all platforms.  Likewise when Apple deprecates an API.  When this technote covers such topics, it references the year of the OS release.  The following table maps years to OS version numbers:\n\n\n\n## Revision History\n\n- **2025-09-05** Added links to [doc:\/\/com.apple.technotes\/documentation\/Technotes\/tn3179-understanding-local-network-privacy].  Added links to the Network framework Swift API introduced in 2025.  Added information about Wi-Fi Aware.  Updated “BSD Sockets best practices” to discuss `NEURLFilter` and `ne_socket_set_domains`.  Updated the version list.  Made other editorial changes.\n- **2023-09-19** Added information about `CFSocket`.\n- **2023-06-06** First published.\n\n## Latest\n\n- **TN3190: USB audio device design considerations**: Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.\n- **TN3194: Handling account deletions and revoking tokens for Sign in with Apple**: Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.\n- **TN3193: Managing the on-device foundation model’s context window**: Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.\n- **TN3115: Bluetooth State Restoration app relaunch rules**: Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.\n- **TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key**: Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.\n- **TN3111: iOS Wi-Fi API overview**: Explore the various Wi-Fi APIs available on iOS and their expected use cases.\n- **TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS**: Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.\n- **TN3134: Network Extension provider deployment**: Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.\n- **TN3179: Understanding local network privacy**: Learn how local network privacy affects your software.\n- **TN3189: Managing Mail background traffic load**: Identify iOS Mail background traffic and manage its impact on your IMAP server.\n- **TN3187: Migrating to the UIKit scene-based life cycle**: Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.\n- **TN3188: Troubleshooting In-App Purchases availability in the App Store**: Verify your In-App Purchases are approved and available for sale in the App Store.\n- **TN3186: Troubleshooting In-App Purchases availability in the sandbox**: Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.\n- **TN3185: Troubleshooting In-App Purchases availability in Xcode**: Inspect your active StoreKit configuration file for unexpected configurations.\n- **TN3182: Adding privacy tracking keys to your privacy manifest**: Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.",
          "name" : "TN3190: USB audio device design considerations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3190-USB-audio-device-design-considerations"
        },
        {
          "description" : "Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.",
          "name" : "TN3194: Handling account deletions and revoking tokens for Sign in with Apple",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3194-handling-account-deletions-and-revoking-tokens-for-sign-in-with-apple"
        },
        {
          "description" : "Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.",
          "name" : "TN3193: Managing the on-device foundation model’s context window",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3193-managing-the-on-device-foundation-model-s-context-window"
        },
        {
          "description" : "Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.",
          "name" : "TN3115: Bluetooth State Restoration app relaunch rules",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3115-bluetooth-state-restoration-app-relaunch-rules"
        },
        {
          "description" : "Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.",
          "name" : "TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3192-Migrating-your-app-from-the-deprecated-UIRequiresFullScreen-key"
        },
        {
          "description" : "Explore the various Wi-Fi APIs available on iOS and their expected use cases.",
          "name" : "TN3111: iOS Wi-Fi API overview",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3111-ios-wifi-api-overview"
        },
        {
          "description" : "Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.",
          "name" : "TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3191-imap-extensions-supported-by-mail"
        },
        {
          "description" : "Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.",
          "name" : "TN3134: Network Extension provider deployment",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3134-network-extension-provider-deployment"
        },
        {
          "description" : "Learn how local network privacy affects your software.",
          "name" : "TN3179: Understanding local network privacy",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3179-understanding-local-network-privacy"
        },
        {
          "description" : "Identify iOS Mail background traffic and manage its impact on your IMAP server.",
          "name" : "TN3189: Managing Mail background traffic load",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3189-managing-mail-background-traffic-load"
        },
        {
          "description" : "Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.",
          "name" : "TN3187: Migrating to the UIKit scene-based life cycle",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle"
        },
        {
          "description" : "Verify your In-App Purchases are approved and available for sale in the App Store.",
          "name" : "TN3188: Troubleshooting In-App Purchases availability in the App Store",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3188-troubleshooting-in-app-purchases-availability-in-the-app-store"
        },
        {
          "description" : "Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.",
          "name" : "TN3186: Troubleshooting In-App Purchases availability in the sandbox",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3186-troubleshooting-in-app-purchases-availability-in-the-sandbox"
        },
        {
          "description" : "Inspect your active StoreKit configuration file for unexpected configurations.",
          "name" : "TN3185: Troubleshooting In-App Purchases availability in Xcode",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3185-troubleshooting-in-app-purchases-availability-in-xcode"
        },
        {
          "description" : "Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.",
          "name" : "TN3182: Adding privacy tracking keys to your privacy manifest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3182-adding-privacy-tracking-keys-to-your-privacy-manifest"
        }
      ],
      "title" : "Latest"
    }
  ],
  "source" : "appleJSON",
  "title" : "TN3151: Choosing the right networking API",
  "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api"
}