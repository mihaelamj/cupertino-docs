{
  "abstract" : "Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.",
  "codeExamples" : [
    {
      "code" : "This process does not adopt UIScene lifecycle. \nThis will become an assert in a future version."
    },
    {
      "code" : "UIScene lifecycle will soon be required. \nFailure to adopt will result in an assert in the future."
    },
    {
      "code" : "<key>UIApplicationSceneManifest<\/key>\n<dict>\n    <key>UIApplicationSupportsMultipleScenes<\/key>\n    <false\/> \n    <key>UISceneConfigurations<\/key>\n    <dict>\n        <key>UIWindowSceneSessionRoleApplication<\/key>\n        <array>\n            <dict>\n                <key>UISceneConfigurationName<\/key>\n                <string>Default Configuration<\/string>\n                <key>UISceneDelegateClassName<\/key>\n                <string>$(PRODUCT_MODULE_NAME).SceneDelegate<\/string>\n                <key>UISceneStoryboardFile<\/key>\n                <string>Main<\/string> \n            <\/dict>\n        <\/array>\n    <\/dict>\n<\/dict>",
      "language" : "xml"
    },
    {
      "code" : "@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(\n        _ application: UIApplication,\n        configurationForConnecting connectingSceneSession: UISceneSession,\n        options: UIScene.ConnectionOptions\n    ) -> UISceneConfiguration {\n\n        \/\/ Each UISceneConfiguration have a unique configuration name.\n        \/\/ The configuration name is a app-specific name\n        \/\/ you use to identify the scene, and it corresponds to entries\n        \/\/ in the `Info.plist` scene manifest.\n        var configurationName: String!\n    \n        switch options.userActivities.first?.activityType {\n        case UserActivity.GalleryOpenInspectorActivityType:\n            \/\/ Create a photo inspector window scene.\n            configurationName = \"Inspector Configuration\"\n        default:\n            \/\/ Create a default gallery window scene.\n            configurationName = \"Default Configuration\"\n        }\n        \n        return UISceneConfiguration(\n            name: configurationName,\n            sessionRole: connectingSceneSession.role\n        )\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    var window: UIWindow?\n    \n    func scene(\n        _ scene: UIScene,\n        willConnectTo session: UISceneSession,\n        options connectionOptions: UIScene.ConnectionOptions\n    ) {\n        \/\/ Confirm the scene is a window scene in iOS or iPadOS.\n        guard let windowScene = scene as? UIWindowScene else { return }\n                \n        window = UIWindow(windowScene: windowScene)\n        window?.rootViewController = YourRootViewController()\n        window?.makeKeyAndVisible()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "7db636f85748c8b6a8051a244147930d1265b718f58815e7528cf70dd5f6a2ed",
  "crawledAt" : "2025-12-05T09:00:39Z",
  "id" : "58977DF2-523D-4A4A-810F-AD1507204AAF",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nA scene represents an instance of your app’s user interface. In a document-based app, such as a text editor, each open document can be displayed in its own scene, enabling users to work on multiple documents side by side.\n\nIn iOS 18.4, iPadOS 18.4, Mac Catalyst 18.4, tvOS 18.4, visionOS 2.4 and later, UIKit logs the following message for apps that haven’t adopted the scene-based life-cycle:\n\nIn iOS 26, iPadOS 26, Mac Catalyst 26, tvOS 26, visionOS 26 , the log message has been updated to:\n\nIn the next major release following iOS 26, UIScene lifecycle will be required when building with the latest SDK; otherwise, your app won’t launch. While supporting multiple scenes is encouraged, only adoption of scene life-cycle is required.\n\nThis guide will help you add scene support to your app so you can receive scene-specific life-cycle events from UIKit and manage your user interface using scene objects and methods. For more information about how to configure scene support, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/specifying-the-scenes-your-app-supports].\n\n## Determine if your app should migrate\n\nMigrate to the scene-based life-cycle if your app meets either of the following conditions:\n\n## Understand the scene-based life-cycle\n\nA scene contains the windows and view controllers for presenting one instance of your UI. UIKit manages each instance of your app’s UI using a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene] object.\n\nYou can specify a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene] object by including the class name for the scene in the `Info.plist` scene manifest.\n\nAlternatively, you can specify the class name when creating a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneConfiguration] object in your app delegate’s `application(:configurationForConnecting:options:)` method. When the user interacts with your app, the system creates an appropriate scene object based on the configuration data you provided. To request a scene programmatically, call the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication\/activateSceneSession(for:errorHandler:)] method of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication].\n\nIn a scene-based app:\n\nUnlike the `UIApplicationDelegate` object, which manages a single app-wide life-cycle, the scene-based life-cycle divides your app’s overall life cycle into two components:\n\n## Adopt the scene-based life cycle\n\nThe simplest way to configure your app’s scenes is to add a `UIApplicationSceneManifest` key with a scene configuration in the `Info.plist` file.\n\nApps that require dynamic scene configurations, such as supporting multiple scenes, customizing scenes based on user activities, or handling different scene roles can implement the `application(_:configurationForConnecting:options:)` method in the app delegate.\n\n### Configure the Info.plist for scene support\n\nTo configure your `Info.plist` for scene support, you should add a `UIApplicationSceneManifest` key with a scene configuration:\n\nFor example:\n\nTo support multiple scenes, include the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/UIApplicationSceneManifest\/UIApplicationSupportsMultipleScenes] key with its `Boolean` value set to `true`, which indicates that the app supports two or more scenes simultaneously. Each `UISceneConfiguration` should have a unique configuration name when supporting multiple scenes.\n\n### Provide scene configurations from your app delegate for dynamic configuration\n\nImplement the `application(_:configurationForConnecting:options:)` method in your app delegate if you don’t include scene-configuration data in your app’s `Info.plist` file or if your app requires dynamic scene configuration—such as, loading different scenes based on user activity or session specific data.\n\nIn this example, through the use of a unique [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity\/activityType], the app can distinguish which new scene to create.\n\nTo learn more about how to configure your app for different scene types and customize scene behavior, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/specifying-the-scenes-your-app-supports], and for more information about how to create multiple windows programmatically, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/supporting-multiple-windows-on-ipad].\n\nIf your root view controller is loaded from the storyboard, ensure that the storyboard name is provided in the `UISceneConfigurations` key in the `Info.plist` scene manifest. The system automatically configures your window scene and its root view controller.\n\nIf your window’s root view controller is loaded programmatically, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneDelegate\/scene(_:willConnectTo:options:)] to create a `UIWindow` and associate it with the specified scene object.\n\nThis example uses a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder] subclass conforming to the `UIWindowSceneDelegate` protocol called `SceneDelegate` to create the app’s primary window scene. For more information about how to prepare your app at launch time, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/responding-to-the-launch-of-your-app].\n\n## Migrate app life-cycle logic\n\nMove your app’s existing life-cycle methods from `UIApplicationDelegate` to `UISceneDelegate`:\n\nMigrating to a scene-based life-cycle modernizes your app and helps it to take full advantage of iOS multitasking features. After adopting scene-based life-cycle ensure to test your app in Split View, Slide Over, and Stage Manager on iPad.\n\nTo learn how to respond to state transitions within your app, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/managing-your-app-s-life-cycle].\n\n## Revision History",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle\ncrawled: 2025-12-05T09:00:39Z\n---\n\n# TN3187: Migrating to the UIKit scene-based life cycle\n\n**Article**\n\nUpdate your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.\n\n## Overview\n\nA scene represents an instance of your app’s user interface. In a document-based app, such as a text editor, each open document can be displayed in its own scene, enabling users to work on multiple documents side by side.\n\nIn iOS 18.4, iPadOS 18.4, Mac Catalyst 18.4, tvOS 18.4, visionOS 2.4 and later, UIKit logs the following message for apps that haven’t adopted the scene-based life-cycle:\n\n```\nThis process does not adopt UIScene lifecycle. \nThis will become an assert in a future version.\n```\n\nIn iOS 26, iPadOS 26, Mac Catalyst 26, tvOS 26, visionOS 26 , the log message has been updated to:\n\n```\nUIScene lifecycle will soon be required. \nFailure to adopt will result in an assert in the future.\n```\n\nIn the next major release following iOS 26, UIScene lifecycle will be required when building with the latest SDK; otherwise, your app won’t launch. While supporting multiple scenes is encouraged, only adoption of scene life-cycle is required.\n\nThis guide will help you add scene support to your app so you can receive scene-specific life-cycle events from UIKit and manage your user interface using scene objects and methods. For more information about how to configure scene support, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/specifying-the-scenes-your-app-supports].\n\n## Determine if your app should migrate\n\nMigrate to the scene-based life-cycle if your app meets either of the following conditions:\n\n- The [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/UIApplicationSceneManifest] key is missing from your [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List] or it has no specified configurations.\n- You haven’t implemented the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:configurationForConnecting:options:)] method in your app delegate.\n\n## Understand the scene-based life-cycle\n\nA scene contains the windows and view controllers for presenting one instance of your UI. UIKit manages each instance of your app’s UI using a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene] object.\n\nYou can specify a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene] object by including the class name for the scene in the `Info.plist` scene manifest.\n\nAlternatively, you can specify the class name when creating a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneConfiguration] object in your app delegate’s `application(:configurationForConnecting:options:)` method. When the user interacts with your app, the system creates an appropriate scene object based on the configuration data you provided. To request a scene programmatically, call the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication\/activateSceneSession(for:errorHandler:)] method of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication].\n\nIn a scene-based app:\n\n- UIKit usually creates a `UIWindowScene` object instead of a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIScene] object. When configuring your app’s scene support, specify `UIWindowScene` objects instead of `UIScene` objects.\n- Use [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/CPTemplateApplicationScene] if your app is adopting scenes for CarPlay. To learn how to add a CarPlay scene see [doc:\/\/com.apple.documentation\/documentation\/CarPlay\/displaying-content-in-carplay].\n- [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneSession] contains a unique identifier and the configuration details of the scene.\n- `UISceneDelegate` and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowSceneDelegate] both handle scene-specific life-cycle events.\n- `UISceneConfiguration` defines how to create and configure scenes.\n\nUnlike the `UIApplicationDelegate` object, which manages a single app-wide life-cycle, the scene-based life-cycle divides your app’s overall life cycle into two components:\n\n- The application life cycle, such as when your app process launches.\n- The life cycle of when an app has UI visible on screen, embodied by a scene.\n\n## Adopt the scene-based life cycle\n\nThe simplest way to configure your app’s scenes is to add a `UIApplicationSceneManifest` key with a scene configuration in the `Info.plist` file.\n\nApps that require dynamic scene configurations, such as supporting multiple scenes, customizing scenes based on user activities, or handling different scene roles can implement the `application(_:configurationForConnecting:options:)` method in the app delegate.\n\n### Configure the Info.plist for scene support\n\nTo configure your `Info.plist` for scene support, you should add a `UIApplicationSceneManifest` key with a scene configuration:\n\n1. Open your Xcode project.\n2. Select your app target.\n3. Navigate to the General settings for your app target.\n4. Select “Scene manifest” in the Deployment Info section.\n5. Edit the Info.plist file and add a `UIApplicationSceneManifest` key\n\nFor example:\n\n```xml\n<key>UIApplicationSceneManifest<\/key>\n<dict>\n    <key>UIApplicationSupportsMultipleScenes<\/key>\n    <false\/> \n    <key>UISceneConfigurations<\/key>\n    <dict>\n        <key>UIWindowSceneSessionRoleApplication<\/key>\n        <array>\n            <dict>\n                <key>UISceneConfigurationName<\/key>\n                <string>Default Configuration<\/string>\n                <key>UISceneDelegateClassName<\/key>\n                <string>$(PRODUCT_MODULE_NAME).SceneDelegate<\/string>\n                <key>UISceneStoryboardFile<\/key>\n                <string>Main<\/string> \n            <\/dict>\n        <\/array>\n    <\/dict>\n<\/dict>\n```\n\n\n\nTo support multiple scenes, include the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/UIApplicationSceneManifest\/UIApplicationSupportsMultipleScenes] key with its `Boolean` value set to `true`, which indicates that the app supports two or more scenes simultaneously. Each `UISceneConfiguration` should have a unique configuration name when supporting multiple scenes.\n\n### Provide scene configurations from your app delegate for dynamic configuration\n\nImplement the `application(_:configurationForConnecting:options:)` method in your app delegate if you don’t include scene-configuration data in your app’s `Info.plist` file or if your app requires dynamic scene configuration—such as, loading different scenes based on user activity or session specific data.\n\n```swift\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(\n        _ application: UIApplication,\n        configurationForConnecting connectingSceneSession: UISceneSession,\n        options: UIScene.ConnectionOptions\n    ) -> UISceneConfiguration {\n\n        \/\/ Each UISceneConfiguration have a unique configuration name.\n        \/\/ The configuration name is a app-specific name\n        \/\/ you use to identify the scene, and it corresponds to entries\n        \/\/ in the `Info.plist` scene manifest.\n        var configurationName: String!\n    \n        switch options.userActivities.first?.activityType {\n        case UserActivity.GalleryOpenInspectorActivityType:\n            \/\/ Create a photo inspector window scene.\n            configurationName = \"Inspector Configuration\"\n        default:\n            \/\/ Create a default gallery window scene.\n            configurationName = \"Default Configuration\"\n        }\n        \n        return UISceneConfiguration(\n            name: configurationName,\n            sessionRole: connectingSceneSession.role\n        )\n    }\n}\n```\n\nIn this example, through the use of a unique [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity\/activityType], the app can distinguish which new scene to create.\n\nTo learn more about how to configure your app for different scene types and customize scene behavior, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/specifying-the-scenes-your-app-supports], and for more information about how to create multiple windows programmatically, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/supporting-multiple-windows-on-ipad].\n\nIf your root view controller is loaded from the storyboard, ensure that the storyboard name is provided in the `UISceneConfigurations` key in the `Info.plist` scene manifest. The system automatically configures your window scene and its root view controller.\n\nIf your window’s root view controller is loaded programmatically, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneDelegate\/scene(_:willConnectTo:options:)] to create a `UIWindow` and associate it with the specified scene object.\n\n```swift\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    var window: UIWindow?\n    \n    func scene(\n        _ scene: UIScene,\n        willConnectTo session: UISceneSession,\n        options connectionOptions: UIScene.ConnectionOptions\n    ) {\n        \/\/ Confirm the scene is a window scene in iOS or iPadOS.\n        guard let windowScene = scene as? UIWindowScene else { return }\n                \n        window = UIWindow(windowScene: windowScene)\n        window?.rootViewController = YourRootViewController()\n        window?.makeKeyAndVisible()\n    }\n}\n```\n\nThis example uses a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder] subclass conforming to the `UIWindowSceneDelegate` protocol called `SceneDelegate` to create the app’s primary window scene. For more information about how to prepare your app at launch time, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/responding-to-the-launch-of-your-app].\n\n## Migrate app life-cycle logic\n\nMove your app’s existing life-cycle methods from `UIApplicationDelegate` to `UISceneDelegate`:\n\n\n\nMigrating to a scene-based life-cycle modernizes your app and helps it to take full advantage of iOS multitasking features. After adopting scene-based life-cycle ensure to test your app in Split View, Slide Over, and Stage Manager on iPad.\n\nTo learn how to respond to state transitions within your app, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/managing-your-app-s-life-cycle].\n\n## Revision History\n\n- **2025-06-23** Added information about the requirements in the major release following iOS 26.\n- **2025-05-05** First published.\n\n## Latest\n\n- **TN3190: USB audio device design considerations**: Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.\n- **TN3194: Handling account deletions and revoking tokens for Sign in with Apple**: Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.\n- **TN3193: Managing the on-device foundation model’s context window**: Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.\n- **TN3115: Bluetooth State Restoration app relaunch rules**: Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.\n- **TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key**: Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.\n- **TN3151: Choosing the right networking API**: Learn which networking API is best for you.\n- **TN3111: iOS Wi-Fi API overview**: Explore the various Wi-Fi APIs available on iOS and their expected use cases.\n- **TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS**: Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.\n- **TN3134: Network Extension provider deployment**: Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.\n- **TN3179: Understanding local network privacy**: Learn how local network privacy affects your software.\n- **TN3189: Managing Mail background traffic load**: Identify iOS Mail background traffic and manage its impact on your IMAP server.\n- **TN3188: Troubleshooting In-App Purchases availability in the App Store**: Verify your In-App Purchases are approved and available for sale in the App Store.\n- **TN3186: Troubleshooting In-App Purchases availability in the sandbox**: Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.\n- **TN3185: Troubleshooting In-App Purchases availability in Xcode**: Inspect your active StoreKit configuration file for unexpected configurations.\n- **TN3182: Adding privacy tracking keys to your privacy manifest**: Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.",
          "name" : "TN3190: USB audio device design considerations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3190-USB-audio-device-design-considerations"
        },
        {
          "description" : "Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.",
          "name" : "TN3194: Handling account deletions and revoking tokens for Sign in with Apple",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3194-handling-account-deletions-and-revoking-tokens-for-sign-in-with-apple"
        },
        {
          "description" : "Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.",
          "name" : "TN3193: Managing the on-device foundation model’s context window",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3193-managing-the-on-device-foundation-model-s-context-window"
        },
        {
          "description" : "Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.",
          "name" : "TN3115: Bluetooth State Restoration app relaunch rules",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3115-bluetooth-state-restoration-app-relaunch-rules"
        },
        {
          "description" : "Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.",
          "name" : "TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3192-Migrating-your-app-from-the-deprecated-UIRequiresFullScreen-key"
        },
        {
          "description" : "Learn which networking API is best for you.",
          "name" : "TN3151: Choosing the right networking API",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api"
        },
        {
          "description" : "Explore the various Wi-Fi APIs available on iOS and their expected use cases.",
          "name" : "TN3111: iOS Wi-Fi API overview",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3111-ios-wifi-api-overview"
        },
        {
          "description" : "Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.",
          "name" : "TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3191-imap-extensions-supported-by-mail"
        },
        {
          "description" : "Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.",
          "name" : "TN3134: Network Extension provider deployment",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3134-network-extension-provider-deployment"
        },
        {
          "description" : "Learn how local network privacy affects your software.",
          "name" : "TN3179: Understanding local network privacy",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3179-understanding-local-network-privacy"
        },
        {
          "description" : "Identify iOS Mail background traffic and manage its impact on your IMAP server.",
          "name" : "TN3189: Managing Mail background traffic load",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3189-managing-mail-background-traffic-load"
        },
        {
          "description" : "Verify your In-App Purchases are approved and available for sale in the App Store.",
          "name" : "TN3188: Troubleshooting In-App Purchases availability in the App Store",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3188-troubleshooting-in-app-purchases-availability-in-the-app-store"
        },
        {
          "description" : "Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.",
          "name" : "TN3186: Troubleshooting In-App Purchases availability in the sandbox",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3186-troubleshooting-in-app-purchases-availability-in-the-sandbox"
        },
        {
          "description" : "Inspect your active StoreKit configuration file for unexpected configurations.",
          "name" : "TN3185: Troubleshooting In-App Purchases availability in Xcode",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3185-troubleshooting-in-app-purchases-availability-in-xcode"
        },
        {
          "description" : "Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.",
          "name" : "TN3182: Adding privacy tracking keys to your privacy manifest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3182-adding-privacy-tracking-keys-to-your-privacy-manifest"
        }
      ],
      "title" : "Latest"
    }
  ],
  "source" : "appleJSON",
  "title" : "TN3187: Migrating to the UIKit scene-based life cycle",
  "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle"
}