{
  "abstract" : "Support iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.",
  "codeExamples" : [
    {
      "code" : "class SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    var gameAssetManager = MyGameAssetManager()\n    var previousSceneSize = CGSize.zero\n\n    func windowScene(\n        _ windowScene: UIWindowScene,\n        didUpdateEffectiveGeometry previousGeometry: UIWindowScene.Geometry) {\n\n        let geometry = windowScene.effectiveGeometry\n        let sceneSize = geometry.coordinateSpace.bounds.size\n\n        if !geometry.isInteractivelyResizing && sceneSize != previousSceneSize {\n            previousSceneSize = sceneSize\n            gameAssetManager.updateAssets(sceneSize: sceneSize)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class SceneDelegate: UIResponder, UIWindowSceneDelegate {\n\n    func scene(_ scene: UIScene,\n               willConnectTo session: UISceneSession,\n               options connectionOptions: UIScene.ConnectionOptions) {\n\n        guard let windowScene = scene as? UIWindowScene else { return }\n        windowScene.sizeRestrictions?.minimumSize.width = 500.0\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n               .frame(minWidth: 100, maxWidth: 400, minHeight: 100, maxHeight: 400)\n        }\n        .windowResizability(.contentMinSize)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class MyRaceViewController: UIViewController {\n\n    override var prefersInterfaceOrientationLocked: Bool {\n        return isDriving\n    }\n\n    \/\/ ...\n\n    var isDriving: Bool = false {\n        didSet {\n            if isDriving != oldValue {\n                setNeedsUpdateOfPrefersInterfaceOrientationLocked()\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    var game = MyGame()\n\n    func windowScene(\n        _ windowScene: UIWindowScene,\n        didUpdateEffectiveGeometry previousGeometry: UIWindowScene.Geometry) {\n\n        let wasLocked = previousGeometry.isInterfaceOrientationLocked\n        let isLocked = windowScene.effectiveGeometry.isInterfaceOrientationLocked\n\n        if wasLocked != isLocked {\n            game.pauseIfNeeded(isInterfaceOrientationLocked: isLocked)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "9d6f04748cd67bc1303d4aca466e30b305ce93b9df92db77cc840186e44c2a3d",
  "crawledAt" : "2025-12-05T10:31:38Z",
  "id" : "DABA60C4-8E75-4384-BBA9-B2286493D195",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nPrior to iPadOS 26, apps could request a compatibility mode that opted them out of multitasking and dynamic scene resizing through the [https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/UIRequiresFullScreen] key. This key-value pair configures iPadOS apps only, and is ignored for iOS apps.\n\nUpdate apps that rely on `UIRequiresFullScreen`’s compatibility mode to handle resizing scenes so they can provide a better multitasking experience.\n\nThis guide will help you migrate away from `UIRequiresFullScreen` and handle dynamic resizing. For more information on the enhanced window resizing and improved multitasking, see WWDC25 session 282: [https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/282\/].\n\n## Determine if your app should update\n\nTo support resizable scenes ensure that your app:\n\nWith these updates, your app will support resizable scenes and multitasking. To learn more about adopting scene-based life cycle, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle].\n\n## Respond to scene size changes\n\nIf your app layout relies on consistent scene size, or uses absolute values for its view geometry, consider using Auto Layout to calculate the size and position of its views through constraints placed on its views.\n\nBy using Auto Layout, you’re able to replace static, frame-based layouts in your app with flexible constraint-based layouts that respond to size changes. For more information on Auto Layout, including layout constraints and attributes, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/UserExperience\/Conceptual\/AutolayoutPG\/index.html].\n\nWhen transitioning away from the deprecated `UIRequiresFullScreen` key, ensure your app’s views adapt to dynamic size changes that occur when users resize windows or change device orientation. Each of these scenarios can cause your app’s scene bounds to change at runtime, potentially breaking layouts that assume fixed dimensions. To learn more about debugging Auto Layout issues, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/UserExperience\/Conceptual\/AutolayoutPG\/ConflictingLayouts.html#\/\/apple_ref\/doc\/uid\/TP40010853-CH19-SW1].\n\nYou can adjust your app’s layout when the environment changes, such as when size class, display scale, or layout direction changes occur. To detect these changes, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITraitChangeObservable-67e94\/registerForTraitChanges(_:target:action:)] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITraitChangeObservable-67e94\/registerForTraitChanges(_:handler:)] to register a list of traits to observe.\n\nTo observe a scene’s geometry changing, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowSceneDelegate\/windowScene(_:didUpdateEffectiveGeometry:)] and compare the `coordinateSpace.bounds` of both geometries.\n\nAdditionally, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene\/Geometry\/isInteractivelyResizing] to handle interactive resizing of the scene specifically. For example:\n\nIn this example, `isInteractivelyResizing` is queried to only update assets for a new scene size after the interaction finishes. This is helpful for games, where multiple assets may require resizing when the scene changes size or if there are elements of your app’s UI that are computationally expensive to draw.\n\nIn SwiftUI, use [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/onInteractiveResizeChange(_:)] to adjust how your view behaves when a window is in the process of being resized by the user.\n\n## Specify scene sizing preference\n\nTo express a preferred minimum size of your scene’s content, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneSizeRestrictions]. For example:\n\nThe example above specifies a preferred minimum width of 500 points.\n\nIn SwiftUI, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/windowResizability(_:)] modifier to allow your scene’s content provide sizing information. The value that you specify indicates the strategy the system uses to place minimum restriction on windows that it creates from that scene. For example:\n\n## Request scene orientation lock\n\nSome apps may benefit from temporarily locking the orientation. For example, a driving game may want to lock the orientation when the device is expected to rotate for steering a vehicle or a camera apps may need to lock orientation during photo or video capture.\n\nTo request orientation lock, override [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/prefersInterfaceOrientationLocked] in your view controller subclass. Whenever this preference changes, call [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/setNeedsUpdateOfSupportedInterfaceOrientations()]. For example:\n\nThe value returned by `prefersInterfaceOrientationLocked` indicates to the system that the view controller prefers the scene’s interface orientation to be locked when shown.\n\nIf your app uses the camera, use [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVCaptureDevice\/RotationCoordinator] to ensure that captures and camera preview interfaces are correctly oriented regardless of interface orientation lock.\n\nTo observe the interface orientation lock, use `windowScene(_:didUpdateEffectiveGeometry:)` and check if the value of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene\/Geometry\/isInterfaceOrientationLocked] has changed. For example:\n\nFor more information about locking your scene to your preferred interface orientation and preventing rotation changes, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/prefersInterfaceOrientationLocked].\n\n## Revision History",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Technotes\/tn3192-Migrating-your-app-from-the-deprecated-UIRequiresFullScreen-key\ncrawled: 2025-12-05T10:31:38Z\n---\n\n# TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key\n\n**Article**\n\nSupport iPad multitasking and dynamic resizing while updating your app to remove the deprecated full-screen compatibility mode.\n\n## Overview\n\nPrior to iPadOS 26, apps could request a compatibility mode that opted them out of multitasking and dynamic scene resizing through the [https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/UIRequiresFullScreen] key. This key-value pair configures iPadOS apps only, and is ignored for iOS apps.\n\nUpdate apps that rely on `UIRequiresFullScreen`’s compatibility mode to handle resizing scenes so they can provide a better multitasking experience.\n\n\n\nThis guide will help you migrate away from `UIRequiresFullScreen` and handle dynamic resizing. For more information on the enhanced window resizing and improved multitasking, see WWDC25 session 282: [https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/282\/].\n\n## Determine if your app should update\n\nTo support resizable scenes ensure that your app:\n\n- Provides a [doc:\/\/com.apple.documentation\/documentation\/Xcode\/specifying-your-apps-launch-screen].\n- Supports all [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/layout#Adaptability].\n- Doesn’t include the `UIRequiresFullScreen` key in its [https:\/\/developer.apple.com\/documentation\/bundleresources\/information-property-list] or [https:\/\/developer.apple.com\/documentation\/xcode\/build-settings-reference#Requires-Full-Screen] or its build settings.\n\nWith these updates, your app will support resizable scenes and multitasking. To learn more about adopting scene-based life cycle, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle].\n\n## Respond to scene size changes\n\nIf your app layout relies on consistent scene size, or uses absolute values for its view geometry, consider using Auto Layout to calculate the size and position of its views through constraints placed on its views.\n\nBy using Auto Layout, you’re able to replace static, frame-based layouts in your app with flexible constraint-based layouts that respond to size changes. For more information on Auto Layout, including layout constraints and attributes, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/UserExperience\/Conceptual\/AutolayoutPG\/index.html].\n\nWhen transitioning away from the deprecated `UIRequiresFullScreen` key, ensure your app’s views adapt to dynamic size changes that occur when users resize windows or change device orientation. Each of these scenarios can cause your app’s scene bounds to change at runtime, potentially breaking layouts that assume fixed dimensions. To learn more about debugging Auto Layout issues, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/UserExperience\/Conceptual\/AutolayoutPG\/ConflictingLayouts.html#\/\/apple_ref\/doc\/uid\/TP40010853-CH19-SW1].\n\nYou can adjust your app’s layout when the environment changes, such as when size class, display scale, or layout direction changes occur. To detect these changes, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITraitChangeObservable-67e94\/registerForTraitChanges(_:target:action:)] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITraitChangeObservable-67e94\/registerForTraitChanges(_:handler:)] to register a list of traits to observe.\n\nTo observe a scene’s geometry changing, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowSceneDelegate\/windowScene(_:didUpdateEffectiveGeometry:)] and compare the `coordinateSpace.bounds` of both geometries.\n\nAdditionally, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene\/Geometry\/isInteractivelyResizing] to handle interactive resizing of the scene specifically. For example:\n\n```swift\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    var gameAssetManager = MyGameAssetManager()\n    var previousSceneSize = CGSize.zero\n\n    func windowScene(\n        _ windowScene: UIWindowScene,\n        didUpdateEffectiveGeometry previousGeometry: UIWindowScene.Geometry) {\n\n        let geometry = windowScene.effectiveGeometry\n        let sceneSize = geometry.coordinateSpace.bounds.size\n\n        if !geometry.isInteractivelyResizing && sceneSize != previousSceneSize {\n            previousSceneSize = sceneSize\n            gameAssetManager.updateAssets(sceneSize: sceneSize)\n        }\n    }\n}\n```\n\nIn this example, `isInteractivelyResizing` is queried to only update assets for a new scene size after the interaction finishes. This is helpful for games, where multiple assets may require resizing when the scene changes size or if there are elements of your app’s UI that are computationally expensive to draw.\n\nIn SwiftUI, use [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/onInteractiveResizeChange(_:)] to adjust how your view behaves when a window is in the process of being resized by the user.\n\n## Specify scene sizing preference\n\nTo express a preferred minimum size of your scene’s content, use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UISceneSizeRestrictions]. For example:\n\n```swift\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n\n    func scene(_ scene: UIScene,\n               willConnectTo session: UISceneSession,\n               options connectionOptions: UIScene.ConnectionOptions) {\n\n        guard let windowScene = scene as? UIWindowScene else { return }\n        windowScene.sizeRestrictions?.minimumSize.width = 500.0\n    }\n}\n```\n\nThe example above specifies a preferred minimum width of 500 points.\n\n\n\nIn SwiftUI, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/windowResizability(_:)] modifier to allow your scene’s content provide sizing information. The value that you specify indicates the strategy the system uses to place minimum restriction on windows that it creates from that scene. For example:\n\n```swift\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n               .frame(minWidth: 100, maxWidth: 400, minHeight: 100, maxHeight: 400)\n        }\n        .windowResizability(.contentMinSize)\n    }\n}\n```\n\n## Request scene orientation lock\n\nSome apps may benefit from temporarily locking the orientation. For example, a driving game may want to lock the orientation when the device is expected to rotate for steering a vehicle or a camera apps may need to lock orientation during photo or video capture.\n\nTo request orientation lock, override [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/prefersInterfaceOrientationLocked] in your view controller subclass. Whenever this preference changes, call [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/setNeedsUpdateOfSupportedInterfaceOrientations()]. For example:\n\n```swift\nclass MyRaceViewController: UIViewController {\n\n    override var prefersInterfaceOrientationLocked: Bool {\n        return isDriving\n    }\n\n    \/\/ ...\n\n    var isDriving: Bool = false {\n        didSet {\n            if isDriving != oldValue {\n                setNeedsUpdateOfPrefersInterfaceOrientationLocked()\n            }\n        }\n    }\n}\n```\n\nThe value returned by `prefersInterfaceOrientationLocked` indicates to the system that the view controller prefers the scene’s interface orientation to be locked when shown.\n\n\n\nIf your app uses the camera, use [doc:\/\/com.apple.documentation\/documentation\/AVFoundation\/AVCaptureDevice\/RotationCoordinator] to ensure that captures and camera preview interfaces are correctly oriented regardless of interface orientation lock.\n\nTo observe the interface orientation lock, use `windowScene(_:didUpdateEffectiveGeometry:)` and check if the value of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIWindowScene\/Geometry\/isInterfaceOrientationLocked] has changed. For example:\n\n```swift\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    var game = MyGame()\n\n    func windowScene(\n        _ windowScene: UIWindowScene,\n        didUpdateEffectiveGeometry previousGeometry: UIWindowScene.Geometry) {\n\n        let wasLocked = previousGeometry.isInterfaceOrientationLocked\n        let isLocked = windowScene.effectiveGeometry.isInterfaceOrientationLocked\n\n        if wasLocked != isLocked {\n            game.pauseIfNeeded(isInterfaceOrientationLocked: isLocked)\n        }\n    }\n}\n```\n\nFor more information about locking your scene to your preferred interface orientation and preventing rotation changes, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/prefersInterfaceOrientationLocked].\n\n## Revision History\n\n- **2025-09-08** First published.\n\n## Latest\n\n- **TN3190: USB audio device design considerations**: Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.\n- **TN3194: Handling account deletions and revoking tokens for Sign in with Apple**: Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.\n- **TN3193: Managing the on-device foundation model’s context window**: Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.\n- **TN3115: Bluetooth State Restoration app relaunch rules**: Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.\n- **TN3151: Choosing the right networking API**: Learn which networking API is best for you.\n- **TN3111: iOS Wi-Fi API overview**: Explore the various Wi-Fi APIs available on iOS and their expected use cases.\n- **TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS**: Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.\n- **TN3134: Network Extension provider deployment**: Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.\n- **TN3179: Understanding local network privacy**: Learn how local network privacy affects your software.\n- **TN3189: Managing Mail background traffic load**: Identify iOS Mail background traffic and manage its impact on your IMAP server.\n- **TN3187: Migrating to the UIKit scene-based life cycle**: Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.\n- **TN3188: Troubleshooting In-App Purchases availability in the App Store**: Verify your In-App Purchases are approved and available for sale in the App Store.\n- **TN3186: Troubleshooting In-App Purchases availability in the sandbox**: Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.\n- **TN3185: Troubleshooting In-App Purchases availability in Xcode**: Inspect your active StoreKit configuration file for unexpected configurations.\n- **TN3182: Adding privacy tracking keys to your privacy manifest**: Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn the best techniques for designing devices that conform to the USB Audio Device Class specifications.",
          "name" : "TN3190: USB audio device design considerations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3190-USB-audio-device-design-considerations"
        },
        {
          "description" : "Learn the best techniques for managing Sign in with Apple user sessions and responding to account deletion requests.",
          "name" : "TN3194: Handling account deletions and revoking tokens for Sign in with Apple",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3194-handling-account-deletions-and-revoking-tokens-for-sign-in-with-apple"
        },
        {
          "description" : "Learn how to budget for the context window limit of Apple’s on-device foundation model and handle the error when reaching the limit.",
          "name" : "TN3193: Managing the on-device foundation model’s context window",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3193-managing-the-on-device-foundation-model-s-context-window"
        },
        {
          "description" : "Learn about the conditions under which an iOS app will be relaunched by Bluetooth State Restoration.",
          "name" : "TN3115: Bluetooth State Restoration app relaunch rules",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3115-bluetooth-state-restoration-app-relaunch-rules"
        },
        {
          "description" : "Learn which networking API is best for you.",
          "name" : "TN3151: Choosing the right networking API",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3151-choosing-the-right-networking-api"
        },
        {
          "description" : "Explore the various Wi-Fi APIs available on iOS and their expected use cases.",
          "name" : "TN3111: iOS Wi-Fi API overview",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3111-ios-wifi-api-overview"
        },
        {
          "description" : "Learn which extensions to the RFC 3501 IMAP protocol are supported by Mail for iOS, iPadOS, and visionOS.",
          "name" : "TN3191: IMAP extensions supported by Mail for iOS, iPadOS, and visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3191-imap-extensions-supported-by-mail"
        },
        {
          "description" : "Explore the platforms, packaging, OS versions, and device configurations for Network Extension provider deployment.",
          "name" : "TN3134: Network Extension provider deployment",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3134-network-extension-provider-deployment"
        },
        {
          "description" : "Learn how local network privacy affects your software.",
          "name" : "TN3179: Understanding local network privacy",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3179-understanding-local-network-privacy"
        },
        {
          "description" : "Identify iOS Mail background traffic and manage its impact on your IMAP server.",
          "name" : "TN3189: Managing Mail background traffic load",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3189-managing-mail-background-traffic-load"
        },
        {
          "description" : "Update your app to receive scene-based life-cycle events and manage your user interface using scene objects and methods.",
          "name" : "TN3187: Migrating to the UIKit scene-based life cycle",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3187-Migrating-to-the-UIKit-scene-based-life-cycle"
        },
        {
          "description" : "Verify your In-App Purchases are approved and available for sale in the App Store.",
          "name" : "TN3188: Troubleshooting In-App Purchases availability in the App Store",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3188-troubleshooting-in-app-purchases-availability-in-the-app-store"
        },
        {
          "description" : "Identify common configurations that make your In-App Purchases unavailable in the sandbox environment.",
          "name" : "TN3186: Troubleshooting In-App Purchases availability in the sandbox",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3186-troubleshooting-in-app-purchases-availability-in-the-sandbox"
        },
        {
          "description" : "Inspect your active StoreKit configuration file for unexpected configurations.",
          "name" : "TN3185: Troubleshooting In-App Purchases availability in Xcode",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3185-troubleshooting-in-app-purchases-availability-in-xcode"
        },
        {
          "description" : "Declare the tracking domains you use in your app or third-party SDK in a privacy manifest.",
          "name" : "TN3182: Adding privacy tracking keys to your privacy manifest",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3182-adding-privacy-tracking-keys-to-your-privacy-manifest"
        }
      ],
      "title" : "Latest"
    }
  ],
  "source" : "appleJSON",
  "title" : "TN3192: Migrating your iPad app from the deprecated UIRequiresFullScreen key",
  "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3192-Migrating-your-app-from-the-deprecated-UIRequiresFullScreen-key"
}