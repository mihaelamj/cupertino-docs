{
  "abstract" : "Create an Ethernet driver that interfaces with the system’s network protocol stack.",
  "codeExamples" : [
    {
      "code" : "let request = OSSystemExtensionRequest\n    .activationRequest(forExtensionWithIdentifier: dextIdentifier,\n                       queue: .main)\nrequest.delegate = self\nOSSystemExtensionManager.shared.submitRequest(request)",
      "language" : "swift"
    },
    {
      "code" : "~ % systemextensionsctl list\n1 extension(s)\n--- com.apple.system_extension.driver_extension\nenabled    active    teamID    bundleID (version)    name    [state]\n*    *    A123456789    com.example.apple-samplecode.NetworkingDriverKitSample (1.0\/1)    com.example.apple-samplecode.NetworkingDriverKitSample    [activated enabled]\n",
      "language" : "swift"
    },
    {
      "code" : "    | +-o NetworkingDriverKitSample  <class IOUserNetworkEthernet, id 0x100028cee, registered, matched, active, busy 0 (4 ms), retain 16>",
      "language" : "swift"
    },
    {
      "code" : "ret = CopyDispatchQueue(\"Default\", &ivars->dsQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;",
      "language" : "other"
    },
    {
      "code" : "ret = CreateActionTxPacketAvailable(0, &ivars->txPacketAction);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nret = IOUserNetworkTxSubmissionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->txsQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = ivars->txsQueue->CopyDataQueue(&dataQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = dataQueue->SetDataAvailableHandler(ivars->txPacketAction);\nif (ret != kIOReturnSuccess)\n    goto fail;",
      "language" : "other"
    },
    {
      "code" : "ret = IOUserNetworkTxCompletionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->txcQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = IOUserNetworkRxSubmissionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->rxsQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = IOUserNetworkRxCompletionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->rxcQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;",
      "language" : "other"
    },
    {
      "code" : "ret = IOTimerDispatchSource::Create(ivars->dsQueue, &ivars->receiveTimerSource);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nstatus = CreateActionReceiveTimer(sizeof(void *), &ivars->receiveTimer);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nstatus = ivars->receiveTimerSource->SetHandler(ivars->receiveTimer);\nif (ret != kIOReturnSuccess)\n    goto fail;",
      "language" : "other"
    },
    {
      "code" : "now = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);\ndeadline = now + 1000 * kMillisecondScale;\nret = ivars->receiveTimerSource->WakeAtTime(kIOTimerClockUptimeRaw, deadline, 0);\nif (ret != kIOReturnSuccess)\n    goto disable;",
      "language" : "other"
    },
    {
      "code" : "dequeueCount = ivars->rxsQueue->DequeuePackets(packets, 8);\n\nlinkHeaderLength = 0;\nfor (i = 0; i < dequeueCount; i++) {\n    packet = packets[i];\n    good_packet = true;\n    dataAddr = (uint8_t *)packet->getDataVirtualAddress();\n    dataOffset = packet->getDataOffset();\n    \n    DLOG(\"dataAddr = %p dataOffset = %llu\", dataAddr, dataOffset);\n    \n    pktBuffer = (decltype(pktBuffer))(uintptr_t)(dataAddr + dataOffset);\n    \n    bcopy(echoRequest, pktBuffer, sizeof(echoRequest));\n\n    ret = packet->setDataOffset(dataOffset);\n    good_packet &= (ret == kIOReturnSuccess);\n\n    ret = packet->SetLinkHeaderLength(linkHeaderLength);\n    good_packet &= (ret == kIOReturnSuccess);\n\n    ret = packet->setDataLength(sizeof(echoRequest));\n    good_packet &= (ret == kIOReturnSuccess);\n\n    if (good_packet) {\n        DLOG(\"enqueue - packet[%d] = %p\", i, packet);\n\n        ret = ivars->rxcQueue->EnqueuePacket(packet);\n        if (ret != kIOReturnSuccess) {\n            ivars->pool->DeallocatePacket(packet);\n            LOG(\"Enqueue failed dropping pkt\\n\");\n        }\n    } else {\n        ivars->pool->DeallocatePacket(packet);\n        LOG(\"Packet setup failed dropping pkt\\n\");\n    }\n}\n\nnow = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);\ndeadline = now + 5ULL * kSecondScale;\nret = ivars->receiveTimerSource->WakeAtTime(kIOTimerClockUptimeRaw, deadline, 0);\nif (ret != kIOReturnSuccess) {\n    DLOG(\"error setting interrupt read timer 0x%08x\\n\", ret);\n}",
      "language" : "other"
    },
    {
      "code" : "dequeueCount = ivars->txsQueue->DequeuePackets(packets, 8);\n\nlinkHeaderLength = 0;\n\nif (dequeueCount) {\n    for (i = 0; i < dequeueCount; i++) {\n        packet = packets[i];\n\n        DLOG(\"dequeue - TX packet[%d] = %p\", i, packet);\n\n        dataAddr = (uint8_t *)packet->getDataVirtualAddress();\n        dataOffset = packet->getDataOffset();\n        \n        ret = packet->GetLinkHeaderLength(&linkHeaderLength);\n        \n        DLOG(\"dataAddr = %p dataOffset = %llu linkHeaderLength = %d\", dataAddr, dataOffset, linkHeaderLength);\n\n        ret = ivars->txcQueue->EnqueuePacket(packet);\n        if (ret != kIOReturnSuccess) {\n            ivars->pool->DeallocatePacket(packet);\n            LOG(\"Returning Tx Packet failed just return to pool\\n\");\n        }\n    }\n}",
      "language" : "other"
    },
    {
      "code" : "~ % systemextensionsctl uninstall A123456789 com.example.apple-samplecode.NetworkingDriverKitSample",
      "language" : "swift"
    }
  ],
  "contentHash" : "f863ecdbd5d7a36afd2add4558000f35337c588d4e6d42aaa0a2b3ab3f736bd0",
  "crawledAt" : "2025-12-02T15:51:24Z",
  "id" : "52750B67-AAE8-43B9-96AF-D3EAB6A447E2",
  "kind" : "unknown",
  "language" : "occ",
  "module" : "NetworkingDriverKit",
  "overview" : "## Overview\n\nThe `NetworkingDriverKitSample` project provides an example of how to write a driver with the NetworkingDriverKit APIs. Once installed and started, it appears like any other networking driver, viewable in IORegistry, System Settings, and the command-line interface `ifconfig`.\n\nUse this sample as a guide for developing drivers for your own networking hardware. This sample is not hardware-dependent, and instead uses an internal timer to simulate receiving new packets. In a real-world driver, you’d connect the RX\/TX submission and completion queues to real hardware transmit\/receive descriptor rings supported by PCIDriverKit and USBDriverKit drivers.\n\nKeep in mind that NetworkingDriverKit currently only supports developing Ethernet drivers.\n\nThe project contains two targets:\n\n### Configure the sample code project\n\nTo run the sample code project, you first need to build and run `NetworkingDriverKitSampleApp`, which installs the dexts.\n\nStart by choosing new bundle IDs for the app and driver. The bundle IDs included with the project are already associated with specific App IDs, so you need unique identifiers to create your own App IDs. Use a reverse-DNS format for your identifier (for more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/preparing-your-app-for-distribution]). Then, in `DriverLoadingViewModel.swift`, edit the definition of `dextIdentifier` to use the string you chose for your driver’s bundle ID.\n\nThe installer and driver both need specific entitlements to run. For `NetworkingDriverKitSampleApp`, request the following entitlements:\n\nFor the `NetworkingDriverKitSample` target, request the following:\n\nFor more information on requesting entitlements, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/requesting-entitlements-for-driverkit-development].\n\nNext, log in to your Apple Developer account and navigate to the [link-3680797] list in the Certificates, IDs & Profiles section. From here, create new App IDs for `NetworkingDriverKitSampleApp` and `NetworkingDriverKitSample`.\n\nFor the Bundle ID field, choose Explicit, and use the bundle IDs you chose earlier. Then, for `NetworkingDriverKitSampleApp`, request the System Extension capability. For `NetworkingDriverKitSample`, request the DriverKit and DriverKit Family Networking capabilities (under Additional Capabilities).\n\nNext, visit the [link-3680799] section of the site to create new provisioning profiles.\n\nRepeat these same steps to create a profile for `NetworkingDriverKitSample`, with one key difference: on the Register a New Provisioning Profile page, choose DriverKit App Development.\n\nBack in Xcode, do the following:\n\n### Use the System Extensions framework to install the driver extension\n\nThe `NetworkingDriverKitSampleApp` target declares `NetworkingDriverKitSample` as a dependency, so building the app target builds the dext and its installer together. When it’s running, `NetworkingDriverKitSampleApp` shows a single window with an Install Dext button.\n\nThe app uses the [doc:\/\/com.apple.systemextensions\/documentation\/SystemExtensions] framework to install and activate the dext. For more information, see `Installing System Extensions and Drivers`.\n\n\n\nAfter installation, the driver appears in System Settings as Ethernet Adapter (enXX), where *XX* is a number, like `en17`. You can also see the extension in Terminal with the command `systemextensionsctl list`, which lists all running system extensions. When the driver is running, it has an entry like the following, but with a different `teamID` value:\n\nYou can also inspect its entry in the I\/O Registry with the Terminal command `ioreg`. It appears in the registry tree with an entry like the following:\n\n### Start the driver by creating transmit and receive queues\n\nAt startup, NetworkingDriverKit calls the following methods on a driver as part of its lifecycle:\n\nThe sample driver does its setup work in the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. The driver uses this opportunity to set up queues to ensure that calls to and from NetworkingDriverKit are thread-safe. First, the sample creates a primary dispatch queue, which it calls `Default`.\n\n\n\nThe `Start` method then uses this dispatch queue, stored in `ivars->dsQueue`, to create the transmit submission queue. Since the `.iig` file declares a method named `TxPacketAvailable`, DriverKit creates a method called `CreateActionTxPacketAvailable`. This method creates the action that DriverKit calls when packets are available to transmit. The following setup in `Start` creates a queue and calls `SetDataAvailableHandler` to tell the queue to use the newly created action. The actual implementation of `TxPacketAvailable` appears later in this article.\n\n\n\nNext, the `Start` method creates three queues — one for transmit completion, one for receive submission, and one for receive completion — and associates each of them with the dispatch queue, `ivars->dsQueue`.\n\n\n\nTo mimic reception of data from the network, the sample creates a timer. Since the timer needs a callback action, the `.iig` declares a `RecieveTimer` method, which prompts DriverKit to provide a `CreateActionReceiveTimer` method. The following listing calls that method to create the action, then sets it as the handler for an `IOTimerDispatchSource` stored in `ivars->receiveTimerSource`.\n\n\n\nThe timer actually starts later, in `SetInterfaceEnable`, after enabling the transmit and receive queues seen earlier.\n\n\n\n### Receive packets in an action callback\n\nWhen the timer fires, it calls the sample’s `ReceiveTimer` callback. For the purposes of the sample project, this creates a fake ICMP request packet that it can submit to the receive-completion queue. For each packet dequeued from the [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkRxSubmissionQueue], this method performs the following steps:\n\nIf any of the mutations to the packet fail, the sample deallocates the packet without enqueueing it. The timer update occurs in either case.\n\n\n\n### Transmit packets in an action callback\n\nThe `Start` method created the action `TxPacketAvailable` to handle callbacks when the networking stack places packets on the transmit-submssion queue. Like the packet-receive handler, this method dequeues available packets, this time from the [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkTxSubmissionQueue], and loops over them. For the purposes of the sample, this method implementation just logs the data address, data offset, and link header length of each packet, and enqueues it in the [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkTxCompletionQueue].\n\n\n\n### Remove the running driver\n\nWhen shipping a DriverKit driver, people delete the driver by removing the parent app from their `\/Applications` directory. If you’re using dext developer mode to build and run the driver from Xcode, then you need to remove the driver manually.\n\nTo remove the driver, use the `systemextensionsctl uninstall` command, passing the team ID and the driver’s bundle ID. To look up these identifiers, use the `systemextensionsctl list` command to return both of these values. Invoke the `uninstall` command as follows:\n\nAfter authorization – via password, Touch ID, or an equivalent – the driver disappears from the System Settings network pane, and will no longer appear in the I\/O Registry.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/pcidriverkit\/connecting_a_network_driver\ncrawled: 2025-12-02T15:51:24Z\n---\n\n# Connecting a network driver\n\n**Sample Code**\n\nCreate an Ethernet driver that interfaces with the system’s network protocol stack.\n\n## Overview\n\nThe `NetworkingDriverKitSample` project provides an example of how to write a driver with the NetworkingDriverKit APIs. Once installed and started, it appears like any other networking driver, viewable in IORegistry, System Settings, and the command-line interface `ifconfig`.\n\nUse this sample as a guide for developing drivers for your own networking hardware. This sample is not hardware-dependent, and instead uses an internal timer to simulate receiving new packets. In a real-world driver, you’d connect the RX\/TX submission and completion queues to real hardware transmit\/receive descriptor rings supported by PCIDriverKit and USBDriverKit drivers.\n\nKeep in mind that NetworkingDriverKit currently only supports developing Ethernet drivers.\n\nThe project contains two targets:\n\n- NetworkingDriverKitSample — The sample driver, written in C++.\n- NetworkingDriverKitSampleApp — A SwiftUI-based app that uses the SystemExtensions framework to install the driver.\n\n### Configure the sample code project\n\nTo run the sample code project, you first need to build and run `NetworkingDriverKitSampleApp`, which installs the dexts.\n\nStart by choosing new bundle IDs for the app and driver. The bundle IDs included with the project are already associated with specific App IDs, so you need unique identifiers to create your own App IDs. Use a reverse-DNS format for your identifier (for more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/preparing-your-app-for-distribution]). Then, in `DriverLoadingViewModel.swift`, edit the definition of `dextIdentifier` to use the string you chose for your driver’s bundle ID.\n\nThe installer and driver both need specific entitlements to run. For `NetworkingDriverKitSampleApp`, request the following entitlements:\n\n- [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/Entitlements\/com.apple.developer.system-extension.install]\n- [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/Entitlements\/com.apple.security.app-sandbox]\n- [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/Entitlements\/com.apple.security.files.user-selected.read-only]\n\nFor the `NetworkingDriverKitSample` target, request the following:\n\n- [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit]\n- [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit.family.networking]\n\nFor more information on requesting entitlements, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/requesting-entitlements-for-driverkit-development].\n\nNext, log in to your Apple Developer account and navigate to the [link-3680797] list in the Certificates, IDs & Profiles section. From here, create new App IDs for `NetworkingDriverKitSampleApp` and `NetworkingDriverKitSample`.\n\nFor the Bundle ID field, choose Explicit, and use the bundle IDs you chose earlier. Then, for `NetworkingDriverKitSampleApp`, request the System Extension capability. For `NetworkingDriverKitSample`, request the DriverKit and DriverKit Family Networking capabilities (under Additional Capabilities).\n\nNext, visit the [link-3680799] section of the site to create new provisioning profiles.\n\n1. For `NetworkingDriverKitSampleApp`, press the `+` icon to create a new profile.\n2. On the Register a New Provisioning Profile page, choose macOS App Development and then Mac for the profile type.\n3. On the next two pages, add any certificates and devices you want to include in the profile.\n4. On the Additional Entitlements page, accept the default entitlements and click Continue.\n5. Provide a name for the profile, click Generate, and download the profile to your computer. Drag and drop the file to Xcode to add it.\n\nRepeat these same steps to create a profile for `NetworkingDriverKitSample`, with one key difference: on the Register a New Provisioning Profile page, choose DriverKit App Development.\n\nBack in Xcode, do the following:\n\n1. In the Project navigator’s Signing & Capabilities tab, disable “Automatically manage signing,” so that you can manually assign the provisioning profile. For each target, enter the unique bundle ID you chose earlier in the Bundle Identifier field, and use the Provisioning Profile popup to select the profile you downloaded in the previous two steps.\n2. If you want to run `NetworkingDriverKitSampleApp` directly from Xcode, enter dext development mode with the Terminal command `systemextensionsctl developer on` (for more information, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/debugging-and-testing-system-extensions]). Alternately, you can drag the built `DriverKitSample.app` from the build directory into the `\/Applications` directory and run it from there.\n\n### Use the System Extensions framework to install the driver extension\n\nThe `NetworkingDriverKitSampleApp` target declares `NetworkingDriverKitSample` as a dependency, so building the app target builds the dext and its installer together. When it’s running, `NetworkingDriverKitSampleApp` shows a single window with an Install Dext button.\n\nThe app uses the [doc:\/\/com.apple.systemextensions\/documentation\/SystemExtensions] framework to install and activate the dext. For more information, see `Installing System Extensions and Drivers`.\n\n```swift\nlet request = OSSystemExtensionRequest\n    .activationRequest(forExtensionWithIdentifier: dextIdentifier,\n                       queue: .main)\nrequest.delegate = self\nOSSystemExtensionManager.shared.submitRequest(request)\n```\n\n\n\n\n\nAfter installation, the driver appears in System Settings as Ethernet Adapter (enXX), where *XX* is a number, like `en17`. You can also see the extension in Terminal with the command `systemextensionsctl list`, which lists all running system extensions. When the driver is running, it has an entry like the following, but with a different `teamID` value:\n\n```swift\n~ % systemextensionsctl list\n1 extension(s)\n--- com.apple.system_extension.driver_extension\nenabled    active    teamID    bundleID (version)    name    [state]\n*    *    A123456789    com.example.apple-samplecode.NetworkingDriverKitSample (1.0\/1)    com.example.apple-samplecode.NetworkingDriverKitSample    [activated enabled]\n\n```\n\nYou can also inspect its entry in the I\/O Registry with the Terminal command `ioreg`. It appears in the registry tree with an entry like the following:\n\n```swift\n    | +-o NetworkingDriverKitSample  <class IOUserNetworkEthernet, id 0x100028cee, registered, matched, active, busy 0 (4 ms), retain 16>\n```\n\n### Start the driver by creating transmit and receive queues\n\nAt startup, NetworkingDriverKit calls the following methods on a driver as part of its lifecycle:\n\n- [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkEthernet\/init] — The object initializer, which a driver uses to allocate and initialize its instance variables.\n- [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] — The message that indicates NetworkingDriverKit matched a provider for the driver. Drivers use this method to reset hardware and pepare it for operation.\n- [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/SetPowerState] — An indication that the provider’s power state is changing. Drivers can use the first call to the method for setup, but typically do so in `Start()`. Instead, use this callback to get into and out of a safe state given the power setting.\n- [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkEthernet\/SetInterfaceEnable-3v24g] — This call enables or disables the Ethernet service. A hardware driver uses this callback to bring the hardware up or down based on the Boolean `isEnable` parameter.\n\nThe sample driver does its setup work in the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. The driver uses this opportunity to set up queues to ensure that calls to and from NetworkingDriverKit are thread-safe. First, the sample creates a primary dispatch queue, which it calls `Default`.\n\n```other\nret = CopyDispatchQueue(\"Default\", &ivars->dsQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n```\n\n\n\nThe `Start` method then uses this dispatch queue, stored in `ivars->dsQueue`, to create the transmit submission queue. Since the `.iig` file declares a method named `TxPacketAvailable`, DriverKit creates a method called `CreateActionTxPacketAvailable`. This method creates the action that DriverKit calls when packets are available to transmit. The following setup in `Start` creates a queue and calls `SetDataAvailableHandler` to tell the queue to use the newly created action. The actual implementation of `TxPacketAvailable` appears later in this article.\n\n```other\nret = CreateActionTxPacketAvailable(0, &ivars->txPacketAction);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nret = IOUserNetworkTxSubmissionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->txsQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = ivars->txsQueue->CopyDataQueue(&dataQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = dataQueue->SetDataAvailableHandler(ivars->txPacketAction);\nif (ret != kIOReturnSuccess)\n    goto fail;\n```\n\n\n\nNext, the `Start` method creates three queues — one for transmit completion, one for receive submission, and one for receive completion — and associates each of them with the dispatch queue, `ivars->dsQueue`.\n\n```other\nret = IOUserNetworkTxCompletionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->txcQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = IOUserNetworkRxSubmissionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->rxsQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nDLOG(\"==> %p (%p)\", this, provider);\n\nret = IOUserNetworkRxCompletionQueue::Create(\n    ivars->pool, this, 8, 0, ivars->dsQueue, &ivars->rxcQueue);\nif (ret != kIOReturnSuccess)\n    goto fail;\n```\n\n\n\nTo mimic reception of data from the network, the sample creates a timer. Since the timer needs a callback action, the `.iig` declares a `RecieveTimer` method, which prompts DriverKit to provide a `CreateActionReceiveTimer` method. The following listing calls that method to create the action, then sets it as the handler for an `IOTimerDispatchSource` stored in `ivars->receiveTimerSource`.\n\n```other\nret = IOTimerDispatchSource::Create(ivars->dsQueue, &ivars->receiveTimerSource);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nstatus = CreateActionReceiveTimer(sizeof(void *), &ivars->receiveTimer);\nif (ret != kIOReturnSuccess)\n    goto fail;\n\nstatus = ivars->receiveTimerSource->SetHandler(ivars->receiveTimer);\nif (ret != kIOReturnSuccess)\n    goto fail;\n```\n\n\n\nThe timer actually starts later, in `SetInterfaceEnable`, after enabling the transmit and receive queues seen earlier.\n\n```other\nnow = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);\ndeadline = now + 1000 * kMillisecondScale;\nret = ivars->receiveTimerSource->WakeAtTime(kIOTimerClockUptimeRaw, deadline, 0);\nif (ret != kIOReturnSuccess)\n    goto disable;\n```\n\n\n\n### Receive packets in an action callback\n\nWhen the timer fires, it calls the sample’s `ReceiveTimer` callback. For the purposes of the sample project, this creates a fake ICMP request packet that it can submit to the receive-completion queue. For each packet dequeued from the [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkRxSubmissionQueue], this method performs the following steps:\n\n- Copies in a block of static data called `echoRequest`\n- Sets the packet’s data offset, data length, and link header length\n- Enqueues the packet in the [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkRxCompletionQueue]\n- Deallocates the packet\n- Resets the timer for the next simulated receive-packets event\n\nIf any of the mutations to the packet fail, the sample deallocates the packet without enqueueing it. The timer update occurs in either case.\n\n```other\ndequeueCount = ivars->rxsQueue->DequeuePackets(packets, 8);\n\nlinkHeaderLength = 0;\nfor (i = 0; i < dequeueCount; i++) {\n    packet = packets[i];\n    good_packet = true;\n    dataAddr = (uint8_t *)packet->getDataVirtualAddress();\n    dataOffset = packet->getDataOffset();\n    \n    DLOG(\"dataAddr = %p dataOffset = %llu\", dataAddr, dataOffset);\n    \n    pktBuffer = (decltype(pktBuffer))(uintptr_t)(dataAddr + dataOffset);\n    \n    bcopy(echoRequest, pktBuffer, sizeof(echoRequest));\n\n    ret = packet->setDataOffset(dataOffset);\n    good_packet &= (ret == kIOReturnSuccess);\n\n    ret = packet->SetLinkHeaderLength(linkHeaderLength);\n    good_packet &= (ret == kIOReturnSuccess);\n\n    ret = packet->setDataLength(sizeof(echoRequest));\n    good_packet &= (ret == kIOReturnSuccess);\n\n    if (good_packet) {\n        DLOG(\"enqueue - packet[%d] = %p\", i, packet);\n\n        ret = ivars->rxcQueue->EnqueuePacket(packet);\n        if (ret != kIOReturnSuccess) {\n            ivars->pool->DeallocatePacket(packet);\n            LOG(\"Enqueue failed dropping pkt\\n\");\n        }\n    } else {\n        ivars->pool->DeallocatePacket(packet);\n        LOG(\"Packet setup failed dropping pkt\\n\");\n    }\n}\n\nnow = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);\ndeadline = now + 5ULL * kSecondScale;\nret = ivars->receiveTimerSource->WakeAtTime(kIOTimerClockUptimeRaw, deadline, 0);\nif (ret != kIOReturnSuccess) {\n    DLOG(\"error setting interrupt read timer 0x%08x\\n\", ret);\n}\n```\n\n\n\n### Transmit packets in an action callback\n\nThe `Start` method created the action `TxPacketAvailable` to handle callbacks when the networking stack places packets on the transmit-submssion queue. Like the packet-receive handler, this method dequeues available packets, this time from the [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkTxSubmissionQueue], and loops over them. For the purposes of the sample, this method implementation just logs the data address, data offset, and link header length of each packet, and enqueues it in the [doc:\/\/com.apple.networkingdriverkit\/documentation\/NetworkingDriverKit\/IOUserNetworkTxCompletionQueue].\n\n```other\ndequeueCount = ivars->txsQueue->DequeuePackets(packets, 8);\n\nlinkHeaderLength = 0;\n\nif (dequeueCount) {\n    for (i = 0; i < dequeueCount; i++) {\n        packet = packets[i];\n\n        DLOG(\"dequeue - TX packet[%d] = %p\", i, packet);\n\n        dataAddr = (uint8_t *)packet->getDataVirtualAddress();\n        dataOffset = packet->getDataOffset();\n        \n        ret = packet->GetLinkHeaderLength(&linkHeaderLength);\n        \n        DLOG(\"dataAddr = %p dataOffset = %llu linkHeaderLength = %d\", dataAddr, dataOffset, linkHeaderLength);\n\n        ret = ivars->txcQueue->EnqueuePacket(packet);\n        if (ret != kIOReturnSuccess) {\n            ivars->pool->DeallocatePacket(packet);\n            LOG(\"Returning Tx Packet failed just return to pool\\n\");\n        }\n    }\n}\n```\n\n\n\n### Remove the running driver\n\nWhen shipping a DriverKit driver, people delete the driver by removing the parent app from their `\/Applications` directory. If you’re using dext developer mode to build and run the driver from Xcode, then you need to remove the driver manually.\n\nTo remove the driver, use the `systemextensionsctl uninstall` command, passing the team ID and the driver’s bundle ID. To look up these identifiers, use the `systemextensionsctl list` command to return both of these values. Invoke the `uninstall` command as follows:\n\n```swift\n~ % systemextensionsctl uninstall A123456789 com.example.apple-samplecode.NetworkingDriverKitSample\n```\n\nAfter authorization – via password, Touch ID, or an equivalent – the driver disappears from the System Settings network pane, and will no longer appear in the I\/O Registry.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Connecting a network driver",
  "url" : "https:\/\/developer.apple.com\/documentation\/pcidriverkit\/connecting_a_network_driver"
}