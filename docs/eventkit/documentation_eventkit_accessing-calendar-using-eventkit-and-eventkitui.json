{
  "abstract" : "Choose and implement the appropriate Calendar access level in your app.",
  "codeExamples" : [
    {
      "code" : "@State private var store = EKEventStore()",
      "language" : "swift"
    },
    {
      "code" : "    .sheet(isPresented: $showEventEditViewController,\n           onDismiss: didDismissEventEditController, content: {\n       EventEditViewController(event: $selectedEvent, eventStore: store)\n})",
      "language" : "swift"
    },
    {
      "code" : "let controller = EKEventEditViewController()\ncontroller.eventStore = eventStore\ncontroller.event = event\ncontroller.editViewDelegate = context.coordinator",
      "language" : "swift"
    },
    {
      "code" : "func eventEditViewController(_ controller: EKEventEditViewController, didCompleteWith action: EKEventEditViewAction) {\n    parent.presentationMode.wrappedValue.dismiss()\n}",
      "language" : "swift"
    },
    {
      "code" : "return try await eventStore.requestWriteOnlyAccessToEvents()",
      "language" : "swift"
    },
    {
      "code" : "try self.eventStore.save(newEvent, span: .futureEvents)",
      "language" : "swift"
    },
    {
      "code" : ".sheet(isPresented: $showCalendarChooser) {\n    CalendarChooser(calendar: $calendar)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Initializes a calendar chooser that allows the user to select a single calendar from a list of writable calendars only.\nlet calendarChooser = EKCalendarChooser(selectionStyle: .single,\n                                        displayStyle: .writableCalendarsOnly,\n                                        entityType: .event,\n                                        eventStore: storeManager.store)",
      "language" : "swift"
    },
    {
      "code" : "\/*\n    Set up the selected calendars property. If the user previously selected a calendar from the view controller, update the property with it.\n    Otherwise, update selected calendars with an empty set.\n*\/\nif let calendar = calendar {\n    let selectedCalendar: Set<EKCalendar> = [calendar]\n    calendarChooser.selectedCalendars = selectedCalendar\n} else {\n    calendarChooser.selectedCalendars = []\n}",
      "language" : "swift"
    },
    {
      "code" : "calendarChooser.delegate = context.coordinator\n\/\/ Configure the chooser to display Done and Cancel buttons.\ncalendarChooser.showsDoneButton = true\ncalendarChooser.showsCancelButton = true\nreturn UINavigationController(rootViewController: calendarChooser)",
      "language" : "swift"
    },
    {
      "code" : "let center = NotificationCenter.default\nlet notifications = center.notifications(named: .EKEventStoreChanged).map({ (notification: Notification) in notification.name })\nfor await _ in notifications {\n    guard await dataStore.isFullAccessAuthorized else { return }\n    await self.fetchLatestEvents()\n}",
      "language" : "swift"
    },
    {
      "code" : "let status = EKEventStore.authorizationStatus(for: .event)",
      "language" : "swift"
    },
    {
      "code" : "return try await eventStore.requestFullAccessToEvents()",
      "language" : "swift"
    },
    {
      "code" : "EKEventStore.authorizationStatus(for: .event) == .fullAccess",
      "language" : "swift"
    },
    {
      "code" : "let start = Date.now\nlet end = start.oneMonthOut\nlet predicate = eventStore.predicateForEvents(withStart: start, end: end, calendars: nil)\nreturn eventStore.events(matching: predicate).sortedEventByAscendingDate()",
      "language" : "swift"
    },
    {
      "code" : "try self.eventStore.remove(event, span: .thisEvent, commit: false)",
      "language" : "swift"
    },
    {
      "code" : "try eventStore.commit()",
      "language" : "swift"
    },
    {
      "code" : "eventStore.reset()",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Fall back on earlier versions.\nreturn try await eventStore.requestAccess(to: .event)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Fall back on earlier versions.\nEKEventStore.authorizationStatus(for: .event) == .authorized",
      "language" : "swift"
    }
  ],
  "contentHash" : "c7d0b364f0961b69060910d5a3c333f9d7a8ba4d933643044af3e6a0a95ac1b2",
  "crawledAt" : "2025-12-02T15:46:46Z",
  "id" : "6D0C58EA-0DCB-45D3-BF37-B9A90E906FF2",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "EventKit",
  "overview" : "## Overview\n\nPrior to iOS 17, your app needs to include the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSCalendarsUsageDescription] key in its `Info.plist` and request authorization from the user before it can access the user’s calendar data. `NSCalendarsUsageDescription` indicates how your app intends to use calendar data. If the user approves the request, the app gets full access to all events on all the user’s calendars, including the ones the app didn’t create. If the user denies the request, the app gets no access to the user’s data.\n\nStarting in iOS 17, your app should only request the specific level of access it requires to complete its calendar data tasks. The iOS 17 SDK introduces new calendar usage description strings, the ability to add events to Calendar without prompting the user for access, and a new write-only access. See [doc:\/\/com.apple.documentation\/documentation\/EventKit\/accessing-the-event-store] for details.\n\nThis sample consists of three targets that illustrate how to implement Calendar access level using EventKit and EventKitUI. The `DropInLessons` target builds an app that saves events to Calendar without prompting the user for authorization. The `RepeatingLessons` target, which implements the write-only access feature, builds an app that saves events directly to Calendar with user permission. The `MonthlyEvents` target, which illustrates the full-access feature, builds an app that fetches and displays all events occuring within a month in all the user’s calendars.\n\n### Configure the sample code project\n\nBefore you run the sample code project in Xcode:\n\n### Save events without prompting the user for access\n\nIn iOS 17, your app can add events to Calendar without prompting the user for access using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventEditViewController]. If the purpose of your app is to create, configure, and present calendar events in an editor UI, consider saving events to Calendar without prompting the user for authorization in your app following these steps:\n\nThe `DropInLessons` app writes data to Calendar without performing any other operations on the user’s events. Because its workflow doesn’t interact with the user’s calendar data, the app isn’t required to include any calendar usage strings or prompt the user for access. [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore] allows apps to request permission from the user, and read and write data to Calendar. `DropInLessons` creates an instance of the event store, `store`.\n\nWhen the user schedules a lesson, `DropInLessons` creates a `selectedEvent`, then presents an event edit view controller.\n\nThe app creates `selectedEvent` in the event store, adds it to the default calendar for the store, then configures `selectedEvent` with the selected lesson’s details. The view controller takes `selectedEvent` and `store` as parameters.\n\n`DropInLessons` relinquishes control once the editor is presented. Because the event edit view controller renders its content out of process, it has full access to all the user’s calendars on the device, regardless of the access granted to the app. This allows the user to get a full-featured editing experience, such as choosing another calendar to save the selected lesson or changing presented information in the editor. However, the app isn’t aware of any of these changes. When the user taps the Add button in the UI, the system saves the lesson to the user’s selected or default calendar, then dismisses the editor.\n\nBecause the calendar edits happen out of process, inspecting the properties of the dismissed `controller`, such as [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventEditViewController\/event], to determine what the user added to Calendar doesn’t return any useful information. The app isn’t aware of the changes, which naturally means it can’t see them.\n\n### Request write-only access\n\nIn iOS 17, an app with write-only access can create and save events to Calendar, display events using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventEditViewController], and allow the user to select another calendar using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooser]. If your app needs to write data directly, consider implementing write-only access in your app following these steps:\n\n`RepeatingLessons` displays a list of recurring lessons and a “Select calendar” button in the toolbar. The app offers the lessons on specific dates and times and doesn’t fetch any events from the user’s calendars. `RepeatingLessons` can’t let the user or the system make any changes to these events. Because of these reasons, the app requires write-only access so it can control the date and time of every event added to Calendar. When the user selects a lesson, then taps the booking button, the app first checks whether it has authorization to access the user’s calendar data. If the authorization status is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined], the app uses an instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore], `eventStore`, to prompt the user for write-only access.\n\n`RepeatingLessons` includes `NSCalendarsWriteOnlyAccessUsageDescription` in its `Info.plist` file and uses its value when showing an alert. The alert prompts the user for write-only acess to save repeating lessons to a calendar that the user chooses. If the user grants the request, the app receives a `.writeOnly` authorization status, creates a recurring event using the selected lesson’s details, then saves it to Calendar without the user making any changes to this event.\n\nThe “Select calendar” button in the toolbar allows the user to choose another calendar to save the recurring events using `EKCalendarChooser`. The app turns off the button by default. The app turns it on when the user grants write-only or full access to the app. When the user taps the button, `RepeatingLessons` presents a calendar chooser with an instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendar], `calendar`, which keeps track of calendars the user chooses in the view controller.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooserDisplayStyle] property of `EKCalendarChooser` specifies whether to display writable calendars only or all calendars. In write-only access apps, the calendar chooser ignores the value of the `displayStyle` setting and this setting always behaves as if it’s set to [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooserDisplayStyle\/writableCalendarsOnly]. As a result, the app only allows the user to select a single writable calendar from the list presented in the calendar chooser.\n\nThe app sets the [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooser\/selectedCalendars] property of `EKCalendarChooser` to `calendar`, which is empty when the user hasn’t selected a calendar.\n\n`RepeatingLessons` configures the chooser to show the Done and Cancel buttons.\n\nIf the user chooses a calendar from the view controller, `RepeatingLessons` adds recurring events to that calendar. If the user doesn’t make any selection, the app saves the events to the user’s default calendar.\n\n### Request full access\n\nIn iOS 17, an app with full access can create, edit, save, delete, and fetch all events on all the user’s calendars. Additionally, the app can display events using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventViewController] and allow the user to select another calendar using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooser]. Implement full access if your app needs to read and write data to Calendar. If your app only needs to write data directly to Calendar, implement write-only access instead. If your app only uses EventKit APIs to create and set up events, consider saving events to Calendar without prompting the user for authorization.\n\nTo implement full access in your app, follow these steps:\n\nUpon its first launch, the `MonthlyEvents` app registers for [https:\/\/developer.apple.com\/documentation\/foundation\/nsnotification\/name\/ekeventstorechanged] notifications to listen for any changes to the event store.\n\nThen, the app checks whether it’s authorized to access the user’s calendar data.\n\nIf the authorization status is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined], the app uses an instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore], `eventStore`, to prompt the user for full access.\n\n`MonthlyEvents` includes `NSCalendarsFullAccessUsageDescription` in its `Info.plist` file and uses its value when showing an alert. The alert  prompts the user for  full access to fetch events in all the user’s calendars and delete the ones the user selects in the app. If the user grants the request, the app receives a `.fullAccess` authorization status.\n\nThen, the app fetches and displays all events occuring within a month in all the user’s calendars sorted by start date in ascending order.\n\nIf the user denies the request, the app does nothing. In subsequent launches, the app displays a message prompting the user to grant the app full access in Settings on their device.\n\nBecause the user authorized the app for full access, the user can additionally select and delete one or more events in `MonthlyEvents`. The app iterates through an array of events that the user chose to delete. It calls and sets the `commit` parameter of the [doc:\/\/com.apple.eventkit\/documentation\/EventKit\/EKEventStore\/remove(_:span:commit:)] function to `false` to batch the deletion of each event in the array.\n\nThen, the app commits the changes once it’s done iterating through the array.\n\nWhen you assign `true` to `commit` to immediately save or remove the event in your app, the event store automatically rolls back any changes if the commit operation fails. However, if you set `commit` to `false` and your app successfully removes some events and fails removing others, this can result in a later commit failing. Every subsequent commit fails until you roll back the changes. Call [doc:\/\/com.apple.eventkit\/documentation\/EventKit\/EKEventStore\/reset()] to manually roll back the changes.\n\n### Run apps on operating system earlier than iOS 17\n\nIf you build your app with Xcode 15, link it against the iOS 17 SDK, and need to run it on systems earlier than iOS 17:\n\nThe `DropInLessons`, `MonthlyEvents`, and `RepeatingLessons` targets in the sample project have a deployment target of iOS 16.4, meaning their apps can run on devices running iOS 16.4 and later. These apps include `NSCalendarsUsageDescription` in their `Info.plist` and use `requestAccess(to: .event`) when requesting permission from the user.\n\n`MonthlyEvents` and `RepeatingLessons` confirm that they have an [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus] authorization status.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/EventKit\/accessing-calendar-using-eventkit-and-eventkitui\ncrawled: 2025-12-02T15:46:46Z\n---\n\n# Accessing Calendar using EventKit and EventKitUI\n\n**Sample Code**\n\nChoose and implement the appropriate Calendar access level in your app.\n\n## Overview\n\nPrior to iOS 17, your app needs to include the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSCalendarsUsageDescription] key in its `Info.plist` and request authorization from the user before it can access the user’s calendar data. `NSCalendarsUsageDescription` indicates how your app intends to use calendar data. If the user approves the request, the app gets full access to all events on all the user’s calendars, including the ones the app didn’t create. If the user denies the request, the app gets no access to the user’s data.\n\nStarting in iOS 17, your app should only request the specific level of access it requires to complete its calendar data tasks. The iOS 17 SDK introduces new calendar usage description strings, the ability to add events to Calendar without prompting the user for access, and a new write-only access. See [doc:\/\/com.apple.documentation\/documentation\/EventKit\/accessing-the-event-store] for details.\n\nThis sample consists of three targets that illustrate how to implement Calendar access level using EventKit and EventKitUI. The `DropInLessons` target builds an app that saves events to Calendar without prompting the user for authorization. The `RepeatingLessons` target, which implements the write-only access feature, builds an app that saves events directly to Calendar with user permission. The `MonthlyEvents` target, which illustrates the full-access feature, builds an app that fetches and displays all events occuring within a month in all the user’s calendars.\n\n\n\n### Configure the sample code project\n\nBefore you run the sample code project in Xcode:\n\n- Open the sample with Xcode 15 or later.\n- Select the top-level Calendar Access project.\n- For the three targets, choose your team from the Team menu in the Signing & Capabilities pane to let Xcode automatically manage your provisioning profile.\n- Select the target you wish to build, then build and run it in the Simulator, in Mac Catalyst, or on a device.\n\n### Save events without prompting the user for access\n\nIn iOS 17, your app can add events to Calendar without prompting the user for access using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventEditViewController]. If the purpose of your app is to create, configure, and present calendar events in an editor UI, consider saving events to Calendar without prompting the user for authorization in your app following these steps:\n\n- Build your app with Xcode 15 and link against the iOS 17 SDK.\n- If your app includes [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSCalendarsUsageDescription], remove this key.\n- If your app requests permission using [https:\/\/developer.apple.com\/documentation\/eventkit\/ekeventstore\/requestaccess] or `requestAccess(to:)`, remove these instance methods from your source code.\n\nThe `DropInLessons` app writes data to Calendar without performing any other operations on the user’s events. Because its workflow doesn’t interact with the user’s calendar data, the app isn’t required to include any calendar usage strings or prompt the user for access. [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore] allows apps to request permission from the user, and read and write data to Calendar. `DropInLessons` creates an instance of the event store, `store`.\n\n```swift\n@State private var store = EKEventStore()\n```\n\nWhen the user schedules a lesson, `DropInLessons` creates a `selectedEvent`, then presents an event edit view controller.\n\n```swift\n    .sheet(isPresented: $showEventEditViewController,\n           onDismiss: didDismissEventEditController, content: {\n       EventEditViewController(event: $selectedEvent, eventStore: store)\n})\n```\n\nThe app creates `selectedEvent` in the event store, adds it to the default calendar for the store, then configures `selectedEvent` with the selected lesson’s details. The view controller takes `selectedEvent` and `store` as parameters.\n\n```swift\nlet controller = EKEventEditViewController()\ncontroller.eventStore = eventStore\ncontroller.event = event\ncontroller.editViewDelegate = context.coordinator\n```\n\n`DropInLessons` relinquishes control once the editor is presented. Because the event edit view controller renders its content out of process, it has full access to all the user’s calendars on the device, regardless of the access granted to the app. This allows the user to get a full-featured editing experience, such as choosing another calendar to save the selected lesson or changing presented information in the editor. However, the app isn’t aware of any of these changes. When the user taps the Add button in the UI, the system saves the lesson to the user’s selected or default calendar, then dismisses the editor.\n\n```swift\nfunc eventEditViewController(_ controller: EKEventEditViewController, didCompleteWith action: EKEventEditViewAction) {\n    parent.presentationMode.wrappedValue.dismiss()\n}\n```\n\nBecause the calendar edits happen out of process, inspecting the properties of the dismissed `controller`, such as [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventEditViewController\/event], to determine what the user added to Calendar doesn’t return any useful information. The app isn’t aware of the changes, which naturally means it can’t see them.\n\n### Request write-only access\n\nIn iOS 17, an app with write-only access can create and save events to Calendar, display events using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventEditViewController], and allow the user to select another calendar using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooser]. If your app needs to write data directly, consider implementing write-only access in your app following these steps:\n\n- Build your app with Xcode 15 and link against the iOS 17 SDK.\n- Add the `NSCalendarsWriteOnlyAccessUsageDescription` key to the `Info.plist` file of the target building your app.\n- To request write-only access to events, use `requestWriteOnlyAccessToEvents(completion:)` or `requestWriteOnlyAccessToEvents()`.\n\n\n\n`RepeatingLessons` displays a list of recurring lessons and a “Select calendar” button in the toolbar. The app offers the lessons on specific dates and times and doesn’t fetch any events from the user’s calendars. `RepeatingLessons` can’t let the user or the system make any changes to these events. Because of these reasons, the app requires write-only access so it can control the date and time of every event added to Calendar. When the user selects a lesson, then taps the booking button, the app first checks whether it has authorization to access the user’s calendar data. If the authorization status is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined], the app uses an instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore], `eventStore`, to prompt the user for write-only access.\n\n```swift\nreturn try await eventStore.requestWriteOnlyAccessToEvents()\n```\n\n`RepeatingLessons` includes `NSCalendarsWriteOnlyAccessUsageDescription` in its `Info.plist` file and uses its value when showing an alert. The alert prompts the user for write-only acess to save repeating lessons to a calendar that the user chooses. If the user grants the request, the app receives a `.writeOnly` authorization status, creates a recurring event using the selected lesson’s details, then saves it to Calendar without the user making any changes to this event.\n\n```swift\ntry self.eventStore.save(newEvent, span: .futureEvents)\n```\n\nThe “Select calendar” button in the toolbar allows the user to choose another calendar to save the recurring events using `EKCalendarChooser`. The app turns off the button by default. The app turns it on when the user grants write-only or full access to the app. When the user taps the button, `RepeatingLessons` presents a calendar chooser with an instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendar], `calendar`, which keeps track of calendars the user chooses in the view controller.\n\n```swift\n.sheet(isPresented: $showCalendarChooser) {\n    CalendarChooser(calendar: $calendar)\n}\n```\n\nThe [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooserDisplayStyle] property of `EKCalendarChooser` specifies whether to display writable calendars only or all calendars. In write-only access apps, the calendar chooser ignores the value of the `displayStyle` setting and this setting always behaves as if it’s set to [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooserDisplayStyle\/writableCalendarsOnly]. As a result, the app only allows the user to select a single writable calendar from the list presented in the calendar chooser.\n\n```swift\n\/\/ Initializes a calendar chooser that allows the user to select a single calendar from a list of writable calendars only.\nlet calendarChooser = EKCalendarChooser(selectionStyle: .single,\n                                        displayStyle: .writableCalendarsOnly,\n                                        entityType: .event,\n                                        eventStore: storeManager.store)\n```\n\nThe app sets the [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooser\/selectedCalendars] property of `EKCalendarChooser` to `calendar`, which is empty when the user hasn’t selected a calendar.\n\n```swift\n\/*\n    Set up the selected calendars property. If the user previously selected a calendar from the view controller, update the property with it.\n    Otherwise, update selected calendars with an empty set.\n*\/\nif let calendar = calendar {\n    let selectedCalendar: Set<EKCalendar> = [calendar]\n    calendarChooser.selectedCalendars = selectedCalendar\n} else {\n    calendarChooser.selectedCalendars = []\n}\n```\n\n`RepeatingLessons` configures the chooser to show the Done and Cancel buttons.\n\n```swift\ncalendarChooser.delegate = context.coordinator\n\/\/ Configure the chooser to display Done and Cancel buttons.\ncalendarChooser.showsDoneButton = true\ncalendarChooser.showsCancelButton = true\nreturn UINavigationController(rootViewController: calendarChooser)\n```\n\nIf the user chooses a calendar from the view controller, `RepeatingLessons` adds recurring events to that calendar. If the user doesn’t make any selection, the app saves the events to the user’s default calendar.\n\n### Request full access\n\nIn iOS 17, an app with full access can create, edit, save, delete, and fetch all events on all the user’s calendars. Additionally, the app can display events using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKEventViewController] and allow the user to select another calendar using [doc:\/\/com.apple.documentation\/documentation\/EventKitUI\/EKCalendarChooser]. Implement full access if your app needs to read and write data to Calendar. If your app only needs to write data directly to Calendar, implement write-only access instead. If your app only uses EventKit APIs to create and set up events, consider saving events to Calendar without prompting the user for authorization.\n\nTo implement full access in your app, follow these steps:\n\n- Build your app with Xcode 15 and link against the iOS 17 SDK.\n- Add the `NSCalendarsFullAccessUsageDescription` key to the `Info.plist` file of the target building your app.\n- To request full access to events, use `requestFullAccessToEvents(completion:)` or `requestFullAccessToEvents()`.\n\nUpon its first launch, the `MonthlyEvents` app registers for [https:\/\/developer.apple.com\/documentation\/foundation\/nsnotification\/name\/ekeventstorechanged] notifications to listen for any changes to the event store.\n\n```swift\nlet center = NotificationCenter.default\nlet notifications = center.notifications(named: .EKEventStoreChanged).map({ (notification: Notification) in notification.name })\nfor await _ in notifications {\n    guard await dataStore.isFullAccessAuthorized else { return }\n    await self.fetchLatestEvents()\n}\n```\n\nThen, the app checks whether it’s authorized to access the user’s calendar data.\n\n```swift\nlet status = EKEventStore.authorizationStatus(for: .event)\n```\n\nIf the authorization status is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined], the app uses an instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore], `eventStore`, to prompt the user for full access.\n\n```swift\nreturn try await eventStore.requestFullAccessToEvents()\n```\n\n`MonthlyEvents` includes `NSCalendarsFullAccessUsageDescription` in its `Info.plist` file and uses its value when showing an alert. The alert  prompts the user for  full access to fetch events in all the user’s calendars and delete the ones the user selects in the app. If the user grants the request, the app receives a `.fullAccess` authorization status.\n\n```swift\nEKEventStore.authorizationStatus(for: .event) == .fullAccess\n```\n\nThen, the app fetches and displays all events occuring within a month in all the user’s calendars sorted by start date in ascending order.\n\n```swift\nlet start = Date.now\nlet end = start.oneMonthOut\nlet predicate = eventStore.predicateForEvents(withStart: start, end: end, calendars: nil)\nreturn eventStore.events(matching: predicate).sortedEventByAscendingDate()\n```\n\nIf the user denies the request, the app does nothing. In subsequent launches, the app displays a message prompting the user to grant the app full access in Settings on their device.\n\nBecause the user authorized the app for full access, the user can additionally select and delete one or more events in `MonthlyEvents`. The app iterates through an array of events that the user chose to delete. It calls and sets the `commit` parameter of the [doc:\/\/com.apple.eventkit\/documentation\/EventKit\/EKEventStore\/remove(_:span:commit:)] function to `false` to batch the deletion of each event in the array.\n\n```swift\ntry self.eventStore.remove(event, span: .thisEvent, commit: false)\n```\n\nThen, the app commits the changes once it’s done iterating through the array.\n\n```swift\ntry eventStore.commit()\n```\n\nWhen you assign `true` to `commit` to immediately save or remove the event in your app, the event store automatically rolls back any changes if the commit operation fails. However, if you set `commit` to `false` and your app successfully removes some events and fails removing others, this can result in a later commit failing. Every subsequent commit fails until you roll back the changes. Call [doc:\/\/com.apple.eventkit\/documentation\/EventKit\/EKEventStore\/reset()] to manually roll back the changes.\n\n```swift\neventStore.reset()\n```\n\n### Run apps on operating system earlier than iOS 17\n\nIf you build your app with Xcode 15, link it against the iOS 17 SDK, and need to run it on systems earlier than iOS 17:\n\n- Add [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSCalendarsUsageDescription] to the `Info.plist` file of the target building your app. If your app that’s linked on iOS 10 through iOS 16 doesn’t include `NSCalendarsUsageDescription`, your app crashes.\n- To request access to events, use [doc:\/\/com.apple.eventkit\/documentation\/EventKit\/EKEventStore\/requestAccess(to:completion:)] or `requestAccess(to: .event)`.\n- To determine whether your app is authorized to access the user’s calendar data, confirm that [https:\/\/developer.apple.com\/documentation\/eventkit\/ekeventstore\/authorizationstatus] is set to [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus].\n\n\n\nThe `DropInLessons`, `MonthlyEvents`, and `RepeatingLessons` targets in the sample project have a deployment target of iOS 16.4, meaning their apps can run on devices running iOS 16.4 and later. These apps include `NSCalendarsUsageDescription` in their `Info.plist` and use `requestAccess(to: .event`) when requesting permission from the user.\n\n```swift\n\/\/ Fall back on earlier versions.\nreturn try await eventStore.requestAccess(to: .event)\n```\n\n\n\n`MonthlyEvents` and `RepeatingLessons` confirm that they have an [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus] authorization status.\n\n```swift\n\/\/ Fall back on earlier versions.\nEKEventStore.authorizationStatus(for: .event) == .authorized\n```\n\n## Essentials\n\n- **Accessing the event store**: Request access to a person’s calendar data through the event store.\n- **EKEventStore**: An object that accesses a person’s calendar events and reminders and supports the scheduling of new events.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Request access to a person’s calendar data through the event store.",
          "name" : "Accessing the event store",
          "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/accessing-the-event-store"
        },
        {
          "description" : "An object that accesses a person’s calendar events and reminders and supports the scheduling of new events.",
          "name" : "EKEventStore",
          "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/EKEventStore"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Accessing Calendar using EventKit and EventKitUI",
  "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/accessing-calendar-using-eventkit-and-eventkitui"
}