{
  "abstract" : "Access reminders set up with geofence-enabled alarms on a person’s calendars.",
  "codeExamples" : [
    {
      "code" : "authorizationStatus = EKEventStore.authorizationStatus(for: .reminder)",
      "language" : "swift"
    },
    {
      "code" : "return try await withCheckedThrowingContinuation { continuation in\n    eventStore.requestFullAccessToReminders { granted, error in\n        if let error {\n            continuation.resume(throwing: error)\n        }\n        continuation.resume(returning: granted)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "eventStore.defaultCalendarForNewReminders() != nil",
      "language" : "swift"
    },
    {
      "code" : "let reminder = EKReminder(eventStore: eventStore)\nreminder.calendar = calendar\nreminder.title = entry.title\nreminder.priority = entry.priority\n\n\/*\n    The app creates reminders with a specific date and time. To create an\n    all-day reminder, set `dueDateComponents` to a date component without\n    hour, minute, and second components.\n*\/\nreminder.dueDateComponents = Date.next7DaysComponents\n\n\/*\n    A floating reminder is one that isn't associated with a specific time\n    zone. Set `timeZone` to `nil` if you wish to have a floating reminder.\n*\/\nreminder.timeZone = TimeZone.current",
      "language" : "swift"
    },
    {
      "code" : "let structuredLocation = EKStructuredLocation(title: annotation.name)\nstructuredLocation.geoLocation = CLLocation(latitude: annotation.coordinates.latitude, longitude: annotation.coordinates.longitude)",
      "language" : "swift"
    },
    {
      "code" : "let structuredLocation = EKStructuredLocation(mapItem: mapItem)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Get the person's preferred unit of length measurement.\nlet preferredUnit = UnitLength(forLocale: .current, usage: .asProvided)\nstructuredLocation.radius = (preferredUnit == .meters) ? entry.radius : entry.radius.convert(from: preferredUnit, to: .meters)",
      "language" : "swift"
    },
    {
      "code" : "let alarm = EKAlarm(relativeOffset: 0)\nalarm.structuredLocation = structuredLocation\nalarm.proximity = entry.proximity",
      "language" : "swift"
    },
    {
      "code" : "reminder.addAlarm(alarm)",
      "language" : "swift"
    },
    {
      "code" : "try eventStore.save(reminder, commit: true)",
      "language" : "swift"
    },
    {
      "code" : "let predicate = eventStore.predicateForReminders(in: nil)",
      "language" : "swift"
    },
    {
      "code" : "return await withCheckedContinuation { continuation in\n    eventStore.fetchReminders(matching: predicate) { reminders in\n        var result: [LocationReminder] = []\n        \n        if let reminders {\n            result = reminders\n                .filter(\\.isLocation)\n                .map { LocationReminder(reminder: $0) }\n        }\n        continuation.resume(returning: result)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Specifies whether the reminder is location-based.\nvar isLocation: Bool {\n    guard let alarms else { return false }\n    \n    let proximityAlarms = alarms.filter {\n        $0.structuredLocation != nil && ($0.proximity == .enter || $0.proximity == .leave)\n    }\n    \n    return !proximityAlarms.isEmpty\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Sorts reminders by creation date, due date, or title in ascending order.\nfunc reminders(sortedBy sort: ReminderSortValue) -> [LocationReminder] {\n    switch sort {\n    case .creationDate: return self.sorted(by: \\.creationDate)\n    case .dueDate: return self.sorted(by: \\.dueDate)\n    case .title: return self.sorted(by: \\.title)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "84884b24d55ed851e8e688e731cd121a60087be9c4686f615d94706addcbb3fc",
  "crawledAt" : "2025-12-04T17:48:08Z",
  "id" : "7210A0DF-8E4A-4182-A771-0500080A76BE",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "EventKit",
  "overview" : "## Overview\n\nWith the Reminders app, people can create reminders with alarms based on time and location. When Location Services is turned on, people receive location-based reminders when entering or leaving a specified geographic area or geofence. This sample code demonstrates how to add, fetch, complete, remove, filter, and sort location-based reminders. You app must first request full access to reminders from the person using the app before it can access their reminder data. An app with full access can create, edit, save, delete, and fetch all reminders on all of the person’s calendars. For more information, see [doc:\/\/com.apple.documentation\/documentation\/EventKit\/accessing-the-event-store]. Next, register your app for [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStoreChangedNotification] notifications at launch to listen for any changes to the person’s Calendar database. When your app receives this notification, consider your current reminder data are stale or invalid and refetch all your reminders. For more information, see [doc:\/\/com.apple.documentation\/documentation\/EventKit\/updating-with-notifications].\n\n### Configure the sample code project\n\nBefore running the sample code project in Xcode, select the sample target, then configure it to use your team for signing. For more information, see Assign the project to a team in [doc:\/\/com.apple.documentation\/documentation\/Xcode\/preparing-your-app-for-distribution].\n\n### Provide a map annotation\n\nThe sample app presents a map with custom annotations that someone can use to create location-based reminders within the app. It uses location-specific data saved in the `MapData.json` file to create annotations for the map. The sample defines a `MapAnnotation` data type to represent each annotation. `MapData.json` contains three `MapAnnotation` entries. To test reminders around other locations, duplicate and update a `MapAnnotation` entry in `MapData.json` with other data as needed.\n\nThe sample displays a settings button that allows the person to grant or deny the app access to location services. If the person grants permission, the app uses the person’s current location to add a user annotation to the map. If the person denies access, the app does nothing.\n\n### Provide a full-access usage description for reminders\n\nThe sample includes the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSRemindersFullAccessUsageDescription] key in its `Info.plist` file. The value of the key is a string that explains why the app needs access to a person’s reminders. The system displays the string when prompting the person for authorization.\n\n### Check your app authorization status\n\nThe sample app verifies its authorization status upon launching. The authorization status of the app is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined] until the person authorizes or denies access. The person can grant or deny the app access to their reminder data, then change the authorization status later in the Settings app. To determine its status, the app calls the [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/authorizationStatus(for:)] class method of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore] with an entity type [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEntityType\/reminder]:\n\n### Request full access\n\nIf the authorization status is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined], the sample app initializes a single instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore], `eventStore`, then calls its [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/requestFullAccessToReminders(completion:)] method to prompt the person for full access:\n\nIf the person approves the request, the app receives a [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/fullAccess] authorization status. It fetches location reminders in all of the person’s calendars, then displays them organized by priority. If the person denies the request, the app gets no access and displays a message prompting the person to grant the app full access in Settings on their device.\n\n### Check for a default list\n\nCreating a reminder requires a list, which is a calendar for these items. The app calls [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/defaultCalendarForNewReminders()] on `eventStore` to check whether the person has specified a default list for reminders.\n\nThe app fetches and displays location reminders in all of the person’s calendars if `defaultCalendarForNewReminders()` returns a value, and shows a message prompting the person to create a list, otherwise.\n\n### Create location-based reminders\n\nA location-based reminder is a reminder created with a geofence-enabled alarm. A geofence-enabled alarm has a structured location and proximity configured. The structured location consists of a location object and radius. To use the default radius, set its value to 0. The sample uses the following steps to create a location-based reminder:\n\nFirst, the sample app creates an [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKReminder] object using [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKReminder\/init(eventStore:)], then it sets the [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendarItem\/title] and [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendarItem\/calendar] properties, and other properties, such as priority and time zone:\n\nNext, the sample creates a structured location by using either [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation]’s [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/init(title:)] or [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/init(mapItem:)] methods. When the location object has latitude and longitude coordinates, the app uses `init(title:)` to create the structured location. The sample initializes an [https:\/\/developer.apple.com\/documentation\/corelocation\/cllocation] object with the specified latitude and longitude, then assigns it to the created structured location’s [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/geoLocation] property:\n\nWhen the location object is an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapItem] object, the sample uses `init(mapItem:)` to create the structured location:\n\nEventKit defines the structured location’s [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/radius] property in meters. When someone enters a value for the radius, the app checks the person’s preferences for unit of length measurement. If the person’s preferred unit of length is a unit other than meters, the sample converts the radius value to meters, then assigns the converted value to the structured location’s `radius` property:\n\nNext, the sample creates an [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAlarm] object, then sets its [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation] property to the created structured location object. The sample then sets the [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAlarm\/proximity] property to a value to finish configuring the alarm’s geofence:\n\nThe app adds the created alarm to the reminder. For more information on adding alarms, see [doc:\/\/com.apple.documentation\/documentation\/EventKit\/setting-an-alarm].\n\nFinally, it saves the reminder to the person’s Calendar database:\n\n### Fetch location-based reminders\n\nThe [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/fetchReminders(matching:completion:)] method asynchronously fetches all reminders matching a given predicate. The app calls this method with [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/predicateForReminders(in:)] to fetch complete and incomplete reminders. The predicate takes `nil` or an array of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendarItem\/calendar] objects in its `calendars` parameters. Pass `nil` to fetch from all of the person’s calendars, and an array to fetch reminders from a subset of the person’s calendars. The app passes `nil` to `predicateForReminders(in:)`:\n\nThen, the app executes the fetch request. If the request succeeds, `fetchReminders(matching:completion:)` returns an array that contains both time-based and location-based reminders:\n\nTo retrieve location-based reminders, the app parses the returned array for reminders defined with an existing alarm that has a `structuredlocation` and `proximity` value:\n\n### Filter and sort reminders\n\nAfter fetching the location-based reminders, the app displays a segmented control that organizes the fetched reminders by priority: None, Low, Medium, and High. Fetching reminders from the Calendar database returns reminders sorted by creation date. The app offers a menu that lets people choose how to sort the reminders by creation date, due date, or title in ascending order. When someone selects a priority in the control, the sample inspects the fetch result. If the result contains location reminders with the priority the person selected, the app uses the person’s sorting preferences to sort the reminders, then it displays them. The sample uses key paths to sort the fetched location-based reminders.\n\nIf the fetch result contains no value, the app prompts the person to add some location reminders with the selected priority.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/eventkit\/managing-location-based-reminders\ncrawled: 2025-12-04T17:48:08Z\n---\n\n# Managing location-based reminders\n\n**Sample Code**\n\nAccess reminders set up with geofence-enabled alarms on a person’s calendars.\n\n## Overview\n\nWith the Reminders app, people can create reminders with alarms based on time and location. When Location Services is turned on, people receive location-based reminders when entering or leaving a specified geographic area or geofence. This sample code demonstrates how to add, fetch, complete, remove, filter, and sort location-based reminders. You app must first request full access to reminders from the person using the app before it can access their reminder data. An app with full access can create, edit, save, delete, and fetch all reminders on all of the person’s calendars. For more information, see [doc:\/\/com.apple.documentation\/documentation\/EventKit\/accessing-the-event-store]. Next, register your app for [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStoreChangedNotification] notifications at launch to listen for any changes to the person’s Calendar database. When your app receives this notification, consider your current reminder data are stale or invalid and refetch all your reminders. For more information, see [doc:\/\/com.apple.documentation\/documentation\/EventKit\/updating-with-notifications].\n\n### Configure the sample code project\n\nBefore running the sample code project in Xcode, select the sample target, then configure it to use your team for signing. For more information, see Assign the project to a team in [doc:\/\/com.apple.documentation\/documentation\/Xcode\/preparing-your-app-for-distribution].\n\n### Provide a map annotation\n\nThe sample app presents a map with custom annotations that someone can use to create location-based reminders within the app. It uses location-specific data saved in the `MapData.json` file to create annotations for the map. The sample defines a `MapAnnotation` data type to represent each annotation. `MapData.json` contains three `MapAnnotation` entries. To test reminders around other locations, duplicate and update a `MapAnnotation` entry in `MapData.json` with other data as needed.\n\nThe sample displays a settings button that allows the person to grant or deny the app access to location services. If the person grants permission, the app uses the person’s current location to add a user annotation to the map. If the person denies access, the app does nothing.\n\n\n\n### Provide a full-access usage description for reminders\n\nThe sample includes the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSRemindersFullAccessUsageDescription] key in its `Info.plist` file. The value of the key is a string that explains why the app needs access to a person’s reminders. The system displays the string when prompting the person for authorization.\n\n\n\n### Check your app authorization status\n\nThe sample app verifies its authorization status upon launching. The authorization status of the app is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined] until the person authorizes or denies access. The person can grant or deny the app access to their reminder data, then change the authorization status later in the Settings app. To determine its status, the app calls the [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/authorizationStatus(for:)] class method of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore] with an entity type [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEntityType\/reminder]:\n\n```swift\nauthorizationStatus = EKEventStore.authorizationStatus(for: .reminder)\n```\n\n### Request full access\n\nIf the authorization status is [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/notDetermined], the sample app initializes a single instance of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore], `eventStore`, then calls its [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/requestFullAccessToReminders(completion:)] method to prompt the person for full access:\n\n```swift\nreturn try await withCheckedThrowingContinuation { continuation in\n    eventStore.requestFullAccessToReminders { granted, error in\n        if let error {\n            continuation.resume(throwing: error)\n        }\n        continuation.resume(returning: granted)\n    }\n}\n```\n\nIf the person approves the request, the app receives a [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAuthorizationStatus\/fullAccess] authorization status. It fetches location reminders in all of the person’s calendars, then displays them organized by priority. If the person denies the request, the app gets no access and displays a message prompting the person to grant the app full access in Settings on their device.\n\n\n\n### Check for a default list\n\nCreating a reminder requires a list, which is a calendar for these items. The app calls [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/defaultCalendarForNewReminders()] on `eventStore` to check whether the person has specified a default list for reminders.\n\n```swift\neventStore.defaultCalendarForNewReminders() != nil\n```\n\nThe app fetches and displays location reminders in all of the person’s calendars if `defaultCalendarForNewReminders()` returns a value, and shows a message prompting the person to create a list, otherwise.\n\n### Create location-based reminders\n\nA location-based reminder is a reminder created with a geofence-enabled alarm. A geofence-enabled alarm has a structured location and proximity configured. The structured location consists of a location object and radius. To use the default radius, set its value to 0. The sample uses the following steps to create a location-based reminder:\n\n1. Create a reminder object.\n2. Configure the reminder’s calendar and title properties.\n3. Add a structured location.\n4. Add an alarm.\n5. Save the reminder.\n\nFirst, the sample app creates an [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKReminder] object using [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKReminder\/init(eventStore:)], then it sets the [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendarItem\/title] and [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendarItem\/calendar] properties, and other properties, such as priority and time zone:\n\n```swift\nlet reminder = EKReminder(eventStore: eventStore)\nreminder.calendar = calendar\nreminder.title = entry.title\nreminder.priority = entry.priority\n\n\/*\n    The app creates reminders with a specific date and time. To create an\n    all-day reminder, set `dueDateComponents` to a date component without\n    hour, minute, and second components.\n*\/\nreminder.dueDateComponents = Date.next7DaysComponents\n\n\/*\n    A floating reminder is one that isn't associated with a specific time\n    zone. Set `timeZone` to `nil` if you wish to have a floating reminder.\n*\/\nreminder.timeZone = TimeZone.current\n```\n\n\n\nNext, the sample creates a structured location by using either [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation]’s [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/init(title:)] or [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/init(mapItem:)] methods. When the location object has latitude and longitude coordinates, the app uses `init(title:)` to create the structured location. The sample initializes an [https:\/\/developer.apple.com\/documentation\/corelocation\/cllocation] object with the specified latitude and longitude, then assigns it to the created structured location’s [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/geoLocation] property:\n\n```swift\nlet structuredLocation = EKStructuredLocation(title: annotation.name)\nstructuredLocation.geoLocation = CLLocation(latitude: annotation.coordinates.latitude, longitude: annotation.coordinates.longitude)\n```\n\nWhen the location object is an [doc:\/\/com.apple.documentation\/documentation\/MapKit\/MKMapItem] object, the sample uses `init(mapItem:)` to create the structured location:\n\n```swift\nlet structuredLocation = EKStructuredLocation(mapItem: mapItem)\n```\n\nEventKit defines the structured location’s [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation\/radius] property in meters. When someone enters a value for the radius, the app checks the person’s preferences for unit of length measurement. If the person’s preferred unit of length is a unit other than meters, the sample converts the radius value to meters, then assigns the converted value to the structured location’s `radius` property:\n\n```swift\n\/\/ Get the person's preferred unit of length measurement.\nlet preferredUnit = UnitLength(forLocale: .current, usage: .asProvided)\nstructuredLocation.radius = (preferredUnit == .meters) ? entry.radius : entry.radius.convert(from: preferredUnit, to: .meters)\n```\n\nNext, the sample creates an [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAlarm] object, then sets its [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKStructuredLocation] property to the created structured location object. The sample then sets the [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKAlarm\/proximity] property to a value to finish configuring the alarm’s geofence:\n\n```swift\nlet alarm = EKAlarm(relativeOffset: 0)\nalarm.structuredLocation = structuredLocation\nalarm.proximity = entry.proximity\n```\n\nThe app adds the created alarm to the reminder. For more information on adding alarms, see [doc:\/\/com.apple.documentation\/documentation\/EventKit\/setting-an-alarm].\n\n```swift\nreminder.addAlarm(alarm)\n```\n\nFinally, it saves the reminder to the person’s Calendar database:\n\n```swift\ntry eventStore.save(reminder, commit: true)\n```\n\n### Fetch location-based reminders\n\nThe [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/fetchReminders(matching:completion:)] method asynchronously fetches all reminders matching a given predicate. The app calls this method with [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKEventStore\/predicateForReminders(in:)] to fetch complete and incomplete reminders. The predicate takes `nil` or an array of [doc:\/\/com.apple.documentation\/documentation\/EventKit\/EKCalendarItem\/calendar] objects in its `calendars` parameters. Pass `nil` to fetch from all of the person’s calendars, and an array to fetch reminders from a subset of the person’s calendars. The app passes `nil` to `predicateForReminders(in:)`:\n\n```swift\nlet predicate = eventStore.predicateForReminders(in: nil)\n```\n\nThen, the app executes the fetch request. If the request succeeds, `fetchReminders(matching:completion:)` returns an array that contains both time-based and location-based reminders:\n\n```swift\nreturn await withCheckedContinuation { continuation in\n    eventStore.fetchReminders(matching: predicate) { reminders in\n        var result: [LocationReminder] = []\n        \n        if let reminders {\n            result = reminders\n                .filter(\\.isLocation)\n                .map { LocationReminder(reminder: $0) }\n        }\n        continuation.resume(returning: result)\n    }\n}\n```\n\nTo retrieve location-based reminders, the app parses the returned array for reminders defined with an existing alarm that has a `structuredlocation` and `proximity` value:\n\n```swift\n\/\/\/ Specifies whether the reminder is location-based.\nvar isLocation: Bool {\n    guard let alarms else { return false }\n    \n    let proximityAlarms = alarms.filter {\n        $0.structuredLocation != nil && ($0.proximity == .enter || $0.proximity == .leave)\n    }\n    \n    return !proximityAlarms.isEmpty\n}\n```\n\n### Filter and sort reminders\n\nAfter fetching the location-based reminders, the app displays a segmented control that organizes the fetched reminders by priority: None, Low, Medium, and High. Fetching reminders from the Calendar database returns reminders sorted by creation date. The app offers a menu that lets people choose how to sort the reminders by creation date, due date, or title in ascending order. When someone selects a priority in the control, the sample inspects the fetch result. If the result contains location reminders with the priority the person selected, the app uses the person’s sorting preferences to sort the reminders, then it displays them. The sample uses key paths to sort the fetched location-based reminders.\n\n```swift\n\/\/\/ Sorts reminders by creation date, due date, or title in ascending order.\nfunc reminders(sortedBy sort: ReminderSortValue) -> [LocationReminder] {\n    switch sort {\n    case .creationDate: return self.sorted(by: \\.creationDate)\n    case .dueDate: return self.sorted(by: \\.dueDate)\n    case .title: return self.sorted(by: \\.title)\n    }\n}\n```\n\nIf the fetch result contains no value, the app prompts the person to add some location reminders with the selected priority.\n\n## Events and reminders\n\n- **Creating events and reminders**: Create and modify events and reminders in a person’s database.\n- **Retrieving events and reminders**: Fetch events and reminders from the Calendar database.\n- **Updating with notifications**: Register for notifications about changes and keep your app up to date.\n- **EKEvent**: A class that represents an event in a calendar.\n- **EKReminder**: A class that represents a reminder in a calendar.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create and modify events and reminders in a person’s database.",
          "name" : "Creating events and reminders",
          "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/creating-events-and-reminders"
        },
        {
          "description" : "Fetch events and reminders from the Calendar database.",
          "name" : "Retrieving events and reminders",
          "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/retrieving-events-and-reminders"
        },
        {
          "description" : "Register for notifications about changes and keep your app up to date.",
          "name" : "Updating with notifications",
          "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/updating-with-notifications"
        },
        {
          "description" : "A class that represents an event in a calendar.",
          "name" : "EKEvent",
          "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/EKEvent"
        },
        {
          "description" : "A class that represents a reminder in a calendar.",
          "name" : "EKReminder",
          "url" : "https:\/\/developer.apple.com\/documentation\/EventKit\/EKReminder"
        }
      ],
      "title" : "Events and reminders"
    }
  ],
  "source" : "appleJSON",
  "title" : "Managing location-based reminders",
  "url" : "https:\/\/developer.apple.com\/documentation\/eventkit\/managing-location-based-reminders"
}