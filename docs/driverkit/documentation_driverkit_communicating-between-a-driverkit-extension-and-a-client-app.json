{
  "abstract" : "Send and receive different kinds of data securely by validating inputs and asynchronously by storing and using a callback.",
  "codeExamples" : [
    {
      "code" : "let request = OSSystemExtensionRequest\n    .activationRequest(forExtensionWithIdentifier: dextIdentifier,\n                       queue: .main)\nrequest.delegate = self\nOSSystemExtensionManager.shared.submitRequest(request)",
      "language" : "swift"
    },
    {
      "code" : "CFMutableDictionaryRef matchingDictionary = IOServiceNameMatching(dextIdentifier);\nif (matchingDictionary == NULL)\n{\n    fprintf(stderr, \"Failed to initialize matchingDictionary.\\n\");\n    UserClientTeardown();\n    return false;\n}\nmatchingDictionary = (CFMutableDictionaryRef)CFRetain(matchingDictionary);\nmatchingDictionary = (CFMutableDictionaryRef)CFRetain(matchingDictionary);\n\nret = IOServiceAddMatchingNotification(globalNotificationPort, kIOFirstMatchNotification, matchingDictionary, DeviceAdded, refcon, &globalDeviceAddedIter);\nif (ret != kIOReturnSuccess)\n{\n    fprintf(stderr, \"Add matching notification failed with error: 0x%08x.\\n\", ret);\n    UserClientTeardown();\n    return false;\n}\nDeviceAdded(refcon, globalDeviceAddedIter);",
      "language" : "objective-c"
    },
    {
      "code" : "void DeviceAdded(void* refcon, io_iterator_t iterator)\n{\n    kern_return_t ret = kIOReturnSuccess;\n    io_connect_t connection = IO_OBJECT_NULL;\n    io_service_t device = IO_OBJECT_NULL;\n    bool attemptedToMatchDevice = false;\n\n    while ((device = IOIteratorNext(iterator)) != IO_OBJECT_NULL)\n    {\n        attemptedToMatchDevice = true;\n\n        \/\/ Open a connection to this user client as a server to that client, and store the instance in \"service\"\n        ret = IOServiceOpen(device, mach_task_self_, 0, &connection);\n\n        if (ret == kIOReturnSuccess)\n        {\n            fprintf(stdout, \"Opened connection to dext.\\n\");\n        }\n        else\n        {\n            fprintf(stderr, \"Failed opening connection to dext with error: 0x%08x.\\n\", ret);\n            IOObjectRelease(device);\n            return;\n        }\n\n        SwiftDeviceAdded(refcon, connection);\n\n        IOObjectRelease(device);\n    }\n}",
      "language" : "objective-c"
    },
    {
      "code" : "kern_return_t ret = kIOReturnSuccess;\n\n\/\/ IOConnectCallScalarMethod will fail intentionally for any inputCount or outputCount greater than 16.\nconst uint32_t arraySize = 16;\nconst uint64_t input[arraySize] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n\nuint32_t outputArraySize = arraySize;\nuint64_t output[arraySize] = {};\n\nret = IOConnectCallScalarMethod(connection, MessageType_Scalar, input, arraySize, output, &outputArraySize);\nif (ret != kIOReturnSuccess)\n{\n    printf(\"IOConnectCallScalarMethod failed with error: 0x%08x.\\n\", ret);\n    PrintErrorDetails(ret);\n}",
      "language" : "objective-c"
    },
    {
      "code" : "[ExternalMethodType_CheckedScalar] =\n{\n\t.function = (IOUserClientMethodFunction) &NullDriverUserClient::StaticHandleExternalCheckedScalar,\n\t.checkCompletionExists = false, \/\/ Since this call doesn't use a callback, this value is false and IOUserClientMethodArguments.completion must be 0.\n\t.checkScalarInputCount = 16,\n\t.checkStructureInputSize = 0,\n\t.checkScalarOutputCount = 16,\n\t.checkStructureOutputSize = 0,\n},",
      "language" : "c"
    },
    {
      "code" : "struct NullDriverUserClient_IVars {\n\tOSAction* callbackAction = nullptr;\n\tIODispatchQueue* dispatchQueue = nullptr;\n\tIOTimerDispatchSource* dispatchSource = nullptr;\n\tOSAction* simulatedAsyncDeviceResponseAction = nullptr;\n};",
      "language" : "c"
    },
    {
      "code" : "virtual void SimulatedAsyncEvent(OSAction* action, uint64_t time) TYPE(IOTimerDispatchSource::TimerOccurred);",
      "language" : "c"
    },
    {
      "code" : "ret = CreateActionSimulatedAsyncEvent(sizeof(DataStruct), &ivars->simulatedAsyncDeviceResponseAction);\nif (ret != kIOReturnSuccess)\n{\n\tLog(\"Start() - Failed to create action for simulated async event with error: 0x%08x.\", ret);\n\tgoto Exit;\n}",
      "language" : "c"
    },
    {
      "code" : "if (arguments->completion == nullptr)\n{\n\tLog(\"Got a null completion.\");\n\treturn kIOReturnBadArgument;\n}\n\n\/\/ Save the completion for later.\n\/\/ If not saved, then it might be freed before the asychronous return.\nivars->callbackAction = arguments->completion;\nivars->callbackAction->retain();",
      "language" : "c"
    },
    {
      "code" : "input = (DataStruct*)arguments->structureInput->getBytesNoCopy();\n\n\/\/ Retain action memory for later work.\nvoid* osActionRetainedMemory = ivars->simulatedAsyncDeviceResponseAction->GetReference();\nmemcpy(osActionRetainedMemory, input, sizeof(DataStruct));\n\noutput.foo = input->foo + 1;\noutput.bar = input->bar + 10;\n\narguments->structureOutput = OSData::withBytes(&output, sizeof(DataStruct));\n\n\/\/ Dispatch action that waits five to seven seconds and then calls the callback.\nconst uint64_t fiveSecondsInNanoSeconds = 5000000000;\nconst uint64_t twoSecondsInNanoSeconds = 2000000000;\nuint64_t currentTime = clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW);\n\nLog(\"Sleeping async...\");\nivars->dispatchSource->WakeAtTime(kIOTimerClockMonotonicRaw, currentTime + fiveSecondsInNanoSeconds, twoSecondsInNanoSeconds);",
      "language" : "c"
    }
  ],
  "contentHash" : "702f244586343720038c7eecd9759e0602eb30466f9a8ce44aa200ed2ad4fb93",
  "crawledAt" : "2025-12-02T15:51:22Z",
  "id" : "153EE0EA-0C70-44B5-A022-B78DF1F97F87",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "DriverKit",
  "overview" : "## Overview\n\nThis sample code project shows how a DriverKit extension (dext) receives data from an app client running on macOS or iPadOS. The sample handles both scalar data and structures, and has two code paths for each type: an insecure version, and a “checked” version that validates traits like data size and input count.\n\nThe sample also demonstrates registering and executing a callback function, so the driver can call the client asynchronously.\n\nThe sample project contains two targets:\n\n### Configure the Sample Code Project\n\nTo run the sample code project, you first need to build and run `DriverKitSampleApp`, which installs the driver.\n\nYou can set up the project to build with automatic signing (recommended) or manual signing. To use automatic signing:\n\nIf you want to build with manual signing instead, do the following:\n\n### Install and run the driver extension on macOS\n\nTo run the sample app in macOS, use the scheme selector to select the `DriverKitSampleApp` scheme and the My Mac destination. Build the target, then copy the app to the Applications folder and launch the app. For simplicity, you can run the app directly from Xcode instead, without moving the app bundle to the Applications folder each time. To do this, use the `systemextensionsctl` command to enable system extensions developer mode, as explained in [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/debugging-and-testing-system-extensions].\n\nThe `DriverKitSampleApp` target declares the `NullDriver` as a dependency, so building the app target builds the dext and its installer together. When run, the `DriverKitSampleApp` shows a single window with a text label that says “NullDriver isn’t loaded”. Below this, it shows an “Install Dext” button, and a “Communicate with Dext” button. Click “Install Dext” to perform the installation.\n\nTo install the dext on macOS, the app uses the [doc:\/\/com.apple.documentation\/documentation\/SystemExtensions] framework to install and activate the dext, as described in [doc:\/\/com.apple.documentation\/documentation\/SystemExtensions\/installing-system-extensions-and-drivers].\n\n### Run the sample in iPadOS\n\nTo run the sample app in iPadOS, connect an iPad with an M-series chip to your Mac. Use the scheme selector to select the `DriverKitSampleApp` scheme and the name of your iPad as the destination. Run the app directly from Xcode to launch it on your iPad.\n\nIn iPadOS, the `DriverKitSampleApp` app doesn’t show the Driver Manager section because the app isn’t responsible for installing the driver like it is in macOS. Instead, open the Settings app, navigate to Privacy & Security > Drivers, and enable the driver there. You can also navigate to this settings panel by tapping “Open Settings to Enable Driver” in DriverKitSampleApp.\n\n### Call the driver from the client\n\nAfter installing the driver and granting it permission to run in the Settings app, you can use DriverKitSampleApp to communicate with the driver. Click the “Communicate with Dext” button to connect to the driver.\n\nTo find the driver, the host app uses the `dextIdentifier` to create a matching dictionary and registers this with `IOServiceAddMatchingNotification`. When the system finds a running driver with the matching identifier, it calls the app’s `DeviceAdded` method.\n\nWhen `DeviceAdded` runs, it iterates over matching services until it finds one that it can connect to with `IOServiceOpen`. If the `IOServiceOpen` call succeeds, the app calls an internal `SwiftDeviceAdded` method to update the SwiftUI data model with a connection to the driver.\n\nThe SwiftUI “Driver Communication” view shows three sets of buttons, along with a “Manage Dext” button to return to the installer view. The sets of buttons that communicate with the driver are:\n\nWhen you click or tap one of these buttons, the “Waiting for action” label changes to “Request returned successfully” if the call to the driver succeeds. If an error occurs, the label says “Request returned an error, check the logs for details”. If you launched the app from Xcode, view the Console to see the data sent to and returned from the driver.\n\nThe buttons in the Unchecked and Checked sections exercise different code paths that send scalar values and structures to the dext. Note that these are synchronous calls that block until the driver returns a result. The buttons in the Async section perform asynchronous operations that allow the driver to call back to the client after a delay.\n\nEach of these options uses the connection in calls to `IOConnectCallScalarMethod`, `IOConnectCallStructMethod`, and `IOConnectCallAsyncStructMethod` (or `IOConnectCallMethod` and `IOConnectCallAsyncMethod`, which this sample doesn’t use). For example, the following listing shows the Scalar call from the Unchecked button group, which sends an array of 16 `uint64_t` values, and receives a different array back.\n\nThe other options are all similar, differing only in which `IOConnect...` function they call and the type of data they send.\n\n### Validate arguments to driver function calls\n\nThe `NullDriver` receives calls from the client in its overridden [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClient\/ExternalMethod] method. The Unchecked options in the SwiftUI view perform calls that the driver passes unchecked to its [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClient\/ExternalMethod] implementation. In practice, it’s important that a driver validates its inputs before passing them along, to make sure the data is the expected size and contains reasonable values. `NullDriver` has functions that check scalar and structure calls, which are exercised by the Checked buttons in the SwiftUI app.\n\nThe “checked” methods in `NullDriver` — `CheckedScalar` and `CheckedStruct` —  use an [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClientMethodDispatch] instance to describe the expected fields of the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClientMethodArguments]. The sample stores these dispatch instances in an array called `externalMethodChecks`. For example, the dispatch instance for the checked scalar call expects to receive and return 16 scalar values, as seen below:\n\nAfter fetching the appropriate  [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClientMethodDispatch] instance from the array, the driver passes it in its call to the superclass’s [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClient\/ExternalMethod] along with the method selector and its arguments. If the number of arguments or return values don’t match what’s in the dispatch instance, the call fails and returns [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/kIOReturnBadArgument]. Checking client calls like this prevents a malicious call to the driver from using attack vectors like buffer overruns.\n\n### Prepare for driver-to-client callbacks\n\n`DriverKitSampleApp` also shows how to communicate from the driver to the client by using a callback function. The Assign Callback button sets up a callback to make an asynchronous call to the client, and then invokes the callback after a short delay to simulate the driver acting on its own. After registering a callback with this button, calls to Async Action re-invoke the callback.\n\nThe `NullDriver` class defines `NullDriver_IVars`, the DriverKit structure that holds the driver’s instance variables. `NullDriver_IVars` stores the callback action, as well as a dispatch queue and a timer dispatch source to use when calling back to the client.\n\n`NullDriver` initializes the `dispatchQueue` and `dispatchSource` in its `Start` implementation.\n\nThe driver’s implementation of `Start` also sets up the `ivars` member `simulatedAsyncDeviceResponseAction`, which the example uses to simulate asynchronous processing that happens on real hardware. This [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/OSAction] refers to an asynchronous timer callback to the `SimulatedAsyncEvent` function defined in the `.iig` file:\n\nThis declaration takes the same arguments as the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOTimerDispatchSource\/TimerOccurred] method that that the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/TYPE]  macro wraps. By declaring the callback’s name as `SimulatedAsyncEvent`, the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/TYPE] macro synthesizes `CreateActionSimulatedAsyncEvent`, the function that creates the  [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/OSAction]. The driver’s `Start` implementation then calls this synthesized method to initialize the `simulatedAsyncDeviceResponseAction` member of the `ivars` structure:\n\n### Retain and use the callback to notify the client\n\nWhen the driver is running and it receives a request from the client to register a callback, it calls `NullDriver::RegisterAsyncCallback`. This method stores the completion, if it exists, in the `ivars` structure, like this:\n\nNext, the `NullDriver::RegisterAsyncCallback` method sets up a delayed callback to the client to simulate a hardware delay, allowing it to return quickly, by using the `simulatedAsyncDeviceResponseAction`:\n\nAfter the driver stores the callback, the client app can perform multiple simulated callbacks with the Async Action. This calls `NullDriver::HandleAsyncRequest`, which is largely similar to the delayed call performed in the previous listing.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/DriverKit\/communicating-between-a-driverkit-extension-and-a-client-app\ncrawled: 2025-12-02T15:51:22Z\n---\n\n# Communicating between a DriverKit extension and a client app\n\n**Sample Code**\n\nSend and receive different kinds of data securely by validating inputs and asynchronously by storing and using a callback.\n\n## Overview\n\nThis sample code project shows how a DriverKit extension (dext) receives data from an app client running on macOS or iPadOS. The sample handles both scalar data and structures, and has two code paths for each type: an insecure version, and a “checked” version that validates traits like data size and input count.\n\nThe sample also demonstrates registering and executing a callback function, so the driver can call the client asynchronously.\n\n\n\nThe sample project contains two targets:\n\n- `DriverKitSampleApp` - A  SwiftUI app for macOS and iPadOS. Use this app to install or update the driver, and then to call the driver directly.\n- `NullDriver` - The dext itself, which responds to client calls and optionally checks that each call sends the expected data.\n\n### Configure the Sample Code Project\n\nTo run the sample code project, you first need to build and run `DriverKitSampleApp`, which installs the driver.\n\nYou can set up the project to build with automatic signing (recommended) or manual signing. To use automatic signing:\n\n1. Temporarily turn off SIP, as described in the article [doc:\/\/com.apple.documentation\/documentation\/Security\/disabling-and-enabling-system-integrity-protection]. After you’ve done this, confirm that SIP is disabled with the Terminal command `csrutil status`, and enter dext development mode with `systemextensionsctl developer`, as described in the article [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/debugging-and-testing-system-extensions].\n2. Select the `DriverKitUserClientSample` project and use the “Signing & Capabilities” tab to set the `DriverKitSampleApp` and `NullDriver` targets to “Automatically manage signing”.\n3. In the “Build Settings” tab, change the “Code Signing Identity” value to “Sign to Run Locally” for both targets.\n4. Also in “Build Settings”, add a new build setting with the name `AD_HOC_CODE_SIGNING_ALLOWED` and the value `YES` for Debug schemes. This build setting is already present in the downloadable version of the project; you need to add it to your own projects to build and run them automatically.\n\nIf you want to build with manual signing instead, do the following:\n\n1. Choose new bundle identifiers for the app and driver. The bundle identifiers included with the project already have App IDs associated with them, so you need unique identifiers to create your own App IDs. Use a reverse-DNS format for your identifier, as described in [doc:\/\/com.apple.documentation\/documentation\/Xcode\/preparing-your-app-for-distribution].\n2. In the Xcode Project navigator, choose the project and use the Signing & Capabilities tab to replace the existing bundle identfier with your chosen identifier for each of the targets.\n3. Request entitlements, as described in  [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/requesting-entitlements-for-driverkit-development]. For `DriverKitSampleApp`, you need the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.system-extension.install] and [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit.communicates-with-drivers] entitlements. For `NullDriver`, you need the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit] entitlement and the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit.allow-any-userclient-access] entitlements. This latter macOS-only entitlement allows any app to connect to the driver as a user client. Although this simplifies running the sample code, in your own apps you may prefer to use [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit.userclient-access]. This entitlement goes on the app rather than the driver, and lists bundle identifiers of drivers it can connect to.\n4. On `developer.apple.com`, select Account and visit the “Certificates, Identifiers, and Profiles” section. Select “Identifiers” and create new App IDs for `DriverKitSampleApp` and `NullDriver`. For the Bundle ID, choose “explicit”, and use the names you chose in the first step. When you reach the “Capabilities” step, `DriverKitSampleApp` needs the “Communicates with Drivers” and “System Extension” capabilities. For `NullDriver`, under the “Capabilities” tab, enable the “DriverKit (development)” capability, and under the “Additional Capabilities” tab, enable “DriverKit” and “DriverKit Allow Any UserClient Access”.\n5. For each of the App IDs you created in the previous steps, select Profiles to create a new provisioning profile. You need one for the macOS and iOS host app, and one for the driver. When creating the driver’s profile, be sure to select DriverKit App Development as the profile type.\n6. Download each profile and add it to Xcode.\n7. In the “Signing & Capabilities” tab, set each target to manual code signing and select the newly-created profile.\n\n### Install and run the driver extension on macOS\n\nTo run the sample app in macOS, use the scheme selector to select the `DriverKitSampleApp` scheme and the My Mac destination. Build the target, then copy the app to the Applications folder and launch the app. For simplicity, you can run the app directly from Xcode instead, without moving the app bundle to the Applications folder each time. To do this, use the `systemextensionsctl` command to enable system extensions developer mode, as explained in [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/debugging-and-testing-system-extensions].\n\nThe `DriverKitSampleApp` target declares the `NullDriver` as a dependency, so building the app target builds the dext and its installer together. When run, the `DriverKitSampleApp` shows a single window with a text label that says “NullDriver isn’t loaded”. Below this, it shows an “Install Dext” button, and a “Communicate with Dext” button. Click “Install Dext” to perform the installation.\n\nTo install the dext on macOS, the app uses the [doc:\/\/com.apple.documentation\/documentation\/SystemExtensions] framework to install and activate the dext, as described in [doc:\/\/com.apple.documentation\/documentation\/SystemExtensions\/installing-system-extensions-and-drivers].\n\n```swift\nlet request = OSSystemExtensionRequest\n    .activationRequest(forExtensionWithIdentifier: dextIdentifier,\n                       queue: .main)\nrequest.delegate = self\nOSSystemExtensionManager.shared.submitRequest(request)\n```\n\n\n\n### Run the sample in iPadOS\n\nTo run the sample app in iPadOS, connect an iPad with an M-series chip to your Mac. Use the scheme selector to select the `DriverKitSampleApp` scheme and the name of your iPad as the destination. Run the app directly from Xcode to launch it on your iPad.\n\nIn iPadOS, the `DriverKitSampleApp` app doesn’t show the Driver Manager section because the app isn’t responsible for installing the driver like it is in macOS. Instead, open the Settings app, navigate to Privacy & Security > Drivers, and enable the driver there. You can also navigate to this settings panel by tapping “Open Settings to Enable Driver” in DriverKitSampleApp.\n\n### Call the driver from the client\n\nAfter installing the driver and granting it permission to run in the Settings app, you can use DriverKitSampleApp to communicate with the driver. Click the “Communicate with Dext” button to connect to the driver.\n\nTo find the driver, the host app uses the `dextIdentifier` to create a matching dictionary and registers this with `IOServiceAddMatchingNotification`. When the system finds a running driver with the matching identifier, it calls the app’s `DeviceAdded` method.\n\n```objective-c\nCFMutableDictionaryRef matchingDictionary = IOServiceNameMatching(dextIdentifier);\nif (matchingDictionary == NULL)\n{\n    fprintf(stderr, \"Failed to initialize matchingDictionary.\\n\");\n    UserClientTeardown();\n    return false;\n}\nmatchingDictionary = (CFMutableDictionaryRef)CFRetain(matchingDictionary);\nmatchingDictionary = (CFMutableDictionaryRef)CFRetain(matchingDictionary);\n\nret = IOServiceAddMatchingNotification(globalNotificationPort, kIOFirstMatchNotification, matchingDictionary, DeviceAdded, refcon, &globalDeviceAddedIter);\nif (ret != kIOReturnSuccess)\n{\n    fprintf(stderr, \"Add matching notification failed with error: 0x%08x.\\n\", ret);\n    UserClientTeardown();\n    return false;\n}\nDeviceAdded(refcon, globalDeviceAddedIter);\n```\n\nWhen `DeviceAdded` runs, it iterates over matching services until it finds one that it can connect to with `IOServiceOpen`. If the `IOServiceOpen` call succeeds, the app calls an internal `SwiftDeviceAdded` method to update the SwiftUI data model with a connection to the driver.\n\n```objective-c\nvoid DeviceAdded(void* refcon, io_iterator_t iterator)\n{\n    kern_return_t ret = kIOReturnSuccess;\n    io_connect_t connection = IO_OBJECT_NULL;\n    io_service_t device = IO_OBJECT_NULL;\n    bool attemptedToMatchDevice = false;\n\n    while ((device = IOIteratorNext(iterator)) != IO_OBJECT_NULL)\n    {\n        attemptedToMatchDevice = true;\n\n        \/\/ Open a connection to this user client as a server to that client, and store the instance in \"service\"\n        ret = IOServiceOpen(device, mach_task_self_, 0, &connection);\n\n        if (ret == kIOReturnSuccess)\n        {\n            fprintf(stdout, \"Opened connection to dext.\\n\");\n        }\n        else\n        {\n            fprintf(stderr, \"Failed opening connection to dext with error: 0x%08x.\\n\", ret);\n            IOObjectRelease(device);\n            return;\n        }\n\n        SwiftDeviceAdded(refcon, connection);\n\n        IOObjectRelease(device);\n    }\n}\n```\n\nThe SwiftUI “Driver Communication” view shows three sets of buttons, along with a “Manage Dext” button to return to the installer view. The sets of buttons that communicate with the driver are:\n\n- “Unchecked” — “Scalar”, “Struct”, and “Large Struct”\n- “Checked” — “Scalar” and “Struct”\n- “Async” — “Assign Callback” and “Async Action”\n\nWhen you click or tap one of these buttons, the “Waiting for action” label changes to “Request returned successfully” if the call to the driver succeeds. If an error occurs, the label says “Request returned an error, check the logs for details”. If you launched the app from Xcode, view the Console to see the data sent to and returned from the driver.\n\nThe buttons in the Unchecked and Checked sections exercise different code paths that send scalar values and structures to the dext. Note that these are synchronous calls that block until the driver returns a result. The buttons in the Async section perform asynchronous operations that allow the driver to call back to the client after a delay.\n\nEach of these options uses the connection in calls to `IOConnectCallScalarMethod`, `IOConnectCallStructMethod`, and `IOConnectCallAsyncStructMethod` (or `IOConnectCallMethod` and `IOConnectCallAsyncMethod`, which this sample doesn’t use). For example, the following listing shows the Scalar call from the Unchecked button group, which sends an array of 16 `uint64_t` values, and receives a different array back.\n\n```objective-c\nkern_return_t ret = kIOReturnSuccess;\n\n\/\/ IOConnectCallScalarMethod will fail intentionally for any inputCount or outputCount greater than 16.\nconst uint32_t arraySize = 16;\nconst uint64_t input[arraySize] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n\nuint32_t outputArraySize = arraySize;\nuint64_t output[arraySize] = {};\n\nret = IOConnectCallScalarMethod(connection, MessageType_Scalar, input, arraySize, output, &outputArraySize);\nif (ret != kIOReturnSuccess)\n{\n    printf(\"IOConnectCallScalarMethod failed with error: 0x%08x.\\n\", ret);\n    PrintErrorDetails(ret);\n}\n```\n\nThe other options are all similar, differing only in which `IOConnect...` function they call and the type of data they send.\n\n### Validate arguments to driver function calls\n\nThe `NullDriver` receives calls from the client in its overridden [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClient\/ExternalMethod] method. The Unchecked options in the SwiftUI view perform calls that the driver passes unchecked to its [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClient\/ExternalMethod] implementation. In practice, it’s important that a driver validates its inputs before passing them along, to make sure the data is the expected size and contains reasonable values. `NullDriver` has functions that check scalar and structure calls, which are exercised by the Checked buttons in the SwiftUI app.\n\nThe “checked” methods in `NullDriver` — `CheckedScalar` and `CheckedStruct` —  use an [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClientMethodDispatch] instance to describe the expected fields of the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClientMethodArguments]. The sample stores these dispatch instances in an array called `externalMethodChecks`. For example, the dispatch instance for the checked scalar call expects to receive and return 16 scalar values, as seen below:\n\n```c\n[ExternalMethodType_CheckedScalar] =\n{\n\t.function = (IOUserClientMethodFunction) &NullDriverUserClient::StaticHandleExternalCheckedScalar,\n\t.checkCompletionExists = false, \/\/ Since this call doesn't use a callback, this value is false and IOUserClientMethodArguments.completion must be 0.\n\t.checkScalarInputCount = 16,\n\t.checkStructureInputSize = 0,\n\t.checkScalarOutputCount = 16,\n\t.checkStructureOutputSize = 0,\n},\n```\n\nAfter fetching the appropriate  [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClientMethodDispatch] instance from the array, the driver passes it in its call to the superclass’s [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOUserClient\/ExternalMethod] along with the method selector and its arguments. If the number of arguments or return values don’t match what’s in the dispatch instance, the call fails and returns [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/kIOReturnBadArgument]. Checking client calls like this prevents a malicious call to the driver from using attack vectors like buffer overruns.\n\n### Prepare for driver-to-client callbacks\n\n`DriverKitSampleApp` also shows how to communicate from the driver to the client by using a callback function. The Assign Callback button sets up a callback to make an asynchronous call to the client, and then invokes the callback after a short delay to simulate the driver acting on its own. After registering a callback with this button, calls to Async Action re-invoke the callback.\n\nThe `NullDriver` class defines `NullDriver_IVars`, the DriverKit structure that holds the driver’s instance variables. `NullDriver_IVars` stores the callback action, as well as a dispatch queue and a timer dispatch source to use when calling back to the client.\n\n```c\nstruct NullDriverUserClient_IVars {\n\tOSAction* callbackAction = nullptr;\n\tIODispatchQueue* dispatchQueue = nullptr;\n\tIOTimerDispatchSource* dispatchSource = nullptr;\n\tOSAction* simulatedAsyncDeviceResponseAction = nullptr;\n};\n```\n\n`NullDriver` initializes the `dispatchQueue` and `dispatchSource` in its `Start` implementation.\n\nThe driver’s implementation of `Start` also sets up the `ivars` member `simulatedAsyncDeviceResponseAction`, which the example uses to simulate asynchronous processing that happens on real hardware. This [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/OSAction] refers to an asynchronous timer callback to the `SimulatedAsyncEvent` function defined in the `.iig` file:\n\n```c\nvirtual void SimulatedAsyncEvent(OSAction* action, uint64_t time) TYPE(IOTimerDispatchSource::TimerOccurred);\n```\n\nThis declaration takes the same arguments as the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOTimerDispatchSource\/TimerOccurred] method that that the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/TYPE]  macro wraps. By declaring the callback’s name as `SimulatedAsyncEvent`, the [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/TYPE] macro synthesizes `CreateActionSimulatedAsyncEvent`, the function that creates the  [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/OSAction]. The driver’s `Start` implementation then calls this synthesized method to initialize the `simulatedAsyncDeviceResponseAction` member of the `ivars` structure:\n\n```c\nret = CreateActionSimulatedAsyncEvent(sizeof(DataStruct), &ivars->simulatedAsyncDeviceResponseAction);\nif (ret != kIOReturnSuccess)\n{\n\tLog(\"Start() - Failed to create action for simulated async event with error: 0x%08x.\", ret);\n\tgoto Exit;\n}\n```\n\n### Retain and use the callback to notify the client\n\nWhen the driver is running and it receives a request from the client to register a callback, it calls `NullDriver::RegisterAsyncCallback`. This method stores the completion, if it exists, in the `ivars` structure, like this:\n\n```c\nif (arguments->completion == nullptr)\n{\n\tLog(\"Got a null completion.\");\n\treturn kIOReturnBadArgument;\n}\n\n\/\/ Save the completion for later.\n\/\/ If not saved, then it might be freed before the asychronous return.\nivars->callbackAction = arguments->completion;\nivars->callbackAction->retain();\n```\n\nNext, the `NullDriver::RegisterAsyncCallback` method sets up a delayed callback to the client to simulate a hardware delay, allowing it to return quickly, by using the `simulatedAsyncDeviceResponseAction`:\n\n```c\ninput = (DataStruct*)arguments->structureInput->getBytesNoCopy();\n\n\/\/ Retain action memory for later work.\nvoid* osActionRetainedMemory = ivars->simulatedAsyncDeviceResponseAction->GetReference();\nmemcpy(osActionRetainedMemory, input, sizeof(DataStruct));\n\noutput.foo = input->foo + 1;\noutput.bar = input->bar + 10;\n\narguments->structureOutput = OSData::withBytes(&output, sizeof(DataStruct));\n\n\/\/ Dispatch action that waits five to seven seconds and then calls the callback.\nconst uint64_t fiveSecondsInNanoSeconds = 5000000000;\nconst uint64_t twoSecondsInNanoSeconds = 2000000000;\nuint64_t currentTime = clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW);\n\nLog(\"Sleeping async...\");\nivars->dispatchSource->WakeAtTime(kIOTimerClockMonotonicRaw, currentTime + fiveSecondsInNanoSeconds, twoSecondsInNanoSeconds);\n```\n\nAfter the driver stores the callback, the client app can perform multiple simulated callbacks with the Async Action. This calls `NullDriver::HandleAsyncRequest`, which is largely similar to the delayed call performed in the previous listing.\n\n\n\n## External drivers\n\n- **com.apple.developer.driverkit.userclient-access**: An array of strings that represent macOS driver extensions that may communicate with other DriverKit services.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An array of strings that represent macOS driver extensions that may communicate with other DriverKit services.",
          "name" : "com.apple.developer.driverkit.userclient-access",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit.userclient-access"
        }
      ],
      "title" : "External drivers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Communicating between a DriverKit extension and a client app",
  "url" : "https:\/\/developer.apple.com\/documentation\/DriverKit\/communicating-between-a-driverkit-extension-and-a-client-app"
}