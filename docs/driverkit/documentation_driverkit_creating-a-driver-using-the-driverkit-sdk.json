{
  "abstract" : "Create a driver that supports proprietary features of your company’s hardware devices.",
  "codeExamples" : [
    {
      "code" : "class MyCustomDriver: public IOUserNetworkEthernet\n{\npublic:\n    virtual kern_return_t\n    Start(IOService * provider) override;\n};",
      "language" : "objc"
    },
    {
      "code" : "struct HIDKeyboardDriver_IVars\n{\n    OSArray *elements;\n    \n    struct {\n        OSArray *elements;\n    } keyboard;\n};\n\nbool HIDKeyboardDriver::init()\n{\n    if (!super::init()) {\n        return false;\n    }\n    \n    ivars = IONewZero(HIDKeyboardDriver_IVars, 1);\n    if (!ivars) {\n        return false;\n    }\n    \nexit:\n    return true;\n}\n",
      "language" : "objc"
    },
    {
      "code" : "IMPL(HIDKeyboardDriver, Start)\n{\n   kern_return_t ret;\n    \n   \/\/ Call the superclass implementation of Start.\n   ret = Start(provider, SUPERDISPATCH);\n   if (ret != kIOReturnSuccess) {\n      Stop(provider, SUPERDISPATCH);\n      return ret;\n   }\n\n   \/\/ Perform startup tasks...\n   \n   \/\/ Register the service with the system.\n   RegisterService();\n    \n   return ret;\n}\n",
      "language" : "objc"
    },
    {
      "code" : "virtual void TxPacketsAvailable (OSAction *action)\n               TYPE(IODataQueueDispatchSource::DataAvailable);",
      "language" : "objc"
    },
    {
      "code" : "status = CreateActionTxPacketsAvailable(sizeof(void *), &ivars->tx_packet);\nif (status != kIOReturnSuccess)\n   goto exit;",
      "language" : "objc"
    }
  ],
  "contentHash" : "f0ef654b1581f4711aea20eb1e6147e28f4318e1cbb8db0363404252dcf17f10",
  "crawledAt" : "2025-12-03T04:47:52Z",
  "id" : "CA5000A1-C0F0-48B8-BE41-78832F23C346",
  "kind" : "article",
  "language" : "occ",
  "module" : "DriverKit",
  "overview" : "## Overview\n\nDrivers act as a bridge between computer peripherals and the rest of the system. A driver is a collection of software-based services that communicate with a hardware device. For example, a keyboard service converts the raw state of the keyboard into keystroke events for the system to deliver to apps.\n\nWhen the user plugs in a hardware device, the system loads an initial service to communicate with the device and get basic information from it. After it establishes communication, the system loads additional services to handle device-specific interactions. For example, the system might load a service to communicate with a USB device using a specific protocol. Each new service becomes a client of the previous service, which is known as the provider for the client.\n\n\n\nApple supplies drivers and services for all standard hardware devices and communication protocols, including USB, Thunderbolt, Peripheral Component Interconnect (PCI), and more. Apple also provides drivers and services for the most common human interface device (HID) types, including mice and keyboards. You create custom drivers and services to support proprietary features or unique behaviors for your devices. You package your custom driver services inside a DriverKit extension.\n\nUse the DriverKit SDK to create custom drivers and services for the following types of devices and interfaces:\n\n### Add a DriverKit Extension Target to Your App\n\nThe delivery of a DriverKit extension requires a macOS app. You use the app to deliver the driver to your users. The app also registers the driver with the system.\n\nXcode provides a template for DriverKit extensions. To add one to your existing app, do the following:\n\nXcode adds the driver to your project and configures the build settings to install that driver inside the `Contents\/Library\/SystemExtensions` folder of your app’s bundle.\n\nThe default DriverKit template contains a C++ source file and an IOKit interface generator (`.iig`) header file to use as the starting point for your service. The template also contains a default entitlements file for you to populate with the entitlements your driver requires. For information on how to configure your driver’s entitlements, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/requesting-entitlements-for-driverkit-development].\n\n### Select an Appropriate Service to Customize\n\nThe DriverKit template provides a default subclass of the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService] class, which is the base class for all driver services. Although you can subclass [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService] directly, typically you build off of a class that is more specific to your needs. For example, when developing drivers for USB devices, you build off one of the classes in the [doc:\/\/com.apple.documentation\/documentation\/USBDriverKit] framework.\n\nThe services you create embody one of two roles:\n\nCreate interface services for devices that communicate using standards-based protocols, such as USB, but which require interpretation or management of the resulting data. An interface service reads and writes data, processes that data, and does something useful with it. For example, a HID interface service processes input reports from a HID device and dispatches events to the system. Interface classes include [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOUserHIDEventService], [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOHIDInterface], [doc:\/\/com.apple.documentation\/documentation\/SerialDriverKit\/IOUserSerial], and [doc:\/\/com.apple.documentation\/documentation\/NetworkingDriverKit\/IOUserNetworkEthernet].\n\nCreate device services to support custom communication protocols or custom hardware features. Apple provides device services for all standard protocols and hardware types. For example, the [doc:\/\/com.apple.documentation\/documentation\/USBDriverKit\/IOUSBHostDevice] class reads and writes data from any USB device. You create device services to support custom devices or to configure devices so that the system can use them. Device classes include [doc:\/\/com.apple.documentation\/documentation\/USBDriverKit\/IOUSBHostDevice], [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOHIDDevice], and [doc:\/\/com.apple.documentation\/documentation\/PCIDriverKit\/IOPCIDevice].\n\nIn your project’s `.iig` file, change the superclass of your custom service to your preferred service class. For example, to define a custom interface for a USB networking device, subclass [doc:\/\/com.apple.documentation\/documentation\/NetworkingDriverKit\/IOUserNetworkEthernet] as shown in the following code.\n\n### Initialize Your Driver\n\nWhen the system needs your driver, it instantiates your service class and calls its [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/init] method. Keep the implementation of that method as simple as possible. Typically, the only thing you do at initialization time is allocate space for your driver’s variables.\n\nYour service subclass must not contain any member variables. Instead, define a structure containing the variables your driver requires, and allocate that structure at initialization time. The following code example shows the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/init] method for a HID keyboard driver, which is a subclass of the [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOUserHIDEventService] class. The driver stores a subset of the event services elements in a custom array that it then stores in the `HIDKeyboardDriver_IVars` structure. At initialization time, the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/init]> method allocates space for this structure and assigns it to the inherited `ivars` member variable.\n\nBefore unloading your service, the system calls its free method to release any memory that it holds. Use that method to deallocate any data structures you created during initialization.\n\n### Start and Stop Your Service\n\nWhen the system is ready for your driver to begin processing information from the hardware device, it calls your service’s [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. The [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method is where you perform the actual startup tasks your driver requires, such as:\n\nUpon the succesful completion of your service’s startup tasks, call the inherited [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/RegisterService] method to let the system know that your service is running. The following code shows a template [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method for you to use for your own services.\n\nIn the preceding code, notice that the definition of the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method uses the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IMPL] macro. DriverKit services run in separate user processes, but communicate with the kernel. The [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IMPL] macro provides the kernel with the bridging code it needs to call into your driver’s process. Similarly, the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/SUPERDISPATCH] macro provides the reverse bridging that you need to call the inherited [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method, which runs in the kernel.\n\nWhen the system no longer needs your service, it calls its [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Stop] method. Use that method to undo all of the setup work from your [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. If your service has any in-progress asynchronous tasks, cancel them and wait for DriverKit to report their successful cancellation before calling the inherited [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Stop] method. Don’t use the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Stop] method to release your `ivars` structure; use your service’s [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/free] method instead.\n\n### Define Asynchronous Callback Functions\n\nWhenever you request information from DriverKit or a device, the system APIs process that request and deliver the results asynchronously to your service class. All asynchronous requests require an [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object, which tells the system which method of your service class to call. To create an [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object:\n\nTo illustrate the process, consider the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IODataQueueDispatchSource\/DataAvailable] callback function of [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IODataQueueDispatchSource]. The system calls this method when new data appears on the specified queue object. To implement your own version of this method, create a definition in your `.iig` file similar to the following:\n\nUse any name you want for your method, but make sure its return type and parameters match those of the original method—the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IODataQueueDispatchSource\/DataAvailable] method in this example. Add the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/TYPE] macro to the end of the declaration, passing the DriverKit class and method name as shown. The [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/TYPE] macro generates a function whose name is the prefix “CreateAction” followed by your custom method name. For the `TxPacketsAvailable` method, the macro creates the `CreateActionTxPacketsAvailable` function. Use this function to create the corresponding [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object, as shown in the following code:\n\nThe first parameter to the `CreateAction` function is the amount of additional memory you want the system to allocate on your behalf. Use this memory to store additional state information, and access the memory by calling the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction\/GetReference] method of the action object. The second parameter is a pointer for storing the newly created [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object.\n\n### Provide Version and Description Information\n\nThe system requires specific information to support the loading and installation of your driver. Specifically, installation of your driver fails if any of the following keys aren’t in the `Info.plist` file of your driver extension:\n\nThe system uses the version information to determine when to install a new version of your driver. Increment the version number whenever you change your driver’s behavior and want to install a new version.\n\n### Specify Criteria for Matching Your Services Against Devices\n\nThe system maintains a registry of installed drivers, and each driver contains information about the types of devices it supports. At boot time, and whenever a new hardware device appears, the system searches for drivers to support that device. In particular, it searches for drivers that meet the following criteria:\n\nDuring its search for drivers, the system uses information from the `IOKitPersonalities` key of each driver’s `Info.plist` file to identify potential matches. This key contains a dictionary of the driver’s *personalities*—that is, the types of devices it supports. Each key in the dictionary is a descriptive name of the personality, and the value is another dictionary of keys that describe the specific personality. Include the following minimum set of keys for each personality:\n\nIn addition to the minimum set of keys, include additional keys in the personality dictionary that are specific to your IOService subclasses. For example, a personality for an [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOUserHIDEventService] subclass include the `VendorID`, `ProductID`, `PrimaryUsagePage`, and `PrimaryUsage` keys to indicate the device type and manufacturer information. This information helps the system find the most appropriate match for a specific device.\n\nAfter the matching process identifies an appropriate driver, it loads the driver, initializes it, and calls its [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. Typically, the system instantiates multiple services for a single device, with each new service becoming a client of the previous service. This chain of services allows each service to handle specific tasks and rely on its provider object for lower-level tasks.\n\n### Install Your Driver Using the System Extensions Framework\n\nDriverKit extensions reside inside your app’s `Contents\/Library\/SystemExtensions` folder, and you register them using the Systems Extension framework. You must register drivers before the system can use them. During the registration process, the system validates the driver and reports back to your app about whether registration was successful.\n\nFor information about how to install your driver, see `Installing System Extensions and Drivers`.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/DriverKit\/creating-a-driver-using-the-driverkit-sdk\ncrawled: 2025-12-03T04:47:52Z\n---\n\n# Creating a Driver Using the DriverKit SDK\n\n**Article**\n\nCreate a driver that supports proprietary features of your company’s hardware devices.\n\n## Overview\n\nDrivers act as a bridge between computer peripherals and the rest of the system. A driver is a collection of software-based services that communicate with a hardware device. For example, a keyboard service converts the raw state of the keyboard into keystroke events for the system to deliver to apps.\n\nWhen the user plugs in a hardware device, the system loads an initial service to communicate with the device and get basic information from it. After it establishes communication, the system loads additional services to handle device-specific interactions. For example, the system might load a service to communicate with a USB device using a specific protocol. Each new service becomes a client of the previous service, which is known as the provider for the client.\n\n\n\nApple supplies drivers and services for all standard hardware devices and communication protocols, including USB, Thunderbolt, Peripheral Component Interconnect (PCI), and more. Apple also provides drivers and services for the most common human interface device (HID) types, including mice and keyboards. You create custom drivers and services to support proprietary features or unique behaviors for your devices. You package your custom driver services inside a DriverKit extension.\n\nUse the DriverKit SDK to create custom drivers and services for the following types of devices and interfaces:\n\n- Most USB devices\n- HID devices\n- PCI cards and devices\n- Devices with serial communication interfaces\n\n\n\n### Add a DriverKit Extension Target to Your App\n\nThe delivery of a DriverKit extension requires a macOS app. You use the app to deliver the driver to your users. The app also registers the driver with the system.\n\nXcode provides a template for DriverKit extensions. To add one to your existing app, do the following:\n\n1. Open your app project in Xcode.\n2. Select File > New > Target.\n3. Navigate to the DriverKit section.\n4. Select DriverKit Driver.\n5. Specify the driver’s name and configure other details about your driver.\n\nXcode adds the driver to your project and configures the build settings to install that driver inside the `Contents\/Library\/SystemExtensions` folder of your app’s bundle.\n\n\n\nThe default DriverKit template contains a C++ source file and an IOKit interface generator (`.iig`) header file to use as the starting point for your service. The template also contains a default entitlements file for you to populate with the entitlements your driver requires. For information on how to configure your driver’s entitlements, see [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/requesting-entitlements-for-driverkit-development].\n\n### Select an Appropriate Service to Customize\n\nThe DriverKit template provides a default subclass of the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService] class, which is the base class for all driver services. Although you can subclass [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService] directly, typically you build off of a class that is more specific to your needs. For example, when developing drivers for USB devices, you build off one of the classes in the [doc:\/\/com.apple.documentation\/documentation\/USBDriverKit] framework.\n\nThe services you create embody one of two roles:\n\n- An *interface service* manages information moving to and from the device.\n- A *device service* supports communication with the hardware.\n\nCreate interface services for devices that communicate using standards-based protocols, such as USB, but which require interpretation or management of the resulting data. An interface service reads and writes data, processes that data, and does something useful with it. For example, a HID interface service processes input reports from a HID device and dispatches events to the system. Interface classes include [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOUserHIDEventService], [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOHIDInterface], [doc:\/\/com.apple.documentation\/documentation\/SerialDriverKit\/IOUserSerial], and [doc:\/\/com.apple.documentation\/documentation\/NetworkingDriverKit\/IOUserNetworkEthernet].\n\nCreate device services to support custom communication protocols or custom hardware features. Apple provides device services for all standard protocols and hardware types. For example, the [doc:\/\/com.apple.documentation\/documentation\/USBDriverKit\/IOUSBHostDevice] class reads and writes data from any USB device. You create device services to support custom devices or to configure devices so that the system can use them. Device classes include [doc:\/\/com.apple.documentation\/documentation\/USBDriverKit\/IOUSBHostDevice], [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOHIDDevice], and [doc:\/\/com.apple.documentation\/documentation\/PCIDriverKit\/IOPCIDevice].\n\nIn your project’s `.iig` file, change the superclass of your custom service to your preferred service class. For example, to define a custom interface for a USB networking device, subclass [doc:\/\/com.apple.documentation\/documentation\/NetworkingDriverKit\/IOUserNetworkEthernet] as shown in the following code.\n\n```objc\nclass MyCustomDriver: public IOUserNetworkEthernet\n{\npublic:\n    virtual kern_return_t\n    Start(IOService * provider) override;\n};\n```\n\n### Initialize Your Driver\n\nWhen the system needs your driver, it instantiates your service class and calls its [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/init] method. Keep the implementation of that method as simple as possible. Typically, the only thing you do at initialization time is allocate space for your driver’s variables.\n\nYour service subclass must not contain any member variables. Instead, define a structure containing the variables your driver requires, and allocate that structure at initialization time. The following code example shows the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/init] method for a HID keyboard driver, which is a subclass of the [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOUserHIDEventService] class. The driver stores a subset of the event services elements in a custom array that it then stores in the `HIDKeyboardDriver_IVars` structure. At initialization time, the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/init]> method allocates space for this structure and assigns it to the inherited `ivars` member variable.\n\n```objc\nstruct HIDKeyboardDriver_IVars\n{\n    OSArray *elements;\n    \n    struct {\n        OSArray *elements;\n    } keyboard;\n};\n\nbool HIDKeyboardDriver::init()\n{\n    if (!super::init()) {\n        return false;\n    }\n    \n    ivars = IONewZero(HIDKeyboardDriver_IVars, 1);\n    if (!ivars) {\n        return false;\n    }\n    \nexit:\n    return true;\n}\n\n```\n\nBefore unloading your service, the system calls its free method to release any memory that it holds. Use that method to deallocate any data structures you created during initialization.\n\n### Start and Stop Your Service\n\nWhen the system is ready for your driver to begin processing information from the hardware device, it calls your service’s [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. The [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method is where you perform the actual startup tasks your driver requires, such as:\n\n- Initialize your custom instance variables structure.\n- Fetch the device’s configuration and change any settings.\n- Set up pipes and other communication channels with the device.\n- Store a reference to the provider object that the system passed to your [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method.\n- Allocate memory for data buffers.\n- Fetch the initial set of data.\n- Create and register callback methods.\n\nUpon the succesful completion of your service’s startup tasks, call the inherited [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/RegisterService] method to let the system know that your service is running. The following code shows a template [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method for you to use for your own services.\n\n```objc\nIMPL(HIDKeyboardDriver, Start)\n{\n   kern_return_t ret;\n    \n   \/\/ Call the superclass implementation of Start.\n   ret = Start(provider, SUPERDISPATCH);\n   if (ret != kIOReturnSuccess) {\n      Stop(provider, SUPERDISPATCH);\n      return ret;\n   }\n\n   \/\/ Perform startup tasks...\n   \n   \/\/ Register the service with the system.\n   RegisterService();\n    \n   return ret;\n}\n\n```\n\nIn the preceding code, notice that the definition of the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method uses the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IMPL] macro. DriverKit services run in separate user processes, but communicate with the kernel. The [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IMPL] macro provides the kernel with the bridging code it needs to call into your driver’s process. Similarly, the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/SUPERDISPATCH] macro provides the reverse bridging that you need to call the inherited [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method, which runs in the kernel.\n\nWhen the system no longer needs your service, it calls its [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Stop] method. Use that method to undo all of the setup work from your [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. If your service has any in-progress asynchronous tasks, cancel them and wait for DriverKit to report their successful cancellation before calling the inherited [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Stop] method. Don’t use the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Stop] method to release your `ivars` structure; use your service’s [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/free] method instead.\n\n### Define Asynchronous Callback Functions\n\nWhenever you request information from DriverKit or a device, the system APIs process that request and deliver the results asynchronously to your service class. All asynchronous requests require an [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object, which tells the system which method of your service class to call. To create an [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object:\n\n1. Define a custom method in your service class, and give the method the same signature as a DriverKit asynchronous callback function.\n2. Add the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/TYPE] macro to the end of your custom method, specifying the DriverKit class and method name as the macro’s parameter.\n3. Create the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object using the `CreateAction` method the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/TYPE] macro generates.\n\nTo illustrate the process, consider the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IODataQueueDispatchSource\/DataAvailable] callback function of [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IODataQueueDispatchSource]. The system calls this method when new data appears on the specified queue object. To implement your own version of this method, create a definition in your `.iig` file similar to the following:\n\n```objc\nvirtual void TxPacketsAvailable (OSAction *action)\n               TYPE(IODataQueueDispatchSource::DataAvailable);\n```\n\nUse any name you want for your method, but make sure its return type and parameters match those of the original method—the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IODataQueueDispatchSource\/DataAvailable] method in this example. Add the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/TYPE] macro to the end of the declaration, passing the DriverKit class and method name as shown. The [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/TYPE] macro generates a function whose name is the prefix “CreateAction” followed by your custom method name. For the `TxPacketsAvailable` method, the macro creates the `CreateActionTxPacketsAvailable` function. Use this function to create the corresponding [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object, as shown in the following code:\n\n```objc\nstatus = CreateActionTxPacketsAvailable(sizeof(void *), &ivars->tx_packet);\nif (status != kIOReturnSuccess)\n   goto exit;\n```\n\nThe first parameter to the `CreateAction` function is the amount of additional memory you want the system to allocate on your behalf. Use this memory to store additional state information, and access the memory by calling the [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction\/GetReference] method of the action object. The second parameter is a pointer for storing the newly created [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/OSAction] object.\n\n### Provide Version and Description Information\n\nThe system requires specific information to support the loading and installation of your driver. Specifically, installation of your driver fails if any of the following keys aren’t in the `Info.plist` file of your driver extension:\n\n- [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/CFBundleShortVersionString]\n- [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/CFBundleVersion]\n- [doc:\/\/com.apple.documentation\/documentation\/SystemExtensions\/OSBundleUsageDescriptionKey]\n\nThe system uses the version information to determine when to install a new version of your driver. Increment the version number whenever you change your driver’s behavior and want to install a new version.\n\n### Specify Criteria for Matching Your Services Against Devices\n\nThe system maintains a registry of installed drivers, and each driver contains information about the types of devices it supports. At boot time, and whenever a new hardware device appears, the system searches for drivers to support that device. In particular, it searches for drivers that meet the following criteria:\n\n- Supports the appropriate class of hardware (USB, PCI, Thunderbolt)\n- Supports the vendor that created the device\n- Supports the protocols or interfaces (HID, Mass Storage) listed in the device’s configuration data\n\nDuring its search for drivers, the system uses information from the `IOKitPersonalities` key of each driver’s `Info.plist` file to identify potential matches. This key contains a dictionary of the driver’s *personalities*—that is, the types of devices it supports. Each key in the dictionary is a descriptive name of the personality, and the value is another dictionary of keys that describe the specific personality. Include the following minimum set of keys for each personality:\n\n- [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/CFBundleIdentifier]—The bundle ID of your driver\n- `IOClass`—The Apple class containing the base behavior\n- `IOUserClass`—The name of your custom service class\n- `IOUserServerName`—The bundle identifier of your driver\n- `IOProviderClass`—The class that your service requires as its provider object\n\nIn addition to the minimum set of keys, include additional keys in the personality dictionary that are specific to your IOService subclasses. For example, a personality for an [doc:\/\/com.apple.documentation\/documentation\/HIDDriverKit\/IOUserHIDEventService] subclass include the `VendorID`, `ProductID`, `PrimaryUsagePage`, and `PrimaryUsage` keys to indicate the device type and manufacturer information. This information helps the system find the most appropriate match for a specific device.\n\nAfter the matching process identifies an appropriate driver, it loads the driver, initializes it, and calls its [doc:\/\/com.apple.driverkit\/documentation\/DriverKit\/IOService\/Start] method. Typically, the system instantiates multiple services for a single device, with each new service becoming a client of the previous service. This chain of services allows each service to handle specific tasks and rely on its provider object for lower-level tasks.\n\n### Install Your Driver Using the System Extensions Framework\n\nDriverKit extensions reside inside your app’s `Contents\/Library\/SystemExtensions` folder, and you register them using the Systems Extension framework. You must register drivers before the system can use them. During the registration process, the system validates the driver and reports back to your app about whether registration was successful.\n\nFor information about how to install your driver, see `Installing System Extensions and Drivers`.\n\n## Services\n\n- **Debugging and testing system extensions**: Debug your system extensions by temporarily disabling the security checks that macOS performs during the installation process.\n- **IOService**: The base class for managing the setup and registration of your driver.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Debug your system extensions by temporarily disabling the security checks that macOS performs during the installation process.",
          "name" : "Debugging and testing system extensions",
          "url" : "https:\/\/developer.apple.com\/documentation\/DriverKit\/debugging-and-testing-system-extensions"
        },
        {
          "description" : "The base class for managing the setup and registration of your driver.",
          "name" : "IOService",
          "url" : "https:\/\/developer.apple.com\/documentation\/DriverKit\/IOService"
        }
      ],
      "title" : "Services"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a Driver Using the DriverKit SDK",
  "url" : "https:\/\/developer.apple.com\/documentation\/DriverKit\/creating-a-driver-using-the-driverkit-sdk"
}