{
  "abstract" : "Integrate your custom collaboration app with Messages.",
  "codeExamples" : [
    {
      "code" : "\/\/ Configure the SWCollaborationMetadata.\n\nlet localIdentifier = SWLocalCollaborationIdentifier(rawValue: \"identifier\")\nlet metadata = SWCollaborationMetadata(localIdentifier: localIdentifier)\nmetadata.title = \"Content Title\"\nmetadata.initiatorHandle = \"user@example.com\"\n\nlet formatter = PersonNameComponentsFormatter()\nif let components = formatter.personNameComponents(from: \"Devin\") {\n    metadata.initiatorNameComponents = components\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Configure the SWCollaborationShareOptions.\n\nlet permission = SWCollaborationOptionsPickerGroup(identifier: UUID().uuidString, \n                                                   options: [\n    SWCollaborationOption(title: \"Can make changes\", identifier: UUID().uuidString),\n    SWCollaborationOption(title: \"Read only\", identifier: UUID().uuidString)\n])\npermission.options[0].isSelected = true\npermission.title = \"Permission\"\n\nlet additionalOptions = SWCollaborationOptionsGroup(identifier: UUID().uuidString, \n                                                    options: [\n    SWCollaborationOption(title: \"Allow mentions\", identifier: UUID().uuidString),\n    SWCollaborationOption(title: \"Allow comments\", identifier: UUID().uuidString)\n])\nadditionalOptions.title = \"Additional Settings\"\nlet optionsGroups = [permission, additionalOptions]\nmetadata.defaultShareOptions = SWCollaborationShareOptions(optionsGroups: optionsGroups)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Configure the SwiftUI TransferRepresentation object.\n\nstruct CustomCollaboration: Transferable {\n    var name: String\n\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation { customCollaboration in\n            SWCollaborationMetadata(\n                localIdentifier: .init(rawValue: \"com.example.customcollaboration\"),\n                title: customCollaboration.name,\n                defaultShareOptions: nil,\n                initiatorHandle: \"johnappleseed@apple.com\",\n                initiatorNameComponents: nil\n            )\n        }\n    }\n}\n\n\/\/ Initialize ShareLink with the custom collaboration model object.\n\nstruct ContentView: View {\n    var body: some View {\n        ShareLink(item: CustomCollaboration(name: \"Example\"), preview: .init(\"Example\"))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Present the iOS share sheet.\n\nfunc presentActivityViewController(metadata: SWCollaborationMetadata) {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    let activityConfig = UIActivityItemsConfiguration(itemProviders: [itemProvider])\n    let shareSheet = UIActivityViewController(activityItemsConfiguration: activityConfig)\n    present(shareSheet, animated: true)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Support iOS drag and drop.\n\nfunc createDragItem(metadata: SWCollaborationMetadata) -> UIDragItem {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    return UIDragItem(itemProvider: itemProvider)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Show the macOS sharing popover.\n\nfunc showSharingServicePicker(view: NSView, metadata: SWCollaborationMetadata) {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    let picker = NSSharingServicePicker(items: [itemProvider])\n    picker.show(relativeTo: view.bounds, of: view, preferredEdge: .minY)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Support macOS drag and drop.\n\nfunc createPasteboardItem(metadata: SWCollaborationMetadata) -> NSPasteboardItem {\n    let pasteboardItem = NSPasteboardItem()\n    pasteboardItem.collaborationMetadata = metadata\n    return pasteboardItem\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Assign your action handler to the SWCollaborationCoordinator.\n\nprivate let collaborationCoordinator = SWCollaborationCoordinator.shared\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]?) -> Bool {\n    \/\/ Conform to the SWCollaborationActionHandler protocol.\n    collaborationCoordinator.actionHandler = self\n}\n",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Handle a system request for an SWStartCollaborationAction.\n\nfunc collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWStartCollaborationAction) {\n    let localID = action.collaborationMetadata.localIdentifier.rawValue\n    let selectedOptions = action.collaborationMetadata.userSelectedShareOptions\n    let prepareRequest = APIRequest.PrepareCollaboration(localID: localID, selectedOptions)\n    Task {\n        do {            \n            let response = try await apiController.send(request: prepareRequest)\n            let identifier = response.deviceIndependentIdentifier\n            action.fulfill(using: response.url, collaborationIdentifier: identifier)\n        } catch {\n            Log.error(\"Caught an error while preparing the collaboration: \\(error)\")\n            action.fail() \/\/ Cancels the message.\n        }\n    }\n}\n",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Retrieve a signed identity proof for a highlight.\n\nfunc application(_ app: UIApplication, open url: URL, \n               options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let challengeRequest = APIRequest.GetChallengeData()\n    Task {\n        do {\n            let highlight = try highlightCenter.collaborationHighlight(for: url)\n            let challenge = try await apiController.send(request: challengeRequest)\n            let proof = try await highlightCenter.getSignedIdentityProof(for: highlight, \n                                                                       using: challenge.data)\n    let proofOfInclusionRequest = APIRequest.SubmitProofOfInclusion(for: proof)\n            let result = try await apiController.send(request: proofOfInclusionRequest)\n            documentController.update(currentDocument, with: result)\n        } catch {\n            Log.error(\"Caught an error while generating the proof of inclusion: \\(error)\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Recursive code for root hash generation.\n\nfunc generateRootHashFromArray(localHash: SHA256Digest, inclusionHashes: [SHA256Digest], \n                       publicKeyIndex: Int) -> SHA256Digest {\n    guard let firstHash = inclusionHashes.first else { return localHash }\n    \/\/ Check whether the node is the left or the right successor.\n    let isLeft = publicKeyIndex.isMultiple(of: 2)\n    \/\/ Calculate the combined hash.\n    var rootHash: SHA256Digest\n    if isLeft {\n        rootHash = hash(concatenate([localHash, firstHash]), using: .sha256)\n    } else {\n        rootHash = hash(concatenate([firstHash, localHash]), using: .sha256)\n    }\n    \/\/ Recursively pass in elements and move up the Merkle tree.\n    let newInclusionHashes = inclusionHashes.dropFirst()\n    rootHash = generateRootHashFromArray(\n        localHash: rootHash,\n        inclusionHashes: Array(newInclusionHashes),\n        publicKeyIndex: (publicKeyIndex \/ 2)\n    )\n    return rootHash\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Add a participant.\n\nfunc collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWUpdateCollaborationParticipantsAction) {\n    let identifier = action.collaborationMetadata.collaborationIdentifier\n    let participants: [Data] = action.addedIdentities.compactMap { $0.rootHash }\n    let addParticipants = APIRequest.AddParticipants(identifier: identifier, participants)\n    Task {\n        do {            \n            try await apiController.send(request: addParticipants)\n            action.fulfill() \/\/ Sends the URL that the start action provides.\n        } catch {\n            Log.error(\"Caught an error while adding participants to the collaboration: \\(error)\")\n            action.fail() \/\/ Cancels the message.\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Remove a participant.\n\nfunc collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWUpdateCollaborationParticipantsAction) {\n    \/\/ This is an example of removing participants only. Handle the added identities here too.\n    let identifier = action.collaborationMetadata.collaborationIdentifier\n    let removed: [Data] = action.removedIdentities.compactMap { $0.rootHash }\n    let removeParticipants = APIRequest.RemoveParticipants(identifier: identifier, removed)\n    Task {\n        do {            \n            try await apiController.send(request: removeParticipants)\n            action.fulfill()\n        } catch {\n            log.error(\"Caught an error while adding participants to the collaboration: \\(error)\")\n            action.fail()\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Post a change event notice.\n\nfunc postContentEditEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let editEvent = SWHighlightChangeEvent(highlight: highlight, trigger: .edit)\n\n    highlightCenter.postNotice(for: editEvent)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Post a membership event notice.\n\nfunc postMembershipEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let membershipEvent = SWHighlightMembershipEvent(highlight: highlight, trigger: .addCollaborator)\n\n    highlightCenter.postNotice(for: membershipEvent)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Post a mention event notice.\n\nfunc postMentionEvent(identifier: SWCollaborationIdentifier, mentionedRootHash: Data) throws {\n    let mentionedIdentity = SWPerson.Identity(rootHash: mentionedRootHash)\n\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let mentionEvent = SWHighlightMentionEvent(highlight: highlight,\n                                               mentionedPersonIdentity: mentionedIdentity)\n    highlightCenter.postNotice(for: mentionEvent)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Post a persistent event notice.\n\nfunc postContentRenamedEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let renamedEvent = SWHighlightPersistenceEvent(highlight: highlight, trigger: .renamed)\n    highlightCenter.postNotice(for: renamedEvent)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "0b0c532df85cd665e4c0eb8e5fd6a1d4e045cd859a52f26571b745bc8dedb70d",
  "crawledAt" : "2025-12-04T02:42:47Z",
  "id" : "F02F0DDA-4AEA-4658-8215-A550056A0E9E",
  "kind" : "article",
  "language" : "swift",
  "module" : "Shared with You",
  "overview" : "## Overview\n\nIf your app uses iCloud to store shared content, you can use the steps in [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/adding-shared-content-collaboration-to-your-app] to add collaboration. To share content without using iCloud, the Shared with You framework provides an [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata] object wrapped in [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProvider] to implement a custom collaboration infrastructure.\n\nBefore you can use this collaboration infrastructure, your app needs to support universal links to share content with other apps. For more details about implementing universal links, see [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/making-your-app-content-shareable].\n\n\n\n### Create the metadata object\n\nWhen a user decides to share a collaboration from your app through the Messages app, you first create metadata to represent the content. The metadata includes share options the user can configure prior to sending the message, and many other properties you can customize. Next, you provide that metadata to the share sheet, or to drag and drop using the steps below in the “Present a collaboration view” section.\n\nThe string you pass to [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWLocalCollaborationIdentifier] doesn’t need to be unique across devices, it’s only for your app to use locally. Similarly, the system displays the initiator’s account handle and name that your app retrieves from [doc:\/\/com.apple.documentation\/documentation\/Foundation\/PersonNameComponentsFormatter\/personNameComponents(from:)] locally so the collaborator can confirm their account.\n\nAfter your app sets the identifier and initiator for the metadata, configure [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationShareOptions]. Share options are the settings a person configures on the collaboration in Messages or the share sheet. Options represent individual switches, or mutually exclusive values for a setting. Options have a title and an identifier, and are either in a selected or an unselected state.\n\nThere are two classes to represent a group of options: [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationOptionsGroup] and [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationOptionsPickerGroup]. Use `SWCollaborationOptionsGroup` to represent a collection of switches, and use `SWCollaborationOptionsPickerGroup` to represent mutually exclusive values for a setting.\n\nIn the example below, a person can choose either the “Can make changes” or the “Read only” option. The collaborator can choose “Allow mentions” and the “Allow comments” options independent of each other. The app then passes both the option groups to `SWCollaborationShareOptions` to initialize the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata\/defaultShareOptions].\n\n### Present a collaboration view\n\nIf your app uses SwiftUI, [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata] is compatible with the [doc:\/\/com.apple.documentation\/documentation\/CoreTransferable\/Transferable] protocol and the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ShareLink] view. In the example below, the app defines a `Transferable` model object and creates a [doc:\/\/com.apple.documentation\/documentation\/CoreTransferable\/ProxyRepresentation] to return a collaboration metadata instance. Then, the app passes that model object to a `ShareLink` instance in the view.\n\nIt’s good practice to register multiple representations of the content to support sharing through as many channels as possible. For example, Messages automatically offers an option to send the content as a copy if you provide a file representation.\n\nFor UIKit and AppKit apps, use [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProvider] to support content sharing. `SWCollaborationMetadata` conforms to the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProviderReading] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProviderWriting] protocols, so you can register a metadata instance with an item provider to support collaboration. Use `NSItemProvider` with [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIActivityViewController] and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIDragItem] in iOS and iPadOS, and [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSSharingServicePicker] in macOS.\n\nIn the example code below, the app registers the collaboration metadata in an `NSItemProvider` instance. Then the app creates a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIActivityItemsConfiguration] object with the item provider object and passes that to the `UIActivityViewController`. Finally, the app presents the share sheet.\n\nTo support drag and drop in iOS, initialize `NSItemProvider` and register the metadata the same way as in the previous code example, then create a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIDragItem] with the item provider.\n\nThe API is similar in macOS for the sharing popover. Use the item provider to initialize an [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSSharingServicePicker] object and show the picker relative to a target view.\n\nTo support drag and drop in macOS, use [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSPasteboardItem] instead of `NSItemProvider`. Assign the collaboration metadata to [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSPasteboardItem\/collaborationMetadata] on a new `NSPasteboardItem` instance.\n\nThe system stages a draft of your collaborative content in Messages. After a person taps the Send button, the system coordinates with your app to create the share.\n\n### Prepare the collaboration coordinator\n\n`SWCollaborationCoordinator` is a singleton, meaning there’s a global shared instance that your app uses to respond to action requests. Your app defines an action handler that conforms to the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationActionHandler] protocol. Because the collaboration coordinator runs in the background and can send requests for actions to your app at any time, define your action handler early in the launch process. The app in the example below registers the handler in the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)] method:\n\nYour action handler is responsible for responding to [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction] requests from the system. An `SWAction` represents work your app needs to handle during a collaboration. Your app calls [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction\/fulfill()] after it completes a request. If your app can’t complete an action, it responds with [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction\/fail()]. It’s important to respond to `SWAction` requests quickly to avoid a system timeout.\n\nThe example code below retrieves the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata\/localIdentifier] and [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata\/userSelectedShareOptions] from the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata] in the action. The `APIRequest` object in this example is the API for processing collaboration requests on a web server.\n\nIf the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWStartCollaborationAction] is successful, the system sends your app a second action to update the collaboration participants. Before you can add or remove participants, your app needs to have a way to verify participants.\n\n### Verify participant access\n\nThe [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWUpdateCollaborationParticipantsAction] contains the cryptographic identities for the participants. The system derives the identities from the collaboration identifier that `SWStartCollaborationAction` provides. Your shared content server is responsible for identity storage and verification of recipient devices.\n\nTo verify a participant, use the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/Identity] [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/Identity\/rootHash] property. A root hash is a secure value your app sends to your server to uniquely identify a participant on their devices. To perform a verification, your server needs to compute a root hash.\n\nWhen the system sends a collaboration message for a participant, it actually sends individual messages to each device for that participant. The Messages app identifies each device using a cryptographic public key. Because the goal is to allow access only on this participant’s set of devices, the system derives the root hash from the set of public keys registered to each recipient.\n\nThe root hash is the root node of a data structure called a *Merkle tree*. A Merkle tree is a binary tree that the system builds by performing a sequence of hashing operations. To derive an identity for the participant based on their public keys, the system uses the keys as the *leaves* of this tree. The hashing algorithm that the system uses in the Merkle tree ensures that the system can only compute the root node from that set of keys.\n\nIn the example below, the user has three devices and three public keys. The keys are unique for each collaboration identifier that your app provides, using a process called key diversification. To prevent tracking the number of devices registered to a user, the system pads the set with random keys up to a fixed size. Your server hashes the padded set of diversified keys to create the leaf nodes of the tree with a SHA-256 algorithm.\n\n\n\nYour server then concatenates and hashes each pair of leaf nodes to derive their predecessor nodes. Repeat this process with the predecessor nodes until a single root node remains. This is the root hash that the system uses to uniquely represent this recipient’s identity across their devices.\n\nThe figure below shows that it’s possible to generate a root hash using a subset of the nodes from a complete Merkle tree. Your server can use the hashes H4, H7, and H11, along with the diversified public key P3, to reproduce the root hash in this tree. First, hash the public key to get the missing leaf node H3. Then use H3 and H4 to generate H8. Next, use the given H7 node with H8 to generate H10. Finally, use H10 and H11 to produce the root hash.\n\n\n\nIt’s important to note that you can prove the system uses the public key P3 to generate a given root hash, without needing to reconstruct the entire tree. The subset of nodes necessary to do this is a proof of inclusion. Verification begins when your app opens a universal link. To do this, you first need to check that the link is collaborative.\n\n### Verify a collaboration link\n\n[doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWCollaborationHighlight] represents a collaborative link that your app retrieves from [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightCenter]. Use that collaboration highlight to generate the proof of inclusion. To represent a proof of inclusion, use [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/IdentityProof]. To perform verification, first generate this object along with a cryptographic signature to send to your server. Retrieve the proof using the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightCenter\/getSignedIdentityProof(for:using:completionHandler:)] method on `SWHighlightCenter`.\n\nUse the signature to ensure that a bad actor can’t send the request to gain access to your collaboration. The data can be a challenge you request from your server, or a nonce that the device generates. The example below uses the challenge approach.\n\nThe system passes the URL, which is the universal link associated with a collaboration, to [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)]. Use this URL to fetch the associated `SWCollaborationHighlight` from the `SWHighlightCenter`.\n\nRequest the challenge from the server, and pass the returned data to the `getSignedIdentityProof` method on `SWHighlightCenter`, along with the highlight. This method returns a signed identity proof that the app sends to the server for verification.\n\nThe app sends the proof to the server, along with the public key and the signed data. Your app signs the data using the Elliptic Curve Digital Signature Algorithm over the P-256 elliptic curve. Verify the signature on the data using the public key in the identity proof. You can do this with most common encryption libraries.\n\nAfter you verify the signature, you can trust that the identity proof the system sends is from the device associated with that public key. Next, use the identity proof to recompute the root hash. A recursive algorithm works well with tree data structures, as in the code example below:\n\nOn the initial invocation, pass in the hash of the public key, the set of inclusion hashes, and the public key index. Next, remove the first inclusion hash. Check the public key index to see whether the key is on the left or the right of its sibling. Concatenate and hash the selected hashes in the correct order. Next, remove the consumed node in the `inclusionHashes` array, and pass the rest to a recursive call to this same function. The public key index then updates so that it’s ready for the next node in the tree.\n\nWith this simple function, you can quickly compute a root hash given an identity proof. The server can check that this generated root hash is in the list of root hashes the owner of the document uploads during sending. The hash is present in the list of known hashes, so the server can grant access to the document.\n\nNext, sign some data and retrieve the proof of inclusion. Send the signed data and proof to your server. Verify the signature on the data. Using the proof of inclusion, generate the root hash. Finally, compare the root hash to the list of known identities associated with that content.\n\n### Add a participant\n\nThe example below shows how to handle the update participants action. First, retrieve the collaboration identifier from the action’s metadata — this is the identifier you supply to the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction\/fulfill()] method while handling `SWStartCollaborationAction`.\n\nNext, use the action’s [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWUpdateCollaborationParticipantsAction\/addedIdentities] property to retrieve the participant data to store on your content server. Each identity has a [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/Identity\/rootHash] property, which is the data you store on your server to validate participants during the collaboration process.\n\nAfter you retrieve this data, create another server request to add the participants to the collaboration with the target identifier. Then, send the request to your server, and fulfill or fail the action. This time, the fulfill method doesn’t take any parameters. After you set up the collaboration, your app has everything it needs to grant immediate access to the recipients of the message.\n\n### Remove a participant\n\nTo remove a participant, look up any account associated with a removed identity and revoke their access. If your app doesn’t have any associated accounts for this collaboration, delete the root hash from your database. The example code below uses the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWUpdateCollaborationParticipantsAction\/removedIdentities] property on the action and passes it to a similar removal API request:\n\n### Post a change event notice\n\nWhen a participant makes changes to a collaboration, your app posts notices about those changes. The system displays those notices in Messages as a banner in the shared conversation. The banner includes a description of the changes, as well as the name of the person who makes each change.\n\nYour app posts a change event for content updates or comments, and it posts a membership event when a participant joins or leaves. When a person mentions another person in a collaboration, post a mention event. Post a persistence event when a collaborator moves or deletes content. The example code below shows how to post a change event for an edit to a collaboration:\n\n### Post a membership event notice\n\nFor participant changes, your app posts a membership event and passes either the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightMembershipEventTrigger\/addedCollaborator] or [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightMembershipEventTrigger\/removedCollaborator] trigger type.\n\n### Post a mention event notice\n\nIf your app supports user mentions, you can post a mention event. Initialize a person identity with the root hash of the mentioned user. Next, pass the mentioned identity to [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightMentionEvent] and post the mention event.\n\nThe system shows this notice only to the mentioned user in the Messages app.\n\n### Post a persistence event notice\n\nYour app posts the persistence event type when a participant moves, renames, or deletes content. In the example below, the app uses [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightPersistenceEventTrigger\/renamed] to indicate that the participant changed the name of the content:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/sharedwithyou\/adding-custom-collaboration-to-your-app\ncrawled: 2025-12-04T02:42:47Z\n---\n\n# Adding custom collaboration to your app\n\n**Article**\n\nIntegrate your custom collaboration app with Messages.\n\n## Overview\n\nIf your app uses iCloud to store shared content, you can use the steps in [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/adding-shared-content-collaboration-to-your-app] to add collaboration. To share content without using iCloud, the Shared with You framework provides an [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata] object wrapped in [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProvider] to implement a custom collaboration infrastructure.\n\nBefore you can use this collaboration infrastructure, your app needs to support universal links to share content with other apps. For more details about implementing universal links, see [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/making-your-app-content-shareable].\n\n\n\n\n\n### Create the metadata object\n\nWhen a user decides to share a collaboration from your app through the Messages app, you first create metadata to represent the content. The metadata includes share options the user can configure prior to sending the message, and many other properties you can customize. Next, you provide that metadata to the share sheet, or to drag and drop using the steps below in the “Present a collaboration view” section.\n\nThe string you pass to [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWLocalCollaborationIdentifier] doesn’t need to be unique across devices, it’s only for your app to use locally. Similarly, the system displays the initiator’s account handle and name that your app retrieves from [doc:\/\/com.apple.documentation\/documentation\/Foundation\/PersonNameComponentsFormatter\/personNameComponents(from:)] locally so the collaborator can confirm their account.\n\n```swift\n\/\/ Configure the SWCollaborationMetadata.\n\nlet localIdentifier = SWLocalCollaborationIdentifier(rawValue: \"identifier\")\nlet metadata = SWCollaborationMetadata(localIdentifier: localIdentifier)\nmetadata.title = \"Content Title\"\nmetadata.initiatorHandle = \"user@example.com\"\n\nlet formatter = PersonNameComponentsFormatter()\nif let components = formatter.personNameComponents(from: \"Devin\") {\n    metadata.initiatorNameComponents = components\n}\n```\n\nAfter your app sets the identifier and initiator for the metadata, configure [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationShareOptions]. Share options are the settings a person configures on the collaboration in Messages or the share sheet. Options represent individual switches, or mutually exclusive values for a setting. Options have a title and an identifier, and are either in a selected or an unselected state.\n\nThere are two classes to represent a group of options: [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationOptionsGroup] and [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationOptionsPickerGroup]. Use `SWCollaborationOptionsGroup` to represent a collection of switches, and use `SWCollaborationOptionsPickerGroup` to represent mutually exclusive values for a setting.\n\nIn the example below, a person can choose either the “Can make changes” or the “Read only” option. The collaborator can choose “Allow mentions” and the “Allow comments” options independent of each other. The app then passes both the option groups to `SWCollaborationShareOptions` to initialize the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata\/defaultShareOptions].\n\n```swift\n\/\/ Configure the SWCollaborationShareOptions.\n\nlet permission = SWCollaborationOptionsPickerGroup(identifier: UUID().uuidString, \n                                                   options: [\n    SWCollaborationOption(title: \"Can make changes\", identifier: UUID().uuidString),\n    SWCollaborationOption(title: \"Read only\", identifier: UUID().uuidString)\n])\npermission.options[0].isSelected = true\npermission.title = \"Permission\"\n\nlet additionalOptions = SWCollaborationOptionsGroup(identifier: UUID().uuidString, \n                                                    options: [\n    SWCollaborationOption(title: \"Allow mentions\", identifier: UUID().uuidString),\n    SWCollaborationOption(title: \"Allow comments\", identifier: UUID().uuidString)\n])\nadditionalOptions.title = \"Additional Settings\"\nlet optionsGroups = [permission, additionalOptions]\nmetadata.defaultShareOptions = SWCollaborationShareOptions(optionsGroups: optionsGroups)\n```\n\n### Present a collaboration view\n\nIf your app uses SwiftUI, [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata] is compatible with the [doc:\/\/com.apple.documentation\/documentation\/CoreTransferable\/Transferable] protocol and the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ShareLink] view. In the example below, the app defines a `Transferable` model object and creates a [doc:\/\/com.apple.documentation\/documentation\/CoreTransferable\/ProxyRepresentation] to return a collaboration metadata instance. Then, the app passes that model object to a `ShareLink` instance in the view.\n\n```swift\n\/\/ Configure the SwiftUI TransferRepresentation object.\n\nstruct CustomCollaboration: Transferable {\n    var name: String\n\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation { customCollaboration in\n            SWCollaborationMetadata(\n                localIdentifier: .init(rawValue: \"com.example.customcollaboration\"),\n                title: customCollaboration.name,\n                defaultShareOptions: nil,\n                initiatorHandle: \"johnappleseed@apple.com\",\n                initiatorNameComponents: nil\n            )\n        }\n    }\n}\n\n\/\/ Initialize ShareLink with the custom collaboration model object.\n\nstruct ContentView: View {\n    var body: some View {\n        ShareLink(item: CustomCollaboration(name: \"Example\"), preview: .init(\"Example\"))\n    }\n}\n```\n\nIt’s good practice to register multiple representations of the content to support sharing through as many channels as possible. For example, Messages automatically offers an option to send the content as a copy if you provide a file representation.\n\nFor UIKit and AppKit apps, use [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProvider] to support content sharing. `SWCollaborationMetadata` conforms to the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProviderReading] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSItemProviderWriting] protocols, so you can register a metadata instance with an item provider to support collaboration. Use `NSItemProvider` with [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIActivityViewController] and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIDragItem] in iOS and iPadOS, and [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSSharingServicePicker] in macOS.\n\nIn the example code below, the app registers the collaboration metadata in an `NSItemProvider` instance. Then the app creates a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIActivityItemsConfiguration] object with the item provider object and passes that to the `UIActivityViewController`. Finally, the app presents the share sheet.\n\n```swift\n\/\/ Present the iOS share sheet.\n\nfunc presentActivityViewController(metadata: SWCollaborationMetadata) {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    let activityConfig = UIActivityItemsConfiguration(itemProviders: [itemProvider])\n    let shareSheet = UIActivityViewController(activityItemsConfiguration: activityConfig)\n    present(shareSheet, animated: true)\n}\n```\n\nTo support drag and drop in iOS, initialize `NSItemProvider` and register the metadata the same way as in the previous code example, then create a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIDragItem] with the item provider.\n\n```swift\n\/\/ Support iOS drag and drop.\n\nfunc createDragItem(metadata: SWCollaborationMetadata) -> UIDragItem {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    return UIDragItem(itemProvider: itemProvider)\n}\n```\n\nThe API is similar in macOS for the sharing popover. Use the item provider to initialize an [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSSharingServicePicker] object and show the picker relative to a target view.\n\n```swift\n\/\/ Show the macOS sharing popover.\n\nfunc showSharingServicePicker(view: NSView, metadata: SWCollaborationMetadata) {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    let picker = NSSharingServicePicker(items: [itemProvider])\n    picker.show(relativeTo: view.bounds, of: view, preferredEdge: .minY)\n}\n```\n\nTo support drag and drop in macOS, use [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSPasteboardItem] instead of `NSItemProvider`. Assign the collaboration metadata to [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSPasteboardItem\/collaborationMetadata] on a new `NSPasteboardItem` instance.\n\n```swift\n\/\/ Support macOS drag and drop.\n\nfunc createPasteboardItem(metadata: SWCollaborationMetadata) -> NSPasteboardItem {\n    let pasteboardItem = NSPasteboardItem()\n    pasteboardItem.collaborationMetadata = metadata\n    return pasteboardItem\n}\n```\n\nThe system stages a draft of your collaborative content in Messages. After a person taps the Send button, the system coordinates with your app to create the share.\n\n### Prepare the collaboration coordinator\n\n`SWCollaborationCoordinator` is a singleton, meaning there’s a global shared instance that your app uses to respond to action requests. Your app defines an action handler that conforms to the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationActionHandler] protocol. Because the collaboration coordinator runs in the background and can send requests for actions to your app at any time, define your action handler early in the launch process. The app in the example below registers the handler in the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)] method:\n\n```swift\n\/\/ Assign your action handler to the SWCollaborationCoordinator.\n\nprivate let collaborationCoordinator = SWCollaborationCoordinator.shared\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]?) -> Bool {\n    \/\/ Conform to the SWCollaborationActionHandler protocol.\n    collaborationCoordinator.actionHandler = self\n}\n\n```\n\nYour action handler is responsible for responding to [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction] requests from the system. An `SWAction` represents work your app needs to handle during a collaboration. Your app calls [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction\/fulfill()] after it completes a request. If your app can’t complete an action, it responds with [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction\/fail()]. It’s important to respond to `SWAction` requests quickly to avoid a system timeout.\n\nThe example code below retrieves the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata\/localIdentifier] and [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata\/userSelectedShareOptions] from the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWCollaborationMetadata] in the action. The `APIRequest` object in this example is the API for processing collaboration requests on a web server.\n\n```swift\n\/\/ Handle a system request for an SWStartCollaborationAction.\n\nfunc collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWStartCollaborationAction) {\n    let localID = action.collaborationMetadata.localIdentifier.rawValue\n    let selectedOptions = action.collaborationMetadata.userSelectedShareOptions\n    let prepareRequest = APIRequest.PrepareCollaboration(localID: localID, selectedOptions)\n    Task {\n        do {            \n            let response = try await apiController.send(request: prepareRequest)\n            let identifier = response.deviceIndependentIdentifier\n            action.fulfill(using: response.url, collaborationIdentifier: identifier)\n        } catch {\n            Log.error(\"Caught an error while preparing the collaboration: \\(error)\")\n            action.fail() \/\/ Cancels the message.\n        }\n    }\n}\n\n```\n\nIf the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWStartCollaborationAction] is successful, the system sends your app a second action to update the collaboration participants. Before you can add or remove participants, your app needs to have a way to verify participants.\n\n### Verify participant access\n\nThe [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWUpdateCollaborationParticipantsAction] contains the cryptographic identities for the participants. The system derives the identities from the collaboration identifier that `SWStartCollaborationAction` provides. Your shared content server is responsible for identity storage and verification of recipient devices.\n\nTo verify a participant, use the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/Identity] [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/Identity\/rootHash] property. A root hash is a secure value your app sends to your server to uniquely identify a participant on their devices. To perform a verification, your server needs to compute a root hash.\n\nWhen the system sends a collaboration message for a participant, it actually sends individual messages to each device for that participant. The Messages app identifies each device using a cryptographic public key. Because the goal is to allow access only on this participant’s set of devices, the system derives the root hash from the set of public keys registered to each recipient.\n\nThe root hash is the root node of a data structure called a *Merkle tree*. A Merkle tree is a binary tree that the system builds by performing a sequence of hashing operations. To derive an identity for the participant based on their public keys, the system uses the keys as the *leaves* of this tree. The hashing algorithm that the system uses in the Merkle tree ensures that the system can only compute the root node from that set of keys.\n\nIn the example below, the user has three devices and three public keys. The keys are unique for each collaboration identifier that your app provides, using a process called key diversification. To prevent tracking the number of devices registered to a user, the system pads the set with random keys up to a fixed size. Your server hashes the padded set of diversified keys to create the leaf nodes of the tree with a SHA-256 algorithm.\n\n\n\nYour server then concatenates and hashes each pair of leaf nodes to derive their predecessor nodes. Repeat this process with the predecessor nodes until a single root node remains. This is the root hash that the system uses to uniquely represent this recipient’s identity across their devices.\n\nThe figure below shows that it’s possible to generate a root hash using a subset of the nodes from a complete Merkle tree. Your server can use the hashes H4, H7, and H11, along with the diversified public key P3, to reproduce the root hash in this tree. First, hash the public key to get the missing leaf node H3. Then use H3 and H4 to generate H8. Next, use the given H7 node with H8 to generate H10. Finally, use H10 and H11 to produce the root hash.\n\n\n\nIt’s important to note that you can prove the system uses the public key P3 to generate a given root hash, without needing to reconstruct the entire tree. The subset of nodes necessary to do this is a proof of inclusion. Verification begins when your app opens a universal link. To do this, you first need to check that the link is collaborative.\n\n### Verify a collaboration link\n\n[doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWCollaborationHighlight] represents a collaborative link that your app retrieves from [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightCenter]. Use that collaboration highlight to generate the proof of inclusion. To represent a proof of inclusion, use [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/IdentityProof]. To perform verification, first generate this object along with a cryptographic signature to send to your server. Retrieve the proof using the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightCenter\/getSignedIdentityProof(for:using:completionHandler:)] method on `SWHighlightCenter`.\n\nUse the signature to ensure that a bad actor can’t send the request to gain access to your collaboration. The data can be a challenge you request from your server, or a nonce that the device generates. The example below uses the challenge approach.\n\nThe system passes the URL, which is the universal link associated with a collaboration, to [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)]. Use this URL to fetch the associated `SWCollaborationHighlight` from the `SWHighlightCenter`.\n\nRequest the challenge from the server, and pass the returned data to the `getSignedIdentityProof` method on `SWHighlightCenter`, along with the highlight. This method returns a signed identity proof that the app sends to the server for verification.\n\nThe app sends the proof to the server, along with the public key and the signed data. Your app signs the data using the Elliptic Curve Digital Signature Algorithm over the P-256 elliptic curve. Verify the signature on the data using the public key in the identity proof. You can do this with most common encryption libraries.\n\n```swift\n\/\/ Retrieve a signed identity proof for a highlight.\n\nfunc application(_ app: UIApplication, open url: URL, \n               options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let challengeRequest = APIRequest.GetChallengeData()\n    Task {\n        do {\n            let highlight = try highlightCenter.collaborationHighlight(for: url)\n            let challenge = try await apiController.send(request: challengeRequest)\n            let proof = try await highlightCenter.getSignedIdentityProof(for: highlight, \n                                                                       using: challenge.data)\n    let proofOfInclusionRequest = APIRequest.SubmitProofOfInclusion(for: proof)\n            let result = try await apiController.send(request: proofOfInclusionRequest)\n            documentController.update(currentDocument, with: result)\n        } catch {\n            Log.error(\"Caught an error while generating the proof of inclusion: \\(error)\")\n        }\n    }\n}\n```\n\nAfter you verify the signature, you can trust that the identity proof the system sends is from the device associated with that public key. Next, use the identity proof to recompute the root hash. A recursive algorithm works well with tree data structures, as in the code example below:\n\n```swift\n\/\/ Recursive code for root hash generation.\n\nfunc generateRootHashFromArray(localHash: SHA256Digest, inclusionHashes: [SHA256Digest], \n                       publicKeyIndex: Int) -> SHA256Digest {\n    guard let firstHash = inclusionHashes.first else { return localHash }\n    \/\/ Check whether the node is the left or the right successor.\n    let isLeft = publicKeyIndex.isMultiple(of: 2)\n    \/\/ Calculate the combined hash.\n    var rootHash: SHA256Digest\n    if isLeft {\n        rootHash = hash(concatenate([localHash, firstHash]), using: .sha256)\n    } else {\n        rootHash = hash(concatenate([firstHash, localHash]), using: .sha256)\n    }\n    \/\/ Recursively pass in elements and move up the Merkle tree.\n    let newInclusionHashes = inclusionHashes.dropFirst()\n    rootHash = generateRootHashFromArray(\n        localHash: rootHash,\n        inclusionHashes: Array(newInclusionHashes),\n        publicKeyIndex: (publicKeyIndex \/ 2)\n    )\n    return rootHash\n}\n```\n\nOn the initial invocation, pass in the hash of the public key, the set of inclusion hashes, and the public key index. Next, remove the first inclusion hash. Check the public key index to see whether the key is on the left or the right of its sibling. Concatenate and hash the selected hashes in the correct order. Next, remove the consumed node in the `inclusionHashes` array, and pass the rest to a recursive call to this same function. The public key index then updates so that it’s ready for the next node in the tree.\n\nWith this simple function, you can quickly compute a root hash given an identity proof. The server can check that this generated root hash is in the list of root hashes the owner of the document uploads during sending. The hash is present in the list of known hashes, so the server can grant access to the document.\n\nNext, sign some data and retrieve the proof of inclusion. Send the signed data and proof to your server. Verify the signature on the data. Using the proof of inclusion, generate the root hash. Finally, compare the root hash to the list of known identities associated with that content.\n\n### Add a participant\n\nThe example below shows how to handle the update participants action. First, retrieve the collaboration identifier from the action’s metadata — this is the identifier you supply to the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWAction\/fulfill()] method while handling `SWStartCollaborationAction`.\n\nNext, use the action’s [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWUpdateCollaborationParticipantsAction\/addedIdentities] property to retrieve the participant data to store on your content server. Each identity has a [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWPerson\/Identity\/rootHash] property, which is the data you store on your server to validate participants during the collaboration process.\n\nAfter you retrieve this data, create another server request to add the participants to the collaboration with the target identifier. Then, send the request to your server, and fulfill or fail the action. This time, the fulfill method doesn’t take any parameters. After you set up the collaboration, your app has everything it needs to grant immediate access to the recipients of the message.\n\n```swift\n\/\/ Add a participant.\n\nfunc collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWUpdateCollaborationParticipantsAction) {\n    let identifier = action.collaborationMetadata.collaborationIdentifier\n    let participants: [Data] = action.addedIdentities.compactMap { $0.rootHash }\n    let addParticipants = APIRequest.AddParticipants(identifier: identifier, participants)\n    Task {\n        do {            \n            try await apiController.send(request: addParticipants)\n            action.fulfill() \/\/ Sends the URL that the start action provides.\n        } catch {\n            Log.error(\"Caught an error while adding participants to the collaboration: \\(error)\")\n            action.fail() \/\/ Cancels the message.\n        }\n    }\n}\n```\n\n### Remove a participant\n\nTo remove a participant, look up any account associated with a removed identity and revoke their access. If your app doesn’t have any associated accounts for this collaboration, delete the root hash from your database. The example code below uses the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYouCore\/SWUpdateCollaborationParticipantsAction\/removedIdentities] property on the action and passes it to a similar removal API request:\n\n```swift\n\/\/ Remove a participant.\n\nfunc collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWUpdateCollaborationParticipantsAction) {\n    \/\/ This is an example of removing participants only. Handle the added identities here too.\n    let identifier = action.collaborationMetadata.collaborationIdentifier\n    let removed: [Data] = action.removedIdentities.compactMap { $0.rootHash }\n    let removeParticipants = APIRequest.RemoveParticipants(identifier: identifier, removed)\n    Task {\n        do {            \n            try await apiController.send(request: removeParticipants)\n            action.fulfill()\n        } catch {\n            log.error(\"Caught an error while adding participants to the collaboration: \\(error)\")\n            action.fail()\n        }\n    }\n}\n```\n\n### Post a change event notice\n\nWhen a participant makes changes to a collaboration, your app posts notices about those changes. The system displays those notices in Messages as a banner in the shared conversation. The banner includes a description of the changes, as well as the name of the person who makes each change.\n\nYour app posts a change event for content updates or comments, and it posts a membership event when a participant joins or leaves. When a person mentions another person in a collaboration, post a mention event. Post a persistence event when a collaborator moves or deletes content. The example code below shows how to post a change event for an edit to a collaboration:\n\n```swift\n\/\/ Post a change event notice.\n\nfunc postContentEditEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let editEvent = SWHighlightChangeEvent(highlight: highlight, trigger: .edit)\n\n    highlightCenter.postNotice(for: editEvent)\n}\n```\n\n### Post a membership event notice\n\nFor participant changes, your app posts a membership event and passes either the [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightMembershipEventTrigger\/addedCollaborator] or [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightMembershipEventTrigger\/removedCollaborator] trigger type.\n\n```swift\n\/\/ Post a membership event notice.\n\nfunc postMembershipEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let membershipEvent = SWHighlightMembershipEvent(highlight: highlight, trigger: .addCollaborator)\n\n    highlightCenter.postNotice(for: membershipEvent)\n}\n```\n\n### Post a mention event notice\n\nIf your app supports user mentions, you can post a mention event. Initialize a person identity with the root hash of the mentioned user. Next, pass the mentioned identity to [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightMentionEvent] and post the mention event.\n\nThe system shows this notice only to the mentioned user in the Messages app.\n\n```swift\n\/\/ Post a mention event notice.\n\nfunc postMentionEvent(identifier: SWCollaborationIdentifier, mentionedRootHash: Data) throws {\n    let mentionedIdentity = SWPerson.Identity(rootHash: mentionedRootHash)\n\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let mentionEvent = SWHighlightMentionEvent(highlight: highlight,\n                                               mentionedPersonIdentity: mentionedIdentity)\n    highlightCenter.postNotice(for: mentionEvent)\n}\n```\n\n### Post a persistence event notice\n\nYour app posts the persistence event type when a participant moves, renames, or deletes content. In the example below, the app uses [doc:\/\/com.apple.sharedwithyou\/documentation\/SharedWithYou\/SWHighlightPersistenceEventTrigger\/renamed] to indicate that the participant changed the name of the content:\n\n```swift\n\/\/ Post a persistent event notice.\n\nfunc postContentRenamedEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let renamedEvent = SWHighlightPersistenceEvent(highlight: highlight, trigger: .renamed)\n    highlightCenter.postNotice(for: renamedEvent)\n}\n```\n\n## Collaboration\n\n- **Adding shared content collaboration to your app**: Manage shared content collaboration in your app using CloudKit and iCloud Drive.\n- **Collaboration views**: Create and customize a collaboration view to manage the shared content actions.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Manage shared content collaboration in your app using CloudKit and iCloud Drive.",
          "name" : "Adding shared content collaboration to your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SharedWithYou\/adding-shared-content-collaboration-to-your-app"
        },
        {
          "description" : "Create and customize a collaboration view to manage the shared content actions.",
          "name" : "Collaboration views",
          "url" : "https:\/\/developer.apple.com\/documentation\/SharedWithYou\/collaboration-views"
        }
      ],
      "title" : "Collaboration"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding custom collaboration to your app",
  "url" : "https:\/\/developer.apple.com\/documentation\/sharedwithyou\/adding-custom-collaboration-to-your-app"
}