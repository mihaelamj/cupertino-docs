{
  "abstract" : "Maintain game state across multiple players in a race to capture all the coins.",
  "codeExamples" : [
    {
      "code" : "class Game {\n    let tabletopGame: TabletopGame\n    let renderer: GameRenderer\n    let observer: GameObserver\n    let setup: GameSetup\n\n    \/\/...\n}",
      "language" : "swift"
    },
    {
      "code" : "var body: some View {\n    GeometryReader3D { proxy3D in\n        RealityView { (content: inout RealityViewContent) in\n            content.entities.append(volumetricRoot)\n            \/\/ Set the root at the base of the volume.\n            let frame = content.convert(proxy3D.frame(in: .local), from: .local, to: volumetricRoot)\n            volumetricRoot.transform.translation.y = frame.min.y\n            volumetricRoot.addChild(game.renderer.root)\n        }\n    }.toolbar() {\n        GameToolbar(game: game)\n    }.tabletopGame(game.tabletopGame, parent: game.renderer.root) { value in\n        var delegate: GameInteraction?\n\n        if let _ = game.tabletopGame.equipment(of: Log.self, matching: value.startingEquipmentID) {\n            delegate = LogInteraction(game: game)\n        } else if let _ = game.tabletopGame.equipment(of: LilyPad.self, matching: value.startingEquipmentID) {\n            delegate = LilyPadInteraction(game: game)\n        } else if let _ = game.tabletopGame.equipment(of: Player.self, matching: value.startingEquipmentID) {\n            delegate = PlayerInteraction(game: game)\n        } else {\n            delegate = GameInteraction(game: game)\n        }\n\n        return delegate!\n    }.task {\n        activityManager = .init(tabletopGame: game.tabletopGame)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Activity: GroupActivity {\n    var metadata: GroupActivityMetadata {\n        var metadata = GroupActivityMetadata()\n        metadata.type = .generic\n        metadata.title = \"TabletopKitSample\"\n        return metadata\n    }\n}\n\nclass GroupActivityManager: Observable {\n    var tabletopGame: TabletopGame\n    var sessionTask = Task<Void, Never> {}\n\n    init(tabletopGame: TabletopGame) {\n        self.tabletopGame = tabletopGame\n        sessionTask = Task { @MainActor in\n            for await session in Activity.sessions() {\n                tabletopGame.coordinateWithSession(session)\n            }\n        }\n    }\n\n    deinit {\n        tabletopGame.detachNetworkCoordinator()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class GameInteraction: TabletopInteraction.Delegate {\n    let game: Game\n    \n    init(game: Game) {\n        self.game = game\n    }\n    \n    func update(interaction: TabletopKit.TabletopInteraction) {\n\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class PlayerInteraction: GameInteraction {\n    override func update(interaction: TabletopInteraction) {\n        \/\/ A gesture interaction to aim the jump.\n        if interaction.value.gesture != nil || interaction.value.startingEquipmentID != interaction.value.controlledEquipmentID {\n            updateGestureInteraction(interaction: interaction)\n            return\n        }\n        \n        \/\/ A programmatic interaction for the jump after the player releases the aim.\n        updateProgrammaticInteraction(interaction: interaction)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func updateGestureInteraction(interaction: TabletopInteraction) {\n    guard let gesture = interaction.value.gesture else { return }\n    if gesture.phase == .started {\n        guard let player = game.tabletopGame.equipment(matching: interaction.value.startingEquipmentID) as? Player else { return }\n        interaction.setControlledEquipment(matching: .aimingSightID(for: player.seat))\n        return\n    }\n    \/\/...",
      "language" : "swift"
    },
    {
      "code" : "    \/\/...\n    if gesture.phase == .update {\n        \/\/ Update the slingshot visuals while the player is still dragging.\n        game.tabletopGame.withCurrentSnapshot { snapshot in\n            guard let (playerEquip, _) = snapshot.equipment(of: Player.self, matching: interaction.value.startingEquipmentID) else { return }\n            let aimX = interaction.value.pose.position.x\n            let aimZ = interaction.value.pose.position.z\n            let root = game.renderer.root\n            Task { @MainActor in\n                playerEquip.updateAimingVisuals(dragPosition: .init(x: aimX, z: aimZ), root: root)\n            }\n        }\n        return\n    }\n    \/\/...",
      "language" : "swift"
    },
    {
      "code" : "    \/\/...\n    if gesture.phase == .ended {\n        \/\/ When the player releases the aim, hide the aiming visuals and start a programmatic interaction for the jump.\n        game.tabletopGame.withCurrentSnapshot { snapshot in\n            if let (playerEquip, _) = snapshot.equipment(of: Player.self, matching: interaction.value.startingEquipmentID) {\n                Task { @MainActor in\n                    playerEquip.hideAimingVisuals()\n                }\n            }\n            \n            guard let interactionIdentifier = game.tabletopGame.startInteraction(onEquipmentID: interaction.value.startingEquipmentID) else {\n                return\n            }\n            guard let (playerEquip, _) = snapshot.equipment(of: Player.self, matching: interaction.value.startingEquipmentID) else { return }\n            \n            let targetX = interaction.value.pose.position.x\n            let targetZ = interaction.value.pose.position.z\n            let root = game.renderer.root\n            Task { @MainActor in\n                game.programmaticPlayerInteractions[interactionIdentifier] = playerEquip.calcTargetPose(\n                    dragPosition: .init(x: targetX, z: targetZ),\n                    root: root\n                )\n                playerEquip.playJumpAudio()\n            }\n        }\n        return\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func updateProgrammaticInteraction(interaction: TabletopInteraction) {\n    if interaction.value.phase == .started {\n        interaction.setConfiguration(.init(allowedDestinations: .restricted(.allStones + .allLilyPads + .allLogs)))\n        return\n    }\n    \/\/...",
      "language" : "swift"
    },
    {
      "code" : "    \/\/...\n    if interaction.value.phase == .update {\n        guard let targetPose = game.programmaticPlayerInteractions[interaction.value.id] else { return }\n        let oldPose = interaction.value.pose\n        \n        if abs(oldPose.position.x - targetPose.position.x) < 1e-3 && abs(oldPose.position.z - targetPose.position.z) < 1e-3 {\n            if interaction.value.proposedDestination == nil {\n                sinkPlayer(interaction: interaction, targetPose: targetPose)\n                return\n            }\n            interaction.setPose(targetPose)\n            interaction.end()\n            return\n        }\n        movePlayer(interaction: interaction, targetPose: targetPose)\n        return\n    }\n    \/\/...",
      "language" : "swift"
    },
    {
      "code" : "    \/\/...\n    if interaction.value.phase == .ended {\n        endJump(interaction: interaction)\n    }\n}\n\nfunc endJump(interaction: TabletopInteraction) {\n    if let proposedDestination = interaction.value.proposedDestination {\n        \/\/ Move the player to the proposed destination.\n        interaction.addAction(.moveEquipment(matching: interaction.value.controlledEquipmentID,\n                                             childOf: proposedDestination.equipmentID, pose: proposedDestination.pose))\n        \n        \/\/ If the destination is a lily pad, sink it.\n        if game.tabletopGame.equipment(of: LilyPad.self, matching: proposedDestination.equipmentID) != nil {\n            _ = game.tabletopGame.startInteraction(onEquipmentID: proposedDestination.equipmentID)\n        }\n        \n        \/\/ If the destination contains an uncollected coin, collect it.\n        game.tabletopGame.withCurrentSnapshot { snapshot in\n            if let childId = snapshot.equipmentIDs(childrenOf: proposedDestination.equipmentID).first,\n               let coinState = snapshot.state(matching: childId) as? CoinState {\n                if !coinState.collected {\n                    interaction.addAction(CollectCoin(playerId: interaction.value.controlledEquipmentID, coinId: childId))\n                }\n            }\n        }\n        game.programmaticPlayerInteractions.removeValue(forKey: interaction.value.id)\n        return\n    }\n    \/\/...",
      "language" : "swift"
    },
    {
      "code" : "    \/\/ If the player doesn't land on a valid destination, return them to their starting position.\n    let player = game.tabletopGame.equipment(of: Player.self, matching: interaction.value.controlledEquipmentID)!\n    interaction.addAction(.moveEquipment(matching: player.id, childOf: .bankID(for: player.seat), pose: .identity))\n    interaction.addAction(DecrementHealth(playerId: interaction.value.controlledEquipmentID))\n    game.programmaticPlayerInteractions.removeValue(forKey: interaction.value.id)\n}",
      "language" : "swift"
    },
    {
      "code" : "class GameObserver: TabletopGame.Observer {\n    func actionWasConfirmed(_ action: some TabletopAction, oldSnapshot: TableSnapshot, newSnapshot: TableSnapshot) {\n        \n        guard let game else {\n            return\n        }\n        \n        if let resetPlayerAction = ResetPlayer(from: action) {\n            let (equip, state) = newSnapshot.equipment(of: Player.self, matching: [resetPlayerAction.playerId]).first!\n            game.playerStats[equip.seat].health = state.health\n            game.playerStats[equip.seat].coinsCount = state.coinsCount\n            \n            return\n        }\n        \n        if let decrementHealthAction = DecrementHealth(from: action) {\n            let (equip, state) = newSnapshot.equipment(of: Player.self, matching: [decrementHealthAction.playerId]).first!\n            game.playerStats[equip.seat].health = state.health\n            \n            \/\/ Freeze the player when their health equals `0`.\n            if action.playerID == game.tabletopGame.localPlayer.id && state.health == 0 {\n                game.tabletopGame.addAction(FreezePlayer(playerId: equip.id))\n            }\n            \n            return\n        }\n        \n        if let collectCoinAction = CollectCoin(from: action) {\n            let (equip, playerState) = newSnapshot.equipment(of: Player.self, matching: [collectCoinAction.playerId]).first!\n            game.playerStats[equip.seat].coinsCount = playerState.coinsCount\n            \n            return\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "edabb735e579edca919830df8195c610100be94ea75ddc21edc88cde5ddb98a9",
  "crawledAt" : "2025-12-03T07:24:01Z",
  "id" : "3BFB7DD6-CC68-4A98-B35B-0215891E70B5",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "TabletopKit",
  "overview" : "## Overview\n\nThis sample code project demonstrates how to overcome the difficult task of maintaining a multiplayer game’s state in real time. TabletopKit supports automatic game-state synchronization by keeping gameplay items, such as player tokens, dice, coins, and scenery updates — all with positions and actions — in sync during a multiplayer game. TabletopKit also supports many more gameplay styles than the traditional board game layout.\n\n## Set up the app\n\nThe TabletopKit app object creates an instance of the `Game` class, which sets up, observes, and renders the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame] state. `Game` equipment, objects that implement the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/Equipment] protocol, represents all interactive portions of a game. The `Game` class also handles game start and reset, initiating programmatic interactions, and adding equipment reset actions. The `GameSetup` class initializes and positions all game equipment.\n\nThe `GameRenderer` class implements [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/RenderDelegate], which loads assets and communicates when the game needs visual updates. The `GameObserver` class implements [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/Observer] and indicates confirmed gameplay actions. You can define custom actions to modify the game state to your needs. The `CustomAction.swift` file in this sample contains custom actions to reset the players, decrement player health, collect coins, reset coins, sink lily pads, and reset lily pads.\n\nThe `GameView` structure contains the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView], which hosts game content and the toolbar for player interaction, and stores the `Game` object as an environment property. The [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/tabletopGame(_:parent:automaticUpdate:)] modifier connects the `TabletopGame` object to the `RealityView`. The modifier returns the appropriate delegate for the game equipment ID that passes into the update closure. A [doc:\/\/com.apple.documentation\/documentation\/Swift\/Task] creates `GroupActivityManager`, which connects multiple players and provides the `TabletopGame` object.\n\nThe player joins other players by tapping the SharePlay button in the volume’s toolbar. This instantiates an `Activity` object that implements the [doc:\/\/com.apple.documentation\/documentation\/GroupActivities\/GroupActivity] protocol. `Activity` initializes an observable `GroupActivityManager` awaiting `Activity` sessions that coordinate with the provided `TabletopGame`. TabletopKit handles all player connections and synchronization. The app only needs to register its equipment and actions, and then handle their updates.\n\n## Define gameplay\n\nThe game begins when the player taps the Start Game button in the toolbar. This sets the `Game.gameStarted` state to `true` and initiates `Log` entity interactions. Objects that implement the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate] protocol handle all gameplay event updates.\n\n`PlayerInteraction` handles player input by implementing `TabletopInteraction.Delegate`. When the player gazes at a gameplay object and interacts using direct or indirect gestures, the `PlayerInteraction` receives a [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction] object in its [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate\/update(interaction:)] method. TabletopKit supplies an active gesture for the interaction. The sample splits this functionality into two parts — updating based on user gestures and updating due to automatic programmatic interactions.\n\n`PlayerInteraction` calls into `updateGestureInteraction` to handle gesture events. On gesture start, `updateGestureInteraction` sets the `.aimingSightID` for the controlled equipment on the interaction. This allows TabletopKit to manipulate the appropriate equipment entity onscreen.\n\nOn gesture update, `updateGestureInteraction` modifies the local slingshot visuals, matching user input.\n\nOn gesture end, `updateGestureInteraction` calculates the change in gesture position, calls [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/startInteraction(onEquipmentID:)] for the interaction’s equipment, and adds it to the programmatic player interaction dictionary of `Game`. When gesture handling is complete, TabletopKit moves the player’s piece.\n\nNext, `PlayerInteraction.updateProgrammaticInteraction` handles the programmatic interactions of automated equipment. At the beginning of the interaction, it provides the set of available interaction destinations — the stones, lily pads, and logs.\n\nDuring the interaction, the app finds a target programmatic player interaction for the provided interaction ID and sets the target’s position.\n\nAt the end of the interaction, `updateProgrammaticInteraction` calls into `endJump`. Adding a [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/MoveEquipmentAction] object to the active `TabletopInteraction` moves the player. If the target lands on a lily pad, the sample initiates the sinking animation by calling  [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/startInteraction(onEquipmentID:)] with the lily pad’s equipment ID. If the target lands on an allowed destination with a coin, `endJump` adds a `CollectCoin` action to the active `TabletopInteraction`. The app then removes the interaction from the `programmaticPlayerInteractions` dictionary.\n\nFinally, if the landing site isn’t a valid location, `endJump` returns the player to their starting position and decrements their health.\n\nThe `GameObserver` class is responsible for reacting to confirmed game actions. The game decrements a player’s health when the player lands in the water, or if they fail to jump again quickly after landing on a lily pad before it sinks. Within `actionWasConfirmed()`, the game resets the player’s state if the newly provided [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TableSnapshot] matches a `ResetPlayer` action. The actions can have other possible matches, like `DecrementHealth` where the game decrements the player’s health, or `CollectCoin` where the player collects a coin at the player’s new location. The game ends when the players collect all of the coins, or when all of the players run out of lives.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/tabletopkit\/synchronizing-group-gameplay-with-tabletopkit\ncrawled: 2025-12-03T07:24:01Z\n---\n\n# Synchronizing group gameplay with TabletopKit\n\n**Sample Code**\n\nMaintain game state across multiple players in a race to capture all the coins.\n\n## Overview\n\nThis sample code project demonstrates how to overcome the difficult task of maintaining a multiplayer game’s state in real time. TabletopKit supports automatic game-state synchronization by keeping gameplay items, such as player tokens, dice, coins, and scenery updates — all with positions and actions — in sync during a multiplayer game. TabletopKit also supports many more gameplay styles than the traditional board game layout.\n\n\n\n## Set up the app\n\nThe TabletopKit app object creates an instance of the `Game` class, which sets up, observes, and renders the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame] state. `Game` equipment, objects that implement the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/Equipment] protocol, represents all interactive portions of a game. The `Game` class also handles game start and reset, initiating programmatic interactions, and adding equipment reset actions. The `GameSetup` class initializes and positions all game equipment.\n\nThe `GameRenderer` class implements [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/RenderDelegate], which loads assets and communicates when the game needs visual updates. The `GameObserver` class implements [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/Observer] and indicates confirmed gameplay actions. You can define custom actions to modify the game state to your needs. The `CustomAction.swift` file in this sample contains custom actions to reset the players, decrement player health, collect coins, reset coins, sink lily pads, and reset lily pads.\n\n```swift\nclass Game {\n    let tabletopGame: TabletopGame\n    let renderer: GameRenderer\n    let observer: GameObserver\n    let setup: GameSetup\n\n    \/\/...\n}\n```\n\nThe `GameView` structure contains the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView], which hosts game content and the toolbar for player interaction, and stores the `Game` object as an environment property. The [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/tabletopGame(_:parent:automaticUpdate:)] modifier connects the `TabletopGame` object to the `RealityView`. The modifier returns the appropriate delegate for the game equipment ID that passes into the update closure. A [doc:\/\/com.apple.documentation\/documentation\/Swift\/Task] creates `GroupActivityManager`, which connects multiple players and provides the `TabletopGame` object.\n\n```swift\nvar body: some View {\n    GeometryReader3D { proxy3D in\n        RealityView { (content: inout RealityViewContent) in\n            content.entities.append(volumetricRoot)\n            \/\/ Set the root at the base of the volume.\n            let frame = content.convert(proxy3D.frame(in: .local), from: .local, to: volumetricRoot)\n            volumetricRoot.transform.translation.y = frame.min.y\n            volumetricRoot.addChild(game.renderer.root)\n        }\n    }.toolbar() {\n        GameToolbar(game: game)\n    }.tabletopGame(game.tabletopGame, parent: game.renderer.root) { value in\n        var delegate: GameInteraction?\n\n        if let _ = game.tabletopGame.equipment(of: Log.self, matching: value.startingEquipmentID) {\n            delegate = LogInteraction(game: game)\n        } else if let _ = game.tabletopGame.equipment(of: LilyPad.self, matching: value.startingEquipmentID) {\n            delegate = LilyPadInteraction(game: game)\n        } else if let _ = game.tabletopGame.equipment(of: Player.self, matching: value.startingEquipmentID) {\n            delegate = PlayerInteraction(game: game)\n        } else {\n            delegate = GameInteraction(game: game)\n        }\n\n        return delegate!\n    }.task {\n        activityManager = .init(tabletopGame: game.tabletopGame)\n    }\n}\n```\n\nThe player joins other players by tapping the SharePlay button in the volume’s toolbar. This instantiates an `Activity` object that implements the [doc:\/\/com.apple.documentation\/documentation\/GroupActivities\/GroupActivity] protocol. `Activity` initializes an observable `GroupActivityManager` awaiting `Activity` sessions that coordinate with the provided `TabletopGame`. TabletopKit handles all player connections and synchronization. The app only needs to register its equipment and actions, and then handle their updates.\n\n```swift\nstruct Activity: GroupActivity {\n    var metadata: GroupActivityMetadata {\n        var metadata = GroupActivityMetadata()\n        metadata.type = .generic\n        metadata.title = \"TabletopKitSample\"\n        return metadata\n    }\n}\n\nclass GroupActivityManager: Observable {\n    var tabletopGame: TabletopGame\n    var sessionTask = Task<Void, Never> {}\n\n    init(tabletopGame: TabletopGame) {\n        self.tabletopGame = tabletopGame\n        sessionTask = Task { @MainActor in\n            for await session in Activity.sessions() {\n                tabletopGame.coordinateWithSession(session)\n            }\n        }\n    }\n\n    deinit {\n        tabletopGame.detachNetworkCoordinator()\n    }\n}\n```\n\n## Define gameplay\n\nThe game begins when the player taps the Start Game button in the toolbar. This sets the `Game.gameStarted` state to `true` and initiates `Log` entity interactions. Objects that implement the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate] protocol handle all gameplay event updates.\n\n```swift\nclass GameInteraction: TabletopInteraction.Delegate {\n    let game: Game\n    \n    init(game: Game) {\n        self.game = game\n    }\n    \n    func update(interaction: TabletopKit.TabletopInteraction) {\n\n    }\n}\n```\n\n`PlayerInteraction` handles player input by implementing `TabletopInteraction.Delegate`. When the player gazes at a gameplay object and interacts using direct or indirect gestures, the `PlayerInteraction` receives a [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction] object in its [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate\/update(interaction:)] method. TabletopKit supplies an active gesture for the interaction. The sample splits this functionality into two parts — updating based on user gestures and updating due to automatic programmatic interactions.\n\n```swift\nclass PlayerInteraction: GameInteraction {\n    override func update(interaction: TabletopInteraction) {\n        \/\/ A gesture interaction to aim the jump.\n        if interaction.value.gesture != nil || interaction.value.startingEquipmentID != interaction.value.controlledEquipmentID {\n            updateGestureInteraction(interaction: interaction)\n            return\n        }\n        \n        \/\/ A programmatic interaction for the jump after the player releases the aim.\n        updateProgrammaticInteraction(interaction: interaction)\n    }\n}\n```\n\n`PlayerInteraction` calls into `updateGestureInteraction` to handle gesture events. On gesture start, `updateGestureInteraction` sets the `.aimingSightID` for the controlled equipment on the interaction. This allows TabletopKit to manipulate the appropriate equipment entity onscreen.\n\n```swift\nfunc updateGestureInteraction(interaction: TabletopInteraction) {\n    guard let gesture = interaction.value.gesture else { return }\n    if gesture.phase == .started {\n        guard let player = game.tabletopGame.equipment(matching: interaction.value.startingEquipmentID) as? Player else { return }\n        interaction.setControlledEquipment(matching: .aimingSightID(for: player.seat))\n        return\n    }\n    \/\/...\n```\n\nOn gesture update, `updateGestureInteraction` modifies the local slingshot visuals, matching user input.\n\n```swift\n    \/\/...\n    if gesture.phase == .update {\n        \/\/ Update the slingshot visuals while the player is still dragging.\n        game.tabletopGame.withCurrentSnapshot { snapshot in\n            guard let (playerEquip, _) = snapshot.equipment(of: Player.self, matching: interaction.value.startingEquipmentID) else { return }\n            let aimX = interaction.value.pose.position.x\n            let aimZ = interaction.value.pose.position.z\n            let root = game.renderer.root\n            Task { @MainActor in\n                playerEquip.updateAimingVisuals(dragPosition: .init(x: aimX, z: aimZ), root: root)\n            }\n        }\n        return\n    }\n    \/\/...\n```\n\nOn gesture end, `updateGestureInteraction` calculates the change in gesture position, calls [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/startInteraction(onEquipmentID:)] for the interaction’s equipment, and adds it to the programmatic player interaction dictionary of `Game`. When gesture handling is complete, TabletopKit moves the player’s piece.\n\n```swift\n    \/\/...\n    if gesture.phase == .ended {\n        \/\/ When the player releases the aim, hide the aiming visuals and start a programmatic interaction for the jump.\n        game.tabletopGame.withCurrentSnapshot { snapshot in\n            if let (playerEquip, _) = snapshot.equipment(of: Player.self, matching: interaction.value.startingEquipmentID) {\n                Task { @MainActor in\n                    playerEquip.hideAimingVisuals()\n                }\n            }\n            \n            guard let interactionIdentifier = game.tabletopGame.startInteraction(onEquipmentID: interaction.value.startingEquipmentID) else {\n                return\n            }\n            guard let (playerEquip, _) = snapshot.equipment(of: Player.self, matching: interaction.value.startingEquipmentID) else { return }\n            \n            let targetX = interaction.value.pose.position.x\n            let targetZ = interaction.value.pose.position.z\n            let root = game.renderer.root\n            Task { @MainActor in\n                game.programmaticPlayerInteractions[interactionIdentifier] = playerEquip.calcTargetPose(\n                    dragPosition: .init(x: targetX, z: targetZ),\n                    root: root\n                )\n                playerEquip.playJumpAudio()\n            }\n        }\n        return\n    }\n}\n```\n\nNext, `PlayerInteraction.updateProgrammaticInteraction` handles the programmatic interactions of automated equipment. At the beginning of the interaction, it provides the set of available interaction destinations — the stones, lily pads, and logs.\n\n```swift\nfunc updateProgrammaticInteraction(interaction: TabletopInteraction) {\n    if interaction.value.phase == .started {\n        interaction.setConfiguration(.init(allowedDestinations: .restricted(.allStones + .allLilyPads + .allLogs)))\n        return\n    }\n    \/\/...\n```\n\nDuring the interaction, the app finds a target programmatic player interaction for the provided interaction ID and sets the target’s position.\n\n```swift\n    \/\/...\n    if interaction.value.phase == .update {\n        guard let targetPose = game.programmaticPlayerInteractions[interaction.value.id] else { return }\n        let oldPose = interaction.value.pose\n        \n        if abs(oldPose.position.x - targetPose.position.x) < 1e-3 && abs(oldPose.position.z - targetPose.position.z) < 1e-3 {\n            if interaction.value.proposedDestination == nil {\n                sinkPlayer(interaction: interaction, targetPose: targetPose)\n                return\n            }\n            interaction.setPose(targetPose)\n            interaction.end()\n            return\n        }\n        movePlayer(interaction: interaction, targetPose: targetPose)\n        return\n    }\n    \/\/...\n```\n\nAt the end of the interaction, `updateProgrammaticInteraction` calls into `endJump`. Adding a [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/MoveEquipmentAction] object to the active `TabletopInteraction` moves the player. If the target lands on a lily pad, the sample initiates the sinking animation by calling  [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopGame\/startInteraction(onEquipmentID:)] with the lily pad’s equipment ID. If the target lands on an allowed destination with a coin, `endJump` adds a `CollectCoin` action to the active `TabletopInteraction`. The app then removes the interaction from the `programmaticPlayerInteractions` dictionary.\n\n```swift\n    \/\/...\n    if interaction.value.phase == .ended {\n        endJump(interaction: interaction)\n    }\n}\n\nfunc endJump(interaction: TabletopInteraction) {\n    if let proposedDestination = interaction.value.proposedDestination {\n        \/\/ Move the player to the proposed destination.\n        interaction.addAction(.moveEquipment(matching: interaction.value.controlledEquipmentID,\n                                             childOf: proposedDestination.equipmentID, pose: proposedDestination.pose))\n        \n        \/\/ If the destination is a lily pad, sink it.\n        if game.tabletopGame.equipment(of: LilyPad.self, matching: proposedDestination.equipmentID) != nil {\n            _ = game.tabletopGame.startInteraction(onEquipmentID: proposedDestination.equipmentID)\n        }\n        \n        \/\/ If the destination contains an uncollected coin, collect it.\n        game.tabletopGame.withCurrentSnapshot { snapshot in\n            if let childId = snapshot.equipmentIDs(childrenOf: proposedDestination.equipmentID).first,\n               let coinState = snapshot.state(matching: childId) as? CoinState {\n                if !coinState.collected {\n                    interaction.addAction(CollectCoin(playerId: interaction.value.controlledEquipmentID, coinId: childId))\n                }\n            }\n        }\n        game.programmaticPlayerInteractions.removeValue(forKey: interaction.value.id)\n        return\n    }\n    \/\/...\n```\n\nFinally, if the landing site isn’t a valid location, `endJump` returns the player to their starting position and decrements their health.\n\n```swift\n    \/\/ If the player doesn't land on a valid destination, return them to their starting position.\n    let player = game.tabletopGame.equipment(of: Player.self, matching: interaction.value.controlledEquipmentID)!\n    interaction.addAction(.moveEquipment(matching: player.id, childOf: .bankID(for: player.seat), pose: .identity))\n    interaction.addAction(DecrementHealth(playerId: interaction.value.controlledEquipmentID))\n    game.programmaticPlayerInteractions.removeValue(forKey: interaction.value.id)\n}\n```\n\nThe `GameObserver` class is responsible for reacting to confirmed game actions. The game decrements a player’s health when the player lands in the water, or if they fail to jump again quickly after landing on a lily pad before it sinks. Within `actionWasConfirmed()`, the game resets the player’s state if the newly provided [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TableSnapshot] matches a `ResetPlayer` action. The actions can have other possible matches, like `DecrementHealth` where the game decrements the player’s health, or `CollectCoin` where the player collects a coin at the player’s new location. The game ends when the players collect all of the coins, or when all of the players run out of lives.\n\n```swift\nclass GameObserver: TabletopGame.Observer {\n    func actionWasConfirmed(_ action: some TabletopAction, oldSnapshot: TableSnapshot, newSnapshot: TableSnapshot) {\n        \n        guard let game else {\n            return\n        }\n        \n        if let resetPlayerAction = ResetPlayer(from: action) {\n            let (equip, state) = newSnapshot.equipment(of: Player.self, matching: [resetPlayerAction.playerId]).first!\n            game.playerStats[equip.seat].health = state.health\n            game.playerStats[equip.seat].coinsCount = state.coinsCount\n            \n            return\n        }\n        \n        if let decrementHealthAction = DecrementHealth(from: action) {\n            let (equip, state) = newSnapshot.equipment(of: Player.self, matching: [decrementHealthAction.playerId]).first!\n            game.playerStats[equip.seat].health = state.health\n            \n            \/\/ Freeze the player when their health equals `0`.\n            if action.playerID == game.tabletopGame.localPlayer.id && state.health == 0 {\n                game.tabletopGame.addAction(FreezePlayer(playerId: equip.id))\n            }\n            \n            return\n        }\n        \n        if let collectCoinAction = CollectCoin(from: action) {\n            let (equip, playerState) = newSnapshot.equipment(of: Player.self, matching: [collectCoinAction.playerId]).first!\n            game.playerStats[equip.seat].coinsCount = playerState.coinsCount\n            \n            return\n        }\n    }\n}\n```\n\n## Essentials\n\n- **Creating tabletop games**: Develop a spatial board game where multiple players interact with pieces on a table.\n- **TabletopGame**: An object that manages the setup and gameplay of a tabletop game.\n- **TableSetup**: An object that represents the arrangement of seats, equipment, and counters around the game table.\n- **Tabletop**: A protocol for the table surface in your game.\n- **EntityTabletop**: A protocol for the table surface in your game when you render it using RealityKit.\n- **TabletopShape**: An object that represents the physical properties of the table.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Develop a spatial board game where multiple players interact with pieces on a table.",
          "name" : "Creating tabletop games",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/creating-tabletop-games"
        },
        {
          "description" : "An object that manages the setup and gameplay of a tabletop game.",
          "name" : "TabletopGame",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TabletopGame"
        },
        {
          "description" : "An object that represents the arrangement of seats, equipment, and counters around the game table.",
          "name" : "TableSetup",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TableSetup"
        },
        {
          "description" : "A protocol for the table surface in your game.",
          "name" : "Tabletop",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/Tabletop"
        },
        {
          "description" : "A protocol for the table surface in your game when you render it using RealityKit.",
          "name" : "EntityTabletop",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/EntityTabletop"
        },
        {
          "description" : "An object that represents the physical properties of the table.",
          "name" : "TabletopShape",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TabletopShape"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Synchronizing group gameplay with TabletopKit",
  "url" : "https:\/\/developer.apple.com\/documentation\/tabletopkit\/synchronizing-group-gameplay-with-tabletopkit"
}