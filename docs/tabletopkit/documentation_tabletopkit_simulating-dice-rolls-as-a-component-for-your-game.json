{
  "abstract" : "Create a physically realistic dice game by adding interactive rolling and scoring.",
  "codeExamples" : [
    {
      "code" : "let customOctahedronFaceMap: FaceMap<TossableRepresentation.OctahedronFace> = [\n    .a: 1,\n    .b: 5,\n    .c: 10,\n    .d: 15,\n    .e: 20,\n    .f: 25,\n    .g: 30,\n    .h: 35\n]",
      "language" : "swift"
    },
    {
      "code" : "func customOctahedronDie(index: Int, height: Float = 0.02) -> Die {\n    Die(index: index,\n        entityName: \"dice\/D8_customFaces\",\n        representation: TossableRepresentation.octahedron(height: height),\n        faceMap: customOctahedronFaceMap)\n}",
      "language" : "swift"
    },
    {
      "code" : "func calculateScore(for state: RawValueState) -> Int {\n    guard let currentFace = faceType.init(rawValue: state.rawValue) else {\n        fatalError(\"Invalid rawValue in state\")\n    }\n    \n    guard let score = faceMap.value(for: currentFace) else {\n        fatalError(\"Wrong face map used for this die\")\n    }\n    return score\n}",
      "language" : "swift"
    },
    {
      "code" : "var setup = TableSetup(tabletop: tabletop)\nsetup.add(seat: PlayerSeat(index: 0, position: .init(x: 0, z: +0.5), rotation: .init(degrees: 0)))\nsetup.add(equipment: tetrahedronDie(index: 1))\nsetup.add(equipment: cubeDie(index: 2))\nsetup.add(equipment: octahedronDie(index: 3))\nsetup.add(equipment: customOctahedronDie(index: 4))\nsetup.add(equipment: decahedronDie(index: 5))\nsetup.add(equipment: dodecahedronDie(index: 6))\nsetup.add(equipment: icosahedronDie(index: 7))\n\ntabletopGame = TabletopGame(tableSetup: setup)\ntabletopGame.claimAnySeat()",
      "language" : "swift"
    },
    {
      "code" : "case .started:\n    \/\/\/ Group the dice together when the person selects \"Toss All\".\n    for (index, die) in extraDiceToToss.enumerated() {\n        interaction.addAction(.moveEquipment(die,\n                                             childOf: controlledDie,\n                                             pose: hexagonPoses[index]))\n    }",
      "language" : "swift"
    },
    {
      "code" : "case .update:\n    \/\/\/ Run the tossing simulation when the player releases the dice.\n    if interaction.value.gesture?.phase == .ended {\n        interaction.toss(equipmentID: controlledDie.id,\n                         as: controlledDie.tossableRepresentation)\n        \n        for die in extraDiceToToss {\n            interaction.toss(equipmentID: die.id,\n                             as: die.tossableRepresentation)\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "case .ended:\n    \/\/\/ Calculate and store the result.\n    if interaction.value.phase == .ended {\n        game.updateLastRollScore(for: [controlledDie] + extraDiceToToss)\n    }",
      "language" : "swift"
    },
    {
      "code" : "func onTossStart(interaction: TabletopInteraction,\n                 outcomes: [TabletopInteraction.TossOutcome]) {\n    \n    let allTossedDice = [controlledDie] + extraDiceToToss\n    \n    for outcome in outcomes {\n        guard let die = allTossedDice.first(where: { $0.id == outcome.id }) else {\n            fatalError(\"Outcome ID does not match any tossed dice\")\n        }\n        \n        let face = if predeterminedOutcome {\n            die.faceWithHighestScore()\n        } else {\n            \/\/ Roll the score that the physics simulation determines.\n            outcome.tossableRepresentation.face(for: outcome.restingOrientation)\n        }\n        \n        \/\/ Set the new final pose and score on the die.\n        interaction.addAction(.updateEquipment(die,\n                                               rawValue: face.rawValue,\n                                               pose: outcome.pose))\n\n        if die.id != controlledDie.id {\n            \/\/ If this was one of the extra dice, ensure that its pose is\n            \/\/ back in table space.\n            interaction.addAction(.moveEquipment(matching: die.id,\n                                                 childOf: .tableID))\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func updateLastRollScore(for tossedDice: [Die]) {\n    tabletopGame.withCurrentSnapshot { snapshot in\n        var score = 0\n        for die in tossedDice {\n            score += die.calculateScore(for: snapshot.state(for: die))\n        }\n        lastRollScore = score\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "f297429d803e463a4af37e4f80a74971602385801505ff1d4c1509fb7a49993c",
  "crawledAt" : "2025-12-02T15:48:39Z",
  "id" : "5C171A1F-0DC8-49FA-AED7-CA4F015BFCA2",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "TabletopKit",
  "overview" : "## Overview\n\nWhen reproducing the physicality of a game — whether it’s a role-playing game or a boardgame — one key component is how you add realistic dice rolls to your game. When a player interacts with a die, the interaction feels natural as they lift, rotate, toss, and observe each die land on the appropriate face.\n\nThis sample code app showcases physics-driven dice simulation with realistic tossing mechanics, rotation handling, and score calculation across multiple dice types with various sides. The API gives you the ability to toss the dice and let the physics simulation handle deciding the final pose and resting orientation. It helps you:\n\n\n\nThe app provides a tabletop gaming experience in a volumetric window that allows a player to toss an individual die or a group of dice. After tossing an individual or group of dice, the sample shows the total score.\n\n## Create a die with face mapping\n\nBefore creating the representation of dice with `TabletopKit`, the sample app includes corresponding `USDZ` files for each of the dice in the `RealityKit` content bundle, including a custom 8-sided die, shown here:\n\n\n\nThe face mapping system allows you to assign custom values to each face of a die. The sample includes standard sequential mappings for most dice, but also demonstrates custom scoring with a custom 8-sided die:\n\nThe sample creates different types of dice by using [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TossableRepresentation]. Each die type uses a specific geometric representation — like an octahedron with eight sides — and face mapping that determines the score value of each face on the die:\n\nEach die implements the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/EntityEquipment] protocol and includes methods for calculating scores, determining resting orientations, and finding the highest-scoring face. The `Die` class encapsulates the 3D model entity, tossable representation, and the face mapping for the die. After a toss ends, the sample calls `calculateScore(for:)` to get the score for the die state:\n\n## Configure the game\n\nThe game configuration involves setting up the tabletop environment and adding seven dice to the table. The `Game` class manages the overall game state and coordinates between TabletopKit and the UI:\n\nThe app uses a volumetric window style with a 2 x 2 x 2 meter default size to provide adequate space for dice interaction. The `RoundTabletop` provides the surface for dice physics simulation. The game automatically positions the table within the volumetric space, ensuring that the table surface aligns with the bottom of the volume and the closest edge stays against the front boundary so it remains close to the player interacting with the dice. When the player tosses the dice at the boundary, they bounce off of the volume bounds and back onto the table surface.\n\n## Handle the dice interaction\n\nThe sample app manages dice interaction through the `DiceInteraction` class, which implements [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate]. The interaction system supports both single die tossing and group tossing, where multiple dice move together and get tossed simultaneously. The sample uses a hexagonal positioning pattern to ensure dice don’t overlap during group interactions.\n\nThe `controlledDie` is a single die that the player interacts with in the sample app. When the interaction begins with a die, and the “Toss all” option is in a selected state, the system sets up additional dice for tossing them as a group with the controlled die:\n\nThe sample app monitors gesture completion and initiates the toss when the player releases the dice:\n\nAfter the player completes their toss, the system calculates and updates the final score:\n\n## Process the dice toss and score\n\nThe sample includes toggle controls for testing different scenarios:\n\nThe physics simulation provides realistic dice behavior including rotation, bouncing, and the dice settling into their final positions. The toss outcome processing occurs in the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate\/onTossStart(interaction:outcomes:)] method, where the sample processes the physics simulation and final die states. When determining the outcome, the sample uses `predeterminedOutcome` to get the highest score for the toss. If the player didn’t select the option for the highest score, the sample calls the function [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TossableRepresentation\/face(for:)] to get the die face for the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/TossOutcome]:\n\nScore calculation uses the face mapping system to determine point values for each die. The game tracks the total score by summing individual die scores and displays the result in the interface:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/TabletopKit\/simulating-dice-rolls-as-a-component-for-your-game\ncrawled: 2025-12-02T15:48:39Z\n---\n\n# Simulating dice rolls as a component for your game\n\n**Sample Code**\n\nCreate a physically realistic dice game by adding interactive rolling and scoring.\n\n## Overview\n\nWhen reproducing the physicality of a game — whether it’s a role-playing game or a boardgame — one key component is how you add realistic dice rolls to your game. When a player interacts with a die, the interaction feels natural as they lift, rotate, toss, and observe each die land on the appropriate face.\n\nThis sample code app showcases physics-driven dice simulation with realistic tossing mechanics, rotation handling, and score calculation across multiple dice types with various sides. The API gives you the ability to toss the dice and let the physics simulation handle deciding the final pose and resting orientation. It helps you:\n\n- Determine what face a die lands on naturally.\n- Interact with the dice, like lifting and rotating a die.\n- Produce outcomes for all of the dice thrown for a particular roll.\n- Convert between the logical face of a die and the corresponding resting orientation.\n\n\n\nThe app provides a tabletop gaming experience in a volumetric window that allows a player to toss an individual die or a group of dice. After tossing an individual or group of dice, the sample shows the total score.\n\n## Create a die with face mapping\n\nBefore creating the representation of dice with `TabletopKit`, the sample app includes corresponding `USDZ` files for each of the dice in the `RealityKit` content bundle, including a custom 8-sided die, shown here:\n\n\n\nThe face mapping system allows you to assign custom values to each face of a die. The sample includes standard sequential mappings for most dice, but also demonstrates custom scoring with a custom 8-sided die:\n\n```swift\nlet customOctahedronFaceMap: FaceMap<TossableRepresentation.OctahedronFace> = [\n    .a: 1,\n    .b: 5,\n    .c: 10,\n    .d: 15,\n    .e: 20,\n    .f: 25,\n    .g: 30,\n    .h: 35\n]\n```\n\nThe sample creates different types of dice by using [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TossableRepresentation]. Each die type uses a specific geometric representation — like an octahedron with eight sides — and face mapping that determines the score value of each face on the die:\n\n```swift\nfunc customOctahedronDie(index: Int, height: Float = 0.02) -> Die {\n    Die(index: index,\n        entityName: \"dice\/D8_customFaces\",\n        representation: TossableRepresentation.octahedron(height: height),\n        faceMap: customOctahedronFaceMap)\n}\n```\n\nEach die implements the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/EntityEquipment] protocol and includes methods for calculating scores, determining resting orientations, and finding the highest-scoring face. The `Die` class encapsulates the 3D model entity, tossable representation, and the face mapping for the die. After a toss ends, the sample calls `calculateScore(for:)` to get the score for the die state:\n\n```swift\nfunc calculateScore(for state: RawValueState) -> Int {\n    guard let currentFace = faceType.init(rawValue: state.rawValue) else {\n        fatalError(\"Invalid rawValue in state\")\n    }\n    \n    guard let score = faceMap.value(for: currentFace) else {\n        fatalError(\"Wrong face map used for this die\")\n    }\n    return score\n}\n```\n\n## Configure the game\n\nThe game configuration involves setting up the tabletop environment and adding seven dice to the table. The `Game` class manages the overall game state and coordinates between TabletopKit and the UI:\n\n```swift\nvar setup = TableSetup(tabletop: tabletop)\nsetup.add(seat: PlayerSeat(index: 0, position: .init(x: 0, z: +0.5), rotation: .init(degrees: 0)))\nsetup.add(equipment: tetrahedronDie(index: 1))\nsetup.add(equipment: cubeDie(index: 2))\nsetup.add(equipment: octahedronDie(index: 3))\nsetup.add(equipment: customOctahedronDie(index: 4))\nsetup.add(equipment: decahedronDie(index: 5))\nsetup.add(equipment: dodecahedronDie(index: 6))\nsetup.add(equipment: icosahedronDie(index: 7))\n\ntabletopGame = TabletopGame(tableSetup: setup)\ntabletopGame.claimAnySeat()\n```\n\nThe app uses a volumetric window style with a 2 x 2 x 2 meter default size to provide adequate space for dice interaction. The `RoundTabletop` provides the surface for dice physics simulation. The game automatically positions the table within the volumetric space, ensuring that the table surface aligns with the bottom of the volume and the closest edge stays against the front boundary so it remains close to the player interacting with the dice. When the player tosses the dice at the boundary, they bounce off of the volume bounds and back onto the table surface.\n\n## Handle the dice interaction\n\nThe sample app manages dice interaction through the `DiceInteraction` class, which implements [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate]. The interaction system supports both single die tossing and group tossing, where multiple dice move together and get tossed simultaneously. The sample uses a hexagonal positioning pattern to ensure dice don’t overlap during group interactions.\n\nThe `controlledDie` is a single die that the player interacts with in the sample app. When the interaction begins with a die, and the “Toss all” option is in a selected state, the system sets up additional dice for tossing them as a group with the controlled die:\n\n```swift\ncase .started:\n    \/\/\/ Group the dice together when the person selects \"Toss All\".\n    for (index, die) in extraDiceToToss.enumerated() {\n        interaction.addAction(.moveEquipment(die,\n                                             childOf: controlledDie,\n                                             pose: hexagonPoses[index]))\n    }\n```\n\nThe sample app monitors gesture completion and initiates the toss when the player releases the dice:\n\n```swift\ncase .update:\n    \/\/\/ Run the tossing simulation when the player releases the dice.\n    if interaction.value.gesture?.phase == .ended {\n        interaction.toss(equipmentID: controlledDie.id,\n                         as: controlledDie.tossableRepresentation)\n        \n        for die in extraDiceToToss {\n            interaction.toss(equipmentID: die.id,\n                             as: die.tossableRepresentation)\n        }\n    }\n```\n\nAfter the player completes their toss, the system calculates and updates the final score:\n\n```swift\ncase .ended:\n    \/\/\/ Calculate and store the result.\n    if interaction.value.phase == .ended {\n        game.updateLastRollScore(for: [controlledDie] + extraDiceToToss)\n    }\n```\n\n## Process the dice toss and score\n\nThe sample includes toggle controls for testing different scenarios:\n\n\n\nThe physics simulation provides realistic dice behavior including rotation, bouncing, and the dice settling into their final positions. The toss outcome processing occurs in the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/Delegate\/onTossStart(interaction:outcomes:)] method, where the sample processes the physics simulation and final die states. When determining the outcome, the sample uses `predeterminedOutcome` to get the highest score for the toss. If the player didn’t select the option for the highest score, the sample calls the function [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TossableRepresentation\/face(for:)] to get the die face for the [doc:\/\/com.apple.tabletopkit\/documentation\/TabletopKit\/TabletopInteraction\/TossOutcome]:\n\n```swift\nfunc onTossStart(interaction: TabletopInteraction,\n                 outcomes: [TabletopInteraction.TossOutcome]) {\n    \n    let allTossedDice = [controlledDie] + extraDiceToToss\n    \n    for outcome in outcomes {\n        guard let die = allTossedDice.first(where: { $0.id == outcome.id }) else {\n            fatalError(\"Outcome ID does not match any tossed dice\")\n        }\n        \n        let face = if predeterminedOutcome {\n            die.faceWithHighestScore()\n        } else {\n            \/\/ Roll the score that the physics simulation determines.\n            outcome.tossableRepresentation.face(for: outcome.restingOrientation)\n        }\n        \n        \/\/ Set the new final pose and score on the die.\n        interaction.addAction(.updateEquipment(die,\n                                               rawValue: face.rawValue,\n                                               pose: outcome.pose))\n\n        if die.id != controlledDie.id {\n            \/\/ If this was one of the extra dice, ensure that its pose is\n            \/\/ back in table space.\n            interaction.addAction(.moveEquipment(matching: die.id,\n                                                 childOf: .tableID))\n        }\n    }\n}\n```\n\nScore calculation uses the face mapping system to determine point values for each die. The game tracks the total score by summing individual die scores and displays the result in the interface:\n\n```swift\nfunc updateLastRollScore(for tossedDice: [Die]) {\n    tabletopGame.withCurrentSnapshot { snapshot in\n        var score = 0\n        for die in tossedDice {\n            score += die.calculateScore(for: snapshot.state(for: die))\n        }\n        lastRollScore = score\n    }\n}\n```\n\n## Interactions\n\n- **TabletopInteraction**: A protocol for objects that manage the entire flow of players interacting with equipment.\n- **TossableRepresentation**: An object that represents geometric shapes that the player can throw during gameplay, such as dice.\n- **TableSnapshot**: A snapshot of the current state of the table.\n- **TableVisualState**: A structure that represents the appearance of an object on the table.\n- **TableCursor**: A cursor conveys information about one equipment that is currently being controlled by an interaction.\n- **TableCursorIdentifier**: A unique identifier for cursors.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A protocol for objects that manage the entire flow of players interacting with equipment.",
          "name" : "TabletopInteraction",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TabletopInteraction"
        },
        {
          "description" : "An object that represents geometric shapes that the player can throw during gameplay, such as dice.",
          "name" : "TossableRepresentation",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TossableRepresentation"
        },
        {
          "description" : "A snapshot of the current state of the table.",
          "name" : "TableSnapshot",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TableSnapshot"
        },
        {
          "description" : "A structure that represents the appearance of an object on the table.",
          "name" : "TableVisualState",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TableVisualState"
        },
        {
          "description" : "A cursor conveys information about one equipment that is currently being controlled by an interaction.",
          "name" : "TableCursor",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TableCursor"
        },
        {
          "description" : "A unique identifier for cursors.",
          "name" : "TableCursorIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/TableCursorIdentifier"
        }
      ],
      "title" : "Interactions"
    }
  ],
  "source" : "appleJSON",
  "title" : "Simulating dice rolls as a component for your game",
  "url" : "https:\/\/developer.apple.com\/documentation\/TabletopKit\/simulating-dice-rolls-as-a-component-for-your-game"
}