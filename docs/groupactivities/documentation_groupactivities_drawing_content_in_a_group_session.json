{
  "abstract" : "Invite your friends to draw on a shared canvas while on a FaceTime call.",
  "codeExamples" : [
    {
      "code" : "struct DrawTogether: GroupActivity {\n    var metadata: GroupActivityMetadata {\n        var metadata = GroupActivityMetadata()\n        metadata.title = NSLocalizedString(\"Draw Together\", comment: \"Title of group activity\")\n        metadata.type = .generic\n        return metadata\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "if canvas.groupSession == nil && groupStateObserver.isEligibleForGroupSession {\n    Button {\n        canvas.startSharing()\n    } label: {\n        Image(systemName: \"person.2.fill\")\n    }\n    .buttonStyle(.borderedProminent)\n}",
      "language" : "swift"
    },
    {
      "code" : "func startSharing() {\n    Task {\n        do {\n            _ = try await DrawTogether().activate()\n        } catch {\n            print(\"Failed to activate DrawTogether activity: \\(error)\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func configureGroupSession(_ groupSession: GroupSession<DrawTogether>) {\n    strokes = []\n\n    self.groupSession = groupSession\n    let messenger = GroupSessionMessenger(session: groupSession)\n    self.messenger = messenger",
      "language" : "swift"
    },
    {
      "code" : "struct UpsertStrokeMessage: Codable {\n    let id: UUID\n    let color: Stroke.Color\n    let point: CGPoint\n}",
      "language" : "swift"
    },
    {
      "code" : "for await (message, _) in messenger.messages(of: UpsertStrokeMessage.self) {\n    handle(message)\n}",
      "language" : "swift"
    },
    {
      "code" : "try? await messenger.send(UpsertStrokeMessage(id: stroke.id, color: stroke.color, point: point))",
      "language" : "swift"
    },
    {
      "code" : "var task = Task {\n    for await (message, _) in messenger.messages(of: UpsertStrokeMessage.self) {\n        handle(message)\n    }\n}\ntasks.insert(task)",
      "language" : "swift"
    },
    {
      "code" : "func handle(_ message: UpsertStrokeMessage) {\n    if let stroke = strokes.first(where: { $0.id == message.id }) {\n        stroke.points.append(message.point)\n    } else {\n        let stroke = Stroke(id: message.id, color: message.color)\n        stroke.points.append(message.point)\n        strokes.append(stroke)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func addPointToActiveStroke(_ point: CGPoint) {\n    let stroke: Stroke\n    if let activeStroke = activeStroke {\n        stroke = activeStroke\n    } else {\n        stroke = Stroke(color: strokeColor)\n        activeStroke = stroke\n    }\n\n    stroke.points.append(point)\n\n    if let messenger = messenger {\n        Task {\n            try? await messenger.send(UpsertStrokeMessage(id: stroke.id, color: stroke.color, point: point))\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CanvasMessage: Codable {\n    let strokes: [Stroke]\n    let pointCount: Int\n}",
      "language" : "swift"
    },
    {
      "code" : "task = Task {\n    for await (message, _) in messenger.messages(of: CanvasMessage.self) {\n        handle(message)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func handle(_ message: CanvasMessage) {\n    guard message.pointCount > self.pointCount else { return }\n    self.strokes = message.strokes\n}",
      "language" : "swift"
    },
    {
      "code" : "groupSession.$activeParticipants\n    .sink { activeParticipants in\n        let newParticipants = activeParticipants.subtracting(groupSession.activeParticipants)\n\n        Task {\n            try? await messenger.send(CanvasMessage(strokes: self.strokes, pointCount: self.pointCount), to: .only(newParticipants))\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "Button {\n    canvas.reset()\n} label: {\n    Image(systemName: \"trash.fill\")\n}",
      "language" : "swift"
    },
    {
      "code" : "func reset() {\n    \/\/ Clear the local drawing canvas.\n    strokes = []\n\n    \/\/ Tear down the existing groupSession.\n    messenger = nil\n    tasks.forEach { $0.cancel() }\n    tasks = []\n    subscriptions = []\n    if groupSession != nil {\n        groupSession?.leave()\n        groupSession = nil\n        self.startSharing()\n    }\n}\n\nfunc startSharing() {\n    Task {\n        do {\n            _ = try await DrawTogether().activate()\n        } catch {\n            print(\"Failed to activate DrawTogether activity: \\(error)\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ControlBar: View {\n    @ObservedObject var canvas: Canvas\n    @StateObject var groupStateObserver = GroupStateObserver()\n\n    var body: some View {\n        HStack {\n            if canvas.groupSession == nil && groupStateObserver.isEligibleForGroupSession {\n                Button {\n                    canvas.startSharing()\n                } label: {\n                    Image(systemName: \"person.2.fill\")\n                }\n                .buttonStyle(.borderedProminent)\n            }\n\n            Spacer()\n\n            Button {\n                canvas.reset()\n            } label: {\n                Image(systemName: \"trash.fill\")\n            }\n        }\n        .buttonStyle(.bordered)\n        .controlSize(.large)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "e469571acc1b18c4a53518ba70a8773d6ae31ad94ab26511c57c15af0d54ac42",
  "crawledAt" : "2025-12-02T15:49:59Z",
  "id" : "DD06ABAE-C86B-4F0C-BBB3-93190F804B9F",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "GroupActivities",
  "overview" : "## Overview\n\nGroup Activities allows you to build shared experiences across devices with SharePlay. Although its focus is on creating media experiences, you can design your own custom app experiences to share with multiple devices. The real-time interactions you unlock, and the instant reaction people who use your app get, can lead to some truly special moments.\n\nThe sample app, DrawTogether, builds on some of the concepts introduced in WWDC21 session [link-4064242]. It allows you to draw together while on a FaceTime call. The entire screen is the canvas, and everyone draws with a random color.\n\nThere are two steps to adopt a [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity]: activity creation and session management. These are covered in detail in WWDC21 session [link-4064242] and in [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/supporting-coordinated-media-playback].\n\nThese steps change slightly when building a custom experience, starting with activity creation. Activity creation consists of configuring the activity, and then activating the activity. Only the configuration part is different for a custom activity compared to a media activity.\n\n### Configure the sample code project\n\nTo see the custom drawing experience together, install the app on two or more devices with unique Apple IDs, and start a FaceTime call between the devices. Tap the bottom-left icon, and respond to the system prompt to start a shared DrawTogether experience. On the other device, join the group session. The app gives each user a random color to draw with. When the user draws on the screen, the app propagates the drawing to all the other devices in the group session.\n\n### Configure a custom activity\n\nTo make drawing a group experience, the sample defines a `DrawTogether` structure that adopts the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity] protocol. This protocol defines a shareable experience in the app.  The `GroupActivity` protocol has two properties that the app implements: [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/activityIdentifier] and [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/metadata]. The app relies on the default implementation for `activityIdentifier`, and the `metadata` property is required. To make this activity a custom activity, the sample code sets the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivityMetadata\/type] on the `metadata` to [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivityMetadata\/ActivityType\/generic]. This is crucial for a custom activity, and is the only difference between configuring a custom activity and a media activity.\n\n### Activate an activity\n\nAfter configuring the activity, the app needs to activate it at the appropriate moment. The sample provides a button for activation. First, the sample checks to make sure a [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession] doesn’t exist already. Next, it calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver]  [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver\/isEligibleForGroupSession] method to make sure a FaceTime call is active and the system can create group sessions. Then, in the action closure, the sample calls its `canvas.startSharing()` method to activate the activity.\n\nIn its `canvas.startSharing()` method, the sample creates a new instance of the custom activity, and calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/activate()] method on it. That’s all that’s necessary to activate the activity.\n\n### Configure the session for sending and receiving custom data\n\nThe sample uses [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] to configure the session for sending and receiving its custom drawing data. The app creates a `GroupSessionMessenger` from the `GroupSession`. It also adds the `messenger` property to its `Canvas` to hold the `messenger` object.\n\nWhen using [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger], the sample code defines the type of data to exchange between participants. The app shares the strokes themselves. The sample defines the `UpsertStrokeMessage` structure to represent a stroke with three properties: an identifier, a color, and a coordinate point. The sample also specifies that the `UpsertStrokeMessage` structure conforms to the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Codable] protocol. `GroupSessionMessenger` automatically handles the serialization and deserialization of the message data if the messages are `Codable`.\n\nThe second step in configuring the session is to call the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/messages(of:)-jvoz] method to receive the `UpsertStrokeMessages` data. The sample specifies the `UpsertStrokeMessage` type  when calling the `messages` method. This method returns an async sequence that provides a tuple containing messages of that type and the context surrounding the message, such as which participant sends the message.\n\nThe third step for configuring the session is to send data using the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/send(_:to:)-2a4ku] method. The app sends an `UpsertStrokeMessage` to all participants within the group.\n\n### Receive custom data\n\nThe sample creates a detached task to receive the `UpsertStrokeMessages` from the async sequence, then calls its `handle` method to process the message.\n\nThe `handle` method checks the `stroke` identifier to see if one exists already — and if so, adds the point to it. Otherwise, it creates a new `stroke`, adds the point to it, and appends the `stroke` to an array of `strokes`.\n\n### Send custom data\n\nThe sample calls its `addPointToActiveStroke` method to send the messages using the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/send(_:to:)-2a4ku] method.\n\n### Handle late joiners\n\nLate joiners are devices that join an activity session after the session starts. To ensure a proper experience, the app gives late joiners the most recent information so all the devices use the same data.\n\nWhen a new device calls [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/join()] on the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession], every other device in the `GroupSession` receives an update of the `GroupSession` [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/activeParticipants] property. Devices that observe the update then send their own catch-up data (in this case, the existing drawing canvas) to the newly joined device.\n\nThe app defines its catch-up data in the `CanvasMessage` structure. This structure contains all of the existing strokes and a variable `pointCount`, a heuristic that calculates which message is the most up-to-date.\n\nThe sample defines a message handler in its `configureGroupSession` method to receive this message using the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/messages(of:)-jvoz] method. The handler calls the samples `handle()` method to process the message.\n\nThe sample’s `handle()` method guards against the `pointCount` heuristic to only accept catch-up messages that are newer than any currently saved messages. Then the sample overrides the `canvas` `strokes` with the catch-up message’s `strokes`.\n\nNext, the sample listens for [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/activeParticipants] changes to determine whether there are any new participants to communicate with. The sample’s `configureGroupSession` method handler obtains the delta between the new `activeParticipants` and the previous `activeParticipants`. This ensures that the sample only sends catch-up messages to the newly joined participants. Finally, the sample forms and sends the message.  The message contains the current `canvas` state and sends it only to the `newParticipants`.\n\n### Change activities\n\nThe Group Activities framework provides two ways to change activities: create a [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession], or update the activity for everyone in the existing `GroupSession`.\n\nThe sample app resets for each new drawing canvas. The sample triggers a new session when the user taps the Reset button. In this case, the sample calls its `Canvas` `reset` method to reset the local state and create a `GroupSession`.\n\nThe sample’s `reset` method removes the existing [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession], which allows for a clean transition to a new `canvas` in the new session.  The `reset` method cancels any tasks for the `GroupSession`. It also checks for an existing `GroupSession`, and if one exists, it calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/leave()] method to leave the current activity. It then calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/activate()] method to start the activity immediately and create a session for the app. Thereafter, the sample waits for the system to deliver a `GroupSession` object asynchronously through the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/Sessions] method of the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity].\n\n### Start SharePlay experiences\n\nThe sample’s `ControlBar` view contains a button to allow users to share the canvas with their friends. The sample dynamically displays the button only when it’s helpful to the user. The sample uses the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver\/isEligibleForGroupSession] property to determine whether a FaceTime call is active and the system can create group sessions. The `ControlBar` only shows the button if the system is eligible for a group session, and not in a group session already.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/groupactivities\/drawing_content_in_a_group_session\ncrawled: 2025-12-02T15:49:59Z\n---\n\n# Drawing content in a group session\n\n**Sample Code**\n\nInvite your friends to draw on a shared canvas while on a FaceTime call.\n\n## Overview\n\n\n\nGroup Activities allows you to build shared experiences across devices with SharePlay. Although its focus is on creating media experiences, you can design your own custom app experiences to share with multiple devices. The real-time interactions you unlock, and the instant reaction people who use your app get, can lead to some truly special moments.\n\nThe sample app, DrawTogether, builds on some of the concepts introduced in WWDC21 session [link-4064242]. It allows you to draw together while on a FaceTime call. The entire screen is the canvas, and everyone draws with a random color.\n\nThere are two steps to adopt a [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity]: activity creation and session management. These are covered in detail in WWDC21 session [link-4064242] and in [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/supporting-coordinated-media-playback].\n\nThese steps change slightly when building a custom experience, starting with activity creation. Activity creation consists of configuring the activity, and then activating the activity. Only the configuration part is different for a custom activity compared to a media activity.\n\n### Configure the sample code project\n\n- Build the sample with Xcode 13 or later, and Swift 5.5 or later.\n- This sample runs on physical devices with iOS 15 or later.\n\nTo see the custom drawing experience together, install the app on two or more devices with unique Apple IDs, and start a FaceTime call between the devices. Tap the bottom-left icon, and respond to the system prompt to start a shared DrawTogether experience. On the other device, join the group session. The app gives each user a random color to draw with. When the user draws on the screen, the app propagates the drawing to all the other devices in the group session.\n\n### Configure a custom activity\n\nTo make drawing a group experience, the sample defines a `DrawTogether` structure that adopts the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity] protocol. This protocol defines a shareable experience in the app.  The `GroupActivity` protocol has two properties that the app implements: [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/activityIdentifier] and [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/metadata]. The app relies on the default implementation for `activityIdentifier`, and the `metadata` property is required. To make this activity a custom activity, the sample code sets the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivityMetadata\/type] on the `metadata` to [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivityMetadata\/ActivityType\/generic]. This is crucial for a custom activity, and is the only difference between configuring a custom activity and a media activity.\n\n```swift\nstruct DrawTogether: GroupActivity {\n    var metadata: GroupActivityMetadata {\n        var metadata = GroupActivityMetadata()\n        metadata.title = NSLocalizedString(\"Draw Together\", comment: \"Title of group activity\")\n        metadata.type = .generic\n        return metadata\n    }\n}\n```\n\n### Activate an activity\n\nAfter configuring the activity, the app needs to activate it at the appropriate moment. The sample provides a button for activation. First, the sample checks to make sure a [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession] doesn’t exist already. Next, it calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver]  [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver\/isEligibleForGroupSession] method to make sure a FaceTime call is active and the system can create group sessions. Then, in the action closure, the sample calls its `canvas.startSharing()` method to activate the activity.\n\n```swift\nif canvas.groupSession == nil && groupStateObserver.isEligibleForGroupSession {\n    Button {\n        canvas.startSharing()\n    } label: {\n        Image(systemName: \"person.2.fill\")\n    }\n    .buttonStyle(.borderedProminent)\n}\n```\n\nIn its `canvas.startSharing()` method, the sample creates a new instance of the custom activity, and calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/activate()] method on it. That’s all that’s necessary to activate the activity.\n\n```swift\nfunc startSharing() {\n    Task {\n        do {\n            _ = try await DrawTogether().activate()\n        } catch {\n            print(\"Failed to activate DrawTogether activity: \\(error)\")\n        }\n    }\n}\n```\n\n### Configure the session for sending and receiving custom data\n\nThe sample uses [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] to configure the session for sending and receiving its custom drawing data. The app creates a `GroupSessionMessenger` from the `GroupSession`. It also adds the `messenger` property to its `Canvas` to hold the `messenger` object.\n\n```swift\nfunc configureGroupSession(_ groupSession: GroupSession<DrawTogether>) {\n    strokes = []\n\n    self.groupSession = groupSession\n    let messenger = GroupSessionMessenger(session: groupSession)\n    self.messenger = messenger\n```\n\nWhen using [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger], the sample code defines the type of data to exchange between participants. The app shares the strokes themselves. The sample defines the `UpsertStrokeMessage` structure to represent a stroke with three properties: an identifier, a color, and a coordinate point. The sample also specifies that the `UpsertStrokeMessage` structure conforms to the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Codable] protocol. `GroupSessionMessenger` automatically handles the serialization and deserialization of the message data if the messages are `Codable`.\n\n```swift\nstruct UpsertStrokeMessage: Codable {\n    let id: UUID\n    let color: Stroke.Color\n    let point: CGPoint\n}\n```\n\nThe second step in configuring the session is to call the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/messages(of:)-jvoz] method to receive the `UpsertStrokeMessages` data. The sample specifies the `UpsertStrokeMessage` type  when calling the `messages` method. This method returns an async sequence that provides a tuple containing messages of that type and the context surrounding the message, such as which participant sends the message.\n\n```swift\nfor await (message, _) in messenger.messages(of: UpsertStrokeMessage.self) {\n    handle(message)\n}\n```\n\nThe third step for configuring the session is to send data using the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/send(_:to:)-2a4ku] method. The app sends an `UpsertStrokeMessage` to all participants within the group.\n\n```swift\ntry? await messenger.send(UpsertStrokeMessage(id: stroke.id, color: stroke.color, point: point))\n```\n\n### Receive custom data\n\nThe sample creates a detached task to receive the `UpsertStrokeMessages` from the async sequence, then calls its `handle` method to process the message.\n\n```swift\nvar task = Task {\n    for await (message, _) in messenger.messages(of: UpsertStrokeMessage.self) {\n        handle(message)\n    }\n}\ntasks.insert(task)\n```\n\nThe `handle` method checks the `stroke` identifier to see if one exists already — and if so, adds the point to it. Otherwise, it creates a new `stroke`, adds the point to it, and appends the `stroke` to an array of `strokes`.\n\n```swift\nfunc handle(_ message: UpsertStrokeMessage) {\n    if let stroke = strokes.first(where: { $0.id == message.id }) {\n        stroke.points.append(message.point)\n    } else {\n        let stroke = Stroke(id: message.id, color: message.color)\n        stroke.points.append(message.point)\n        strokes.append(stroke)\n    }\n}\n```\n\n### Send custom data\n\nThe sample calls its `addPointToActiveStroke` method to send the messages using the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/send(_:to:)-2a4ku] method.\n\n```swift\nfunc addPointToActiveStroke(_ point: CGPoint) {\n    let stroke: Stroke\n    if let activeStroke = activeStroke {\n        stroke = activeStroke\n    } else {\n        stroke = Stroke(color: strokeColor)\n        activeStroke = stroke\n    }\n\n    stroke.points.append(point)\n\n    if let messenger = messenger {\n        Task {\n            try? await messenger.send(UpsertStrokeMessage(id: stroke.id, color: stroke.color, point: point))\n        }\n    }\n}\n```\n\n### Handle late joiners\n\nLate joiners are devices that join an activity session after the session starts. To ensure a proper experience, the app gives late joiners the most recent information so all the devices use the same data.\n\nWhen a new device calls [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/join()] on the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession], every other device in the `GroupSession` receives an update of the `GroupSession` [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/activeParticipants] property. Devices that observe the update then send their own catch-up data (in this case, the existing drawing canvas) to the newly joined device.\n\nThe app defines its catch-up data in the `CanvasMessage` structure. This structure contains all of the existing strokes and a variable `pointCount`, a heuristic that calculates which message is the most up-to-date.\n\n```swift\nstruct CanvasMessage: Codable {\n    let strokes: [Stroke]\n    let pointCount: Int\n}\n```\n\nThe sample defines a message handler in its `configureGroupSession` method to receive this message using the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSessionMessenger\/messages(of:)-jvoz] method. The handler calls the samples `handle()` method to process the message.\n\n```swift\ntask = Task {\n    for await (message, _) in messenger.messages(of: CanvasMessage.self) {\n        handle(message)\n    }\n}\n```\n\nThe sample’s `handle()` method guards against the `pointCount` heuristic to only accept catch-up messages that are newer than any currently saved messages. Then the sample overrides the `canvas` `strokes` with the catch-up message’s `strokes`.\n\n```swift\nfunc handle(_ message: CanvasMessage) {\n    guard message.pointCount > self.pointCount else { return }\n    self.strokes = message.strokes\n}\n```\n\nNext, the sample listens for [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/activeParticipants] changes to determine whether there are any new participants to communicate with. The sample’s `configureGroupSession` method handler obtains the delta between the new `activeParticipants` and the previous `activeParticipants`. This ensures that the sample only sends catch-up messages to the newly joined participants. Finally, the sample forms and sends the message.  The message contains the current `canvas` state and sends it only to the `newParticipants`.\n\n```swift\ngroupSession.$activeParticipants\n    .sink { activeParticipants in\n        let newParticipants = activeParticipants.subtracting(groupSession.activeParticipants)\n\n        Task {\n            try? await messenger.send(CanvasMessage(strokes: self.strokes, pointCount: self.pointCount), to: .only(newParticipants))\n        }\n    }\n```\n\n### Change activities\n\nThe Group Activities framework provides two ways to change activities: create a [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession], or update the activity for everyone in the existing `GroupSession`.\n\nThe sample app resets for each new drawing canvas. The sample triggers a new session when the user taps the Reset button. In this case, the sample calls its `Canvas` `reset` method to reset the local state and create a `GroupSession`.\n\n```swift\nButton {\n    canvas.reset()\n} label: {\n    Image(systemName: \"trash.fill\")\n}\n```\n\nThe sample’s `reset` method removes the existing [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession], which allows for a clean transition to a new `canvas` in the new session.  The `reset` method cancels any tasks for the `GroupSession`. It also checks for an existing `GroupSession`, and if one exists, it calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupSession\/leave()] method to leave the current activity. It then calls the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/activate()] method to start the activity immediately and create a session for the app. Thereafter, the sample waits for the system to deliver a `GroupSession` object asynchronously through the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity\/Sessions] method of the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupActivity].\n\n```swift\nfunc reset() {\n    \/\/ Clear the local drawing canvas.\n    strokes = []\n\n    \/\/ Tear down the existing groupSession.\n    messenger = nil\n    tasks.forEach { $0.cancel() }\n    tasks = []\n    subscriptions = []\n    if groupSession != nil {\n        groupSession?.leave()\n        groupSession = nil\n        self.startSharing()\n    }\n}\n\nfunc startSharing() {\n    Task {\n        do {\n            _ = try await DrawTogether().activate()\n        } catch {\n            print(\"Failed to activate DrawTogether activity: \\(error)\")\n        }\n    }\n}\n```\n\n### Start SharePlay experiences\n\nThe sample’s `ControlBar` view contains a button to allow users to share the canvas with their friends. The sample dynamically displays the button only when it’s helpful to the user. The sample uses the [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver] [doc:\/\/com.apple.GroupActivities\/documentation\/GroupActivities\/GroupStateObserver\/isEligibleForGroupSession] property to determine whether a FaceTime call is active and the system can create group sessions. The `ControlBar` only shows the button if the system is eligible for a group session, and not in a group session already.\n\n```swift\nstruct ControlBar: View {\n    @ObservedObject var canvas: Canvas\n    @StateObject var groupStateObserver = GroupStateObserver()\n\n    var body: some View {\n        HStack {\n            if canvas.groupSession == nil && groupStateObserver.isEligibleForGroupSession {\n                Button {\n                    canvas.startSharing()\n                } label: {\n                    Image(systemName: \"person.2.fill\")\n                }\n                .buttonStyle(.borderedProminent)\n            }\n\n            Spacer()\n\n            Button {\n                canvas.reset()\n            } label: {\n                Image(systemName: \"trash.fill\")\n            }\n        }\n        .buttonStyle(.bordered)\n        .controlSize(.large)\n    }\n}\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Drawing content in a group session",
  "url" : "https:\/\/developer.apple.com\/documentation\/groupactivities\/drawing_content_in_a_group_session"
}