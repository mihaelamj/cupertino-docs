{
  "abstract" : "Play a custom haptic pattern whose strength depends on an object’s collision speed.",
  "codeExamples" : [
    {
      "code" : "\/\/ Create and configure a haptic engine.\ndo {\n    engine = try CHHapticEngine()\n} catch let error {\n    fatalError(\"Engine Creation Error: \\(error)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "wallCollisions = UICollisionBehavior(items: [sphereView])\nwallCollisions.collisionDelegate = self\n\n\/\/ Express walls using vertices.\nlet upperLeft = CGPoint(x: -1, y: -1)\nlet upperRight = CGPoint(x: windowWidth + 1, y: -1)\nlet lowerRight = CGPoint(x: windowWidth + 1, y: windowHeight + 1)\nlet lowerLeft = CGPoint(x: -1, y: windowHeight + 1)\n\n\/\/ Each wall is a straight line shifted one pixel offscreen, to give an impression of existing at the boundary.\n\n\/\/ Left edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"leftWall\"),\n                           from: upperLeft,\n                           to: lowerLeft)\n\n\/\/ Right edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"rightWall\"),\n                           from: upperRight,\n                           to: lowerRight)\n\n\/\/ Top edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"topWall\"),\n                           from: upperLeft,\n                           to: upperRight)\n\n\/\/ Bottom edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"bottomWall\"),\n                           from: lowerRight,\n                           to: lowerLeft)",
      "language" : "swift"
    },
    {
      "code" : "animator = UIDynamicAnimator(referenceView: view)\n\n\/\/ Add bounce, gravity, and collision behavior.\nanimator.addBehavior(bounce)\nanimator.addBehavior(gravity)\nanimator.addBehavior(wallCollisions)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Manage motion events in a separate queue off the main thread.\nmotionQueue = OperationQueue()\nmotionData = CMAccelerometerData()\nmotionManager = CMMotionManager()\n\nguard let manager = motionManager else { return }\n\nmanager.startDeviceMotionUpdates(to: motionQueue) { deviceMotion, error in\n    guard let motion = deviceMotion else { return }\n    \n    let gravity = motion.gravity\n    \n    \/\/ Dispatch gravity updates to main queue, since they affect UI.\n    DispatchQueue.main.async {\n        self.gravity.gravityDirection = CGVector(dx: gravity.x * 3.5,\n                                                 dy: -gravity.y * 3.5)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Map the bounce velocity to intensity & sharpness.\nlet velocity = bounce.linearVelocity(for: item)\nlet xVelocity = Float(velocity.x)\nlet yVelocity = Float(velocity.y)\n\n\/\/ Normalize magnitude to map one number to haptic parameters:\nlet magnitude = sqrtf(xVelocity * xVelocity + yVelocity * yVelocity)\nlet normalizedMagnitude = min(max(Float(magnitude) \/ kMaxVelocity, 0.0), 1.0)\n\n\/\/ Create a haptic pattern player from normalized magnitude.\nlet hapticPlayer = try playerForMagnitude(normalizedMagnitude)",
      "language" : "swift"
    },
    {
      "code" : "let pattern = try CHHapticPattern(events: [audioEvent, hapticEvent], parameters: [])\nreturn try engine.makePlayer(with: pattern)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Start player, fire and forget\ntry hapticPlayer?.start(atTime: CHHapticTimeImmediate)",
      "language" : "swift"
    },
    {
      "code" : "let volume = linearInterpolation(alpha: magnitude, min: 0.1, max: 0.4)\nlet decay: Float = linearInterpolation(alpha: magnitude, min: 0.0, max: 0.1)\nlet audioEvent = CHHapticEvent(eventType: .audioContinuous, parameters: [\n    CHHapticEventParameter(parameterID: .audioPitch, value: -0.15),\n    CHHapticEventParameter(parameterID: .audioVolume, value: volume),\n    CHHapticEventParameter(parameterID: .decayTime, value: decay),\n    CHHapticEventParameter(parameterID: .sustained, value: 0)\n], relativeTime: 0)",
      "language" : "swift"
    }
  ],
  "contentHash" : "eb4ab7902511df4a62cdeb5ce8c412ff8c292e391facc30d5287246104f9bd9b",
  "crawledAt" : "2025-12-05T17:22:27Z",
  "id" : "4B136350-A8FF-4A89-94A1-6F8100525FE1",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Core Haptics",
  "overview" : "## Overview\n\nThe sample code project, HapticBounce, demonstrates how to play a haptic with audio when a bouncing sphere collides with the edges of the screen. The sample app shows how to vary the volume of the synthesized audio signal and the intensity of the transient haptic pattern based on the sphere’s velocity during impact.\n\nAlthough the sample app uses UIKit Dynamics and UIKit for simplicity and familiarity with UIKit classes, but your app can also use a 2D engine like SpriteKit to represent interactive object collisions.\n\n### Configure the App to Play Haptics\n\nCheck for device compatibility and set up an instance of [doc:\/\/com.apple.corehaptics\/documentation\/CoreHaptics\/CHHapticEngine], as the sample demonstrates when you launch the app.\n\nSee [doc:\/\/com.apple.corehaptics\/documentation\/CoreHaptics\/preparing-your-app-to-play-haptics] for more information about setting up the engine.\n\n### Define the Objects in UIKit Dynamics\n\nExpress the walls as boundaries in a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollisionBehavior] with the sphere.\n\nEach bounce against the wall is a dynamic item behavior, which lets you tweak the elasticity to match the haptic effect. An animator of class [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIDynamicAnimator] ties together all of these dynamic objects with gravity.\n\nHapticBounce uses the device’s accelerometer to move the sphere. It adjusts the accelerometer by responding to motion updates in a completion handler.\n\n### Play Variable Haptic Patterns on Collision\n\nWhen the sphere collides with a wall, the dynamics framework sends a callback to its delegate. `ViewController` implements this delegate, [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollisionBehaviorDelegate], to respond to collisions.\n\nTo vary the haptic at the point of collision, check the sphere’s velocity and map it to a normalized (0 to 1) intensity and sharpness value, as follows:\n\nThe sample sets `kMaxVelocity` based on experimentation dropping the sphere from a maximum possible height, but you can adjust the value to create a stronger or weaker intensity pattern.\n\nOn each impact, you can create a haptic player, an inexpensive operation, on the spot, using the desired haptic parameters.\n\nStarting the player plays the haptic.\n\n### Synthesize Audio to Play With the Haptic\n\nIn addition to playing haptic patterns, the haptic engine also synthesizes audio. The engine in HapticBounce plays this audio by adding an audio event to the same haptic player as the haptic event, as follows:\n\nInstead of adjusting haptic intensity and sharpness based on the sphere’s velocity, you vary audio volume and pitch.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/corehaptics\/playing-collision-based-haptic-patterns\ncrawled: 2025-12-05T17:22:27Z\n---\n\n# Playing Collision-Based Haptic Patterns\n\n**Sample Code**\n\nPlay a custom haptic pattern whose strength depends on an object’s collision speed.\n\n## Overview\n\nThe sample code project, HapticBounce, demonstrates how to play a haptic with audio when a bouncing sphere collides with the edges of the screen. The sample app shows how to vary the volume of the synthesized audio signal and the intensity of the transient haptic pattern based on the sphere’s velocity during impact.\n\nAlthough the sample app uses UIKit Dynamics and UIKit for simplicity and familiarity with UIKit classes, but your app can also use a 2D engine like SpriteKit to represent interactive object collisions.\n\n\n\n### Configure the App to Play Haptics\n\nCheck for device compatibility and set up an instance of [doc:\/\/com.apple.corehaptics\/documentation\/CoreHaptics\/CHHapticEngine], as the sample demonstrates when you launch the app.\n\n```swift\n\/\/ Create and configure a haptic engine.\ndo {\n    engine = try CHHapticEngine()\n} catch let error {\n    fatalError(\"Engine Creation Error: \\(error)\")\n}\n```\n\nSee [doc:\/\/com.apple.corehaptics\/documentation\/CoreHaptics\/preparing-your-app-to-play-haptics] for more information about setting up the engine.\n\n### Define the Objects in UIKit Dynamics\n\nExpress the walls as boundaries in a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollisionBehavior] with the sphere.\n\n```swift\nwallCollisions = UICollisionBehavior(items: [sphereView])\nwallCollisions.collisionDelegate = self\n\n\/\/ Express walls using vertices.\nlet upperLeft = CGPoint(x: -1, y: -1)\nlet upperRight = CGPoint(x: windowWidth + 1, y: -1)\nlet lowerRight = CGPoint(x: windowWidth + 1, y: windowHeight + 1)\nlet lowerLeft = CGPoint(x: -1, y: windowHeight + 1)\n\n\/\/ Each wall is a straight line shifted one pixel offscreen, to give an impression of existing at the boundary.\n\n\/\/ Left edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"leftWall\"),\n                           from: upperLeft,\n                           to: lowerLeft)\n\n\/\/ Right edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"rightWall\"),\n                           from: upperRight,\n                           to: lowerRight)\n\n\/\/ Top edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"topWall\"),\n                           from: upperLeft,\n                           to: upperRight)\n\n\/\/ Bottom edge of the screen:\nwallCollisions.addBoundary(withIdentifier: NSString(\"bottomWall\"),\n                           from: lowerRight,\n                           to: lowerLeft)\n```\n\nEach bounce against the wall is a dynamic item behavior, which lets you tweak the elasticity to match the haptic effect. An animator of class [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIDynamicAnimator] ties together all of these dynamic objects with gravity.\n\n```swift\nanimator = UIDynamicAnimator(referenceView: view)\n\n\/\/ Add bounce, gravity, and collision behavior.\nanimator.addBehavior(bounce)\nanimator.addBehavior(gravity)\nanimator.addBehavior(wallCollisions)\n```\n\nHapticBounce uses the device’s accelerometer to move the sphere. It adjusts the accelerometer by responding to motion updates in a completion handler.\n\n```swift\n\/\/ Manage motion events in a separate queue off the main thread.\nmotionQueue = OperationQueue()\nmotionData = CMAccelerometerData()\nmotionManager = CMMotionManager()\n\nguard let manager = motionManager else { return }\n\nmanager.startDeviceMotionUpdates(to: motionQueue) { deviceMotion, error in\n    guard let motion = deviceMotion else { return }\n    \n    let gravity = motion.gravity\n    \n    \/\/ Dispatch gravity updates to main queue, since they affect UI.\n    DispatchQueue.main.async {\n        self.gravity.gravityDirection = CGVector(dx: gravity.x * 3.5,\n                                                 dy: -gravity.y * 3.5)\n    }\n}\n```\n\n### Play Variable Haptic Patterns on Collision\n\nWhen the sphere collides with a wall, the dynamics framework sends a callback to its delegate. `ViewController` implements this delegate, [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollisionBehaviorDelegate], to respond to collisions.\n\nTo vary the haptic at the point of collision, check the sphere’s velocity and map it to a normalized (0 to 1) intensity and sharpness value, as follows:\n\n```swift\n\/\/ Map the bounce velocity to intensity & sharpness.\nlet velocity = bounce.linearVelocity(for: item)\nlet xVelocity = Float(velocity.x)\nlet yVelocity = Float(velocity.y)\n\n\/\/ Normalize magnitude to map one number to haptic parameters:\nlet magnitude = sqrtf(xVelocity * xVelocity + yVelocity * yVelocity)\nlet normalizedMagnitude = min(max(Float(magnitude) \/ kMaxVelocity, 0.0), 1.0)\n\n\/\/ Create a haptic pattern player from normalized magnitude.\nlet hapticPlayer = try playerForMagnitude(normalizedMagnitude)\n```\n\nThe sample sets `kMaxVelocity` based on experimentation dropping the sphere from a maximum possible height, but you can adjust the value to create a stronger or weaker intensity pattern.\n\nOn each impact, you can create a haptic player, an inexpensive operation, on the spot, using the desired haptic parameters.\n\n```swift\nlet pattern = try CHHapticPattern(events: [audioEvent, hapticEvent], parameters: [])\nreturn try engine.makePlayer(with: pattern)\n```\n\nStarting the player plays the haptic.\n\n```swift\n\/\/ Start player, fire and forget\ntry hapticPlayer?.start(atTime: CHHapticTimeImmediate)\n```\n\n### Synthesize Audio to Play With the Haptic\n\nIn addition to playing haptic patterns, the haptic engine also synthesizes audio. The engine in HapticBounce plays this audio by adding an audio event to the same haptic player as the haptic event, as follows:\n\n```swift\nlet volume = linearInterpolation(alpha: magnitude, min: 0.1, max: 0.4)\nlet decay: Float = linearInterpolation(alpha: magnitude, min: 0.0, max: 0.1)\nlet audioEvent = CHHapticEvent(eventType: .audioContinuous, parameters: [\n    CHHapticEventParameter(parameterID: .audioPitch, value: -0.15),\n    CHHapticEventParameter(parameterID: .audioVolume, value: volume),\n    CHHapticEventParameter(parameterID: .decayTime, value: decay),\n    CHHapticEventParameter(parameterID: .sustained, value: 0)\n], relativeTime: 0)\n```\n\nInstead of adjusting haptic intensity and sharpness based on the sphere’s velocity, you vary audio volume and pitch.\n\n## Programmatic haptics\n\n- **Delivering Rich App Experiences with Haptics**: Enhance your app’s experience by incorporating haptic and sound feedback into key interactive moments.\n- **Updating Continuous and Transient Haptic Parameters in Real Time**: Generate continuous and transient haptic patterns in response to user touch.\n- **CHHapticEvent**: An object that describes a single haptic or audio event.\n- **CHHapticEventParameter**: A static parameter value that represents a single property of the haptic pattern.\n- **CHHapticDynamicParameter**: A value that you send to a haptic pattern player to alter a property value during playback.\n- **CHHapticParameterCurve**: A curve that you send to a haptic pattern player to alter a property value gradually during playback.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Enhance your app’s experience by incorporating haptic and sound feedback into key interactive moments.",
          "name" : "Delivering Rich App Experiences with Haptics",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreHaptics\/delivering-rich-app-experiences-with-haptics"
        },
        {
          "description" : "Generate continuous and transient haptic patterns in response to user touch.",
          "name" : "Updating Continuous and Transient Haptic Parameters in Real Time",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreHaptics\/updating-continuous-and-transient-haptic-parameters-in-real-time"
        },
        {
          "description" : "An object that describes a single haptic or audio event.",
          "name" : "CHHapticEvent",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreHaptics\/CHHapticEvent"
        },
        {
          "description" : "A static parameter value that represents a single property of the haptic pattern.",
          "name" : "CHHapticEventParameter",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreHaptics\/CHHapticEventParameter"
        },
        {
          "description" : "A value that you send to a haptic pattern player to alter a property value during playback.",
          "name" : "CHHapticDynamicParameter",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreHaptics\/CHHapticDynamicParameter"
        },
        {
          "description" : "A curve that you send to a haptic pattern player to alter a property value gradually during playback.",
          "name" : "CHHapticParameterCurve",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreHaptics\/CHHapticParameterCurve"
        }
      ],
      "title" : "Programmatic haptics"
    }
  ],
  "source" : "appleJSON",
  "title" : "Playing Collision-Based Haptic Patterns",
  "url" : "https:\/\/developer.apple.com\/documentation\/corehaptics\/playing-collision-based-haptic-patterns"
}