{
  "abstract" : "Learn how to create a simple app that handles coalesced touches.",
  "codeExamples" : [
    {
      "code" : "class Stroke {\n    var samples = [StrokeSample]()\n    func add(sample: StrokeSample) {\n        samples.append(sample)\n    }\n}\n \nstruct StrokeSample {\n    let location: CGPoint\n    let coalescedSample: Bool\n    init(point: CGPoint, coalesced : Bool = false) {\n        location = point\n        coalescedSample = coalesced\n    }\n}\n",
      "language" : "swift"
    },
    {
      "code" : "class StrokeCollection {\n    var strokes = [Stroke]()\n    var activeStroke: Stroke? = nil\n \n    func acceptActiveStroke() {\n        if let stroke = activeStroke {\n            strokes.append(stroke)\n            activeStroke = nil\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class DrawingView : UIView {\n   var strokeCollection: StrokeCollection? {\n      didSet {\n         \/\/ If the strokes change, redraw the view's content.\n         if oldValue !== strokeCollection {\n            setNeedsDisplay()\n         }\n      }\n   }\n \n   \/\/ Initialization methods...\n \n   \/\/ Touch Handling methods\n   override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n      \/\/ Create a new stroke and make it the active stroke.\n      let newStroke = Stroke()\n      strokeCollection?.activeStroke = newStroke\n \n      \/\/ The view does not support multitouch, so get the samples\n      \/\/  for only the first touch in the event.\n      if let coalesced = event?.coalescedTouches(for: touches.first!) {\n         addSamples(for: coalesced)\n      }\n   }\n \n   override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {\n      if let coalesced = event?.coalescedTouches(for: touches.first!) {\n         addSamples(for: coalesced)\n      }\n   }\n \n   override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {\n      \/\/ Accept the current stroke and add it to the stroke collection.\n      if let coalesced = event?.coalescedTouches(for: touches.first!) {\n         addSamples(for: coalesced)\n      }\n      \/\/ Accept the active stroke.\n      strokeCollection?.acceptActiveStroke()\n   }\n \n   override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {\n      \/\/ Clear the last stroke.\n      strokeCollection?.activeStroke = nil\n   }\n \n   \/\/ More methods...\n}",
      "language" : "swift"
    },
    {
      "code" : "func addSamples(for touches: [UITouch]) {\n   if let stroke = strokeCollection?.activeStroke {\n      \/\/ Add all of the touches to the active stroke.\n      for touch in touches {\n         if touch == touches.last {\n            let sample = StrokeSample(point: touch.preciseLocation(in: self))\n            stroke.add(sample: sample)\n         } else {\n            \/\/ If the touch is not the last one in the array,\n            \/\/  it was a coalesced touch. \n            let sample = StrokeSample(point: touch.preciseLocation(in: self), \n                                  coalesced: true)\n            stroke.add(sample: sample)\n         }\n      } \n      \/\/ Update the view.\n      self.setNeedsDisplay()\n   }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "202d077ca2c6ffc957809e6b06875cb2392ed4b9d29c5f9e7a3a6aa0e0a2a9ec",
  "crawledAt" : "2025-12-03T18:35:04Z",
  "id" : "B11C513B-8820-4ADF-B7FB-F0ADBF5B6D46",
  "kind" : "article",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nThe following image shows a simple drawing app that captures touches and renders the resulting path onscreen. The app tracks all touches reported by UIKit, including coalesced touches. The app builds the path by drawing line segments from one touch point to the next.\n\n\n\n### Provide storage for the touches\n\nThe main view of the app uses incoming touch events to build a set of `Stroke` objects. The following image shows the definition of the `Stroke` class and the associated `StrokeSample` class, which store information about each touch event.\n\nThe main view maintains a collection of `Stroke` objects that have been created using the `StrokeCollection` class, the implementation of which is shown in the following code. The `strokes` property of this class stores the completed strokes and the `activeStroke` property contains a stroke object that’s currently being modified. Calling the `acceptActiveStroke` method moves the active stroke to the set of completed strokes.\n\n### Retrieve the coalesced touches\n\nThe following code shows the portion of the main drawing view that creates new `Stroke` objects. The view doesn’t support multitouch, so only the first touch event needs to be tracked. The [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesBegan(_:with:)] method creates a new stroke object and marks it as the active stroke. New touch data is added to the active stroke until the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesEnded(_:with:)] method is called, at which point the stroke is accepted into the stroke collection. If the touch sequence is interrupted for any reason, the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesCancelled(_:with:)] method abandons the currently active stroke.\n\nThe touch input methods of `DrawingView` use the `addSamples` method (shown in the following code) to incorporate new touches into the active stroke. This method creates a new `StrokeSample` for each touch point and adds that sample to the active stroke. The example flags coalesced touches internally, but the touches are no different from the regular touches reported by the system.\n\nThe remaining methods of the `DrawingView` class take the touch samples and turn them into the rendered output. The app’s Clear button releases the view’s current `StrokeCollection` object and creates a new one.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/uikit\/implementing-coalesced-touch-support-in-an-app\ncrawled: 2025-12-03T18:35:04Z\n---\n\n# Implementing coalesced touch support in an app\n\n**Article**\n\nLearn how to create a simple app that handles coalesced touches.\n\n## Overview\n\nThe following image shows a simple drawing app that captures touches and renders the resulting path onscreen. The app tracks all touches reported by UIKit, including coalesced touches. The app builds the path by drawing line segments from one touch point to the next.\n\n\n\n### Provide storage for the touches\n\nThe main view of the app uses incoming touch events to build a set of `Stroke` objects. The following image shows the definition of the `Stroke` class and the associated `StrokeSample` class, which store information about each touch event.\n\n```swift\nclass Stroke {\n    var samples = [StrokeSample]()\n    func add(sample: StrokeSample) {\n        samples.append(sample)\n    }\n}\n \nstruct StrokeSample {\n    let location: CGPoint\n    let coalescedSample: Bool\n    init(point: CGPoint, coalesced : Bool = false) {\n        location = point\n        coalescedSample = coalesced\n    }\n}\n\n```\n\nThe main view maintains a collection of `Stroke` objects that have been created using the `StrokeCollection` class, the implementation of which is shown in the following code. The `strokes` property of this class stores the completed strokes and the `activeStroke` property contains a stroke object that’s currently being modified. Calling the `acceptActiveStroke` method moves the active stroke to the set of completed strokes.\n\n```swift\nclass StrokeCollection {\n    var strokes = [Stroke]()\n    var activeStroke: Stroke? = nil\n \n    func acceptActiveStroke() {\n        if let stroke = activeStroke {\n            strokes.append(stroke)\n            activeStroke = nil\n        }\n    }\n}\n```\n\n### Retrieve the coalesced touches\n\nThe following code shows the portion of the main drawing view that creates new `Stroke` objects. The view doesn’t support multitouch, so only the first touch event needs to be tracked. The [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesBegan(_:with:)] method creates a new stroke object and marks it as the active stroke. New touch data is added to the active stroke until the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesEnded(_:with:)] method is called, at which point the stroke is accepted into the stroke collection. If the touch sequence is interrupted for any reason, the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesCancelled(_:with:)] method abandons the currently active stroke.\n\n```swift\nclass DrawingView : UIView {\n   var strokeCollection: StrokeCollection? {\n      didSet {\n         \/\/ If the strokes change, redraw the view's content.\n         if oldValue !== strokeCollection {\n            setNeedsDisplay()\n         }\n      }\n   }\n \n   \/\/ Initialization methods...\n \n   \/\/ Touch Handling methods\n   override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {\n      \/\/ Create a new stroke and make it the active stroke.\n      let newStroke = Stroke()\n      strokeCollection?.activeStroke = newStroke\n \n      \/\/ The view does not support multitouch, so get the samples\n      \/\/  for only the first touch in the event.\n      if let coalesced = event?.coalescedTouches(for: touches.first!) {\n         addSamples(for: coalesced)\n      }\n   }\n \n   override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {\n      if let coalesced = event?.coalescedTouches(for: touches.first!) {\n         addSamples(for: coalesced)\n      }\n   }\n \n   override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {\n      \/\/ Accept the current stroke and add it to the stroke collection.\n      if let coalesced = event?.coalescedTouches(for: touches.first!) {\n         addSamples(for: coalesced)\n      }\n      \/\/ Accept the active stroke.\n      strokeCollection?.acceptActiveStroke()\n   }\n \n   override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {\n      \/\/ Clear the last stroke.\n      strokeCollection?.activeStroke = nil\n   }\n \n   \/\/ More methods...\n}\n```\n\nThe touch input methods of `DrawingView` use the `addSamples` method (shown in the following code) to incorporate new touches into the active stroke. This method creates a new `StrokeSample` for each touch point and adds that sample to the active stroke. The example flags coalesced touches internally, but the touches are no different from the regular touches reported by the system.\n\n```swift\nfunc addSamples(for touches: [UITouch]) {\n   if let stroke = strokeCollection?.activeStroke {\n      \/\/ Add all of the touches to the active stroke.\n      for touch in touches {\n         if touch == touches.last {\n            let sample = StrokeSample(point: touch.preciseLocation(in: self))\n            stroke.add(sample: sample)\n         } else {\n            \/\/ If the touch is not the last one in the array,\n            \/\/  it was a coalesced touch. \n            let sample = StrokeSample(point: touch.preciseLocation(in: self), \n                                  coalesced: true)\n            stroke.add(sample: sample)\n         }\n      } \n      \/\/ Update the view.\n      self.setNeedsDisplay()\n   }\n}\n```\n\n\n\nThe remaining methods of the `DrawingView` class take the touch samples and turn them into the rendered output. The app’s Clear button releases the view’s current `StrokeCollection` object and creates a new one.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Implementing coalesced touch support in an app",
  "url" : "https:\/\/developer.apple.com\/documentation\/uikit\/implementing-coalesced-touch-support-in-an-app"
}