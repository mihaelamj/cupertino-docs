{
  "abstract" : "Return your app to its previous state after the system terminates it.",
  "codeExamples" : [
    {
      "code" : "func application(_ application: UIApplication, \n            shouldSaveSecureApplicationState coder: NSCoder) -> Bool {\n   \/\/ Save the current app version to the archive.\n   coder.encode(11.0, forKey: \"MyAppVersion\")\n        \n   \/\/ Always save state information.\n   return true\n}\n    \nfunc application(_ application: UIApplication, \n            shouldRestoreSecureApplicationState coder: NSCoder) -> Bool {\n   \/\/ Restore the state only if the app version matches.\n   let version = coder.decodeFloat(forKey: \"MyAppVersion\")\n   if version == 11.0 {\n      return true\n   }\n    \n   \/\/ Don't restore from old data.    \n   return false\n}",
      "language" : "swift"
    },
    {
      "code" : "override func encodeRestorableState(with coder: NSCoder) {\n   super.encodeRestorableState(with: coder)\n        \n   \/\/ Save the user ID so that we can load that user later.\n   coder.encode(userID, forKey: \"UserID\")\n\n   \/\/ Write out any temporary data if editing is in progress.\n   if firstNameField!.isFirstResponder {\n      coder.encode(firstNameField?.text, forKey: \"EditedText\")\n      coder.encode(Int32(1), forKey: \"EditField\")\n   }\n   else if lastNameField!.isFirstResponder {\n      coder.encode(lastNameField?.text, forKey: \"EditedText\")\n      coder.encode(Int32(2), forKey: \"EditField\")\n   }\n   else {\n      \/\/ No editing was in progress.\n      coder.encode(Int32(0), forKey: \"EditField\")\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "override func decodeRestorableState(with coder: NSCoder) {\n   super.decodeRestorableState(with: coder)\n   \n   \/\/ Restore the first name and last name from the user ID.\n   let identifier = coder.decodeObject(forKey: \"UserID\") as! String\n   setUserID(identifier: identifier)\n\n   \/\/ Restore an in-progress values that was not saved.\n   let activeField = coder.decodeInteger(forKey: \"EditField\")\n   let editedText = coder.decodeObject(forKey: \"EditedText\") as! \n                         String?\n\n   switch activeField {\n      case 1:\n         firstNameField?.text = editedText\n         firstNameField?.becomeFirstResponder()\n         break\n            \n      case 2:\n         lastNameField?.text = editedText\n         lastNameField?.becomeFirstResponder()\n         break\n            \n     default:\n         break  \/\/ Do nothing.\n  }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "21d2fa56b432609895fed9374c925e29cc97da88dd965c70d5acf465de35dd96",
  "crawledAt" : "2025-12-02T16:20:01Z",
  "id" : "50F2184C-FB95-4775-9755-B2DD2905C3E2",
  "kind" : "collection",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nPreserving your app’s user interface helps maintain the illusion that your app is always running. Interruptions can occur frequently on iOS devices, and a prolonged interruption might cause the system to terminate your app to free up resources. However, users don’t know that your app has been terminated and won’t expect the state of your app to change. Instead, they expect your app to be in the same state as when they left it. State preservation and restoration ensures that your app returns to its previous state when it launches again.\n\nAt appropriate times, UIKit preserves the state of your app’s views and view controllers to an encrypted file on disk. When your app is terminated and relaunched later, UIKit reconstructs your views and view controllers from the preserved data. The preservation and restoration processes are initiated automatically, but you must also do some specific work to support those processes:\n\nIf you define your interface entirely in storyboards, UIKit knows how to recreate your view controllers, and does so automatically. If you don’t use storyboards, or if you want more control over the creation and initialization of your view controllers, you can create them yourself.\n\nTo see an example of state preservation and restoration, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/restoring-your-app-s-state].\n\n### Enable state preservation and restoration for your app\n\nYou opt-in to state preservation and restoration by implementing your app delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldSaveSecureApplicationState:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldRestoreSecureApplicationState:)] methods. Both methods return a Boolean value indicating whether the associated process should occur, and in most cases you simply return [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. However, you can return [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] at times when restoring your app’s interface might not be appropriate.\n\nWhen UIKit calls your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldSaveSecureApplicationState:)] method, you can save data in addition to returning [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. You might save data that you intend to use during the restoration process. For example, the following code shows an example that saves the app’s current version number. At restoration time, the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldRestoreSecureApplicationState:)] method checks the version number in the archive and prevents restoration from occurring if it doesn’t match the expected version.\n\nIf you prevent restoration from occurring, you can still configure your app’s interface manually in the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)] method of your app delegate.\n\n### Assign restoration identifiers to your view controllers\n\nYou explicitly tell UIKit which view controllers to preserve by assigning restoration identifiers to them. A restoration identifier is a unique string that you assign to the view controller programmatically or in Interface Builder. The name of the view controller class is usually a suitable restoration identifier, but you may use any string. Add that string to the view controller in your storyboard file or assign it to the view controller’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIViewController\/restorationIdentifier] property at runtime.\n\n\n\nAt preservation time, UIKit attempts to preserve the root view controllers of your app’s windows. For each root view controller with a restoration identifier, UIKit asks that view controller to encode its custom data in an archive. A container view controller can encode references to its child view controllers as part of its custom data. If it does, and if those view controllers also have restoration identifiers, UIKit attempts to preserve the child view controllers and their contents. This process continues recursively, following the connections from one view controller to the next until all of them are saved or ignored.\n\nYou aren’t required to assign a restoration identifier to every view controller. In fact, there are times when you might not want to preserve all of your view controllers. For example, if your app displays a temporary login screen, you might not want that screen preserved. Instead, you’d want to determine at restoration time whether to display it. In that case, you wouldn’t assign a restoration identifier to the view controller for your login screen.\n\nFor detailed information about what gets preserved, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/about-the-ui-preservation-process].\n\n### Encode and decode custom information for your app\n\nDuring the preservation process, UIKit calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIStateRestoring\/encodeRestorableState(with:)] method of each preserved view and view controller. Use this method to preserve the information that you need to return the view or view controller to its current state.\n\nState preservation isn’t a substitute for saving your app’s data to disk. UIKit can discard state preservation data at its discretion, allowing your app to return to its default state. Use the preservation process to store information about the state of your app’s user interface, such as the currently selected row of a table. Don’t use it to store the data contained in that table.\n\nThe following code shows an example of a view controller with text fields for gathering a first and last name. If one of the text fields contains an unsaved value, the method saves the unsaved value and an identifier for which text field contains that value. In this case, the unsaved value isn’t part of the app’s persistent data; it’s a temporary value that can be discarded if needed.\n\nFor more information about how UIKit preserves your app’s views, view controllers, and state information, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/about-the-ui-preservation-process].\n\n### Create view controllers when asked\n\nIf preserved state information is available when your app is launched, the system attempts to restore your app’s interface using the preserved data.\n\nUIKit loads both the view controller and its views from your storyboard initially. After those objects have been loaded and initialized, UIKit begins restoring their state information. Use your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIStateRestoring\/decodeRestorableState(with:)] methods to return your view controller to its previous state.\n\nThe following code shows the method for decoding the state that was encoded in the previous example. This method restores the view controller’s data from the preserved user ID. If a text field was being edited, this method also restores the in-progress value and makes the corresponding text field the first responder, which displays the keyboard for that text field.\n\nDefining your view controllers in storyboards is the easiest way to manage state restoration, but it isn’t the only way. For more information about other ways to recreate your view controllers, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/about-the-ui-restoration-process].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/preserving-your-app-s-ui-across-launches\ncrawled: 2025-12-02T16:20:01Z\n---\n\n# Preserving your app’s UI across launches\n\nReturn your app to its previous state after the system terminates it.\n\n## Overview\n\nPreserving your app’s user interface helps maintain the illusion that your app is always running. Interruptions can occur frequently on iOS devices, and a prolonged interruption might cause the system to terminate your app to free up resources. However, users don’t know that your app has been terminated and won’t expect the state of your app to change. Instead, they expect your app to be in the same state as when they left it. State preservation and restoration ensures that your app returns to its previous state when it launches again.\n\nAt appropriate times, UIKit preserves the state of your app’s views and view controllers to an encrypted file on disk. When your app is terminated and relaunched later, UIKit reconstructs your views and view controllers from the preserved data. The preservation and restoration processes are initiated automatically, but you must also do some specific work to support those processes:\n\n- Enable support for state preservation and restoration.\n- Assign restoration identifiers to the view controllers that you want to preserve.\n- Recreate view controllers, as needed, at restoration time.\n- Encode and decode the custom data that you need to restore your view controller to its previous state.\n\nIf you define your interface entirely in storyboards, UIKit knows how to recreate your view controllers, and does so automatically. If you don’t use storyboards, or if you want more control over the creation and initialization of your view controllers, you can create them yourself.\n\nTo see an example of state preservation and restoration, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/restoring-your-app-s-state].\n\n### Enable state preservation and restoration for your app\n\nYou opt-in to state preservation and restoration by implementing your app delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldSaveSecureApplicationState:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldRestoreSecureApplicationState:)] methods. Both methods return a Boolean value indicating whether the associated process should occur, and in most cases you simply return [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. However, you can return [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] at times when restoring your app’s interface might not be appropriate.\n\nWhen UIKit calls your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldSaveSecureApplicationState:)] method, you can save data in addition to returning [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. You might save data that you intend to use during the restoration process. For example, the following code shows an example that saves the app’s current version number. At restoration time, the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldRestoreSecureApplicationState:)] method checks the version number in the archive and prevents restoration from occurring if it doesn’t match the expected version.\n\n```swift\nfunc application(_ application: UIApplication, \n            shouldSaveSecureApplicationState coder: NSCoder) -> Bool {\n   \/\/ Save the current app version to the archive.\n   coder.encode(11.0, forKey: \"MyAppVersion\")\n        \n   \/\/ Always save state information.\n   return true\n}\n    \nfunc application(_ application: UIApplication, \n            shouldRestoreSecureApplicationState coder: NSCoder) -> Bool {\n   \/\/ Restore the state only if the app version matches.\n   let version = coder.decodeFloat(forKey: \"MyAppVersion\")\n   if version == 11.0 {\n      return true\n   }\n    \n   \/\/ Don't restore from old data.    \n   return false\n}\n```\n\nIf you prevent restoration from occurring, you can still configure your app’s interface manually in the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFinishLaunchingWithOptions:)] method of your app delegate.\n\n### Assign restoration identifiers to your view controllers\n\nYou explicitly tell UIKit which view controllers to preserve by assigning restoration identifiers to them. A restoration identifier is a unique string that you assign to the view controller programmatically or in Interface Builder. The name of the view controller class is usually a suitable restoration identifier, but you may use any string. Add that string to the view controller in your storyboard file or assign it to the view controller’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIViewController\/restorationIdentifier] property at runtime.\n\n\n\nAt preservation time, UIKit attempts to preserve the root view controllers of your app’s windows. For each root view controller with a restoration identifier, UIKit asks that view controller to encode its custom data in an archive. A container view controller can encode references to its child view controllers as part of its custom data. If it does, and if those view controllers also have restoration identifiers, UIKit attempts to preserve the child view controllers and their contents. This process continues recursively, following the connections from one view controller to the next until all of them are saved or ignored.\n\nYou aren’t required to assign a restoration identifier to every view controller. In fact, there are times when you might not want to preserve all of your view controllers. For example, if your app displays a temporary login screen, you might not want that screen preserved. Instead, you’d want to determine at restoration time whether to display it. In that case, you wouldn’t assign a restoration identifier to the view controller for your login screen.\n\nFor detailed information about what gets preserved, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/about-the-ui-preservation-process].\n\n### Encode and decode custom information for your app\n\nDuring the preservation process, UIKit calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIStateRestoring\/encodeRestorableState(with:)] method of each preserved view and view controller. Use this method to preserve the information that you need to return the view or view controller to its current state.\n\n- **Do** save details about the visual state of views and controls.\n- **Do** save references to child view controllers that you also want to preserve.\n- **Do** save information that can be discarded without affecting the user’s data.\n- **Don’t** include data that’s already in your app’s persistent storage. Instead, include an identifier that you can use to locate that data later.\n\nState preservation isn’t a substitute for saving your app’s data to disk. UIKit can discard state preservation data at its discretion, allowing your app to return to its default state. Use the preservation process to store information about the state of your app’s user interface, such as the currently selected row of a table. Don’t use it to store the data contained in that table.\n\nThe following code shows an example of a view controller with text fields for gathering a first and last name. If one of the text fields contains an unsaved value, the method saves the unsaved value and an identifier for which text field contains that value. In this case, the unsaved value isn’t part of the app’s persistent data; it’s a temporary value that can be discarded if needed.\n\n```swift\noverride func encodeRestorableState(with coder: NSCoder) {\n   super.encodeRestorableState(with: coder)\n        \n   \/\/ Save the user ID so that we can load that user later.\n   coder.encode(userID, forKey: \"UserID\")\n\n   \/\/ Write out any temporary data if editing is in progress.\n   if firstNameField!.isFirstResponder {\n      coder.encode(firstNameField?.text, forKey: \"EditedText\")\n      coder.encode(Int32(1), forKey: \"EditField\")\n   }\n   else if lastNameField!.isFirstResponder {\n      coder.encode(lastNameField?.text, forKey: \"EditedText\")\n      coder.encode(Int32(2), forKey: \"EditField\")\n   }\n   else {\n      \/\/ No editing was in progress.\n      coder.encode(Int32(0), forKey: \"EditField\")\n   }\n}\n```\n\nFor more information about how UIKit preserves your app’s views, view controllers, and state information, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/about-the-ui-preservation-process].\n\n### Create view controllers when asked\n\nIf preserved state information is available when your app is launched, the system attempts to restore your app’s interface using the preserved data.\n\n1. UIKit calls your app delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldRestoreSecureApplicationState:)] method to determine if restoration should proceed.\n2. UIKit uses your app’s storyboards to recreate your view controllers.\n3. UIKit calls each view controller’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIStateRestoring\/decodeRestorableState(with:)] method to restore its state information.\n\nUIKit loads both the view controller and its views from your storyboard initially. After those objects have been loaded and initialized, UIKit begins restoring their state information. Use your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIStateRestoring\/decodeRestorableState(with:)] methods to return your view controller to its previous state.\n\nThe following code shows the method for decoding the state that was encoded in the previous example. This method restores the view controller’s data from the preserved user ID. If a text field was being edited, this method also restores the in-progress value and makes the corresponding text field the first responder, which displays the keyboard for that text field.\n\n```swift\noverride func decodeRestorableState(with coder: NSCoder) {\n   super.decodeRestorableState(with: coder)\n   \n   \/\/ Restore the first name and last name from the user ID.\n   let identifier = coder.decodeObject(forKey: \"UserID\") as! String\n   setUserID(identifier: identifier)\n\n   \/\/ Restore an in-progress values that was not saved.\n   let activeField = coder.decodeInteger(forKey: \"EditField\")\n   let editedText = coder.decodeObject(forKey: \"EditedText\") as! \n                         String?\n\n   switch activeField {\n      case 1:\n         firstNameField?.text = editedText\n         firstNameField?.becomeFirstResponder()\n         break\n            \n      case 2:\n         lastNameField?.text = editedText\n         lastNameField?.becomeFirstResponder()\n         break\n            \n     default:\n         break  \/\/ Do nothing.\n  }\n}\n```\n\nDefining your view controllers in storyboards is the easiest way to manage state restoration, but it isn’t the only way. For more information about other ways to recreate your view controllers, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/about-the-ui-restoration-process].\n\n## Process details\n\n- **About the UI preservation process**: Learn how to customize the UIKit state preservation process.\n- **About the UI restoration process**: Learn how to customize the UIKit state restoration process.\n\n## Interface restoration\n\n- **Restoring your app’s state**: Provide continuity for the user by preserving current activities.\n- **Restoring your app’s state with SwiftUI**: Provide app continuity for users by preserving their current activities.\n- **UIViewControllerRestoration**: The methods that objects adopt so that they can act as a restoration class for view controllers during state restoration.\n- **UIObjectRestoration**: The interface that restoration classes use to restore preserved objects.\n- **UIStateRestoring**: Methods for adding objects to your state restoration archives.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn how to customize the UIKit state preservation process.",
          "name" : "About the UI preservation process",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/about-the-ui-preservation-process"
        },
        {
          "description" : "Learn how to customize the UIKit state restoration process.",
          "name" : "About the UI restoration process",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/about-the-ui-restoration-process"
        }
      ],
      "title" : "Process details"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Provide continuity for the user by preserving current activities.",
          "name" : "Restoring your app’s state",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/restoring-your-app-s-state"
        },
        {
          "description" : "Provide app continuity for users by preserving their current activities.",
          "name" : "Restoring your app’s state with SwiftUI",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/restoring-your-app-s-state-with-swiftui"
        },
        {
          "description" : "The methods that objects adopt so that they can act as a restoration class for view controllers during state restoration.",
          "name" : "UIViewControllerRestoration",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIViewControllerRestoration"
        },
        {
          "description" : "The interface that restoration classes use to restore preserved objects.",
          "name" : "UIObjectRestoration",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIObjectRestoration"
        },
        {
          "description" : "Methods for adding objects to your state restoration archives.",
          "name" : "UIStateRestoring",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIStateRestoring"
        }
      ],
      "title" : "Interface restoration"
    }
  ],
  "source" : "appleJSON",
  "title" : "Preserving your app’s UI across launches",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/preserving-your-app-s-ui-across-launches"
}