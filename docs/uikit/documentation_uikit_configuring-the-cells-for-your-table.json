{
  "abstract" : "Specify the appearance and content of your table’s rows by defining one or more prototype cells in your storyboard.",
  "codeExamples" : [
    {
      "code" : "var cell = tableView.dequeueReusableCell(withIdentifier: \"myCellType\", for: indexPath)",
      "language" : "swift"
    },
    {
      "code" : "override func tableView(_ tableView: UITableView, \n             cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n   \/\/ Reuse or create a cell. \n   let cell = tableView.dequeueReusableCell(withIdentifier: \"basicStyle\", for: indexPath)\n\n   \/\/ For a standard cell, use the UITableViewCell properties.\n   cell.textLabel!.text = \"Title text\"\n   cell.imageView!.image = UIImage(named: \"bunny\")\n   return cell\n}",
      "language" : "swift"
    },
    {
      "code" : "class FoodCell: UITableViewCell {\n    @IBOutlet var name : UILabel?\n    @IBOutlet var plantDescription : UILabel?\n    @IBOutlet var picture : UIImageView?\n}",
      "language" : "swift"
    },
    {
      "code" : "override func tableView(_ tableView: UITableView, \n             cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n\n   \/\/ Reuse or create a cell of the appropriate type.\n   let cell = tableView.dequeueReusableCell(withIdentifier: \"foodCellType\", \n                         for: indexPath) as! FoodCell\n\n   \/\/ Fetch the data for the row.\n   let theFood = foods[indexPath.row]\n        \n   \/\/ Configure the cell’s contents with data from the fetched object.\n   cell.name?.text = theFood.name\n   cell.plantDescription?.text = theFood.description\n   cell.picture?.image = theFood.picture\n        \n   return cell\n}",
      "language" : "swift"
    },
    {
      "code" : "override func tableView(_ tableView: UITableView, \n           heightForRowAt indexPath: IndexPath) -> CGFloat {\n   \/\/ Make the first row larger to accommodate a custom cell.\n  if indexPath.row == 0 {\n      return 80\n   }\n\n   \/\/ Use the default size for all other rows.\n   return UITableView.automaticDimension\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "e5d702fc0a7b2c38f50652bba53beadff910f85b118ffa8fbe7d4fea2490ddd8",
  "crawledAt" : "2025-12-03T18:48:11Z",
  "id" : "F1B48314-A95C-417E-80DD-B4905D579A36",
  "kind" : "article",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nCells provide the visual representation of your table’s rows. For most tables, you provide only one or two different types of cells. Design your cells to ensure that the most important information stands out. Do that using a careful choice of views and view configurations in your cells.\n\nYou specify the appearance of cells at design time in your storyboard file. Xcode provides one prototype cell for each table, and you can add more prototype cells as needed. A prototype cell acts a template for your cell’s appearance. It includes the views you want to display and their arrangement within the content area of the cell. At runtime, the table’s data source object creates actual cells from the prototypes and configures them with your app’s data.\n\n\n\nFor tips on how to design the appearance of your cells, see [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/components\/layout-and-organization\/lists-and-tables].\n\n### Assign a reuse identifier to each cell\n\nReuse identifiers facilitate the creation and recycling of your table’s cells. A reuse identifier is a string that you assign to each prototype cell of your table. In your storyboard, select your prototype cell and assign a nonempty value to its identifier attribute. Each cell in a table view must have a unique reuse identifier.\n\nWhen you need a cell object at runtime, call the table view’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView\/dequeueReusableCell(withIdentifier:for:)] method, passing the reuse identifier for the cell you want. The table view maintains an internal queue of already-created cells. If the queue contains a cell of the requested type, the table view returns that cell. If not, it creates a new cell using the prototype cell in your storyboard. Reusing cells improves performance by minimizing memory allocations during critical times, such as during scrolling.\n\n### Configure a cell with a built-in style\n\nThe simplest way to configure a cell is to use one of the built-in styles provided by [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell]. You use these styles as is; you don’t need to provide a custom subclass to manage the cell. Each style incorporates one or two labels, with the style determining the positions of the labels within the cell’s content area. Most of the styles also incorporate an image at the leading edge of the cell’s content.\n\nTo configure a prototype cell with one of the standard styles, select the cell in your storyboard and set the cell’s Style property to a value other than custom.\n\n\n\nIn your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDataSource\/tableView(_:cellForRowAt:)] method, configure the content of your cell using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/textLabel], [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/detailTextLabel], and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/imageView] properties of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell]. Those properties contain views, but the cell object only assigns a view if the style supports the corresponding content. For example, the Basic cell style doesn’t support a detail string, so the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/detailTextLabel] property is `nil` for that style. The following example code shows how to configure a cell that uses the basic cell style.\n\n### Configure a cell with custom views\n\nFor appearances other than the standard styles, use the custom cell style. With a custom cell, you specify the views you want in the cell, their configurations, and their sizes and positions. Static views such as labels and images make the best content for cells. Avoid views that require user interactions such as controls. Don’t include scroll views, table views, collection views, or other complex container views in cells. You may include stack views in your cells, but minimize the number of items in your stack view to improve performance.\n\nTo configure a custom cell, drag views into the prototype cell for your table. The following illustration shows a cell with a custom layout and formatting for its views. You use constraints to position your views within the cell’s content area. When setting up constraints, use the “Constrain to margins” option to preserve the gap between the content areas of your cells.\n\n\n\nFor custom cells, you need to define a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell] subclass to access your cell’s views. Add outlets to your subclass and connect those outlets to the corresponding views in your prototype cell.\n\nIn the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDataSource\/tableView(_:cellForRowAt:)] method of your data source, use your cell’s outlets to assign values to any views.\n\n### Change the height of rows\n\nA table view tracks the height of rows separately from the cells that represent them. [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView] provides default sizes for rows, but you can override the default height by assigning a custom value to the table view’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView\/rowHeight] property. Always use this property when the height of all of your rows is the same. Doing so is more efficient than returning the height values from your delegate object.\n\nIf the row heights aren’t all the same, or can change dynamically, provide the heights using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDelegate\/tableView(_:heightForRowAt:)] method of your delegate object. When you implement this method, you must provide values for every row in your table. The following example code shows how to return a custom height for the first row of each section and use the default height for all other rows.\n\nThe table view asks for the heights of visible rows only. As the user scrolls, the table view asks you to provide the height for each row as it appears, including when it moves offscreen and then back onscreen.\n\n### Restore your cell’s original appearance before reuse\n\nWhen a cell moves offscreen, the table view removes it from its view hierarchy and places it in an internally managed recycling queue. When you request a new cell using the table view’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView\/dequeueReusableCell(withIdentifier:for:)] method, the table view returns cells from the recycling queue first. If the queue is empty, the table view instantiates a new cell from your storyboard.\n\nIf you change the appearance of your custom cell’s views, implement the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/prepareForReuse()] method of your cell subclass. In your implementation, return the appearance of your cell’s views to their original state. For example, if you change the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIView\/alpha] property of a view in your cell, return that property to its original value. You don’t need to clear label text, set images to `nil`, or do anything that would be corrected by your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDataSource\/tableView(_:cellForRowAt:)] method when configuring the cell for display.\n\n### Add an accessory view to your cell\n\nAn accessory view is an optional, system-defined view that appears at the trailing edge of a cell. You use accessory views to communicate standard cell behaviors to users. For example, you add a detail button to let the user know that tapping the row displays more information about the row.\n\nTo configure an accessory view:\n\nUsers expect accessory views to have specific behaviors when tapped. For information about how to implement those behaviors, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/AccessoryType-swift.enum].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/configuring-the-cells-for-your-table\ncrawled: 2025-12-03T18:48:11Z\n---\n\n# Configuring the cells for your table\n\n**Article**\n\nSpecify the appearance and content of your table’s rows by defining one or more prototype cells in your storyboard.\n\n## Overview\n\nCells provide the visual representation of your table’s rows. For most tables, you provide only one or two different types of cells. Design your cells to ensure that the most important information stands out. Do that using a careful choice of views and view configurations in your cells.\n\nYou specify the appearance of cells at design time in your storyboard file. Xcode provides one prototype cell for each table, and you can add more prototype cells as needed. A prototype cell acts a template for your cell’s appearance. It includes the views you want to display and their arrangement within the content area of the cell. At runtime, the table’s data source object creates actual cells from the prototypes and configures them with your app’s data.\n\n\n\nFor tips on how to design the appearance of your cells, see [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/components\/layout-and-organization\/lists-and-tables].\n\n### Assign a reuse identifier to each cell\n\nReuse identifiers facilitate the creation and recycling of your table’s cells. A reuse identifier is a string that you assign to each prototype cell of your table. In your storyboard, select your prototype cell and assign a nonempty value to its identifier attribute. Each cell in a table view must have a unique reuse identifier.\n\nWhen you need a cell object at runtime, call the table view’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView\/dequeueReusableCell(withIdentifier:for:)] method, passing the reuse identifier for the cell you want. The table view maintains an internal queue of already-created cells. If the queue contains a cell of the requested type, the table view returns that cell. If not, it creates a new cell using the prototype cell in your storyboard. Reusing cells improves performance by minimizing memory allocations during critical times, such as during scrolling.\n\n```swift\nvar cell = tableView.dequeueReusableCell(withIdentifier: \"myCellType\", for: indexPath)\n```\n\n### Configure a cell with a built-in style\n\nThe simplest way to configure a cell is to use one of the built-in styles provided by [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell]. You use these styles as is; you don’t need to provide a custom subclass to manage the cell. Each style incorporates one or two labels, with the style determining the positions of the labels within the cell’s content area. Most of the styles also incorporate an image at the leading edge of the cell’s content.\n\nTo configure a prototype cell with one of the standard styles, select the cell in your storyboard and set the cell’s Style property to a value other than custom.\n\n\n\nIn your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDataSource\/tableView(_:cellForRowAt:)] method, configure the content of your cell using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/textLabel], [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/detailTextLabel], and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/imageView] properties of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell]. Those properties contain views, but the cell object only assigns a view if the style supports the corresponding content. For example, the Basic cell style doesn’t support a detail string, so the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/detailTextLabel] property is `nil` for that style. The following example code shows how to configure a cell that uses the basic cell style.\n\n```swift\noverride func tableView(_ tableView: UITableView, \n             cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n   \/\/ Reuse or create a cell. \n   let cell = tableView.dequeueReusableCell(withIdentifier: \"basicStyle\", for: indexPath)\n\n   \/\/ For a standard cell, use the UITableViewCell properties.\n   cell.textLabel!.text = \"Title text\"\n   cell.imageView!.image = UIImage(named: \"bunny\")\n   return cell\n}\n```\n\n### Configure a cell with custom views\n\nFor appearances other than the standard styles, use the custom cell style. With a custom cell, you specify the views you want in the cell, their configurations, and their sizes and positions. Static views such as labels and images make the best content for cells. Avoid views that require user interactions such as controls. Don’t include scroll views, table views, collection views, or other complex container views in cells. You may include stack views in your cells, but minimize the number of items in your stack view to improve performance.\n\nTo configure a custom cell, drag views into the prototype cell for your table. The following illustration shows a cell with a custom layout and formatting for its views. You use constraints to position your views within the cell’s content area. When setting up constraints, use the “Constrain to margins” option to preserve the gap between the content areas of your cells.\n\n\n\nFor custom cells, you need to define a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell] subclass to access your cell’s views. Add outlets to your subclass and connect those outlets to the corresponding views in your prototype cell.\n\n```swift\nclass FoodCell: UITableViewCell {\n    @IBOutlet var name : UILabel?\n    @IBOutlet var plantDescription : UILabel?\n    @IBOutlet var picture : UIImageView?\n}\n```\n\nIn the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDataSource\/tableView(_:cellForRowAt:)] method of your data source, use your cell’s outlets to assign values to any views.\n\n```swift\noverride func tableView(_ tableView: UITableView, \n             cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n\n   \/\/ Reuse or create a cell of the appropriate type.\n   let cell = tableView.dequeueReusableCell(withIdentifier: \"foodCellType\", \n                         for: indexPath) as! FoodCell\n\n   \/\/ Fetch the data for the row.\n   let theFood = foods[indexPath.row]\n        \n   \/\/ Configure the cell’s contents with data from the fetched object.\n   cell.name?.text = theFood.name\n   cell.plantDescription?.text = theFood.description\n   cell.picture?.image = theFood.picture\n        \n   return cell\n}\n```\n\n### Change the height of rows\n\nA table view tracks the height of rows separately from the cells that represent them. [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView] provides default sizes for rows, but you can override the default height by assigning a custom value to the table view’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView\/rowHeight] property. Always use this property when the height of all of your rows is the same. Doing so is more efficient than returning the height values from your delegate object.\n\nIf the row heights aren’t all the same, or can change dynamically, provide the heights using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDelegate\/tableView(_:heightForRowAt:)] method of your delegate object. When you implement this method, you must provide values for every row in your table. The following example code shows how to return a custom height for the first row of each section and use the default height for all other rows.\n\n```swift\noverride func tableView(_ tableView: UITableView, \n           heightForRowAt indexPath: IndexPath) -> CGFloat {\n   \/\/ Make the first row larger to accommodate a custom cell.\n  if indexPath.row == 0 {\n      return 80\n   }\n\n   \/\/ Use the default size for all other rows.\n   return UITableView.automaticDimension\n}\n```\n\nThe table view asks for the heights of visible rows only. As the user scrolls, the table view asks you to provide the height for each row as it appears, including when it moves offscreen and then back onscreen.\n\n### Restore your cell’s original appearance before reuse\n\nWhen a cell moves offscreen, the table view removes it from its view hierarchy and places it in an internally managed recycling queue. When you request a new cell using the table view’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableView\/dequeueReusableCell(withIdentifier:for:)] method, the table view returns cells from the recycling queue first. If the queue is empty, the table view instantiates a new cell from your storyboard.\n\nIf you change the appearance of your custom cell’s views, implement the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/prepareForReuse()] method of your cell subclass. In your implementation, return the appearance of your cell’s views to their original state. For example, if you change the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIView\/alpha] property of a view in your cell, return that property to its original value. You don’t need to clear label text, set images to `nil`, or do anything that would be corrected by your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewDataSource\/tableView(_:cellForRowAt:)] method when configuring the cell for display.\n\n### Add an accessory view to your cell\n\nAn accessory view is an optional, system-defined view that appears at the trailing edge of a cell. You use accessory views to communicate standard cell behaviors to users. For example, you add a detail button to let the user know that tapping the row displays more information about the row.\n\nTo configure an accessory view:\n\n- In your storyboard, use the cell’s Accessory attribute to select the accessory view you want.\n- In your code, change the value of the cell’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/accessoryType-swift.property] property.\n\nUsers expect accessory views to have specific behaviors when tapped. For information about how to implement those behaviors, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITableViewCell\/AccessoryType-swift.enum].\n\n## Related Documentation\n\n- **Estimating the height of a table’s scrolling area**: Provide height estimates for your table view’s headers, footers, and rows to ensure that scrolling accurately reflects the size of your content.\n\n## Cells, headers, and footers\n\n- **Creating self-sizing table view cells**: Create table view cells that support Dynamic Type and use system spacing constraints to adjust the spacing surrounding text labels.\n- **Adding headers and footers to table sections**: Differentiate groups of rows visually by adding header and footer views to your table view’s sections.\n- **UITableViewCell**: The visual representation of a single row in a table view.\n- **UITableViewHeaderFooterView**: A reusable view that you place at the top or bottom of a table section to display additional information for that section.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Provide height estimates for your table view’s headers, footers, and rows to ensure that scrolling accurately reflects the size of your content.",
          "name" : "Estimating the height of a table’s scrolling area",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/estimating-the-height-of-a-table-s-scrolling-area"
        }
      ],
      "title" : "Related Documentation"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create table view cells that support Dynamic Type and use system spacing constraints to adjust the spacing surrounding text labels.",
          "name" : "Creating self-sizing table view cells",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/creating-self-sizing-table-view-cells"
        },
        {
          "description" : "Differentiate groups of rows visually by adding header and footer views to your table view’s sections.",
          "name" : "Adding headers and footers to table sections",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/adding-headers-and-footers-to-table-sections"
        },
        {
          "description" : "The visual representation of a single row in a table view.",
          "name" : "UITableViewCell",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UITableViewCell"
        },
        {
          "description" : "A reusable view that you place at the top or bottom of a table section to display additional information for that section.",
          "name" : "UITableViewHeaderFooterView",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UITableViewHeaderFooterView"
        }
      ],
      "title" : "Cells, headers, and footers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Configuring the cells for your table",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/configuring-the-cells-for-your-table"
}