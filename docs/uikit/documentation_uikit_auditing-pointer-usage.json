{
  "abstract" : "Ensure that the pointers in your code are safe for the 64-bit runtime.",
  "codeExamples" : [
    {
      "code" : "int *c = something passed in as an argument....\n\nint *d = (int *)((int)c + 4); \/\/ Incorrect.\n\nint *d = c + 1;               \/\/ Correct.",
      "language" : "objc"
    },
    {
      "code" : "\/\/ Incorrect.\nuint32_t *x = (uint32_t *)malloc(4);\n\n\/\/ Correct.\nuint32_t *x = (uint32_t *)malloc(sizeof(uint32_t));",
      "language" : "objc"
    },
    {
      "code" : "#include <inttypes.h>\nvoid *foo;\nintptr_t k = (intptr_t) foo;\nvoid *ptr = &k;\n\nprintf(\"The value of k is %\" PRIdPTR \"\\n\", k);\nprintf(\"The value of ptr is %p\\n\", ptr);",
      "language" : "objc"
    }
  ],
  "contentHash" : "14a82e019b93456fcdd2f216dc50eba8d2ad63c57ed24dfed1d5aa0fef4158fa",
  "crawledAt" : "2025-12-04T10:10:16Z",
  "id" : "DA12EF2F-DF55-495E-81F3-DAF663DBC395",
  "kind" : "article",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nPointers reference objects and other data in memory and are used often in C and Objective-C for passing objects to functions or manipulating the contents of memory. When you update from 32-bit to 64-bit architecture, the pointers in your code double in size, with implications throughout the code. Any assumptions that you make about pointer sizes can lead to undefined behavior, memory corruption, or crashes.\n\nTo review your code for proper pointer usage, look for areas where a pointer is being cast, or coerced, to another type. Avoid casting pointers to other types, such as integers. If you print the values of pointers using functions such as `NSLog` or `printf,` use properly prescribed macros in your format string to ensure that values are displayed correctly.\n\n### Cast pointers to integers selectively\n\nWhen you cast pointers to an integer type, use pointer types consistently to ensure that all of your variables are large enough to hold an address.\n\nThe code below casts a pointer to an `int` type to perform arithmetic on the address. In the 32-bit runtime, this code works because an `int` type and a pointer are the same size. However, in the 64-bit runtime, a pointer is larger than an `int` type, so the assignment loses some of the pointer’s data. To address this, remove the casts. The compiler-generated code now advances the pointer correctly.\n\nIf you must cast a pointer to an integer type, always use the `uintptr_t` type to avoid truncation. Note that modifying pointer values through integer math and then converting them back into a pointer can violate basic type aliasing rules. This can lead to unexpected behavior from the compiler as well as processor faults when a misaligned pointer is accessed.\n\n### Allocate memory using sizeof\n\nAlways use `sizeof` to obtain the correct size for any structure or variable you allocate. Never call `malloc` with an explicit size to allocate space for a variable.\n\nSearch your code for any instance of `malloc` that isn’t followed by `sizeof`.\n\n### Access Objective-C internal structures using approved methods\n\nIf you have code that directly accesses an object’s `isa` field, that code fails when executing in the 64-bit runtime, because the `isa` field no longer holds a pointer. Instead, it includes some pointer data and uses the remaining bits to hold other runtime information.\n\nTo read an object’s `isa` field, use the class property or call the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/object_getClass(_:)] function instead. To write to an object’s `isa` field, call the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/object_setClass(_:_:)] function.\n\n### Update format strings\n\nPrint functions, such as `printf`, can be difficult to write when your code has to support both the 32-bit and 64-bit runtimes, because the data types change from one runtime to the other. To solve this problem for standard types and pointer-sized integers, use the various macros listed in the following tables.\n\nThis example code prints an `intptr_t` variable (a pointer-sized integer) and a pointer.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/auditing-pointer-usage\ncrawled: 2025-12-04T10:10:16Z\n---\n\n# Auditing pointer usage\n\n**Article**\n\nEnsure that the pointers in your code are safe for the 64-bit runtime.\n\n## Overview\n\nPointers reference objects and other data in memory and are used often in C and Objective-C for passing objects to functions or manipulating the contents of memory. When you update from 32-bit to 64-bit architecture, the pointers in your code double in size, with implications throughout the code. Any assumptions that you make about pointer sizes can lead to undefined behavior, memory corruption, or crashes.\n\nTo review your code for proper pointer usage, look for areas where a pointer is being cast, or coerced, to another type. Avoid casting pointers to other types, such as integers. If you print the values of pointers using functions such as `NSLog` or `printf,` use properly prescribed macros in your format string to ensure that values are displayed correctly.\n\n### Cast pointers to integers selectively\n\nWhen you cast pointers to an integer type, use pointer types consistently to ensure that all of your variables are large enough to hold an address.\n\nThe code below casts a pointer to an `int` type to perform arithmetic on the address. In the 32-bit runtime, this code works because an `int` type and a pointer are the same size. However, in the 64-bit runtime, a pointer is larger than an `int` type, so the assignment loses some of the pointer’s data. To address this, remove the casts. The compiler-generated code now advances the pointer correctly.\n\n```objc\nint *c = something passed in as an argument....\n\nint *d = (int *)((int)c + 4); \/\/ Incorrect.\n\nint *d = c + 1;               \/\/ Correct.\n```\n\nIf you must cast a pointer to an integer type, always use the `uintptr_t` type to avoid truncation. Note that modifying pointer values through integer math and then converting them back into a pointer can violate basic type aliasing rules. This can lead to unexpected behavior from the compiler as well as processor faults when a misaligned pointer is accessed.\n\n### Allocate memory using sizeof\n\nAlways use `sizeof` to obtain the correct size for any structure or variable you allocate. Never call `malloc` with an explicit size to allocate space for a variable.\n\n```objc\n\/\/ Incorrect.\nuint32_t *x = (uint32_t *)malloc(4);\n\n\/\/ Correct.\nuint32_t *x = (uint32_t *)malloc(sizeof(uint32_t));\n```\n\nSearch your code for any instance of `malloc` that isn’t followed by `sizeof`.\n\n### Access Objective-C internal structures using approved methods\n\nIf you have code that directly accesses an object’s `isa` field, that code fails when executing in the 64-bit runtime, because the `isa` field no longer holds a pointer. Instead, it includes some pointer data and uses the remaining bits to hold other runtime information.\n\nTo read an object’s `isa` field, use the class property or call the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/object_getClass(_:)] function instead. To write to an object’s `isa` field, call the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/object_setClass(_:_:)] function.\n\n\n\n### Update format strings\n\nPrint functions, such as `printf`, can be difficult to write when your code has to support both the 32-bit and 64-bit runtimes, because the data types change from one runtime to the other. To solve this problem for standard types and pointer-sized integers, use the various macros listed in the following tables.\n\n\n\n\n\nThis example code prints an `intptr_t` variable (a pointer-sized integer) and a pointer.\n\n```objc\n#include <inttypes.h>\nvoid *foo;\nintptr_t k = (intptr_t) foo;\nvoid *ptr = &k;\n\nprintf(\"The value of k is %\" PRIdPTR \"\\n\", k);\nprintf(\"The value of ptr is %p\\n\", ptr);\n```\n\n## Memory and pointer access\n\n- **Updating data structures**: Review your app’s data design and update it to conform with 64-bit architecture.\n- **Managing functions and function pointers**: Ensure that your code correctly handles functions, function pointers, and Objective-C messages.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Review your app’s data design and update it to conform with 64-bit architecture.",
          "name" : "Updating data structures",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/updating-data-structures"
        },
        {
          "description" : "Ensure that your code correctly handles functions, function pointers, and Objective-C messages.",
          "name" : "Managing functions and function pointers",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/managing-functions-and-function-pointers"
        }
      ],
      "title" : "Memory and pointer access"
    }
  ],
  "source" : "appleJSON",
  "title" : "Auditing pointer usage",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/auditing-pointer-usage"
}