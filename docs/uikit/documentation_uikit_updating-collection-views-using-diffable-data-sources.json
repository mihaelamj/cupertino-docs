{
  "abstract" : "Streamline the display and update of data in a collection view using a diffable data source that contains identifiers.",
  "codeExamples" : [
    {
      "code" : "private var recipeListDataSource: UICollectionViewDiffableDataSource<RecipeListSection, Recipe.ID>!",
      "language" : "swift"
    },
    {
      "code" : "private enum RecipeListSection: Int {\n    case main\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Recipe: Identifiable, Codable {\n    var id: Int\n    var title: String\n    var prepTime: Int   \/\/ In seconds.\n    var cookTime: Int   \/\/ In seconds.\n    var servings: String\n    var ingredients: String\n    var directions: String\n    var isFavorite: Bool\n    var collections: [String]\n    fileprivate var addedOn: Date? = Date()\n    fileprivate var imageNames: [String]\n}",
      "language" : "swift"
    },
    {
      "code" : "private func configureDataSource() {\n    \/\/ Create a cell registration that the diffable data source will use.\n    let recipeCellRegistration = UICollectionView.CellRegistration<UICollectionViewListCell, Recipe> { cell, indexPath, recipe in\n        var contentConfiguration = UIListContentConfiguration.subtitleCell()\n        contentConfiguration.text = recipe.title\n        contentConfiguration.secondaryText = recipe.subtitle\n        contentConfiguration.image = recipe.smallImage\n        contentConfiguration.imageProperties.cornerRadius = 4\n        contentConfiguration.imageProperties.maximumSize = CGSize(width: 60, height: 60)\n        \n        cell.contentConfiguration = contentConfiguration\n        \n        if recipe.isFavorite {\n            let image = UIImage(systemName: \"heart.fill\")\n            let accessoryConfiguration = UICellAccessory.CustomViewConfiguration(customView: UIImageView(image: image),\n                                                                                 placement: .trailing(displayed: .always),\n                                                                                 tintColor: .secondaryLabel)\n            cell.accessories = [.customView(configuration: accessoryConfiguration)]\n        } else {\n            cell.accessories = []\n        }\n    }\n\n    \/\/ Create the diffable data source and its cell provider.\n    recipeListDataSource = UICollectionViewDiffableDataSource(collectionView: collectionView) {\n        collectionView, indexPath, identifier -> UICollectionViewCell in\n        \/\/ `identifier` is an instance of `Recipe.ID`. Use it to\n        \/\/ retrieve the recipe from the backing data store.\n        let recipe = dataStore.recipe(with: identifier)!\n        return collectionView.dequeueConfiguredReusableCell(using: recipeCellRegistration, for: indexPath, item: recipe)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func loadRecipeData() {\n    \/\/ Retrieve the list of recipe identifiers determined based on a\n    \/\/ selected sidebar item such as All Recipes or Favorites.\n    guard let recipeIds = recipeSplitViewController.selectedRecipes?.recipeIds()\n    else { return }\n    \n    \/\/ Update the collection view by adding the recipe identifiers to\n    \/\/ a new snapshot, and apply the snapshop to the diffable data source.\n    var snapshot = NSDiffableDataSourceSnapshot<RecipeListSection, Recipe.ID>()\n    snapshot.appendSections([.main])\n    snapshot.appendItems(recipeIds, toSection: .main)\n    recipeListDataSource.applySnapshotUsingReloadData(snapshot)\n}",
      "language" : "swift"
    },
    {
      "code" : "NotificationCenter.default.addObserver(\n    self,\n    selector: #selector(selectedRecipesDidChange(_:)),\n    name: .selectedRecipesDidChange,\n    object: nil\n)",
      "language" : "swift"
    },
    {
      "code" : "@objc\nprivate func selectedRecipesDidChange(_ notification: Notification) {\n    \/\/ Create a snapshot of the selected recipe identifiers from the notification's\n    \/\/ `userInfo` dictionary, and apply it to the diffable data source.\n    guard\n        let userInfo = notification.userInfo,\n        let selectedRecipeIds = userInfo[NotificationKeys.selectedRecipeIds] as? [Recipe.ID]\n    else { return }\n    \n    var snapshot = NSDiffableDataSourceSnapshot<RecipeListSection, Recipe.ID>()\n    snapshot.appendSections([.main])\n    snapshot.appendItems(selectedRecipeIds, toSection: .main)\n    recipeListDataSource.apply(snapshot, animatingDifferences: true)\n\n    \/\/ The design of this sample app makes it possible for the selected\n    \/\/ recipe displayed in the secondary (detail) view controller to exist\n    \/\/ in the new snapshot but not exist in the collection view prior to\n    \/\/ applying the snapshot. For instance, while displaying the list of\n    \/\/ favorite recipes, a person can unfavorite the selected recipe by tapping\n    \/\/ the `isFavorite` button. This removes the selected recipe from the\n    \/\/ favorites list. Tap the button again and the recipe reappears in the\n    \/\/ list. In this scenario, the app needs to re-select the recipe so it\n    \/\/ appears as selected in the collection view.\n    selectRecipeIfNeeded()\n}",
      "language" : "swift"
    },
    {
      "code" : "NotificationCenter.default.addObserver(\n    self,\n    selector: #selector(recipeDidChange(_:)),\n    name: .recipeDidChange,\n    object: nil\n)",
      "language" : "swift"
    },
    {
      "code" : "@objc\nprivate func recipeDidChange(_ notification: Notification) {\n    guard\n        \/\/ Get `recipeId` from from the `userInfo` dictionary.\n        let userInfo = notification.userInfo,\n        let recipeId = userInfo[NotificationKeys.recipeId] as? Recipe.ID,\n        \/\/ Confirm that the data source contains the recipe.\n        recipeListDataSource.indexPath(for: recipeId) != nil\n    else { return }\n    \n    \/\/ Get the diffable data source's current snapshot.\n    var snapshot = recipeListDataSource.snapshot()\n    \/\/ Update the recipe's data displayed in the collection view.\n    snapshot.reconfigureItems([recipeId])\n    recipeListDataSource.apply(snapshot, animatingDifferences: true)\n}",
      "language" : "swift"
    },
    {
      "code" : "private struct SidebarItem: Hashable {\n    let title: String\n    let type: SidebarItemType\n    \n    enum SidebarItemType {\n        case standard, collection, expandableHeader\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func createSnapshotOfStandardItems() -> NSDiffableDataSourceSectionSnapshot<SidebarItem> {\n    let items = [\n        SidebarItem(title: StandardSidebarItem.all.rawValue, type: .standard),\n        SidebarItem(title: StandardSidebarItem.favorites.rawValue, type: .standard),\n        SidebarItem(title: StandardSidebarItem.recents.rawValue, type: .standard)\n    ]\n    return createSidebarItemSnapshot(.standardItems, items: items)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "5cf7ed0ad91b3ca9225f280711591b1d9e4ce115817dcfef0beaf4714594a251",
  "crawledAt" : "2025-12-02T15:34:22Z",
  "id" : "C462987F-86F6-49E8-9F37-88441762352F",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nA *collection view* presents data in the form of sections and items, and an app that displays data in a collection view inserts those sections and items into the view. The app may also need to handle deleting or moving sections and items. For instance, the sample app in this project displays recipes in a collection view, and people using the app can add and delete recipes, and mark recipes as favorites. To support these actions, the sample app handles inserting, deleting, moving, and updating data within a collection view.\n\nWhen populating a collection view in an app, you can create a custom data source that adopts the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDataSource] protocol. To keep the information in the collection view current, you determine what data changed and perform a batch update based on those changes, a process that requires careful coordination of inserts, deletes, and moves.\n\nTo avoid the complexity of that process, the sample app uses a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa] object. A *diffable data source* stores a list of section and item *identifiers*, which represents the identity of each section and item contained in a collection view. These identifiers are stable, meaning they don’t change. In contrast, a custom data source that conforms to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDataSource] uses *indices* and *index paths*, which aren’t stable. They represent the location of sections and items, which can change as the data source adds, removes, and rearranges the contents of a collection view. However, with identifiers a diffable data source can refer to a section or item without knowledge of its location within a collection view.\n\nTo use a value as an identifier, its data type must conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable] protocol. Hashing allows data collections such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/Set], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Dictionary], and snapshots — instances of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSectionSnapshot-swift.struct] — to use values as keys, providing quick and efficient lookups. Hashable types also conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable] protocol, so your identifiers must properly implement equality. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable]`.`\n\nBecause identifiers are hashable and equatable, a diffable data source can determine the differences between its current snapshot and another snapshot. Then it can insert, delete, and move sections and items within a collection view for you based on those differences, eliminating the need for custom code that performs batch updates.\n\n### Define the diffable data source\n\nIn this sample project, `RecipeListViewController` displays a list of recipes in a collection view. Before the controller can display the recipes, it defines an instance variable to store a diffable data source.\n\n`RecipeListViewController` declares `recipeListDataSource` with `RecipeListSection` as the section identifier type, and `Recipe.ID` as the item identifier type. These identifier types tell the data source the type of values it contains.\n\nFor the section identifier type, `recipeListDataSource` uses `RecipeListSection`, an enumeration with a raw value of type [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int] (in Swift, `Int` is hashable). Each enumeration case identifies a section of the collection view. In the sample, there’s only one section, `main`, which displays a list of recipes.\n\nFor the item identifier type, `recipeListDataSource` uses `Recipe.ID`. This type comes from the `Recipe` structure, defined as:\n\nThis structure conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable] protocol, which requires the structure to include an [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable\/id-8t2ws] property. By conforming to `Identifiable`, the `Recipe` structure automatically exposes the associated type [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable\/ID-swift.associatedtype], which is a type determined based on the declaration of the `id` property in the structure. And because this type must be hashable, the sample app can use `Recipe.ID` as the item identifier type.\n\nUsing the `Recipe.ID` as the item identifier type for the `recipeListDataSource` means that the data source, and any snapshots applied to it, contains only `Recipe.ID` values and not the complete recipe data. This approach optimizes the diffable data source for peak performance when displaying recipes in a collection view because the identifier type is a simple, hashable type.\n\n### Configure the diffable data source\n\nBefore populating a collection view with data from a diffable data source, the sample app configures the data source. The app creates an instance of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa] and sets its *cell provider*, a closure that configures and returns a cell for the collection view.\n\n`RecipeListViewController` configures `recipeListDataSource` in a helper method named `configureDataSource()`. The view controller calls this method in its [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIViewController\/viewDidLoad()] method.\n\nThe `configureDataSource()` method creates a cell registration and provides a handler closure that configures each cell with data from a recipe. The closure receives an instance of `Recipe`, which it uses to configure the cell.\n\nNext, `configureDataSource()` creates an instance of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa] and defines the cell provider closure. The closure receives the identifier of a recipe. It then retrieves the recipe from the backing data store (using the identifier) and passes the recipe structure to the cell registration’s handler closure.\n\n### Load the diffable data source with identifiers\n\nWith the diffable data source configured, `RecipeListViewController` calls its helper method `loadRecipeData()` to perform an initial load of data into the data source, which in turn populates a collection view with recipes. This method retrieves a list of recipe identifiers and creates an instance of  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct]. Then it adds the `main` section and recipe identifiers to the snapshot. Lastly, the method calls [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/applySnapshotUsingReloadData(_:)] to apply the snapshot to the data source, resetting the collection view to reflect the state of the data in the snapshot without computing a diff or animating the changes.\n\n### Insert, delete, and move items\n\nPeople using the sample app can make two types of changes to the recipe data:\n\nTo handle changes to a data collection, the app creates a new snapshot that represents the current state of the data collection and applies it to the diffable data source. The data source compares its current snapshot with the new snapshot to determine the changes. Then it performs the necessary inserts, deletes, and moves into the collection view based on those changes.\n\nWhile a diffable data source can determine the changes between its current snapshot and a new one, it doesn’t monitor the data collection for changes. Instead, it’s the responsibility of the app to detect data changes and tell the diffable data source about those changes, by applying a new snapshot.\n\nTo inform other parts of the app that the list of recipes changed — for instance, after someone adds or removes a recipe — the sample uses a notification center to send a `selectedRecipesDidChange` notification. To receive the notification, `RecipeListViewController` adds a notification observer with `selectedRecipesDidChange(_:)` as its selector.\n\n`selectedRecipesDidChange(_:)` is similar to `loadRecipeData()` but it uses [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/apply(_:animatingDifferences:)] to apply the list of selected recipe identifiers that the notification provides instead of using [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/applySnapshotUsingReloadData(_:)]. The [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/apply(_:animatingDifferences:)] method performs incremental updates to the collection view instead of entirely resetting the data displayed. And because `animatingDifferences` is `true`, the collection view animates the changes as they appear.\n\n### Update existing items\n\nTo handle changes to the properties of an existing item, an app retrieves the current snapshot from the diffable data source and calls either [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reconfigureItems(_:)] or [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reloadItems(_:)] on the snapshot. Then it applies the snapshot to the diffable data source, which updates the display of the specified items.\n\nAgain, the app, not the diffable data source, detects the data changes.\n\nTo tell others parts of the app about a change to a recipe — for instance, when a person marks a recipe as a favorite — the sample sends a `recipeDidChange` notification. `RecipeListViewController` receives the notification using an observer with `recipeDidChange(_:)` as the selector.\n\nThe `recipeDidChange` notification indicates that data for a single recipe changed. Because only one recipe changed, there’s no need to update the entire list of recipes shown in the collection view. Instead, the sample only updates the cell that displays the recipe that changed. For instance, when a person marks a recipe as a favorite, an icon of a heart appears beside that recipe. And when the person unmarks the recipe as a favorite, the heart disappears.\n\nTo update the cell with the latest recipe data, the `recipeDidChange(_:)` method confirms that the diffable data source contains the recipe identifier that the notification provides. Then the method retrieves the current snapshot from the data source and calls [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reconfigureItems(_:)], passing in the recipe identifier. This call tells the data source to update the data displayed in the cell identified by the recipe identifier. Finally, `recipeDidChange(_:)` applies the updated snapshot to the data source.\n\nThe diffable data source compares the updated snapshot to its current snapshot and applies the difference — in this instance, a request to reconfigure the item that displays the recipe that changed. To fulfill the request, the data source invokes its cell provider closure, which retrieves the updated recipe and configures the cell with the latest recipe data. And because `animatingDifferences` is `true` when applying the snapshot, the collection view animates the visual change of the cell by showing or hiding the heart icon.\n\n### Populate snapshots with lightweight data structures\n\nAn alternative approach to storing identifiers involves populating diffable data sources and snapshots with lightweight data structures. While the data structure approach is convenient and can be a good fit in some circumstances — like for quick prototyping, or displaying a collection of static items with properties that don’t change — it carries significant limitations and tradeoffs. For instance, the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable] implementations must incorporate all properties of the structure that can change. Any changes to the data in the structure cause it to no longer be equal to the previous version, which the diffable data source uses to determine what changed when applying a new snapshot.\n\nThe sample uses this approach to show items in a sidebar. In `SidebarViewController`, the custom structure `SidebarItem` defines the properties of a sidebar item, which are `title` and `type`.\n\nThe combination of these properties determine the hashing value for each sidebar item, and because the property values don’t change, populating the snapshot with this `SidebarItem` structure instead of identifiers is an acceptable use case.\n\nThe downside of this approach is that the diffable data source can no longer track identity. Any time an existing item changes, the diffable data source sees the change as a delete of the old item and an insert of a new item. As a result, the collection view loses important state tied to the item. For instance, a selected item becomes unselected when any property of the item changes because, from the diffable data source’s perspective, the app deleted the item and added a new one to take its place.\n\nAlso, if `animatingDifferences` is `true` when applying the snapshot, every change requires the process of animating out the old cell and animating in a new cell, which can be detrimental to performance and cause loss of UI state, including animations, within the cell.\n\nAdditionally, this strategy precludes using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reconfigureItems(_:)] or [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reloadItems(_:)] methods when populating a snapshot with data structures, because those methods require the use of proper identifiers. The only mechanism to update the data for existing items is to apply a new snapshot containing the new data structures, which causes the diffable data source to perform a delete and an insert for each changed item.\n\nStoring data structures directly into diffable data sources and snapshots isn’t a robust solution for many real-world use cases because the data source loses the ability to track identity. Only use this approach for simple use cases in which items don’t change, like the sidebar items in this sample, or when the identity of an item isn’t important. For all other use cases, or when in doubt as to which approach to use, populate diffable data sources and snapshots with proper identifiers.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/updating-collection-views-using-diffable-data-sources\ncrawled: 2025-12-02T15:34:22Z\n---\n\n# Updating collection views using diffable data sources\n\n**Sample Code**\n\nStreamline the display and update of data in a collection view using a diffable data source that contains identifiers.\n\n## Overview\n\nA *collection view* presents data in the form of sections and items, and an app that displays data in a collection view inserts those sections and items into the view. The app may also need to handle deleting or moving sections and items. For instance, the sample app in this project displays recipes in a collection view, and people using the app can add and delete recipes, and mark recipes as favorites. To support these actions, the sample app handles inserting, deleting, moving, and updating data within a collection view.\n\nWhen populating a collection view in an app, you can create a custom data source that adopts the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDataSource] protocol. To keep the information in the collection view current, you determine what data changed and perform a batch update based on those changes, a process that requires careful coordination of inserts, deletes, and moves.\n\nTo avoid the complexity of that process, the sample app uses a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa] object. A *diffable data source* stores a list of section and item *identifiers*, which represents the identity of each section and item contained in a collection view. These identifiers are stable, meaning they don’t change. In contrast, a custom data source that conforms to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDataSource] uses *indices* and *index paths*, which aren’t stable. They represent the location of sections and items, which can change as the data source adds, removes, and rearranges the contents of a collection view. However, with identifiers a diffable data source can refer to a section or item without knowledge of its location within a collection view.\n\n\n\nTo use a value as an identifier, its data type must conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable] protocol. Hashing allows data collections such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/Set], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Dictionary], and snapshots — instances of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSectionSnapshot-swift.struct] — to use values as keys, providing quick and efficient lookups. Hashable types also conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable] protocol, so your identifiers must properly implement equality. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable]`.`\n\nBecause identifiers are hashable and equatable, a diffable data source can determine the differences between its current snapshot and another snapshot. Then it can insert, delete, and move sections and items within a collection view for you based on those differences, eliminating the need for custom code that performs batch updates.\n\n\n\n### Define the diffable data source\n\nIn this sample project, `RecipeListViewController` displays a list of recipes in a collection view. Before the controller can display the recipes, it defines an instance variable to store a diffable data source.\n\n```swift\nprivate var recipeListDataSource: UICollectionViewDiffableDataSource<RecipeListSection, Recipe.ID>!\n```\n\n`RecipeListViewController` declares `recipeListDataSource` with `RecipeListSection` as the section identifier type, and `Recipe.ID` as the item identifier type. These identifier types tell the data source the type of values it contains.\n\nFor the section identifier type, `recipeListDataSource` uses `RecipeListSection`, an enumeration with a raw value of type [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int] (in Swift, `Int` is hashable). Each enumeration case identifies a section of the collection view. In the sample, there’s only one section, `main`, which displays a list of recipes.\n\n```swift\nprivate enum RecipeListSection: Int {\n    case main\n}\n```\n\nFor the item identifier type, `recipeListDataSource` uses `Recipe.ID`. This type comes from the `Recipe` structure, defined as:\n\n```swift\nstruct Recipe: Identifiable, Codable {\n    var id: Int\n    var title: String\n    var prepTime: Int   \/\/ In seconds.\n    var cookTime: Int   \/\/ In seconds.\n    var servings: String\n    var ingredients: String\n    var directions: String\n    var isFavorite: Bool\n    var collections: [String]\n    fileprivate var addedOn: Date? = Date()\n    fileprivate var imageNames: [String]\n}\n```\n\nThis structure conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable] protocol, which requires the structure to include an [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable\/id-8t2ws] property. By conforming to `Identifiable`, the `Recipe` structure automatically exposes the associated type [doc:\/\/com.apple.documentation\/documentation\/Swift\/Identifiable\/ID-swift.associatedtype], which is a type determined based on the declaration of the `id` property in the structure. And because this type must be hashable, the sample app can use `Recipe.ID` as the item identifier type.\n\n\n\nUsing the `Recipe.ID` as the item identifier type for the `recipeListDataSource` means that the data source, and any snapshots applied to it, contains only `Recipe.ID` values and not the complete recipe data. This approach optimizes the diffable data source for peak performance when displaying recipes in a collection view because the identifier type is a simple, hashable type.\n\n### Configure the diffable data source\n\nBefore populating a collection view with data from a diffable data source, the sample app configures the data source. The app creates an instance of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa] and sets its *cell provider*, a closure that configures and returns a cell for the collection view.\n\n`RecipeListViewController` configures `recipeListDataSource` in a helper method named `configureDataSource()`. The view controller calls this method in its [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIViewController\/viewDidLoad()] method.\n\nThe `configureDataSource()` method creates a cell registration and provides a handler closure that configures each cell with data from a recipe. The closure receives an instance of `Recipe`, which it uses to configure the cell.\n\n\n\nNext, `configureDataSource()` creates an instance of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa] and defines the cell provider closure. The closure receives the identifier of a recipe. It then retrieves the recipe from the backing data store (using the identifier) and passes the recipe structure to the cell registration’s handler closure.\n\n```swift\nprivate func configureDataSource() {\n    \/\/ Create a cell registration that the diffable data source will use.\n    let recipeCellRegistration = UICollectionView.CellRegistration<UICollectionViewListCell, Recipe> { cell, indexPath, recipe in\n        var contentConfiguration = UIListContentConfiguration.subtitleCell()\n        contentConfiguration.text = recipe.title\n        contentConfiguration.secondaryText = recipe.subtitle\n        contentConfiguration.image = recipe.smallImage\n        contentConfiguration.imageProperties.cornerRadius = 4\n        contentConfiguration.imageProperties.maximumSize = CGSize(width: 60, height: 60)\n        \n        cell.contentConfiguration = contentConfiguration\n        \n        if recipe.isFavorite {\n            let image = UIImage(systemName: \"heart.fill\")\n            let accessoryConfiguration = UICellAccessory.CustomViewConfiguration(customView: UIImageView(image: image),\n                                                                                 placement: .trailing(displayed: .always),\n                                                                                 tintColor: .secondaryLabel)\n            cell.accessories = [.customView(configuration: accessoryConfiguration)]\n        } else {\n            cell.accessories = []\n        }\n    }\n\n    \/\/ Create the diffable data source and its cell provider.\n    recipeListDataSource = UICollectionViewDiffableDataSource(collectionView: collectionView) {\n        collectionView, indexPath, identifier -> UICollectionViewCell in\n        \/\/ `identifier` is an instance of `Recipe.ID`. Use it to\n        \/\/ retrieve the recipe from the backing data store.\n        let recipe = dataStore.recipe(with: identifier)!\n        return collectionView.dequeueConfiguredReusableCell(using: recipeCellRegistration, for: indexPath, item: recipe)\n    }\n}\n```\n\n### Load the diffable data source with identifiers\n\nWith the diffable data source configured, `RecipeListViewController` calls its helper method `loadRecipeData()` to perform an initial load of data into the data source, which in turn populates a collection view with recipes. This method retrieves a list of recipe identifiers and creates an instance of  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct]. Then it adds the `main` section and recipe identifiers to the snapshot. Lastly, the method calls [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/applySnapshotUsingReloadData(_:)] to apply the snapshot to the data source, resetting the collection view to reflect the state of the data in the snapshot without computing a diff or animating the changes.\n\n```swift\nprivate func loadRecipeData() {\n    \/\/ Retrieve the list of recipe identifiers determined based on a\n    \/\/ selected sidebar item such as All Recipes or Favorites.\n    guard let recipeIds = recipeSplitViewController.selectedRecipes?.recipeIds()\n    else { return }\n    \n    \/\/ Update the collection view by adding the recipe identifiers to\n    \/\/ a new snapshot, and apply the snapshop to the diffable data source.\n    var snapshot = NSDiffableDataSourceSnapshot<RecipeListSection, Recipe.ID>()\n    snapshot.appendSections([.main])\n    snapshot.appendItems(recipeIds, toSection: .main)\n    recipeListDataSource.applySnapshotUsingReloadData(snapshot)\n}\n```\n\n\n\n### Insert, delete, and move items\n\nPeople using the sample app can make two types of changes to the recipe data:\n\n- Changes to the collection of data itself, like adding or removing recipes, or reordering them.\n- Changes to the properties of existing items, like changing the name of a recipe or marking one as a favorite.\n\nTo handle changes to a data collection, the app creates a new snapshot that represents the current state of the data collection and applies it to the diffable data source. The data source compares its current snapshot with the new snapshot to determine the changes. Then it performs the necessary inserts, deletes, and moves into the collection view based on those changes.\n\nWhile a diffable data source can determine the changes between its current snapshot and a new one, it doesn’t monitor the data collection for changes. Instead, it’s the responsibility of the app to detect data changes and tell the diffable data source about those changes, by applying a new snapshot.\n\n\n\nTo inform other parts of the app that the list of recipes changed — for instance, after someone adds or removes a recipe — the sample uses a notification center to send a `selectedRecipesDidChange` notification. To receive the notification, `RecipeListViewController` adds a notification observer with `selectedRecipesDidChange(_:)` as its selector.\n\n```swift\nNotificationCenter.default.addObserver(\n    self,\n    selector: #selector(selectedRecipesDidChange(_:)),\n    name: .selectedRecipesDidChange,\n    object: nil\n)\n```\n\n`selectedRecipesDidChange(_:)` is similar to `loadRecipeData()` but it uses [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/apply(_:animatingDifferences:)] to apply the list of selected recipe identifiers that the notification provides instead of using [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/applySnapshotUsingReloadData(_:)]. The [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa\/apply(_:animatingDifferences:)] method performs incremental updates to the collection view instead of entirely resetting the data displayed. And because `animatingDifferences` is `true`, the collection view animates the changes as they appear.\n\n```swift\n@objc\nprivate func selectedRecipesDidChange(_ notification: Notification) {\n    \/\/ Create a snapshot of the selected recipe identifiers from the notification's\n    \/\/ `userInfo` dictionary, and apply it to the diffable data source.\n    guard\n        let userInfo = notification.userInfo,\n        let selectedRecipeIds = userInfo[NotificationKeys.selectedRecipeIds] as? [Recipe.ID]\n    else { return }\n    \n    var snapshot = NSDiffableDataSourceSnapshot<RecipeListSection, Recipe.ID>()\n    snapshot.appendSections([.main])\n    snapshot.appendItems(selectedRecipeIds, toSection: .main)\n    recipeListDataSource.apply(snapshot, animatingDifferences: true)\n\n    \/\/ The design of this sample app makes it possible for the selected\n    \/\/ recipe displayed in the secondary (detail) view controller to exist\n    \/\/ in the new snapshot but not exist in the collection view prior to\n    \/\/ applying the snapshot. For instance, while displaying the list of\n    \/\/ favorite recipes, a person can unfavorite the selected recipe by tapping\n    \/\/ the `isFavorite` button. This removes the selected recipe from the\n    \/\/ favorites list. Tap the button again and the recipe reappears in the\n    \/\/ list. In this scenario, the app needs to re-select the recipe so it\n    \/\/ appears as selected in the collection view.\n    selectRecipeIfNeeded()\n}\n```\n\n### Update existing items\n\nTo handle changes to the properties of an existing item, an app retrieves the current snapshot from the diffable data source and calls either [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reconfigureItems(_:)] or [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reloadItems(_:)] on the snapshot. Then it applies the snapshot to the diffable data source, which updates the display of the specified items.\n\nAgain, the app, not the diffable data source, detects the data changes.\n\nTo tell others parts of the app about a change to a recipe — for instance, when a person marks a recipe as a favorite — the sample sends a `recipeDidChange` notification. `RecipeListViewController` receives the notification using an observer with `recipeDidChange(_:)` as the selector.\n\n```swift\nNotificationCenter.default.addObserver(\n    self,\n    selector: #selector(recipeDidChange(_:)),\n    name: .recipeDidChange,\n    object: nil\n)\n```\n\nThe `recipeDidChange` notification indicates that data for a single recipe changed. Because only one recipe changed, there’s no need to update the entire list of recipes shown in the collection view. Instead, the sample only updates the cell that displays the recipe that changed. For instance, when a person marks a recipe as a favorite, an icon of a heart appears beside that recipe. And when the person unmarks the recipe as a favorite, the heart disappears.\n\nTo update the cell with the latest recipe data, the `recipeDidChange(_:)` method confirms that the diffable data source contains the recipe identifier that the notification provides. Then the method retrieves the current snapshot from the data source and calls [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reconfigureItems(_:)], passing in the recipe identifier. This call tells the data source to update the data displayed in the cell identified by the recipe identifier. Finally, `recipeDidChange(_:)` applies the updated snapshot to the data source.\n\n```swift\n@objc\nprivate func recipeDidChange(_ notification: Notification) {\n    guard\n        \/\/ Get `recipeId` from from the `userInfo` dictionary.\n        let userInfo = notification.userInfo,\n        let recipeId = userInfo[NotificationKeys.recipeId] as? Recipe.ID,\n        \/\/ Confirm that the data source contains the recipe.\n        recipeListDataSource.indexPath(for: recipeId) != nil\n    else { return }\n    \n    \/\/ Get the diffable data source's current snapshot.\n    var snapshot = recipeListDataSource.snapshot()\n    \/\/ Update the recipe's data displayed in the collection view.\n    snapshot.reconfigureItems([recipeId])\n    recipeListDataSource.apply(snapshot, animatingDifferences: true)\n}\n```\n\nThe diffable data source compares the updated snapshot to its current snapshot and applies the difference — in this instance, a request to reconfigure the item that displays the recipe that changed. To fulfill the request, the data source invokes its cell provider closure, which retrieves the updated recipe and configures the cell with the latest recipe data. And because `animatingDifferences` is `true` when applying the snapshot, the collection view animates the visual change of the cell by showing or hiding the heart icon.\n\n### Populate snapshots with lightweight data structures\n\nAn alternative approach to storing identifiers involves populating diffable data sources and snapshots with lightweight data structures. While the data structure approach is convenient and can be a good fit in some circumstances — like for quick prototyping, or displaying a collection of static items with properties that don’t change — it carries significant limitations and tradeoffs. For instance, the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable] implementations must incorporate all properties of the structure that can change. Any changes to the data in the structure cause it to no longer be equal to the previous version, which the diffable data source uses to determine what changed when applying a new snapshot.\n\nThe sample uses this approach to show items in a sidebar. In `SidebarViewController`, the custom structure `SidebarItem` defines the properties of a sidebar item, which are `title` and `type`.\n\n```swift\nprivate struct SidebarItem: Hashable {\n    let title: String\n    let type: SidebarItemType\n    \n    enum SidebarItemType {\n        case standard, collection, expandableHeader\n    }\n}\n```\n\nThe combination of these properties determine the hashing value for each sidebar item, and because the property values don’t change, populating the snapshot with this `SidebarItem` structure instead of identifiers is an acceptable use case.\n\n```swift\nprivate func createSnapshotOfStandardItems() -> NSDiffableDataSourceSectionSnapshot<SidebarItem> {\n    let items = [\n        SidebarItem(title: StandardSidebarItem.all.rawValue, type: .standard),\n        SidebarItem(title: StandardSidebarItem.favorites.rawValue, type: .standard),\n        SidebarItem(title: StandardSidebarItem.recents.rawValue, type: .standard)\n    ]\n    return createSidebarItemSnapshot(.standardItems, items: items)\n}\n```\n\nThe downside of this approach is that the diffable data source can no longer track identity. Any time an existing item changes, the diffable data source sees the change as a delete of the old item and an insert of a new item. As a result, the collection view loses important state tied to the item. For instance, a selected item becomes unselected when any property of the item changes because, from the diffable data source’s perspective, the app deleted the item and added a new one to take its place.\n\nAlso, if `animatingDifferences` is `true` when applying the snapshot, every change requires the process of animating out the old cell and animating in a new cell, which can be detrimental to performance and cause loss of UI state, including animations, within the cell.\n\nAdditionally, this strategy precludes using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reconfigureItems(_:)] or [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct\/reloadItems(_:)] methods when populating a snapshot with data structures, because those methods require the use of proper identifiers. The only mechanism to update the data for existing items is to apply a new snapshot containing the new data structures, which causes the diffable data source to perform a delete and an insert for each changed item.\n\nStoring data structures directly into diffable data sources and snapshots isn’t a robust solution for many real-world use cases because the data source loses the ability to track identity. Only use this approach for simple use cases in which items don’t change, like the sidebar items in this sample, or when the identity of an item isn’t important. For all other use cases, or when in doubt as to which approach to use, populate diffable data sources and snapshots with proper identifiers.\n\n## Data\n\n- **Implementing modern collection views**: Bring compositional layouts to your app and simplify updating your user interface with diffable data sources.\n- **Building high-performance lists and collection views**: Improve the performance of lists and collections in your app with prefetching and image preparation.\n- **UICollectionViewDiffableDataSource**: The object you use to manage data and provide cells for a collection view.\n- **UICollectionViewDataSource**: The methods adopted by the object you use to manage data and provide cells for a collection view.\n- **UICollectionViewDataSourcePrefetching**: A protocol that provides advance warning of the data requirements for a collection view, allowing the triggering of asynchronous data load operations.\n- **NSDiffableDataSourceSnapshot**: A representation of the state of the data in a view at a specific point in time.\n- **NSDiffableDataSourceSectionSnapshot**: A representation of the state of the data in a layout section at a specific point in time.\n- **UIRefreshControl**: A standard control that can initiate the refreshing of a scroll view’s contents.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Bring compositional layouts to your app and simplify updating your user interface with diffable data sources.",
          "name" : "Implementing modern collection views",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/implementing-modern-collection-views"
        },
        {
          "description" : "Improve the performance of lists and collections in your app with prefetching and image preparation.",
          "name" : "Building high-performance lists and collection views",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/building-high-performance-lists-and-collection-views"
        },
        {
          "description" : "The object you use to manage data and provide cells for a collection view.",
          "name" : "UICollectionViewDiffableDataSource",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewDiffableDataSource-9tqpa"
        },
        {
          "description" : "The methods adopted by the object you use to manage data and provide cells for a collection view.",
          "name" : "UICollectionViewDataSource",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewDataSource"
        },
        {
          "description" : "A protocol that provides advance warning of the data requirements for a collection view, allowing the triggering of asynchronous data load operations.",
          "name" : "UICollectionViewDataSourcePrefetching",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewDataSourcePrefetching"
        },
        {
          "description" : "A representation of the state of the data in a view at a specific point in time.",
          "name" : "NSDiffableDataSourceSnapshot",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSDiffableDataSourceSnapshot-swift.struct"
        },
        {
          "description" : "A representation of the state of the data in a layout section at a specific point in time.",
          "name" : "NSDiffableDataSourceSectionSnapshot",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSDiffableDataSourceSectionSnapshot-swift.struct"
        },
        {
          "description" : "A standard control that can initiate the refreshing of a scroll view’s contents.",
          "name" : "UIRefreshControl",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIRefreshControl"
        }
      ],
      "title" : "Data"
    }
  ],
  "source" : "appleJSON",
  "title" : "Updating collection views using diffable data sources",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/updating-collection-views-using-diffable-data-sources"
}