{
  "abstract" : "Lay out text in a custom-shaped container and apply glyph substitutions.",
  "codeExamples" : [
    {
      "code" : "override func lineFragmentRect(forProposedRect proposedRect: CGRect,\n                               at characterIndex: Int,\n                               writingDirection baseWritingDirection: NSWritingDirection,\n                               remaining remainingRect: UnsafeMutablePointer<CGRect>?) -> CGRect {\n    let rect = super.lineFragmentRect(forProposedRect: proposedRect,\n                                      at: characterIndex,\n                                      writingDirection: baseWritingDirection,\n                                      remaining: remainingRect)\n    let containerWidth = Float(size.width), containerHeight = Float(size.height)\n\n    let diameter = fminf(containerWidth, containerHeight)\n    let radius = diameter \/ 2.0\n    \n    \/\/ Vertical distance from the line center to the container center.\n    let yDistance = fabsf(Float(rect.origin.y + rect.size.height \/ 2.0) - radius)\n    \/\/ The new line width.\n    let width = (yDistance < radius) ? 2.0 * sqrt(radius * radius - yDistance * yDistance) : 0.0\n    \/\/ Horizontal distance from rect.origin.x to the starting point of the line.\n    let xOffset = (containerWidth > diameter) ? (containerWidth - diameter) \/ 2.0 : 0.0\n    \/\/ The starting x of the line.\n    let xPosition = CGFloat(xOffset + Float(rect.origin.x) + radius - width \/ 2.0)\n    return CGRect(x: xPosition, y: CGFloat(rect.origin.y), width: CGFloat(width), height: rect.size.height)\n}",
      "language" : "swift"
    },
    {
      "code" : "let textContainer = CircleTextContainer(size: .zero)\ntextContainer.widthTracksTextView = true\n\nlet layoutManager = NSLayoutManager()\nlayoutManager.addTextContainer(textContainer)\ntextStorage.addLayoutManager(layoutManager)\n\ntextView = UITextView(frame: CGRect.zero, textContainer: textContainer)",
      "language" : "swift"
    },
    {
      "code" : "let firstTextContainer = NSTextContainer()\nfirstTextContainer.widthTracksTextView = true\nfirstTextContainer.heightTracksTextView = true\n\nlet secondTextContainer = NSTextContainer()\nsecondTextContainer.widthTracksTextView = true\nsecondTextContainer.heightTracksTextView = true\nsecondTextContainer.lineBreakMode = .byTruncatingTail\n\nlet layoutManager = NSLayoutManager()\nlayoutManager.addTextContainer(firstTextContainer)\nlayoutManager.addTextContainer(secondTextContainer)\n\ntextStorage.addLayoutManager(layoutManager)\n\nlet firstTextView = UITextView(frame: .zero, textContainer: firstTextContainer)\nfirstTextView.isScrollEnabled = false\nview.addSubview(firstTextView)\n\nlet secondTextView = UITextView(frame: .zero, textContainer: secondTextContainer)\nsecondTextView.isScrollEnabled = false\nview.addSubview(secondTextView)",
      "language" : "swift"
    },
    {
      "code" : "textView.textContainer.exclusionPaths = [translatedCirclePath]",
      "language" : "swift"
    },
    {
      "code" : "layoutManager.invalidateGlyphs(forCharacterRange: endingWordsCharRange, changeInLength: 0,\n                               actualCharacterRange: nil)\nlayoutManager.invalidateLayout(forCharacterRange: endingWordsCharRange,\n                               actualCharacterRange: nil)",
      "language" : "swift"
    },
    {
      "code" : "let ellipsisStartIndex = ellipsisIntersection.location\nfor index in ellipsisStartIndex..<ellipsisStartIndex + ellipsisIntersection.length {\n    if index == ellipsisGlyphRange!.location {\n        finalGlyphs[index - glyphRange.location] = myGlyphs[0]\n    } else {\n        finalProps[index - glyphRange.location] = .controlCharacter\n    }\n}\nlet flexibleSpaceStartIndex = flexibleSpaceIntersection.location\nfor index in  flexibleSpaceStartIndex..<flexibleSpaceStartIndex + flexibleSpaceIntersection.length {\n    finalProps[index - glyphRange.location] = .controlCharacter\n}",
      "language" : "swift"
    },
    {
      "code" : "func layoutManager(_ layoutManager: NSLayoutManager, shouldUse action: NSLayoutManager.ControlCharacterAction,\n                   forControlCharacterAt charIndex: Int) -> NSLayoutManager.ControlCharacterAction {\n    if let flexibleSpaceGlyphRange = self.flexibleSpaceGlyphRange,\n        flexibleSpaceGlyphRange.contains(layoutManager.glyphIndexForCharacter(at: charIndex)) {\n        return .whitespace\n    }\n    return action\n}",
      "language" : "swift"
    },
    {
      "code" : "func layoutManager(_ layoutManager: NSLayoutManager,\n                   boundingBoxForControlGlyphAt glyphIndex: Int,\n                   for textContainer: NSTextContainer,\n                   proposedLineFragment proposedRect: CGRect,\n                   glyphPosition: CGPoint,\n                   characterIndex charIndex: Int) -> CGRect {\n    guard let flexibleSpaceGlyphRange = self.flexibleSpaceGlyphRange,\n        flexibleSpaceGlyphRange.contains(glyphIndex) else {\n        return CGRect(x: glyphPosition.x, y: glyphPosition.y, width: 0, height: proposedRect.height)\n    }\n    let padding = textContainer.lineFragmentPadding * 2\n    let width = proposedRect.width - (glyphPosition.x - proposedRect.minX) - padding\n    let rect = CGRect(x: glyphPosition.x, y: glyphPosition.y, width: width, height: proposedRect.height)\n    return rect\n}",
      "language" : "swift"
    },
    {
      "code" : "func layoutManager(_ layoutManager: NSLayoutManager,\n                   shouldSetLineFragmentRect lineFragmentRect: UnsafeMutablePointer<CGRect>,\n                   lineFragmentUsedRect: UnsafeMutablePointer<CGRect>,\n                   baselineOffset: UnsafeMutablePointer<CGFloat>,\n                   in textContainer: NSTextContainer,\n                   forGlyphRange glyphRange: NSRange) -> Bool {\n    guard let ellipsisGlyphRange = self.ellipsisGlyphRange,\n        glyphRange.location > ellipsisGlyphRange.location else {\n            return false\n    }\n    let originX = textContainer.size.width\n    lineFragmentRect.pointee.origin = CGPoint(x: originX, y: lineFragmentRect.pointee.origin.y)\n    return true\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "a82a6d579846cd587f83cacb801778b76ef6471d7062267d95e9e21b11ec2745",
  "crawledAt" : "2025-12-02T15:52:18Z",
  "id" : "A29AA45A-8BF7-4876-ABAF-FAD145B9B0AA",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nSome apps, such as book and magazine readers, text editors, and games, may need to lay out their text in a way that better fits their app style. TextKit provides a set of APIs for these apps to implement a custom text layout. This sample demonstrates how to use the APIs to display text in a circular container and in a two-column container, how to set up an exclusive area for a text container, and how to substitute a glyph without changing the text storage.\n\n### Implement a custom-shaped text container\n\nWhen laying out a line of text, TextKit calls the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer\/lineFragmentRect(forProposedRect:at:writingDirection:remaining:)] method from [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer] to determine the position and size of the line, which TextKit calls a *line fragment rectangle*. By creating a subclass of `NSTextContainer` to return a custom line fragment rectangle in the method, apps can implement a custom-shaped text container.\n\nThis sample uses the `CircleTextContainer` class to implement a circular text container. To calculate a line fragment rectangle that fits in the inscribed circle of the container’s bounds, the class calls the implementation of `super` to retrieve the default rectangle, then adjusts its `origin.x` and `width` according to the current line origin and container size.\n\n### Lay out text with a custom text container\n\nTo lay out text with a custom text container, apps simply set up a text view with the container, and let TextKit do the rest. The  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextView\/init(frame:textContainer:)] method from [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextView] serves this purpose, and this sample uses it to create a `UITextView` instance with its circular text container.\n\nWith this configuration, the TextKit class that coordinates the layout and display of characters,  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManager], automatically uses the line fragment rectangles that `CircleTextContainer` returns to lay out the text.\n\n`NSLayoutManager` supports laying out text in multiple text containers, so implementing a two-column layout is as easy as adding a second text container to the layout manager, as the code below shows:\n\nNote that after adding a second text container to the layout manager, the text views become uneditable and unselectable.\n\n### Reserve an area in a text container\n\nTo create an appealing UI, some apps may have their text wrap around a certain shape. They can achieve that by using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer\/exclusionPaths] property from `NSTextContainer` to reserve an exclusive area for the shape in a text container.\n\nThis sample uses the following code to set up an exclusive area where `translatedCirclePath` is a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIBezierPath] instance using the text container’s coordinate system.\n\n### Substitute glyphs without changing the text storage\n\nWhen a text container doesn’t have enough space to display text, apps may need a way to indicate that the container has additional, or *overflow*, text. A standard text container can use the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer\/lineBreakMode] property from  `NSTextContainer` to add an ending ellipsis that helps handle this situation, but the property doesn’t completely support custom-shaped containers like `CircleTextContainer`.\n\nTo show an overflow indicator in its circular text container, as well as to demonstrate TextKit’s capability of glyph substitutions and layout adjustment, this sample substitutes the glyphs of the container’s ending characters with an ellipsis, and makes it the container’s last visible glyph.\n\nThe ending characters are the characters of the last words with a total width that is larger than an ellipsis. The characters have to be wider so that the text container has enough space to display the ellipsis. However, because they are wider, the text container has extra space after the glyph substitution, which can drag in more characters. To avoid showing text after the ellipsis, this sample implements a second glyph substitution by selecting the character next to the container’s last word, and substituting it with a control glyph that uses the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManager\/ControlCharacterAction\/whitespace] action. Using this substitution, the character becomes a whitespace with a width that is flexible. With this flexible space character, the sample can fill up the extra space and push the extra characters to the next line, and then move the line out of the text container.\n\nThe detailed implementation of the glyphs substitutions and the layout adjustment is as follows:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/display-text-with-a-custom-layout\ncrawled: 2025-12-02T15:52:18Z\n---\n\n# Display text with a custom layout\n\n**Sample Code**\n\nLay out text in a custom-shaped container and apply glyph substitutions.\n\n## Overview\n\nSome apps, such as book and magazine readers, text editors, and games, may need to lay out their text in a way that better fits their app style. TextKit provides a set of APIs for these apps to implement a custom text layout. This sample demonstrates how to use the APIs to display text in a circular container and in a two-column container, how to set up an exclusive area for a text container, and how to substitute a glyph without changing the text storage.\n\n### Implement a custom-shaped text container\n\nWhen laying out a line of text, TextKit calls the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer\/lineFragmentRect(forProposedRect:at:writingDirection:remaining:)] method from [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer] to determine the position and size of the line, which TextKit calls a *line fragment rectangle*. By creating a subclass of `NSTextContainer` to return a custom line fragment rectangle in the method, apps can implement a custom-shaped text container.\n\nThis sample uses the `CircleTextContainer` class to implement a circular text container. To calculate a line fragment rectangle that fits in the inscribed circle of the container’s bounds, the class calls the implementation of `super` to retrieve the default rectangle, then adjusts its `origin.x` and `width` according to the current line origin and container size.\n\n```swift\noverride func lineFragmentRect(forProposedRect proposedRect: CGRect,\n                               at characterIndex: Int,\n                               writingDirection baseWritingDirection: NSWritingDirection,\n                               remaining remainingRect: UnsafeMutablePointer<CGRect>?) -> CGRect {\n    let rect = super.lineFragmentRect(forProposedRect: proposedRect,\n                                      at: characterIndex,\n                                      writingDirection: baseWritingDirection,\n                                      remaining: remainingRect)\n    let containerWidth = Float(size.width), containerHeight = Float(size.height)\n\n    let diameter = fminf(containerWidth, containerHeight)\n    let radius = diameter \/ 2.0\n    \n    \/\/ Vertical distance from the line center to the container center.\n    let yDistance = fabsf(Float(rect.origin.y + rect.size.height \/ 2.0) - radius)\n    \/\/ The new line width.\n    let width = (yDistance < radius) ? 2.0 * sqrt(radius * radius - yDistance * yDistance) : 0.0\n    \/\/ Horizontal distance from rect.origin.x to the starting point of the line.\n    let xOffset = (containerWidth > diameter) ? (containerWidth - diameter) \/ 2.0 : 0.0\n    \/\/ The starting x of the line.\n    let xPosition = CGFloat(xOffset + Float(rect.origin.x) + radius - width \/ 2.0)\n    return CGRect(x: xPosition, y: CGFloat(rect.origin.y), width: CGFloat(width), height: rect.size.height)\n}\n```\n\n### Lay out text with a custom text container\n\nTo lay out text with a custom text container, apps simply set up a text view with the container, and let TextKit do the rest. The  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextView\/init(frame:textContainer:)] method from [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextView] serves this purpose, and this sample uses it to create a `UITextView` instance with its circular text container.\n\n```swift\nlet textContainer = CircleTextContainer(size: .zero)\ntextContainer.widthTracksTextView = true\n\nlet layoutManager = NSLayoutManager()\nlayoutManager.addTextContainer(textContainer)\ntextStorage.addLayoutManager(layoutManager)\n\ntextView = UITextView(frame: CGRect.zero, textContainer: textContainer)\n```\n\nWith this configuration, the TextKit class that coordinates the layout and display of characters,  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManager], automatically uses the line fragment rectangles that `CircleTextContainer` returns to lay out the text.\n\n`NSLayoutManager` supports laying out text in multiple text containers, so implementing a two-column layout is as easy as adding a second text container to the layout manager, as the code below shows:\n\n```swift\nlet firstTextContainer = NSTextContainer()\nfirstTextContainer.widthTracksTextView = true\nfirstTextContainer.heightTracksTextView = true\n\nlet secondTextContainer = NSTextContainer()\nsecondTextContainer.widthTracksTextView = true\nsecondTextContainer.heightTracksTextView = true\nsecondTextContainer.lineBreakMode = .byTruncatingTail\n\nlet layoutManager = NSLayoutManager()\nlayoutManager.addTextContainer(firstTextContainer)\nlayoutManager.addTextContainer(secondTextContainer)\n\ntextStorage.addLayoutManager(layoutManager)\n\nlet firstTextView = UITextView(frame: .zero, textContainer: firstTextContainer)\nfirstTextView.isScrollEnabled = false\nview.addSubview(firstTextView)\n\nlet secondTextView = UITextView(frame: .zero, textContainer: secondTextContainer)\nsecondTextView.isScrollEnabled = false\nview.addSubview(secondTextView)\n```\n\nNote that after adding a second text container to the layout manager, the text views become uneditable and unselectable.\n\n### Reserve an area in a text container\n\nTo create an appealing UI, some apps may have their text wrap around a certain shape. They can achieve that by using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer\/exclusionPaths] property from `NSTextContainer` to reserve an exclusive area for the shape in a text container.\n\nThis sample uses the following code to set up an exclusive area where `translatedCirclePath` is a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIBezierPath] instance using the text container’s coordinate system.\n\n```swift\ntextView.textContainer.exclusionPaths = [translatedCirclePath]\n```\n\n### Substitute glyphs without changing the text storage\n\nWhen a text container doesn’t have enough space to display text, apps may need a way to indicate that the container has additional, or *overflow*, text. A standard text container can use the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContainer\/lineBreakMode] property from  `NSTextContainer` to add an ending ellipsis that helps handle this situation, but the property doesn’t completely support custom-shaped containers like `CircleTextContainer`.\n\nTo show an overflow indicator in its circular text container, as well as to demonstrate TextKit’s capability of glyph substitutions and layout adjustment, this sample substitutes the glyphs of the container’s ending characters with an ellipsis, and makes it the container’s last visible glyph.\n\nThe ending characters are the characters of the last words with a total width that is larger than an ellipsis. The characters have to be wider so that the text container has enough space to display the ellipsis. However, because they are wider, the text container has extra space after the glyph substitution, which can drag in more characters. To avoid showing text after the ellipsis, this sample implements a second glyph substitution by selecting the character next to the container’s last word, and substituting it with a control glyph that uses the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManager\/ControlCharacterAction\/whitespace] action. Using this substitution, the character becomes a whitespace with a width that is flexible. With this flexible space character, the sample can fill up the extra space and push the extra characters to the next line, and then move the line out of the text container.\n\nThe detailed implementation of the glyphs substitutions and the layout adjustment is as follows:\n\n- Begin the glyph substitutions by invalidating the glyphs and layout of the ending characters.\n\n```swift\nlayoutManager.invalidateGlyphs(forCharacterRange: endingWordsCharRange, changeInLength: 0,\n                               actualCharacterRange: nil)\nlayoutManager.invalidateLayout(forCharacterRange: endingWordsCharRange,\n                               actualCharacterRange: nil)\n```\n\n- Implement the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManagerDelegate\/layoutManager(_:shouldGenerateGlyphs:properties:characterIndexes:font:forGlyphRange:)] method from [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManagerDelegate] to substitute the glyphs. TextKit calls this delegate method before storing the glyphs to give apps an opportunity to change the glyphs and their properties.\n\n```swift\nlet ellipsisStartIndex = ellipsisIntersection.location\nfor index in ellipsisStartIndex..<ellipsisStartIndex + ellipsisIntersection.length {\n    if index == ellipsisGlyphRange!.location {\n        finalGlyphs[index - glyphRange.location] = myGlyphs[0]\n    } else {\n        finalProps[index - glyphRange.location] = .controlCharacter\n    }\n}\nlet flexibleSpaceStartIndex = flexibleSpaceIntersection.location\nfor index in  flexibleSpaceStartIndex..<flexibleSpaceStartIndex + flexibleSpaceIntersection.length {\n    finalProps[index - glyphRange.location] = .controlCharacter\n}\n```\n\n- Implement the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManagerDelegate\/layoutManager(_:shouldUse:forControlCharacterAt:)] method to return the  `NSLayoutManager.ControlCharacterAction.whitespace` action for the flexible space character.\n\n```swift\nfunc layoutManager(_ layoutManager: NSLayoutManager, shouldUse action: NSLayoutManager.ControlCharacterAction,\n                   forControlCharacterAt charIndex: Int) -> NSLayoutManager.ControlCharacterAction {\n    if let flexibleSpaceGlyphRange = self.flexibleSpaceGlyphRange,\n        flexibleSpaceGlyphRange.contains(layoutManager.glyphIndexForCharacter(at: charIndex)) {\n        return .whitespace\n    }\n    return action\n}\n```\n\n- Implement the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManagerDelegate\/layoutManager(_:boundingBoxForControlGlyphAt:for:proposedLineFragment:glyphPosition:characterIndex:)] method to return a bounding box that can fill up the current line fragment rectangle.\n\n```swift\nfunc layoutManager(_ layoutManager: NSLayoutManager,\n                   boundingBoxForControlGlyphAt glyphIndex: Int,\n                   for textContainer: NSTextContainer,\n                   proposedLineFragment proposedRect: CGRect,\n                   glyphPosition: CGPoint,\n                   characterIndex charIndex: Int) -> CGRect {\n    guard let flexibleSpaceGlyphRange = self.flexibleSpaceGlyphRange,\n        flexibleSpaceGlyphRange.contains(glyphIndex) else {\n        return CGRect(x: glyphPosition.x, y: glyphPosition.y, width: 0, height: proposedRect.height)\n    }\n    let padding = textContainer.lineFragmentPadding * 2\n    let width = proposedRect.width - (glyphPosition.x - proposedRect.minX) - padding\n    let rect = CGRect(x: glyphPosition.x, y: glyphPosition.y, width: width, height: proposedRect.height)\n    return rect\n}\n```\n\n- Implement the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSLayoutManagerDelegate\/layoutManager(_:shouldSetLineFragmentRect:lineFragmentUsedRect:baselineOffset:in:forGlyphRange:)] method to move the extra line out of the text container.\n\n```swift\nfunc layoutManager(_ layoutManager: NSLayoutManager,\n                   shouldSetLineFragmentRect lineFragmentRect: UnsafeMutablePointer<CGRect>,\n                   lineFragmentUsedRect: UnsafeMutablePointer<CGRect>,\n                   baselineOffset: UnsafeMutablePointer<CGFloat>,\n                   in textContainer: NSTextContainer,\n                   forGlyphRange glyphRange: NSRange) -> Bool {\n    guard let ellipsisGlyphRange = self.ellipsisGlyphRange,\n        glyphRange.location > ellipsisGlyphRange.location else {\n            return false\n    }\n    let originX = textContainer.size.width\n    lineFragmentRect.pointee.origin = CGPoint(x: originX, y: lineFragmentRect.pointee.origin.y)\n    return true\n}\n```\n\n## Layout\n\n- **Using TextKit 2 to interact with text**: Interact with text by managing text selection and inserting custom text elements.\n- **NSTextLayoutManager**: The primary class that you use to manage text layout and presentation for custom text displays.\n- **NSTextContainer**: A region where text layout occurs.\n- **NSTextLayoutFragment**: A class that represents the layout fragment typically corresponding to a rendering surface, such as a layer or view subclass.\n- **NSTextLineFragment**: A class that represents a line fragment as a single textual layout and rendering unit inside a text layout fragment.\n- **NSTextViewportLayoutController**: Manages the layout process inside the viewport interacting with its delegate.\n- **NSTextLayoutOrientationProvider**: A set of methods that define the orientation of text for an object.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Interact with text by managing text selection and inserting custom text elements.",
          "name" : "Using TextKit 2 to interact with text",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/using-textkit-2-to-interact-with-text"
        },
        {
          "description" : "The primary class that you use to manage text layout and presentation for custom text displays.",
          "name" : "NSTextLayoutManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSTextLayoutManager"
        },
        {
          "description" : "A region where text layout occurs.",
          "name" : "NSTextContainer",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSTextContainer"
        },
        {
          "description" : "A class that represents the layout fragment typically corresponding to a rendering surface, such as a layer or view subclass.",
          "name" : "NSTextLayoutFragment",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSTextLayoutFragment"
        },
        {
          "description" : "A class that represents a line fragment as a single textual layout and rendering unit inside a text layout fragment.",
          "name" : "NSTextLineFragment",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSTextLineFragment"
        },
        {
          "description" : "Manages the layout process inside the viewport interacting with its delegate.",
          "name" : "NSTextViewportLayoutController",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSTextViewportLayoutController"
        },
        {
          "description" : "A set of methods that define the orientation of text for an object.",
          "name" : "NSTextLayoutOrientationProvider",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/NSTextLayoutOrientationProvider"
        }
      ],
      "title" : "Layout"
    }
  ],
  "source" : "appleJSON",
  "title" : "Display text with a custom layout",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/display-text-with-a-custom-layout"
}