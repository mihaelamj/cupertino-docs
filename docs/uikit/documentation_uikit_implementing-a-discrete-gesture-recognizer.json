{
  "abstract" : "If your gesture involves a specific pattern of events, consider implementing a discrete gesture recognizer for it.",
  "codeExamples" : [
    {
      "code" : "enum CheckmarkPhases {\n    case notStarted\n    case initialPoint\n    case downStroke\n    case upStroke\n} \nclass CheckmarkGestureRecognizer : UIGestureRecognizer {\n    var strokePhase : CheckmarkPhases = .notStarted\n    var initialTouchPoint : CGPoint = CGPoint.zero\n    var trackedTouch : UITouch? = nil\n   \/\/ Overridden methods to come...",
      "language" : "swift"
    },
    {
      "code" : "override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesBegan(touches, with: event)\n   if touches.count != 1 {\n      self.state = .failed\n   } \n \n   \/\/ Capture the first touch and store some information about it.\n   if self.trackedTouch == nil {\n      self.trackedTouch = touches.first\n      self.strokePhase = .initialPoint\n      self.initialTouchPoint = (self.trackedTouch?.location(in: self.view))!\n   } else {\n      \/\/ Ignore all but the first touch.\n      for touch in touches {\n         if touch != self.trackedTouch {\n            self.ignore(touch, for: event)\n         }\n      }\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesMoved(touches, with: event)\n   let newTouch = touches.first \n   \/\/ There should be only the first touch.\n   guard newTouch == self.trackedTouch else { \n      self.state = .failed \n      return\n   } \n   let newPoint = (newTouch?.location(in: self.view))!\n   let previousPoint = (newTouch?.previousLocation(in: self.view))!\n   if self.strokePhase == .initialPoint {\n      \/\/ Make sure the initial movement is down and to the right.\n      if newPoint.x >= initialTouchPoint.x && newPoint.y >= initialTouchPoint.y {\n         self.strokePhase = .downStroke\n      } else {         self.state = .failed\n      }\n   } else if self.strokePhase == .downStroke {\n      \/\/ Always keep moving left to right.\n      if newPoint.x >= previousPoint.x {\n         \/\/ If the y direction changes, the gesture is moving up again.\n         \/\/ Otherwise, the down stroke continues.\n         if newPoint.y < previousPoint.y {\n            self.strokePhase = .upStroke\n         }\n      } else {\n        \/\/ If the new x value is to the left, the gesture fails.\n        self.state = .failed\n      }\n   } else if self.strokePhase == .upStroke {\n      \/\/ If the new x value is to the left, or the new y value\n      \/\/ changed directions again, the gesture fails.]\n      if newPoint.x < previousPoint.x || newPoint.y > previousPoint.y {\n         self.state = .failed\n      }\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesEnded(touches, with: event) \n   let newTouch = touches.first\n   let newPoint = (newTouch?.location(in: self.view))!\n   \/\/ There should be only the first touch.\n   guard newTouch == self.trackedTouch else { \n      self.state = .failed \n      return\n   } \n   \/\/ If the stroke was moving up and the final point is\n   \/\/ above the initial point, the gesture succeeds.\n   if self.state == .possible && \n         self.strokePhase == .upStroke && \n         newPoint.y < initialTouchPoint.y {\n      self.state = .recognized\n   } else {\n      self.state = .failed\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesCancelled(touches, with: event)\n   self.initialTouchPoint = CGPoint.zero\n   self.strokePhase = .notStarted\n   self.trackedTouch = nil\n   self.state = .cancelled\n}\n \noverride func reset() {\n   super.reset()\n   self.initialTouchPoint = CGPoint.zero\n   self.strokePhase = .notStarted\n   self.trackedTouch = nil\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "c43371d19c71b1089b91d9274b5eb43600c2dc10fbae31974e82f216b7ca088c",
  "crawledAt" : "2025-12-03T23:40:31Z",
  "id" : "42B7EBDA-69AF-45BC-98EA-39DCB5ACEAD7",
  "kind" : "article",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nA gesture recognizer remains in the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/possible] state until events indicate that your gesture succeeded or failed, at which point you change its state. The advantage of discrete gesture recognizers is that they are simpler to implement because they require fewer state transitions. One disadvantage is that because the state change typically occurs later in the event sequence, recognition can easily be preempted by continuous gestures attached to the same view.\n\nThe following image shows a checkmark gesture, which is created by tracing one finger down and to the right and then back up and to the right. Because the gesture follows a specific path, it makes sense to use a discrete gesture recognizer.\n\n\n\n### Defining the conditions for success\n\nBefore implementing your gesture recognizer code, define the conditions for which recognition should occur. The conditions for matching a checkmark gesture are as follows:\n\n### Saving gesture-related data\n\nWith the conditions defined, add properties to your gesture recognizer to track any needed information. For the checkmark gesture, the gesture recognizer needs to know the starting point of the gesture so that it can compare that point to the final point. It also needs to know whether the user’s finger is moving downward or upward.\n\nThe following code shows the first part of a custom `CheckmarkGestureRecognizer` class definition. This class stores the initial touch point and the current phase of the gesture. The class also stores the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] object associated with the first finger so that it can ignore any other touches.\n\n### Processing touch events\n\nThe following code shows the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesBegan(_:with:)] method, which sets up the initial conditions for recognizing the gesture. The gesture fails immediately if the initial event contains two touches. If there is only one touch, the touch object is saved in the `trackedTouch` property. Because UIKit reuses [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] objects, and therefore overwrites their properties, this method also saves the location of the touch in the `initialTouchPoint` property. After the first touch occurs, any new touches added to the event sequence are ignored.\n\nWhen touch information changes, UIKit calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesMoved(_:with:)] method. The following code shows the implementation of this method for the checkmark gesture. This method verifies that the first touch is the correct one, which it should be because all subsequent touches were ignored. It then looks at the movement of that touch. When the initial movement is down and to the right, this method sets the `strokePhase` property to `downStroke`. When the motion changes direction and starts moving upward, the method changes the stroke phase to `upStroke`. If the gesture deviates from this pattern in any way, the method sets the gesture’s state to failed.\n\nAt the end of the touch sequence, UIKit calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesEnded(_:with:)] method. The following code shows the implementation of this method for the checkmark gesture. If the gesture has not already failed, this method determines whether the gesture was moving upward when it ended and determines whether the final point is higher than the initial point. If both conditions are true, the method sets the state to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/recognized]; otherwise, the gesture fails.\n\n### Resetting the gesture recognizer\n\nIn addition to tracking the touches, the `CheckmarkGestureRecognizer` class implements the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesCancelled(_:with:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/reset()] methods. The class uses these methods to reset the gesture recognizer’s local properties to appropriate values. The following code shows the implementations of these methods.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/implementing-a-discrete-gesture-recognizer\ncrawled: 2025-12-03T23:40:31Z\n---\n\n# Implementing a discrete gesture recognizer\n\n**Article**\n\nIf your gesture involves a specific pattern of events, consider implementing a discrete gesture recognizer for it.\n\n## Overview\n\nA gesture recognizer remains in the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/possible] state until events indicate that your gesture succeeded or failed, at which point you change its state. The advantage of discrete gesture recognizers is that they are simpler to implement because they require fewer state transitions. One disadvantage is that because the state change typically occurs later in the event sequence, recognition can easily be preempted by continuous gestures attached to the same view.\n\nThe following image shows a checkmark gesture, which is created by tracing one finger down and to the right and then back up and to the right. Because the gesture follows a specific path, it makes sense to use a discrete gesture recognizer.\n\n\n\n### Defining the conditions for success\n\nBefore implementing your gesture recognizer code, define the conditions for which recognition should occur. The conditions for matching a checkmark gesture are as follows:\n\n- Only the first finger to touch the screen is tracked. All others are ignored.\n- The touch always moves left to right.\n- The touch moves downward initially but then changes direction and moves upward.\n- The upward stroke ends higher on the screen than the initial touch point.\n\n### Saving gesture-related data\n\nWith the conditions defined, add properties to your gesture recognizer to track any needed information. For the checkmark gesture, the gesture recognizer needs to know the starting point of the gesture so that it can compare that point to the final point. It also needs to know whether the user’s finger is moving downward or upward.\n\nThe following code shows the first part of a custom `CheckmarkGestureRecognizer` class definition. This class stores the initial touch point and the current phase of the gesture. The class also stores the  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] object associated with the first finger so that it can ignore any other touches.\n\n```swift\nenum CheckmarkPhases {\n    case notStarted\n    case initialPoint\n    case downStroke\n    case upStroke\n} \nclass CheckmarkGestureRecognizer : UIGestureRecognizer {\n    var strokePhase : CheckmarkPhases = .notStarted\n    var initialTouchPoint : CGPoint = CGPoint.zero\n    var trackedTouch : UITouch? = nil\n   \/\/ Overridden methods to come...\n```\n\n### Processing touch events\n\nThe following code shows the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesBegan(_:with:)] method, which sets up the initial conditions for recognizing the gesture. The gesture fails immediately if the initial event contains two touches. If there is only one touch, the touch object is saved in the `trackedTouch` property. Because UIKit reuses [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] objects, and therefore overwrites their properties, this method also saves the location of the touch in the `initialTouchPoint` property. After the first touch occurs, any new touches added to the event sequence are ignored.\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesBegan(touches, with: event)\n   if touches.count != 1 {\n      self.state = .failed\n   } \n \n   \/\/ Capture the first touch and store some information about it.\n   if self.trackedTouch == nil {\n      self.trackedTouch = touches.first\n      self.strokePhase = .initialPoint\n      self.initialTouchPoint = (self.trackedTouch?.location(in: self.view))!\n   } else {\n      \/\/ Ignore all but the first touch.\n      for touch in touches {\n         if touch != self.trackedTouch {\n            self.ignore(touch, for: event)\n         }\n      }\n   }\n}\n```\n\nWhen touch information changes, UIKit calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesMoved(_:with:)] method. The following code shows the implementation of this method for the checkmark gesture. This method verifies that the first touch is the correct one, which it should be because all subsequent touches were ignored. It then looks at the movement of that touch. When the initial movement is down and to the right, this method sets the `strokePhase` property to `downStroke`. When the motion changes direction and starts moving upward, the method changes the stroke phase to `upStroke`. If the gesture deviates from this pattern in any way, the method sets the gesture’s state to failed.\n\n```swift\noverride func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesMoved(touches, with: event)\n   let newTouch = touches.first \n   \/\/ There should be only the first touch.\n   guard newTouch == self.trackedTouch else { \n      self.state = .failed \n      return\n   } \n   let newPoint = (newTouch?.location(in: self.view))!\n   let previousPoint = (newTouch?.previousLocation(in: self.view))!\n   if self.strokePhase == .initialPoint {\n      \/\/ Make sure the initial movement is down and to the right.\n      if newPoint.x >= initialTouchPoint.x && newPoint.y >= initialTouchPoint.y {\n         self.strokePhase = .downStroke\n      } else {         self.state = .failed\n      }\n   } else if self.strokePhase == .downStroke {\n      \/\/ Always keep moving left to right.\n      if newPoint.x >= previousPoint.x {\n         \/\/ If the y direction changes, the gesture is moving up again.\n         \/\/ Otherwise, the down stroke continues.\n         if newPoint.y < previousPoint.y {\n            self.strokePhase = .upStroke\n         }\n      } else {\n        \/\/ If the new x value is to the left, the gesture fails.\n        self.state = .failed\n      }\n   } else if self.strokePhase == .upStroke {\n      \/\/ If the new x value is to the left, or the new y value\n      \/\/ changed directions again, the gesture fails.]\n      if newPoint.x < previousPoint.x || newPoint.y > previousPoint.y {\n         self.state = .failed\n      }\n   }\n}\n```\n\nAt the end of the touch sequence, UIKit calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesEnded(_:with:)] method. The following code shows the implementation of this method for the checkmark gesture. If the gesture has not already failed, this method determines whether the gesture was moving upward when it ended and determines whether the final point is higher than the initial point. If both conditions are true, the method sets the state to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/recognized]; otherwise, the gesture fails.\n\n```swift\noverride func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesEnded(touches, with: event) \n   let newTouch = touches.first\n   let newPoint = (newTouch?.location(in: self.view))!\n   \/\/ There should be only the first touch.\n   guard newTouch == self.trackedTouch else { \n      self.state = .failed \n      return\n   } \n   \/\/ If the stroke was moving up and the final point is\n   \/\/ above the initial point, the gesture succeeds.\n   if self.state == .possible && \n         self.strokePhase == .upStroke && \n         newPoint.y < initialTouchPoint.y {\n      self.state = .recognized\n   } else {\n      self.state = .failed\n   }\n}\n```\n\n### Resetting the gesture recognizer\n\nIn addition to tracking the touches, the `CheckmarkGestureRecognizer` class implements the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesCancelled(_:with:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/reset()] methods. The class uses these methods to reset the gesture recognizer’s local properties to appropriate values. The following code shows the implementations of these methods.\n\n```swift\noverride func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent) {\n   super.touchesCancelled(touches, with: event)\n   self.initialTouchPoint = CGPoint.zero\n   self.strokePhase = .notStarted\n   self.trackedTouch = nil\n   self.state = .cancelled\n}\n \noverride func reset() {\n   super.reset()\n   self.initialTouchPoint = CGPoint.zero\n   self.strokePhase = .notStarted\n   self.trackedTouch = nil\n}\n```\n\n## Creating Custom Gesture Recognizers\n\n- **About the Gesture Recognizer State Machine**: Learn about the states and transitions of the state machine that underlies gesture recognizers.\n- **Implementing a Continuous Gesture Recognizer**: For gestures that do not easily match a specific pattern, or when you want to use a gesture recognizer to gather touch input, create a continuous gesture recognizer.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn about the states and transitions of the state machine that underlies gesture recognizers.",
          "name" : "About the Gesture Recognizer State Machine",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/about-the-gesture-recognizer-state-machine"
        },
        {
          "description" : "For gestures that do not easily match a specific pattern, or when you want to use a gesture recognizer to gather touch input, create a continuous gesture recognizer.",
          "name" : "Implementing a Continuous Gesture Recognizer",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/implementing-a-continuous-gesture-recognizer"
        }
      ],
      "title" : "Creating Custom Gesture Recognizers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing a discrete gesture recognizer",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/implementing-a-discrete-gesture-recognizer"
}