{
  "abstract" : "Insert, delete, and manipulate text by using a proxy to a text input view.",
  "codeExamples" : [
    {
      "code" : "textDocumentProxy.insertText(\"Hello world.\")",
      "language" : "swift"
    },
    {
      "code" : "textDocumentProxy.deleteBackward()",
      "language" : "swift"
    },
    {
      "code" : "if textDocumentProxy.hasText {\n    \/\/ Do something with the text\n}\n",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Move the text insertion position forward 1 character\ntextDocumentProxy.adjustTextPosition(byCharacterOffset: 1)\n\n\/\/ Delete the previous character\ntextDocumentProxy.deleteBackward()",
      "language" : "swift"
    },
    {
      "code" : "func textWillChange(_ textInput: UITextInput?)\nfunc textDidChange(_ textInput: UITextInput?)\n\nfunc selectionWillChange(_ textInput: UITextInput?)\nfunc selectionDidChange(_ textInput: UITextInput?)",
      "language" : "swift"
    },
    {
      "code" : "let precedingText = textDocumentProxy.documentContextBeforeInput ?? \"\"\nlet followingText = textDocumentProxy.documentContextAfterInput ?? \"\"\nlet selectedText = textDocumentProxy.selectedText ?? \"\"\nlet fullText = \"\\(precedingText)\\(selectedText)\\(followingText)\"",
      "language" : "swift"
    },
    {
      "code" : "let accentCharacter = \" \\u{0301}\"\nlet range = NSRange(location: 0, length: accentCharacter.count)\ntextDocumentProxy.setMarkedText(accentCharacter, selectedRange: range)",
      "language" : "swift"
    },
    {
      "code" : "textDocumentProxy.insertText(\"a\\u{0301}\")",
      "language" : "swift"
    },
    {
      "code" : "let text = \"Anthony\"\nlet range = NSRange(location: 4, length: 3)\ntextDocumentProxy.setMarkedText(text, selectedRange: range)",
      "language" : "swift"
    }
  ],
  "contentHash" : "5466358d07a233a0462f35850ce85bf7677cd74a773eb7aa8bb1ffc05b6db2af",
  "crawledAt" : "2025-12-04T10:29:09Z",
  "id" : "42BA59F0-875E-4CC7-BE34-E30BBCA91FF1",
  "kind" : "article",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nCustom keyboards execute in a separate process that doesn’t have direct access to the text a user is editing. A proxy object, [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy], provides access to the input text view. Through the text document proxy you can insert or delete text, manipulate the insertion point, and access additional textual context around the insertion point.\n\n\n\n### Insert and delete text\n\nThe text document proxy conforms to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIKeyInput] protocol, providing methods for inserting and deleting text. To insert a character or string into the current input view:\n\nTo delete the character preceding the current insertion point:\n\nYou can determine if the input view has any text at all using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIKeyInput\/hasText] property:\n\n### Adjust the insertion point\n\nTo move the insertion point in the text input view, use the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/adjustTextPosition(byCharacterOffset:)] method. For example, if you want to implement a forward delete action, move the insertion position forward by one character then delete backwards:\n\nYou might choose to enable this capability only when the insertion point isn’t at the end of the text being input by checking the context after the insertion point. See [doc:\/\/com.apple.uikit\/documentation\/UIKit\/handling-text-interactions-in-custom-keyboards#Get-context-around-the-insertion-point] for more details.\n\n### Respond to changes while the user is editing\n\nWhile your keyboard is active, the user may perform operations that change the text or selection. Your custom keyboard controller, a subclass of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIInputViewController] that conforms to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextInputDelegate] protocol, can automatically be informed of these text and selection changes. You can override two sets of methods in this delegate protocol to receive these notifications. The first set is called when text is changing, and the second is called when the selection is changing. Because your keyboard extension doesn’t have direct access to the text input field, the argument is `nil`.\n\n### Get context around the insertion point\n\nTo perform certain operations like autocomplete or autocapitalization, you may need additional context of the text surrounding what the user is typing. You can access the context before and after the insertion point as follows:\n\nUse [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CFStringTokenizer] to better understand the context by breaking the surrounding text (or combined text) into words, paragraphs, or sentences. This information enables you to implement autocapitalization.\n\n### Mark text while the user is editing\n\nSome text input operations require multiple actions in order to complete a single character or word. For example, your keyboard might support a language that requires multiple keystrokes to compose a single character. [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy] allows you to insert text and mark some or all of it for subsequent editing operations. The following code shows how you could insert a combining accent character as marked text using [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/setMarkedText(_:selectedRange:)]:\n\nCalling `setMarkedText` selects the text specified by `range`. Subsequent insertions replace the characters selected in the range. In the example above, a space with a combining acute accent is shown. If the next character input by the user is an `a`, you could then insert a combined `á`.\n\nIf the range passed to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/setMarkedText(_:selectedRange:)] only covers a portion of the string passed in, the nonselected portion is marked with a background color. You could use this to display autocompleted content. For example, if you supported autocompletion of names and the user had typed “Anth”, you might display “Anthony” as the autocompletion:\n\nThe above would display the text as:\n\n\n\nAs the user continues to type, you can update the marked text with subsequent calls to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/setMarkedText(_:selectedRange:)].\n\nCall [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/unmarkText()] to clear the marked text indication, leaving the text in the input view.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/handling-text-interactions-in-custom-keyboards\ncrawled: 2025-12-04T10:29:09Z\n---\n\n# Handling text interactions in custom keyboards\n\n**Article**\n\nInsert, delete, and manipulate text by using a proxy to a text input view.\n\n## Overview\n\nCustom keyboards execute in a separate process that doesn’t have direct access to the text a user is editing. A proxy object, [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy], provides access to the input text view. Through the text document proxy you can insert or delete text, manipulate the insertion point, and access additional textual context around the insertion point.\n\n\n\n### Insert and delete text\n\nThe text document proxy conforms to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIKeyInput] protocol, providing methods for inserting and deleting text. To insert a character or string into the current input view:\n\n```swift\ntextDocumentProxy.insertText(\"Hello world.\")\n```\n\nTo delete the character preceding the current insertion point:\n\n```swift\ntextDocumentProxy.deleteBackward()\n```\n\nYou can determine if the input view has any text at all using the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIKeyInput\/hasText] property:\n\n```swift\nif textDocumentProxy.hasText {\n    \/\/ Do something with the text\n}\n\n```\n\n### Adjust the insertion point\n\nTo move the insertion point in the text input view, use the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/adjustTextPosition(byCharacterOffset:)] method. For example, if you want to implement a forward delete action, move the insertion position forward by one character then delete backwards:\n\n```swift\n\/\/ Move the text insertion position forward 1 character\ntextDocumentProxy.adjustTextPosition(byCharacterOffset: 1)\n\n\/\/ Delete the previous character\ntextDocumentProxy.deleteBackward()\n```\n\nYou might choose to enable this capability only when the insertion point isn’t at the end of the text being input by checking the context after the insertion point. See [doc:\/\/com.apple.uikit\/documentation\/UIKit\/handling-text-interactions-in-custom-keyboards#Get-context-around-the-insertion-point] for more details.\n\n### Respond to changes while the user is editing\n\nWhile your keyboard is active, the user may perform operations that change the text or selection. Your custom keyboard controller, a subclass of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIInputViewController] that conforms to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextInputDelegate] protocol, can automatically be informed of these text and selection changes. You can override two sets of methods in this delegate protocol to receive these notifications. The first set is called when text is changing, and the second is called when the selection is changing. Because your keyboard extension doesn’t have direct access to the text input field, the argument is `nil`.\n\n```swift\nfunc textWillChange(_ textInput: UITextInput?)\nfunc textDidChange(_ textInput: UITextInput?)\n\nfunc selectionWillChange(_ textInput: UITextInput?)\nfunc selectionDidChange(_ textInput: UITextInput?)\n```\n\n### Get context around the insertion point\n\nTo perform certain operations like autocomplete or autocapitalization, you may need additional context of the text surrounding what the user is typing. You can access the context before and after the insertion point as follows:\n\n```swift\nlet precedingText = textDocumentProxy.documentContextBeforeInput ?? \"\"\nlet followingText = textDocumentProxy.documentContextAfterInput ?? \"\"\nlet selectedText = textDocumentProxy.selectedText ?? \"\"\nlet fullText = \"\\(precedingText)\\(selectedText)\\(followingText)\"\n```\n\nUse [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CFStringTokenizer] to better understand the context by breaking the surrounding text (or combined text) into words, paragraphs, or sentences. This information enables you to implement autocapitalization.\n\n1. Call [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/documentContextBeforeInput] to get the text preceding the insertion point.\n2. Use [doc:\/\/com.apple.documentation\/documentation\/CoreFoundation\/CFStringTokenizer] to locate the beginning of the current word.\n3. Move the insertion point after the first character of the word.\n4. Call [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIKeyInput\/deleteBackward()].\n5. Call [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIKeyInput\/insertText(_:)] and pass the appropriate capitalized letter.\n6. Move the insertion point back to its original position.\n\n### Mark text while the user is editing\n\nSome text input operations require multiple actions in order to complete a single character or word. For example, your keyboard might support a language that requires multiple keystrokes to compose a single character. [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy] allows you to insert text and mark some or all of it for subsequent editing operations. The following code shows how you could insert a combining accent character as marked text using [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/setMarkedText(_:selectedRange:)]:\n\n```swift\nlet accentCharacter = \" \\u{0301}\"\nlet range = NSRange(location: 0, length: accentCharacter.count)\ntextDocumentProxy.setMarkedText(accentCharacter, selectedRange: range)\n```\n\nCalling `setMarkedText` selects the text specified by `range`. Subsequent insertions replace the characters selected in the range. In the example above, a space with a combining acute accent is shown. If the next character input by the user is an `a`, you could then insert a combined `á`.\n\n```swift\ntextDocumentProxy.insertText(\"a\\u{0301}\")\n```\n\nIf the range passed to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/setMarkedText(_:selectedRange:)] only covers a portion of the string passed in, the nonselected portion is marked with a background color. You could use this to display autocompleted content. For example, if you supported autocompletion of names and the user had typed “Anth”, you might display “Anthony” as the autocompletion:\n\n```swift\nlet text = \"Anthony\"\nlet range = NSRange(location: 4, length: 3)\ntextDocumentProxy.setMarkedText(text, selectedRange: range)\n```\n\nThe above would display the text as:\n\n\n\nAs the user continues to type, you can update the marked text with subsequent calls to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/setMarkedText(_:selectedRange:)].\n\nCall [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextDocumentProxy\/unmarkText()] to clear the marked text indication, leaving the text in the input view.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Handling text interactions in custom keyboards",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/handling-text-interactions-in-custom-keyboards"
}