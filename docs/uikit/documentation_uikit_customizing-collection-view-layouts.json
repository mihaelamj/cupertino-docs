{
  "abstract" : "Customize a view layout by changing the size of cells in the flow or implementing a mosaic style.",
  "codeExamples" : [
    {
      "code" : "override func prepare() {\n    super.prepare()\n\n    guard let collectionView = collectionView else { return }\n    \n    let availableWidth = collectionView.bounds.inset(by: collectionView.layoutMargins).width\n    let maxNumColumns = Int(availableWidth \/ minColumnWidth)\n    let cellWidth = (availableWidth \/ CGFloat(maxNumColumns)).rounded(.down)\n    \n    self.itemSize = CGSize(width: cellWidth, height: cellHeight)\n    self.sectionInset = UIEdgeInsets(top: self.minimumInteritemSpacing, left: 0.0, bottom: 0.0, right: 0.0)\n    self.sectionInsetReference = .fromSafeArea\n}",
      "language" : "swift"
    },
    {
      "code" : "override func prepare() {\n    super.prepare()\n    \n    guard let collectionView = collectionView else { return }\n\n    \/\/ Reset cached information.\n    cachedAttributes.removeAll()\n    contentBounds = CGRect(origin: .zero, size: collectionView.bounds.size)\n    \n    \/\/ For every item in the collection view:\n    \/\/  - Prepare the attributes.\n    \/\/  - Store attributes in the cachedAttributes array.\n    \/\/  - Combine contentBounds with attributes.frame.\n    let count = collectionView.numberOfItems(inSection: 0)\n    \n    var currentIndex = 0\n    var segment: MosaicSegmentStyle = .fullWidth\n    var lastFrame: CGRect = .zero\n    \n    let cvWidth = collectionView.bounds.size.width\n    \n    while currentIndex < count {\n        let segmentFrame = CGRect(x: 0, y: lastFrame.maxY + 1.0, width: cvWidth, height: 200.0)\n        \n        var segmentRects = [CGRect]()\n        switch segment {\n        case .fullWidth:\n            segmentRects = [segmentFrame]\n            \n        case .fiftyFifty:\n            let horizontalSlices = segmentFrame.dividedIntegral(fraction: 0.5, from: .minXEdge)\n            segmentRects = [horizontalSlices.first, horizontalSlices.second]\n            \n        case .twoThirdsOneThird:\n            let horizontalSlices = segmentFrame.dividedIntegral(fraction: (2.0 \/ 3.0), from: .minXEdge)\n            let verticalSlices = horizontalSlices.second.dividedIntegral(fraction: 0.5, from: .minYEdge)\n            segmentRects = [horizontalSlices.first, verticalSlices.first, verticalSlices.second]\n            \n        case .oneThirdTwoThirds:\n            let horizontalSlices = segmentFrame.dividedIntegral(fraction: (1.0 \/ 3.0), from: .minXEdge)\n            let verticalSlices = horizontalSlices.first.dividedIntegral(fraction: 0.5, from: .minYEdge)\n            segmentRects = [verticalSlices.first, verticalSlices.second, horizontalSlices.second]\n        }\n        \n        \/\/ Create and cache layout attributes for calculated frames.\n        for rect in segmentRects {\n            let attributes = UICollectionViewLayoutAttributes(forCellWith: IndexPath(item: currentIndex, section: 0))\n            attributes.frame = rect\n            \n            cachedAttributes.append(attributes)\n            contentBounds = contentBounds.union(lastFrame)\n            \n            currentIndex += 1\n            lastFrame = rect\n        }\n\n        \/\/ Determine the next segment style.\n        switch count - currentIndex {\n        case 1:\n            segment = .fullWidth\n        case 2:\n            segment = .fiftyFifty\n        default:\n            switch segment {\n            case .fullWidth:\n                segment = .fiftyFifty\n            case .fiftyFifty:\n                segment = .twoThirdsOneThird\n            case .twoThirdsOneThird:\n                segment = .oneThirdTwoThirds\n            case .oneThirdTwoThirds:\n                segment = .fiftyFifty\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "override var collectionViewContentSize: CGSize {\n    return contentBounds.size\n}",
      "language" : "swift"
    },
    {
      "code" : "override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {\n    var attributesArray = [UICollectionViewLayoutAttributes]()\n    \n    \/\/ Find any cell that sits within the query rect.\n    guard let lastIndex = cachedAttributes.indices.last,\n          let firstMatchIndex = binSearch(rect, start: 0, end: lastIndex) else { return attributesArray }\n    \n    \/\/ Starting from the match, loop up and down through the array until all the attributes\n    \/\/ have been added within the query rect.\n    for attributes in cachedAttributes[..<firstMatchIndex].reversed() {\n        guard attributes.frame.maxY >= rect.minY else { break }\n        attributesArray.append(attributes)\n    }\n    \n    for attributes in cachedAttributes[firstMatchIndex...] {\n        guard attributes.frame.minY <= rect.maxY else { break }\n        attributesArray.append(attributes)\n    }\n    \n    return attributesArray\n}",
      "language" : "swift"
    },
    {
      "code" : "override func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {\n    return cachedAttributes[indexPath.item]\n}",
      "language" : "swift"
    },
    {
      "code" : "override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool {\n    guard let collectionView = collectionView else { return false }\n    return !newBounds.size.equalTo(collectionView.bounds.size)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Perform any cell reloads without animation because there is no movement.\nUIView.performWithoutAnimation {\n    collectionView.performBatchUpdates({\n        for update in remoteUpdates {\n            if case let .reload(index) = update {\n                people[index].isUpdated = true\n                collectionView.reloadItems(at: [IndexPath(item: index, section: 0)])\n            }\n        }\n    })\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Animate all other update types together.\ncollectionView.performBatchUpdates({\n    var deletes = [Int]()\n    var inserts = [(person:Person, index:Int)]()\n\n    for update in remoteUpdates {\n        switch update {\n        case let .delete(index):\n            collectionView.deleteItems(at: [IndexPath(item: index, section: 0)])\n            deletes.append(index)\n            \n        case let .insert(person, index):\n            collectionView.insertItems(at: [IndexPath(item: index, section: 0)])\n            inserts.append((person, index))\n            \n        case let .move(fromIndex, toIndex):\n            \/\/ Updates that move a person are split into an addition and a deletion.\n            collectionView.moveItem(at: IndexPath(item: fromIndex, section: 0),\n                                    to: IndexPath(item: toIndex, section: 0))\n            deletes.append(fromIndex)\n            inserts.append((people[fromIndex], toIndex))\n            \n        default: break\n        }\n    }\n    \n    \/\/ Apply deletions in descending order.\n    for deletedIndex in deletes.sorted().reversed() {\n        people.remove(at: deletedIndex)\n    }\n    \n    \/\/ Apply insertions in ascending order.\n    let sortedInserts = inserts.sorted(by: { (personA, personB) -> Bool in\n        return personA.index <= personB.index\n    })\n    for insertion in sortedInserts {\n        people.insert(insertion.person, at: insertion.index)\n    }\n    \n    \/\/ The update button is enabled only if the list still has people in it.\n    navigationItem.rightBarButtonItem?.isEnabled = !people.isEmpty\n})",
      "language" : "swift"
    }
  ],
  "contentHash" : "d8d00ce0b7b8c3b4372f85c7b06482ebd41a5806e3f1a423695c025eb3f04da7",
  "crawledAt" : "2025-12-02T15:52:13Z",
  "id" : "E0648730-EEE5-4B5B-B2E4-ADEF635CD7F7",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nTo lay out UICollectionView cells in a simple grid, you can use [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout] directly. For more flexibility, you can subclass [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout] to create advanced layouts.\n\nThis sample app demonstrates two custom layout subclasses:\n\nThe app opens to the Friends view controller, which uses a column flow layout to display a list of people. Tapping any cell takes you to the Feed view controller, which uses a mosaic layout to display photos from the user’s photo library.\n\nTapping the cloud icon to the right of the navigation bar demonstrates batched animations for inserting, deleting, moving, and reloading items in the collection view. For more information, see “Perform Batch Updates,” below. Using pull-to-refresh on the collection view resets the data.\n\n### For a simple grid, size cells dynamically\n\n`ColumnFlowLayout` is a subclass of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout] that uses the size of the collection view to determine the width of its cells. If only one cell fits comfortably horizontally, the layout arranges the cells to occupy the entire width of the collection view. Otherwise, the layout displays multiple columns of cells with a fixed width.\n\nIn practice, on iPhone devices in portrait mode, `ColumnFlowLayout` displays a single vertical column of cells. In landscape mode, or on an iPad, it displays a grid layout.\n\nUse the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/prepare()] function to compute the available screen width of the device and set the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout\/itemSize] property accordingly.\n\n### For a complex grid, define cell sizes explicitly\n\nIf you need more customization than is possible with a subclass of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout], subclass [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout] instead.\n\n`MosaicLayout` is a `UICollectionViewLayout` subclass that displays an arbitrary number of cells with differing sizes and aspect ratios. The `FeedViewController` class uses a mosaic layout to display images from the user’s photo library. Cells are organized into rows in one of four styles, from a single cell to multiple cells in varying layouts.\n\n\n\n**Calculate cell dimensions**\n\nThe [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/prepare()] method is called whenever a layout is invalidated. Override this method to calculate the position and size of every cell, as well as the total dimensions for the entire layout.\n\n**Provide the content size**\n\nOverride the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/collectionViewContentSize] property, providing a size for the collection view.\n\n**Define the layout attributes**\n\nOverride [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/layoutAttributesForElements(in:)], defining the layout attributes for a geometric region. The collection view calls this function periodically to display items, which is known as *querying by geometric region*.\n\nAlso provide the layout attributes for a specific item by implementing [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/layoutAttributesForItem(at:)]. The collection view calls this function periodically to display one particular item, which is known as *querying by index path*.\n\nBecause these functions are called often, they can affect the performance of your app. To make them as efficient as possible, follow the example code as closely as you can.\n\n**Handle bounds changes**\n\nThe [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSCollectionViewLayout\/shouldInvalidateLayout(forBoundsChange:)] function is called for every bounds change from the collection view, or whenever its size or origin changes. This function is also called frequently during scrolling. The default implementation returns `false`, or, if the size and origin change, it returns `true`.\n\nFor optimum performance, this sample performs a binary search inside [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/layoutAttributesForElements(in:)] instead of a linear search of the attributes it needs for each element in a given bounds area.\n\n### Perform batch updates\n\nTapping the top-right button in the navigation bar triggers the collection view to perform a *batch update* of multiple animated operations (insert, delete, move, and reload) of its collection view cells all at the same time.\n\nWithin a call to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionView\/performBatchUpdates(_:completion:)], the system simultaneously animates all insert, delete, move, and reload operations. In this sample, the app batches updates by processing an array of `PersonUpdate` objects, each of which encapsulates one update:\n\nFirst, the `reload` operations are performed without animation because no cell movement is involved:\n\nNext, the remaining operations are animated:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/customizing-collection-view-layouts\ncrawled: 2025-12-02T15:52:13Z\n---\n\n# Customizing collection view layouts\n\n**Sample Code**\n\nCustomize a view layout by changing the size of cells in the flow or implementing a mosaic style.\n\n## Overview\n\nTo lay out UICollectionView cells in a simple grid, you can use [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout] directly. For more flexibility, you can subclass [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout] to create advanced layouts.\n\nThis sample app demonstrates two custom layout subclasses:\n\n- `ColumnFlowLayout` — A `UICollectionViewFlowLayout` subclass that arranges cells in a list format for narrow screens, or as a grid for wider screens. See “For a Simple Grid, Size Cells Dynamically,” below.\n- `MosaicLayout` — A `UICollectionViewLayout` subclass that lays out cells in a mosaic-style, nonconforming grid. See “For a Complex Grid, Define Cell Sizes Explicitly,” below.\n\nThe app opens to the Friends view controller, which uses a column flow layout to display a list of people. Tapping any cell takes you to the Feed view controller, which uses a mosaic layout to display photos from the user’s photo library.\n\nTapping the cloud icon to the right of the navigation bar demonstrates batched animations for inserting, deleting, moving, and reloading items in the collection view. For more information, see “Perform Batch Updates,” below. Using pull-to-refresh on the collection view resets the data.\n\n### For a simple grid, size cells dynamically\n\n`ColumnFlowLayout` is a subclass of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout] that uses the size of the collection view to determine the width of its cells. If only one cell fits comfortably horizontally, the layout arranges the cells to occupy the entire width of the collection view. Otherwise, the layout displays multiple columns of cells with a fixed width.\n\nIn practice, on iPhone devices in portrait mode, `ColumnFlowLayout` displays a single vertical column of cells. In landscape mode, or on an iPad, it displays a grid layout.\n\nUse the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/prepare()] function to compute the available screen width of the device and set the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout\/itemSize] property accordingly.\n\n```swift\noverride func prepare() {\n    super.prepare()\n\n    guard let collectionView = collectionView else { return }\n    \n    let availableWidth = collectionView.bounds.inset(by: collectionView.layoutMargins).width\n    let maxNumColumns = Int(availableWidth \/ minColumnWidth)\n    let cellWidth = (availableWidth \/ CGFloat(maxNumColumns)).rounded(.down)\n    \n    self.itemSize = CGSize(width: cellWidth, height: cellHeight)\n    self.sectionInset = UIEdgeInsets(top: self.minimumInteritemSpacing, left: 0.0, bottom: 0.0, right: 0.0)\n    self.sectionInsetReference = .fromSafeArea\n}\n```\n\n### For a complex grid, define cell sizes explicitly\n\nIf you need more customization than is possible with a subclass of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewFlowLayout], subclass [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout] instead.\n\n`MosaicLayout` is a `UICollectionViewLayout` subclass that displays an arbitrary number of cells with differing sizes and aspect ratios. The `FeedViewController` class uses a mosaic layout to display images from the user’s photo library. Cells are organized into rows in one of four styles, from a single cell to multiple cells in varying layouts.\n\n\n\n**Calculate cell dimensions**\n\nThe [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/prepare()] method is called whenever a layout is invalidated. Override this method to calculate the position and size of every cell, as well as the total dimensions for the entire layout.\n\n```swift\noverride func prepare() {\n    super.prepare()\n    \n    guard let collectionView = collectionView else { return }\n\n    \/\/ Reset cached information.\n    cachedAttributes.removeAll()\n    contentBounds = CGRect(origin: .zero, size: collectionView.bounds.size)\n    \n    \/\/ For every item in the collection view:\n    \/\/  - Prepare the attributes.\n    \/\/  - Store attributes in the cachedAttributes array.\n    \/\/  - Combine contentBounds with attributes.frame.\n    let count = collectionView.numberOfItems(inSection: 0)\n    \n    var currentIndex = 0\n    var segment: MosaicSegmentStyle = .fullWidth\n    var lastFrame: CGRect = .zero\n    \n    let cvWidth = collectionView.bounds.size.width\n    \n    while currentIndex < count {\n        let segmentFrame = CGRect(x: 0, y: lastFrame.maxY + 1.0, width: cvWidth, height: 200.0)\n        \n        var segmentRects = [CGRect]()\n        switch segment {\n        case .fullWidth:\n            segmentRects = [segmentFrame]\n            \n        case .fiftyFifty:\n            let horizontalSlices = segmentFrame.dividedIntegral(fraction: 0.5, from: .minXEdge)\n            segmentRects = [horizontalSlices.first, horizontalSlices.second]\n            \n        case .twoThirdsOneThird:\n            let horizontalSlices = segmentFrame.dividedIntegral(fraction: (2.0 \/ 3.0), from: .minXEdge)\n            let verticalSlices = horizontalSlices.second.dividedIntegral(fraction: 0.5, from: .minYEdge)\n            segmentRects = [horizontalSlices.first, verticalSlices.first, verticalSlices.second]\n            \n        case .oneThirdTwoThirds:\n            let horizontalSlices = segmentFrame.dividedIntegral(fraction: (1.0 \/ 3.0), from: .minXEdge)\n            let verticalSlices = horizontalSlices.first.dividedIntegral(fraction: 0.5, from: .minYEdge)\n            segmentRects = [verticalSlices.first, verticalSlices.second, horizontalSlices.second]\n        }\n        \n        \/\/ Create and cache layout attributes for calculated frames.\n        for rect in segmentRects {\n            let attributes = UICollectionViewLayoutAttributes(forCellWith: IndexPath(item: currentIndex, section: 0))\n            attributes.frame = rect\n            \n            cachedAttributes.append(attributes)\n            contentBounds = contentBounds.union(lastFrame)\n            \n            currentIndex += 1\n            lastFrame = rect\n        }\n\n        \/\/ Determine the next segment style.\n        switch count - currentIndex {\n        case 1:\n            segment = .fullWidth\n        case 2:\n            segment = .fiftyFifty\n        default:\n            switch segment {\n            case .fullWidth:\n                segment = .fiftyFifty\n            case .fiftyFifty:\n                segment = .twoThirdsOneThird\n            case .twoThirdsOneThird:\n                segment = .oneThirdTwoThirds\n            case .oneThirdTwoThirds:\n                segment = .fiftyFifty\n            }\n        }\n    }\n}\n```\n\n**Provide the content size**\n\nOverride the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/collectionViewContentSize] property, providing a size for the collection view.\n\n```swift\noverride var collectionViewContentSize: CGSize {\n    return contentBounds.size\n}\n```\n\n**Define the layout attributes**\n\nOverride [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/layoutAttributesForElements(in:)], defining the layout attributes for a geometric region. The collection view calls this function periodically to display items, which is known as *querying by geometric region*.\n\n```swift\noverride func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {\n    var attributesArray = [UICollectionViewLayoutAttributes]()\n    \n    \/\/ Find any cell that sits within the query rect.\n    guard let lastIndex = cachedAttributes.indices.last,\n          let firstMatchIndex = binSearch(rect, start: 0, end: lastIndex) else { return attributesArray }\n    \n    \/\/ Starting from the match, loop up and down through the array until all the attributes\n    \/\/ have been added within the query rect.\n    for attributes in cachedAttributes[..<firstMatchIndex].reversed() {\n        guard attributes.frame.maxY >= rect.minY else { break }\n        attributesArray.append(attributes)\n    }\n    \n    for attributes in cachedAttributes[firstMatchIndex...] {\n        guard attributes.frame.minY <= rect.maxY else { break }\n        attributesArray.append(attributes)\n    }\n    \n    return attributesArray\n}\n```\n\nAlso provide the layout attributes for a specific item by implementing [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/layoutAttributesForItem(at:)]. The collection view calls this function periodically to display one particular item, which is known as *querying by index path*.\n\n```swift\noverride func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {\n    return cachedAttributes[indexPath.item]\n}\n```\n\nBecause these functions are called often, they can affect the performance of your app. To make them as efficient as possible, follow the example code as closely as you can.\n\n**Handle bounds changes**\n\nThe [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSCollectionViewLayout\/shouldInvalidateLayout(forBoundsChange:)] function is called for every bounds change from the collection view, or whenever its size or origin changes. This function is also called frequently during scrolling. The default implementation returns `false`, or, if the size and origin change, it returns `true`.\n\n```swift\noverride func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool {\n    guard let collectionView = collectionView else { return false }\n    return !newBounds.size.equalTo(collectionView.bounds.size)\n}\n```\n\nFor optimum performance, this sample performs a binary search inside [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionViewLayout\/layoutAttributesForElements(in:)] instead of a linear search of the attributes it needs for each element in a given bounds area.\n\n### Perform batch updates\n\nTapping the top-right button in the navigation bar triggers the collection view to perform a *batch update* of multiple animated operations (insert, delete, move, and reload) of its collection view cells all at the same time.\n\nWithin a call to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UICollectionView\/performBatchUpdates(_:completion:)], the system simultaneously animates all insert, delete, move, and reload operations. In this sample, the app batches updates by processing an array of `PersonUpdate` objects, each of which encapsulates one update:\n\n- `insert` with a `Person` object and insertion index.\n- `delete` with an index.\n- `move` from one index to another.\n- `reload` with an index.\n\nFirst, the `reload` operations are performed without animation because no cell movement is involved:\n\n```swift\n\/\/ Perform any cell reloads without animation because there is no movement.\nUIView.performWithoutAnimation {\n    collectionView.performBatchUpdates({\n        for update in remoteUpdates {\n            if case let .reload(index) = update {\n                people[index].isUpdated = true\n                collectionView.reloadItems(at: [IndexPath(item: index, section: 0)])\n            }\n        }\n    })\n}\n```\n\nNext, the remaining operations are animated:\n\n```swift\n\/\/ Animate all other update types together.\ncollectionView.performBatchUpdates({\n    var deletes = [Int]()\n    var inserts = [(person:Person, index:Int)]()\n\n    for update in remoteUpdates {\n        switch update {\n        case let .delete(index):\n            collectionView.deleteItems(at: [IndexPath(item: index, section: 0)])\n            deletes.append(index)\n            \n        case let .insert(person, index):\n            collectionView.insertItems(at: [IndexPath(item: index, section: 0)])\n            inserts.append((person, index))\n            \n        case let .move(fromIndex, toIndex):\n            \/\/ Updates that move a person are split into an addition and a deletion.\n            collectionView.moveItem(at: IndexPath(item: fromIndex, section: 0),\n                                    to: IndexPath(item: toIndex, section: 0))\n            deletes.append(fromIndex)\n            inserts.append((people[fromIndex], toIndex))\n            \n        default: break\n        }\n    }\n    \n    \/\/ Apply deletions in descending order.\n    for deletedIndex in deletes.sorted().reversed() {\n        people.remove(at: deletedIndex)\n    }\n    \n    \/\/ Apply insertions in ascending order.\n    let sortedInserts = inserts.sorted(by: { (personA, personB) -> Bool in\n        return personA.index <= personB.index\n    })\n    for insertion in sortedInserts {\n        people.insert(insertion.person, at: insertion.index)\n    }\n    \n    \/\/ The update button is enabled only if the list still has people in it.\n    navigationItem.rightBarButtonItem?.isEnabled = !people.isEmpty\n})\n```\n\n## Manual layouts\n\n- **UICollectionViewLayout**: An abstract base class for generating layout information for a collection view.\n- **UICollectionViewFlowLayout**: A layout object that organizes items into a grid with optional header and footer views for each section.\n- **UICollectionViewTransitionLayout**: A special type of layout object that lets you implement behaviors when changing from one layout to another in your collection view.\n- **UICollectionViewLayoutAttributes**: A layout object that manages the layout-related attributes for a given item in a collection view.\n- **UICollectionViewFlowLayoutInvalidationContext**: A set of properties for determining whether to recompute the size of items or their position in the layout.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An abstract base class for generating layout information for a collection view.",
          "name" : "UICollectionViewLayout",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewLayout"
        },
        {
          "description" : "A layout object that organizes items into a grid with optional header and footer views for each section.",
          "name" : "UICollectionViewFlowLayout",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewFlowLayout"
        },
        {
          "description" : "A special type of layout object that lets you implement behaviors when changing from one layout to another in your collection view.",
          "name" : "UICollectionViewTransitionLayout",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewTransitionLayout"
        },
        {
          "description" : "A layout object that manages the layout-related attributes for a given item in a collection view.",
          "name" : "UICollectionViewLayoutAttributes",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewLayoutAttributes"
        },
        {
          "description" : "A set of properties for determining whether to recompute the size of items or their position in the layout.",
          "name" : "UICollectionViewFlowLayoutInvalidationContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UICollectionViewFlowLayoutInvalidationContext"
        }
      ],
      "title" : "Manual layouts"
    }
  ],
  "source" : "appleJSON",
  "title" : "Customizing collection view layouts",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/customizing-collection-view-layouts"
}