{
  "abstract" : "Add Writing Tools support, including support for inline replacement animations, to your custom iOS views that contain text.",
  "codeExamples" : [
    {
      "code" : "class MyTextView : UIView {\n    var coordinator: UIWritingToolsCoordinator?\n\n   \/\/…\n}\n\nextension MyTextView : UIWritingToolsCoordinator.Delegate {\n\n    func configureWritingTools() {\n        guard UIWritingToolsCoordinator.isWritingToolsAvailable else { return }\n        guard coordinator == nil else { return }\n        \n        coordinator = UIWritingToolsCoordinator(delegate:self)\n        addInteraction(coordinator!)\n    }\n   \/\/…\n}",
      "language" : "swift"
    },
    {
      "code" : "func configureWritingTools() {\n    guard UIWritingToolsCoordinator.isWritingToolsAvailable else { return }\n    guard coordinator == nil else { return }\n\n    coordinator = UIWritingToolsCoordinator(delegate:self)\n    coordinator?.preferredBehavior = .complete\n    coordinator?.preferredResultOptions = [.richText, .list]\n    addInteraction(coordinator!)\n}",
      "language" : "swift"
    },
    {
      "code" : "func writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsContextsFor scope: UIWritingToolsCoordinator.ContextScope,\n        completion: @escaping ([UIWritingToolsCoordinator.Context]) -> Void) {\n\n    \/\/ Store the created contexts for the completion handler.\n    var contexts = [UIWritingToolsCoordinator.Context]()\n                \n    switch scope {\n    case .userSelection:\n        let context = getContextObjectForSelection()\n        contexts.append(context)\n        break\n            \n    case .fullDocument:\n        let context = getContextObjectForFullDocument()\n        contexts.append(context)\n        break\n\n    case .visibleArea:\n        let context = getContextObjectForVisibleArea()\n        contexts.append(context)\n        break\n\n    default:\n        break\n    }\n        \n    \/\/ Save references to the contexts for later delegate calls.\n    storeContexts(contexts)\n        \n    \/\/ Deliver the contexts to Writing Tools.\n    completion(contexts)\n}",
      "language" : "swift"
    },
    {
      "code" : "var startingLocationsForContexts = [UUID : Int]()\n\nfunc getContextObjectForSelection() -> UIWritingToolsCoordinator.Context {\n    \/\/ Get the text to evaluate, which includes the text selection and some\n    \/\/ of the surrounding text. The method returns (NSAttributedString, Int),\n    \/\/ which represents the text itself, and the starting location of that\n    \/\/ text in the view's text storage.\n    let (textToEvaluate, startLocation) = getSelectedTextToEvaluate()\n\n    \/\/ Get the NSRange for the text selection, relative to the text storage.\n    let textSelectionRange = getTextSelectionRange()\n    var contextRange = textSelectionRange\n        \n    \/\/ The view guarantees that startLocation is less than or equal to the\n    \/\/ selection range. Adjust contextRange so that location 0 corresponds\n    \/\/ to the first character in textToEvaluate. Keep the length the same.\n    contextRange.location = textSelectionRange.location - startLocation\n        \n    \/\/ Create the new context object.\n    let context = UIWritingToolsCoordinator.Context(attributedString: textToEvaluate, range: contextRange)\n    \n    \/\/ Save the starting location of the text, relative to the text storage.\n    startingLocationsForContexts[context.identifier] = startLocation\n    \n    return context\n}",
      "language" : "swift"
    },
    {
      "code" : "func writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        replace range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        proposedText replacementText: NSAttributedString, \n        reason: UIWritingToolsCoordinator.TextReplacementReason, \n        animationParameters: UIWritingToolsCoordinator.AnimationParameters?, \n        completion: @escaping (NSAttributedString?) -> Void) {\n        \n    \/\/ Make sure there's a valid starting location in the text storage.\n    guard let startingLocation = startingLocationsForContexts[context.identifier] \n        else { completion(nil); return }\n    guard let textStorage = textContentStorage.textStorage else { completion(nil); return }\n\n    \/\/ Determine the correct location in the text storage.\n    let adjustedRange = NSRange(location: startingLocation + range.location, length: range.length)\n        \n    \/\/ Update the view’s NSTextContentManager using a transaction.\n    textContentStorage.performEditingTransaction {\n        textStorage.replaceCharacters(in: adjustedRange, with: replacementText)\n    }\n    \n    completion(replacementText)\n}",
      "language" : "swift"
    },
    {
      "code" : "func writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        select ranges: [NSValue], \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping () -> Void) {\n        \n    guard let startingLocation = startingLocationsForContexts[context.identifier] \n              else { completion(); return }\n    var adjustedRanges = [NSRange]()\n        \n    for value in ranges {\n        let range = value.rangeValue\n        let newRange = NSRange(location: startingLocation + range.location, length: range.length)\n        adjustedRanges.append(newRange)\n    }\n\n    \/\/ Highlight the specified text in the view.\n    selectTextInDocument(adjustedRanges)\n    completion()\n}",
      "language" : "swift"
    },
    {
      "code" : "func writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsPreviewFor textAnimation: UIWritingToolsCoordinator.TextAnimation, \n        of range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping (UITargetedPreview?) -> Void) {\n        \n    let textRange = MyTextRange(range)         \/\/ Create the view's custom subclass of NSTextRange.\n    let textRects = getTextRectangles(range)   \/\/ Returns an array of NSValue<NSRect*>.\n\n    if !textRange.isEmpty {\n        \/\/ Get the frame rectangle that encloses the text.\n        let textFrame = unionRect(for: textRects.map({$0.cgRectValue}))\n            \n        \/\/ Create the image renderer and render the image.\n        let renderer = UIGraphicsImageRenderer(bounds: textFrame)\n        let image = renderer.image { context in\n            \/\/ Limit drawing to the text rectangles.\n            context.cgContext.clip(to: textRects.map({$0.cgRectValue}))\n                \n            \/\/ Draw the specified range of text using the view's layout manager.\n            drawTextInRange(range)\n        }\n        \/\/ Create an image view and set its frame to match the area with the text.\n        let imageView = UIImageView(image:image)\n        imageView.frame = textFrame\n            \n        \/\/ Create the targeted preview.\n        let parameters = UIPreviewParameters(textLineRects: \n                       textRects.map({NSValue(cgRect: $0.cgRectValue)}))\n        let target = UIPreviewTarget(container: self, center: self.center)\n        let preview = UITargetedPreview(view: imageView, parameters: parameters, target: target)\n            \n        completion(preview)\n    }\n    else {\n        completion(nil)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsUnderlinePathsFor range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping ([UIBezierPath]) -> Void) {\n\n    let textRects = getTextRectangles(range)   \/\/ Returns an array of NSValue<NSRect*>.\n        \n    var paths = [UIBezierPath]()\n    for rect in textRects.map({$0.cgRectValue}) {\n        let underlineHeight: CGFloat = 2\n        let newRect = CGRect(x: rect.origin.x, y: rect.origin.y + rect.height - (underlineHeight\/2), \n                             width: rect.width, height: underlineHeight)\n        paths.append(UIBezierPath(rect: newRect))\n    }\n                \n    completion(paths)\n\n}",
      "language" : "swift"
    },
    {
      "code" : "func writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsBoundingBezierPathsFor range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping ([UIBezierPath]) -> Void) {\n\n    let textRects = getTextRectangles(range)   \/\/ Returns an array of NSValue<NSRect*>.\n        \n    var paths = [UIBezierPath]()\n    for rect in textRects.map({$0.cgRectValue}) {\n        paths.append(UIBezierPath(rect: rect))\n    }\n                \n    completion(paths)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "5d0fc485b63542292dd9a671ebfc5cedae39c9761eabdd39c7bd0bc8c6b77166",
  "crawledAt" : "2025-12-03T05:49:26Z",
  "id" : "7495D3E3-62A2-4766-8444-684E2F70BECE",
  "kind" : "article",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nIf you don’t use a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextView] or [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextField] object in your app, you can still add Writing Tools support to other views that contain text. You might use this support when you prefer not to use the standard text views. For example, you might use it if you build your own text view using TextKit or your own proprietary text engine. The UIKit API for this support gives you access to the same Writing Tools features available in the system views, including the ability to animate changes to the text in your view.\n\nWhen a person triggers the Writing Tools UI from your custom view, UIKit works with your view to evaluate the relevant text and incorporate changes. You specify the type of Writing Tools experience you want for your view. The complete experience animates changes to your view’s content directly, working with your view to create those animations. The limited experience displays changes in the Writing Tools UI, and only incorporates the final changes back into your view’s text storage. All of these interactions happen with the help of the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator] object you attach to your view.\n\n### Add a Writing Tools coordinator to your view\n\nA [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator] object manages interactions between your view and the Writing Tools feature. In iOS, this object is a type of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIInteraction] object, and you attach to your view only when you want to support Writing Tools. To manage your view-specific behavior, you provide a delegate object when setting up the coordinator. Your delegate provides Writing Tools with initial text to evaluate, incorporates changes, provides proofreading marks, and provides preview objects to use during animations.\n\nAttach a coordinator object to your view, typically when creating and configuring that view. Supply a delegate object that adopts the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol] protocol and has access to your view’s text content and layout information. The following example shows an extension to a custom view that creates the coordinator and initializes it with the view itself. The custom method checks to see if Writing Tools is available before creating a coordinator object and adding it to the view.\n\nThe presence of a coordinator object on your view causes UIKit to enable Writing Tools support for that view. When someone interacts with your view’s contextual menu, UIKit automatically adds a command to that menu to launch Writing Tools.\n\nFor a complete list of delegate methods you must implement to support Writing Tools, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol].\n\n### Configure your view’s Writing Tools behavior\n\nWhen setting up Writing Tools for your view, configure your coordinator’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/preferredBehavior] property with the types of interactions you support. Writing Tools offers different levels of integration with your view’s content, which also affects how much work you need to do to support the feature. With the complete experience, you provide UIKit with more information so that it can make changes directly in your view. The limited experience pushes more interactions into the Writing Tools UI, giving you a less integrated experience, but one that’s easier to implement.\n\nAt configuration time, you also specify the types of text content your view supports using your coordinator’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/preferredResultOptions] property. The models that Writing Tools uses to evaluate your text can generate plain or formatted text. Writing Tools supports all types of output by default, but you can limit it to specific types as needed.\n\nThe following code updates the previous example method, and adds some preferred behaviors for the coordinator object. In addition to wanting the inline experience for Writing Tools interactions, the method requests that the system generate rich text and optional list-based content. Providing a specific list of result options tells Writing Tools to generate only that type of content. You might provide this information if your view doesn’t support specific types of content, like tables.\n\nThe availability of Writing Tools depends on the current device, its operating system, and its readiness to execute requests. On devices with appropriate hardware, some Writing Tools features operate locally after the system downloads the required models. However, more complex requests require a network connection so the system can use [https:\/\/security.apple.com\/documentation\/private-cloud-compute] to evaluate the provided text.\n\n### Supply your view’s text for evaluation\n\nWhen someone starts Writing Tools in your view, the system asks your delegate to provide the text to evaluate. Depending on what the person wants to do, Writing Tools might ask for only the selected text or it might ask for all of your view’s text. For example, they might want to proof only the currently selected text, or they might want to proofread all of the text in your view. You provide that text from your delegate inside a context object.\n\nA [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Context] object is a data object that you fill with the requested text. Context objects provide the common ground that you and Writing Tools use to communicate throughout a single operation. For each request, you create one context object for each text-storage object that has text for Writing Tools to consider. Most views have only one text-storage object and therefore create only one context object. However, a view that uses multiple subviews to manage different parts of its content might assign separate text- storage objects to each subview. In that scenario, you create one context object for each subview that contains the requested text.\n\nTo request your view’s context object, the coordinator calls your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:requestsContextsFor:completion:)] method. Use the parameters of that method to determine if Writing Tools wants all of your view’s text or only some of it. The following example creates a single context object with either the currently selected text or the view’s full text. After creating the context, the custom `storeContexts` method saves a reference to the context for subsequent tasks.\n\nWhen specifying only a subset of your view’s text, provide some of the surrounding text to give Writing Tools additional content for its evaluation. As a general principle, include whole paragraphs of text in the context object, not just the currently selected text. Use the context object’s range value to identify the portion of the overall text that Writing Tools requested. For example, if you fill a context object with the current text selection and some of the surrounding text, use the context object’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Context\/range] property to specify the location of the selected text in that object.\n\nAfter you create a context object, cache any additional information that you need to map the text in your context object to the text in your view’s text storage. You need to know where the content for each context object starts, in order to update your text storage later. One option is to create a dictionary that maps the context object’s identifier to the starting location of its text in your text storage. You can use that value to adjust any context-specific ranges that Writing provides you later.\n\nThe following example shows a method that the delegate uses to create a context object for the current text selection. The method calls the custom `getSelectedTextToEvaluate` function, which returns an expanded version of the text that includes both the selection and some of the surrounding text. The method also returns the starting location of that expanded text in the view’s text storage. Because the text selection is now in the middle of the text, the method initializes the context object with a range that provides the location of only the selected text, relative to the start of `textToEvaluate`. The method saves the actual starting location in a dictionary variable, mapping the value to the context’s unique identifier.\n\nAfter you create a context object, you can use its unique identifier as a key for saving other data. The context objects you create remain in existence for the duration of the current Writing Tools operation. If the person rejects the current changes and starts a new operation, Writing Tools asks you for a new set of context objects.\n\n### Incorporate Writing Tools changes into your view\n\nAfter evaluating your view’s text, Writing Tools delivers any suggested changes to your delegate object. If your view adopts the limited experience, Writing Tools waits until the person accepts any changes before delivering them to your view. If you adopt the complete experience, Writing Tools delivers the changes before the person accepts them. If the person later rejects the changes, Writing Tools delivers a new set of changes that restore your view’s original text.\n\nIn your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:replace:in:proposedText:reason:animationParameters:completion:)] method, incorporate the specified change into your view’s text storage. Writing Tools calls this method for each distinct change it needs to make, and it might call the method multiple times with different range values for the same context object. The following simple example validates the provided range information and validates the view’s own cached information for the context object. If everything is valid, the method then calculates the correct range of text to replace and creates a transaction to perform the replacement. Before returning, the method executes the provided completion handler with the text it incorporated, if any.\n\nAfter each replacement operation, update other parts of your app as needed to account for the change. An [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContentManager] object automatically generates the required layout updates when you make changes using a transaction. If you need to update other parts of your interface, initiate those changes from your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:replace:in:proposedText:reason:animationParameters:completion:)] method. For example, you might update a view that displays the current character count for your document. Check the `reason` parameter to determine when Writing Tools is making changes interactively, and use the provided animation parameters object to create the actual animations.\n\n### Update your view’s selected text\n\nWhen working on your view’s selected text, Writing Tools updates the text selection to account for any text updates. Use your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:select:in:completion:)] method to update the selected text in your view. The method delivers an array of range values to allow for views to create discontiguous selections. If your view supports only a continuous range of selected characters, update your view’s selection based on the first element in the `ranges` array.\n\nWhen implementing your delegate method, remember to update range values to account for offset to the start of the text in your context object. The following example creates an adjusted set of ranges by adding the starting location recorded at the start of the operation for the context object. It then passes that information to the view’s text engine to highlight the appropriate ranges of text.\n\n### Generate preview images for inline animated changes\n\nWhen you choose the complete Writing Tools experience for your view, the system animates changes to your content directly in your view. The system creates animations when Writing Tools starts evaluating your text, when it removes old text, and when it inserts new text. Because the animations involve your content, you must help the system create them. At appropriate times, the coordinator asks your delegate object to perform the following tasks:\n\nTo create a preview image of your text, use your layout manager and a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGraphicsImageRenderer] to generate the image in your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:requestsPreviewFor:of:in:completion:)] method. Use your layout manager to get the frame rectangle that surrounds the specified text, and configure your image renderer with the size of that rectangle. In your rendering code, configure a clipping path to limit drawing to the area that contains only the specified text, and render that text onto a clear background.\n\nThe following example shows an implementation of the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:requestsPreviewFor:of:in:completion:)] method that creates a preview image for the view’s text. The method relies on the view’s layout manager to get the text rectangles that surround each line of text in the specified range. It also uses the layout manager to draw the text within the block of the graphics renderer. The image renderer generates an image with the rendered text, which the method places in an image view and uses to create a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITargetedPreview] object. Setting the frame rectangle of the image view tells Writing Tools where to place that image in the overall text view. When creating animations, Writing Tools applies the required visual effects to the provided image view instead of to the text itself.\n\nIn addition to providing the initial image, use the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:prepareFor:for:in:completion:)] method to hide the specified range of text in your view. UIKit inserts the image view from your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITargetedPreview] object into the same part of your view that contains the hidden text. Placement of the image view is important, which is why you must set its frame rectangle to the precise location of the text in your view. When the animations finish, Writing Tools calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:finish:for:in:completion:)] method so you can show the text in the specified range again.\n\n### Create proofreading marks for your content\n\nIf someone chooses a proofreading option, Writing Tools evaluates your view’s text and asks you to provide proofreading marks to decorate the view. For each mark, Writing Tools asks you to provide a Bézier path that underlines the text in a particular range. The following example uses the view’s layout manager to get the bounding rectangles for the specified range of text. It then flattens those rectangles to create a line shape underneath the text and passes the resulting paths to the completion handler. The code creates separate shapes for each rectangle to account for situations where a proofreading mark extends onto multiple lines of text.\n\nIn addition to providing the proofreading mark shapes, Writing Tools also asks you to provide the bounding rectangles for the text itself. Writing Tools uses these bounding rectangles to draw highlights around your text. The following example retrieves the bounding rectangles for the specified range of text and passes a Bézier path for each rectangle to the completion handler:\n\n### Respond to state changes\n\nDuring the course of changing content, the state of the Writing Tools system changes based on what’s happening. Writing Tools starts in the inactive state, but quickly moves to other states based on the type of experience it creates. When a person accepts or rejects the changes for the current operation, Writing Tools moves back to inactive state. You might use your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:willChangeTo:completion:)] method to respond to the following types of changes:\n\nFor more information about how to handle individual states, see the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/State-swift.enum] type.\n\n### Inform the coordinator of external changes to your content\n\nWhen Writing Tools is active, it tracks changes to the text in your view. If you make changes to your view’s text storage while Writing Tools is active, let the system know immediately. Writing Tools tracks the changes it makes internally, so it needs to know about any external changes to make sure it delivers accurate information to your delegate object. To notify Writing Tools of any changes, use one of the following methods:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/adding-writing-tools-support-to-a-custom-uiview\ncrawled: 2025-12-03T05:49:26Z\n---\n\n# Adding Writing Tools support to a custom UIKit view\n\n**Article**\n\nAdd Writing Tools support, including support for inline replacement animations, to your custom iOS views that contain text.\n\n## Overview\n\nIf you don’t use a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextView] or [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITextField] object in your app, you can still add Writing Tools support to other views that contain text. You might use this support when you prefer not to use the standard text views. For example, you might use it if you build your own text view using TextKit or your own proprietary text engine. The UIKit API for this support gives you access to the same Writing Tools features available in the system views, including the ability to animate changes to the text in your view.\n\nWhen a person triggers the Writing Tools UI from your custom view, UIKit works with your view to evaluate the relevant text and incorporate changes. You specify the type of Writing Tools experience you want for your view. The complete experience animates changes to your view’s content directly, working with your view to create those animations. The limited experience displays changes in the Writing Tools UI, and only incorporates the final changes back into your view’s text storage. All of these interactions happen with the help of the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator] object you attach to your view.\n\n### Add a Writing Tools coordinator to your view\n\nA [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator] object manages interactions between your view and the Writing Tools feature. In iOS, this object is a type of [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIInteraction] object, and you attach to your view only when you want to support Writing Tools. To manage your view-specific behavior, you provide a delegate object when setting up the coordinator. Your delegate provides Writing Tools with initial text to evaluate, incorporates changes, provides proofreading marks, and provides preview objects to use during animations.\n\nAttach a coordinator object to your view, typically when creating and configuring that view. Supply a delegate object that adopts the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol] protocol and has access to your view’s text content and layout information. The following example shows an extension to a custom view that creates the coordinator and initializes it with the view itself. The custom method checks to see if Writing Tools is available before creating a coordinator object and adding it to the view.\n\n```swift\nclass MyTextView : UIView {\n    var coordinator: UIWritingToolsCoordinator?\n\n   \/\/…\n}\n\nextension MyTextView : UIWritingToolsCoordinator.Delegate {\n\n    func configureWritingTools() {\n        guard UIWritingToolsCoordinator.isWritingToolsAvailable else { return }\n        guard coordinator == nil else { return }\n        \n        coordinator = UIWritingToolsCoordinator(delegate:self)\n        addInteraction(coordinator!)\n    }\n   \/\/…\n}\n```\n\nThe presence of a coordinator object on your view causes UIKit to enable Writing Tools support for that view. When someone interacts with your view’s contextual menu, UIKit automatically adds a command to that menu to launch Writing Tools.\n\nFor a complete list of delegate methods you must implement to support Writing Tools, see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol].\n\n### Configure your view’s Writing Tools behavior\n\nWhen setting up Writing Tools for your view, configure your coordinator’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/preferredBehavior] property with the types of interactions you support. Writing Tools offers different levels of integration with your view’s content, which also affects how much work you need to do to support the feature. With the complete experience, you provide UIKit with more information so that it can make changes directly in your view. The limited experience pushes more interactions into the Writing Tools UI, giving you a less integrated experience, but one that’s easier to implement.\n\nAt configuration time, you also specify the types of text content your view supports using your coordinator’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/preferredResultOptions] property. The models that Writing Tools uses to evaluate your text can generate plain or formatted text. Writing Tools supports all types of output by default, but you can limit it to specific types as needed.\n\nThe following code updates the previous example method, and adds some preferred behaviors for the coordinator object. In addition to wanting the inline experience for Writing Tools interactions, the method requests that the system generate rich text and optional list-based content. Providing a specific list of result options tells Writing Tools to generate only that type of content. You might provide this information if your view doesn’t support specific types of content, like tables.\n\n```swift\nfunc configureWritingTools() {\n    guard UIWritingToolsCoordinator.isWritingToolsAvailable else { return }\n    guard coordinator == nil else { return }\n\n    coordinator = UIWritingToolsCoordinator(delegate:self)\n    coordinator?.preferredBehavior = .complete\n    coordinator?.preferredResultOptions = [.richText, .list]\n    addInteraction(coordinator!)\n}\n```\n\nThe availability of Writing Tools depends on the current device, its operating system, and its readiness to execute requests. On devices with appropriate hardware, some Writing Tools features operate locally after the system downloads the required models. However, more complex requests require a network connection so the system can use [https:\/\/security.apple.com\/documentation\/private-cloud-compute] to evaluate the provided text.\n\n### Supply your view’s text for evaluation\n\nWhen someone starts Writing Tools in your view, the system asks your delegate to provide the text to evaluate. Depending on what the person wants to do, Writing Tools might ask for only the selected text or it might ask for all of your view’s text. For example, they might want to proof only the currently selected text, or they might want to proofread all of the text in your view. You provide that text from your delegate inside a context object.\n\nA [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Context] object is a data object that you fill with the requested text. Context objects provide the common ground that you and Writing Tools use to communicate throughout a single operation. For each request, you create one context object for each text-storage object that has text for Writing Tools to consider. Most views have only one text-storage object and therefore create only one context object. However, a view that uses multiple subviews to manage different parts of its content might assign separate text- storage objects to each subview. In that scenario, you create one context object for each subview that contains the requested text.\n\nTo request your view’s context object, the coordinator calls your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:requestsContextsFor:completion:)] method. Use the parameters of that method to determine if Writing Tools wants all of your view’s text or only some of it. The following example creates a single context object with either the currently selected text or the view’s full text. After creating the context, the custom `storeContexts` method saves a reference to the context for subsequent tasks.\n\n```swift\nfunc writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsContextsFor scope: UIWritingToolsCoordinator.ContextScope,\n        completion: @escaping ([UIWritingToolsCoordinator.Context]) -> Void) {\n\n    \/\/ Store the created contexts for the completion handler.\n    var contexts = [UIWritingToolsCoordinator.Context]()\n                \n    switch scope {\n    case .userSelection:\n        let context = getContextObjectForSelection()\n        contexts.append(context)\n        break\n            \n    case .fullDocument:\n        let context = getContextObjectForFullDocument()\n        contexts.append(context)\n        break\n\n    case .visibleArea:\n        let context = getContextObjectForVisibleArea()\n        contexts.append(context)\n        break\n\n    default:\n        break\n    }\n        \n    \/\/ Save references to the contexts for later delegate calls.\n    storeContexts(contexts)\n        \n    \/\/ Deliver the contexts to Writing Tools.\n    completion(contexts)\n}\n```\n\nWhen specifying only a subset of your view’s text, provide some of the surrounding text to give Writing Tools additional content for its evaluation. As a general principle, include whole paragraphs of text in the context object, not just the currently selected text. Use the context object’s range value to identify the portion of the overall text that Writing Tools requested. For example, if you fill a context object with the current text selection and some of the surrounding text, use the context object’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Context\/range] property to specify the location of the selected text in that object.\n\nAfter you create a context object, cache any additional information that you need to map the text in your context object to the text in your view’s text storage. You need to know where the content for each context object starts, in order to update your text storage later. One option is to create a dictionary that maps the context object’s identifier to the starting location of its text in your text storage. You can use that value to adjust any context-specific ranges that Writing provides you later.\n\nThe following example shows a method that the delegate uses to create a context object for the current text selection. The method calls the custom `getSelectedTextToEvaluate` function, which returns an expanded version of the text that includes both the selection and some of the surrounding text. The method also returns the starting location of that expanded text in the view’s text storage. Because the text selection is now in the middle of the text, the method initializes the context object with a range that provides the location of only the selected text, relative to the start of `textToEvaluate`. The method saves the actual starting location in a dictionary variable, mapping the value to the context’s unique identifier.\n\n```swift\nvar startingLocationsForContexts = [UUID : Int]()\n\nfunc getContextObjectForSelection() -> UIWritingToolsCoordinator.Context {\n    \/\/ Get the text to evaluate, which includes the text selection and some\n    \/\/ of the surrounding text. The method returns (NSAttributedString, Int),\n    \/\/ which represents the text itself, and the starting location of that\n    \/\/ text in the view's text storage.\n    let (textToEvaluate, startLocation) = getSelectedTextToEvaluate()\n\n    \/\/ Get the NSRange for the text selection, relative to the text storage.\n    let textSelectionRange = getTextSelectionRange()\n    var contextRange = textSelectionRange\n        \n    \/\/ The view guarantees that startLocation is less than or equal to the\n    \/\/ selection range. Adjust contextRange so that location 0 corresponds\n    \/\/ to the first character in textToEvaluate. Keep the length the same.\n    contextRange.location = textSelectionRange.location - startLocation\n        \n    \/\/ Create the new context object.\n    let context = UIWritingToolsCoordinator.Context(attributedString: textToEvaluate, range: contextRange)\n    \n    \/\/ Save the starting location of the text, relative to the text storage.\n    startingLocationsForContexts[context.identifier] = startLocation\n    \n    return context\n}\n```\n\nAfter you create a context object, you can use its unique identifier as a key for saving other data. The context objects you create remain in existence for the duration of the current Writing Tools operation. If the person rejects the current changes and starts a new operation, Writing Tools asks you for a new set of context objects.\n\n### Incorporate Writing Tools changes into your view\n\nAfter evaluating your view’s text, Writing Tools delivers any suggested changes to your delegate object. If your view adopts the limited experience, Writing Tools waits until the person accepts any changes before delivering them to your view. If you adopt the complete experience, Writing Tools delivers the changes before the person accepts them. If the person later rejects the changes, Writing Tools delivers a new set of changes that restore your view’s original text.\n\nIn your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:replace:in:proposedText:reason:animationParameters:completion:)] method, incorporate the specified change into your view’s text storage. Writing Tools calls this method for each distinct change it needs to make, and it might call the method multiple times with different range values for the same context object. The following simple example validates the provided range information and validates the view’s own cached information for the context object. If everything is valid, the method then calculates the correct range of text to replace and creates a transaction to perform the replacement. Before returning, the method executes the provided completion handler with the text it incorporated, if any.\n\n```swift\nfunc writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        replace range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        proposedText replacementText: NSAttributedString, \n        reason: UIWritingToolsCoordinator.TextReplacementReason, \n        animationParameters: UIWritingToolsCoordinator.AnimationParameters?, \n        completion: @escaping (NSAttributedString?) -> Void) {\n        \n    \/\/ Make sure there's a valid starting location in the text storage.\n    guard let startingLocation = startingLocationsForContexts[context.identifier] \n        else { completion(nil); return }\n    guard let textStorage = textContentStorage.textStorage else { completion(nil); return }\n\n    \/\/ Determine the correct location in the text storage.\n    let adjustedRange = NSRange(location: startingLocation + range.location, length: range.length)\n        \n    \/\/ Update the view’s NSTextContentManager using a transaction.\n    textContentStorage.performEditingTransaction {\n        textStorage.replaceCharacters(in: adjustedRange, with: replacementText)\n    }\n    \n    completion(replacementText)\n}\n```\n\nAfter each replacement operation, update other parts of your app as needed to account for the change. An [doc:\/\/com.apple.uikit\/documentation\/UIKit\/NSTextContentManager] object automatically generates the required layout updates when you make changes using a transaction. If you need to update other parts of your interface, initiate those changes from your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:replace:in:proposedText:reason:animationParameters:completion:)] method. For example, you might update a view that displays the current character count for your document. Check the `reason` parameter to determine when Writing Tools is making changes interactively, and use the provided animation parameters object to create the actual animations.\n\n### Update your view’s selected text\n\nWhen working on your view’s selected text, Writing Tools updates the text selection to account for any text updates. Use your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:select:in:completion:)] method to update the selected text in your view. The method delivers an array of range values to allow for views to create discontiguous selections. If your view supports only a continuous range of selected characters, update your view’s selection based on the first element in the `ranges` array.\n\nWhen implementing your delegate method, remember to update range values to account for offset to the start of the text in your context object. The following example creates an adjusted set of ranges by adding the starting location recorded at the start of the operation for the context object. It then passes that information to the view’s text engine to highlight the appropriate ranges of text.\n\n```swift\nfunc writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        select ranges: [NSValue], \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping () -> Void) {\n        \n    guard let startingLocation = startingLocationsForContexts[context.identifier] \n              else { completion(); return }\n    var adjustedRanges = [NSRange]()\n        \n    for value in ranges {\n        let range = value.rangeValue\n        let newRange = NSRange(location: startingLocation + range.location, length: range.length)\n        adjustedRanges.append(newRange)\n    }\n\n    \/\/ Highlight the specified text in the view.\n    selectTextInDocument(adjustedRanges)\n    completion()\n}\n```\n\n### Generate preview images for inline animated changes\n\nWhen you choose the complete Writing Tools experience for your view, the system animates changes to your content directly in your view. The system creates animations when Writing Tools starts evaluating your text, when it removes old text, and when it inserts new text. Because the animations involve your content, you must help the system create them. At appropriate times, the coordinator asks your delegate object to perform the following tasks:\n\n1. Create a preview image of a specific portion of your content.\n2. Hide that content when the animation starts.\n3. Show the content again when the animation finishes.\n\nTo create a preview image of your text, use your layout manager and a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGraphicsImageRenderer] to generate the image in your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:requestsPreviewFor:of:in:completion:)] method. Use your layout manager to get the frame rectangle that surrounds the specified text, and configure your image renderer with the size of that rectangle. In your rendering code, configure a clipping path to limit drawing to the area that contains only the specified text, and render that text onto a clear background.\n\nThe following example shows an implementation of the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:requestsPreviewFor:of:in:completion:)] method that creates a preview image for the view’s text. The method relies on the view’s layout manager to get the text rectangles that surround each line of text in the specified range. It also uses the layout manager to draw the text within the block of the graphics renderer. The image renderer generates an image with the rendered text, which the method places in an image view and uses to create a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITargetedPreview] object. Setting the frame rectangle of the image view tells Writing Tools where to place that image in the overall text view. When creating animations, Writing Tools applies the required visual effects to the provided image view instead of to the text itself.\n\n```swift\nfunc writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsPreviewFor textAnimation: UIWritingToolsCoordinator.TextAnimation, \n        of range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping (UITargetedPreview?) -> Void) {\n        \n    let textRange = MyTextRange(range)         \/\/ Create the view's custom subclass of NSTextRange.\n    let textRects = getTextRectangles(range)   \/\/ Returns an array of NSValue<NSRect*>.\n\n    if !textRange.isEmpty {\n        \/\/ Get the frame rectangle that encloses the text.\n        let textFrame = unionRect(for: textRects.map({$0.cgRectValue}))\n            \n        \/\/ Create the image renderer and render the image.\n        let renderer = UIGraphicsImageRenderer(bounds: textFrame)\n        let image = renderer.image { context in\n            \/\/ Limit drawing to the text rectangles.\n            context.cgContext.clip(to: textRects.map({$0.cgRectValue}))\n                \n            \/\/ Draw the specified range of text using the view's layout manager.\n            drawTextInRange(range)\n        }\n        \/\/ Create an image view and set its frame to match the area with the text.\n        let imageView = UIImageView(image:image)\n        imageView.frame = textFrame\n            \n        \/\/ Create the targeted preview.\n        let parameters = UIPreviewParameters(textLineRects: \n                       textRects.map({NSValue(cgRect: $0.cgRectValue)}))\n        let target = UIPreviewTarget(container: self, center: self.center)\n        let preview = UITargetedPreview(view: imageView, parameters: parameters, target: target)\n            \n        completion(preview)\n    }\n    else {\n        completion(nil)\n    }\n}\n```\n\nIn addition to providing the initial image, use the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:prepareFor:for:in:completion:)] method to hide the specified range of text in your view. UIKit inserts the image view from your [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITargetedPreview] object into the same part of your view that contains the hidden text. Placement of the image view is important, which is why you must set its frame rectangle to the precise location of the text in your view. When the animations finish, Writing Tools calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:finish:for:in:completion:)] method so you can show the text in the specified range again.\n\n### Create proofreading marks for your content\n\nIf someone chooses a proofreading option, Writing Tools evaluates your view’s text and asks you to provide proofreading marks to decorate the view. For each mark, Writing Tools asks you to provide a Bézier path that underlines the text in a particular range. The following example uses the view’s layout manager to get the bounding rectangles for the specified range of text. It then flattens those rectangles to create a line shape underneath the text and passes the resulting paths to the completion handler. The code creates separate shapes for each rectangle to account for situations where a proofreading mark extends onto multiple lines of text.\n\n```swift\nfunc writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsUnderlinePathsFor range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping ([UIBezierPath]) -> Void) {\n\n    let textRects = getTextRectangles(range)   \/\/ Returns an array of NSValue<NSRect*>.\n        \n    var paths = [UIBezierPath]()\n    for rect in textRects.map({$0.cgRectValue}) {\n        let underlineHeight: CGFloat = 2\n        let newRect = CGRect(x: rect.origin.x, y: rect.origin.y + rect.height - (underlineHeight\/2), \n                             width: rect.width, height: underlineHeight)\n        paths.append(UIBezierPath(rect: newRect))\n    }\n                \n    completion(paths)\n\n}\n```\n\nIn addition to providing the proofreading mark shapes, Writing Tools also asks you to provide the bounding rectangles for the text itself. Writing Tools uses these bounding rectangles to draw highlights around your text. The following example retrieves the bounding rectangles for the specified range of text and passes a Bézier path for each rectangle to the completion handler:\n\n```swift\nfunc writingToolsCoordinator(_ writingToolsCoordinator: UIWritingToolsCoordinator, \n        requestsBoundingBezierPathsFor range: NSRange, \n        in context: UIWritingToolsCoordinator.Context, \n        completion: @escaping ([UIBezierPath]) -> Void) {\n\n    let textRects = getTextRectangles(range)   \/\/ Returns an array of NSValue<NSRect*>.\n        \n    var paths = [UIBezierPath]()\n    for rect in textRects.map({$0.cgRectValue}) {\n        paths.append(UIBezierPath(rect: rect))\n    }\n                \n    completion(paths)\n}\n```\n\n### Respond to state changes\n\nDuring the course of changing content, the state of the Writing Tools system changes based on what’s happening. Writing Tools starts in the inactive state, but quickly moves to other states based on the type of experience it creates. When a person accepts or rejects the changes for the current operation, Writing Tools moves back to inactive state. You might use your delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol\/writingToolsCoordinator(_:willChangeTo:completion:)] method to respond to the following types of changes:\n\n- Use a transition to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/State-swift.enum\/inactive] state to clear any cached data from the previous operation.\n- Use transitions to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/State-swift.enum\/noninteractive] or [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/State-swift.enum\/interactiveResting] state to determine the level of interactivity with your view.\n- Use a transition to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/State-swift.enum\/interactiveStreaming] state to start progress controls or otherwise indicate that Writing Tools is working on the request. In addition, use transitions to and from this state to implement undo coalescing. Specifically, start a new undo group on a transition to this state, and end that undo group on a transition away from this state. Notify Writing Tools of any undo stack changes by calling the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/updateRange(_:with:reason:forContextWithIdentifier:)] method.\n\nFor more information about how to handle individual states, see the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/State-swift.enum] type.\n\n### Inform the coordinator of external changes to your content\n\nWhen Writing Tools is active, it tracks changes to the text in your view. If you make changes to your view’s text storage while Writing Tools is active, let the system know immediately. Writing Tools tracks the changes it makes internally, so it needs to know about any external changes to make sure it delivers accurate information to your delegate object. To notify Writing Tools of any changes, use one of the following methods:\n\n- Call the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/updateRange(_:with:reason:forContextWithIdentifier:)] method if you change the text that corresponds to text in one of your context objects. Depending on the scope of your changes, Writing Tools might incorporate your changes or abort the current operation altogether.\n- Call the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIWritingToolsCoordinator\/updateForReflowedTextInContextWithIdentifier(_:)] method to report any changes that affect your view’s layout. For example, call this method if the size of your view changes, or if you change the text that precedes what’s in one of your context objects. When you call this method, Writing Tools requests new previews, proofreading marks, and other layout-dependent information.\n\n## Writing Tools for custom views\n\n- **UIWritingToolsCoordinator**: An object that manages interactions between Writing Tools and your custom text view.\n- **UIWritingToolsCoordinator.Delegate**: An interface that you use to manage interactions between Writing Tools and your custom text view.\n- **UIWritingToolsCoordinator.Context**: A data object that you use to share your custom view’s text with Writing Tools.\n- **UIWritingToolsCoordinator.AnimationParameters**: An object you use to configure additional tasks or animations to run alongside the Writing Tools animations.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object that manages interactions between Writing Tools and your custom text view.",
          "name" : "UIWritingToolsCoordinator",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIWritingToolsCoordinator"
        },
        {
          "description" : "An interface that you use to manage interactions between Writing Tools and your custom text view.",
          "name" : "UIWritingToolsCoordinator.Delegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIWritingToolsCoordinator\/Delegate-swift.protocol"
        },
        {
          "description" : "A data object that you use to share your custom view’s text with Writing Tools.",
          "name" : "UIWritingToolsCoordinator.Context",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIWritingToolsCoordinator\/Context"
        },
        {
          "description" : "An object you use to configure additional tasks or animations to run alongside the Writing Tools animations.",
          "name" : "UIWritingToolsCoordinator.AnimationParameters",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIWritingToolsCoordinator\/AnimationParameters"
        }
      ],
      "title" : "Writing Tools for custom views"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding Writing Tools support to a custom UIKit view",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/adding-writing-tools-support-to-a-custom-uiview"
}