{
  "abstract" : "Manage documents across multiple devices to create a seamless editing and collaboration experience.",
  "codeExamples" : [
    {
      "code" : "    <key>NSUbiquitousContainers<\/key>\n    <dict>\n        <key>iCloud.com.example.apple-samplecode.SimpleiCloudDocument<\/key>\n        <dict>\n            <key>NSUbiquitousContainerIsDocumentScopePublic<\/key>\n            <true\/>\n            <key>NSUbiquitousContainerName<\/key>\n            <string>SimpleiCloudDocument<\/string>\n            <key>NSUbiquitousContainerSupportedFolderLevels<\/key>\n            <string>ANY<\/string>\n        <\/dict>\n    <\/dict>",
      "language" : "xml"
    },
    {
      "code" : "metadataQuery.notificationBatchingInterval = 1\nmetadataQuery.searchScopes = [NSMetadataQueryUbiquitousDataScope, NSMetadataQueryUbiquitousDocumentsScope]\nmetadataQuery.predicate = NSPredicate(format: \"%K LIKE %@\", NSMetadataItemFSNameKey, \"*.\" + Document.extensionName)\nmetadataQuery.sortDescriptors = [NSSortDescriptor(key: NSMetadataItemFSNameKey, ascending: true)]\nmetadataQuery.start()",
      "language" : "swift"
    },
    {
      "code" : "func metadataItemList() -> [MetadataItem] {\n    var result = [MetadataItem]()\n    metadataQuery.disableUpdates()\n    if let metadatItems = metadataQuery.results as? [NSMetadataItem] {\n        result = metadataItemList(from: metadatItems)\n    }\n    metadataQuery.enableUpdates()\n    return result\n}",
      "language" : "swift"
    },
    {
      "code" : "func retrieveImageAsynchronously(with imageName: String, completionHandler: @escaping (UIImage?) -> Void) {\n    performAsynchronousFileAccess {\n        let imageFileURL = self.fileURL.appendingPathComponent(imageName)\n        let fileCoordinator = NSFileCoordinator(filePresenter: self)\n        fileCoordinator.coordinate(readingItemAt: imageFileURL, options: .withoutChanges, error: nil) { newURL in\n            if let imageData = try? Data(contentsOf: newURL), let image = UIImage(data: imageData) {\n                completionHandler(image)\n            } else {\n                completionHandler(nil)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "override func save(to url: URL, for saveOperation: UIDocument.SaveOperation, completionHandler: ((Bool) -> Void)? = nil) {\n    if saveOperation != .forCreating {\n        print(\"\\(#function)\")\n        return performAsynchronousFileAccess {\n            let fileCoordinator = NSFileCoordinator(filePresenter: self)\n            fileCoordinator.coordinate(writingItemAt: self.fileURL, options: .forMerging, error: nil) { newURL in\n                let success = self.fulfillUnsavedChanges()\n                self.fileModificationDate = Date()\n                if let completionHandler = completionHandler {\n                    DispatchQueue.main.async {\n                        completionHandler(success)\n                    }\n                }\n            }\n        }\n    }\n    super.save(to: url, for: saveOperation, completionHandler: completionHandler)\n}",
      "language" : "swift"
    },
    {
      "code" : "private func resolveConflictsAsynchronously(document: Document, completionHandler: ((Bool) -> Void)?) {\n    DispatchQueue.global().async {\n        NSFileCoordinator().coordinate(writingItemAt: document.fileURL,\n                                       options: .contentIndependentMetadataOnly, error: nil) { newURL in\n            let shouldRevert = self.pickLatestVersion(for: newURL)\n            completionHandler?(shouldRevert)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "a15396f2201f058b9a60d365c46c851ee5c5b53facceafb11cd769c1b1933fe5",
  "crawledAt" : "2025-12-02T15:52:30Z",
  "id" : "EA71A3E8-6FC7-41FF-BD48-318A9A5989FD",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nAs technology advances, more and more people generate their digital assets from different devices, and expect those assets to synchronize seamlessly. To support such use cases, apps need to discover the assets, as well as their changes, from all the devices, and present the user with a consistent view.\n\nThis sample demonstrates how to discover and synchronize documents in the iCloud environment, and manage them to achieve high performance and a low memory footprint. These *documents* can be the digital assets or any user data.\n\nThe sample also demonstrates how to publish an iCloud container to iCloud Drive so that the user can access the container’s `Documents` folder from other apps. Additionally, it shows how to support the Open-in-Place feature, which allows the user to launch an app by tapping a document in Files, and then edit it directly.\n\n### Configure the sample code project\n\nBefore building the sample, perform the following steps in Xcode:\n\nBefore running the sample on a device, configure the device as follows:\n\n### Publish an iCloud container to iCloud Drive\n\nPublishing an iCloud container to iCloud Drive makes the container’s `Documents` folder appear in iCloud Drive so the user can access the folder from other apps. Follow these steps to publish a container:\n\nThe `NSUbiquitousContainers` entry of the sample is as follows:\n\n### Support Open-in-Place\n\nThe Open-in-Place feature allows the user to launch an app by tapping a document of the type the app owns. After opening it, the app can change the document directly without copying it to the app’s sandbox container. Follow these steps to implement the feature:\n\nApps need to wrap the code that accesses the passed-in URL with the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSURL\/startAccessingSecurityScopedResource()] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSURL\/stopAccessingSecurityScopedResource()] methods if the URL is outside of their sandbox. This sample doesn’t explicitly do that because it accesses the URL via [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument], which handles [https:\/\/developer.apple.com\/library\/archive\/documentation\/Security\/Conceptual\/AppSandboxDesignGuide\/AppSandboxInDepth\/AppSandboxInDepth.html#\/\/apple_ref\/doc\/uid\/TP40011183-CH3-SW16] automatically.\n\n### Discover documents in an iCloud container\n\niOS apps use [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSMetadataQuery] rather than file system APIs to discover documents in an iCloud container. When an app creates an iCloud document on one device, iCloud first synchronizes the document metadata to the other devices to tell them about the existence of the document. Then, depending on the device types, iCloud may or may not continue to synchronize the document data. For iOS devices, iCloud doesn’t synchronize the document data until an app asks (either explicitly or implicitly). When an iOS app receives a notification that a new document exists, the document data may not physically exist on the local file system, so it isn’t discoverable with file system APIs.\n\nTo watch the metadata changes in the iCloud container, the sample creates an `NSMetadataQuery` object. It uses the following code to configure and start the query to gather the changes of documents that are in the iCloud container and have an `.sicd` extension name.\n\nA query has two phases when gathering the metadata: the initial phase that collects all currently matching results, and a second phase that gathers live updates. It posts an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/NSMetadataQueryDidFinishGathering] notification when it finishes the first phase, and an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/NSMetadataQueryDidUpdate] notification each time an update occurs. To avoid potential conflicts with the system, disable the query update when accessing the results, and enable it after finishing the access, as the following example shows:\n\n### Manage a large data set\n\nDocuments in this sample could potentially contain many images, and the images might be large. To load image data only when necessary, and release the data immediately after using it, the `Document` class provides public methods for directly accessing the images in the document package. As an example, the following method retrieves a full image asynchronously:\n\nWhen directly manipulating the files in the document package, the sample calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument\/performAsynchronousFileAccess(_:)] method to serialize the file access in the background queue, and uses [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSFileCoordinator] to coordinate the reading or writing.\n\nLikewise, to avoid the default implementation that loads image data to [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileWrapper] objects and keeps it in memory, the sample overrides the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument\/save(to:for:completionHandler:)] method to directly remove or add image files when updating a document.\n\n### Resolve version conflicts\n\nIn the iCloud environment, the user can edit a document from different devices. Depending on networking conditions and the timing of synchronization, that may trigger version conflicts. Apps that provide support for iCloud documents need to resolve these conflicts, and remove the obsolete versions so they don’t consume the user’s iCloud storage.\n\nTo create a document conflict with the sample:\n\nHandling version conflicts in document-based apps is straightforward because `UIDocument` does most of the heavy lifting. When a conflict occurs, `UIDocument` detects it and posts a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument\/stateChangedNotification] notification, which apps can observe and then implement their conflict resolution strategy.\n\nThe sample resolves a conflict by selecting the version that has the most recent [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSFileVersion\/modificationDate] and removing all others. It uses file coordination to assess the version information of an iCloud document to avoid potential conflicts with the system.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/synchronizing-documents-in-the-icloud-environment\ncrawled: 2025-12-02T15:52:30Z\n---\n\n# Synchronizing documents in the iCloud environment\n\n**Sample Code**\n\nManage documents across multiple devices to create a seamless editing and collaboration experience.\n\n## Overview\n\nAs technology advances, more and more people generate their digital assets from different devices, and expect those assets to synchronize seamlessly. To support such use cases, apps need to discover the assets, as well as their changes, from all the devices, and present the user with a consistent view.\n\nThis sample demonstrates how to discover and synchronize documents in the iCloud environment, and manage them to achieve high performance and a low memory footprint. These *documents* can be the digital assets or any user data.\n\nThe sample also demonstrates how to publish an iCloud container to iCloud Drive so that the user can access the container’s `Documents` folder from other apps. Additionally, it shows how to support the Open-in-Place feature, which allows the user to launch an app by tapping a document in Files, and then edit it directly.\n\n### Configure the sample code project\n\nBefore building the sample, perform the following steps in Xcode:\n\n1. In the General pane of the `SimpleiCloudDocument` target, update the Bundle Identifier field with a new identifier.\n2. In the Signing & Capabilities pane, select the applicable team from the Team drop-down menu to let Xcode automatically manage the provisioning profile. See [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev23aab79b4] for details.\n3. Make sure the iCloud capability is present and the iCloud Documents box is in a selected state, then select the iCloud container with your bundle identifier from step 1 from the Containers list. If the container doesn’t exist, click the Add button (+), enter the container name (iCloud.<bundle identifier>), and click OK to let Xcode create the container and associate it with the app.\n4. If you prefer to use a different container, select it from the Containers list, specify the container identifier when creating the `MetadataProvider` instance in the `viewDidLoad` method of the `MainViewController` class. An iCloud container identifier is case-sensitive and must begin with “`iCloud.`”.\n5. Find the `NSUbiquitousContainers` entry in the `Info.plist` file, and change the iCloud container identifier there as well.\n\nBefore running the sample on a device, configure the device as follows:\n\n1. Log in with an Apple ID. For documents to synchronize across devices, the Apple ID must be the same on all devices.\n2. Choose Settings > Apple ID > iCloud, and turn on iCloud Drive, if it is off.\n3. Prepare some pictures in the Photo Library to use in the sample.\n\n### Publish an iCloud container to iCloud Drive\n\nPublishing an iCloud container to iCloud Drive makes the container’s `Documents` folder appear in iCloud Drive so the user can access the folder from other apps. Follow these steps to publish a container:\n\n1. Provide the container’s metadata by adding an `NSUbiquitousContainers` entry to the `Info.plist` file like the example code below demonstrates.\n2. Increase the bundle version by changing the Build field in the General pane of the Xcode target, or the  [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/CFBundleVersion] entry in the `Info.plist` file. The new value must be larger than the previous value when using the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSString\/compare(_:options:range:)] method with the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSString\/CompareOptions\/numeric] option to compare, and must only contain numeric (0 – 9) and period (.) characters. The system only updates an app’s iCloud container metadata when detecting a new version, so perform this step every time the metadata changes.\n3. Make sure the `Documents` folder exists in the iCloud container and has at least one document.\n\nThe `NSUbiquitousContainers` entry of the sample is as follows:\n\n```xml\n    <key>NSUbiquitousContainers<\/key>\n    <dict>\n        <key>iCloud.com.example.apple-samplecode.SimpleiCloudDocument<\/key>\n        <dict>\n            <key>NSUbiquitousContainerIsDocumentScopePublic<\/key>\n            <true\/>\n            <key>NSUbiquitousContainerName<\/key>\n            <string>SimpleiCloudDocument<\/string>\n            <key>NSUbiquitousContainerSupportedFolderLevels<\/key>\n            <string>ANY<\/string>\n        <\/dict>\n    <\/dict>\n```\n\n### Support Open-in-Place\n\nThe Open-in-Place feature allows the user to launch an app by tapping a document of the type the app owns. After opening it, the app can change the document directly without copying it to the app’s sandbox container. Follow these steps to implement the feature:\n\n1. Declare and export a document type for the app by adding the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/CFBundleDocumentTypes] and [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/UTExportedTypeDeclarations] `Info.plist` entries. Make sure the type conforms to at least `public.content` and `public.data` in the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/UTExportedTypeDeclarations\/UTTypeConformsTo] entry so that the other system components, like `UIActivityViewController`, recognize it.\n2. Add the `LSSupportsOpeningDocumentsInPlace` key to the `Info.plist` file, and set the value to `YES`.\n3. Implement the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UISceneDelegate\/scene(_:openURLContexts:)] method of the  `UISceneDelegate` protocol to accept the document.\n\nApps need to wrap the code that accesses the passed-in URL with the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSURL\/startAccessingSecurityScopedResource()] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSURL\/stopAccessingSecurityScopedResource()] methods if the URL is outside of their sandbox. This sample doesn’t explicitly do that because it accesses the URL via [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument], which handles [https:\/\/developer.apple.com\/library\/archive\/documentation\/Security\/Conceptual\/AppSandboxDesignGuide\/AppSandboxInDepth\/AppSandboxInDepth.html#\/\/apple_ref\/doc\/uid\/TP40011183-CH3-SW16] automatically.\n\n### Discover documents in an iCloud container\n\niOS apps use [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSMetadataQuery] rather than file system APIs to discover documents in an iCloud container. When an app creates an iCloud document on one device, iCloud first synchronizes the document metadata to the other devices to tell them about the existence of the document. Then, depending on the device types, iCloud may or may not continue to synchronize the document data. For iOS devices, iCloud doesn’t synchronize the document data until an app asks (either explicitly or implicitly). When an iOS app receives a notification that a new document exists, the document data may not physically exist on the local file system, so it isn’t discoverable with file system APIs.\n\nTo watch the metadata changes in the iCloud container, the sample creates an `NSMetadataQuery` object. It uses the following code to configure and start the query to gather the changes of documents that are in the iCloud container and have an `.sicd` extension name.\n\n```swift\nmetadataQuery.notificationBatchingInterval = 1\nmetadataQuery.searchScopes = [NSMetadataQueryUbiquitousDataScope, NSMetadataQueryUbiquitousDocumentsScope]\nmetadataQuery.predicate = NSPredicate(format: \"%K LIKE %@\", NSMetadataItemFSNameKey, \"*.\" + Document.extensionName)\nmetadataQuery.sortDescriptors = [NSSortDescriptor(key: NSMetadataItemFSNameKey, ascending: true)]\nmetadataQuery.start()\n```\n\nA query has two phases when gathering the metadata: the initial phase that collects all currently matching results, and a second phase that gathers live updates. It posts an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/NSMetadataQueryDidFinishGathering] notification when it finishes the first phase, and an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/NSMetadataQueryDidUpdate] notification each time an update occurs. To avoid potential conflicts with the system, disable the query update when accessing the results, and enable it after finishing the access, as the following example shows:\n\n```swift\nfunc metadataItemList() -> [MetadataItem] {\n    var result = [MetadataItem]()\n    metadataQuery.disableUpdates()\n    if let metadatItems = metadataQuery.results as? [NSMetadataItem] {\n        result = metadataItemList(from: metadatItems)\n    }\n    metadataQuery.enableUpdates()\n    return result\n}\n```\n\n### Manage a large data set\n\nDocuments in this sample could potentially contain many images, and the images might be large. To load image data only when necessary, and release the data immediately after using it, the `Document` class provides public methods for directly accessing the images in the document package. As an example, the following method retrieves a full image asynchronously:\n\n```swift\nfunc retrieveImageAsynchronously(with imageName: String, completionHandler: @escaping (UIImage?) -> Void) {\n    performAsynchronousFileAccess {\n        let imageFileURL = self.fileURL.appendingPathComponent(imageName)\n        let fileCoordinator = NSFileCoordinator(filePresenter: self)\n        fileCoordinator.coordinate(readingItemAt: imageFileURL, options: .withoutChanges, error: nil) { newURL in\n            if let imageData = try? Data(contentsOf: newURL), let image = UIImage(data: imageData) {\n                completionHandler(image)\n            } else {\n                completionHandler(nil)\n            }\n        }\n    }\n}\n```\n\nWhen directly manipulating the files in the document package, the sample calls the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument\/performAsynchronousFileAccess(_:)] method to serialize the file access in the background queue, and uses [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSFileCoordinator] to coordinate the reading or writing.\n\nLikewise, to avoid the default implementation that loads image data to [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileWrapper] objects and keeps it in memory, the sample overrides the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument\/save(to:for:completionHandler:)] method to directly remove or add image files when updating a document.\n\n```swift\noverride func save(to url: URL, for saveOperation: UIDocument.SaveOperation, completionHandler: ((Bool) -> Void)? = nil) {\n    if saveOperation != .forCreating {\n        print(\"\\(#function)\")\n        return performAsynchronousFileAccess {\n            let fileCoordinator = NSFileCoordinator(filePresenter: self)\n            fileCoordinator.coordinate(writingItemAt: self.fileURL, options: .forMerging, error: nil) { newURL in\n                let success = self.fulfillUnsavedChanges()\n                self.fileModificationDate = Date()\n                if let completionHandler = completionHandler {\n                    DispatchQueue.main.async {\n                        completionHandler(success)\n                    }\n                }\n            }\n        }\n    }\n    super.save(to: url, for: saveOperation, completionHandler: completionHandler)\n}\n```\n\n### Resolve version conflicts\n\nIn the iCloud environment, the user can edit a document from different devices. Depending on networking conditions and the timing of synchronization, that may trigger version conflicts. Apps that provide support for iCloud documents need to resolve these conflicts, and remove the obsolete versions so they don’t consume the user’s iCloud storage.\n\nTo create a document conflict with the sample:\n\n1. Run the sample on two iOS devices with Internet connections that use the same Apple ID to log in to iCloud.\n2. Create a document with several images on one device, and watch the document synchronize with the other device.\n3. Turn on Airplane mode on both devices to disconnect them from the Internet.\n4. Change the document on both devices by adding some images on one device, removing some images from the other device, and then saving the changes.\n5. Turn off Airplane mode on both devices at the same time to connect them back to the Internet.\n6. If no conflict occurs, repeat steps 3–5. After detecting a conflict, the sample enables the `Conflicts` item on the toolbar, and changes its color to red, so users can resolve the conflict.\n\nHandling version conflicts in document-based apps is straightforward because `UIDocument` does most of the heavy lifting. When a conflict occurs, `UIDocument` detects it and posts a [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIDocument\/stateChangedNotification] notification, which apps can observe and then implement their conflict resolution strategy.\n\nThe sample resolves a conflict by selecting the version that has the most recent [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSFileVersion\/modificationDate] and removing all others. It uses file coordination to assess the version information of an iCloud document to avoid potential conflicts with the system.\n\n```swift\nprivate func resolveConflictsAsynchronously(document: Document, completionHandler: ((Bool) -> Void)?) {\n    DispatchQueue.global().async {\n        NSFileCoordinator().coordinate(writingItemAt: document.fileURL,\n                                       options: .contentIndependentMetadataOnly, error: nil) { newURL in\n            let shouldRevert = self.pickLatestVersion(for: newURL)\n            completionHandler?(shouldRevert)\n        }\n    }\n}\n```\n\n## Documents\n\n- **UIDocument**: An abstract base class for managing discrete portions of your app’s data.\n- **UIManagedDocument**: A managed document object that integrates with Core Data.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An abstract base class for managing discrete portions of your app’s data.",
          "name" : "UIDocument",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIDocument"
        },
        {
          "description" : "A managed document object that integrates with Core Data.",
          "name" : "UIManagedDocument",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIManagedDocument"
        }
      ],
      "title" : "Documents"
    }
  ],
  "source" : "appleJSON",
  "title" : "Synchronizing documents in the iCloud environment",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/synchronizing-documents-in-the-icloud-environment"
}