{
  "abstract" : "Provide continuity for the user by preserving current activities.",
  "codeExamples" : [
    {
      "code" : "func stateRestorationActivity(for scene: UIScene) -> NSUserActivity? {\n    return scene.userActivity\n}",
      "language" : "swift"
    },
    {
      "code" : "func application(_ application: UIApplication, shouldSaveSecureApplicationState coder: NSCoder) -> Bool {\n    return true\n}",
      "language" : "swift"
    },
    {
      "code" : "func application(_ application: UIApplication, shouldRestoreSecureApplicationState coder: NSCoder) -> Bool {\n    return true\n}",
      "language" : "swift"
    },
    {
      "code" : "override func encodeRestorableState(with coder: NSCoder) {\n    super.encodeRestorableState(with: coder)\n\n    coder.encode(product?.identifier.uuidString, forKey: InfoViewController.restoreProductKey)\n}",
      "language" : "swift"
    },
    {
      "code" : "override func decodeRestorableState(with coder: NSCoder) {\n    super.decodeRestorableState(with: coder)\n    \n    guard let decodedProductIdentifier =\n        coder.decodeObject(forKey: InfoViewController.restoreProductKey) as? String else {\n        fatalError(\"A product did not exist in the restore. In your app, handle this gracefully.\")\n    }\n    product = DataModelManager.sharedInstance.product(fromIdentifier: decodedProductIdentifier)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "f44d6c4c8ef6bfa8798bcce7012cff048339ae3edbc29e395aa2ba1cc4b69fe2",
  "crawledAt" : "2025-12-05T06:45:37Z",
  "id" : "08AD4F26-15DF-46B1-87C3-F4E93BF82F63",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nThis sample project demonstrates how to preserve your app’s state information and restore the app to that previous state on subsequent launches. During a subsequent launch, restoring your interface to the previous interaction point provides continuity for the user, and lets them finish active tasks quickly.\n\nWhen using your app, the user performs actions that affect the user interface. For example, the user might view a specific page of information, and after the user leaves the app, the operating system might terminate it to free up the resources it holds. The user should be able to return to where they left off — and UI state restoration is a core part of making that experience seamless.\n\nThis sample app demonstrates the use of state preservation and restoration for scenarios where the system interrupts the app. The sample project manages a set of products. Each product has a title, an image, and other metadata you can view and edit. The project shows how to preserve and restore a product in its `DetailParentViewController`.\n\nThe sample supports two state preservation approaches. In iOS 13 and later, apps save the state for each window scene using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] objects. In iOS 12 and earlier, apps preserve the state of their user interfaces by saving and restoring the configuration of view controllers.\n\nFor scene-based apps, UIKit asks each scene to save its state information using an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] object. `NSUserActivity` is a core part of modern state restoration with [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIScene] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UISceneDelegate]. In your own apps, you use the activity object to store information needed to recreate your scene’s interface and restore the content of that interface. If your app doesn’t support scenes, use the view-controller-based state restoration process to preserve the state of your interface instead.\n\nFor additional information about state restoration, see  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/preserving-your-app-s-ui-across-launches].\n\n### Configure the sample code project\n\nIn Xcode, select your development team on the iOS target’s General tab.\n\n### Enable state preservation and restoration\n\nTo provide the necessary activity object, the sample implements the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UISceneDelegate\/stateRestorationActivity(for:)] method of its scene delegate as shown in the example below. Implementing this method tells the system that the sample supports user-activity-based state restoration. The implementation of this method returns the activity object from the scene’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/userActivity] property, which the sample populates when the scene becomes inactive.\n\nFor view-controller-based state restoration, this sample opts in to state preservation and restoration using the app delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldSaveApplicationState:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldRestoreApplicationState:)] methods. Both methods return a `Bool` value that indicates whether the step should occur. This sample returns `true` for both functions.\n\nThis example enables the preservation of state for the app:\n\nThis example enables the restoration of state for the app:\n\n### Restore the app state with an activity object\n\nScene-based state restoration is the recommended way to restore the app’s user interface. An [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] object captures the app’s state at the current moment in time. For this sample, the app preserves and restores the product information as the user displays or edits it. The sample app saves the product’s data in an `NSUserActivity` object when the user closes the app or the app enters the background. When the user launches the app again, the sample’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UISceneDelegate\/scene(_:willConnectTo:options:)] method checks for the presence of an activity object. If one is present, the method configures the detail view controller that the activity object specifies.\n\n### Restore the app state using view controllers\n\nThis sample preserves its state by saving the state of its view controller hierarchy. View controllers adopt the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIStateRestoring] protocol, which defines methods for saving custom state information to an archive and restoring that information later.\n\nThe sample specifies which of its view controllers to save, and assigns a restoration identifier to that view controller. A restoration identifier is a string that UIKit uses to identify a view controller or other user interface element. The identifier for each view controller must be unique. The sample assigns the identifiers in Interface Builder, but this can also occur in code.\n\nThe sample assigns a restoration ID for each view controller in the storyboard file. This information is available by selecting the view controller and looking at the Identity Inspector. The Storyboard ID for that view controller is usually the same as the Restoration ID.\n\nThis sample saves the state information in the detail view controller’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder\/encodeRestorableState(with:)] method, and it restores that state in the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder\/restoreState(with:)] method. Because it already encapsulates the view controller’s state in an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] object, the implementations of these methods operate on the existing activity object. The sample then calls the required superclass methods from these methods, which allows UIKit to restore the rest of the view controller’s inherited state.\n\nThis example enables the state preservation of `InfoViewController`:\n\nThis example enables the state restoration of  `InfoViewController`:\n\n### Test state restoration on a device\n\nThis sample restores the following user interface:\n\nWhen debugging the sample project, the system automatically deletes its preserved state when the user force quits the app. Deleting the preserved state information is a safety precaution. In addition, the system deletes the preserved state if the app crashes at launch time. To test the sample app’s ability to restore the sample’s state, do not use the app switcher to force quit it during debugging. Instead, use Xcode to stop the app, or stop the app programmatically. One technique is to suspend the sample app using the Home button, and then stop the debugger in Xcode. Launch the sample app again using Xcode, and UIKit initiates the state restoration process.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/uikit\/restoring-your-app-s-state\ncrawled: 2025-12-05T06:45:37Z\n---\n\n# Restoring your app’s state\n\n**Sample Code**\n\nProvide continuity for the user by preserving current activities.\n\n## Overview\n\nThis sample project demonstrates how to preserve your app’s state information and restore the app to that previous state on subsequent launches. During a subsequent launch, restoring your interface to the previous interaction point provides continuity for the user, and lets them finish active tasks quickly.\n\nWhen using your app, the user performs actions that affect the user interface. For example, the user might view a specific page of information, and after the user leaves the app, the operating system might terminate it to free up the resources it holds. The user should be able to return to where they left off — and UI state restoration is a core part of making that experience seamless.\n\nThis sample app demonstrates the use of state preservation and restoration for scenarios where the system interrupts the app. The sample project manages a set of products. Each product has a title, an image, and other metadata you can view and edit. The project shows how to preserve and restore a product in its `DetailParentViewController`.\n\nThe sample supports two state preservation approaches. In iOS 13 and later, apps save the state for each window scene using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] objects. In iOS 12 and earlier, apps preserve the state of their user interfaces by saving and restoring the configuration of view controllers.\n\nFor scene-based apps, UIKit asks each scene to save its state information using an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] object. `NSUserActivity` is a core part of modern state restoration with [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIScene] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UISceneDelegate]. In your own apps, you use the activity object to store information needed to recreate your scene’s interface and restore the content of that interface. If your app doesn’t support scenes, use the view-controller-based state restoration process to preserve the state of your interface instead.\n\nFor additional information about state restoration, see  [doc:\/\/com.apple.uikit\/documentation\/UIKit\/preserving-your-app-s-ui-across-launches].\n\n### Configure the sample code project\n\nIn Xcode, select your development team on the iOS target’s General tab.\n\n### Enable state preservation and restoration\n\nTo provide the necessary activity object, the sample implements the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UISceneDelegate\/stateRestorationActivity(for:)] method of its scene delegate as shown in the example below. Implementing this method tells the system that the sample supports user-activity-based state restoration. The implementation of this method returns the activity object from the scene’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/userActivity] property, which the sample populates when the scene becomes inactive.\n\n```swift\nfunc stateRestorationActivity(for scene: UIScene) -> NSUserActivity? {\n    return scene.userActivity\n}\n```\n\nFor view-controller-based state restoration, this sample opts in to state preservation and restoration using the app delegate’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldSaveApplicationState:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIApplicationDelegate\/application(_:shouldRestoreApplicationState:)] methods. Both methods return a `Bool` value that indicates whether the step should occur. This sample returns `true` for both functions.\n\nThis example enables the preservation of state for the app:\n\n```swift\nfunc application(_ application: UIApplication, shouldSaveSecureApplicationState coder: NSCoder) -> Bool {\n    return true\n}\n```\n\nThis example enables the restoration of state for the app:\n\n```swift\nfunc application(_ application: UIApplication, shouldRestoreSecureApplicationState coder: NSCoder) -> Bool {\n    return true\n}\n```\n\n### Restore the app state with an activity object\n\nScene-based state restoration is the recommended way to restore the app’s user interface. An [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] object captures the app’s state at the current moment in time. For this sample, the app preserves and restores the product information as the user displays or edits it. The sample app saves the product’s data in an `NSUserActivity` object when the user closes the app or the app enters the background. When the user launches the app again, the sample’s [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UISceneDelegate\/scene(_:willConnectTo:options:)] method checks for the presence of an activity object. If one is present, the method configures the detail view controller that the activity object specifies.\n\n### Restore the app state using view controllers\n\nThis sample preserves its state by saving the state of its view controller hierarchy. View controllers adopt the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIStateRestoring] protocol, which defines methods for saving custom state information to an archive and restoring that information later.\n\nThe sample specifies which of its view controllers to save, and assigns a restoration identifier to that view controller. A restoration identifier is a string that UIKit uses to identify a view controller or other user interface element. The identifier for each view controller must be unique. The sample assigns the identifiers in Interface Builder, but this can also occur in code.\n\nThe sample assigns a restoration ID for each view controller in the storyboard file. This information is available by selecting the view controller and looking at the Identity Inspector. The Storyboard ID for that view controller is usually the same as the Restoration ID.\n\nThis sample saves the state information in the detail view controller’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder\/encodeRestorableState(with:)] method, and it restores that state in the [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder\/restoreState(with:)] method. Because it already encapsulates the view controller’s state in an [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSUserActivity] object, the implementations of these methods operate on the existing activity object. The sample then calls the required superclass methods from these methods, which allows UIKit to restore the rest of the view controller’s inherited state.\n\nThis example enables the state preservation of `InfoViewController`:\n\n```swift\noverride func encodeRestorableState(with coder: NSCoder) {\n    super.encodeRestorableState(with: coder)\n\n    coder.encode(product?.identifier.uuidString, forKey: InfoViewController.restoreProductKey)\n}\n```\n\nThis example enables the state restoration of  `InfoViewController`:\n\n```swift\noverride func decodeRestorableState(with coder: NSCoder) {\n    super.decodeRestorableState(with: coder)\n    \n    guard let decodedProductIdentifier =\n        coder.decodeObject(forKey: InfoViewController.restoreProductKey) as? String else {\n        fatalError(\"A product did not exist in the restore. In your app, handle this gracefully.\")\n    }\n    product = DataModelManager.sharedInstance.product(fromIdentifier: decodedProductIdentifier)\n}\n```\n\n### Test state restoration on a device\n\nThis sample restores the following user interface:\n\n- Detail View Controller — Tap a product in the collection view to open its detail information. The app restores the selected product and selected tab.\n- Detail View Controller’s Edit State — In the detail view, tap Edit. The app restores the edit view and its content.\n- Secondary Window — (iPad only) Drag a product from the collection view over to the left or right of the device screen to create a second scene window. The app restores that scene and its product. Another way to create the secondary window is to tap and hold a product from the collection view through its contextual menu and select Open New Window.\n\nWhen debugging the sample project, the system automatically deletes its preserved state when the user force quits the app. Deleting the preserved state information is a safety precaution. In addition, the system deletes the preserved state if the app crashes at launch time. To test the sample app’s ability to restore the sample’s state, do not use the app switcher to force quit it during debugging. Instead, use Xcode to stop the app, or stop the app programmatically. One technique is to suspend the sample app using the Home button, and then stop the debugger in Xcode. Launch the sample app again using Xcode, and UIKit initiates the state restoration process.\n\n## Interface restoration\n\n- **Restoring your app’s state with SwiftUI**: Provide app continuity for users by preserving their current activities.\n- **Preserving your app’s UI across launches**: Return your app to its previous state after the system terminates it.\n- **UIViewControllerRestoration**: The methods that objects adopt so that they can act as a restoration class for view controllers during state restoration.\n- **UIObjectRestoration**: The interface that restoration classes use to restore preserved objects.\n- **UIStateRestoring**: Methods for adding objects to your state restoration archives.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Provide app continuity for users by preserving their current activities.",
          "name" : "Restoring your app’s state with SwiftUI",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/restoring-your-app-s-state-with-swiftui"
        },
        {
          "description" : "Return your app to its previous state after the system terminates it.",
          "name" : "Preserving your app’s UI across launches",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/preserving-your-app-s-ui-across-launches"
        },
        {
          "description" : "The methods that objects adopt so that they can act as a restoration class for view controllers during state restoration.",
          "name" : "UIViewControllerRestoration",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIViewControllerRestoration"
        },
        {
          "description" : "The interface that restoration classes use to restore preserved objects.",
          "name" : "UIObjectRestoration",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIObjectRestoration"
        },
        {
          "description" : "Methods for adding objects to your state restoration archives.",
          "name" : "UIStateRestoring",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/UIStateRestoring"
        }
      ],
      "title" : "Interface restoration"
    }
  ],
  "source" : "appleJSON",
  "title" : "Restoring your app’s state",
  "url" : "https:\/\/developer.apple.com\/documentation\/uikit\/restoring-your-app-s-state"
}