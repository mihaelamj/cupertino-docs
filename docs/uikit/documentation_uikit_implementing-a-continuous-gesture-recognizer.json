{
  "abstract" : "For gestures that do not easily match a specific pattern, or when you want to use a gesture recognizer to gather touch input, create a continuous gesture recognizer.",
  "codeExamples" : [
    {
      "code" : "struct StrokeSample {\n    let location: CGPoint \n \n    init(location: CGPoint) {\n        self.location = location\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class TouchCaptureGesture: UIGestureRecognizer, NSCoding {\n   var trackedTouch: UITouch? = nil\n   var samples = [StrokeSample]() \n \n   required init?(coder aDecoder: NSCoder) {\n      super.init(target: nil, action: nil) \n \n      self.samples = [StrokeSample]()\n   } \n   func encode(with aCoder: NSCoder) { }   \n   \/\/ Overridden methods to come...\n}",
      "language" : "swift"
    },
    {
      "code" : "override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {\n   if touches.count != 1 {\n      self.state = .failed\n   } \n \n   \/\/ Capture the first touch and store some information about it.\n   if self.trackedTouch == nil {\n      if let firstTouch = touches.first {\n         self.trackedTouch = firstTouch\n         self.addSample(for: firstTouch)\n         state = .began\n      }\n   } else {\n      \/\/ Ignore all but the first touch.\n      for touch in touches {\n         if touch != self.trackedTouch {\n            self.ignore(touch, for: event)\n         }\n      }\n   }\n}\n \nfunc addSample(for touch: UITouch) {\n   let newSample = StrokeSample(location: touch.location(in: self.view))\n   self.samples.append(newSample)\n}",
      "language" : "swift"
    },
    {
      "code" : "override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {\n   self.addSample(for: touches.first!)\n   state = .changed\n}\n \noverride func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {\n   self.addSample(for: touches.first!)\n   state = .ended\n}",
      "language" : "swift"
    },
    {
      "code" : "override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {\n   self.samples.removeAll()\n   state = .cancelled\n} \n \noverride func reset() {\n   self.samples.removeAll()\n   self.trackedTouch = nil\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "68fc20d99d92c415e9bf7ad690db9c2c2d9b18afe6fb29002f5e8ef9764142d6",
  "crawledAt" : "2025-12-02T04:43:07Z",
  "id" : "047CA785-F111-4E4C-B13E-0262FCBE3818",
  "kind" : "article",
  "module" : "UIKit",
  "overview" : "## Overview\n\nA continuous gesture recognizer lets you encapsulate your event-handling logic in one place and reuse that logic in multiple views. Although continuous gesture recognizers require a little more effort to implement the state machine, they also perform tasks that would be difficult with a discrete gesture recognizer, such as capturing free-form input.\n\nThe following image shows a free-form gesture whose input you might use to draw paths onscreen. Although you could use a pan gesture recognizer to capture the input, your action method would need to handle all of the phases of the capture process, which would add to its complexity. Using a custom gesture recognizer, you can simplify your code by distributing your logic to various methods of your subclass. Using a custom gesture recognizer also means that you can write your code for capturing the path once and reuse it in multiple views.\n\n\n\nFor a custom gesture recognizer that captures touch input, there are no explicit conditions that trigger a failure of the gesture. Instead, the gesture recognizer captures touch input until the touch sequence ends or is cancelled by the system. While the gesture is ongoing, the gesture recognizer places the touch data into a temporary buffer. Clients of the gesture recognizer use their action method to fetch that buffer and apply it temporarily to the app’s content. For example, a client might use that data to draw the path onscreen. Only when the touch sequence ends successfully would those target objects commit the data permanently to the app’s data structures.\n\n### Saving Gesture-Related Data\n\nA continuous gesture recognizer that tracks touch events needs a way to store that information. You cannot simply store references to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] objects that you receive because UIKit reuses those objects and overwrites any old values. Instead, you must define custom data structures to store the touch information you need.\n\nThe following code shows the definition of a `StrokeSample` struct, whose purpose is to store the location associated with a touch. In your own implementation, you might add other properties to this struct to store information such as the timestamp or the force of the touch.\n\nThe following code shows the partial definition of a `TouchCaptureGesture` class used to capture touch information. This class stores touch data in the `samples` property, which is an array of `StrokeSample` structs. The class also stores the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] object associated with the first finger so that it can ignore any other touches. The implementation of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSCoding\/init(coder:)] method ensures that the `samples` property is initialized properly when loading the gesture recognizer from an Interface Builder file.\n\n### Processing Touch Events\n\nThe following code shows the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesBegan(_:with:)] method of the `TouchCaptureGesture` class. The gesture fails immediately if the initial event contains two touches. If there is only one touch, the touch object is saved in the `trackedTouch` property and the custom `addSample` helper method creates a new `StrokeSample` struct with the touch data. After the first touch occurs, any new touches added to the event sequence are ignored.\n\nThe [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesMoved(_:with:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesEnded(_:with:)] methods (shown in the following code) record each new sample and update the gesture recognizer’s state. Setting the state to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/ended] is equivalent to setting the state to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/recognized] and results in a call to the gesture recognizer’s action method.\n\n### Resetting the Gesture Recognizer\n\nAlways implement the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesCancelled(_:with:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/reset()] methods in your gesture recognizers and use them to perform any cleanup. The following code shows the implementation of these methods for the `TouchCaptureGesture` class. Both methods restore the gesture recognizer’s properties to their initial values.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/implementing-a-continuous-gesture-recognizer\ncrawled: 2025-12-02T04:43:07Z\n---\n\n# Implementing a Continuous Gesture Recognizer\n\n**Article**\n\nFor gestures that do not easily match a specific pattern, or when you want to use a gesture recognizer to gather touch input, create a continuous gesture recognizer.\n\n## Overview\n\nA continuous gesture recognizer lets you encapsulate your event-handling logic in one place and reuse that logic in multiple views. Although continuous gesture recognizers require a little more effort to implement the state machine, they also perform tasks that would be difficult with a discrete gesture recognizer, such as capturing free-form input.\n\nThe following image shows a free-form gesture whose input you might use to draw paths onscreen. Although you could use a pan gesture recognizer to capture the input, your action method would need to handle all of the phases of the capture process, which would add to its complexity. Using a custom gesture recognizer, you can simplify your code by distributing your logic to various methods of your subclass. Using a custom gesture recognizer also means that you can write your code for capturing the path once and reuse it in multiple views.\n\n\n\nFor a custom gesture recognizer that captures touch input, there are no explicit conditions that trigger a failure of the gesture. Instead, the gesture recognizer captures touch input until the touch sequence ends or is cancelled by the system. While the gesture is ongoing, the gesture recognizer places the touch data into a temporary buffer. Clients of the gesture recognizer use their action method to fetch that buffer and apply it temporarily to the app’s content. For example, a client might use that data to draw the path onscreen. Only when the touch sequence ends successfully would those target objects commit the data permanently to the app’s data structures.\n\n### Saving Gesture-Related Data\n\nA continuous gesture recognizer that tracks touch events needs a way to store that information. You cannot simply store references to the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] objects that you receive because UIKit reuses those objects and overwrites any old values. Instead, you must define custom data structures to store the touch information you need.\n\nThe following code shows the definition of a `StrokeSample` struct, whose purpose is to store the location associated with a touch. In your own implementation, you might add other properties to this struct to store information such as the timestamp or the force of the touch.\n\n```swift\nstruct StrokeSample {\n    let location: CGPoint \n \n    init(location: CGPoint) {\n        self.location = location\n    }\n}\n```\n\nThe following code shows the partial definition of a `TouchCaptureGesture` class used to capture touch information. This class stores touch data in the `samples` property, which is an array of `StrokeSample` structs. The class also stores the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UITouch] object associated with the first finger so that it can ignore any other touches. The implementation of the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSCoding\/init(coder:)] method ensures that the `samples` property is initialized properly when loading the gesture recognizer from an Interface Builder file.\n\n```swift\nclass TouchCaptureGesture: UIGestureRecognizer, NSCoding {\n   var trackedTouch: UITouch? = nil\n   var samples = [StrokeSample]() \n \n   required init?(coder aDecoder: NSCoder) {\n      super.init(target: nil, action: nil) \n \n      self.samples = [StrokeSample]()\n   } \n   func encode(with aCoder: NSCoder) { }   \n   \/\/ Overridden methods to come...\n}\n```\n\n### Processing Touch Events\n\nThe following code shows the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesBegan(_:with:)] method of the `TouchCaptureGesture` class. The gesture fails immediately if the initial event contains two touches. If there is only one touch, the touch object is saved in the `trackedTouch` property and the custom `addSample` helper method creates a new `StrokeSample` struct with the touch data. After the first touch occurs, any new touches added to the event sequence are ignored.\n\n```swift\noverride func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {\n   if touches.count != 1 {\n      self.state = .failed\n   } \n \n   \/\/ Capture the first touch and store some information about it.\n   if self.trackedTouch == nil {\n      if let firstTouch = touches.first {\n         self.trackedTouch = firstTouch\n         self.addSample(for: firstTouch)\n         state = .began\n      }\n   } else {\n      \/\/ Ignore all but the first touch.\n      for touch in touches {\n         if touch != self.trackedTouch {\n            self.ignore(touch, for: event)\n         }\n      }\n   }\n}\n \nfunc addSample(for touch: UITouch) {\n   let newSample = StrokeSample(location: touch.location(in: self.view))\n   self.samples.append(newSample)\n}\n```\n\nThe [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesMoved(_:with:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesEnded(_:with:)] methods (shown in the following code) record each new sample and update the gesture recognizer’s state. Setting the state to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/ended] is equivalent to setting the state to [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/State-swift.enum\/recognized] and results in a call to the gesture recognizer’s action method.\n\n```swift\noverride func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {\n   self.addSample(for: touches.first!)\n   state = .changed\n}\n \noverride func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {\n   self.addSample(for: touches.first!)\n   state = .ended\n}\n```\n\n### Resetting the Gesture Recognizer\n\nAlways implement the [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIResponder\/touchesCancelled(_:with:)] and [doc:\/\/com.apple.uikit\/documentation\/UIKit\/UIGestureRecognizer\/reset()] methods in your gesture recognizers and use them to perform any cleanup. The following code shows the implementation of these methods for the `TouchCaptureGesture` class. Both methods restore the gesture recognizer’s properties to their initial values.\n\n```swift\noverride func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {\n   self.samples.removeAll()\n   state = .cancelled\n} \n \noverride func reset() {\n   self.samples.removeAll()\n   self.trackedTouch = nil\n}\n```\n\n## Creating Custom Gesture Recognizers\n\n- **About the Gesture Recognizer State Machine**: Learn about the states and transitions of the state machine that underlies gesture recognizers.\n- **Implementing a discrete gesture recognizer**: If your gesture involves a specific pattern of events, consider implementing a discrete gesture recognizer for it.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn about the states and transitions of the state machine that underlies gesture recognizers.",
          "name" : "About the Gesture Recognizer State Machine",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/about-the-gesture-recognizer-state-machine"
        },
        {
          "description" : "If your gesture involves a specific pattern of events, consider implementing a discrete gesture recognizer for it.",
          "name" : "Implementing a discrete gesture recognizer",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/implementing-a-discrete-gesture-recognizer"
        }
      ],
      "title" : "Creating Custom Gesture Recognizers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing a Continuous Gesture Recognizer",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/implementing-a-continuous-gesture-recognizer"
}