{
  "abstract" : "Learn how to create a simple app that incorporates predicted touches into its drawing code.",
  "codeExamples" : [
    {
      "code" : "\/\/ Collect predicted touches only while the gesture is ongoing. \nif (usesPredictedSamples && stroke.state == .active) {\n   if let predictedTouches = event?.predictedTouches(for: touchToAppend) {\n      for touch in predictedTouches {\n         collector(stroke, touch, view, false, true)\n      }\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "class Stroke {\n    static let calligraphyFallbackAzimuthUnitVector = CGVector(dx: 1.0, dy:1.0).normalize! \n    var samples: [StrokeSample] = []\n    var predictedSamples: [StrokeSample] = []\n    var previousPredictedSamples: [StrokeSample]?\n    var state: StrokeState = .active\n    var sampleIndicesExpectingUpdates = Set<Int>()\n    var expectsAltitudeAzimuthBackfill = false\n    var hasUpdatesFromStartTo: Int?\n    var hasUpdatesAtEndFrom: Int? \n    var receivedAllNeededUpdatesBlock: (() -> ())?\n \n    func add(sample: StrokeSample) -> Int {\n        let resultIndex = samples.count\n        if hasUpdatesAtEndFrom == nil {\n            hasUpdatesAtEndFrom = resultIndex\n        }\n \n        samples.append(sample)\n        if previousPredictedSamples == nil {\n            previousPredictedSamples = predictedSamples\n        }\n \n        if sample.estimatedPropertiesExpectingUpdates != [] {\n            sampleIndicesExpectingUpdates.insert(resultIndex)\n        }\n \n        predictedSamples.removeAll()\n        return resultIndex\n    } \n \n    func addPredicted(sample: StrokeSample) {\n        predictedSamples.append(sample)\n    } \n \n    func clearUpdateInfo() {\n        hasUpdatesFromStartTo = nil\n        hasUpdatesAtEndFrom = nil\n        previousPredictedSamples = nil\n    } \n \n    \/\/ Other methods...\n}",
      "language" : "swift"
    },
    {
      "code" : "class StrokeSegmentIterator: IteratorProtocol {\n    private let stroke: Stroke\n    private var nextIndex: Int\n    private let sampleCount: Int\n    private let predictedSampleCount: Int\n    private var segment: StrokeSegment!\n \n    init(stroke: Stroke) {\n        self.stroke = stroke\n        nextIndex = 1\n        sampleCount = stroke.samples.count\n        predictedSampleCount = stroke.predictedSamples.count\n        if (predictedSampleCount + sampleCount > 1) {\n            segment = StrokeSegment(sample: sampleAt(0)!)\n            segment.advanceWithSample(incomingSample: sampleAt(1))\n        }\n    } \n \n    func sampleAt(_ index: Int) -> StrokeSample? {\n        if (index < sampleCount) {\n            return stroke.samples[index]\n        }\n        let predictedIndex = index - sampleCount\n        if predictedIndex < predictedSampleCount {\n            return stroke.predictedSamples[predictedIndex]\n        } else {\n            return nil\n        }\n    }\n \n    func next() -> StrokeSegment? {\n        nextIndex += 1\n        if let segment = self.segment {\n            if segment.advanceWithSample(incomingSample: sampleAt(nextIndex)) {\n                return segment\n            }\n        }\n        return nil\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "880806f1c89ebc1cc31a120f7cbadd830e9be6eb5b49dae9e31dbb5e67cc211b",
  "crawledAt" : "2025-12-03T18:16:11Z",
  "id" : "5E769A19-7712-4FA3-AFE1-97A308EE4382",
  "kind" : "article",
  "language" : "swift",
  "module" : "UIKit",
  "overview" : "## Overview\n\nThe sample app Speed Sketch (see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/leveraging-touch-input-for-drawing-apps]) uses predicted touches to minimize latency when drawing using either Apple Pencil or a finger. The key class for gathering touches is the `StrokeGestureRecognizer` class. Each new sequence of touch events results in the creation of a `Stroke` object to the app’s drawing canvas. Stroke objects store the touch data needed to do stylized line drawing and can render that data using a calligraphy pen or a regular pen, or in a special debug mode that draws line segments for each distinct touch event.\n\n\n\n### Collect the touch input\n\nThe `StrokeGestureRecognizer` class collects drawing-related touch input and uses it to create a `Stroke` object representing the path to render. In addition to the touches that actually occurred, the class also gathers any predicted touches. The following code shows the portion of the gesture recognizer’s `append` method that’s responsible for gathering the predicted touches. The `collector` block called by this code processes each touch event. The parameters to that block indicate whether the touch is an actual touch or a predicted touch.\n\nThe collection of touch input results in the creation of `StrokeSample` objects, which are then added to the current `Stroke` object. Stroke objects store predicted touches separately from other touches. Keeping them separate makes it easier to remove them later, and keeps them from being accidentally confused with the real touch input. Each time the app adds a new set of actual touches, it discards the preceding set of predicted samples.\n\nThe following code shows a portion of the `Stroke` class, which represents the touches associated with a single drawn line. For each new set of touches, the class adds the actual touches to its primary list of samples. Any predicted touches are then stored in the `predictedSamples` property. Each time `StrokeGestureRecognizer` calls the `Stroke` method `add`, the method moves the last set of predicted touches to the `previousPredictedSamples` property and are ultimately discarded. Thus, `Stroke` maintains only the last set of predicted touches.\n\n### Render the predicted touches\n\nDuring rendering, the app treats predicted touches like actual touches. It breaks down the contents of each `Stroke` object into one or more `StrokeSegment` objects, which the drawing code fetches using a `StrokeSegmentIterator` object. The following code shows the implementation of this class. As the drawing code iterates over the stroke samples, the `sampleAt` method returns the samples for the actual touches first. Only after the method returns all of the actual touch samples does the iterator return the samples for any predicted touches. Thus, the predicted touches are always located at the end of the stroked line.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/UIKit\/incorporating-predicted-touches-into-an-app\ncrawled: 2025-12-03T18:16:11Z\n---\n\n# Incorporating predicted touches into an app\n\n**Article**\n\nLearn how to create a simple app that incorporates predicted touches into its drawing code.\n\n## Overview\n\nThe sample app Speed Sketch (see [doc:\/\/com.apple.uikit\/documentation\/UIKit\/leveraging-touch-input-for-drawing-apps]) uses predicted touches to minimize latency when drawing using either Apple Pencil or a finger. The key class for gathering touches is the `StrokeGestureRecognizer` class. Each new sequence of touch events results in the creation of a `Stroke` object to the app’s drawing canvas. Stroke objects store the touch data needed to do stylized line drawing and can render that data using a calligraphy pen or a regular pen, or in a special debug mode that draws line segments for each distinct touch event.\n\n\n\n### Collect the touch input\n\nThe `StrokeGestureRecognizer` class collects drawing-related touch input and uses it to create a `Stroke` object representing the path to render. In addition to the touches that actually occurred, the class also gathers any predicted touches. The following code shows the portion of the gesture recognizer’s `append` method that’s responsible for gathering the predicted touches. The `collector` block called by this code processes each touch event. The parameters to that block indicate whether the touch is an actual touch or a predicted touch.\n\n```swift\n\/\/ Collect predicted touches only while the gesture is ongoing. \nif (usesPredictedSamples && stroke.state == .active) {\n   if let predictedTouches = event?.predictedTouches(for: touchToAppend) {\n      for touch in predictedTouches {\n         collector(stroke, touch, view, false, true)\n      }\n   }\n}\n```\n\nThe collection of touch input results in the creation of `StrokeSample` objects, which are then added to the current `Stroke` object. Stroke objects store predicted touches separately from other touches. Keeping them separate makes it easier to remove them later, and keeps them from being accidentally confused with the real touch input. Each time the app adds a new set of actual touches, it discards the preceding set of predicted samples.\n\nThe following code shows a portion of the `Stroke` class, which represents the touches associated with a single drawn line. For each new set of touches, the class adds the actual touches to its primary list of samples. Any predicted touches are then stored in the `predictedSamples` property. Each time `StrokeGestureRecognizer` calls the `Stroke` method `add`, the method moves the last set of predicted touches to the `previousPredictedSamples` property and are ultimately discarded. Thus, `Stroke` maintains only the last set of predicted touches.\n\n```swift\nclass Stroke {\n    static let calligraphyFallbackAzimuthUnitVector = CGVector(dx: 1.0, dy:1.0).normalize! \n    var samples: [StrokeSample] = []\n    var predictedSamples: [StrokeSample] = []\n    var previousPredictedSamples: [StrokeSample]?\n    var state: StrokeState = .active\n    var sampleIndicesExpectingUpdates = Set<Int>()\n    var expectsAltitudeAzimuthBackfill = false\n    var hasUpdatesFromStartTo: Int?\n    var hasUpdatesAtEndFrom: Int? \n    var receivedAllNeededUpdatesBlock: (() -> ())?\n \n    func add(sample: StrokeSample) -> Int {\n        let resultIndex = samples.count\n        if hasUpdatesAtEndFrom == nil {\n            hasUpdatesAtEndFrom = resultIndex\n        }\n \n        samples.append(sample)\n        if previousPredictedSamples == nil {\n            previousPredictedSamples = predictedSamples\n        }\n \n        if sample.estimatedPropertiesExpectingUpdates != [] {\n            sampleIndicesExpectingUpdates.insert(resultIndex)\n        }\n \n        predictedSamples.removeAll()\n        return resultIndex\n    } \n \n    func addPredicted(sample: StrokeSample) {\n        predictedSamples.append(sample)\n    } \n \n    func clearUpdateInfo() {\n        hasUpdatesFromStartTo = nil\n        hasUpdatesAtEndFrom = nil\n        previousPredictedSamples = nil\n    } \n \n    \/\/ Other methods...\n}\n```\n\n### Render the predicted touches\n\nDuring rendering, the app treats predicted touches like actual touches. It breaks down the contents of each `Stroke` object into one or more `StrokeSegment` objects, which the drawing code fetches using a `StrokeSegmentIterator` object. The following code shows the implementation of this class. As the drawing code iterates over the stroke samples, the `sampleAt` method returns the samples for the actual touches first. Only after the method returns all of the actual touch samples does the iterator return the samples for any predicted touches. Thus, the predicted touches are always located at the end of the stroked line.\n\n```swift\nclass StrokeSegmentIterator: IteratorProtocol {\n    private let stroke: Stroke\n    private var nextIndex: Int\n    private let sampleCount: Int\n    private let predictedSampleCount: Int\n    private var segment: StrokeSegment!\n \n    init(stroke: Stroke) {\n        self.stroke = stroke\n        nextIndex = 1\n        sampleCount = stroke.samples.count\n        predictedSampleCount = stroke.predictedSamples.count\n        if (predictedSampleCount + sampleCount > 1) {\n            segment = StrokeSegment(sample: sampleAt(0)!)\n            segment.advanceWithSample(incomingSample: sampleAt(1))\n        }\n    } \n \n    func sampleAt(_ index: Int) -> StrokeSample? {\n        if (index < sampleCount) {\n            return stroke.samples[index]\n        }\n        let predictedIndex = index - sampleCount\n        if predictedIndex < predictedSampleCount {\n            return stroke.predictedSamples[predictedIndex]\n        } else {\n            return nil\n        }\n    }\n \n    func next() -> StrokeSegment? {\n        nextIndex += 1\n        if let segment = self.segment {\n            if segment.advanceWithSample(incomingSample: sampleAt(nextIndex)) {\n                return segment\n            }\n        }\n        return nil\n    }\n}\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Incorporating predicted touches into an app",
  "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/incorporating-predicted-touches-into-an-app"
}