{
  "abstract" : "Exchange data streams by using proxy-provider classes.",
  "codeExamples" : [
    {
      "code" : "let flow: NEAppProxyTCPFlow\nlet connection: NWConnection\n\n\/\/ Read from the remote connection and write to the flow.\nfunc inboundCopier() {\n\n    connection.receive(minimumIncompleteLength: 1, \n                       maximumLength: 2048) { (data, _, isComplete, error) in\n\n        switch (data, isComplete, error) {\n            case (let data?, _, _):\n                flow.write(data) { writeError in\n                    if writeError == nil {\n                        \/\/ Set up another read on the remote connection if no error is present.\n                        self.inboundCopier()\n                    }\n                }\n            case (_, true, _):\n                \/\/ The connection is finished; cancel the remote connection and mark flow as closed.\n                connection.stateUpdateHandler = nil\n                connection.cancel()\n                flow.closeReadWithError(error)\n                flow.closeWriteWithError(error)\n            case (_, _, let error?):\n                \/\/ Handle any error.\n            default:\n                \/\/ Handle default case.   \n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let flow: NEAppProxyTCPFlow\nlet connection: NWConnection\n\n\/\/ Reads from the flow and writes to the remote connection.\nfunc outboundCopier() {\n\n    flow.readData { (data, error) in\n        if error == nil, let readData = data, !readData.isEmpty {\n            connection.send(content: readData, \n                            completion: .contentProcessed( { connectionError in\n                \/\/ Handle completion success or error.\n                \/\/ Set up another read if there is no error.\n                if connectionError == nil {\n                    self.outboundCopier()\n                }\n            }))\n        } else {\n            \/\/ Handle error case or the read that contains empty data.\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "14f6ed44ace3de6370be439d2d0d377f574990e054e68b4255520543440987f8",
  "crawledAt" : "2025-12-03T17:25:53Z",
  "id" : "275AA829-7B69-444E-B19B-71199855F227",
  "kind" : "article",
  "language" : "swift",
  "module" : "Network Extension",
  "overview" : "## Overview\n\nIn the context of a Network Extension provider, a *flow* is a bidirectional stream of data. A TCP flow represents a TCP connection. A UDP flow represents a sequence of incoming and outgoing datagrams you can identify based on a local IP address and port and a remote IP address and port.\n\n*Flow copying* has two components: inbound and outbound data. Think of handling inbound data as reading from the remote side of the connection and writing to the local flow. Likewise, handling outbound data is comparable to reading from the local flow and writing to the remote side of the connection.\n\nSome proxy providers may only want to flow copy for a specific set of traffic, such as only Safari flows. Starting with macOS 11,  [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NETransparentProxyProvider] gives the provider the option to handle the flow or let the system do it. This is the only provider you can use to do this. The only other way to limit flows claimed by the provider is to alter the `NETunnelNetworkSettings`.\n\nWhen implementing a [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyProvider] or [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEDNSProxyProvider], you must deal with flows. The system calls the [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyProvider\/handleNewFlow(_:)] method for a flow that the proxy provider claims, based on network settings configured in the provider. A flow enters this method in a closed state, so returning `false` in this method indicates the flow remains closed and the system discards it.\n\n### Decide How to Handle a Flow\n\n`NETransparentProxyProvider` gives the proxy provider the option to handle the flow or let the system do it. This means you can choose the best approach for your situation. For example, when the flow enters `handleNewFlow`, the provider logic handles the flow based on the application from which the traffic originated or the destination IP of the flow.\n\n### Open the Connection\n\nOnce you’ve decided how you want to handle the flow, the next step is to set up the remote side of the connection. You can decide how the provider handles the remote side of the connection, but this article assumes usage of an API such as [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection] or [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_connection_t]. The steps to open the connection are:\n\n### Handle Inbound Data\n\nWhen both sides of the connection move into the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/ready], your next step is to define flow copying methods to read and write inbound data to both sides of the connection. Using `NWConnection` and `NEAppProxyTCPFlow` as an example, you use the following APIs, as shown in the code below:\n\n### Handle Outbound Data\n\nHandle outbound data as you do inbound data, by creating an outbound copier that reads from the local flow and writes to the remote connection. Using `NWConnection` and `NEAppProxyTCPFlow` once again as examples, the methods are listed here and the code is below:\n\n### Implement Flow Control\n\nFlow control is important because it keeps the Network Extension from allocating unbounded amounts of memory that can lead to slow performance or even a *jetsam event*, where the system frees memory by terminating applications. Such conditions can occur when a device experiences poor network conditions or large volumes of data pass through the provider. For more on a *jetsam event*, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/identifying-high-memory-use-with-jetsam-event-reports].\n\nYou can implement flow control by using an implicit technique, where all data is written before any more is read.  This prevents buffering too much data at any one time.  Buffering larger amounts of data can lead to memory problems. If the provider must buffer data, set an upper bound on the buffer and don’t read until the buffer has space to hold more data.\n\n### Close the Connections\n\nWhen the system marks the connection as complete, the flow copying process is finished. Once finished, the flow copying process calls [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/cancel()] on the remote side of the connection, and calls [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyFlow\/closeReadWithError(_:)] and [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyFlow\/closeWriteWithError(_:)]  on the flow. Note that you need to apply the same cancellation and close process when an error takes place on either side of the connection.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/NetworkExtension\/handling-flow-copying\ncrawled: 2025-12-03T17:25:53Z\n---\n\n# Handling Flow Copying\n\n**Article**\n\nExchange data streams by using proxy-provider classes.\n\n## Overview\n\nIn the context of a Network Extension provider, a *flow* is a bidirectional stream of data. A TCP flow represents a TCP connection. A UDP flow represents a sequence of incoming and outgoing datagrams you can identify based on a local IP address and port and a remote IP address and port.\n\n*Flow copying* has two components: inbound and outbound data. Think of handling inbound data as reading from the remote side of the connection and writing to the local flow. Likewise, handling outbound data is comparable to reading from the local flow and writing to the remote side of the connection.\n\nSome proxy providers may only want to flow copy for a specific set of traffic, such as only Safari flows. Starting with macOS 11,  [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NETransparentProxyProvider] gives the provider the option to handle the flow or let the system do it. This is the only provider you can use to do this. The only other way to limit flows claimed by the provider is to alter the `NETunnelNetworkSettings`.\n\nWhen implementing a [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyProvider] or [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEDNSProxyProvider], you must deal with flows. The system calls the [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyProvider\/handleNewFlow(_:)] method for a flow that the proxy provider claims, based on network settings configured in the provider. A flow enters this method in a closed state, so returning `false` in this method indicates the flow remains closed and the system discards it.\n\n\n\n### Decide How to Handle a Flow\n\n`NETransparentProxyProvider` gives the proxy provider the option to handle the flow or let the system do it. This means you can choose the best approach for your situation. For example, when the flow enters `handleNewFlow`, the provider logic handles the flow based on the application from which the traffic originated or the destination IP of the flow.\n\n- To handle a desired flow, return `true` from `handleNewFlow`.\n- To let the operating system handle the flow, return `false` for `NETransparentProxyProvider`.\n- All other proxy providers must handle the flow if returning `true` in `handleNewFlow.`\n- Returning `false` for `NEAppProxyProvider` or `NEDNSProxyProvider`, results in the flow being discarded by the system.\n\n### Open the Connection\n\nOnce you’ve decided how you want to handle the flow, the next step is to set up the remote side of the connection. You can decide how the provider handles the remote side of the connection, but this article assumes usage of an API such as [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection] or [doc:\/\/com.apple.documentation\/documentation\/Network\/nw_connection_t]. The steps to open the connection are:\n\n1. Cast the original [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyFlow] object provided from `handleNewFlow` into the transport protocol object that represents the flow the provider is going to copy. For example, if the provider flow copies TCP, use [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyTCPFlow], and for UDP, use [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyUDPFlow]. The new `NEAppProxyTCPFlow` provides the `remoteEndpoint` object with which you set up the remote connection.\n2. Open the remote connection and wait until it transitions to the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/ready].\n3. After the remote connection is ready, open the local flow using the `NWHostEndpoint` object to represent a local Endpoint.\n\n### Handle Inbound Data\n\nWhen both sides of the connection move into the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/ready], your next step is to define flow copying methods to read and write inbound data to both sides of the connection. Using `NWConnection` and `NEAppProxyTCPFlow` as an example, you use the following APIs, as shown in the code below:\n\n- (Remote side) [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/receive(minimumIncompleteLength:maximumLength:completion:)]\n- (Flow side) [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyTCPFlow\/write(_:withCompletionHandler:)]\n\n```swift\nlet flow: NEAppProxyTCPFlow\nlet connection: NWConnection\n\n\/\/ Read from the remote connection and write to the flow.\nfunc inboundCopier() {\n\n    connection.receive(minimumIncompleteLength: 1, \n                       maximumLength: 2048) { (data, _, isComplete, error) in\n\n        switch (data, isComplete, error) {\n            case (let data?, _, _):\n                flow.write(data) { writeError in\n                    if writeError == nil {\n                        \/\/ Set up another read on the remote connection if no error is present.\n                        self.inboundCopier()\n                    }\n                }\n            case (_, true, _):\n                \/\/ The connection is finished; cancel the remote connection and mark flow as closed.\n                connection.stateUpdateHandler = nil\n                connection.cancel()\n                flow.closeReadWithError(error)\n                flow.closeWriteWithError(error)\n            case (_, _, let error?):\n                \/\/ Handle any error.\n            default:\n                \/\/ Handle default case.   \n        }\n    }\n}\n```\n\n### Handle Outbound Data\n\nHandle outbound data as you do inbound data, by creating an outbound copier that reads from the local flow and writes to the remote connection. Using `NWConnection` and `NEAppProxyTCPFlow` once again as examples, the methods are listed here and the code is below:\n\n- (Flow side) [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyTCPFlow\/readData(completionHandler:)]\n- (Remote side) `send(content:contentContext:isComplete:completion:)`\n\n```swift\nlet flow: NEAppProxyTCPFlow\nlet connection: NWConnection\n\n\/\/ Reads from the flow and writes to the remote connection.\nfunc outboundCopier() {\n\n    flow.readData { (data, error) in\n        if error == nil, let readData = data, !readData.isEmpty {\n            connection.send(content: readData, \n                            completion: .contentProcessed( { connectionError in\n                \/\/ Handle completion success or error.\n                \/\/ Set up another read if there is no error.\n                if connectionError == nil {\n                    self.outboundCopier()\n                }\n            }))\n        } else {\n            \/\/ Handle error case or the read that contains empty data.\n        }\n    }\n}\n```\n\n### Implement Flow Control\n\nFlow control is important because it keeps the Network Extension from allocating unbounded amounts of memory that can lead to slow performance or even a *jetsam event*, where the system frees memory by terminating applications. Such conditions can occur when a device experiences poor network conditions or large volumes of data pass through the provider. For more on a *jetsam event*, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/identifying-high-memory-use-with-jetsam-event-reports].\n\nYou can implement flow control by using an implicit technique, where all data is written before any more is read.  This prevents buffering too much data at any one time.  Buffering larger amounts of data can lead to memory problems. If the provider must buffer data, set an upper bound on the buffer and don’t read until the buffer has space to hold more data.\n\n### Close the Connections\n\nWhen the system marks the connection as complete, the flow copying process is finished. Once finished, the flow copying process calls [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/cancel()] on the remote side of the connection, and calls [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyFlow\/closeReadWithError(_:)] and [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEAppProxyFlow\/closeWriteWithError(_:)]  on the flow. Note that you need to apply the same cancellation and close process when an error takes place on either side of the connection.\n\n## Flow handling\n\n- **NEAppProxyTCPFlow**: An object for reading and writing data to and from a TCP connection being proxied by the provider.\n- **NEAppProxyUDPFlow**: An object for reading and writing data to and from a UDP conversation being proxied by the provider.\n- **NEAppProxyFlow**: An abstract base class shared by NEAppProxyTCPFlow and NEAppProxyUDPFlow.\n- **NEFlowMetaData**: Additional information about data flowing through a per-app VPN provider.\n- **In-Provider Networking**: Network APIs for use by all types of NetworkExtension providers and by hotspot helpers.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object for reading and writing data to and from a TCP connection being proxied by the provider.",
          "name" : "NEAppProxyTCPFlow",
          "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/NEAppProxyTCPFlow"
        },
        {
          "description" : "An object for reading and writing data to and from a UDP conversation being proxied by the provider.",
          "name" : "NEAppProxyUDPFlow",
          "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/NEAppProxyUDPFlow"
        },
        {
          "description" : "An abstract base class shared by NEAppProxyTCPFlow and NEAppProxyUDPFlow.",
          "name" : "NEAppProxyFlow",
          "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/NEAppProxyFlow"
        },
        {
          "description" : "Additional information about data flowing through a per-app VPN provider.",
          "name" : "NEFlowMetaData",
          "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/NEFlowMetaData"
        },
        {
          "description" : "Network APIs for use by all types of NetworkExtension providers and by hotspot helpers.",
          "name" : "In-Provider Networking",
          "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/in-provider-networking"
        }
      ],
      "title" : "Flow handling"
    }
  ],
  "source" : "appleJSON",
  "title" : "Handling Flow Copying",
  "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/handling-flow-copying"
}