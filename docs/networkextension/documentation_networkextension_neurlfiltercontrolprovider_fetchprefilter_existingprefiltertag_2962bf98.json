{
  "abstract" : "Fetches prefilter data, in response to a call from the framework.",
  "codeExamples" : [
    {
      "code" : "h1(x) = FNV-1a(x)\nh2(x) = MurmurHash3(x) with murmurSeed\n\nfor each index i in the range from 0 to < hashCount\n    hashes[i] = (h1(x) + i * h2(x)) mod bitCount",
      "language" : "not specified"
    }
  ],
  "contentHash" : "7261f6f63905f0fef73da741bd481a9fb9d27c4f13ad96d091f83553ee546dfd",
  "crawledAt" : "2025-12-02T18:03:16Z",
  "declaration" : {
    "code" : "func fetchPrefilter(existingPrefilterTag: String?) async throws -> NEURLFilterPrefilter?",
    "language" : "swift"
  },
  "id" : "071B02F6-3FC3-42D9-9F46-596D29CF2D61",
  "kind" : "method",
  "language" : "swift",
  "module" : "Network Extension",
  "overview" : "## Return Value\n\nAn [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter] that contains the prefilter information. The initial fetch must return a valid [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter]. Returning a `nil` prefilter for subsequent fetches indicates no change; in this case, the system continues to use the current prefilter data.\n\n## Discussion\n\nThe system calls this method at the frequency specified by [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterManager\/prefilterFetchInterval]. Your implementation overrides this method to perform whatever steps are necessary to fetch prefilter data. Make sure the first call to this method returns a non-`nil` Bloom filter. On subsequent calls, you can return `nil` to indicate no change to the current Bloom filter. In this case, the system continues to use the previously provided Bloom filter.\n\nThe fetched prefilter data must be a Bloom filter using the 32-bit FNV-1a and 32-bit MurmurHash3 hash functions, with double hashing. Both the FNV-1a and MurmurHash3 hash functions are fast noncryptographic hash functions that produce good distribution. Adding double hashing further improves the spread and distribution of hash values over a Bloom filter’s bit array.\n\nNote that the [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/bitCount] and [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/hashCount] are calculated based on number of items in the data set as well as the false-positive tolerance selected for the Bloom filter. The selected false-positive tolerance must be relatively low to allow for accurate and efficient prefiltering.\n\nGiven the number of items in the data set, `n`, select the false-positive tolerance, `p`, in the range between `0.0` and `1.0`, excluding the bounds, you can calculate the [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/bitCount] and [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/hashCount] as follows:\n\nComposition of the Bloom filter as well as membership testing must deploy the same indexing operations, where `x` is the data string to be insert or check:\n\nFor composition, set the bits to `1` at each of the positions in `hashes[]`. For membership testing, verify if all the bits at positions in `hashes[]` are `1`.\n\nThe input data set contains the URLs you want to block. All URLs in the data set must already be puny-coded before constructing the Bloom filter.\n\nYour provider implementation can return the complete Bloom filter data if the Bloom filter data is relatively small. Otherwise, the implementation can save the Bloom filter data in a temporary file and return the file path.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/NetworkExtension\/NEURLFilterControlProvider\/fetchPrefilter(existingPrefilterTag:)\ncrawled: 2025-12-02T18:03:16Z\n---\n\n# fetchPrefilter(existingPrefilterTag:)\n\n**Instance Method**\n\nFetches prefilter data, in response to a call from the framework.\n\n## Declaration\n\n```swift\nfunc fetchPrefilter(existingPrefilterTag: String?) async throws -> NEURLFilterPrefilter?\n```\n\n## Parameters\n\n- **existingPrefilterTag**: The tag of the current Bloom filter.  The system passes the tag of the last fetched Bloom filter, or `nil` for the initial fetch. Your implementation can use this tag to decide if a Bloom filter update is necessary.  If an update isn’t necessary, return `nil` to tell the system to continue using the current Bloom filter.\n\n## Return Value\n\nAn [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter] that contains the prefilter information. The initial fetch must return a valid [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter]. Returning a `nil` prefilter for subsequent fetches indicates no change; in this case, the system continues to use the current prefilter data.\n\n## Discussion\n\nThe system calls this method at the frequency specified by [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterManager\/prefilterFetchInterval]. Your implementation overrides this method to perform whatever steps are necessary to fetch prefilter data. Make sure the first call to this method returns a non-`nil` Bloom filter. On subsequent calls, you can return `nil` to indicate no change to the current Bloom filter. In this case, the system continues to use the previously provided Bloom filter.\n\nThe fetched prefilter data must be a Bloom filter using the 32-bit FNV-1a and 32-bit MurmurHash3 hash functions, with double hashing. Both the FNV-1a and MurmurHash3 hash functions are fast noncryptographic hash functions that produce good distribution. Adding double hashing further improves the spread and distribution of hash values over a Bloom filter’s bit array.\n\nNote that the [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/bitCount] and [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/hashCount] are calculated based on number of items in the data set as well as the false-positive tolerance selected for the Bloom filter. The selected false-positive tolerance must be relatively low to allow for accurate and efficient prefiltering.\n\nGiven the number of items in the data set, `n`, select the false-positive tolerance, `p`, in the range between `0.0` and `1.0`, excluding the bounds, you can calculate the [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/bitCount] and [doc:\/\/com.apple.networkextension\/documentation\/NetworkExtension\/NEURLFilterPrefilter\/hashCount] as follows:\n\n\n\nComposition of the Bloom filter as well as membership testing must deploy the same indexing operations, where `x` is the data string to be insert or check:\n\n```not specified\nh1(x) = FNV-1a(x)\nh2(x) = MurmurHash3(x) with murmurSeed\n\nfor each index i in the range from 0 to < hashCount\n    hashes[i] = (h1(x) + i * h2(x)) mod bitCount\n```\n\nFor composition, set the bits to `1` at each of the positions in `hashes[]`. For membership testing, verify if all the bits at positions in `hashes[]` are `1`.\n\nThe input data set contains the URLs you want to block. All URLs in the data set must already be puny-coded before constructing the Bloom filter.\n\nYour provider implementation can return the complete Bloom filter data if the Bloom filter data is relatively small. Otherwise, the implementation can save the Bloom filter data in a temporary file and return the file path.\n\n\n\n## Fetching a prefilter\n\n- **NEURLFilterPrefilter**: A structure containing a prefilter returned by a filter control provider.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A structure containing a prefilter returned by a filter control provider.",
          "name" : "NEURLFilterPrefilter",
          "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/NEURLFilterPrefilter"
        }
      ],
      "title" : "Fetching a prefilter"
    }
  ],
  "source" : "appleJSON",
  "title" : "fetchPrefilter(existingPrefilterTag:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/NetworkExtension\/NEURLFilterControlProvider\/fetchPrefilter(existingPrefilterTag:)"
}