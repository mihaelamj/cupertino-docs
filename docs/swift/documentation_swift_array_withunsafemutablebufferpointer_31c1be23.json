{
  "abstract" : "Calls the given closure with a pointer to the array’s mutable contiguous storage.",
  "codeExamples" : [
    {
      "code" : "var numbers = [1, 2, 3, 4, 5]\nnumbers.withUnsafeMutableBufferPointer { buffer in\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {\n        buffer.swapAt(i, i + 1)\n    }\n}\nprint(numbers)\n\/\/ Prints \"[2, 1, 4, 3, 5]\"",
      "language" : "swift"
    }
  ],
  "contentHash" : "a58739d105b5e6ffa21265d62ba060a4f7455de9ce9fbad1bc3bd9d7ad1e4a7b",
  "crawledAt" : "2025-12-02T20:52:37Z",
  "declaration" : {
    "code" : "mutating func withUnsafeMutableBufferPointer<R, E>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws(E) -> R) throws(E) -> R where E : Error",
    "language" : "swift"
  },
  "id" : "D8FE9D6E-2C91-4F73-AF3F-83DF07DD9FEC",
  "kind" : "method",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nThe return value, if any, of the `body` closure parameter.\n\n## Discussion\n\nOften, the optimizer can eliminate bounds checks within an array algorithm, but when that fails, invoking the same algorithm on the buffer pointer passed into your closure lets you trade safety for speed.\n\nThe following example shows how modifying the contents of the `UnsafeMutableBufferPointer` argument to `body` alters the contents of the array:\n\nThe pointer passed as an argument to `body` is valid only during the execution of `withUnsafeMutableBufferPointer(_:)`. Do not store or return the pointer for later use.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeMutableBufferPointer(_:)\ncrawled: 2025-12-02T20:52:37Z\n---\n\n# withUnsafeMutableBufferPointer(_:)\n\n**Instance Method**\n\nCalls the given closure with a pointer to the array’s mutable contiguous storage.\n\n## Declaration\n\n```swift\nmutating func withUnsafeMutableBufferPointer<R, E>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws(E) -> R) throws(E) -> R where E : Error\n```\n\n## Parameters\n\n- **body**: A closure with an `UnsafeMutableBufferPointer` parameter that points to the contiguous storage for the array. If no such storage exists, it is created. If `body` has a return value, that value is also used as the return value for the `withUnsafeMutableBufferPointer(_:)` method. The pointer argument is valid only for the duration of the method’s execution.\n\n## Return Value\n\nThe return value, if any, of the `body` closure parameter.\n\n## Discussion\n\nOften, the optimizer can eliminate bounds checks within an array algorithm, but when that fails, invoking the same algorithm on the buffer pointer passed into your closure lets you trade safety for speed.\n\nThe following example shows how modifying the contents of the `UnsafeMutableBufferPointer` argument to `body` alters the contents of the array:\n\n```swift\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.withUnsafeMutableBufferPointer { buffer in\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {\n        buffer.swapAt(i, i + 1)\n    }\n}\nprint(numbers)\n\/\/ Prints \"[2, 1, 4, 3, 5]\"\n```\n\nThe pointer passed as an argument to `body` is valid only during the execution of `withUnsafeMutableBufferPointer(_:)`. Do not store or return the pointer for later use.\n\n\n\n## Accessing Underlying Storage\n\n- **withUnsafeBufferPointer(_:)**: Calls a closure with a pointer to the array’s contiguous storage.\n- **withUnsafeBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.\n- **withUnsafeMutableBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.\n- **withContiguousStorageIfAvailable(_:)**: Executes a closure on the sequence’s contiguous storage.\n- **withContiguousMutableStorageIfAvailable(_:)**: Executes a closure on the collection’s contiguous storage.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Calls a closure with a pointer to the array’s contiguous storage.",
          "name" : "withUnsafeBufferPointer(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeBufferPointer(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.",
          "name" : "withUnsafeBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeBytes(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.",
          "name" : "withUnsafeMutableBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeMutableBytes(_:)"
        },
        {
          "description" : "Executes a closure on the sequence’s contiguous storage.",
          "name" : "withContiguousStorageIfAvailable(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withContiguousStorageIfAvailable(_:)"
        },
        {
          "description" : "Executes a closure on the collection’s contiguous storage.",
          "name" : "withContiguousMutableStorageIfAvailable(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withContiguousMutableStorageIfAvailable(_:)"
        }
      ],
      "title" : "Accessing Underlying Storage"
    }
  ],
  "source" : "appleJSON",
  "title" : "withUnsafeMutableBufferPointer(_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeMutableBufferPointer(_:)"
}