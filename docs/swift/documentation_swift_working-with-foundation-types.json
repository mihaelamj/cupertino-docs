{
  "abstract" : "Use bridged Foundation types in your Swift codebase to work with dates, times, and other values.",
  "codeExamples" : [
    {
      "code" : "let dataValue = Data(base64Encoded: myString)\nlet dataReference = dataValue as NSData?",
      "language" : "swift"
    }
  ],
  "contentHash" : "fe72cb134fe960df31b1454bd879e9f43005a908c63525dd511dfbb976d762da",
  "crawledAt" : "2025-12-04T02:30:09Z",
  "id" : "955111E3-8BC5-42D5-B6E4-843F6E4BEAA5",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nWhen importing the Foundation framework, the Swift overlay provides value types for many bridged reference types. Many other types are renamed or nested to clarify relationships.\n\n### Prefer Swift Value Types to Bridged Objective-C Reference Types\n\nThe value types in the table below have the same functionality as their corresponding reference types. Class clusters that include immutable and mutable subclasses, like `NSArray` and `NSMutableArray`, are bridged to a single value type.\n\nWhen Swift code imports Objective-C APIs, the importer replaces Foundation reference types with their corresponding value types. For this reason, you should almost never need to use a bridged reference type directly in your own code.\n\nIf you need the reference semantics that come with the Foundation reference type, you can access it with its original `NS` class name prefix. Cast between a Swift value type and its corresponding reference type by using the `as` keyword.\n\n### Note Renamed Reference Types\n\nFor Foundation types that *aren’t* bridged to value types, the Swift overlay renames classes and protocols, as well as related enumerations and constants. These types and protocols drop their `NS` prefix, with the following exceptions:\n\nFoundation classes often declare enumeration or constant types. When importing these types, Swift moves them to be nested types of their related types. For example, the `NSJSONReadingOptions` option set is imported as `JSONSerialization.ReadingOptions`.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/working-with-foundation-types\ncrawled: 2025-12-04T02:30:09Z\n---\n\n# Working with Foundation Types\n\n**Article**\n\nUse bridged Foundation types in your Swift codebase to work with dates, times, and other values.\n\n## Overview\n\nWhen importing the Foundation framework, the Swift overlay provides value types for many bridged reference types. Many other types are renamed or nested to clarify relationships.\n\n### Prefer Swift Value Types to Bridged Objective-C Reference Types\n\nThe value types in the table below have the same functionality as their corresponding reference types. Class clusters that include immutable and mutable subclasses, like `NSArray` and `NSMutableArray`, are bridged to a single value type.\n\n\n\nWhen Swift code imports Objective-C APIs, the importer replaces Foundation reference types with their corresponding value types. For this reason, you should almost never need to use a bridged reference type directly in your own code.\n\nIf you need the reference semantics that come with the Foundation reference type, you can access it with its original `NS` class name prefix. Cast between a Swift value type and its corresponding reference type by using the `as` keyword.\n\n```swift\nlet dataValue = Data(base64Encoded: myString)\nlet dataReference = dataValue as NSData?\n```\n\n### Note Renamed Reference Types\n\nFor Foundation types that *aren’t* bridged to value types, the Swift overlay renames classes and protocols, as well as related enumerations and constants. These types and protocols drop their `NS` prefix, with the following exceptions:\n\n- Classes specific to Objective-C or inherently tied to the Objective-C runtime, like `NSObject`, `NSAutoreleasePool`, `NSException`, and `NSProxy`\n- Platform-specific classes, like `NSBackgroundActivity`, `NSUserNotification`, and `NSXPCConnection`\n\nFoundation classes often declare enumeration or constant types. When importing these types, Swift moves them to be nested types of their related types. For example, the `NSJSONReadingOptions` option set is imported as `JSONSerialization.ReadingOptions`.\n\n## Cocoa Frameworks\n\n- **Working with Core Foundation Types**: Work directly with memory-managed Core Foundation types in your Swift code, and manually handle retains as needed.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Work directly with memory-managed Core Foundation types in your Swift code, and manually handle retains as needed.",
          "name" : "Working with Core Foundation Types",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/working-with-core-foundation-types"
        }
      ],
      "title" : "Cocoa Frameworks"
    }
  ],
  "source" : "appleJSON",
  "title" : "Working with Foundation Types",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/working-with-foundation-types"
}