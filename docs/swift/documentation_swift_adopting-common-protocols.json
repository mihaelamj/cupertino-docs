{
  "abstract" : "Make your custom types easier to use by ensuring that they conform to Swift protocols.",
  "codeExamples" : [
    {
      "code" : "if username == \"Arturo\" {\n    print(\"Hi, Arturo!\")\n}\n\nlet favoriteNumbers = [4, 7, 8, 9]\nif favoriteNumbers.contains(todaysDate.day) {\n    print(\"It's a good day today!\")\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ A position in an x-y coordinate system.\nstruct Position: Equatable, Hashable {\n    var x: Int\n    var y: Int\n\n    init(_ x: Int, _ y: Int) {\n        self.x = x\n        self.y = y\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let availablePositions = [Position(0, 0), Position(0, 1), Position(1, 0)]\nlet gemPosition = Position(1, 0)\n\nfor position in availablePositions {\n    if gemPosition == position {\n        print(\"Gem found at (\\(position.x), \\(position.y))!\")\n    } else {\n        print(\"No gem at (\\(position.x), \\(position.y))\")\n    }\n}\n\/\/ No gem at (0, 0)\n\/\/ No gem at (0, 1)\n\/\/ Gem found at (1, 0)!\n",
      "language" : "swift"
    },
    {
      "code" : "var visitedPositions: Set = [Position(0, 0), Position(1, 0)]\nlet currentPosition = Position(1, 3)\n\nif visitedPositions.contains(currentPosition) {\n    print(\"Already visited (\\(currentPosition.x), \\(currentPosition.y))\")\n} else {\n    print(\"First time at (\\(currentPosition.x), \\(currentPosition.y))\")\n    visitedPositions.insert(currentPosition)\n}\n\/\/ First time at (1, 3)\n",
      "language" : "swift"
    },
    {
      "code" : "class Player {\n    var name: String\n    var position: Position\n\n    init(name: String, position: Position) {\n        self.name = name\n        self.position = position\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Player: Equatable {\n    static func ==(lhs: Player, rhs: Player) -> Bool {\n        return lhs.name == rhs.name && lhs.position == rhs.position\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Player: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(position)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension MyNSObjectSubclass {\n    override func isEqual(_ object: Any?) -> Bool {\n        guard let other = object as? MyNSObjectSubclass\n            else { return false }\n        return self.firstProperty == other.firstProperty \n            && self.secondProperty == other.secondProperty\n    }\n\n    override var hash: Int {\n        var hasher = Hasher()\n        hasher.combine(firstProperty)\n        hasher.combine(secondProperty)\n        return hasher.finalize()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "74b2eff94297b81e8b2952f28702cebfdaa3461632f4987c9fd6dd808859a38e",
  "crawledAt" : "2025-12-03T04:15:58Z",
  "id" : "DB2E5076-BA58-4F49-BC73-D75A08C6DCB4",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nWhen using custom types to model data in your programs, you may frequently need to check whether two values are the same or different, or whether a particular value is included in a list of values. This capability, as well as the ability to store values in a set or use them as keys in a dictionary, are governed by two related standard library protocols, [doc:\/\/com.apple.Swift\/documentation\/Swift\/Equatable] and [doc:\/\/com.apple.Swift\/documentation\/Swift\/Hashable].\n\nMany standard library types are both equatable and hashable, including strings, integers, floating-point values, Boolean values, and collections of equatable and hashable types. The `==` comparison and the `contains(_:)` method call in the following example depend on strings and integers being equatable:\n\nConforming to the `Equatable` and `Hashable` protocols is straightforward and makes it easier to use your own types in Swift. It’s a good idea for all your custom model types to conform.\n\n### Conform Automatically to Equatable and Hashable\n\nYou can make many custom types equatable and hashable by simply declaring these protocol conformances in the same file as the type’s original declaration. Add `Equatable` and `Hashable` to the list of adopted protocols when declaring the type, and the compiler automatically fills in the requirements for the two protocols:\n\nWith `Equatable` conformance, you can use the equal-to operator (`==`) or the not-equal-to operator (`!=`) with any two instances of the `Position` type.\n\n`Hashable` conformance means that you can store positions in a set and quickly check whether you’ve visited a position before, as shown in the following example:\n\nIn addition to simplifying your code, this automatic conformance reduces errors, because any new properties you add to your custom types are automatically included when hashing and testing for equality. A type is eligible for automatic conformance to `Equatable` and `Hashable` when it’s a structure or an enumeration that meets these criteria:\n\n### Conform Manually to Equatable and Hashable\n\nYou need to manually implement `Equatable` and `Hashable` conformance for a type in these cases:\n\nThe `Player` type is a class, so it doesn’t qualify for automatic synthesis of the `Equatable` or `Hashable` requirements. To make this class conform to the `Equatable` protocol, declare conformance in an extension and implement the  static `==` operator method. Compare each significant property for equality in your `==` method’s implementation:\n\nTo make `Player` conform to the `Hashable` protocol, declare conformance in another extension and implement the `hash(into:)` method. In the `hash(into:)` method, call the `combine(_:)` method on the provided hasher with each significant property:\n\n#### Use All Significant Properties for Equatable and Hashable\n\nWhen implementing the `==` method and the `hash(into:)` method, use all the properties that affect whether two instances of your custom type are considered equal. In the implementations above, the `Player` type uses `name` and `position` in both methods.\n\nIf your type contains properties that don’t affect whether two instances are considered equal, exclude those properties from comparison in the `==` method and from hashing in `hash(into:)`. For example, a type might cache an expensive computed value so that it only needs to calculate it once. If you compare two instances of that type, whether or not the computed value has been cached shouldn’t affect their equality, so the cached value should be excluded from comparison and hashing.\n\n### Customize NSObject Subclass Behavior\n\n`NSObject` subclasses inherit conformance to the `Equatable` and `Hashable` protocols, with equality based on instance identity. If you need to customize this behavior, override the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObjectProtocol\/isEqual(_:)] method and [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObjectProtocol\/hash] property instead of the `==` operator method and `hashValue` property.\n\nAs noted in the previous section, two instances that are considered equal must have the same hash value. If you override one of these declarations, you must also override the other to maintain that guarantee.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/adopting-common-protocols\ncrawled: 2025-12-03T04:15:58Z\n---\n\n# Adopting Common Protocols\n\n**Article**\n\nMake your custom types easier to use by ensuring that they conform to Swift protocols.\n\n## Overview\n\nWhen using custom types to model data in your programs, you may frequently need to check whether two values are the same or different, or whether a particular value is included in a list of values. This capability, as well as the ability to store values in a set or use them as keys in a dictionary, are governed by two related standard library protocols, [doc:\/\/com.apple.Swift\/documentation\/Swift\/Equatable] and [doc:\/\/com.apple.Swift\/documentation\/Swift\/Hashable].\n\n- You can compare instances of an *equatable* type by using the equal-to (`==`) and not-equal-to (`!=`) operators.\n- An instance of a *hashable* type can reduce its value mathematically to a single integer, which is used internally by sets and dictionaries to make lookups consistently fast.\n\nMany standard library types are both equatable and hashable, including strings, integers, floating-point values, Boolean values, and collections of equatable and hashable types. The `==` comparison and the `contains(_:)` method call in the following example depend on strings and integers being equatable:\n\n```swift\nif username == \"Arturo\" {\n    print(\"Hi, Arturo!\")\n}\n\nlet favoriteNumbers = [4, 7, 8, 9]\nif favoriteNumbers.contains(todaysDate.day) {\n    print(\"It's a good day today!\")\n}\n```\n\nConforming to the `Equatable` and `Hashable` protocols is straightforward and makes it easier to use your own types in Swift. It’s a good idea for all your custom model types to conform.\n\n### Conform Automatically to Equatable and Hashable\n\nYou can make many custom types equatable and hashable by simply declaring these protocol conformances in the same file as the type’s original declaration. Add `Equatable` and `Hashable` to the list of adopted protocols when declaring the type, and the compiler automatically fills in the requirements for the two protocols:\n\n```swift\n\/\/\/ A position in an x-y coordinate system.\nstruct Position: Equatable, Hashable {\n    var x: Int\n    var y: Int\n\n    init(_ x: Int, _ y: Int) {\n        self.x = x\n        self.y = y\n    }\n}\n```\n\nWith `Equatable` conformance, you can use the equal-to operator (`==`) or the not-equal-to operator (`!=`) with any two instances of the `Position` type.\n\n```swift\nlet availablePositions = [Position(0, 0), Position(0, 1), Position(1, 0)]\nlet gemPosition = Position(1, 0)\n\nfor position in availablePositions {\n    if gemPosition == position {\n        print(\"Gem found at (\\(position.x), \\(position.y))!\")\n    } else {\n        print(\"No gem at (\\(position.x), \\(position.y))\")\n    }\n}\n\/\/ No gem at (0, 0)\n\/\/ No gem at (0, 1)\n\/\/ Gem found at (1, 0)!\n\n```\n\n`Hashable` conformance means that you can store positions in a set and quickly check whether you’ve visited a position before, as shown in the following example:\n\n```swift\nvar visitedPositions: Set = [Position(0, 0), Position(1, 0)]\nlet currentPosition = Position(1, 3)\n\nif visitedPositions.contains(currentPosition) {\n    print(\"Already visited (\\(currentPosition.x), \\(currentPosition.y))\")\n} else {\n    print(\"First time at (\\(currentPosition.x), \\(currentPosition.y))\")\n    visitedPositions.insert(currentPosition)\n}\n\/\/ First time at (1, 3)\n\n```\n\nIn addition to simplifying your code, this automatic conformance reduces errors, because any new properties you add to your custom types are automatically included when hashing and testing for equality. A type is eligible for automatic conformance to `Equatable` and `Hashable` when it’s a structure or an enumeration that meets these criteria:\n\n- For a structure, *all* its stored properties must conform to `Equatable` and `Hashable`.\n- For an enumeration, *all* its associated values must conform to `Equatable` and `Hashable`. (Enumerations without associated values have `Equatable` and `Hashable` conformance even without declaring adoption.)\n\n### Conform Manually to Equatable and Hashable\n\nYou need to manually implement `Equatable` and `Hashable` conformance for a type in these cases:\n\n- The type doesn’t meet the criteria listed in the previous section.\n- You want to customize the type’s conformance.\n- You want to extend a type declared in another file or module to conform.\n\n```swift\nclass Player {\n    var name: String\n    var position: Position\n\n    init(name: String, position: Position) {\n        self.name = name\n        self.position = position\n    }\n}\n```\n\nThe `Player` type is a class, so it doesn’t qualify for automatic synthesis of the `Equatable` or `Hashable` requirements. To make this class conform to the `Equatable` protocol, declare conformance in an extension and implement the  static `==` operator method. Compare each significant property for equality in your `==` method’s implementation:\n\n```swift\nextension Player: Equatable {\n    static func ==(lhs: Player, rhs: Player) -> Bool {\n        return lhs.name == rhs.name && lhs.position == rhs.position\n    }\n}\n```\n\nTo make `Player` conform to the `Hashable` protocol, declare conformance in another extension and implement the `hash(into:)` method. In the `hash(into:)` method, call the `combine(_:)` method on the provided hasher with each significant property:\n\n```swift\nextension Player: Hashable {\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(name)\n        hasher.combine(position)\n    }\n}\n```\n\n#### Use All Significant Properties for Equatable and Hashable\n\nWhen implementing the `==` method and the `hash(into:)` method, use all the properties that affect whether two instances of your custom type are considered equal. In the implementations above, the `Player` type uses `name` and `position` in both methods.\n\nIf your type contains properties that don’t affect whether two instances are considered equal, exclude those properties from comparison in the `==` method and from hashing in `hash(into:)`. For example, a type might cache an expensive computed value so that it only needs to calculate it once. If you compare two instances of that type, whether or not the computed value has been cached shouldn’t affect their equality, so the cached value should be excluded from comparison and hashing.\n\n\n\n### Customize NSObject Subclass Behavior\n\n`NSObject` subclasses inherit conformance to the `Equatable` and `Hashable` protocols, with equality based on instance identity. If you need to customize this behavior, override the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObjectProtocol\/isEqual(_:)] method and [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObjectProtocol\/hash] property instead of the `==` operator method and `hashValue` property.\n\n```swift\nextension MyNSObjectSubclass {\n    override func isEqual(_ object: Any?) -> Bool {\n        guard let other = object as? MyNSObjectSubclass\n            else { return false }\n        return self.firstProperty == other.firstProperty \n            && self.secondProperty == other.secondProperty\n    }\n\n    override var hash: Int {\n        var hasher = Hasher()\n        hasher.combine(firstProperty)\n        hasher.combine(secondProperty)\n        return hasher.finalize()\n    }\n}\n```\n\nAs noted in the previous section, two instances that are considered equal must have the same hash value. If you override one of these declarations, you must also override the other to maintain that guarantee.\n\n## Data Modeling\n\n- **Choosing Between Structures and Classes**: Decide how to store data and model behavior.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Decide how to store data and model behavior.",
          "name" : "Choosing Between Structures and Classes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/choosing-between-structures-and-classes"
        }
      ],
      "title" : "Data Modeling"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adopting Common Protocols",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/adopting-common-protocols"
}