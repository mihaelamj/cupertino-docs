{
  "abstract" : "Reserves enough space to store the specified number of elements.",
  "codeExamples" : [
    {
      "code" : "  var values: [Int] = [0, 1, 2, 3]\n\n  \/\/ Don't use 'reserveCapacity(_:)' like this\n  func addTenQuadratic() {\n      let newCount = values.count + 10\n      values.reserveCapacity(newCount)\n      for n in values.count..<newCount {\n          values.append(n)\n      }\n  }",
      "language" : "swift"
    },
    {
      "code" : "  func addTen() {\n      let newCount = values.count + 10\n      for n in values.count..<newCount {\n          values.append(n)\n      }\n  }",
      "language" : "swift"
    }
  ],
  "contentHash" : "e172c44c062b7c91cfc9c926015579c4e56042941df5512388b567a513e94d5d",
  "crawledAt" : "2025-12-03T16:38:19Z",
  "declaration" : {
    "code" : "mutating func reserveCapacity(_ minimumCapacity: Int)",
    "language" : "swift"
  },
  "id" : "4D3402DE-5D46-444E-86F0-8157F1669615",
  "kind" : "method",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Discussion\n\nIf you are adding a known number of elements to an array, use this method to avoid multiple reallocations. This method ensures that the array has unique, mutable, contiguous storage, with space allocated for at least the requested number of elements.\n\nCalling the `reserveCapacity(_:)` method on an array with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store `minimumCapacity` elements.\n\nFor performance reasons, the size of the newly allocated storage might be greater than the requested capacity. Use the array’s `capacity` property to determine the size of the new storage.\n\n# Preserving an Array’s Geometric Growth Strategy\n\nIf you implement a custom data structure backed by an array that grows dynamically, naively calling the `reserveCapacity(_:)` method can lead to worse than expected performance. Arrays need to follow a geometric allocation pattern for appending elements to achieve amortized constant-time performance. The `Array` type’s `append(_:)` and `append(contentsOf:)` methods take care of this detail for you, but `reserveCapacity(_:)` allocates only as much space as you tell it to (padded to a round value), and no more. This avoids over-allocation, but can result in insertion not having amortized constant-time performance.\n\nThe following code declares `values`, an array of integers, and the `addTenQuadratic()` function, which adds ten more values to the `values` array on each call.\n\nThe call to `reserveCapacity(_:)` increases the `values` array’s capacity by exactly 10 elements on each pass through `addTenQuadratic()`, which is linear growth. Instead of having constant time when averaged over many calls, the function may decay to performance that is linear in `values.count`. This is almost certainly not what you want.\n\nIn cases like this, the simplest fix is often to simply remove the call to `reserveCapacity(_:)`, and let the `append(_:)` method grow the array for you.\n\nIf you need more control over the capacity of your array, implement your own geometric growth strategy, passing the size you compute to `reserveCapacity(_:)`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/reserveCapacity(_:)\ncrawled: 2025-12-03T16:38:19Z\n---\n\n# reserveCapacity(_:)\n\n**Instance Method**\n\nReserves enough space to store the specified number of elements.\n\n## Declaration\n\n```swift\nmutating func reserveCapacity(_ minimumCapacity: Int)\n```\n\n## Parameters\n\n- **minimumCapacity**: The requested number of elements to store.\n\n## Discussion\n\nIf you are adding a known number of elements to an array, use this method to avoid multiple reallocations. This method ensures that the array has unique, mutable, contiguous storage, with space allocated for at least the requested number of elements.\n\nCalling the `reserveCapacity(_:)` method on an array with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store `minimumCapacity` elements.\n\nFor performance reasons, the size of the newly allocated storage might be greater than the requested capacity. Use the array’s `capacity` property to determine the size of the new storage.\n\n# Preserving an Array’s Geometric Growth Strategy\n\nIf you implement a custom data structure backed by an array that grows dynamically, naively calling the `reserveCapacity(_:)` method can lead to worse than expected performance. Arrays need to follow a geometric allocation pattern for appending elements to achieve amortized constant-time performance. The `Array` type’s `append(_:)` and `append(contentsOf:)` methods take care of this detail for you, but `reserveCapacity(_:)` allocates only as much space as you tell it to (padded to a round value), and no more. This avoids over-allocation, but can result in insertion not having amortized constant-time performance.\n\nThe following code declares `values`, an array of integers, and the `addTenQuadratic()` function, which adds ten more values to the `values` array on each call.\n\n```swift\n  var values: [Int] = [0, 1, 2, 3]\n\n  \/\/ Don't use 'reserveCapacity(_:)' like this\n  func addTenQuadratic() {\n      let newCount = values.count + 10\n      values.reserveCapacity(newCount)\n      for n in values.count..<newCount {\n          values.append(n)\n      }\n  }\n```\n\nThe call to `reserveCapacity(_:)` increases the `values` array’s capacity by exactly 10 elements on each pass through `addTenQuadratic()`, which is linear growth. Instead of having constant time when averaged over many calls, the function may decay to performance that is linear in `values.count`. This is almost certainly not what you want.\n\nIn cases like this, the simplest fix is often to simply remove the call to `reserveCapacity(_:)`, and let the `append(_:)` method grow the array for you.\n\n```swift\n  func addTen() {\n      let newCount = values.count + 10\n      for n in values.count..<newCount {\n          values.append(n)\n      }\n  }\n```\n\nIf you need more control over the capacity of your array, implement your own geometric growth strategy, passing the size you compute to `reserveCapacity(_:)`.\n\n\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "reserveCapacity(_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/reserveCapacity(_:)"
}