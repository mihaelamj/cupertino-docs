{
  "abstract" : "Improve your app’s performance by refactoring your code to take advantage of asynchronous functions in Swift.",
  "codeExamples" : [
    {
      "code" : "\/\/ Save the sample to the HealthKit store.\ndo {\n    try await store.save(caffeineSample)\n    self.logger.debug(\"\\(mgCaffeine) mg Drink saved to HealthKit\")\n} catch {\n    self.logger.error(\"Unable to save \\(caffeineSample) to the HealthKit store: \\(error.localizedDescription)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "private func queryHealthKit() async throws -> ([HKSample]?, [HKDeletedObject]?, HKQueryAnchor?) {\n    return try await withCheckedThrowingContinuation { continuation in\n        \/\/ Create a predicate that only returns samples created within the last 24 hours.\n        let endDate = Date()\n        let startDate = endDate.addingTimeInterval(-24.0 * 60.0 * 60.0)\n        let datePredicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: [.strictStartDate, .strictEndDate])\n        \n        \/\/ Create the query.\n        let query = HKAnchoredObjectQuery(\n            type: caffeineType,\n            predicate: datePredicate,\n            anchor: anchor,\n            limit: HKObjectQueryNoLimit) { (_, samples, deletedSamples, newAnchor, error) in\n            \n            \/\/ When the query ends, check for errors.\n            if let error = error {\n                continuation.resume(throwing: error)\n            } else {\n                continuation.resume(returning: (samples, deletedSamples, newAnchor))\n            }\n            \n        }\n        store.execute(query)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "actor HealthKitController {",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Handle background refresh tasks.\ncase let backgroundTask as WKApplicationRefreshBackgroundTask:\n    \n    Task {\n        \/\/ Check for updates from HealthKit.\n        let model = CoffeeData.shared\n        \n        let success = await model.healthKitController.loadNewDataFromHealthKit()\n            \n        if success {\n            \/\/ Schedule the next background update.\n            scheduleBackgroundRefreshTasks()\n            self.logger.debug(\"Background Task Completed Successfully!\")\n        }\n        \n        \/\/ Mark the task as ended, and request an updated snapshot, if necessary.\n        backgroundTask.setTaskCompletedWithSnapshot(success)\n    }",
      "language" : "swift"
    },
    {
      "code" : "@MainActor\nclass CoffeeData: ObservableObject {",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Define whether the complication is visible when the watch is unlocked.\nfunc privacyBehavior(for complication: CLKComplication) async -> CLKComplicationPrivacyBehavior {\n    \/\/ This is potentially sensitive data. Hide it on the lock screen.\n    .hideOnLockScreen\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ca54b1d0276a6c668fec4b9cd444f3d09085e3d74622bcb67f40e07afd3dc578",
  "crawledAt" : "2025-12-02T15:32:40Z",
  "id" : "C103FF3F-D920-4B78-8E2C-C348050558BD",
  "kind" : "unknown",
  "language" : "swift",
  "overview" : "## Overview\n\nSwift concurrency provides a standard set of language tools and techniques for concurrent programming. However, you may already have an existing project built with concurrency that uses other frameworks and techniques. You don’t have to convert all of your code all at once; instead, you can use specific refactoring techniques to convert your code one piece at time.\n\nThis sample provides two separate versions of the Coffee Tracker app:\n\nWatch the session to see the process step by step, and then compare the two projects to see the differences.\n\n### Configure the Sample Code Project\n\nTo add the complication to an active watch face, start by building and running the sample code project in the simulator, and follow these steps:\n\nFor more information on setting up watch faces, see [link-3578854].\n\nAfter configuring and running the Coffee Tracker app, you can test the background updates. Make sure the Coffee Tracker complication appears on the active watch face. Then build and run the app in Simulator, and follow these steps:\n\nCoffee Tracker updates the complication within 15 minutes; however, the update may be delayed based on the system’s current state.\n\n### Convert Completion Handlers to Use Asynchronous Methods\n\nThe `HealthKitController` type contains several calls to the HealthKit SDK. In SDKs that support Swift concurrency, frameworks add `async`-`await` versions of most functions that previously took completion handlers. You can remove completion handlers by updating these calls to use the `async`-`await` versions. You suspend the `store.save()` operation by adding the `await` keyword. Execution resumes after the `await` completes. An `async` function can also be a throwing function, which you call by prepending `try await` to the function call. Wrap the call in a `do-catch` statement instead of using an `Error?` type as a parameter to the completion handler.\n\nIn some cases an SDK call requires using a completion handler. For example, a call to [doc:\/\/com.apple.healthkit\/documentation\/HealthKit\/HKAnchoredObjectQuery\/init(type:predicate:anchor:limit:resultsHandler:)] takes a completion handler, but the call that needs to `await` is the call to [doc:\/\/com.apple.healthkit\/documentation\/HealthKit\/HKHealthStore\/execute(_:)].\n\nTo `await` the results of a completion handler in these cases, add a `continuation`:\n\nTo protect the stored properties on the controller when accessed asynchronously, change `HealthKitController` from a `class` type to an `actor`:\n\nCalls to `async` functions from synchronous functions are made by creating new asynchronous tasks, which can use `await` to wait for completion:\n\n### Put the Coffee Data Class on the Main Actor\n\nThe `CoffeeData` class implements `ObservableObject` and has an `@Published` property to feed the SwiftUI views. To ensure that all updates to this property are made on the main thread, place the type on the main actor:\n\nTwo methods that perform synchronous IO — the `load` and `save` methods — are factored out into a separate `CoffeeDataStore` actor, which performs these activities away from the main thread. The model type on the main actor must use `await` to call methods on the `CoffeeDataStore` actor, which allows other work to run on the main thread during the synchronous IO operations.\n\nThe two types communicate by passing an array of `Drink` values, which is a value type because `Drink` is a structure. Loading returns an array of drinks, and saving takes an array of drinks as an argument.\n\nTo perform all methods asynchronously, replace the `currentDrinks` property’s `didSet` operation with `private(set)` and add a new `async` method named `drinksUpdated`. Move the code from the setter into the new method. Call the `drinksUpdated` after any code that sets the `currentDrinks` property, using an `await` call.\n\nUpdate the `drinksUpdated()` method to call the `CoffeeDataStore` actor using an `await` call. The `CoffeeDataStore` actor saves the data on a background thread.\n\nCalls to the `CoffeeData` object from SwiftUI views don’t require any use of `await` as these views are also on the main actor due to their use of `@EnvironmentObject`.\n\n### Replace Delegates and Completion Handlers with Async Methods\n\nSeveral methods on the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource] protocol used to configure the app’s timeline take completion handlers, which you can replace with their `async` equivalents:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/updating_an_app_to_use_swift_concurrency\ncrawled: 2025-12-02T15:32:40Z\n---\n\n# Updating an App to Use Swift Concurrency\n\n**Sample Code**\n\nImprove your app’s performance by refactoring your code to take advantage of asynchronous functions in Swift.\n\n## Overview\n\n\n\nSwift concurrency provides a standard set of language tools and techniques for concurrent programming. However, you may already have an existing project built with concurrency that uses other frameworks and techniques. You don’t have to convert all of your code all at once; instead, you can use specific refactoring techniques to convert your code one piece at time.\n\nThis sample provides two separate versions of the Coffee Tracker app:\n\n- The original version uses completion handlers to query the HealthKit SDK and to respond to `CLKComplicationDataSource` calls, and dispatch queues to isolate concurrent access to memory. For more information on the original version, see [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/creating-and-updating-a-complication-s-timeline].\n- The updated version uses Swift’s concurrency features to provide clearer code with better error checking at compile time. It replaces the completion handlers with `async` functions, and uses actors to guarantee safe access to data.\n\nWatch the session to see the process step by step, and then compare the two projects to see the differences.\n\n### Configure the Sample Code Project\n\nTo add the complication to an active watch face, start by building and running the sample code project in the simulator, and follow these steps:\n\n1. Click the Digital Crown to exit the app and return to the watch face.\n2. Using the trackpad, firmly press the watch face to put the face in edit mode, then tap Customize.\n3. Swipe left until the configuration screen highlights the complications. Select the complication to modify.\n4. Scroll to the Coffee Tracker complication, and then click the Digital Crown again to save your changes.\n5. Tap the Coffee Tracker complication to go back to the app.\n\nFor more information on setting up watch faces, see [link-3578854].\n\nAfter configuring and running the Coffee Tracker app, you can test the background updates. Make sure the Coffee Tracker complication appears on the active watch face. Then build and run the app in Simulator, and follow these steps:\n\n1. Add one or more drinks using the app’s main view.\n2. Click the Digital Crown to send the app to the background.\n3. Open Settings, and scroll down to Health > Health Data > Nutrition > Caffeine to see all of the drinks you added to the app.\n4. Click Delete Caffeine Data to clear all of the caffeine samples from HealthKit.\n5. Navigate back to the watch face.\n\nCoffee Tracker updates the complication within 15 minutes; however, the update may be delayed based on the system’s current state.\n\n### Convert Completion Handlers to Use Asynchronous Methods\n\nThe `HealthKitController` type contains several calls to the HealthKit SDK. In SDKs that support Swift concurrency, frameworks add `async`-`await` versions of most functions that previously took completion handlers. You can remove completion handlers by updating these calls to use the `async`-`await` versions. You suspend the `store.save()` operation by adding the `await` keyword. Execution resumes after the `await` completes. An `async` function can also be a throwing function, which you call by prepending `try await` to the function call. Wrap the call in a `do-catch` statement instead of using an `Error?` type as a parameter to the completion handler.\n\n```swift\n\/\/ Save the sample to the HealthKit store.\ndo {\n    try await store.save(caffeineSample)\n    self.logger.debug(\"\\(mgCaffeine) mg Drink saved to HealthKit\")\n} catch {\n    self.logger.error(\"Unable to save \\(caffeineSample) to the HealthKit store: \\(error.localizedDescription)\")\n}\n```\n\nIn some cases an SDK call requires using a completion handler. For example, a call to [doc:\/\/com.apple.healthkit\/documentation\/HealthKit\/HKAnchoredObjectQuery\/init(type:predicate:anchor:limit:resultsHandler:)] takes a completion handler, but the call that needs to `await` is the call to [doc:\/\/com.apple.healthkit\/documentation\/HealthKit\/HKHealthStore\/execute(_:)].\n\nTo `await` the results of a completion handler in these cases, add a `continuation`:\n\n```swift\nprivate func queryHealthKit() async throws -> ([HKSample]?, [HKDeletedObject]?, HKQueryAnchor?) {\n    return try await withCheckedThrowingContinuation { continuation in\n        \/\/ Create a predicate that only returns samples created within the last 24 hours.\n        let endDate = Date()\n        let startDate = endDate.addingTimeInterval(-24.0 * 60.0 * 60.0)\n        let datePredicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: [.strictStartDate, .strictEndDate])\n        \n        \/\/ Create the query.\n        let query = HKAnchoredObjectQuery(\n            type: caffeineType,\n            predicate: datePredicate,\n            anchor: anchor,\n            limit: HKObjectQueryNoLimit) { (_, samples, deletedSamples, newAnchor, error) in\n            \n            \/\/ When the query ends, check for errors.\n            if let error = error {\n                continuation.resume(throwing: error)\n            } else {\n                continuation.resume(returning: (samples, deletedSamples, newAnchor))\n            }\n            \n        }\n        store.execute(query)\n    }\n}\n```\n\nTo protect the stored properties on the controller when accessed asynchronously, change `HealthKitController` from a `class` type to an `actor`:\n\n```swift\nactor HealthKitController {\n```\n\nCalls to `async` functions from synchronous functions are made by creating new asynchronous tasks, which can use `await` to wait for completion:\n\n```swift\n\/\/ Handle background refresh tasks.\ncase let backgroundTask as WKApplicationRefreshBackgroundTask:\n    \n    Task {\n        \/\/ Check for updates from HealthKit.\n        let model = CoffeeData.shared\n        \n        let success = await model.healthKitController.loadNewDataFromHealthKit()\n            \n        if success {\n            \/\/ Schedule the next background update.\n            scheduleBackgroundRefreshTasks()\n            self.logger.debug(\"Background Task Completed Successfully!\")\n        }\n        \n        \/\/ Mark the task as ended, and request an updated snapshot, if necessary.\n        backgroundTask.setTaskCompletedWithSnapshot(success)\n    }\n```\n\n### Put the Coffee Data Class on the Main Actor\n\nThe `CoffeeData` class implements `ObservableObject` and has an `@Published` property to feed the SwiftUI views. To ensure that all updates to this property are made on the main thread, place the type on the main actor:\n\n```swift\n@MainActor\nclass CoffeeData: ObservableObject {\n```\n\nTwo methods that perform synchronous IO — the `load` and `save` methods — are factored out into a separate `CoffeeDataStore` actor, which performs these activities away from the main thread. The model type on the main actor must use `await` to call methods on the `CoffeeDataStore` actor, which allows other work to run on the main thread during the synchronous IO operations.\n\nThe two types communicate by passing an array of `Drink` values, which is a value type because `Drink` is a structure. Loading returns an array of drinks, and saving takes an array of drinks as an argument.\n\nTo perform all methods asynchronously, replace the `currentDrinks` property’s `didSet` operation with `private(set)` and add a new `async` method named `drinksUpdated`. Move the code from the setter into the new method. Call the `drinksUpdated` after any code that sets the `currentDrinks` property, using an `await` call.\n\nUpdate the `drinksUpdated()` method to call the `CoffeeDataStore` actor using an `await` call. The `CoffeeDataStore` actor saves the data on a background thread.\n\nCalls to the `CoffeeData` object from SwiftUI views don’t require any use of `await` as these views are also on the main actor due to their use of `@EnvironmentObject`.\n\n### Replace Delegates and Completion Handlers with Async Methods\n\nSeveral methods on the [doc:\/\/com.apple.clockkit\/documentation\/ClockKit\/CLKComplicationDataSource] protocol used to configure the app’s timeline take completion handlers, which you can replace with their `async` equivalents:\n\n```swift\n\/\/ Define whether the complication is visible when the watch is unlocked.\nfunc privacyBehavior(for complication: CLKComplication) async -> CLKComplicationPrivacyBehavior {\n    \/\/ This is potentially sensitive data. Hide it on the lock screen.\n    .hideOnLockScreen\n}\n```\n\n## Standard Library\n\n- **Int**: A signed integer value type.\n- **Double**: A double-precision, floating-point value type.\n- **String**: A Unicode string value that is a collection of characters.\n- **Array**: An ordered, random-access collection.\n- **Dictionary**: A collection whose elements are key-value pairs.\n- **Swift Standard Library**: Solve complex problems and write high-performance, readable code.\n- **TicTacFish: Implementing a game using distributed actors**: Use distributed actors to take your Swift concurrency and actor-based apps beyond a single process.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A signed integer value type.",
          "name" : "Int",
          "url" : "https:\/\/developer.apple.com\/documentation\/swift\/int"
        },
        {
          "description" : "A double-precision, floating-point value type.",
          "name" : "Double",
          "url" : "https:\/\/developer.apple.com\/documentation\/swift\/double"
        },
        {
          "description" : "A Unicode string value that is a collection of characters.",
          "name" : "String",
          "url" : "https:\/\/developer.apple.com\/documentation\/swift\/string"
        },
        {
          "description" : "An ordered, random-access collection.",
          "name" : "Array",
          "url" : "https:\/\/developer.apple.com\/documentation\/swift\/array"
        },
        {
          "description" : "A collection whose elements are key-value pairs.",
          "name" : "Dictionary",
          "url" : "https:\/\/developer.apple.com\/documentation\/swift\/dictionary"
        },
        {
          "description" : "Solve complex problems and write high-performance, readable code.",
          "name" : "Swift Standard Library",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/swift-standard-library"
        },
        {
          "description" : "Use distributed actors to take your Swift concurrency and actor-based apps beyond a single process.",
          "name" : "TicTacFish: Implementing a game using distributed actors",
          "url" : "https:\/\/developer.apple.com\/documentation\/swift\/tictacfish_implementing_a_game_using_distributed_actors"
        }
      ],
      "title" : "Standard Library"
    }
  ],
  "source" : "appleJSON",
  "title" : "Updating an App to Use Swift Concurrency",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/updating_an_app_to_use_swift_concurrency"
}