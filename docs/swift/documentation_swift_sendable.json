{
  "abstract" : "A thread-safe type whose values can be shared across arbitrary concurrent contexts without introducing a risk of data races.",
  "codeExamples" : [
    {
      "code" : "let sendableClosure = { @Sendable (number: Int) -> String in\n    if number > 12 {\n        return \"More than a dozen.\"\n    } else {\n        return \"Less than a dozen\"\n    }\n}",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "Array",
    "ArraySlice",
    "AsyncCompactMapSequence",
    "AsyncCompactMapSequence.Iterator",
    "AsyncDropFirstSequence",
    "AsyncDropFirstSequence.Iterator",
    "AsyncDropWhileSequence",
    "AsyncDropWhileSequence.Iterator",
    "AsyncFilterSequence",
    "AsyncFilterSequence.Iterator",
    "AsyncFlatMapSequence",
    "AsyncFlatMapSequence.Iterator",
    "AsyncMapSequence",
    "AsyncMapSequence.Iterator",
    "AsyncPrefixSequence",
    "AsyncPrefixSequence.Iterator",
    "AsyncPrefixWhileSequence",
    "AsyncPrefixWhileSequence.Iterator",
    "AsyncStream",
    "AsyncStream.Continuation",
    "AsyncStream.Continuation.BufferingPolicy",
    "AsyncStream.Continuation.Termination",
    "AsyncStream.Continuation.YieldResult",
    "AsyncThrowingCompactMapSequence",
    "AsyncThrowingCompactMapSequence.Iterator",
    "AsyncThrowingDropWhileSequence",
    "AsyncThrowingDropWhileSequence.Iterator",
    "AsyncThrowingFilterSequence",
    "AsyncThrowingFilterSequence.Iterator",
    "AsyncThrowingFlatMapSequence",
    "AsyncThrowingFlatMapSequence.Iterator",
    "AsyncThrowingMapSequence",
    "AsyncThrowingMapSequence.Iterator",
    "AsyncThrowingPrefixWhileSequence",
    "AsyncThrowingPrefixWhileSequence.Iterator",
    "AsyncThrowingStream",
    "AsyncThrowingStream.Continuation",
    "AsyncThrowingStream.Continuation.BufferingPolicy",
    "AsyncThrowingStream.Continuation.Termination",
    "AsyncThrowingStream.Continuation.YieldResult",
    "Atomic",
    "AtomicLazyReference",
    "AtomicLoadOrdering",
    "AtomicStoreOrdering",
    "AtomicUpdateOrdering",
    "Bool",
    "CancellationError",
    "Character",
    "CheckedContinuation",
    "ClosedRange",
    "ClosedRange.Index",
    "CodingUserInfoKey",
    "CollectionDifference",
    "CollectionDifference.Change",
    "CollectionDifference.Index",
    "CollectionOfOne",
    "CollectionOfOne.Iterator",
    "CommandLine",
    "ContiguousArray",
    "ContinuousClock",
    "ContinuousClock.Instant",
    "DecodingError",
    "DecodingError.Context",
    "DefaultIndices",
    "DefaultStringInterpolation",
    "Dictionary",
    "Dictionary.Index",
    "Dictionary.Iterator",
    "Dictionary.Keys",
    "Dictionary.Keys.Iterator",
    "Dictionary.Values",
    "Dictionary.Values.Iterator",
    "DiscontiguousSlice",
    "DiscontiguousSlice.Index",
    "DistributedActorCodingError",
    "Double",
    "Double.SIMD16Storage",
    "Double.SIMD2Storage",
    "Double.SIMD32Storage",
    "Double.SIMD4Storage",
    "Double.SIMD64Storage",
    "Double.SIMD8Storage",
    "DropFirstSequence",
    "DropWhileSequence",
    "DropWhileSequence.Iterator",
    "Duration",
    "Duration.TimeFormatStyle",
    "Duration.TimeFormatStyle.Attributed",
    "Duration.TimeFormatStyle.Pattern",
    "Duration.UnitsFormatStyle",
    "Duration.UnitsFormatStyle.Attributed",
    "Duration.UnitsFormatStyle.FractionalPartDisplayStrategy",
    "Duration.UnitsFormatStyle.Unit",
    "Duration.UnitsFormatStyle.UnitWidth",
    "Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy",
    "EmptyCollection",
    "EmptyCollection.Iterator",
    "EncodingError",
    "EncodingError.Context",
    "EnumeratedSequence",
    "EnumeratedSequence.Iterator",
    "ExecuteDistributedTargetError",
    "ExecutorJob",
    "ExecutorJob.Kind",
    "FlattenSequence",
    "FlattenSequence.Index",
    "FlattenSequence.Iterator",
    "Float",
    "Float.SIMD16Storage",
    "Float.SIMD2Storage",
    "Float.SIMD32Storage",
    "Float.SIMD4Storage",
    "Float.SIMD64Storage",
    "Float.SIMD8Storage",
    "Float16",
    "Float16.SIMD16Storage",
    "Float16.SIMD2Storage",
    "Float16.SIMD32Storage",
    "Float16.SIMD4Storage",
    "Float16.SIMD64Storage",
    "Float16.SIMD8Storage",
    "Float80",
    "FloatingPointClassification",
    "FloatingPointRoundingRule",
    "FloatingPointSign",
    "Hasher",
    "IndexingIterator",
    "InlineArray",
    "Int",
    "Int.SIMD16Storage",
    "Int.SIMD2Storage",
    "Int.SIMD32Storage",
    "Int.SIMD4Storage",
    "Int.SIMD64Storage",
    "Int.SIMD8Storage",
    "Int.Words",
    "Int128",
    "Int16",
    "Int16.SIMD16Storage",
    "Int16.SIMD2Storage",
    "Int16.SIMD32Storage",
    "Int16.SIMD4Storage",
    "Int16.SIMD64Storage",
    "Int16.SIMD8Storage",
    "Int16.Words",
    "Int32",
    "Int32.SIMD16Storage",
    "Int32.SIMD2Storage",
    "Int32.SIMD32Storage",
    "Int32.SIMD4Storage",
    "Int32.SIMD64Storage",
    "Int32.SIMD8Storage",
    "Int32.Words",
    "Int64",
    "Int64.SIMD16Storage",
    "Int64.SIMD2Storage",
    "Int64.SIMD32Storage",
    "Int64.SIMD4Storage",
    "Int64.SIMD64Storage",
    "Int64.SIMD8Storage",
    "Int64.Words",
    "Int8",
    "Int8.SIMD16Storage",
    "Int8.SIMD2Storage",
    "Int8.SIMD32Storage",
    "Int8.SIMD4Storage",
    "Int8.SIMD64Storage",
    "Int8.SIMD8Storage",
    "Int8.Words",
    "IteratorSequence",
    "Job",
    "JobPriority",
    "JoinedSequence",
    "JoinedSequence.Iterator",
    "KeyValuePairs",
    "LazyPrefixWhileSequence.Index",
    "LazySequence",
    "LocalTestingActorID",
    "LocalTestingDistributedActorSystem",
    "LocalTestingDistributedActorSystemError",
    "MainActor",
    "MemoryLayout",
    "Mirror.DisplayStyle",
    "MutableRawSpan",
    "MutableSpan",
    "Mutex",
    "Never",
    "ObjectIdentifier",
    "ObservationRegistrar",
    "Observations",
    "Observations.Iteration",
    "Optional",
    "OutputRawSpan",
    "OutputSpan",
    "PartialRangeFrom",
    "PartialRangeFrom.Iterator",
    "PartialRangeThrough",
    "PartialRangeUpTo",
    "PrefixSequence",
    "PrefixSequence.Iterator",
    "Range",
    "RangeSet",
    "RangeSet.Ranges",
    "RawSpan",
    "Repeated",
    "Result",
    "ReversedCollection",
    "ReversedCollection.Index",
    "ReversedCollection.Iterator",
    "SIMD16",
    "SIMD2",
    "SIMD3",
    "SIMD32",
    "SIMD4",
    "SIMD64",
    "SIMD8",
    "SIMDMask",
    "Set",
    "Set.Index",
    "Set.Iterator",
    "Slice",
    "Span",
    "StaticBigInt",
    "StaticString",
    "StrideThrough",
    "StrideThroughIterator",
    "StrideTo",
    "StrideToIterator",
    "String",
    "String.Comparator",
    "String.Encoding",
    "String.Index",
    "String.Iterator",
    "String.LocalizationValue",
    "String.LocalizationValue.Placeholder",
    "String.StandardComparator",
    "String.UTF16View",
    "String.UTF16View.Iterator",
    "String.UTF8View",
    "String.UnicodeScalarView",
    "String.UnicodeScalarView.Iterator",
    "Substring",
    "Substring.UTF16View",
    "Substring.UTF8View",
    "Substring.UnicodeScalarView",
    "SuspendingClock",
    "SuspendingClock.Instant",
    "SystemRandomNumberGenerator",
    "Task",
    "TaskLocal",
    "TaskPriority",
    "UInt",
    "UInt.SIMD16Storage",
    "UInt.SIMD2Storage",
    "UInt.SIMD32Storage",
    "UInt.SIMD4Storage",
    "UInt.SIMD64Storage",
    "UInt.SIMD8Storage",
    "UInt.Words",
    "UInt128",
    "UInt128.Words",
    "UInt16",
    "UInt16.SIMD16Storage",
    "UInt16.SIMD2Storage",
    "UInt16.SIMD32Storage",
    "UInt16.SIMD4Storage",
    "UInt16.SIMD64Storage",
    "UInt16.SIMD8Storage",
    "UInt16.Words",
    "UInt32",
    "UInt32.SIMD16Storage",
    "UInt32.SIMD2Storage",
    "UInt32.SIMD32Storage",
    "UInt32.SIMD4Storage",
    "UInt32.SIMD64Storage",
    "UInt32.SIMD8Storage",
    "UInt32.Words",
    "UInt64",
    "UInt64.SIMD16Storage",
    "UInt64.SIMD2Storage",
    "UInt64.SIMD32Storage",
    "UInt64.SIMD4Storage",
    "UInt64.SIMD64Storage",
    "UInt64.SIMD8Storage",
    "UInt64.Words",
    "UInt8",
    "UInt8.SIMD16Storage",
    "UInt8.SIMD2Storage",
    "UInt8.SIMD32Storage",
    "UInt8.SIMD4Storage",
    "UInt8.SIMD64Storage",
    "UInt8.SIMD8Storage",
    "UInt8.Words",
    "UnboundedRange_",
    "UnfoldSequence",
    "Unicode",
    "Unicode.ASCII",
    "Unicode.ASCII.Parser",
    "Unicode.CanonicalCombiningClass",
    "Unicode.GeneralCategory",
    "Unicode.NumericType",
    "Unicode.ParseResult",
    "Unicode.Scalar",
    "Unicode.Scalar.Properties",
    "Unicode.Scalar.UTF16View",
    "Unicode.Scalar.UTF8View",
    "Unicode.UTF16",
    "Unicode.UTF16.ForwardParser",
    "Unicode.UTF16.ReverseParser",
    "Unicode.UTF32",
    "Unicode.UTF32.Parser",
    "Unicode.UTF8",
    "Unicode.UTF8.ForwardParser",
    "Unicode.UTF8.ReverseParser",
    "Unicode.UTF8.ValidationError",
    "Unicode.UTF8.ValidationError.Kind",
    "UnicodeDecodingResult",
    "Unmanaged",
    "UnownedJob",
    "UnownedSerialExecutor",
    "UnownedTaskExecutor",
    "UnsafeContinuation",
    "WordPair",
    "Zip2Sequence",
    "Zip2Sequence.Iterator"
  ],
  "contentHash" : "fd18d5b133c04a62198858b69445581ae6167bbc0bbde6704cac7261dc807ea5",
  "crawledAt" : "2025-12-03T16:45:31Z",
  "declaration" : {
    "code" : "protocol Sendable : SendableMetatype",
    "language" : "swift"
  },
  "id" : "38C8A1F5-9C76-4CC4-AC75-A675F95A737B",
  "inheritedBy" : [
    "Actor",
    "Clock",
    "CodingKey",
    "DistributedActor",
    "DistributedActorSystem",
    "DistributedActorSystemError",
    "DurationProtocol",
    "Error",
    "Executor",
    "InstantProtocol",
    "SerialExecutor",
    "TaskExecutor",
    "UnsafeSendable"
  ],
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nValues of the type may have no shared mutable state, or they may protect that state with a lock or by forcing it to only be accessed from a specific actor.\n\nYou can safely pass values of a sendable type from one concurrency domain to another — for example, you can pass a sendable value as the argument when calling an actor’s methods. All of the following can be marked as sendable:\n\nAlthough this protocol doesn’t have any required methods or properties, it does have semantic requirements that are enforced at compile time. These requirements are listed in the sections below. Conformance to `Sendable` must be declared in the same file as the type’s declaration.\n\nTo declare conformance to `Sendable` without any compiler enforcement, write `@unchecked Sendable`. You are responsible for the correctness of unchecked sendable types, for example, by protecting all access to its state with a lock or a queue. Unchecked conformance to `Sendable` also disables enforcement of the rule that conformance must be in the same file.\n\nFor information about the language-level concurrency model that `Task` is part of, see [https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html] in [https:\/\/docs.swift.org\/swift-book\/].\n\n### Sendable Structures and Enumerations\n\nTo satisfy the requirements of the `Sendable` protocol, an enumeration or structure must have only sendable members and associated values. In some cases, structures and enumerations that satisfy the requirements implicitly conform to `Sendable`:\n\nOtherwise, you need to declare conformance to `Sendable` explicitly.\n\nStructures that have nonsendable stored properties and enumerations that have nonsendable associated values can be marked as `@unchecked Sendable`, disabling compile-time correctness checks, after you manually verify that they satisfy the `Sendable` protocol’s semantic requirements.\n\n### Sendable Actors\n\nAll actor types implicitly conform to `Sendable` because actors ensure that all access to their mutable state is performed sequentially.\n\n### Sendable Classes\n\nTo satisfy the requirements of the `Sendable` protocol, a class must:\n\nClasses marked with `@MainActor` are implicitly sendable, because the main actor coordinates all access to its state. These classes can have stored properties that are mutable and nonsendable.\n\nClasses that don’t meet the requirements above can be marked as `@unchecked Sendable`, disabling compile-time correctness checks, after you manually verify that they satisfy the `Sendable` protocol’s semantic requirements.\n\n### Sendable Functions and Closures\n\nInstead of conforming to the `Sendable` protocol, you mark sendable functions and closures with the `@Sendable` attribute. Any values that the function or closure captures must be sendable. In addition, sendable closures must use only by-value captures, and the captured values must be of a sendable type.\n\nIn a context that expects a sendable closure, a closure that satisfies the requirements implicitly conforms to `Sendable` — for example, in a call to `Task.detached(priority:operation:)`.\n\nYou can explicitly mark a closure as sendable by writing `@Sendable` as part of a type annotation, or by writing `@Sendable` before the closure’s parameters — for example:\n\n### Sendable Tuples\n\nTo satisfy the requirements of the `Sendable` protocol, all of the elements of the tuple must be sendable. Tuples that satisfy the requirements implicitly conform to `Sendable`.\n\n### Sendable Metatypes\n\nMetatypes such as `Int.Type` implicitly conform to the `Sendable` protocol.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/sendable\ncrawled: 2025-12-03T16:45:31Z\n---\n\n# Sendable\n\n**Protocol**\n\nA thread-safe type whose values can be shared across arbitrary concurrent contexts without introducing a risk of data races.\n\n## Declaration\n\n```swift\nprotocol Sendable : SendableMetatype\n```\n\n## Overview\n\nValues of the type may have no shared mutable state, or they may protect that state with a lock or by forcing it to only be accessed from a specific actor.\n\nYou can safely pass values of a sendable type from one concurrency domain to another — for example, you can pass a sendable value as the argument when calling an actor’s methods. All of the following can be marked as sendable:\n\n- Value types\n- Reference types with no mutable storage\n- Reference types that internally manage access to their state\n- Functions and closures (by marking them with `@Sendable`)\n\nAlthough this protocol doesn’t have any required methods or properties, it does have semantic requirements that are enforced at compile time. These requirements are listed in the sections below. Conformance to `Sendable` must be declared in the same file as the type’s declaration.\n\nTo declare conformance to `Sendable` without any compiler enforcement, write `@unchecked Sendable`. You are responsible for the correctness of unchecked sendable types, for example, by protecting all access to its state with a lock or a queue. Unchecked conformance to `Sendable` also disables enforcement of the rule that conformance must be in the same file.\n\nFor information about the language-level concurrency model that `Task` is part of, see [https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html] in [https:\/\/docs.swift.org\/swift-book\/].\n\n### Sendable Structures and Enumerations\n\nTo satisfy the requirements of the `Sendable` protocol, an enumeration or structure must have only sendable members and associated values. In some cases, structures and enumerations that satisfy the requirements implicitly conform to `Sendable`:\n\n- Frozen structures and enumerations\n- Structures and enumerations that aren’t public and aren’t marked `@usableFromInline`.\n\nOtherwise, you need to declare conformance to `Sendable` explicitly.\n\nStructures that have nonsendable stored properties and enumerations that have nonsendable associated values can be marked as `@unchecked Sendable`, disabling compile-time correctness checks, after you manually verify that they satisfy the `Sendable` protocol’s semantic requirements.\n\n### Sendable Actors\n\nAll actor types implicitly conform to `Sendable` because actors ensure that all access to their mutable state is performed sequentially.\n\n### Sendable Classes\n\nTo satisfy the requirements of the `Sendable` protocol, a class must:\n\n- Be marked `final`\n- Contain only stored properties that are immutable and sendable\n- Have no superclass or have `NSObject` as the superclass\n\nClasses marked with `@MainActor` are implicitly sendable, because the main actor coordinates all access to its state. These classes can have stored properties that are mutable and nonsendable.\n\nClasses that don’t meet the requirements above can be marked as `@unchecked Sendable`, disabling compile-time correctness checks, after you manually verify that they satisfy the `Sendable` protocol’s semantic requirements.\n\n### Sendable Functions and Closures\n\nInstead of conforming to the `Sendable` protocol, you mark sendable functions and closures with the `@Sendable` attribute. Any values that the function or closure captures must be sendable. In addition, sendable closures must use only by-value captures, and the captured values must be of a sendable type.\n\nIn a context that expects a sendable closure, a closure that satisfies the requirements implicitly conforms to `Sendable` — for example, in a call to `Task.detached(priority:operation:)`.\n\nYou can explicitly mark a closure as sendable by writing `@Sendable` as part of a type annotation, or by writing `@Sendable` before the closure’s parameters — for example:\n\n```swift\nlet sendableClosure = { @Sendable (number: Int) -> String in\n    if number > 12 {\n        return \"More than a dozen.\"\n    } else {\n        return \"Less than a dozen\"\n    }\n}\n```\n\n### Sendable Tuples\n\nTo satisfy the requirements of the `Sendable` protocol, all of the elements of the tuple must be sendable. Tuples that satisfy the requirements implicitly conform to `Sendable`.\n\n### Sendable Metatypes\n\nMetatypes such as `Int.Type` implicitly conform to the `Sendable` protocol.\n\n## Actors\n\n- **Actor**: Common protocol to which all actors conform.\n- **AnyActor**: Common marker protocol providing a shared “base” for both (local) `Actor` and (potentially remote) `DistributedActor` types.\n- **MainActor**: A singleton actor whose executor is equivalent to the main dispatch queue.\n- **GlobalActor**: A type that represents a globally-unique actor that can be used to isolate various declarations anywhere in the program.\n- **SendableMetatype**: A type whose metatype can be shared across arbitrary concurrent contexts without introducing a risk of data races. When a generic type `T` conforms to `SendableMetatype`, its metatype `T.Type` conforms to `Sendable`.  All concrete types implicitly conform to the `SendableMetatype` protocol, so its primary purpose is in generic code to prohibit the use of isolated conformances along with the generic type.\n- **ConcurrentValue**\n- **UnsafeSendable**: A type whose values can safely be passed across concurrency domains by copying, but which disables some safety checking at the conformance site.\n- **UnsafeConcurrentValue**\n- **isolation()**: Produce a reference to the actor to which the enclosing code is isolated, or `nil` if the code is nonisolated.\n- **extractIsolation(_:)**\n\n## Inherits From\n\n- SendableMetatype\n\n## Inherited By\n\n- Actor\n- Clock\n- CodingKey\n- DistributedActor\n- DistributedActorSystem\n- DistributedActorSystemError\n- DurationProtocol\n- Error\n- Executor\n- InstantProtocol\n- SerialExecutor\n- TaskExecutor\n- UnsafeSendable\n\n## Conforming Types\n\n- Array\n- ArraySlice\n- AsyncCompactMapSequence\n- AsyncCompactMapSequence.Iterator\n- AsyncDropFirstSequence\n- AsyncDropFirstSequence.Iterator\n- AsyncDropWhileSequence\n- AsyncDropWhileSequence.Iterator\n- AsyncFilterSequence\n- AsyncFilterSequence.Iterator\n- AsyncFlatMapSequence\n- AsyncFlatMapSequence.Iterator\n- AsyncMapSequence\n- AsyncMapSequence.Iterator\n- AsyncPrefixSequence\n- AsyncPrefixSequence.Iterator\n- AsyncPrefixWhileSequence\n- AsyncPrefixWhileSequence.Iterator\n- AsyncStream\n- AsyncStream.Continuation\n- AsyncStream.Continuation.BufferingPolicy\n- AsyncStream.Continuation.Termination\n- AsyncStream.Continuation.YieldResult\n- AsyncThrowingCompactMapSequence\n- AsyncThrowingCompactMapSequence.Iterator\n- AsyncThrowingDropWhileSequence\n- AsyncThrowingDropWhileSequence.Iterator\n- AsyncThrowingFilterSequence\n- AsyncThrowingFilterSequence.Iterator\n- AsyncThrowingFlatMapSequence\n- AsyncThrowingFlatMapSequence.Iterator\n- AsyncThrowingMapSequence\n- AsyncThrowingMapSequence.Iterator\n- AsyncThrowingPrefixWhileSequence\n- AsyncThrowingPrefixWhileSequence.Iterator\n- AsyncThrowingStream\n- AsyncThrowingStream.Continuation\n- AsyncThrowingStream.Continuation.BufferingPolicy\n- AsyncThrowingStream.Continuation.Termination\n- AsyncThrowingStream.Continuation.YieldResult\n- Atomic\n- AtomicLazyReference\n- AtomicLoadOrdering\n- AtomicStoreOrdering\n- AtomicUpdateOrdering\n- Bool\n- CancellationError\n- Character\n- CheckedContinuation\n- ClosedRange\n- ClosedRange.Index\n- CodingUserInfoKey\n- CollectionDifference\n- CollectionDifference.Change\n- CollectionDifference.Index\n- CollectionOfOne\n- CollectionOfOne.Iterator\n- CommandLine\n- ContiguousArray\n- ContinuousClock\n- ContinuousClock.Instant\n- DecodingError\n- DecodingError.Context\n- DefaultIndices\n- DefaultStringInterpolation\n- Dictionary\n- Dictionary.Index\n- Dictionary.Iterator\n- Dictionary.Keys\n- Dictionary.Keys.Iterator\n- Dictionary.Values\n- Dictionary.Values.Iterator\n- DiscontiguousSlice\n- DiscontiguousSlice.Index\n- DistributedActorCodingError\n- Double\n- Double.SIMD16Storage\n- Double.SIMD2Storage\n- Double.SIMD32Storage\n- Double.SIMD4Storage\n- Double.SIMD64Storage\n- Double.SIMD8Storage\n- DropFirstSequence\n- DropWhileSequence\n- DropWhileSequence.Iterator\n- Duration\n- Duration.TimeFormatStyle\n- Duration.TimeFormatStyle.Attributed\n- Duration.TimeFormatStyle.Pattern\n- Duration.UnitsFormatStyle\n- Duration.UnitsFormatStyle.Attributed\n- Duration.UnitsFormatStyle.FractionalPartDisplayStrategy\n- Duration.UnitsFormatStyle.Unit\n- Duration.UnitsFormatStyle.UnitWidth\n- Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy\n- EmptyCollection\n- EmptyCollection.Iterator\n- EncodingError\n- EncodingError.Context\n- EnumeratedSequence\n- EnumeratedSequence.Iterator\n- ExecuteDistributedTargetError\n- ExecutorJob\n- ExecutorJob.Kind\n- FlattenSequence\n- FlattenSequence.Index\n- FlattenSequence.Iterator\n- Float\n- Float.SIMD16Storage\n- Float.SIMD2Storage\n- Float.SIMD32Storage\n- Float.SIMD4Storage\n- Float.SIMD64Storage\n- Float.SIMD8Storage\n- Float16\n- Float16.SIMD16Storage\n- Float16.SIMD2Storage\n- Float16.SIMD32Storage\n- Float16.SIMD4Storage\n- Float16.SIMD64Storage\n- Float16.SIMD8Storage\n- Float80\n- FloatingPointClassification\n- FloatingPointRoundingRule\n- FloatingPointSign\n- Hasher\n- IndexingIterator\n- InlineArray\n- Int\n- Int.SIMD16Storage\n- Int.SIMD2Storage\n- Int.SIMD32Storage\n- Int.SIMD4Storage\n- Int.SIMD64Storage\n- Int.SIMD8Storage\n- Int.Words\n- Int128\n- Int16\n- Int16.SIMD16Storage\n- Int16.SIMD2Storage\n- Int16.SIMD32Storage\n- Int16.SIMD4Storage\n- Int16.SIMD64Storage\n- Int16.SIMD8Storage\n- Int16.Words\n- Int32\n- Int32.SIMD16Storage\n- Int32.SIMD2Storage\n- Int32.SIMD32Storage\n- Int32.SIMD4Storage\n- Int32.SIMD64Storage\n- Int32.SIMD8Storage\n- Int32.Words\n- Int64\n- Int64.SIMD16Storage\n- Int64.SIMD2Storage\n- Int64.SIMD32Storage\n- Int64.SIMD4Storage\n- Int64.SIMD64Storage\n- Int64.SIMD8Storage\n- Int64.Words\n- Int8\n- Int8.SIMD16Storage\n- Int8.SIMD2Storage\n- Int8.SIMD32Storage\n- Int8.SIMD4Storage\n- Int8.SIMD64Storage\n- Int8.SIMD8Storage\n- Int8.Words\n- IteratorSequence\n- Job\n- JobPriority\n- JoinedSequence\n- JoinedSequence.Iterator\n- KeyValuePairs\n- LazyPrefixWhileSequence.Index\n- LazySequence\n- LocalTestingActorID\n- LocalTestingDistributedActorSystem\n- LocalTestingDistributedActorSystemError\n- MainActor\n- MemoryLayout\n- Mirror.DisplayStyle\n- MutableRawSpan\n- MutableSpan\n- Mutex\n- Never\n- ObjectIdentifier\n- ObservationRegistrar\n- Observations\n- Observations.Iteration\n- Optional\n- OutputRawSpan\n- OutputSpan\n- PartialRangeFrom\n- PartialRangeFrom.Iterator\n- PartialRangeThrough\n- PartialRangeUpTo\n- PrefixSequence\n- PrefixSequence.Iterator\n- Range\n- RangeSet\n- RangeSet.Ranges\n- RawSpan\n- Repeated\n- Result\n- ReversedCollection\n- ReversedCollection.Index\n- ReversedCollection.Iterator\n- SIMD16\n- SIMD2\n- SIMD3\n- SIMD32\n- SIMD4\n- SIMD64\n- SIMD8\n- SIMDMask\n- Set\n- Set.Index\n- Set.Iterator\n- Slice\n- Span\n- StaticBigInt\n- StaticString\n- StrideThrough\n- StrideThroughIterator\n- StrideTo\n- StrideToIterator\n- String\n- String.Comparator\n- String.Encoding\n- String.Index\n- String.Iterator\n- String.LocalizationValue\n- String.LocalizationValue.Placeholder\n- String.StandardComparator\n- String.UTF16View\n- String.UTF16View.Iterator\n- String.UTF8View\n- String.UnicodeScalarView\n- String.UnicodeScalarView.Iterator\n- Substring\n- Substring.UTF16View\n- Substring.UTF8View\n- Substring.UnicodeScalarView\n- SuspendingClock\n- SuspendingClock.Instant\n- SystemRandomNumberGenerator\n- Task\n- TaskLocal\n- TaskPriority\n- UInt\n- UInt.SIMD16Storage\n- UInt.SIMD2Storage\n- UInt.SIMD32Storage\n- UInt.SIMD4Storage\n- UInt.SIMD64Storage\n- UInt.SIMD8Storage\n- UInt.Words\n- UInt128\n- UInt128.Words\n- UInt16\n- UInt16.SIMD16Storage\n- UInt16.SIMD2Storage\n- UInt16.SIMD32Storage\n- UInt16.SIMD4Storage\n- UInt16.SIMD64Storage\n- UInt16.SIMD8Storage\n- UInt16.Words\n- UInt32\n- UInt32.SIMD16Storage\n- UInt32.SIMD2Storage\n- UInt32.SIMD32Storage\n- UInt32.SIMD4Storage\n- UInt32.SIMD64Storage\n- UInt32.SIMD8Storage\n- UInt32.Words\n- UInt64\n- UInt64.SIMD16Storage\n- UInt64.SIMD2Storage\n- UInt64.SIMD32Storage\n- UInt64.SIMD4Storage\n- UInt64.SIMD64Storage\n- UInt64.SIMD8Storage\n- UInt64.Words\n- UInt8\n- UInt8.SIMD16Storage\n- UInt8.SIMD2Storage\n- UInt8.SIMD32Storage\n- UInt8.SIMD4Storage\n- UInt8.SIMD64Storage\n- UInt8.SIMD8Storage\n- UInt8.Words\n- UnboundedRange_\n- UnfoldSequence\n- Unicode\n- Unicode.ASCII\n- Unicode.ASCII.Parser\n- Unicode.CanonicalCombiningClass\n- Unicode.GeneralCategory\n- Unicode.NumericType\n- Unicode.ParseResult\n- Unicode.Scalar\n- Unicode.Scalar.Properties\n- Unicode.Scalar.UTF16View\n- Unicode.Scalar.UTF8View\n- Unicode.UTF16\n- Unicode.UTF16.ForwardParser\n- Unicode.UTF16.ReverseParser\n- Unicode.UTF32\n- Unicode.UTF32.Parser\n- Unicode.UTF8\n- Unicode.UTF8.ForwardParser\n- Unicode.UTF8.ReverseParser\n- Unicode.UTF8.ValidationError\n- Unicode.UTF8.ValidationError.Kind\n- UnicodeDecodingResult\n- Unmanaged\n- UnownedJob\n- UnownedSerialExecutor\n- UnownedTaskExecutor\n- UnsafeContinuation\n- WordPair\n- Zip2Sequence\n- Zip2Sequence.Iterator\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Common protocol to which all actors conform.",
          "name" : "Actor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Actor"
        },
        {
          "description" : "Common marker protocol providing a shared “base” for both (local) `Actor` and (potentially remote) `DistributedActor` types.",
          "name" : "AnyActor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/AnyActor"
        },
        {
          "description" : "A singleton actor whose executor is equivalent to the main dispatch queue.",
          "name" : "MainActor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/MainActor"
        },
        {
          "description" : "A type that represents a globally-unique actor that can be used to isolate various declarations anywhere in the program.",
          "name" : "GlobalActor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/GlobalActor"
        },
        {
          "description" : "A type whose metatype can be shared across arbitrary concurrent contexts without introducing a risk of data races. When a generic type `T` conforms to `SendableMetatype`, its metatype `T.Type` conforms to `Sendable`.  All concrete types implicitly conform to the `SendableMetatype` protocol, so its primary purpose is in generic code to prohibit the use of isolated conformances along with the generic type.",
          "name" : "SendableMetatype",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/SendableMetatype"
        },
        {
          "description" : "",
          "name" : "ConcurrentValue",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ConcurrentValue"
        },
        {
          "description" : "A type whose values can safely be passed across concurrency domains by copying, but which disables some safety checking at the conformance site.",
          "name" : "UnsafeSendable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/UnsafeSendable"
        },
        {
          "description" : "",
          "name" : "UnsafeConcurrentValue",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/UnsafeConcurrentValue"
        },
        {
          "description" : "Produce a reference to the actor to which the enclosing code is isolated, or `nil` if the code is nonisolated.",
          "name" : "isolation()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/isolation()"
        },
        {
          "description" : "",
          "name" : "extractIsolation(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/extractIsolation(_:)"
        }
      ],
      "title" : "Actors"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "SendableMetatype"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "Sendable",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/sendable"
}