{
  "abstract" : "Executes a closure on the sequence’s contiguous storage.",
  "codeExamples" : [

  ],
  "contentHash" : "4e8a994c37f417341df035af58326c0f5ec1845d9d61c9ba045669112a97201f",
  "crawledAt" : "2025-12-01T21:48:33Z",
  "declaration" : {
    "code" : "func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R?",
    "language" : "swift"
  },
  "id" : "953230E6-7988-4578-8C4A-37D7F5CC9791",
  "kind" : "method",
  "module" : "Swift",
  "overview" : "## Return Value\n\nThe value returned from `body`, unless the sequence doesn’t support contiguous storage, in which case the method ignores `body` and returns `nil`.\n\n## Discussion\n\nThis method calls `body(buffer)`, where `buffer` is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call `body` — it immediately returns `nil`.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the `buffer` argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store `buffer` outside of this method.\n\nA `Collection` that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing `buffer` with a range formed from the distances to the subsequence’s `startIndex` and `endIndex`, respectively.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/array\/withcontiguousstorageifavailable(_:)\ncrawled: 2025-12-01T21:48:33Z\n---\n\n# withContiguousStorageIfAvailable(_:)\n\n**Instance Method**\n\nExecutes a closure on the sequence’s contiguous storage.\n\n## Declaration\n\n```swift\nfunc withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R?\n```\n\n## Parameters\n\n- **body**: A closure that receives an `UnsafeBufferPointer` to the sequence’s contiguous storage.\n\n## Return Value\n\nThe value returned from `body`, unless the sequence doesn’t support contiguous storage, in which case the method ignores `body` and returns `nil`.\n\n## Discussion\n\nThis method calls `body(buffer)`, where `buffer` is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call `body` — it immediately returns `nil`.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the `buffer` argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store `buffer` outside of this method.\n\nA `Collection` that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing `buffer` with a range formed from the distances to the subsequence’s `startIndex` and `endIndex`, respectively.\n\n## Accessing Underlying Storage\n\n- **withUnsafeBufferPointer(_:)**: Calls a closure with a pointer to the array’s contiguous storage.\n- **withUnsafeMutableBufferPointer(_:)**: Calls the given closure with a pointer to the array’s mutable contiguous storage.\n- **withUnsafeBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.\n- **withUnsafeMutableBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.\n- **withContiguousMutableStorageIfAvailable(_:)**: Executes a closure on the collection’s contiguous storage.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Calls a closure with a pointer to the array’s contiguous storage.",
          "name" : "withUnsafeBufferPointer(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeBufferPointer(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the array’s mutable contiguous storage.",
          "name" : "withUnsafeMutableBufferPointer(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeMutableBufferPointer(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.",
          "name" : "withUnsafeBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeBytes(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.",
          "name" : "withUnsafeMutableBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeMutableBytes(_:)"
        },
        {
          "description" : "Executes a closure on the collection’s contiguous storage.",
          "name" : "withContiguousMutableStorageIfAvailable(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withContiguousMutableStorageIfAvailable(_:)"
        }
      ],
      "title" : "Accessing Underlying Storage"
    }
  ],
  "source" : "appleJSON",
  "title" : "withContiguousStorageIfAvailable(_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/array\/withcontiguousstorageifavailable(_:)"
}