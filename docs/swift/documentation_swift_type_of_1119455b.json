{
  "abstract" : "Returns the dynamic type of a value.",
  "codeExamples" : [
    {
      "code" : "func printInfo(_ value: Any) {\n    let t = type(of: value)\n    print(\"'\\(value)' of type '\\(t)'\")\n}\n\nlet count: Int = 5\nprintInfo(count)\n\/\/ '5' of type 'Int'",
      "language" : "swift"
    },
    {
      "code" : "class Smiley {\n    class var text: String {\n        return \":)\"\n    }\n}\n\nclass EmojiSmiley: Smiley {\n     override class var text: String {\n        return \"ðŸ˜€\"\n    }\n}\n\nfunc printSmileyInfo(_ value: Smiley) {\n    let smileyType = type(of: value)\n    print(\"Smile!\", smileyType.text)\n}\n\nlet emojiSmiley = EmojiSmiley()\nprintSmileyInfo(emojiSmiley)\n\/\/ Smile! ðŸ˜€",
      "language" : "swift"
    },
    {
      "code" : "func printGenericInfo<T>(_ value: T) {\n    let t = type(of: value)\n    print(\"'\\(value)' of type '\\(t)'\")\n}\n\nprotocol P {}\nextension String: P {}\n\nlet stringAsP: P = \"Hello!\"\nprintGenericInfo(stringAsP)\n\/\/ 'Hello!' of type 'P'",
      "language" : "swift"
    },
    {
      "code" : "func betterPrintGenericInfo<T>(_ value: T) {\n    let t = type(of: value as Any)\n    print(\"'\\(value)' of type '\\(t)'\")\n}\n\nbetterPrintGenericInfo(stringAsP)\n\/\/ 'Hello!' of type 'String'",
      "language" : "swift"
    }
  ],
  "contentHash" : "c9e7b9948d8c5e11527249435b9e66a9dcecf44c9cec1b56c55aebac7ef7edd1",
  "crawledAt" : "2025-12-03T17:11:50Z",
  "declaration" : {
    "code" : "func type<T, Metatype>(of value: borrowing T) -> Metatype where T : ~Copyable, T : ~Escapable",
    "language" : "swift"
  },
  "id" : "E99E27B4-D237-45CF-91E6-87755D98411E",
  "kind" : "function",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nThe dynamic type, which is a metatype instance.\n\n## Discussion\n\nYou can use the `type(of:)` function to find the dynamic type of a value, particularly when the dynamic type is different from the static type. The *static type* of a value is the known, compile-time type of the value. The *dynamic type* of a value is the valueâ€™s actual type at run-time, which can be a subtype of its concrete type.\n\nIn the following code, the `count` variable has the same static and dynamic type: `Int`. When `count` is passed to the `printInfo(_:)` function, however, the `value` parameter has a static type of `Any` (the type declared for the parameter) and a dynamic type of `Int`.\n\nThe dynamic type returned from `type(of:)` is a *concrete metatype* (`T.Type`) for a class, structure, enumeration, or other nonprotocol type `T`, or an *existential metatype* (`P.Type`) for a protocol or protocol composition `P`. When the static type of the value passed to `type(of:)` is constrained to a class or protocol, you can use that metatype to access initializers or other static members of the class or protocol.\n\nFor example, the parameter passed as `value` to the `printSmileyInfo(_:)` function in the example below is an instance of the `Smiley` class or one of its subclasses. The function uses `type(of:)` to find the dynamic type of `value`, which itself is an instance of the `Smiley.Type` metatype.\n\nIn this example, accessing the `text` property of the `smileyType` metatype retrieves the overridden value from the `EmojiSmiley` subclass, instead of the `Smiley` classâ€™s original definition.\n\n# Finding the Dynamic Type in a Generic Context\n\nNormally, you donâ€™t need to be aware of the difference between concrete and existential metatypes, but calling `type(of:)` can yield unexpected results in a generic context with a type parameter bound to a protocol. In a case like this, where a generic parameter `T` is bound to a protocol `P`, the type parameter is not statically known to be a protocol type in the body of the generic function. As a result, `type(of:)` can only produce the concrete metatype `P.Protocol`.\n\nThe following example defines a `printGenericInfo(_:)` function that takes a generic parameter and declares the `String` typeâ€™s conformance to a new protocol `P`. When `printGenericInfo(_:)` is called with a string that has `P` as its static type, the call to `type(of:)` returns `P.self` instead of `String.self` (the dynamic type inside the parameter).\n\nThis unexpected result occurs because the call to `type(of: value)` inside `printGenericInfo(_:)` must return a metatype that is an instance of `T.Type`, but `String.self` (the expected dynamic type) is not an instance of `P.Type` (the concrete metatype of `value`). To get the dynamic type inside `value` in this generic context, cast the parameter to `Any` when calling `type(of:)`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/type(of:)\ncrawled: 2025-12-03T17:11:50Z\n---\n\n# type(of:)\n\n**Function**\n\nReturns the dynamic type of a value.\n\n## Declaration\n\n```swift\nfunc type<T, Metatype>(of value: borrowing T) -> Metatype where T : ~Copyable, T : ~Escapable\n```\n\n## Parameters\n\n- **value**: The value for which to find the dynamic type.\n\n## Return Value\n\nThe dynamic type, which is a metatype instance.\n\n## Discussion\n\nYou can use the `type(of:)` function to find the dynamic type of a value, particularly when the dynamic type is different from the static type. The *static type* of a value is the known, compile-time type of the value. The *dynamic type* of a value is the valueâ€™s actual type at run-time, which can be a subtype of its concrete type.\n\nIn the following code, the `count` variable has the same static and dynamic type: `Int`. When `count` is passed to the `printInfo(_:)` function, however, the `value` parameter has a static type of `Any` (the type declared for the parameter) and a dynamic type of `Int`.\n\n```swift\nfunc printInfo(_ value: Any) {\n    let t = type(of: value)\n    print(\"'\\(value)' of type '\\(t)'\")\n}\n\nlet count: Int = 5\nprintInfo(count)\n\/\/ '5' of type 'Int'\n```\n\nThe dynamic type returned from `type(of:)` is a *concrete metatype* (`T.Type`) for a class, structure, enumeration, or other nonprotocol type `T`, or an *existential metatype* (`P.Type`) for a protocol or protocol composition `P`. When the static type of the value passed to `type(of:)` is constrained to a class or protocol, you can use that metatype to access initializers or other static members of the class or protocol.\n\nFor example, the parameter passed as `value` to the `printSmileyInfo(_:)` function in the example below is an instance of the `Smiley` class or one of its subclasses. The function uses `type(of:)` to find the dynamic type of `value`, which itself is an instance of the `Smiley.Type` metatype.\n\n```swift\nclass Smiley {\n    class var text: String {\n        return \":)\"\n    }\n}\n\nclass EmojiSmiley: Smiley {\n     override class var text: String {\n        return \"ðŸ˜€\"\n    }\n}\n\nfunc printSmileyInfo(_ value: Smiley) {\n    let smileyType = type(of: value)\n    print(\"Smile!\", smileyType.text)\n}\n\nlet emojiSmiley = EmojiSmiley()\nprintSmileyInfo(emojiSmiley)\n\/\/ Smile! ðŸ˜€\n```\n\nIn this example, accessing the `text` property of the `smileyType` metatype retrieves the overridden value from the `EmojiSmiley` subclass, instead of the `Smiley` classâ€™s original definition.\n\n# Finding the Dynamic Type in a Generic Context\n\nNormally, you donâ€™t need to be aware of the difference between concrete and existential metatypes, but calling `type(of:)` can yield unexpected results in a generic context with a type parameter bound to a protocol. In a case like this, where a generic parameter `T` is bound to a protocol `P`, the type parameter is not statically known to be a protocol type in the body of the generic function. As a result, `type(of:)` can only produce the concrete metatype `P.Protocol`.\n\nThe following example defines a `printGenericInfo(_:)` function that takes a generic parameter and declares the `String` typeâ€™s conformance to a new protocol `P`. When `printGenericInfo(_:)` is called with a string that has `P` as its static type, the call to `type(of:)` returns `P.self` instead of `String.self` (the dynamic type inside the parameter).\n\n```swift\nfunc printGenericInfo<T>(_ value: T) {\n    let t = type(of: value)\n    print(\"'\\(value)' of type '\\(t)'\")\n}\n\nprotocol P {}\nextension String: P {}\n\nlet stringAsP: P = \"Hello!\"\nprintGenericInfo(stringAsP)\n\/\/ 'Hello!' of type 'P'\n```\n\nThis unexpected result occurs because the call to `type(of: value)` inside `printGenericInfo(_:)` must return a metatype that is an instance of `T.Type`, but `String.self` (the expected dynamic type) is not an instance of `P.Type` (the concrete metatype of `value`). To get the dynamic type inside `value` in this generic context, cast the parameter to `Any` when calling `type(of:)`.\n\n```swift\nfunc betterPrintGenericInfo<T>(_ value: T) {\n    let t = type(of: value as Any)\n    print(\"'\\(value)' of type '\\(t)'\")\n}\n\nbetterPrintGenericInfo(stringAsP)\n\/\/ 'Hello!' of type 'String'\n```\n\n## Querying Runtime Values\n\n- **Mirror**: A representation of the substructure and display style of an instance of any type.\n- **ObjectIdentifier**: A unique identifier for a class instance or metatype.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A representation of the substructure and display style of an instance of any type.",
          "name" : "Mirror",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Mirror"
        },
        {
          "description" : "A unique identifier for a class instance or metatype.",
          "name" : "ObjectIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ObjectIdentifier"
        }
      ],
      "title" : "Querying Runtime Values"
    }
  ],
  "source" : "appleJSON",
  "title" : "type(of:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/type(of:)"
}