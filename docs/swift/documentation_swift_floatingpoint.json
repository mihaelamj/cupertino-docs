{
  "abstract" : "A floating-point numeric type.",
  "codeExamples" : [
    {
      "code" : "let temperature = 33.2\nlet recordHigh = 37.5",
      "language" : "swift"
    },
    {
      "code" : "func hypotenuse<T: FloatingPoint>(_ a: T, _ b: T) -> T {\n    return (a * a + b * b).squareRoot()\n}\n\nlet (dx, dy) = (3.0, 4.0)\nlet distance = hypotenuse(dx, dy)\n\/\/ distance == 5.0",
      "language" : "swift"
    },
    {
      "code" : "x.significand * (F.radix ** x.exponent)",
      "language" : "swift"
    },
    {
      "code" : "let y = -8.5\n\/\/ y.sign == .minus\n\/\/ y.significand == 1.0625\n\/\/ y.exponent == 3\n\nlet magnitude = 1.0625 * Double(2 ** 3)\n\/\/ magnitude == 8.5",
      "language" : "swift"
    },
    {
      "code" : "let values: [Double] = [10.0, 25.0, -10.0, .infinity, -.infinity]\nprint(values.sorted())\n\/\/ Prints \"[-inf, -10.0, 10.0, 25.0, inf]\"",
      "language" : "swift"
    },
    {
      "code" : "let myNaN = Double.nan\nprint(myNaN > 0)\n\/\/ Prints \"false\"\nprint(myNaN < 0)\n\/\/ Prints \"false\"\nprint(myNaN == .nan)\n\/\/ Prints \"false\"",
      "language" : "swift"
    },
    {
      "code" : "print(myNaN.isNaN)\n\/\/ Prints \"true\"",
      "language" : "swift"
    },
    {
      "code" : "let temperatureData = [\"21.5\", \"19.25\", \"27\", \"no data\", \"28.25\", \"no data\", \"23\"]\nlet tempsCelsius = temperatureData.map { Double($0) ?? .nan }\nprint(tempsCelsius)\n\/\/ Prints \"[21.5, 19.25, 27, nan, 28.25, nan, 23.0]\"",
      "language" : "swift"
    },
    {
      "code" : "let tempsFahrenheit = tempsCelsius.map { $0 * 1.8 + 32 }\nprint(tempsFahrenheit)\n\/\/ Prints \"[70.7, 66.65, 80.6, nan, 82.85, nan, 73.4]\"",
      "language" : "swift"
    },
    {
      "code" : "let badAverage = tempsFahrenheit.reduce(0.0, +) \/ Double(tempsFahrenheit.count)\n\/\/ badAverage.isNaN == true",
      "language" : "swift"
    },
    {
      "code" : "let validTemps = tempsFahrenheit.filter { !$0.isNaN }\nlet average = validTemps.reduce(0.0, +) \/ Double(validTemps.count)",
      "language" : "swift"
    },
    {
      "code" : "print(\"Average: \\(average)°F in \\(validTemps.count) \" +\n      \"out of \\(tempsFahrenheit.count) observations.\")\n\/\/ Prints \"Average: 74.84°F in 5 out of 7 observations.\"",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "Double",
    "Float",
    "Float16",
    "Float80"
  ],
  "contentHash" : "93b4b3b33d46c8268f299c699e19edc8664a18abaf02b1307da68f6355310190",
  "crawledAt" : "2025-12-05T00:34:11Z",
  "declaration" : {
    "code" : "protocol FloatingPoint : Hashable, SignedNumeric, Strideable where Self == Self.Magnitude",
    "language" : "swift"
  },
  "id" : "B7102326-FE49-470F-99B2-1298714BB76D",
  "inheritedBy" : [
    "BinaryFloatingPoint"
  ],
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nFloating-point types are used to represent fractional numbers, like 5.5, 100.0, or 3.14159274. Each floating-point type has its own possible range and precision. The floating-point types in the standard library are `Float`, `Double`, and `Float80` where available.\n\nCreate new instances of floating-point types using integer or floating-point literals. For example:\n\nThe `FloatingPoint` protocol declares common arithmetic operations, so you can write functions and algorithms that work on any floating-point type. The following example declares a function that calculates the length of the hypotenuse of a right triangle given its two perpendicular sides. Because the `hypotenuse(_:_:)` function uses a generic parameter constrained to the `FloatingPoint` protocol, you can call it using any floating-point type.\n\nFloating-point values are represented as a *sign* and a *magnitude*, where the magnitude is calculated using the type’s *radix* and the instance’s *significand* and *exponent*. This magnitude calculation takes the following form for a floating-point value `x` of type `F`, where `**` is exponentiation:\n\nHere’s an example of the number -8.5 represented as an instance of the `Double` type, which defines a radix of 2.\n\nTypes that conform to the `FloatingPoint` protocol provide most basic (clause 5) operations of the [http:\/\/ieeexplore.ieee.org\/servlet\/opac?punumber=4610933]. The base, precision, and exponent range are not fixed in any way by this protocol, but it enforces the basic requirements of any IEEE 754 floating-point type.\n\n# Additional Considerations\n\nIn addition to representing specific numbers, floating-point types also have special values for working with overflow and nonnumeric results of calculation.\n\n## Infinity\n\nAny value whose magnitude is so great that it would round to a value outside the range of representable numbers is rounded to *infinity*. For a type `F`, positive and negative infinity are represented as `F.infinity` and `-F.infinity`, respectively. Positive infinity compares greater than every finite value and negative infinity, while negative infinity compares less than every finite value and positive infinity. Infinite values with the same sign are equal to each other.\n\nOperations with infinite values follow real arithmetic as much as possible: Adding or subtracting a finite value, or multiplying or dividing infinity by a nonzero finite value, results in infinity.\n\n## NaN (“not a number”)\n\nFloating-point types represent values that are neither finite numbers nor infinity as NaN, an abbreviation for “not a number.” Comparing a NaN with any value, including another NaN, results in `false`.\n\nBecause testing whether one NaN is equal to another NaN results in `false`, use the `isNaN` property to test whether a value is NaN.\n\nNaN propagates through many arithmetic operations. When you are operating on many values, this behavior is valuable because operations on NaN simply forward the value and don’t cause runtime errors. The following example shows how NaN values operate in different contexts.\n\nImagine you have a set of temperature data for which you need to report some general statistics: the total number of observations, the number of valid observations, and the average temperature. First, a set of observations in Celsius is parsed from strings to `Double` values:\n\nNote that some elements in the `temperatureData ` array are not valid numbers. When these invalid strings are parsed by the `Double` failable initializer, the example uses the nil-coalescing operator (`??`) to provide NaN as a fallback value.\n\nNext, the observations in Celsius are converted to Fahrenheit:\n\nThe NaN values in the `tempsCelsius` array are propagated through the conversion and remain NaN in `tempsFahrenheit`.\n\nBecause calculating the average of the observations involves combining every value of the `tempsFahrenheit` array, any NaN values cause the result to also be NaN, as seen in this example:\n\nInstead, when you need an operation to have a specific numeric result, filter out any NaN values using the `isNaN` property.\n\nFinally, report the average temperature and observation counts:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/floatingpoint\ncrawled: 2025-12-05T00:34:11Z\n---\n\n# FloatingPoint\n\n**Protocol**\n\nA floating-point numeric type.\n\n## Declaration\n\n```swift\nprotocol FloatingPoint : Hashable, SignedNumeric, Strideable where Self == Self.Magnitude\n```\n\n## Overview\n\nFloating-point types are used to represent fractional numbers, like 5.5, 100.0, or 3.14159274. Each floating-point type has its own possible range and precision. The floating-point types in the standard library are `Float`, `Double`, and `Float80` where available.\n\nCreate new instances of floating-point types using integer or floating-point literals. For example:\n\n```swift\nlet temperature = 33.2\nlet recordHigh = 37.5\n```\n\nThe `FloatingPoint` protocol declares common arithmetic operations, so you can write functions and algorithms that work on any floating-point type. The following example declares a function that calculates the length of the hypotenuse of a right triangle given its two perpendicular sides. Because the `hypotenuse(_:_:)` function uses a generic parameter constrained to the `FloatingPoint` protocol, you can call it using any floating-point type.\n\n```swift\nfunc hypotenuse<T: FloatingPoint>(_ a: T, _ b: T) -> T {\n    return (a * a + b * b).squareRoot()\n}\n\nlet (dx, dy) = (3.0, 4.0)\nlet distance = hypotenuse(dx, dy)\n\/\/ distance == 5.0\n```\n\nFloating-point values are represented as a *sign* and a *magnitude*, where the magnitude is calculated using the type’s *radix* and the instance’s *significand* and *exponent*. This magnitude calculation takes the following form for a floating-point value `x` of type `F`, where `**` is exponentiation:\n\n```swift\nx.significand * (F.radix ** x.exponent)\n```\n\nHere’s an example of the number -8.5 represented as an instance of the `Double` type, which defines a radix of 2.\n\n```swift\nlet y = -8.5\n\/\/ y.sign == .minus\n\/\/ y.significand == 1.0625\n\/\/ y.exponent == 3\n\nlet magnitude = 1.0625 * Double(2 ** 3)\n\/\/ magnitude == 8.5\n```\n\nTypes that conform to the `FloatingPoint` protocol provide most basic (clause 5) operations of the [http:\/\/ieeexplore.ieee.org\/servlet\/opac?punumber=4610933]. The base, precision, and exponent range are not fixed in any way by this protocol, but it enforces the basic requirements of any IEEE 754 floating-point type.\n\n# Additional Considerations\n\nIn addition to representing specific numbers, floating-point types also have special values for working with overflow and nonnumeric results of calculation.\n\n## Infinity\n\nAny value whose magnitude is so great that it would round to a value outside the range of representable numbers is rounded to *infinity*. For a type `F`, positive and negative infinity are represented as `F.infinity` and `-F.infinity`, respectively. Positive infinity compares greater than every finite value and negative infinity, while negative infinity compares less than every finite value and positive infinity. Infinite values with the same sign are equal to each other.\n\n```swift\nlet values: [Double] = [10.0, 25.0, -10.0, .infinity, -.infinity]\nprint(values.sorted())\n\/\/ Prints \"[-inf, -10.0, 10.0, 25.0, inf]\"\n```\n\nOperations with infinite values follow real arithmetic as much as possible: Adding or subtracting a finite value, or multiplying or dividing infinity by a nonzero finite value, results in infinity.\n\n## NaN (“not a number”)\n\nFloating-point types represent values that are neither finite numbers nor infinity as NaN, an abbreviation for “not a number.” Comparing a NaN with any value, including another NaN, results in `false`.\n\n```swift\nlet myNaN = Double.nan\nprint(myNaN > 0)\n\/\/ Prints \"false\"\nprint(myNaN < 0)\n\/\/ Prints \"false\"\nprint(myNaN == .nan)\n\/\/ Prints \"false\"\n```\n\nBecause testing whether one NaN is equal to another NaN results in `false`, use the `isNaN` property to test whether a value is NaN.\n\n```swift\nprint(myNaN.isNaN)\n\/\/ Prints \"true\"\n```\n\nNaN propagates through many arithmetic operations. When you are operating on many values, this behavior is valuable because operations on NaN simply forward the value and don’t cause runtime errors. The following example shows how NaN values operate in different contexts.\n\nImagine you have a set of temperature data for which you need to report some general statistics: the total number of observations, the number of valid observations, and the average temperature. First, a set of observations in Celsius is parsed from strings to `Double` values:\n\n```swift\nlet temperatureData = [\"21.5\", \"19.25\", \"27\", \"no data\", \"28.25\", \"no data\", \"23\"]\nlet tempsCelsius = temperatureData.map { Double($0) ?? .nan }\nprint(tempsCelsius)\n\/\/ Prints \"[21.5, 19.25, 27, nan, 28.25, nan, 23.0]\"\n```\n\nNote that some elements in the `temperatureData ` array are not valid numbers. When these invalid strings are parsed by the `Double` failable initializer, the example uses the nil-coalescing operator (`??`) to provide NaN as a fallback value.\n\nNext, the observations in Celsius are converted to Fahrenheit:\n\n```swift\nlet tempsFahrenheit = tempsCelsius.map { $0 * 1.8 + 32 }\nprint(tempsFahrenheit)\n\/\/ Prints \"[70.7, 66.65, 80.6, nan, 82.85, nan, 73.4]\"\n```\n\nThe NaN values in the `tempsCelsius` array are propagated through the conversion and remain NaN in `tempsFahrenheit`.\n\nBecause calculating the average of the observations involves combining every value of the `tempsFahrenheit` array, any NaN values cause the result to also be NaN, as seen in this example:\n\n```swift\nlet badAverage = tempsFahrenheit.reduce(0.0, +) \/ Double(tempsFahrenheit.count)\n\/\/ badAverage.isNaN == true\n```\n\nInstead, when you need an operation to have a specific numeric result, filter out any NaN values using the `isNaN` property.\n\n```swift\nlet validTemps = tempsFahrenheit.filter { !$0.isNaN }\nlet average = validTemps.reduce(0.0, +) \/ Double(validTemps.count)\n```\n\nFinally, report the average temperature and observation counts:\n\n```swift\nprint(\"Average: \\(average)°F in \\(validTemps.count) \" +\n      \"out of \\(tempsFahrenheit.count) observations.\")\n\/\/ Prints \"Average: 74.84°F in 5 out of 7 observations.\"\n```\n\n## Operators\n\n- ***(_:_:)**: Multiplies two values and produces their product, rounding to a representable value.\n- ***=(_:_:)**: Multiplies two values and stores the result in the left-hand-side variable, rounding to a representable value.\n- **+(_:_:)**: Adds two values and produces their sum, rounded to a representable value.\n- **+=(_:_:)**: Adds two values and stores the result in the left-hand-side variable, rounded to a representable value.\n- **-(_:)**: Calculates the additive inverse of a value.\n- **-(_:_:)**: Subtracts one value from another and produces their difference, rounded to a representable value.\n- **-=(_:_:)**: Subtracts the second value from the first and stores the difference in the left-hand-side variable, rounding to a representable value.\n- **\/(_:_:)**: Returns the quotient of dividing the first value by the second, rounded to a representable value.\n- **\/=(_:_:)**: Divides the first value by the second and stores the quotient in the left-hand-side variable, rounding to a representable value.\n\n## Associated Types\n\n- **Exponent**: A type that can represent any written exponent.\n\n## Initializers\n\n- **init(_:)**: Creates a new value, rounded to the closest possible representation.\n- **init(_:)**: Creates a new value, rounded to the closest possible representation.\n- **init(exactly:)**: Creates a new value, if the given integer can be represented exactly.\n- **init(sign:exponent:significand:)**: Creates a new value from the given sign, exponent, and significand.\n- **init(signOf:magnitudeOf:)**: Creates a new floating-point value using the sign of one value and the magnitude of another.\n\n## Instance Properties\n\n- **exponent**: The exponent of the floating-point value.\n- **floatingPointClass**: The classification of this value.\n- **isCanonical**: A Boolean value indicating whether the instance’s representation is in its canonical form.\n- **isFinite**: A Boolean value indicating whether this instance is finite.\n- **isInfinite**: A Boolean value indicating whether the instance is infinite.\n- **isNaN**: A Boolean value indicating whether the instance is NaN (“not a number”).\n- **isNormal**: A Boolean value indicating whether this instance is normal.\n- **isSignalingNaN**: A Boolean value indicating whether the instance is a signaling NaN.\n- **isSubnormal**: A Boolean value indicating whether the instance is subnormal.\n- **isZero**: A Boolean value indicating whether the instance is equal to zero.\n- **nextDown**: The greatest representable value that compares less than this value.\n- **nextUp**: The least representable value that compares greater than this value.\n- **sign**: The sign of the floating-point value.\n- **significand**: The significand of the floating-point value.\n- **ulp**: The unit in the last place of this value.\n\n## Instance Methods\n\n- **addProduct(_:_:)**: Adds the product of the two given values to this value in place, computed without intermediate rounding.\n- **addingProduct(_:_:)**: Returns the result of adding the product of the two given values to this value, computed without intermediate rounding.\n- **formRemainder(dividingBy:)**: Replaces this value with the remainder of itself divided by the given value.\n- **formSquareRoot()**: Replaces this value with its square root, rounded to a representable value.\n- **formTruncatingRemainder(dividingBy:)**: Replaces this value with the remainder of itself divided by the given value using truncating division.\n- **isEqual(to:)**: Returns a Boolean value indicating whether this instance is equal to the given value.\n- **isLess(than:)**: Returns a Boolean value indicating whether this instance is less than the given value.\n- **isLessThanOrEqualTo(_:)**: Returns a Boolean value indicating whether this instance is less than or equal to the given value.\n- **isTotallyOrdered(belowOrEqualTo:)**: Returns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\n- **negate()**: Replaces this value with its additive inverse.\n- **remainder(dividingBy:)**: Returns the remainder of this value divided by the given value.\n- **round()**\n- **round(_:)**: Rounds the value to an integral value using the specified rounding rule.\n- **rounded()**\n- **rounded(_:)**: Returns this value rounded to an integral value using the specified rounding rule.\n- **squareRoot()**: Returns the square root of the value, rounded to a representable value.\n- **truncatingRemainder(dividingBy:)**: Returns the remainder of this value divided by the given value using truncating division.\n\n## Type Properties\n\n- **greatestFiniteMagnitude**: The greatest finite number representable by this type.\n- **infinity**: Positive infinity.\n- **leastNonzeroMagnitude**: The least positive number.\n- **leastNormalMagnitude**: The least positive normal number.\n- **nan**: A quiet NaN (“not a number”).\n- **pi**: The mathematical constant pi (π), approximately equal to 3.14159.\n- **radix**: The radix, or base of exponentiation, for a floating-point type.\n- **signalingNaN**: A signaling NaN (“not a number”).\n- **ulpOfOne**: The unit in the last place of 1.0.\n\n## Type Methods\n\n- **maximum(_:_:)**: Returns the greater of the two given values.\n- **maximumMagnitude(_:_:)**: Returns the value with greater magnitude.\n- **minimum(_:_:)**: Returns the lesser of the two given values.\n- **minimumMagnitude(_:_:)**: Returns the value with lesser magnitude.\n\n## Floating Point\n\n- **BinaryFloatingPoint**: A radix-2 (binary) floating-point type.\n\n## Inherits From\n\n- AdditiveArithmetic\n- Comparable\n- Equatable\n- ExpressibleByIntegerLiteral\n- Hashable\n- Numeric\n- SignedNumeric\n- Strideable\n\n## Inherited By\n\n- BinaryFloatingPoint\n\n## Conforming Types\n\n- Double\n- Float\n- Float16\n- Float80\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Multiplies two values and produces their product, rounding to a representable value.",
          "name" : "*(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/*(_:_:)"
        },
        {
          "description" : "Multiplies two values and stores the result in the left-hand-side variable, rounding to a representable value.",
          "name" : "*=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/*=(_:_:)"
        },
        {
          "description" : "Adds two values and produces their sum, rounded to a representable value.",
          "name" : "+(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/+(_:_:)"
        },
        {
          "description" : "Adds two values and stores the result in the left-hand-side variable, rounded to a representable value.",
          "name" : "+=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/+=(_:_:)"
        },
        {
          "description" : "Calculates the additive inverse of a value.",
          "name" : "-(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/-(_:)"
        },
        {
          "description" : "Subtracts one value from another and produces their difference, rounded to a representable value.",
          "name" : "-(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/-(_:_:)"
        },
        {
          "description" : "Subtracts the second value from the first and stores the difference in the left-hand-side variable, rounding to a representable value.",
          "name" : "-=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/-=(_:_:)"
        },
        {
          "description" : "Returns the quotient of dividing the first value by the second, rounded to a representable value.",
          "name" : "\/(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/_(_:_:)"
        },
        {
          "description" : "Divides the first value by the second and stores the quotient in the left-hand-side variable, rounding to a representable value.",
          "name" : "\/=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/_=(_:_:)"
        }
      ],
      "title" : "Operators"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that can represent any written exponent.",
          "name" : "Exponent",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/Exponent-swift.associatedtype"
        }
      ],
      "title" : "Associated Types"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a new value, rounded to the closest possible representation.",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/init(_:)-2f8bx"
        },
        {
          "description" : "Creates a new value, rounded to the closest possible representation.",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/init(_:)-2xwlo"
        },
        {
          "description" : "Creates a new value, if the given integer can be represented exactly.",
          "name" : "init(exactly:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/init(exactly:)"
        },
        {
          "description" : "Creates a new value from the given sign, exponent, and significand.",
          "name" : "init(sign:exponent:significand:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/init(sign:exponent:significand:)"
        },
        {
          "description" : "Creates a new floating-point value using the sign of one value and the magnitude of another.",
          "name" : "init(signOf:magnitudeOf:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/init(signOf:magnitudeOf:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The exponent of the floating-point value.",
          "name" : "exponent",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/exponent-swift.property"
        },
        {
          "description" : "The classification of this value.",
          "name" : "floatingPointClass",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/floatingPointClass"
        },
        {
          "description" : "A Boolean value indicating whether the instance’s representation is in its canonical form.",
          "name" : "isCanonical",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isCanonical"
        },
        {
          "description" : "A Boolean value indicating whether this instance is finite.",
          "name" : "isFinite",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isFinite"
        },
        {
          "description" : "A Boolean value indicating whether the instance is infinite.",
          "name" : "isInfinite",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isInfinite"
        },
        {
          "description" : "A Boolean value indicating whether the instance is NaN (“not a number”).",
          "name" : "isNaN",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isNaN"
        },
        {
          "description" : "A Boolean value indicating whether this instance is normal.",
          "name" : "isNormal",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isNormal"
        },
        {
          "description" : "A Boolean value indicating whether the instance is a signaling NaN.",
          "name" : "isSignalingNaN",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isSignalingNaN"
        },
        {
          "description" : "A Boolean value indicating whether the instance is subnormal.",
          "name" : "isSubnormal",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isSubnormal"
        },
        {
          "description" : "A Boolean value indicating whether the instance is equal to zero.",
          "name" : "isZero",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isZero"
        },
        {
          "description" : "The greatest representable value that compares less than this value.",
          "name" : "nextDown",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/nextDown"
        },
        {
          "description" : "The least representable value that compares greater than this value.",
          "name" : "nextUp",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/nextUp"
        },
        {
          "description" : "The sign of the floating-point value.",
          "name" : "sign",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/sign"
        },
        {
          "description" : "The significand of the floating-point value.",
          "name" : "significand",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/significand"
        },
        {
          "description" : "The unit in the last place of this value.",
          "name" : "ulp",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/ulp"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Adds the product of the two given values to this value in place, computed without intermediate rounding.",
          "name" : "addProduct(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/addProduct(_:_:)"
        },
        {
          "description" : "Returns the result of adding the product of the two given values to this value, computed without intermediate rounding.",
          "name" : "addingProduct(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/addingProduct(_:_:)"
        },
        {
          "description" : "Replaces this value with the remainder of itself divided by the given value.",
          "name" : "formRemainder(dividingBy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/formRemainder(dividingBy:)"
        },
        {
          "description" : "Replaces this value with its square root, rounded to a representable value.",
          "name" : "formSquareRoot()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/formSquareRoot()"
        },
        {
          "description" : "Replaces this value with the remainder of itself divided by the given value using truncating division.",
          "name" : "formTruncatingRemainder(dividingBy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/formTruncatingRemainder(dividingBy:)"
        },
        {
          "description" : "Returns a Boolean value indicating whether this instance is equal to the given value.",
          "name" : "isEqual(to:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isEqual(to:)"
        },
        {
          "description" : "Returns a Boolean value indicating whether this instance is less than the given value.",
          "name" : "isLess(than:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isLess(than:)"
        },
        {
          "description" : "Returns a Boolean value indicating whether this instance is less than or equal to the given value.",
          "name" : "isLessThanOrEqualTo(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isLessThanOrEqualTo(_:)"
        },
        {
          "description" : "Returns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.",
          "name" : "isTotallyOrdered(belowOrEqualTo:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/isTotallyOrdered(belowOrEqualTo:)"
        },
        {
          "description" : "Replaces this value with its additive inverse.",
          "name" : "negate()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/negate()"
        },
        {
          "description" : "Returns the remainder of this value divided by the given value.",
          "name" : "remainder(dividingBy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/remainder(dividingBy:)"
        },
        {
          "description" : "",
          "name" : "round()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/round()"
        },
        {
          "description" : "Rounds the value to an integral value using the specified rounding rule.",
          "name" : "round(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/round(_:)"
        },
        {
          "description" : "",
          "name" : "rounded()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/rounded()"
        },
        {
          "description" : "Returns this value rounded to an integral value using the specified rounding rule.",
          "name" : "rounded(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/rounded(_:)"
        },
        {
          "description" : "Returns the square root of the value, rounded to a representable value.",
          "name" : "squareRoot()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/squareRoot()"
        },
        {
          "description" : "Returns the remainder of this value divided by the given value using truncating division.",
          "name" : "truncatingRemainder(dividingBy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/truncatingRemainder(dividingBy:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The greatest finite number representable by this type.",
          "name" : "greatestFiniteMagnitude",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/greatestFiniteMagnitude"
        },
        {
          "description" : "Positive infinity.",
          "name" : "infinity",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/infinity"
        },
        {
          "description" : "The least positive number.",
          "name" : "leastNonzeroMagnitude",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/leastNonzeroMagnitude"
        },
        {
          "description" : "The least positive normal number.",
          "name" : "leastNormalMagnitude",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/leastNormalMagnitude"
        },
        {
          "description" : "A quiet NaN (“not a number”).",
          "name" : "nan",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/nan"
        },
        {
          "description" : "The mathematical constant pi (π), approximately equal to 3.14159.",
          "name" : "pi",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/pi"
        },
        {
          "description" : "The radix, or base of exponentiation, for a floating-point type.",
          "name" : "radix",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/radix"
        },
        {
          "description" : "A signaling NaN (“not a number”).",
          "name" : "signalingNaN",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/signalingNaN"
        },
        {
          "description" : "The unit in the last place of 1.0.",
          "name" : "ulpOfOne",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/ulpOfOne"
        }
      ],
      "title" : "Type Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns the greater of the two given values.",
          "name" : "maximum(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/maximum(_:_:)"
        },
        {
          "description" : "Returns the value with greater magnitude.",
          "name" : "maximumMagnitude(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/maximumMagnitude(_:_:)"
        },
        {
          "description" : "Returns the lesser of the two given values.",
          "name" : "minimum(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/minimum(_:_:)"
        },
        {
          "description" : "Returns the value with lesser magnitude.",
          "name" : "minimumMagnitude(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FloatingPoint\/minimumMagnitude(_:_:)"
        }
      ],
      "title" : "Type Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A radix-2 (binary) floating-point type.",
          "name" : "BinaryFloatingPoint",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryFloatingPoint"
        }
      ],
      "title" : "Floating Point"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "AdditiveArithmetic"
        },
        {
          "name" : "Comparable"
        },
        {
          "name" : "Equatable"
        },
        {
          "name" : "ExpressibleByIntegerLiteral"
        },
        {
          "name" : "Hashable"
        },
        {
          "name" : "Numeric"
        },
        {
          "name" : "SignedNumeric"
        },
        {
          "name" : "Strideable"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "FloatingPoint",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/floatingpoint"
}