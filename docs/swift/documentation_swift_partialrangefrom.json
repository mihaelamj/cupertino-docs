{
  "abstract" : "A partial interval extending upward from a lower bound.",
  "codeExamples" : [
    {
      "code" : "let atLeastFive = 5...",
      "language" : "swift"
    },
    {
      "code" : "atLeastFive.contains(4)\n\/\/ false\natLeastFive.contains(5)\n\/\/ true\natLeastFive.contains(6)\n\/\/ true",
      "language" : "swift"
    },
    {
      "code" : "let numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n\/\/ Prints \"[40, 50, 60, 70]\"",
      "language" : "swift"
    },
    {
      "code" : "func isTheMagicNumber(_ x: Int) -> Bool {\n    return x == 3\n}\n\nfor x in 1... {\n    if isTheMagicNumber(x) {\n        print(\"\\(x) is the magic number!\")\n        break\n    } else {\n        print(\"\\(x) wasn't it...\")\n    }\n}\n\/\/ \"1 wasn't it...\"\n\/\/ \"2 wasn't it...\"\n\/\/ \"3 is the magic number!\"",
      "language" : "swift"
    },
    {
      "code" : "let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nlet asciiTable = zip(65..., alphabet)\nfor (code, letter) in asciiTable {\n    print(code, letter)\n}\n\/\/ \"65 A\"\n\/\/ \"66 B\"\n\/\/ \"67 C\"\n\/\/ ...\n\/\/ \"89 Y\"\n\/\/ \"90 Z\"",
      "language" : "swift"
    }
  ],
  "conformsTo" : [
    "BNNSGraph.Builder.SliceIndex",
    "Copyable",
    "CustomTestStringConvertible",
    "Decodable",
    "Encodable",
    "MLShapedArrayRangeExpression",
    "MLTensorRangeExpression",
    "RangeExpression",
    "Sendable",
    "SendableMetatype",
    "Sequence"
  ],
  "contentHash" : "e3ddc71ea48a842a9a83ce07f05784e4ad3aa2d4f07e18378387b1a3b2408cf3",
  "crawledAt" : "2025-12-05T22:18:42Z",
  "declaration" : {
    "code" : "@frozen struct PartialRangeFrom<Bound> where Bound : Comparable",
    "language" : "swift"
  },
  "id" : "094EC3BF-8470-4DB5-988E-3EA081BC2960",
  "kind" : "struct",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nYou create `PartialRangeFrom` instances by using the postfix range operator (postfix `...`).\n\nYou can use a partial range to quickly check if a value is contained in a particular range of values. For example:\n\nYou can use a partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\n## Using a Partial Range as a Sequence\n\nWhen a partial range uses integers as its lower and upper bounds, or any other type that conforms to the `Strideable` protocol with an integer stride, you can use that range in a `for`-`in` loop or with any sequence method that doesn’t require that the sequence is finite. The elements of a partial range are the consecutive values from its lower bound continuing upward indefinitely.\n\nBecause a `PartialRangeFrom` sequence counts upward indefinitely, do not use one with methods that read the entire sequence before returning, such as `map(_:)`, `filter(_:)`, or `suffix(_:)`. It is safe to use operations that put an upper limit on the number of elements they access, such as `prefix(_:)` or `dropFirst(_:)`, and operations that you can guarantee will terminate, such as passing a closure you know will eventually return `true` to `first(where:)`.\n\nIn the following example, the `asciiTable` sequence is made by zipping together the characters in the `alphabet` string with a partial range starting at 65, the ASCII value of the capital letter A. Iterating over two zipped sequences continues only as long as the shorter of the two sequences, so the iteration stops at the end of `alphabet`.\n\nThe behavior of incrementing indefinitely is determined by the type of `Bound`. For example, iterating over an instance of `PartialRangeFrom<Int>` traps when the sequence’s next value would be above `Int.max`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/partialrangefrom\ncrawled: 2025-12-05T22:18:42Z\n---\n\n# PartialRangeFrom\n\n**Structure**\n\nA partial interval extending upward from a lower bound.\n\n## Declaration\n\n```swift\n@frozen struct PartialRangeFrom<Bound> where Bound : Comparable\n```\n\n## Overview\n\nYou create `PartialRangeFrom` instances by using the postfix range operator (postfix `...`).\n\n```swift\nlet atLeastFive = 5...\n```\n\nYou can use a partial range to quickly check if a value is contained in a particular range of values. For example:\n\n```swift\natLeastFive.contains(4)\n\/\/ false\natLeastFive.contains(5)\n\/\/ true\natLeastFive.contains(6)\n\/\/ true\n```\n\nYou can use a partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\n```swift\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n\/\/ Prints \"[40, 50, 60, 70]\"\n```\n\n## Using a Partial Range as a Sequence\n\nWhen a partial range uses integers as its lower and upper bounds, or any other type that conforms to the `Strideable` protocol with an integer stride, you can use that range in a `for`-`in` loop or with any sequence method that doesn’t require that the sequence is finite. The elements of a partial range are the consecutive values from its lower bound continuing upward indefinitely.\n\n```swift\nfunc isTheMagicNumber(_ x: Int) -> Bool {\n    return x == 3\n}\n\nfor x in 1... {\n    if isTheMagicNumber(x) {\n        print(\"\\(x) is the magic number!\")\n        break\n    } else {\n        print(\"\\(x) wasn't it...\")\n    }\n}\n\/\/ \"1 wasn't it...\"\n\/\/ \"2 wasn't it...\"\n\/\/ \"3 is the magic number!\"\n```\n\nBecause a `PartialRangeFrom` sequence counts upward indefinitely, do not use one with methods that read the entire sequence before returning, such as `map(_:)`, `filter(_:)`, or `suffix(_:)`. It is safe to use operations that put an upper limit on the number of elements they access, such as `prefix(_:)` or `dropFirst(_:)`, and operations that you can guarantee will terminate, such as passing a closure you know will eventually return `true` to `first(where:)`.\n\nIn the following example, the `asciiTable` sequence is made by zipping together the characters in the `alphabet` string with a partial range starting at 65, the ASCII value of the capital letter A. Iterating over two zipped sequences continues only as long as the shorter of the two sequences, so the iteration stops at the end of `alphabet`.\n\n```swift\nlet alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nlet asciiTable = zip(65..., alphabet)\nfor (code, letter) in asciiTable {\n    print(code, letter)\n}\n\/\/ \"65 A\"\n\/\/ \"66 B\"\n\/\/ \"67 C\"\n\/\/ ...\n\/\/ \"89 Y\"\n\/\/ \"90 Z\"\n```\n\nThe behavior of incrementing indefinitely is determined by the type of `Bound`. For example, iterating over an instance of `PartialRangeFrom<Int>` traps when the sequence’s next value would be above `Int.max`.\n\n## Initializers\n\n- **init(_:)**\n\n## Instance Properties\n\n- **lowerBound**\n\n## Default Implementations\n\n- **Decodable Implementations**\n- **Encodable Implementations**\n- **RangeExpression Implementations**\n- **Sequence Implementations**\n\n## Range Expressions\n\n- **PartialRangeUpTo**: A partial half-open interval up to, but not including, an upper bound.\n- **PartialRangeThrough**: A partial interval up to, and including, an upper bound.\n- **RangeExpression**: A type that can be used to slice a collection.\n- **UnboundedRange_**: A range expression that represents the entire range of a collection.\n\n## Conforms To\n\n- BNNSGraph.Builder.SliceIndex\n- Copyable\n- CustomTestStringConvertible\n- Decodable\n- Encodable\n- MLShapedArrayRangeExpression\n- MLTensorRangeExpression\n- RangeExpression\n- Sendable\n- SendableMetatype\n- Sequence\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeFrom\/init(_:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "lowerBound",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeFrom\/lowerBound"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "Decodable Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeFrom\/Decodable-Implementations"
        },
        {
          "description" : "",
          "name" : "Encodable Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeFrom\/Encodable-Implementations"
        },
        {
          "description" : "",
          "name" : "RangeExpression Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeFrom\/RangeExpression-Implementations"
        },
        {
          "description" : "",
          "name" : "Sequence Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeFrom\/Sequence-Implementations"
        }
      ],
      "title" : "Default Implementations"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A partial half-open interval up to, but not including, an upper bound.",
          "name" : "PartialRangeUpTo",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeUpTo"
        },
        {
          "description" : "A partial interval up to, and including, an upper bound.",
          "name" : "PartialRangeThrough",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PartialRangeThrough"
        },
        {
          "description" : "A type that can be used to slice a collection.",
          "name" : "RangeExpression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RangeExpression"
        },
        {
          "description" : "A range expression that represents the entire range of a collection.",
          "name" : "UnboundedRange_",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/UnboundedRange_"
        }
      ],
      "title" : "Range Expressions"
    }
  ],
  "source" : "appleJSON",
  "title" : "PartialRangeFrom",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/partialrangefrom"
}