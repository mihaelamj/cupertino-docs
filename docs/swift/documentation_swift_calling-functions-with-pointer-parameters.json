{
  "abstract" : "Use implicit pointer casting or bridging when calling functions that takes pointers as parameters.",
  "codeExamples" : [
    {
      "code" : "func takesAPointer(_ p: UnsafePointer<Float>) {\n    \/\/ ...\n}\n\nvar x: Float = 0.0\ntakesAPointer(&x)\ntakesAPointer([1.0, 2.0, 3.0])",
      "language" : "swift"
    },
    {
      "code" : "func takesARawPointer(_ p: UnsafeRawPointer?)  {\n    \/\/ ...\n}\n\nvar x: Float = 0.0, y: Int = 0\ntakesARawPointer(&x)\ntakesARawPointer(&y)\ntakesARawPointer([1.0, 2.0, 3.0] as [Float])\nlet intArray = [1, 2, 3]\ntakesARawPointer(intArray)\ntakesARawPointer(\"How are you today?\")",
      "language" : "swift"
    },
    {
      "code" : "func takesAMutablePointer(_ p: UnsafeMutablePointer<Float>) {\n    \/\/ ...\n}\n\nvar x: Float = 0.0\nvar a: [Float] = [1.0, 2.0, 3.0]\ntakesAMutablePointer(&x)\ntakesAMutablePointer(&a)",
      "language" : "swift"
    },
    {
      "code" : "func takesAMutableRawPointer(_ p: UnsafeMutableRawPointer?)  {\n    \/\/ ...\n}\n\nvar x: Float = 0.0, y: Int = 0\nvar a: [Float] = [1.0, 2.0, 3.0], b: [Int] = [1, 2, 3]\ntakesAMutableRawPointer(&x)\ntakesAMutableRawPointer(&y)\ntakesAMutableRawPointer(&a)\ntakesAMutableRawPointer(&b)",
      "language" : "swift"
    },
    {
      "code" : "func customCopyDescription(_ p: UnsafeRawPointer?) -> Unmanaged<CFString>? {\n    \/\/ return an Unmanaged<CFString>? value\n}\n\nvar callbacks = CFArrayCallBacks(\n    version: 0,\n    retain: nil,\n    release: nil,\n    copyDescription: customCopyDescription,\n    equal: { (p1, p2) -> DarwinBoolean in\n        \/\/ return Bool value\n    }\n)\nvar mutableArray = CFArrayCreateMutable(nil, 0, &callbacks)",
      "language" : "swift"
    }
  ],
  "contentHash" : "275ecfab1b32b5ac78eadc63e2820e53a63f255f8f902bdaacf3e8596b927327",
  "crawledAt" : "2025-12-03T16:53:22Z",
  "id" : "15A379E6-9FB7-4960-ABEE-820D2C230116",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nWhen calling a function that takes a pointer as a parameter, you can use implicit casting to pass a compatible pointer type or implicit bridging to pass a pointer to a variable or the contents of an array.\n\n### Pass a Constant Pointer as a Parameter\n\nWhen you call a function that is declared as taking an `UnsafePointer<Type>` argument, you can pass any of the following:\n\nThe pointer you pass to the function is only guaranteed to be valid for the duration of the function call. Do not persist the pointer and access it after the function has returned.\n\nThis example shows the different ways that you can call the a function that takes a constant pointer:\n\nWhen you call a function that takes an `UnsafeRawPointer` argument, you can pass the same operands as `UnsafePointer<Type>`, but with any type as `Type`.\n\nThis example shows the different ways that you can call a function that takes a constant raw pointer:\n\n### Pass a Mutable Pointer as a Parameter\n\nWhen you call a function that is declared as taking an `UnsafeMutablePointer<Type>` argument, you can pass any of the following:\n\nThis example shows the different ways that you can call a function that takes a mutable pointer:\n\nWhen you call a function that is declared as taking an `UnsafeMutableRawPointer` argument, you can pass the same operands as `UnsafeMutablePointer<Type>`, but for any type as `Type`.\n\nThis example shows the different ways that you can call a function that takes a mutable raw pointer:\n\n### Pass an Autoreleasing Pointer as a Parameter\n\nWhen you call a function that is declared as taking an `AutoreleasingUnsafeMutablePointer<Type>`, you can pass any of the following:\n\nUnlike with other pointer types, you can’t use an array as an implicitly bridged parameter.\n\n### Pass a Function Pointer as a Parameter\n\nWhen calling a function that takes a C function pointer argument, you can pass a top-level Swift function, a closure literal, a closure declared with the `@convention(c)` attribute, or `nil`. You can also pass a closure property of a generic type or a generic method as long as no generic type parameters are referenced in the closure’s argument list or body.\n\nFor example, consider Core Foundation’s `CFArrayCreateMutable(_:_:_:)` function. The `CFArrayCreateMutable(_:_:_:)` function takes a `CFArrayCallBacks` structure, which is initialized with function pointer callbacks:\n\nIn this example, the `CFArrayCallBacks` initializer uses `nil` values as arguments for the `retain` and `release` parameters, the `customCopyDescription(_:)` function as the argument for the `customCopyDescription` parameter, and a closure literal as the argument for the `equal` parameter.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/calling-functions-with-pointer-parameters\ncrawled: 2025-12-03T16:53:22Z\n---\n\n# Calling Functions With Pointer Parameters\n\n**Article**\n\nUse implicit pointer casting or bridging when calling functions that takes pointers as parameters.\n\n## Overview\n\nWhen calling a function that takes a pointer as a parameter, you can use implicit casting to pass a compatible pointer type or implicit bridging to pass a pointer to a variable or the contents of an array.\n\n### Pass a Constant Pointer as a Parameter\n\nWhen you call a function that is declared as taking an `UnsafePointer<Type>` argument, you can pass any of the following:\n\n- An `UnsafePointer<Type>`, `UnsafeMutablePointer<Type>`, or `AutoreleasingUnsafeMutablePointer<Type>` value, which is implicitly cast to `UnsafePointer<Type>` as necessary.\n- A `String` value, if `Type` is `Int8` or `UInt8`. The string is automatically converted to UTF8 in a zero-terminated buffer, and a pointer to that buffer is passed to the function.\n- An in-out expression that contains a mutable variable, property, or subscript reference of type `Type`, which is passed as a pointer to the address of the left-hand side identifier.\n- A `[Type]` value, which is passed as a pointer to the start of the array.\n\nThe pointer you pass to the function is only guaranteed to be valid for the duration of the function call. Do not persist the pointer and access it after the function has returned.\n\nThis example shows the different ways that you can call the a function that takes a constant pointer:\n\n```swift\nfunc takesAPointer(_ p: UnsafePointer<Float>) {\n    \/\/ ...\n}\n\nvar x: Float = 0.0\ntakesAPointer(&x)\ntakesAPointer([1.0, 2.0, 3.0])\n```\n\nWhen you call a function that takes an `UnsafeRawPointer` argument, you can pass the same operands as `UnsafePointer<Type>`, but with any type as `Type`.\n\nThis example shows the different ways that you can call a function that takes a constant raw pointer:\n\n```swift\nfunc takesARawPointer(_ p: UnsafeRawPointer?)  {\n    \/\/ ...\n}\n\nvar x: Float = 0.0, y: Int = 0\ntakesARawPointer(&x)\ntakesARawPointer(&y)\ntakesARawPointer([1.0, 2.0, 3.0] as [Float])\nlet intArray = [1, 2, 3]\ntakesARawPointer(intArray)\ntakesARawPointer(\"How are you today?\")\n```\n\n### Pass a Mutable Pointer as a Parameter\n\nWhen you call a function that is declared as taking an `UnsafeMutablePointer<Type>` argument, you can pass any of the following:\n\n- An `UnsafeMutablePointer<Type>` value.\n- An in-out expression of type `Type` that contains a mutable variable, property, or subscript reference, which is passed as a pointer to the address of the mutable value.\n- An in-out expression of type `[Type]` that contains a mutable variable, property, or subscript reference, which is passed as a pointer to the start of the array, and is lifetime-extended for the duration of the call.\n\nThis example shows the different ways that you can call a function that takes a mutable pointer:\n\n```swift\nfunc takesAMutablePointer(_ p: UnsafeMutablePointer<Float>) {\n    \/\/ ...\n}\n\nvar x: Float = 0.0\nvar a: [Float] = [1.0, 2.0, 3.0]\ntakesAMutablePointer(&x)\ntakesAMutablePointer(&a)\n```\n\nWhen you call a function that is declared as taking an `UnsafeMutableRawPointer` argument, you can pass the same operands as `UnsafeMutablePointer<Type>`, but for any type as `Type`.\n\nThis example shows the different ways that you can call a function that takes a mutable raw pointer:\n\n```swift\nfunc takesAMutableRawPointer(_ p: UnsafeMutableRawPointer?)  {\n    \/\/ ...\n}\n\nvar x: Float = 0.0, y: Int = 0\nvar a: [Float] = [1.0, 2.0, 3.0], b: [Int] = [1, 2, 3]\ntakesAMutableRawPointer(&x)\ntakesAMutableRawPointer(&y)\ntakesAMutableRawPointer(&a)\ntakesAMutableRawPointer(&b)\n```\n\n### Pass an Autoreleasing Pointer as a Parameter\n\nWhen you call a function that is declared as taking an `AutoreleasingUnsafeMutablePointer<Type>`, you can pass any of the following:\n\n- An `AutoreleasingUnsafeMutablePointer<Type>` value.\n- An in-out expression that contains a mutable variable, property, or subscript reference of type `Type`. The value of the operand is copied bitwise into a temporary nonowning buffer. The address of that buffer is passed to the callee, and on return, the value in the buffer is loaded, retained, and reassigned into the operand.\n\nUnlike with other pointer types, you can’t use an array as an implicitly bridged parameter.\n\n### Pass a Function Pointer as a Parameter\n\nWhen calling a function that takes a C function pointer argument, you can pass a top-level Swift function, a closure literal, a closure declared with the `@convention(c)` attribute, or `nil`. You can also pass a closure property of a generic type or a generic method as long as no generic type parameters are referenced in the closure’s argument list or body.\n\nFor example, consider Core Foundation’s `CFArrayCreateMutable(_:_:_:)` function. The `CFArrayCreateMutable(_:_:_:)` function takes a `CFArrayCallBacks` structure, which is initialized with function pointer callbacks:\n\n```swift\nfunc customCopyDescription(_ p: UnsafeRawPointer?) -> Unmanaged<CFString>? {\n    \/\/ return an Unmanaged<CFString>? value\n}\n\nvar callbacks = CFArrayCallBacks(\n    version: 0,\n    retain: nil,\n    release: nil,\n    copyDescription: customCopyDescription,\n    equal: { (p1, p2) -> DarwinBoolean in\n        \/\/ return Bool value\n    }\n)\nvar mutableArray = CFArrayCreateMutable(nil, 0, &callbacks)\n```\n\nIn this example, the `CFArrayCallBacks` initializer uses `nil` values as arguments for the `retain` and `release` parameters, the `customCopyDescription(_:)` function as the argument for the `customCopyDescription` parameter, and a closure literal as the argument for the `equal` parameter.\n\n\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Calling Functions With Pointer Parameters",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/calling-functions-with-pointer-parameters"
}