{
  "abstract" : "Calls a closure with a pointer to the array’s contiguous storage.",
  "codeExamples" : [
    {
      "code" : "let numbers = [1, 2, 3, 4, 5]\nlet sum = numbers.withUnsafeBufferPointer { buffer -> Int in\n    var result = 0\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {\n        result += buffer[i]\n    }\n    return result\n}\n\/\/ 'sum' == 9",
      "language" : "swift"
    }
  ],
  "contentHash" : "b24c91a82f5e29cc19e28fea9b550c768bd1bb0dc4f644988ce20b3d05f6d4a4",
  "crawledAt" : "2025-12-02T20:52:36Z",
  "declaration" : {
    "code" : "func withUnsafeBufferPointer<R, E>(_ body: (UnsafeBufferPointer<Element>) throws(E) -> R) throws(E) -> R where E : Error",
    "language" : "swift"
  },
  "id" : "115640E8-4ADD-47E6-B376-A5ECCBFD3B71",
  "kind" : "method",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nThe return value, if any, of the `body` closure parameter.\n\n## Discussion\n\nOften, the optimizer can eliminate bounds checks within an array algorithm, but when that fails, invoking the same algorithm on the buffer pointer passed into your closure lets you trade safety for speed.\n\nThe following example shows how you can iterate over the contents of the buffer pointer:\n\nThe pointer passed as an argument to `body` is valid only during the execution of `withUnsafeBufferPointer(_:)`. Do not store or return the pointer for later use.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeBufferPointer(_:)\ncrawled: 2025-12-02T20:52:36Z\n---\n\n# withUnsafeBufferPointer(_:)\n\n**Instance Method**\n\nCalls a closure with a pointer to the array’s contiguous storage.\n\n## Declaration\n\n```swift\nfunc withUnsafeBufferPointer<R, E>(_ body: (UnsafeBufferPointer<Element>) throws(E) -> R) throws(E) -> R where E : Error\n```\n\n## Parameters\n\n- **body**: A closure with an `UnsafeBufferPointer` parameter that points to the contiguous storage for the array.  If no such storage exists, it is created. If `body` has a return value, that value is also used as the return value for the `withUnsafeBufferPointer(_:)` method. The pointer argument is valid only for the duration of the method’s execution.\n\n## Return Value\n\nThe return value, if any, of the `body` closure parameter.\n\n## Discussion\n\nOften, the optimizer can eliminate bounds checks within an array algorithm, but when that fails, invoking the same algorithm on the buffer pointer passed into your closure lets you trade safety for speed.\n\nThe following example shows how you can iterate over the contents of the buffer pointer:\n\n```swift\nlet numbers = [1, 2, 3, 4, 5]\nlet sum = numbers.withUnsafeBufferPointer { buffer -> Int in\n    var result = 0\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {\n        result += buffer[i]\n    }\n    return result\n}\n\/\/ 'sum' == 9\n```\n\nThe pointer passed as an argument to `body` is valid only during the execution of `withUnsafeBufferPointer(_:)`. Do not store or return the pointer for later use.\n\n## Accessing Underlying Storage\n\n- **withUnsafeMutableBufferPointer(_:)**: Calls the given closure with a pointer to the array’s mutable contiguous storage.\n- **withUnsafeBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.\n- **withUnsafeMutableBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.\n- **withContiguousStorageIfAvailable(_:)**: Executes a closure on the sequence’s contiguous storage.\n- **withContiguousMutableStorageIfAvailable(_:)**: Executes a closure on the collection’s contiguous storage.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Calls the given closure with a pointer to the array’s mutable contiguous storage.",
          "name" : "withUnsafeMutableBufferPointer(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeMutableBufferPointer(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.",
          "name" : "withUnsafeBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeBytes(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.",
          "name" : "withUnsafeMutableBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeMutableBytes(_:)"
        },
        {
          "description" : "Executes a closure on the sequence’s contiguous storage.",
          "name" : "withContiguousStorageIfAvailable(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withContiguousStorageIfAvailable(_:)"
        },
        {
          "description" : "Executes a closure on the collection’s contiguous storage.",
          "name" : "withContiguousMutableStorageIfAvailable(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withContiguousMutableStorageIfAvailable(_:)"
        }
      ],
      "title" : "Accessing Underlying Storage"
    }
  ],
  "source" : "appleJSON",
  "title" : "withUnsafeBufferPointer(_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/withUnsafeBufferPointer(_:)"
}