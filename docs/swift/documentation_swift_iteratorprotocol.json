{
  "abstract" : "A type that supplies the values of a sequence one at a time.",
  "codeExamples" : [
    {
      "code" : "let animals = [\"Antelope\", \"Butterfly\", \"Camel\", \"Dolphin\"]\nfor animal in animals {\n    print(animal)\n}\n\/\/ Prints \"Antelope\"\n\/\/ Prints \"Butterfly\"\n\/\/ Prints \"Camel\"\n\/\/ Prints \"Dolphin\"",
      "language" : "swift"
    },
    {
      "code" : "var animalIterator = animals.makeIterator()\nwhile let animal = animalIterator.next() {\n    print(animal)\n}\n\/\/ Prints \"Antelope\"\n\/\/ Prints \"Butterfly\"\n\/\/ Prints \"Camel\"\n\/\/ Prints \"Dolphin\"",
      "language" : "swift"
    },
    {
      "code" : "extension Sequence {\n    func reduce1(\n        _ nextPartialResult: (Element, Element) -> Element\n    ) -> Element?\n    {\n        var i = makeIterator()\n        guard var accumulated = i.next() else {\n            return nil\n        }\n\n        while let element = i.next() {\n            accumulated = nextPartialResult(accumulated, element)\n        }\n        return accumulated\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let longestAnimal = animals.reduce1 { current, element in\n    if current.count > element.count {\n        return current\n    } else {\n        return element\n    }\n}\nprint(longestAnimal)\n\/\/ Prints Optional(\"Butterfly\")",
      "language" : "swift"
    },
    {
      "code" : "struct Countdown: Sequence {\n    let start: Int\n\n    func makeIterator() -> CountdownIterator {\n        return CountdownIterator(self)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CountdownIterator: IteratorProtocol {\n    let countdown: Countdown\n    var times = 0\n\n    init(_ countdown: Countdown) {\n        self.countdown = countdown\n    }\n\n    mutating func next() -> Int? {\n        let nextNumber = countdown.start - times\n        guard nextNumber > 0\n            else { return nil }\n\n        times += 1\n        return nextNumber\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let threeTwoOne = Countdown(start: 3)\nfor count in threeTwoOne {\n    print(\"\\(count)...\")\n}\n\/\/ Prints \"3...\"\n\/\/ Prints \"2...\"\n\/\/ Prints \"1...\"",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "AnyIterator",
    "CollectionOfOne.Iterator",
    "Dictionary.Iterator",
    "Dictionary.Keys.Iterator",
    "Dictionary.Values.Iterator",
    "DropWhileSequence.Iterator",
    "EmptyCollection.Iterator",
    "EnumeratedSequence.Iterator",
    "FlattenSequence.Iterator",
    "IndexingIterator",
    "IteratorSequence",
    "JoinedSequence.Iterator",
    "LazyDropWhileSequence.Iterator",
    "LazyFilterSequence.Iterator",
    "LazyMapSequence.Iterator",
    "LazyPrefixWhileSequence.Iterator",
    "PartialRangeFrom.Iterator",
    "PrefixSequence.Iterator",
    "ReversedCollection.Iterator",
    "Set.Iterator",
    "StrideThroughIterator",
    "StrideToIterator",
    "String.Iterator",
    "String.UTF16View.Iterator",
    "String.UnicodeScalarView.Iterator",
    "UnfoldSequence",
    "UnsafeBufferPointer.Iterator",
    "UnsafeRawBufferPointer.Iterator",
    "Zip2Sequence.Iterator"
  ],
  "contentHash" : "92ad59e4b63517eacb3f75a283b3f9b44ca81baec4a6cf661509071adeae4bee",
  "crawledAt" : "2025-12-03T16:24:04Z",
  "declaration" : {
    "code" : "protocol IteratorProtocol<Element>",
    "language" : "swift"
  },
  "id" : "ABBF10BD-59DB-4CEC-B870-9C884BB5C591",
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nThe `IteratorProtocol` protocol is tightly linked with the `Sequence` protocol. Sequences provide access to their elements by creating an iterator, which keeps track of its iteration process and returns one element at a time as it advances through the sequence.\n\nWhenever you use a `for`-`in` loop with an array, set, or any other collection or sequence, you’re using that type’s iterator. Swift uses a sequence’s or collection’s iterator internally to enable the `for`-`in` loop language construct.\n\nUsing a sequence’s iterator directly gives you access to the same elements in the same order as iterating over that sequence using a `for`-`in` loop. For example, you might typically use a `for`-`in` loop to print each of the elements in an array.\n\nBehind the scenes, Swift uses the `animals` array’s iterator to loop over the contents of the array.\n\nThe call to `animals.makeIterator()` returns an instance of the array’s iterator. Next, the `while` loop calls the iterator’s `next()` method repeatedly, binding each element that is returned to `animal` and exiting when the `next()` method returns `nil`.\n\n# Using Iterators Directly\n\nYou rarely need to use iterators directly, because a `for`-`in` loop is the more idiomatic approach to traversing a sequence in Swift. Some algorithms, however, may call for direct iterator use.\n\nOne example is the `reduce1(_:)` method. Similar to the `reduce(_:_:)` method defined in the standard library, which takes an initial value and a combining closure, `reduce1(_:)` uses the first element of the sequence as the initial value.\n\nHere’s an implementation of the `reduce1(_:)` method. The sequence’s iterator is used directly to retrieve the initial value before looping over the rest of the sequence.\n\nThe `reduce1(_:)` method makes certain kinds of sequence operations simpler. Here’s how to find the longest string in a sequence, using the `animals` array introduced earlier as an example:\n\n# Using Multiple Iterators\n\nWhenever you use multiple iterators (or `for`-`in` loops) over a single sequence, be sure you know that the specific sequence supports repeated iteration, either because you know its concrete type or because the sequence is also constrained to the `Collection` protocol.\n\nObtain each separate iterator from separate calls to the sequence’s `makeIterator()` method rather than by copying. Copying an iterator is safe, but advancing one copy of an iterator by calling its `next()` method may invalidate other copies of that iterator. `for`-`in` loops are safe in this regard.\n\n# Adding IteratorProtocol Conformance to Your Type\n\nImplementing an iterator that conforms to `IteratorProtocol` is simple. Declare a `next()` method that advances one step in the related sequence and returns the current element. When the sequence has been exhausted, the `next()` method returns `nil`.\n\nFor example, consider a custom `Countdown` sequence. You can initialize the `Countdown` sequence with a starting integer and then iterate over the count down to zero. The `Countdown` structure’s definition is short: It contains only the starting count and the `makeIterator()` method required by the `Sequence` protocol.\n\nThe `makeIterator()` method returns another custom type, an iterator named `CountdownIterator`. The `CountdownIterator` type keeps track of both the `Countdown` sequence that it’s iterating and the number of times it has returned a value.\n\nEach time the `next()` method is called on a `CountdownIterator` instance, it calculates the new next value, checks to see whether it has reached zero, and then returns either the number, or `nil` if the iterator is finished returning elements of the sequence.\n\nCreating and iterating over a `Countdown` sequence uses a `CountdownIterator` to handle the iteration.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/IteratorProtocol\ncrawled: 2025-12-03T16:24:04Z\n---\n\n# IteratorProtocol\n\n**Protocol**\n\nA type that supplies the values of a sequence one at a time.\n\n## Declaration\n\n```swift\nprotocol IteratorProtocol<Element>\n```\n\n## Overview\n\nThe `IteratorProtocol` protocol is tightly linked with the `Sequence` protocol. Sequences provide access to their elements by creating an iterator, which keeps track of its iteration process and returns one element at a time as it advances through the sequence.\n\nWhenever you use a `for`-`in` loop with an array, set, or any other collection or sequence, you’re using that type’s iterator. Swift uses a sequence’s or collection’s iterator internally to enable the `for`-`in` loop language construct.\n\nUsing a sequence’s iterator directly gives you access to the same elements in the same order as iterating over that sequence using a `for`-`in` loop. For example, you might typically use a `for`-`in` loop to print each of the elements in an array.\n\n```swift\nlet animals = [\"Antelope\", \"Butterfly\", \"Camel\", \"Dolphin\"]\nfor animal in animals {\n    print(animal)\n}\n\/\/ Prints \"Antelope\"\n\/\/ Prints \"Butterfly\"\n\/\/ Prints \"Camel\"\n\/\/ Prints \"Dolphin\"\n```\n\nBehind the scenes, Swift uses the `animals` array’s iterator to loop over the contents of the array.\n\n```swift\nvar animalIterator = animals.makeIterator()\nwhile let animal = animalIterator.next() {\n    print(animal)\n}\n\/\/ Prints \"Antelope\"\n\/\/ Prints \"Butterfly\"\n\/\/ Prints \"Camel\"\n\/\/ Prints \"Dolphin\"\n```\n\nThe call to `animals.makeIterator()` returns an instance of the array’s iterator. Next, the `while` loop calls the iterator’s `next()` method repeatedly, binding each element that is returned to `animal` and exiting when the `next()` method returns `nil`.\n\n# Using Iterators Directly\n\nYou rarely need to use iterators directly, because a `for`-`in` loop is the more idiomatic approach to traversing a sequence in Swift. Some algorithms, however, may call for direct iterator use.\n\nOne example is the `reduce1(_:)` method. Similar to the `reduce(_:_:)` method defined in the standard library, which takes an initial value and a combining closure, `reduce1(_:)` uses the first element of the sequence as the initial value.\n\nHere’s an implementation of the `reduce1(_:)` method. The sequence’s iterator is used directly to retrieve the initial value before looping over the rest of the sequence.\n\n```swift\nextension Sequence {\n    func reduce1(\n        _ nextPartialResult: (Element, Element) -> Element\n    ) -> Element?\n    {\n        var i = makeIterator()\n        guard var accumulated = i.next() else {\n            return nil\n        }\n\n        while let element = i.next() {\n            accumulated = nextPartialResult(accumulated, element)\n        }\n        return accumulated\n    }\n}\n```\n\nThe `reduce1(_:)` method makes certain kinds of sequence operations simpler. Here’s how to find the longest string in a sequence, using the `animals` array introduced earlier as an example:\n\n```swift\nlet longestAnimal = animals.reduce1 { current, element in\n    if current.count > element.count {\n        return current\n    } else {\n        return element\n    }\n}\nprint(longestAnimal)\n\/\/ Prints Optional(\"Butterfly\")\n```\n\n# Using Multiple Iterators\n\nWhenever you use multiple iterators (or `for`-`in` loops) over a single sequence, be sure you know that the specific sequence supports repeated iteration, either because you know its concrete type or because the sequence is also constrained to the `Collection` protocol.\n\nObtain each separate iterator from separate calls to the sequence’s `makeIterator()` method rather than by copying. Copying an iterator is safe, but advancing one copy of an iterator by calling its `next()` method may invalidate other copies of that iterator. `for`-`in` loops are safe in this regard.\n\n# Adding IteratorProtocol Conformance to Your Type\n\nImplementing an iterator that conforms to `IteratorProtocol` is simple. Declare a `next()` method that advances one step in the related sequence and returns the current element. When the sequence has been exhausted, the `next()` method returns `nil`.\n\nFor example, consider a custom `Countdown` sequence. You can initialize the `Countdown` sequence with a starting integer and then iterate over the count down to zero. The `Countdown` structure’s definition is short: It contains only the starting count and the `makeIterator()` method required by the `Sequence` protocol.\n\n```swift\nstruct Countdown: Sequence {\n    let start: Int\n\n    func makeIterator() -> CountdownIterator {\n        return CountdownIterator(self)\n    }\n}\n```\n\nThe `makeIterator()` method returns another custom type, an iterator named `CountdownIterator`. The `CountdownIterator` type keeps track of both the `Countdown` sequence that it’s iterating and the number of times it has returned a value.\n\n```swift\nstruct CountdownIterator: IteratorProtocol {\n    let countdown: Countdown\n    var times = 0\n\n    init(_ countdown: Countdown) {\n        self.countdown = countdown\n    }\n\n    mutating func next() -> Int? {\n        let nextNumber = countdown.start - times\n        guard nextNumber > 0\n            else { return nil }\n\n        times += 1\n        return nextNumber\n    }\n}\n```\n\nEach time the `next()` method is called on a `CountdownIterator` instance, it calculates the new next value, checks to see whether it has reached zero, and then returns either the number, or `nil` if the iterator is finished returning elements of the sequence.\n\nCreating and iterating over a `Countdown` sequence uses a `CountdownIterator` to handle the iteration.\n\n```swift\nlet threeTwoOne = Countdown(start: 3)\nfor count in threeTwoOne {\n    print(\"\\(count)...\")\n}\n\/\/ Prints \"3...\"\n\/\/ Prints \"2...\"\n\/\/ Prints \"1...\"\n```\n\n## Associated Types\n\n- **Element**: The type of element traversed by the iterator.\n\n## Instance Methods\n\n- **next()**: Advances to the next element and returns it, or `nil` if no next element exists.\n\n## Conforming Types\n\n- AnyIterator\n- CollectionOfOne.Iterator\n- Dictionary.Iterator\n- Dictionary.Keys.Iterator\n- Dictionary.Values.Iterator\n- DropWhileSequence.Iterator\n- EmptyCollection.Iterator\n- EnumeratedSequence.Iterator\n- FlattenSequence.Iterator\n- IndexingIterator\n- IteratorSequence\n- JoinedSequence.Iterator\n- LazyDropWhileSequence.Iterator\n- LazyFilterSequence.Iterator\n- LazyMapSequence.Iterator\n- LazyPrefixWhileSequence.Iterator\n- PartialRangeFrom.Iterator\n- PrefixSequence.Iterator\n- ReversedCollection.Iterator\n- Set.Iterator\n- StrideThroughIterator\n- StrideToIterator\n- String.Iterator\n- String.UTF16View.Iterator\n- String.UnicodeScalarView.Iterator\n- UnfoldSequence\n- UnsafeBufferPointer.Iterator\n- UnsafeRawBufferPointer.Iterator\n- Zip2Sequence.Iterator\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The type of element traversed by the iterator.",
          "name" : "Element",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/IteratorProtocol\/Element"
        }
      ],
      "title" : "Associated Types"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Advances to the next element and returns it, or `nil` if no next element exists.",
          "name" : "next()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/IteratorProtocol\/next()"
        }
      ],
      "title" : "Instance Methods"
    }
  ],
  "source" : "appleJSON",
  "title" : "IteratorProtocol",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/IteratorProtocol"
}