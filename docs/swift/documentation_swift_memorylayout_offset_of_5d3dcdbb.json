{
  "abstract" : "Returns the offset of an inline stored property within a type’s in-memory representation.",
  "codeExamples" : [
    {
      "code" : "\/\/ Mutation through the key path\nroot[keyPath: key] = value\n\n\/\/ Mutation through the offset pointer\nwithUnsafeMutableBytes(of: &root) { bytes in\n    let offset = MemoryLayout<T>.offset(of: key)!\n    let rawPointerToValue = bytes.baseAddress! + offset\n    let pointerToValue = rawPointerToValue.assumingMemoryBound(to: U.self)\n    pointerToValue.pointee = value\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ProductCategory {\n    struct Identifier {\n        var name: String              \/\/ addressable\n    }\n\n    var identifier: Identifier        \/\/ addressable\n    var updateCounter: Int            \/\/ addressable\n    var products: [Product] {         \/\/ not addressable: didSet handler\n        didSet { updateCounter += 1 }\n    }\n    var productCount: Int {           \/\/ not addressable: computed property\n        return products.count\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "33974f5392f7959fb8b63d79d5c3703dcc3da36a69fd590085cff8b54519fdee",
  "crawledAt" : "2025-12-04T17:18:21Z",
  "declaration" : {
    "code" : "static func offset(of key: PartialKeyPath<T>) -> Int?",
    "language" : "swift"
  },
  "id" : "49A071FC-C7B5-4A29-9DB0-F17D26D644DC",
  "kind" : "method",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nThe offset in bytes from a pointer to a value of type `T` to a pointer to the storage referenced by `key`, or `nil` if no such offset is available for the storage referenced by `key`. If the value is `nil`, it can be because `key` is computed, has observers, requires reabstraction, or overlaps storage with other properties.\n\n## Discussion\n\nYou can use this method to find the distance in bytes that can be added to a pointer of type `T` to get a pointer to the property referenced by `key`. The offset is available only if the given key refers to inline, directly addressable storage within the in-memory representation of `T`.\n\nIf the return value of this method is non-`nil`, then accessing the value by key path or by an offset pointer are equivalent. For example, for a variable `root` of type `T`, a key path `key` of type `WritableKeyPath<T, U>`, and a `value` of type `U`:\n\nA property has inline, directly addressable storage when it is a stored property for which no additional work is required to extract or set the value. Properties are not directly accessible if they trigger any `didSet` or `willSet` accessors, perform any representation changes such as bridging or closure reabstraction, or mask the value out of overlapping storage as for packed bitfields. In addition, because class instance properties are always stored out-of-line, their positions are not accessible using `offset(of:)`.\n\nFor example, in the `ProductCategory` type defined here, only `\\.updateCounter`, `\\.identifier`, and `\\.identifier.name` refer to properties with inline, directly addressable storage:\n\nWhen using `offset(of:)` with a type imported from a library, don’t assume that future versions of the library will have the same behavior. If a property is converted from a stored property to a computed property, the result of `offset(of:)` changes to `nil`. That kind of conversion is nonbreaking in other contexts, but would trigger a runtime error if the result of `offset(of:)` is force-unwrapped.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/MemoryLayout\/offset(of:)\ncrawled: 2025-12-04T17:18:21Z\n---\n\n# offset(of:)\n\n**Type Method**\n\nReturns the offset of an inline stored property within a type’s in-memory representation.\n\n## Declaration\n\n```swift\nstatic func offset(of key: PartialKeyPath<T>) -> Int?\n```\n\n## Parameters\n\n- **key**: A key path referring to storage that can be accessed through a value of type `T`.\n\n## Return Value\n\nThe offset in bytes from a pointer to a value of type `T` to a pointer to the storage referenced by `key`, or `nil` if no such offset is available for the storage referenced by `key`. If the value is `nil`, it can be because `key` is computed, has observers, requires reabstraction, or overlaps storage with other properties.\n\n## Discussion\n\nYou can use this method to find the distance in bytes that can be added to a pointer of type `T` to get a pointer to the property referenced by `key`. The offset is available only if the given key refers to inline, directly addressable storage within the in-memory representation of `T`.\n\nIf the return value of this method is non-`nil`, then accessing the value by key path or by an offset pointer are equivalent. For example, for a variable `root` of type `T`, a key path `key` of type `WritableKeyPath<T, U>`, and a `value` of type `U`:\n\n```swift\n\/\/ Mutation through the key path\nroot[keyPath: key] = value\n\n\/\/ Mutation through the offset pointer\nwithUnsafeMutableBytes(of: &root) { bytes in\n    let offset = MemoryLayout<T>.offset(of: key)!\n    let rawPointerToValue = bytes.baseAddress! + offset\n    let pointerToValue = rawPointerToValue.assumingMemoryBound(to: U.self)\n    pointerToValue.pointee = value\n}\n```\n\nA property has inline, directly addressable storage when it is a stored property for which no additional work is required to extract or set the value. Properties are not directly accessible if they trigger any `didSet` or `willSet` accessors, perform any representation changes such as bridging or closure reabstraction, or mask the value out of overlapping storage as for packed bitfields. In addition, because class instance properties are always stored out-of-line, their positions are not accessible using `offset(of:)`.\n\nFor example, in the `ProductCategory` type defined here, only `\\.updateCounter`, `\\.identifier`, and `\\.identifier.name` refer to properties with inline, directly addressable storage:\n\n```swift\nstruct ProductCategory {\n    struct Identifier {\n        var name: String              \/\/ addressable\n    }\n\n    var identifier: Identifier        \/\/ addressable\n    var updateCounter: Int            \/\/ addressable\n    var products: [Product] {         \/\/ not addressable: didSet handler\n        didSet { updateCounter += 1 }\n    }\n    var productCount: Int {           \/\/ not addressable: computed property\n        return products.count\n    }\n}\n```\n\nWhen using `offset(of:)` with a type imported from a library, don’t assume that future versions of the library will have the same behavior. If a property is converted from a stored property to a computed property, the result of `offset(of:)` changes to `nil`. That kind of conversion is nonbreaking in other contexts, but would trigger a runtime error if the result of `offset(of:)` is force-unwrapped.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "offset(of:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/MemoryLayout\/offset(of:)"
}