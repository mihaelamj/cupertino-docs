{
  "abstract" : "A type that can be initialized using an array literal.",
  "codeExamples" : [
    {
      "code" : "let employeesSet: Set<String> = [\"Amir\", \"Jihye\", \"Dave\", \"Alessia\", \"Dave\"]\nprint(employeesSet)\n\/\/ Prints \"[\"Amir\", \"Dave\", \"Jihye\", \"Alessia\"]\"\n\nlet employeesArray: [String] = [\"Amir\", \"Jihye\", \"Dave\", \"Alessia\", \"Dave\"]\nprint(employeesArray)\n\/\/ Prints \"[\"Amir\", \"Jihye\", \"Dave\", \"Alessia\", \"Dave\"]\"",
      "language" : "swift"
    },
    {
      "code" : "let integers = [1, 2, 3]\n\/\/ 'integers' has type '[Int]'\n\nlet strings = [\"a\", \"b\", \"c\"]\n\/\/ 'strings' has type '[String]'",
      "language" : "swift"
    },
    {
      "code" : "var emptyArray: [Bool] = []\n\/\/ 'emptyArray' has type '[Bool]'",
      "language" : "swift"
    },
    {
      "code" : "func sum(values: [Int]) -> Int {\n    return values.reduce(0, +)\n}\n\nlet sumOfFour = sum([5, 10, 15, 20])\n\/\/ 'sumOfFour' == 50\n\nlet sumOfNone = sum([])\n\/\/ 'sumOfNone' == 0",
      "language" : "swift"
    },
    {
      "code" : "func log<T>(name name: String, value: T) {\n    print(\"\\(name): \\(value)\")\n}\n\nlog(name: \"Four integers\", value: [5, 10, 15, 20])\n\/\/ Prints \"Four integers: [5, 10, 15, 20]\"\n\nlog(name: \"Zero integers\", value: [] as [Int])\n\/\/ Prints \"Zero integers: []\"",
      "language" : "swift"
    },
    {
      "code" : "struct OrderedSet<Element: Hashable>: Collection, SetAlgebra {\n    \/\/ implementation details\n}\n\nextension OrderedSet: ExpressibleByArrayLiteral {\n    init(arrayLiteral: Element...) {\n        self.init()\n        for element in arrayLiteral {\n            self.append(element)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "Array",
    "ArraySlice",
    "ContiguousArray",
    "SIMD16",
    "SIMD2",
    "SIMD3",
    "SIMD32",
    "SIMD4",
    "SIMD64",
    "SIMD8",
    "SIMDMask",
    "Set"
  ],
  "contentHash" : "2835f9b51bcf4093dcf14e63cd89bef676827e9a212bbe2a9c3baba7ec8a83a7",
  "crawledAt" : "2025-12-04T18:32:22Z",
  "declaration" : {
    "code" : "protocol ExpressibleByArrayLiteral",
    "language" : "swift"
  },
  "id" : "195F8ED9-58BF-4C9B-B47B-F3805EA00C50",
  "inheritedBy" : [
    "OptionSet",
    "SIMD",
    "SetAlgebra"
  ],
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nAn array literal is a simple way of expressing a list of values. Simply surround a comma-separated list of values, instances, or literals with square brackets to create an array literal. You can use an array literal anywhere an instance of an `ExpressibleByArrayLiteral` type is expected: as a value assigned to a variable or constant, as a parameter to a method or initializer, or even as the subject of a nonmutating operation like `map(_:)` or `filter(_:)`.\n\nArrays, sets, and option sets all conform to `ExpressibleByArrayLiteral`, and your own custom types can as well. Here’s an example of creating a set and an array using array literals:\n\nThe `Set` and `Array` types each handle array literals in their own way to create new instances. In this case, the newly created set drops the duplicate value (“Dave”) and doesn’t maintain the order of the array literal’s elements. The new array, on the other hand, matches the order and number of elements provided.\n\n# Type Inference of Array Literals\n\nWhenever possible, Swift’s compiler infers the full intended type of your array literal. Because `Array` is the default type for an array literal, without writing any other code, you can declare an array with a particular element type by providing one or more values.\n\nIn this example, the compiler infers the full type of each array literal.\n\nAn empty array literal alone doesn’t provide enough information for the compiler to infer the intended type of the `Array` instance. When using an empty array literal, specify the type of the variable or constant.\n\nBecause many functions and initializers fully specify the types of their parameters, you can often use an array literal with or without elements as a parameter. For example, the `sum(_:)` function shown here takes an `Int` array as a parameter:\n\nWhen you call a function that does not fully specify its parameters’ types, use the type-cast operator (`as`) to specify the type of an array literal. For example, the `log(name:value:)` function shown here has an unconstrained generic `value` parameter.\n\n# Conforming to ExpressibleByArrayLiteral\n\nAdd the capability to be initialized with an array literal to your own custom types by declaring an `init(arrayLiteral:)` initializer. The following example shows the array literal initializer for a hypothetical `OrderedSet` type, which has setlike semantics but maintains the order of its elements.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/expressiblebyarrayliteral\ncrawled: 2025-12-04T18:32:22Z\n---\n\n# ExpressibleByArrayLiteral\n\n**Protocol**\n\nA type that can be initialized using an array literal.\n\n## Declaration\n\n```swift\nprotocol ExpressibleByArrayLiteral\n```\n\n## Overview\n\nAn array literal is a simple way of expressing a list of values. Simply surround a comma-separated list of values, instances, or literals with square brackets to create an array literal. You can use an array literal anywhere an instance of an `ExpressibleByArrayLiteral` type is expected: as a value assigned to a variable or constant, as a parameter to a method or initializer, or even as the subject of a nonmutating operation like `map(_:)` or `filter(_:)`.\n\nArrays, sets, and option sets all conform to `ExpressibleByArrayLiteral`, and your own custom types can as well. Here’s an example of creating a set and an array using array literals:\n\n```swift\nlet employeesSet: Set<String> = [\"Amir\", \"Jihye\", \"Dave\", \"Alessia\", \"Dave\"]\nprint(employeesSet)\n\/\/ Prints \"[\"Amir\", \"Dave\", \"Jihye\", \"Alessia\"]\"\n\nlet employeesArray: [String] = [\"Amir\", \"Jihye\", \"Dave\", \"Alessia\", \"Dave\"]\nprint(employeesArray)\n\/\/ Prints \"[\"Amir\", \"Jihye\", \"Dave\", \"Alessia\", \"Dave\"]\"\n```\n\nThe `Set` and `Array` types each handle array literals in their own way to create new instances. In this case, the newly created set drops the duplicate value (“Dave”) and doesn’t maintain the order of the array literal’s elements. The new array, on the other hand, matches the order and number of elements provided.\n\n\n\n# Type Inference of Array Literals\n\nWhenever possible, Swift’s compiler infers the full intended type of your array literal. Because `Array` is the default type for an array literal, without writing any other code, you can declare an array with a particular element type by providing one or more values.\n\nIn this example, the compiler infers the full type of each array literal.\n\n```swift\nlet integers = [1, 2, 3]\n\/\/ 'integers' has type '[Int]'\n\nlet strings = [\"a\", \"b\", \"c\"]\n\/\/ 'strings' has type '[String]'\n```\n\nAn empty array literal alone doesn’t provide enough information for the compiler to infer the intended type of the `Array` instance. When using an empty array literal, specify the type of the variable or constant.\n\n```swift\nvar emptyArray: [Bool] = []\n\/\/ 'emptyArray' has type '[Bool]'\n```\n\nBecause many functions and initializers fully specify the types of their parameters, you can often use an array literal with or without elements as a parameter. For example, the `sum(_:)` function shown here takes an `Int` array as a parameter:\n\n```swift\nfunc sum(values: [Int]) -> Int {\n    return values.reduce(0, +)\n}\n\nlet sumOfFour = sum([5, 10, 15, 20])\n\/\/ 'sumOfFour' == 50\n\nlet sumOfNone = sum([])\n\/\/ 'sumOfNone' == 0\n```\n\nWhen you call a function that does not fully specify its parameters’ types, use the type-cast operator (`as`) to specify the type of an array literal. For example, the `log(name:value:)` function shown here has an unconstrained generic `value` parameter.\n\n```swift\nfunc log<T>(name name: String, value: T) {\n    print(\"\\(name): \\(value)\")\n}\n\nlog(name: \"Four integers\", value: [5, 10, 15, 20])\n\/\/ Prints \"Four integers: [5, 10, 15, 20]\"\n\nlog(name: \"Zero integers\", value: [] as [Int])\n\/\/ Prints \"Zero integers: []\"\n```\n\n# Conforming to ExpressibleByArrayLiteral\n\nAdd the capability to be initialized with an array literal to your own custom types by declaring an `init(arrayLiteral:)` initializer. The following example shows the array literal initializer for a hypothetical `OrderedSet` type, which has setlike semantics but maintains the order of its elements.\n\n```swift\nstruct OrderedSet<Element: Hashable>: Collection, SetAlgebra {\n    \/\/ implementation details\n}\n\nextension OrderedSet: ExpressibleByArrayLiteral {\n    init(arrayLiteral: Element...) {\n        self.init()\n        for element in arrayLiteral {\n            self.append(element)\n        }\n    }\n}\n```\n\n## Associated Types\n\n- **ArrayLiteralElement**: The type of the elements of an array literal.\n\n## Initializers\n\n- **init(arrayLiteral:)**: Creates an instance initialized with the given elements.\n\n## Collection Literals\n\n- **ExpressibleByDictionaryLiteral**: A type that can be initialized using a dictionary literal.\n\n## Inherited By\n\n- OptionSet\n- SIMD\n- SetAlgebra\n\n## Conforming Types\n\n- Array\n- ArraySlice\n- ContiguousArray\n- SIMD16\n- SIMD2\n- SIMD3\n- SIMD32\n- SIMD4\n- SIMD64\n- SIMD8\n- SIMDMask\n- Set\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The type of the elements of an array literal.",
          "name" : "ArrayLiteralElement",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ExpressibleByArrayLiteral\/ArrayLiteralElement"
        }
      ],
      "title" : "Associated Types"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an instance initialized with the given elements.",
          "name" : "init(arrayLiteral:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ExpressibleByArrayLiteral\/init(arrayLiteral:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that can be initialized using a dictionary literal.",
          "name" : "ExpressibleByDictionaryLiteral",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ExpressibleByDictionaryLiteral"
        }
      ],
      "title" : "Collection Literals"
    }
  ],
  "source" : "appleJSON",
  "title" : "ExpressibleByArrayLiteral",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/expressiblebyarrayliteral"
}