{
  "abstract" : "A collection that supports efficient random-access index traversal.",
  "codeExamples" : [

  ],
  "conformingTypes" : [
    "AnyRandomAccessCollection",
    "AnyRegexOutput",
    "Array",
    "ArraySlice",
    "ClosedRange",
    "CollectionOfOne",
    "ContiguousArray",
    "DefaultIndices",
    "EmptyCollection",
    "EnumeratedSequence",
    "Int.Words",
    "Int16.Words",
    "Int32.Words",
    "Int64.Words",
    "Int8.Words",
    "KeyValuePairs",
    "LazyMapSequence",
    "LazySequence",
    "Range",
    "RangeSet.Ranges",
    "Repeated",
    "ReversedCollection",
    "Slice",
    "UInt.Words",
    "UInt128.Words",
    "UInt16.Words",
    "UInt32.Words",
    "UInt64.Words",
    "UInt8.Words",
    "Unicode.Scalar.UTF16View",
    "Unicode.Scalar.UTF8View",
    "UnsafeBufferPointer",
    "UnsafeMutableBufferPointer",
    "UnsafeMutableRawBufferPointer",
    "UnsafeRawBufferPointer"
  ],
  "contentHash" : "50ae1802cceb06987a29b4b773d1c540ab30ee35735a39db64b531b485b03bf9",
  "crawledAt" : "2025-12-04T15:11:06Z",
  "declaration" : {
    "code" : "protocol RandomAccessCollection<Element> : BidirectionalCollection where Self.Indices : RandomAccessCollection, Self.SubSequence : RandomAccessCollection",
    "language" : "swift"
  },
  "id" : "D7332FE4-8E74-4B16-A002-BB507F4E826E",
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nRandom-access collections can move indices any distance and measure the distance between indices in O(1) time. Therefore, the fundamental difference between random-access and bidirectional collections is that operations that depend on index movement or distance measurement offer significantly improved efficiency. For example, a random-access collection’s `count` property is calculated in O(1) instead of requiring iteration of an entire collection.\n\n# Conforming to the RandomAccessCollection Protocol\n\nThe `RandomAccessCollection` protocol adds further constraints on the associated `Indices` and `SubSequence` types, but otherwise imposes no additional requirements over the `BidirectionalCollection` protocol. However, in order to meet the complexity guarantees of a random-access collection, either the index for your custom type must conform to the `Strideable` protocol or you must implement the `index(_:offsetBy:)` and `distance(from:to:)` methods with O(1) efficiency.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/randomaccesscollection\ncrawled: 2025-12-04T15:11:06Z\n---\n\n# RandomAccessCollection\n\n**Protocol**\n\nA collection that supports efficient random-access index traversal.\n\n## Declaration\n\n```swift\nprotocol RandomAccessCollection<Element> : BidirectionalCollection where Self.Indices : RandomAccessCollection, Self.SubSequence : RandomAccessCollection\n```\n\n## Overview\n\nRandom-access collections can move indices any distance and measure the distance between indices in O(1) time. Therefore, the fundamental difference between random-access and bidirectional collections is that operations that depend on index movement or distance measurement offer significantly improved efficiency. For example, a random-access collection’s `count` property is calculated in O(1) instead of requiring iteration of an entire collection.\n\n# Conforming to the RandomAccessCollection Protocol\n\nThe `RandomAccessCollection` protocol adds further constraints on the associated `Indices` and `SubSequence` types, but otherwise imposes no additional requirements over the `BidirectionalCollection` protocol. However, in order to meet the complexity guarantees of a random-access collection, either the index for your custom type must conform to the `Strideable` protocol or you must implement the `index(_:offsetBy:)` and `distance(from:to:)` methods with O(1) efficiency.\n\n## Associated Types\n\n- **Element**: A type representing the sequence’s elements.\n- **Index**: A type that represents a position in the collection.\n- **Indices**: A type that represents the indices that are valid for subscripting the collection, in ascending order.\n- **SubSequence**: A collection representing a contiguous subrange of this collection’s elements. The subsequence shares indices with the original collection.\n\n## Instance Properties\n\n- **endIndex**: The collection’s “past the end” position—that is, the position one greater than the last valid subscript argument.\n- **indices**: The indices that are valid for subscripting the collection, in ascending order.\n- **startIndex**: The position of the first element in a nonempty collection.\n\n## Instance Methods\n\n- **distance(from:to:)**: Returns the distance between two indices.\n- **formIndex(after:)**: Replaces the given index with its successor.\n- **formIndex(before:)**: Replaces the given index with its predecessor.\n- **index(_:offsetBy:)**: Returns an index that is the specified distance from the given index.\n- **index(_:offsetBy:limitedBy:)**: Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\n- **index(after:)**: Returns the position immediately after the given index.\n- **index(before:)**: Returns the position immediately before the given index.\n\n## Subscripts\n\n- **subscript(_:)**: Accesses the element at the specified position.\n- **subscript(_:)**: Accesses a contiguous subrange of the collection’s elements.\n\n## Collection Traversal\n\n- **BidirectionalCollection**: A collection that supports backward as well as forward traversal.\n\n## Inherits From\n\n- BidirectionalCollection\n- Collection\n- Sequence\n\n## Conforming Types\n\n- AnyRandomAccessCollection\n- AnyRegexOutput\n- Array\n- ArraySlice\n- ClosedRange\n- CollectionOfOne\n- ContiguousArray\n- DefaultIndices\n- EmptyCollection\n- EnumeratedSequence\n- Int.Words\n- Int16.Words\n- Int32.Words\n- Int64.Words\n- Int8.Words\n- KeyValuePairs\n- LazyMapSequence\n- LazySequence\n- Range\n- RangeSet.Ranges\n- Repeated\n- ReversedCollection\n- Slice\n- UInt.Words\n- UInt128.Words\n- UInt16.Words\n- UInt32.Words\n- UInt64.Words\n- UInt8.Words\n- Unicode.Scalar.UTF16View\n- Unicode.Scalar.UTF8View\n- UnsafeBufferPointer\n- UnsafeMutableBufferPointer\n- UnsafeMutableRawBufferPointer\n- UnsafeRawBufferPointer\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type representing the sequence’s elements.",
          "name" : "Element",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/Element"
        },
        {
          "description" : "A type that represents a position in the collection.",
          "name" : "Index",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/Index"
        },
        {
          "description" : "A type that represents the indices that are valid for subscripting the collection, in ascending order.",
          "name" : "Indices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/Indices-swift.associatedtype"
        },
        {
          "description" : "A collection representing a contiguous subrange of this collection’s elements. The subsequence shares indices with the original collection.",
          "name" : "SubSequence",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/SubSequence"
        }
      ],
      "title" : "Associated Types"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The collection’s “past the end” position—that is, the position one greater than the last valid subscript argument.",
          "name" : "endIndex",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/endIndex"
        },
        {
          "description" : "The indices that are valid for subscripting the collection, in ascending order.",
          "name" : "indices",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/indices-swift.property"
        },
        {
          "description" : "The position of the first element in a nonempty collection.",
          "name" : "startIndex",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/startIndex"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns the distance between two indices.",
          "name" : "distance(from:to:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/distance(from:to:)"
        },
        {
          "description" : "Replaces the given index with its successor.",
          "name" : "formIndex(after:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/formIndex(after:)"
        },
        {
          "description" : "Replaces the given index with its predecessor.",
          "name" : "formIndex(before:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/formIndex(before:)"
        },
        {
          "description" : "Returns an index that is the specified distance from the given index.",
          "name" : "index(_:offsetBy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/index(_:offsetBy:)"
        },
        {
          "description" : "Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.",
          "name" : "index(_:offsetBy:limitedBy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/index(_:offsetBy:limitedBy:)"
        },
        {
          "description" : "Returns the position immediately after the given index.",
          "name" : "index(after:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/index(after:)"
        },
        {
          "description" : "Returns the position immediately before the given index.",
          "name" : "index(before:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/index(before:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Accesses the element at the specified position.",
          "name" : "subscript(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/subscript(_:)-2mluu"
        },
        {
          "description" : "Accesses a contiguous subrange of the collection’s elements.",
          "name" : "subscript(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/RandomAccessCollection\/subscript(_:)-3fc50"
        }
      ],
      "title" : "Subscripts"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A collection that supports backward as well as forward traversal.",
          "name" : "BidirectionalCollection",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BidirectionalCollection"
        }
      ],
      "title" : "Collection Traversal"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "BidirectionalCollection"
        },
        {
          "name" : "Collection"
        },
        {
          "name" : "Sequence"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "RandomAccessCollection",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/randomaccesscollection"
}