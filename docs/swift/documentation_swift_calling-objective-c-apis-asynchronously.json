{
  "abstract" : "Learn how functions and methods that take a completion handler are converted to Swift asynchronous functions.",
  "codeExamples" : [
    {
      "code" : "- (void)presentWithCompletion:(void (^)(BOOL success))completion;",
      "language" : "occ"
    },
    {
      "code" : "func present(completion: ((Bool) -> Void)? = nil)\n\nfunc present() async -> Bool",
      "language" : "swift"
    },
    {
      "code" : "- (void)writeData:(NSData *)data\n          timeout:(NSTimeInterval)timeout\ncompletionHandler:(void (^) (NSError * _Nullable error))completionHandler;",
      "language" : "occ"
    },
    {
      "code" : "func write(\n    _ data: Data, \n    timeout: TimeInterval, \n    completionHandler: @escaping (Error?) -> Void\n)\n\nfunc write(_ data: Data, timeout: TimeInterval) async throws",
      "language" : "swift"
    },
    {
      "code" : "- (void)signData:(NSData *)signData \nwithSecureElementPass:(PKSecureElementPass *)secureElementPass \n      completion:(void (^)(NSData *signedData, NSData *signature, NSError *error))completion;",
      "language" : "occ"
    },
    {
      "code" : "func sign(\n    _ signData: Data, \n    using secureElementPass: PKSecureElementPass, \n    completion: @escaping (Data?, Data?, Error?) -> Void\n)\n\nfunc sign(_ signData: Data, \n    using secureElementPass: PKSecureElementPass\n) async throws -> (Data, Data)",
      "language" : "swift"
    }
  ],
  "contentHash" : "b09a8d43ef2629d41f388934d5006a5cab3ae04b98e92f91fd76bae43866497a",
  "crawledAt" : "2025-12-01T09:23:59Z",
  "id" : "085E64C4-0950-4D43-BFEA-D7FDDF1C86D7",
  "kind" : "article",
  "module" : "Swift",
  "overview" : "## Overview\n\nIn Cocoa, methods that perform asynchronous operations take a completion handler as their last parameter, and the method calls that block after the operation finishes to return a result or an error. Swift 5.5 and later automatically translates Objective-C methods that take completion handlers into asynchronous methods using Swift’s native concurrency support, in addition to importing the callback-based version of the method into Swift. Because both Swift methods have the same behavior, they share the same page in the documentation.\n\nFor information about asynchronous functions, see [https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html] in [https:\/\/docs.swift.org\/swift-book\/].\n\n### Understand How Swift Imports Completion Handlers\n\nSwift imports Objective-C methods that take a completion handler as two related Swift methods: a method that takes a closure, and an asynchronous method that doesn’t take a closure. For example, consider the [doc:\/\/com.apple.documentation\/documentation\/PassKit\/PKPaymentAuthorizationController\/present(completion:)] method from PassKit. In Objective-C, it’s declared like this:\n\nHowever, in Swift, it’s imported as two methods:\n\nThe first version, `present(completion:)`, has a return type of `Void` and takes a completion handler. The second version, `present()`, returns a Boolean value and is an asynchronous method.\n\nMethods whose completion handlers populate a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSError] pointer parameter also become throwing methods in Swift, as described in [doc:\/\/com.apple.Swift\/documentation\/Swift\/about-imported-cocoa-error-parameters]. The `NSError` parameter on an asynchronous throwing method must also be nullable, which indicates that the parameter is used only to communicate an error. For example, consider the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionStreamTask\/write(_:timeout:completionHandler:)] method from [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionStreamTask]. In Objective-C, it’s declared like this:\n\nAs in the previous example, Swift imports this Objective-C method as two methods: an asynchronous method that takes a closure, and an asynchronous throwing method.\n\nMethods whose completion handlers take multiple arguments become methods that return a tuple. For example, the [doc:\/\/com.apple.documentation\/documentation\/PassKit\/PKPassLibrary\/sign(_:using:completion:)] method from PassKit is declared like this in Objective-C:\n\nIn Swift it‘s imported as two methods, an asychronous method that takes a closure and an asynchronous throwing method that returns a tuple:\n\n### Understand the Conversion Rules\n\nThe method that takes a completion handler must meet the following requirements:\n\nIf the method has only one parameter and its selector ends with one of the following suffixes, Swift imports the method as an asynchronous method:\n\nIf the method has more than one parameter, and the last parameter’s selector piece is one of the following, Swift imports the method as an asynchronous method:\n\nThe name of the Swift method is modified from the Objective-C method as follows:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/calling-objective-c-apis-asynchronously\ncrawled: 2025-12-01T09:23:59Z\n---\n\n# Calling Objective-C APIs Asynchronously\n\n**Article**\n\nLearn how functions and methods that take a completion handler are converted to Swift asynchronous functions.\n\n## Overview\n\nIn Cocoa, methods that perform asynchronous operations take a completion handler as their last parameter, and the method calls that block after the operation finishes to return a result or an error. Swift 5.5 and later automatically translates Objective-C methods that take completion handlers into asynchronous methods using Swift’s native concurrency support, in addition to importing the callback-based version of the method into Swift. Because both Swift methods have the same behavior, they share the same page in the documentation.\n\nFor information about asynchronous functions, see [https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/Concurrency.html] in [https:\/\/docs.swift.org\/swift-book\/].\n\n### Understand How Swift Imports Completion Handlers\n\nSwift imports Objective-C methods that take a completion handler as two related Swift methods: a method that takes a closure, and an asynchronous method that doesn’t take a closure. For example, consider the [doc:\/\/com.apple.documentation\/documentation\/PassKit\/PKPaymentAuthorizationController\/present(completion:)] method from PassKit. In Objective-C, it’s declared like this:\n\n```occ\n- (void)presentWithCompletion:(void (^)(BOOL success))completion;\n```\n\nHowever, in Swift, it’s imported as two methods:\n\n```swift\nfunc present(completion: ((Bool) -> Void)? = nil)\n\nfunc present() async -> Bool\n```\n\nThe first version, `present(completion:)`, has a return type of `Void` and takes a completion handler. The second version, `present()`, returns a Boolean value and is an asynchronous method.\n\nMethods whose completion handlers populate a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSError] pointer parameter also become throwing methods in Swift, as described in [doc:\/\/com.apple.Swift\/documentation\/Swift\/about-imported-cocoa-error-parameters]. The `NSError` parameter on an asynchronous throwing method must also be nullable, which indicates that the parameter is used only to communicate an error. For example, consider the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionStreamTask\/write(_:timeout:completionHandler:)] method from [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionStreamTask]. In Objective-C, it’s declared like this:\n\n```occ\n- (void)writeData:(NSData *)data\n          timeout:(NSTimeInterval)timeout\ncompletionHandler:(void (^) (NSError * _Nullable error))completionHandler;\n```\n\nAs in the previous example, Swift imports this Objective-C method as two methods: an asynchronous method that takes a closure, and an asynchronous throwing method.\n\n```swift\nfunc write(\n    _ data: Data, \n    timeout: TimeInterval, \n    completionHandler: @escaping (Error?) -> Void\n)\n\nfunc write(_ data: Data, timeout: TimeInterval) async throws\n```\n\nMethods whose completion handlers take multiple arguments become methods that return a tuple. For example, the [doc:\/\/com.apple.documentation\/documentation\/PassKit\/PKPassLibrary\/sign(_:using:completion:)] method from PassKit is declared like this in Objective-C:\n\n```occ\n- (void)signData:(NSData *)signData \nwithSecureElementPass:(PKSecureElementPass *)secureElementPass \n      completion:(void (^)(NSData *signedData, NSData *signature, NSError *error))completion;\n```\n\nIn Swift it‘s imported as two methods, an asychronous method that takes a closure and an asynchronous throwing method that returns a tuple:\n\n```swift\nfunc sign(\n    _ signData: Data, \n    using secureElementPass: PKSecureElementPass, \n    completion: @escaping (Data?, Data?, Error?) -> Void\n)\n\nfunc sign(_ signData: Data, \n    using secureElementPass: PKSecureElementPass\n) async throws -> (Data, Data)\n```\n\n### Understand the Conversion Rules\n\nThe method that takes a completion handler must meet the following requirements:\n\n- The method has a `void` return type.\n- The block has a `void` return type.\n- The block is called exactly once, on all possible paths of control flow.\n\nIf the method has only one parameter and its selector ends with one of the following suffixes, Swift imports the method as an asynchronous method:\n\n- `WithCompletion`\n- `WithCompletionHandler`\n- `WithCompletionBlock`\n- `WithReplyTo`\n- `WithReply`\n\nIf the method has more than one parameter, and the last parameter’s selector piece is one of the following, Swift imports the method as an asynchronous method:\n\n- `completion`\n- `withCompletion`\n- `completionHandler`\n- `withCompletionHandler`\n- `completionBlock`\n- `withCompletionBlock`\n- `replyTo`\n- `withReplyTo`\n- `reply`\n- `replyTo`\n\nThe name of the Swift method is modified from the Objective-C method as follows:\n\n- The selector piece for the completion handler is removed.\n- If the selector starts with `get`, that prefix is removed and leading initialisms are converted to lowercase.\n- If the selector ends with `Asynchronously`, that suffix is removed.\n- If the method calls its completion handler with a nullable parameter, the asynchronous version in Swift is marked with the `@discardableResult` attribute.\n\n## Language Interoperability with Objective-C and C\n\n- **Objective-C and C Code Customization**: Apply macros to your Objective-C APIs to customize how they’re imported into Swift.\n- **Migrating Your Objective-C Code to Swift**: Learn the recommended steps to migrate your code.\n- **Cocoa Design Patterns**: Adopt and interoperate with Cocoa design patterns in your Swift apps.\n- **Handling Dynamically Typed Methods and Objects in Swift**: Cast instances of the Objective-C `id` type to a specific Swift type.\n- **Using Objective-C Runtime Features in Swift**: Use selectors and key paths to interact with dynamic Objective-C APIs.\n- **Imported C and Objective-C APIs**: Use native Swift syntax to interoperate with types and functions in C and Objective-C.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Apply macros to your Objective-C APIs to customize how they’re imported into Swift.",
          "name" : "Objective-C and C Code Customization",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/objective-c-and-c-code-customization"
        },
        {
          "description" : "Learn the recommended steps to migrate your code.",
          "name" : "Migrating Your Objective-C Code to Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/migrating-your-objective-c-code-to-swift"
        },
        {
          "description" : "Adopt and interoperate with Cocoa design patterns in your Swift apps.",
          "name" : "Cocoa Design Patterns",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/cocoa-design-patterns"
        },
        {
          "description" : "Cast instances of the Objective-C `id` type to a specific Swift type.",
          "name" : "Handling Dynamically Typed Methods and Objects in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/handling-dynamically-typed-methods-and-objects-in-swift"
        },
        {
          "description" : "Use selectors and key paths to interact with dynamic Objective-C APIs.",
          "name" : "Using Objective-C Runtime Features in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/using-objective-c-runtime-features-in-swift"
        },
        {
          "description" : "Use native Swift syntax to interoperate with types and functions in C and Objective-C.",
          "name" : "Imported C and Objective-C APIs",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/imported-c-and-objective-c-apis"
        }
      ],
      "title" : "Language Interoperability with Objective-C and C"
    }
  ],
  "source" : "appleJSON",
  "title" : "Calling Objective-C APIs Asynchronously",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/calling-objective-c-apis-asynchronously"
}