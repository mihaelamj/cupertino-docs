{
  "abstract" : "A type that can be compared for value equality.",
  "codeExamples" : [
    {
      "code" : "let students = [\"Kofi\", \"Abena\", \"Efua\", \"Kweku\", \"Akosua\"]\n\nlet nameToCheck = \"Kofi\"\nif students.contains(nameToCheck) {\n    print(\"\\(nameToCheck) is signed up!\")\n} else {\n    print(\"No record of \\(nameToCheck).\")\n}\n\/\/ Prints \"Kofi is signed up!\"",
      "language" : "swift"
    },
    {
      "code" : "class StreetAddress {\n    let number: String\n    let street: String\n    let unit: String?\n\n    init(_ number: String, _ street: String, unit: String? = nil) {\n        self.number = number\n        self.street = street\n        self.unit = unit\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension StreetAddress: Equatable {\n    static func == (lhs: StreetAddress, rhs: StreetAddress) -> Bool {\n        return\n            lhs.number == rhs.number &&\n            lhs.street == rhs.street &&\n            lhs.unit == rhs.unit\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let addresses = [StreetAddress(\"1490\", \"Grove Street\"),\n                 StreetAddress(\"2119\", \"Maple Avenue\"),\n                 StreetAddress(\"1400\", \"16th Street\")]\nlet home = StreetAddress(\"1400\", \"16th Street\")\n\nprint(addresses[0] == home)\n\/\/ Prints \"false\"\nprint(addresses.contains(home))\n\/\/ Prints \"true\"",
      "language" : "swift"
    },
    {
      "code" : "class IntegerRef: Equatable {\n    let value: Int\n    init(_ value: Int) {\n        self.value = value\n    }\n\n    static func == (lhs: IntegerRef, rhs: IntegerRef) -> Bool {\n        return lhs.value == rhs.value\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let a = IntegerRef(100)\nlet b = IntegerRef(100)\n\nprint(a == a, a == b, separator: \", \")\n\/\/ Prints \"true, true\"",
      "language" : "swift"
    },
    {
      "code" : "let c = a\nprint(c === a, c === b, separator: \", \")\n\/\/ Prints \"true, false\"",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "AnyHashable",
    "AnyIndex",
    "AnyKeyPath",
    "Array",
    "ArraySlice",
    "AsyncStream.Continuation",
    "AsyncStream.Continuation.Termination",
    "AsyncThrowingStream.Continuation",
    "AtomicLoadOrdering",
    "AtomicStoreOrdering",
    "AtomicUpdateOrdering",
    "AutoreleasingUnsafeMutablePointer",
    "Bool",
    "Character",
    "ClosedRange",
    "ClosedRange.Index",
    "CodingUserInfoKey",
    "CollectionDifference",
    "CollectionDifference.Change",
    "CollectionDifference.Index",
    "ContiguousArray",
    "ContinuousClock.Instant",
    "Dictionary",
    "Dictionary.Index",
    "Dictionary.Keys",
    "DiscontiguousSlice",
    "DiscontiguousSlice.Index",
    "Double",
    "Duration",
    "Duration.TimeFormatStyle",
    "Duration.TimeFormatStyle.Attributed",
    "Duration.TimeFormatStyle.Pattern",
    "Duration.UnitsFormatStyle",
    "Duration.UnitsFormatStyle.Attributed",
    "Duration.UnitsFormatStyle.FractionalPartDisplayStrategy",
    "Duration.UnitsFormatStyle.Unit",
    "Duration.UnitsFormatStyle.UnitWidth",
    "Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy",
    "EmptyCollection",
    "EnumeratedSequence.Index",
    "ExecuteDistributedTargetError.ErrorCode",
    "FlattenSequence.Index",
    "Float",
    "Float16",
    "Float80",
    "FloatingPointClassification",
    "FloatingPointRoundingRule",
    "FloatingPointSign",
    "Int",
    "Int128",
    "Int16",
    "Int32",
    "Int64",
    "Int8",
    "JobPriority",
    "KeyPath",
    "LazyPrefixWhileSequence.Index",
    "LocalTestingActorID",
    "ManagedBufferPointer",
    "Mirror.DisplayStyle",
    "Never",
    "ObjectIdentifier",
    "ObservationRegistrar",
    "OpaquePointer",
    "Optional",
    "Optional.Publisher",
    "PartialKeyPath",
    "Range",
    "RangeSet",
    "RangeSet.Ranges",
    "ReferenceWritableKeyPath",
    "RegexRepetitionBehavior",
    "RegexSemanticLevel",
    "RegexWordBoundaryKind",
    "RemoteCallTarget",
    "Result",
    "Result.Publisher",
    "ReversedCollection.Index",
    "SIMD16",
    "SIMD2",
    "SIMD3",
    "SIMD32",
    "SIMD4",
    "SIMD64",
    "SIMD8",
    "SIMDMask",
    "Set",
    "Set.Index",
    "String",
    "String.Comparator",
    "String.Encoding",
    "String.Index",
    "String.IntentInputOptions.CapitalizationType",
    "String.IntentInputOptions.KeyboardType",
    "String.LocalizationValue",
    "String.LocalizationValue.Placeholder",
    "String.StandardComparator",
    "Substring",
    "SuspendingClock.Instant",
    "Task",
    "TaskPriority",
    "UInt",
    "UInt128",
    "UInt16",
    "UInt32",
    "UInt64",
    "UInt8",
    "Unicode.CanonicalCombiningClass",
    "Unicode.GeneralCategory",
    "Unicode.NumericType",
    "Unicode.Scalar",
    "Unicode.UTF32",
    "Unicode.UTF8.ValidationError",
    "Unicode.UTF8.ValidationError.Kind",
    "UnicodeDecodingResult",
    "UnownedTaskExecutor",
    "UnsafeCurrentTask",
    "UnsafeMutablePointer",
    "UnsafeMutableRawPointer",
    "UnsafePointer",
    "UnsafeRawPointer",
    "WordPair",
    "WritableKeyPath"
  ],
  "contentHash" : "6b466a3ab84e6ea4604d2e0cab6b8ef3d8efcf6369b176e99a3efac08db33701",
  "crawledAt" : "2025-12-02T18:07:21Z",
  "declaration" : {
    "code" : "protocol Equatable",
    "language" : "swift"
  },
  "id" : "3BBF54BC-E123-455D-B3D0-365C64E81C4E",
  "inheritedBy" : [
    "AdditiveArithmetic",
    "BinaryFloatingPoint",
    "BinaryInteger",
    "Comparable",
    "DistributedActor",
    "DurationProtocol",
    "FixedWidthInteger",
    "FloatingPoint",
    "Hashable",
    "InstantProtocol",
    "Numeric",
    "OptionSet",
    "SIMD",
    "SetAlgebra",
    "SignedInteger",
    "SignedNumeric",
    "Strideable",
    "StringProtocol",
    "UnsignedInteger"
  ],
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nTypes that conform to the `Equatable` protocol can be compared for equality using the equal-to operator (`==`) or inequality using the not-equal-to operator (`!=`). Most basic types in the Swift standard library conform to `Equatable`.\n\nSome sequence and collection operations can be used more simply when the elements conform to `Equatable`. For example, to check whether an array contains a particular value, you can pass the value itself to the `contains(_:)` method when the array’s element conforms to `Equatable` instead of providing a closure that determines equivalence. The following example shows how the `contains(_:)` method can be used with an array of strings.\n\n# Conforming to the Equatable Protocol\n\nAdding `Equatable` conformance to your custom types means that you can use more convenient APIs when searching for particular instances in a collection. `Equatable` is also the base protocol for the `Hashable` and `Comparable` protocols, which allow more uses of your custom type, such as constructing sets or sorting the elements of a collection.\n\nYou can rely on automatic synthesis of the `Equatable` protocol’s requirements for a custom type when you declare `Equatable` conformance in the type’s original declaration and your type meets these criteria:\n\nTo customize your type’s `Equatable` conformance, to adopt `Equatable` in a type that doesn’t meet the criteria listed above, or to extend an existing type to conform to `Equatable`, implement the equal-to operator (`==`) as a static method of your type. The standard library provides an implementation for the not-equal-to operator (`!=`) for any `Equatable` type, which calls the custom `==` function and negates its result.\n\nAs an example, consider a `StreetAddress` class that holds the parts of a street address: a house or building number, the street name, and an optional unit number. Here’s the initial declaration of the `StreetAddress` type:\n\nNow suppose you have an array of addresses that you need to check for a particular address. To use the `contains(_:)` method without including a closure in each call, extend the `StreetAddress` type to conform to `Equatable`.\n\nThe `StreetAddress` type now conforms to `Equatable`. You can use `==` to check for equality between any two instances or call the `Equatable`-constrained `contains(_:)` method.\n\nEquality implies substitutability—any two instances that compare equally can be used interchangeably in any code that depends on their values. To maintain substitutability, the `==` operator should take into account all visible aspects of an `Equatable` type. Exposing nonvalue aspects of `Equatable` types other than class identity is discouraged, and any that *are* exposed should be explicitly pointed out in documentation.\n\nSince equality between instances of `Equatable` types is an equivalence relation, any of your custom types that conform to `Equatable` must satisfy three conditions, for any values `a`, `b`, and `c`:\n\nMoreover, inequality is the inverse of equality, so any custom implementation of the `!=` operator must guarantee that `a != b` implies `!(a == b)`. The default implementation of the `!=` operator function satisfies this requirement.\n\n## Equality is Separate From Identity\n\nThe identity of a class instance is not part of an instance’s value. Consider a class called `IntegerRef` that wraps an integer value. Here’s the definition for `IntegerRef` and the `==` function that makes it conform to `Equatable`:\n\nThe implementation of the `==` function returns the same value whether its two arguments are the same instance or are two different instances with the same integer stored in their `value` properties. For example:\n\nClass instance identity, on the other hand, is compared using the triple-equals identical-to operator (`===`). For example:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/Equatable\ncrawled: 2025-12-02T18:07:21Z\n---\n\n# Equatable\n\n**Protocol**\n\nA type that can be compared for value equality.\n\n## Declaration\n\n```swift\nprotocol Equatable\n```\n\n## Overview\n\nTypes that conform to the `Equatable` protocol can be compared for equality using the equal-to operator (`==`) or inequality using the not-equal-to operator (`!=`). Most basic types in the Swift standard library conform to `Equatable`.\n\nSome sequence and collection operations can be used more simply when the elements conform to `Equatable`. For example, to check whether an array contains a particular value, you can pass the value itself to the `contains(_:)` method when the array’s element conforms to `Equatable` instead of providing a closure that determines equivalence. The following example shows how the `contains(_:)` method can be used with an array of strings.\n\n```swift\nlet students = [\"Kofi\", \"Abena\", \"Efua\", \"Kweku\", \"Akosua\"]\n\nlet nameToCheck = \"Kofi\"\nif students.contains(nameToCheck) {\n    print(\"\\(nameToCheck) is signed up!\")\n} else {\n    print(\"No record of \\(nameToCheck).\")\n}\n\/\/ Prints \"Kofi is signed up!\"\n```\n\n# Conforming to the Equatable Protocol\n\nAdding `Equatable` conformance to your custom types means that you can use more convenient APIs when searching for particular instances in a collection. `Equatable` is also the base protocol for the `Hashable` and `Comparable` protocols, which allow more uses of your custom type, such as constructing sets or sorting the elements of a collection.\n\nYou can rely on automatic synthesis of the `Equatable` protocol’s requirements for a custom type when you declare `Equatable` conformance in the type’s original declaration and your type meets these criteria:\n\n- For a `struct`, all its stored properties must conform to `Equatable`.\n- For an `enum`, all its associated values must conform to `Equatable`. (An `enum` without associated values has `Equatable` conformance even without the declaration.)\n\nTo customize your type’s `Equatable` conformance, to adopt `Equatable` in a type that doesn’t meet the criteria listed above, or to extend an existing type to conform to `Equatable`, implement the equal-to operator (`==`) as a static method of your type. The standard library provides an implementation for the not-equal-to operator (`!=`) for any `Equatable` type, which calls the custom `==` function and negates its result.\n\nAs an example, consider a `StreetAddress` class that holds the parts of a street address: a house or building number, the street name, and an optional unit number. Here’s the initial declaration of the `StreetAddress` type:\n\n```swift\nclass StreetAddress {\n    let number: String\n    let street: String\n    let unit: String?\n\n    init(_ number: String, _ street: String, unit: String? = nil) {\n        self.number = number\n        self.street = street\n        self.unit = unit\n    }\n}\n```\n\nNow suppose you have an array of addresses that you need to check for a particular address. To use the `contains(_:)` method without including a closure in each call, extend the `StreetAddress` type to conform to `Equatable`.\n\n```swift\nextension StreetAddress: Equatable {\n    static func == (lhs: StreetAddress, rhs: StreetAddress) -> Bool {\n        return\n            lhs.number == rhs.number &&\n            lhs.street == rhs.street &&\n            lhs.unit == rhs.unit\n    }\n}\n```\n\nThe `StreetAddress` type now conforms to `Equatable`. You can use `==` to check for equality between any two instances or call the `Equatable`-constrained `contains(_:)` method.\n\n```swift\nlet addresses = [StreetAddress(\"1490\", \"Grove Street\"),\n                 StreetAddress(\"2119\", \"Maple Avenue\"),\n                 StreetAddress(\"1400\", \"16th Street\")]\nlet home = StreetAddress(\"1400\", \"16th Street\")\n\nprint(addresses[0] == home)\n\/\/ Prints \"false\"\nprint(addresses.contains(home))\n\/\/ Prints \"true\"\n```\n\nEquality implies substitutability—any two instances that compare equally can be used interchangeably in any code that depends on their values. To maintain substitutability, the `==` operator should take into account all visible aspects of an `Equatable` type. Exposing nonvalue aspects of `Equatable` types other than class identity is discouraged, and any that *are* exposed should be explicitly pointed out in documentation.\n\nSince equality between instances of `Equatable` types is an equivalence relation, any of your custom types that conform to `Equatable` must satisfy three conditions, for any values `a`, `b`, and `c`:\n\n- `a == a` is always `true` (Reflexivity)\n- `a == b` implies `b == a` (Symmetry)\n- `a == b` and `b == c` implies `a == c` (Transitivity)\n\nMoreover, inequality is the inverse of equality, so any custom implementation of the `!=` operator must guarantee that `a != b` implies `!(a == b)`. The default implementation of the `!=` operator function satisfies this requirement.\n\n## Equality is Separate From Identity\n\nThe identity of a class instance is not part of an instance’s value. Consider a class called `IntegerRef` that wraps an integer value. Here’s the definition for `IntegerRef` and the `==` function that makes it conform to `Equatable`:\n\n```swift\nclass IntegerRef: Equatable {\n    let value: Int\n    init(_ value: Int) {\n        self.value = value\n    }\n\n    static func == (lhs: IntegerRef, rhs: IntegerRef) -> Bool {\n        return lhs.value == rhs.value\n    }\n}\n```\n\nThe implementation of the `==` function returns the same value whether its two arguments are the same instance or are two different instances with the same integer stored in their `value` properties. For example:\n\n```swift\nlet a = IntegerRef(100)\nlet b = IntegerRef(100)\n\nprint(a == a, a == b, separator: \", \")\n\/\/ Prints \"true, true\"\n```\n\nClass instance identity, on the other hand, is compared using the triple-equals identical-to operator (`===`). For example:\n\n```swift\nlet c = a\nprint(c === a, c === b, separator: \", \")\n\/\/ Prints \"true, false\"\n```\n\n## Equatable Requirements\n\n- **==(_:_:)**: Returns a Boolean value indicating whether two values are equal.\n- **!=(_:_:)**: Returns a Boolean value indicating whether two values are not equal.\n\n## Tuple Comparison\n\n- **==(_:_:)**: Returns a Boolean value indicating whether the corresponding components of two tuples are equal.\n- **==(_:_:)**: Returns a Boolean value indicating whether the corresponding components of two tuples are equal.\n- **==(_:_:)**: Returns a Boolean value indicating whether the corresponding components of two tuples are equal.\n- **==(_:_:)**: Returns a Boolean value indicating whether the corresponding components of two tuples are equal.\n- **==(_:_:)**: Returns a Boolean value indicating whether the corresponding components of two tuples are equal.\n- **==(_:_:)**: Returns a Boolean value indicating whether the corresponding components of two tuples are equal.\n- **==(_:_:)**: Returns a Boolean value indicating whether two types are identical.\n- **!=(_:_:)**: Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.\n- **!=(_:_:)**: Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.\n- **!=(_:_:)**: Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.\n- **!=(_:_:)**: Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.\n- **!=(_:_:)**: Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.\n- **!=(_:_:)**: Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.\n- **!=(_:_:)**: Returns a Boolean value indicating whether two types are not identical.\n\n## Pattern Matching\n\n- **~=(_:_:)**: Returns a Boolean value indicating whether two arguments match by value equality.\n\n## Equality and Ordering\n\n- **Comparable**: A type that can be compared using the relational operators `<`, `<=`, `>=`, and `>`.\n- **Identifiable**: A class of types whose instances hold the value of an entity with stable identity.\n\n## Inherited By\n\n- AdditiveArithmetic\n- BinaryFloatingPoint\n- BinaryInteger\n- Comparable\n- DistributedActor\n- DurationProtocol\n- FixedWidthInteger\n- FloatingPoint\n- Hashable\n- InstantProtocol\n- Numeric\n- OptionSet\n- SIMD\n- SetAlgebra\n- SignedInteger\n- SignedNumeric\n- Strideable\n- StringProtocol\n- UnsignedInteger\n\n## Conforming Types\n\n- AnyHashable\n- AnyIndex\n- AnyKeyPath\n- Array\n- ArraySlice\n- AsyncStream.Continuation\n- AsyncStream.Continuation.Termination\n- AsyncThrowingStream.Continuation\n- AtomicLoadOrdering\n- AtomicStoreOrdering\n- AtomicUpdateOrdering\n- AutoreleasingUnsafeMutablePointer\n- Bool\n- Character\n- ClosedRange\n- ClosedRange.Index\n- CodingUserInfoKey\n- CollectionDifference\n- CollectionDifference.Change\n- CollectionDifference.Index\n- ContiguousArray\n- ContinuousClock.Instant\n- Dictionary\n- Dictionary.Index\n- Dictionary.Keys\n- DiscontiguousSlice\n- DiscontiguousSlice.Index\n- Double\n- Duration\n- Duration.TimeFormatStyle\n- Duration.TimeFormatStyle.Attributed\n- Duration.TimeFormatStyle.Pattern\n- Duration.UnitsFormatStyle\n- Duration.UnitsFormatStyle.Attributed\n- Duration.UnitsFormatStyle.FractionalPartDisplayStrategy\n- Duration.UnitsFormatStyle.Unit\n- Duration.UnitsFormatStyle.UnitWidth\n- Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy\n- EmptyCollection\n- EnumeratedSequence.Index\n- ExecuteDistributedTargetError.ErrorCode\n- FlattenSequence.Index\n- Float\n- Float16\n- Float80\n- FloatingPointClassification\n- FloatingPointRoundingRule\n- FloatingPointSign\n- Int\n- Int128\n- Int16\n- Int32\n- Int64\n- Int8\n- JobPriority\n- KeyPath\n- LazyPrefixWhileSequence.Index\n- LocalTestingActorID\n- ManagedBufferPointer\n- Mirror.DisplayStyle\n- Never\n- ObjectIdentifier\n- ObservationRegistrar\n- OpaquePointer\n- Optional\n- Optional.Publisher\n- PartialKeyPath\n- Range\n- RangeSet\n- RangeSet.Ranges\n- ReferenceWritableKeyPath\n- RegexRepetitionBehavior\n- RegexSemanticLevel\n- RegexWordBoundaryKind\n- RemoteCallTarget\n- Result\n- Result.Publisher\n- ReversedCollection.Index\n- SIMD16\n- SIMD2\n- SIMD3\n- SIMD32\n- SIMD4\n- SIMD64\n- SIMD8\n- SIMDMask\n- Set\n- Set.Index\n- String\n- String.Comparator\n- String.Encoding\n- String.Index\n- String.IntentInputOptions.CapitalizationType\n- String.IntentInputOptions.KeyboardType\n- String.LocalizationValue\n- String.LocalizationValue.Placeholder\n- String.StandardComparator\n- Substring\n- SuspendingClock.Instant\n- Task\n- TaskPriority\n- UInt\n- UInt128\n- UInt16\n- UInt32\n- UInt64\n- UInt8\n- Unicode.CanonicalCombiningClass\n- Unicode.GeneralCategory\n- Unicode.NumericType\n- Unicode.Scalar\n- Unicode.UTF32\n- Unicode.UTF8.ValidationError\n- Unicode.UTF8.ValidationError.Kind\n- UnicodeDecodingResult\n- UnownedTaskExecutor\n- UnsafeCurrentTask\n- UnsafeMutablePointer\n- UnsafeMutableRawPointer\n- UnsafePointer\n- UnsafeRawPointer\n- WordPair\n- WritableKeyPath\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a Boolean value indicating whether two values are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Equatable\/==(_:_:)"
        },
        {
          "description" : "Returns a Boolean value indicating whether two values are not equal.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Equatable\/!=(_:_:)"
        }
      ],
      "title" : "Equatable Requirements"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a Boolean value indicating whether the corresponding components of two tuples are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/==(_:_:)-958in"
        },
        {
          "description" : "Returns a Boolean value indicating whether the corresponding components of two tuples are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/==(_:_:)-2htbb"
        },
        {
          "description" : "Returns a Boolean value indicating whether the corresponding components of two tuples are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/==(_:_:)-h88g"
        },
        {
          "description" : "Returns a Boolean value indicating whether the corresponding components of two tuples are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/==(_:_:)-7lhq7"
        },
        {
          "description" : "Returns a Boolean value indicating whether the corresponding components of two tuples are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/==(_:_:)-1hbor"
        },
        {
          "description" : "Returns a Boolean value indicating whether the corresponding components of two tuples are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/==(_:_:)-1ud2a"
        },
        {
          "description" : "Returns a Boolean value indicating whether two types are identical.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/==(_:_:)-9kf9y"
        },
        {
          "description" : "Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/!=(_:_:)-18co7"
        },
        {
          "description" : "Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/!=(_:_:)-7er1l"
        },
        {
          "description" : "Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/!=(_:_:)-754t2"
        },
        {
          "description" : "Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/!=(_:_:)-7ao4l"
        },
        {
          "description" : "Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/!=(_:_:)-4fzl6"
        },
        {
          "description" : "Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/!=(_:_:)-3nrcc"
        },
        {
          "description" : "Returns a Boolean value indicating whether two types are not identical.",
          "name" : "!=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/!=(_:_:)-1mxms"
        }
      ],
      "title" : "Tuple Comparison"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a Boolean value indicating whether two arguments match by value equality.",
          "name" : "~=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/~=(_:_:)"
        }
      ],
      "title" : "Pattern Matching"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that can be compared using the relational operators `<`, `<=`, `>=`, and `>`.",
          "name" : "Comparable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Comparable"
        },
        {
          "description" : "A class of types whose instances hold the value of an entity with stable identity.",
          "name" : "Identifiable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Identifiable"
        }
      ],
      "title" : "Equality and Ordering"
    }
  ],
  "source" : "appleJSON",
  "title" : "Equatable",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Equatable"
}