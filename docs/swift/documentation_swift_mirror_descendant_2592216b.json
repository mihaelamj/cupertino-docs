{
  "abstract" : "Returns a specific descendant of the reflected subject, or `nil` if no such descendant exists.",
  "codeExamples" : [
    {
      "code" : "var result: Any? = nil\nlet children = myMirror.children\nif let i0 = children.index(\n    children.startIndex, offsetBy: 1, limitedBy: children.endIndex),\n    i0 != children.endIndex\n{\n    let grandChildren = Mirror(reflecting: children[i0].value).children\n    if let i1 = grandChildren.firstIndex(where: { $0.label == \"two\" }) {\n        let greatGrandChildren =\n            Mirror(reflecting: grandChildren[i1].value).children\n        if let i2 = greatGrandChildren.index(\n            greatGrandChildren.startIndex,\n            offsetBy: 3,\n            limitedBy: greatGrandChildren.endIndex),\n            i2 != greatGrandChildren.endIndex\n        {\n            \/\/ Success!\n            result = greatGrandChildren[i2].value\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "485a6f3ca53dedd4704327d4d5247cf26e17467632627794fa4aa6dfe61de4bb",
  "crawledAt" : "2025-12-03T16:20:53Z",
  "declaration" : {
    "code" : "func descendant(_ first: any MirrorPath, _ rest: any MirrorPath...) -> Any?",
    "language" : "swift"
  },
  "id" : "ED515EC9-CFD6-4D3C-A4B8-53032E6FF66E",
  "kind" : "method",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nThe descendant of this mirror specified by the given mirror path components if such a descendant exists; otherwise, `nil`.\n\n## Discussion\n\nPass a variadic list of string and integer arguments. Each string argument selects the first child with a matching label. Each integer argument selects the child at that offset. For example, passing `1, \"two\", 3` as arguments to `myMirror.descendant(_:_:)` is equivalent to:\n\nThis function is suitable for exploring the structure of a mirror in a REPL or playground, but is not intended to be efficient. The efficiency of finding each element in the argument list depends on the argument type and the capabilities of the each level of the mirror’s `children` collections. Each string argument requires a linear search, and unless the underlying collection supports random-access traversal, each integer argument also requires a linear operation.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/Mirror\/descendant(_:_:)\ncrawled: 2025-12-03T16:20:53Z\n---\n\n# descendant(_:_:)\n\n**Instance Method**\n\nReturns a specific descendant of the reflected subject, or `nil` if no such descendant exists.\n\n## Declaration\n\n```swift\nfunc descendant(_ first: any MirrorPath, _ rest: any MirrorPath...) -> Any?\n```\n\n## Parameters\n\n- **first**: The first mirror path component to access.\n- **rest**: Any remaining mirror path components.\n\n## Return Value\n\nThe descendant of this mirror specified by the given mirror path components if such a descendant exists; otherwise, `nil`.\n\n## Discussion\n\nPass a variadic list of string and integer arguments. Each string argument selects the first child with a matching label. Each integer argument selects the child at that offset. For example, passing `1, \"two\", 3` as arguments to `myMirror.descendant(_:_:)` is equivalent to:\n\n```swift\nvar result: Any? = nil\nlet children = myMirror.children\nif let i0 = children.index(\n    children.startIndex, offsetBy: 1, limitedBy: children.endIndex),\n    i0 != children.endIndex\n{\n    let grandChildren = Mirror(reflecting: children[i0].value).children\n    if let i1 = grandChildren.firstIndex(where: { $0.label == \"two\" }) {\n        let greatGrandChildren =\n            Mirror(reflecting: grandChildren[i1].value).children\n        if let i2 = greatGrandChildren.index(\n            greatGrandChildren.startIndex,\n            offsetBy: 3,\n            limitedBy: greatGrandChildren.endIndex),\n            i2 != greatGrandChildren.endIndex\n        {\n            \/\/ Success!\n            result = greatGrandChildren[i2].value\n        }\n    }\n}\n```\n\nThis function is suitable for exploring the structure of a mirror in a REPL or playground, but is not intended to be efficient. The efficiency of finding each element in the argument list depends on the argument type and the capabilities of the each level of the mirror’s `children` collections. Each string argument requires a linear search, and unless the underlying collection supports random-access traversal, each integer argument also requires a linear operation.\n\n## Querying Descendants\n\n- **MirrorPath**: A protocol for legitimate arguments to `Mirror`’s `descendant` method.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A protocol for legitimate arguments to `Mirror`’s `descendant` method.",
          "name" : "MirrorPath",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/MirrorPath"
        }
      ],
      "title" : "Querying Descendants"
    }
  ],
  "source" : "appleJSON",
  "title" : "descendant(_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Mirror\/descendant(_:_:)"
}