{
  "abstract" : "Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.",
  "codeExamples" : [
    {
      "code" : "enum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    \/\/ Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n    \/\/ All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n    \/\/ Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n\/\/ Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"",
      "language" : "swift"
    },
    {
      "code" : "let students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n\/\/ Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"",
      "language" : "swift"
    },
    {
      "code" : "print(students.sorted())\n\/\/ Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n\/\/ Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"",
      "language" : "swift"
    }
  ],
  "contentHash" : "2f5ded1f29f2d1333bf5bd1c39deed21986540e7c40b7765c53244a93dfbe9ce",
  "crawledAt" : "2025-12-05T22:24:06Z",
  "declaration" : {
    "code" : "func sorted(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]",
    "language" : "swift"
  },
  "id" : "4F59127A-0AF3-4551-BA30-9BE2E6D58ECE",
  "kind" : "method",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nA sorted array of the sequence’s elements.\n\n## Discussion\n\nWhen you want to sort a sequence of elements that don’t conform to the `Comparable` protocol, pass a predicate to this method that returns `true` when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom `HTTPResponse` type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nYou also use this method to sort elements that conform to the `Comparable` protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (`>`) as the `areInIncreasingOrder` parameter.\n\nCalling the related `sorted()` method is equivalent to calling this method and passing the less-than operator (`<`) as the predicate.\n\nThe predicate must be a *strict weak ordering* over the elements. That is, for any elements `a`, `b`, and `c`, the following conditions must hold:\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which `areInIncreasingOrder` does not establish an order.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/reversedcollection\/sorted(by:)\ncrawled: 2025-12-05T22:24:06Z\n---\n\n# sorted(by:)\n\n**Instance Method**\n\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\n\n## Declaration\n\n```swift\nfunc sorted(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\n```\n\n## Parameters\n\n- **areInIncreasingOrder**: A predicate that returns `true` if its first argument should be ordered before its second argument; otherwise, `false`.\n\n## Return Value\n\nA sorted array of the sequence’s elements.\n\n## Discussion\n\nWhen you want to sort a sequence of elements that don’t conform to the `Comparable` protocol, pass a predicate to this method that returns `true` when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom `HTTPResponse` type. The predicate orders errors before successes and sorts the error responses by their error code.\n\n```swift\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    \/\/ Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n    \/\/ All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n    \/\/ Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n\/\/ Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n```\n\nYou also use this method to sort elements that conform to the `Comparable` protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (`>`) as the `areInIncreasingOrder` parameter.\n\n```swift\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n\/\/ Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n```\n\nCalling the related `sorted()` method is equivalent to calling this method and passing the less-than operator (`<`) as the predicate.\n\n```swift\nprint(students.sorted())\n\/\/ Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n\/\/ Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n```\n\nThe predicate must be a *strict weak ordering* over the elements. That is, for any elements `a`, `b`, and `c`, the following conditions must hold:\n\n- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)\n- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are both `true`, then `areInIncreasingOrder(a, c)` is also `true`. (Transitive comparability)\n- Two elements are *incomparable* if neither is ordered before the other according to the predicate. If `a` and `b` are incomparable, and `b` and `c` are incomparable, then `a` and `c` are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which `areInIncreasingOrder` does not establish an order.\n\n\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "sorted(by:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/reversedcollection\/sorted(by:)"
}