{
  "abstract" : "Vend results as part of an API when you can’t return errors synchronously.",
  "codeExamples" : [
    {
      "code" : "let queue = DispatchQueue(label: \"com.example.queue\")\n\nenum EntropyError: Error {\n    case entropyDepleted\n}\n\nstruct AsyncRandomGenerator {\n    static let entropyLimit = 5\n    var count = 0\n\n    mutating func fetchRemoteRandomNumber(\n        completion: @escaping (Result<Int, EntropyError>) -> Void\n    ) {\n        let result: Result<Int, EntropyError>\n        if count < AsyncRandomGenerator.entropyLimit {\n            \/\/ Produce numbers until reaching the entropy limit.\n            result = .success(Int.random(in: 1...100))\n        } else {\n            \/\/ Supply a failure reason when the caller hits the limit.\n            result = .failure(.entropyDepleted)\n        }\n\n        count += 1\n\n        \/\/ Delay to simulate an asynchronous source of entropy.\n        queue.asyncAfter(deadline: .now() + 2) {\n            completion(result)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var generator = AsyncRandomGenerator()\n\n\/\/ Request one more number than the limit to trigger a failure.\n(0..<AsyncRandomGenerator.entropyLimit + 1).forEach { _ in\n    generator.fetchRemoteRandomNumber { result in\n        switch result {\n        case .success(let number):\n            print(number)\n        case .failure(let error):\n            print(\"Source of randomness failed: \\(error)\")\n        }\n    }\n}\n\nprint(\"Waiting on some numbers.\")\n\ndispatchMain()\n\/* Prints:\nsuccess(29)\nsuccess(46)\nsuccess(85)\nsuccess(39)\nsuccess(84)\nSource of randomness failed: entropyDepleted\n*\/",
      "language" : "swift"
    }
  ],
  "contentHash" : "7c9a9f543e13f236ec46c0cbf41fdd89fdc0fa5080fcbd574670ddfeb5b23a55",
  "crawledAt" : "2025-12-04T11:29:45Z",
  "id" : "CCB9FA18-7D7E-404E-87A1-6FE86DE5DAD4",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nWhen writing a function, method, or other API that might fail, you use the `throws` keyword on the declaration to indicate that the API call can throw an error. However, you can’t use the `throws` keyword to model APIs that return asynchronously. Instead, use the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result] enumeration to capture information about whether an asychronous call succeeds or fails, and use the associated values for the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/success(_:)] and [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/failure(_:)] cases to carry information about the result of the call.\n\n### Return Result Instances Asynchronously\n\nThe following example models an asynchronous source of random numbers. The `fetchRemoteRandomNumber(completion:)` method returns `Void` synchronously, and asynchronously calls a completion handler with a `Result<Int, EntropyError>` instance that contains either a random result or information about the failure.\n\nUsers of your remote random number generator can decide how to handle both the success and failure cases:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/writing-failable-asynchronous-apis\ncrawled: 2025-12-04T11:29:45Z\n---\n\n# Writing Failable Asynchronous APIs\n\n**Article**\n\nVend results as part of an API when you can’t return errors synchronously.\n\n## Overview\n\nWhen writing a function, method, or other API that might fail, you use the `throws` keyword on the declaration to indicate that the API call can throw an error. However, you can’t use the `throws` keyword to model APIs that return asynchronously. Instead, use the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result] enumeration to capture information about whether an asychronous call succeeds or fails, and use the associated values for the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/success(_:)] and [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/failure(_:)] cases to carry information about the result of the call.\n\n### Return Result Instances Asynchronously\n\nThe following example models an asynchronous source of random numbers. The `fetchRemoteRandomNumber(completion:)` method returns `Void` synchronously, and asynchronously calls a completion handler with a `Result<Int, EntropyError>` instance that contains either a random result or information about the failure.\n\n```swift\nlet queue = DispatchQueue(label: \"com.example.queue\")\n\nenum EntropyError: Error {\n    case entropyDepleted\n}\n\nstruct AsyncRandomGenerator {\n    static let entropyLimit = 5\n    var count = 0\n\n    mutating func fetchRemoteRandomNumber(\n        completion: @escaping (Result<Int, EntropyError>) -> Void\n    ) {\n        let result: Result<Int, EntropyError>\n        if count < AsyncRandomGenerator.entropyLimit {\n            \/\/ Produce numbers until reaching the entropy limit.\n            result = .success(Int.random(in: 1...100))\n        } else {\n            \/\/ Supply a failure reason when the caller hits the limit.\n            result = .failure(.entropyDepleted)\n        }\n\n        count += 1\n\n        \/\/ Delay to simulate an asynchronous source of entropy.\n        queue.asyncAfter(deadline: .now() + 2) {\n            completion(result)\n        }\n    }\n}\n```\n\nUsers of your remote random number generator can decide how to handle both the success and failure cases:\n\n```swift\nvar generator = AsyncRandomGenerator()\n\n\/\/ Request one more number than the limit to trigger a failure.\n(0..<AsyncRandomGenerator.entropyLimit + 1).forEach { _ in\n    generator.fetchRemoteRandomNumber { result in\n        switch result {\n        case .success(let number):\n            print(number)\n        case .failure(let error):\n            print(\"Source of randomness failed: \\(error)\")\n        }\n    }\n}\n\nprint(\"Waiting on some numbers.\")\n\ndispatchMain()\n\/* Prints:\nsuccess(29)\nsuccess(46)\nsuccess(85)\nsuccess(39)\nsuccess(84)\nSource of randomness failed: entropyDepleted\n*\/\n```\n\n## Representing a Result\n\n- **Result.success(_:)**: A success, storing a `Success` value.\n- **Result.failure(_:)**: A failure, storing a `Failure` value.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A success, storing a `Success` value.",
          "name" : "Result.success(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Result\/success(_:)"
        },
        {
          "description" : "A failure, storing a `Failure` value.",
          "name" : "Result.failure(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Result\/failure(_:)"
        }
      ],
      "title" : "Representing a Result"
    }
  ],
  "source" : "appleJSON",
  "title" : "Writing Failable Asynchronous APIs",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/writing-failable-asynchronous-apis"
}