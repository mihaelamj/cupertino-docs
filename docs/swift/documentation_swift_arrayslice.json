{
  "abstract" : "A slice of an `Array`, `ContiguousArray`, or `ArraySlice` instance.",
  "codeExamples" : [
    {
      "code" : "let absences = [0, 2, 0, 4, 0, 3, 1, 0]",
      "language" : "swift"
    },
    {
      "code" : "let midpoint = absences.count \/ 2\n\nlet firstHalf = absences[..<midpoint]\nlet secondHalf = absences[midpoint...]",
      "language" : "swift"
    },
    {
      "code" : "let firstHalfSum = firstHalf.reduce(0, +)\nlet secondHalfSum = secondHalf.reduce(0, +)\n\nif firstHalfSum > secondHalfSum {\n    print(\"More absences in the first half.\")\n} else {\n    print(\"More absences in the second half.\")\n}\n\/\/ Prints \"More absences in the first half.\"",
      "language" : "swift"
    },
    {
      "code" : "if let i = absences.firstIndex(where: { $0 > 0 }) {                 \/\/ 1\n    let absencesAfterFirst = absences[(i + 1)...]                   \/\/ 2\n    if let j = absencesAfterFirst.firstIndex(where: { $0 > 0 }) {   \/\/ 3\n        print(\"The first day with absences had \\(absences[i]).\")    \/\/ 4\n        print(\"The second day with absences had \\(absences[j]).\")\n    }\n}\n\/\/ Prints \"The first day with absences had 2.\"\n\/\/ Prints \"The second day with absences had 4.\"",
      "language" : "swift"
    }
  ],
  "conformsTo" : [
    "AccelerateBuffer",
    "AccelerateMutableBuffer",
    "Attachable",
    "BNNSGraph.Builder.OperationParameter",
    "BidirectionalCollection",
    "Collection",
    "ContiguousBytes",
    "Copyable",
    "CustomDebugStringConvertible",
    "CustomReflectable",
    "CustomStringConvertible",
    "DataProtocol",
    "Equatable",
    "ExpressibleByArrayLiteral",
    "Hashable",
    "MutableCollection",
    "PositionScaleRange",
    "RandomAccessCollection",
    "RangeReplaceableCollection",
    "ScaleDomain",
    "ScaleRange",
    "Sendable",
    "SendableMetatype",
    "Sequence"
  ],
  "contentHash" : "6ab8e5330d7ce29a0c5233c2c4eb17a7fef47d594eab6e57a9a3b27249d9cbed",
  "crawledAt" : "2025-12-05T02:25:23Z",
  "declaration" : {
    "code" : "@frozen struct ArraySlice<Element>",
    "language" : "swift"
  },
  "id" : "FD6538B9-2BF8-4A44-A2C1-A07B4408148D",
  "kind" : "struct",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nThe `ArraySlice` type makes it fast and efficient for you to perform operations on sections of a larger array. Instead of copying over the elements of a slice to new storage, an `ArraySlice` instance presents a view onto the storage of a larger array. And because `ArraySlice` presents the same interface as `Array`, you can generally perform the same operations on a slice as you could on the original array.\n\nFor more information about using arrays, see `Array` and `ContiguousArray`, with which `ArraySlice` shares most properties and methods.\n\n# Slices Are Views onto Arrays\n\nFor example, suppose you have an array holding the number of absences from each class during a session.\n\nYou want to compare the absences in the first half of the session with those in the second half. To do so, start by creating two slices of the `absences` array.\n\nNeither the `firstHalf` nor `secondHalf` slices allocate any new storage of their own. Instead, each presents a view onto the storage of the `absences` array.\n\nYou can call any method on the slices that you might have called on the `absences` array. To learn which half had more absences, use the `reduce(_:_:)` method to calculate each sum.\n\n# Slices Maintain Indices\n\nUnlike `Array` and `ContiguousArray`, the starting index for an `ArraySlice` instance isn’t always zero. Slices maintain the same indices of the larger array for the same elements, so the starting index of a slice depends on how it was created, letting you perform index-based operations on either a full array or a slice.\n\nSharing indices between collections and their subsequences is an important part of the design of Swift’s collection algorithms. Suppose you are tasked with finding the first two days with absences in the session. To find the indices of the two days in question, follow these steps:\n\nHere’s an implementation of those steps:\n\nIn particular, note that `j`, the index of the second day with absences, was found in a slice of the original array and then used to access a value in the original `absences` array itself.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/arrayslice\ncrawled: 2025-12-05T02:25:23Z\n---\n\n# ArraySlice\n\n**Structure**\n\nA slice of an `Array`, `ContiguousArray`, or `ArraySlice` instance.\n\n## Declaration\n\n```swift\n@frozen struct ArraySlice<Element>\n```\n\n## Overview\n\nThe `ArraySlice` type makes it fast and efficient for you to perform operations on sections of a larger array. Instead of copying over the elements of a slice to new storage, an `ArraySlice` instance presents a view onto the storage of a larger array. And because `ArraySlice` presents the same interface as `Array`, you can generally perform the same operations on a slice as you could on the original array.\n\nFor more information about using arrays, see `Array` and `ContiguousArray`, with which `ArraySlice` shares most properties and methods.\n\n# Slices Are Views onto Arrays\n\nFor example, suppose you have an array holding the number of absences from each class during a session.\n\n```swift\nlet absences = [0, 2, 0, 4, 0, 3, 1, 0]\n```\n\nYou want to compare the absences in the first half of the session with those in the second half. To do so, start by creating two slices of the `absences` array.\n\n```swift\nlet midpoint = absences.count \/ 2\n\nlet firstHalf = absences[..<midpoint]\nlet secondHalf = absences[midpoint...]\n```\n\nNeither the `firstHalf` nor `secondHalf` slices allocate any new storage of their own. Instead, each presents a view onto the storage of the `absences` array.\n\nYou can call any method on the slices that you might have called on the `absences` array. To learn which half had more absences, use the `reduce(_:_:)` method to calculate each sum.\n\n```swift\nlet firstHalfSum = firstHalf.reduce(0, +)\nlet secondHalfSum = secondHalf.reduce(0, +)\n\nif firstHalfSum > secondHalfSum {\n    print(\"More absences in the first half.\")\n} else {\n    print(\"More absences in the second half.\")\n}\n\/\/ Prints \"More absences in the first half.\"\n```\n\n\n\n# Slices Maintain Indices\n\nUnlike `Array` and `ContiguousArray`, the starting index for an `ArraySlice` instance isn’t always zero. Slices maintain the same indices of the larger array for the same elements, so the starting index of a slice depends on how it was created, letting you perform index-based operations on either a full array or a slice.\n\nSharing indices between collections and their subsequences is an important part of the design of Swift’s collection algorithms. Suppose you are tasked with finding the first two days with absences in the session. To find the indices of the two days in question, follow these steps:\n\n1. Call `firstIndex(where:)` to find the index of the first element in the `absences` array that is greater than zero.\n2. Create a slice of the `absences` array starting after the index found in step 1.\n3. Call `firstIndex(where:)` again, this time on the slice created in step 2. Where in some languages you might pass a starting index into an `indexOf` method to find the second day, in Swift you perform the same operation on a slice of the original array.\n4. Print the results using the indices found in steps 1 and 3 on the original `absences` array.\n\nHere’s an implementation of those steps:\n\n```swift\nif let i = absences.firstIndex(where: { $0 > 0 }) {                 \/\/ 1\n    let absencesAfterFirst = absences[(i + 1)...]                   \/\/ 2\n    if let j = absencesAfterFirst.firstIndex(where: { $0 > 0 }) {   \/\/ 3\n        print(\"The first day with absences had \\(absences[i]).\")    \/\/ 4\n        print(\"The second day with absences had \\(absences[j]).\")\n    }\n}\n\/\/ Prints \"The first day with absences had 2.\"\n\/\/ Prints \"The second day with absences had 4.\"\n```\n\nIn particular, note that `j`, the index of the second day with absences, was found in a slice of the original array and then used to access a value in the original `absences` array itself.\n\n\n\n## Initializers\n\n- **init(_:)**: Creates an array containing the elements of a sequence.\n\n## Instance Properties\n\n- **capacity**: The total number of elements that the array can contain without allocating new storage.\n- **mutableSpan**\n- **span**\n\n## Instance Methods\n\n- **insert(_:at:)**: Inserts a new element at the specified position.\n- **remove(at:)**: Removes and returns the element at the specified position.\n- **reserveCapacity(_:)**: Reserves enough space to store the specified number of elements.\n- **withUnsafeBufferPointer(_:)**: Calls a closure with a pointer to the array’s contiguous storage.\n- **withUnsafeBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.\n- **withUnsafeMutableBufferPointer(_:)**: Calls the given closure with a pointer to the array’s mutable contiguous storage.\n- **withUnsafeMutableBytes(_:)**: Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.\n\n## Default Implementations\n\n- **BidirectionalCollection Implementations**\n- **Collection Implementations**\n- **CustomDebugStringConvertible Implementations**\n- **CustomReflectable Implementations**\n- **CustomStringConvertible Implementations**\n- **Equatable Implementations**\n- **ExpressibleByArrayLiteral Implementations**\n- **Hashable Implementations**\n- **MutableCollection Implementations**\n- **OperationParameter Implementations**\n- **RandomAccessCollection Implementations**\n- **RangeReplaceableCollection Implementations**\n- **Sequence Implementations**\n\n## Related Array Types\n\n- **ContiguousArray**: A contiguously stored array.\n\n## Conforms To\n\n- AccelerateBuffer\n- AccelerateMutableBuffer\n- Attachable\n- BNNSGraph.Builder.OperationParameter\n- BidirectionalCollection\n- Collection\n- ContiguousBytes\n- Copyable\n- CustomDebugStringConvertible\n- CustomReflectable\n- CustomStringConvertible\n- DataProtocol\n- Equatable\n- ExpressibleByArrayLiteral\n- Hashable\n- MutableCollection\n- PositionScaleRange\n- RandomAccessCollection\n- RangeReplaceableCollection\n- ScaleDomain\n- ScaleRange\n- Sendable\n- SendableMetatype\n- Sequence\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an array containing the elements of a sequence.",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/init(_:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The total number of elements that the array can contain without allocating new storage.",
          "name" : "capacity",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/capacity"
        },
        {
          "description" : "",
          "name" : "mutableSpan",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/mutableSpan"
        },
        {
          "description" : "",
          "name" : "span",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/span"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Inserts a new element at the specified position.",
          "name" : "insert(_:at:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/insert(_:at:)"
        },
        {
          "description" : "Removes and returns the element at the specified position.",
          "name" : "remove(at:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/remove(at:)"
        },
        {
          "description" : "Reserves enough space to store the specified number of elements.",
          "name" : "reserveCapacity(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/reserveCapacity(_:)"
        },
        {
          "description" : "Calls a closure with a pointer to the array’s contiguous storage.",
          "name" : "withUnsafeBufferPointer(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/withUnsafeBufferPointer(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.",
          "name" : "withUnsafeBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/withUnsafeBytes(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the array’s mutable contiguous storage.",
          "name" : "withUnsafeMutableBufferPointer(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/withUnsafeMutableBufferPointer(_:)"
        },
        {
          "description" : "Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.",
          "name" : "withUnsafeMutableBytes(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/withUnsafeMutableBytes(_:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "BidirectionalCollection Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/BidirectionalCollection-Implementations"
        },
        {
          "description" : "",
          "name" : "Collection Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/Collection-Implementations"
        },
        {
          "description" : "",
          "name" : "CustomDebugStringConvertible Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/CustomDebugStringConvertible-Implementations"
        },
        {
          "description" : "",
          "name" : "CustomReflectable Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/CustomReflectable-Implementations"
        },
        {
          "description" : "",
          "name" : "CustomStringConvertible Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/CustomStringConvertible-Implementations"
        },
        {
          "description" : "",
          "name" : "Equatable Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/Equatable-Implementations"
        },
        {
          "description" : "",
          "name" : "ExpressibleByArrayLiteral Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/ExpressibleByArrayLiteral-Implementations"
        },
        {
          "description" : "",
          "name" : "Hashable Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/Hashable-Implementations"
        },
        {
          "description" : "",
          "name" : "MutableCollection Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/MutableCollection-Implementations"
        },
        {
          "description" : "",
          "name" : "OperationParameter Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/OperationParameter-Implementations"
        },
        {
          "description" : "",
          "name" : "RandomAccessCollection Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/RandomAccessCollection-Implementations"
        },
        {
          "description" : "",
          "name" : "RangeReplaceableCollection Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/RangeReplaceableCollection-Implementations"
        },
        {
          "description" : "",
          "name" : "Sequence Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ArraySlice\/Sequence-Implementations"
        }
      ],
      "title" : "Default Implementations"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A contiguously stored array.",
          "name" : "ContiguousArray",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/ContiguousArray"
        }
      ],
      "title" : "Related Array Types"
    }
  ],
  "source" : "appleJSON",
  "title" : "ArraySlice",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/arrayslice"
}