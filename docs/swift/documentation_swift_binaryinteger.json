{
  "abstract" : "An integer type with a binary representation.",
  "codeExamples" : [
    {
      "code" : "let x: Int = 500\nlet y = Int16(x)\n\/\/ y == 500\n\nlet z = Int8(x)\n\/\/ Error: Not enough bits to represent...",
      "language" : "swift"
    },
    {
      "code" : "let e = Int8(127.75)\n\/\/ e == 127\n\nlet f = Int8(128.25)\n\/\/ Error: Double value cannot be converted...",
      "language" : "swift"
    },
    {
      "code" : "let x = Int16(exactly: 500)\n\/\/ x == Optional(500)\n\nlet y = Int8(exactly: 500)\n\/\/ y == nil",
      "language" : "swift"
    },
    {
      "code" : "let e = Int8(exactly: 23.0)       \/\/ integral value, representable\n\/\/ e == Optional(23)\n\nlet f = Int8(exactly: 23.75)      \/\/ fractional value, representable\n\/\/ f == nil\n\nlet g = Int8(exactly: 500.0)      \/\/ integral value, nonrepresentable\n\/\/ g == nil",
      "language" : "swift"
    },
    {
      "code" : "let x = Int16(clamping: 500)\n\/\/ x == 500\n\nlet y = Int8(clamping: 500)\n\/\/ y == 127\n\nlet z = UInt8(clamping: -500)\n\/\/ z == 0",
      "language" : "swift"
    },
    {
      "code" : "let q: Int16 = 850\n\/\/ q == 0b00000011_01010010\n\nlet r = Int8(truncatingIfNeeded: q)      \/\/ truncate 'q' to fit in 8 bits\n\/\/ r == 82\n\/\/   == 0b01010010\n\nlet s = Int16(truncatingIfNeeded: r)     \/\/ extend 'r' to fill 16 bits\n\/\/ s == 82\n\/\/   == 0b00000000_01010010",
      "language" : "swift"
    },
    {
      "code" : "let t: Int8 = -100\n\/\/ t == -100\n\/\/ t's binary representation == 0b10011100\n\nlet u = UInt8(truncatingIfNeeded: t)\n\/\/ u == 156\n\/\/ u's binary representation == 0b10011100\n\nlet v = Int16(truncatingIfNeeded: t)\n\/\/ v == -100\n\/\/ v's binary representation == 0b11111111_10011100\n\nlet w = UInt16(truncatingIfNeeded: t)\n\/\/ w == 65436\n\/\/ w's binary representation == 0b11111111_10011100",
      "language" : "swift"
    },
    {
      "code" : "let x: Int = -23\nlet y: UInt = 1_000\nlet z: UInt8 = 23\n\nif x < y {\n    print(\"\\(x) is less than \\(y).\")\n}\n\/\/ Prints \"-23 is less than 1000.\"\n\nif z > x {\n    print(\"\\(z) is greater than \\(x).\")\n}\n\/\/ Prints \"23 is greater than -23.\"",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "Int",
    "Int128",
    "Int16",
    "Int32",
    "Int64",
    "Int8",
    "UInt",
    "UInt128",
    "UInt16",
    "UInt32",
    "UInt64",
    "UInt8"
  ],
  "contentHash" : "ebd226bb366d7ea05e469a4431af1bea3ee1e88eeb7631854a645bf5f896cb9a",
  "crawledAt" : "2025-12-03T16:08:39Z",
  "declaration" : {
    "code" : "protocol BinaryInteger : CustomStringConvertible, Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude == Self.Magnitude.Magnitude",
    "language" : "swift"
  },
  "id" : "76BB3785-1D7D-472C-B59A-ACF9AFCA9970",
  "inheritedBy" : [
    "FixedWidthInteger",
    "SignedInteger",
    "UnsignedInteger"
  ],
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nThe `BinaryInteger` protocol is the basis for all the integer types provided by the standard library. All of the standard library’s integer types, such as `Int` and `UInt32`, conform to `BinaryInteger`.\n\n# Converting Between Numeric Types\n\nYou can create new instances of a type that conforms to the `BinaryInteger` protocol from a floating-point number or another binary integer of any type. The `BinaryInteger` protocol provides initializers for four different kinds of conversion.\n\n## Range-Checked Conversion\n\nYou use the default `init(_:)` initializer to create a new instance when you’re sure that the value passed is representable in the new type. For example, an instance of `Int16` can represent the value `500`, so the first conversion in the code sample below succeeds. That same value is too large to represent as an `Int8` instance, so the second conversion fails, triggering a runtime error.\n\nWhen you create a binary integer from a floating-point value using the default initializer, the value is rounded toward zero before the range is checked. In the following example, the value `127.75` is rounded to `127`, which is representable by the `Int8` type.  `128.25` is rounded to `128`, which is not representable as an `Int8` instance, triggering a runtime error.\n\n## Exact Conversion\n\nUse the `init?(exactly:)` initializer to create a new instance after checking whether the passed value is representable. Instead of trapping on out-of-range values, using the failable `init?(exactly:)` initializer results in `nil`.\n\nWhen converting floating-point values, the `init?(exactly:)` initializer checks both that the passed value has no fractional part and that the value is representable in the resulting type.\n\n## Clamping Conversion\n\nUse the `init(clamping:)` initializer to create a new instance of a binary integer type where out-of-range values are clamped to the representable range of the type. For a type `T`, the resulting value is in the range `T.min...T.max`.\n\n## Bit Pattern Conversion\n\nUse the `init(truncatingIfNeeded:)` initializer to create a new instance with the same bit pattern as the passed value, extending or truncating the value’s representation as necessary. Note that the value may not be preserved, particularly when converting between signed to unsigned integer types or when the destination type has a smaller bit width than the source type. The following example shows how extending and truncating work for nonnegative integers:\n\nAny padding is performed by *sign-extending* the passed value. When nonnegative integers are extended, the result is padded with zeroes. When negative integers are extended, the result is padded with ones. This example shows several extending conversions of a negative value—note that negative values are sign-extended even when converting to an unsigned type.\n\n# Comparing Across Integer Types\n\nYou can use relational operators, such as the less-than and equal-to operators (`<` and `==`), to compare instances of different binary integer types. The following example compares instances of the `Int`, `UInt`, and `UInt8` types:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/binaryinteger\ncrawled: 2025-12-03T16:08:39Z\n---\n\n# BinaryInteger\n\n**Protocol**\n\nAn integer type with a binary representation.\n\n## Declaration\n\n```swift\nprotocol BinaryInteger : CustomStringConvertible, Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude == Self.Magnitude.Magnitude\n```\n\n## Overview\n\nThe `BinaryInteger` protocol is the basis for all the integer types provided by the standard library. All of the standard library’s integer types, such as `Int` and `UInt32`, conform to `BinaryInteger`.\n\n# Converting Between Numeric Types\n\nYou can create new instances of a type that conforms to the `BinaryInteger` protocol from a floating-point number or another binary integer of any type. The `BinaryInteger` protocol provides initializers for four different kinds of conversion.\n\n## Range-Checked Conversion\n\nYou use the default `init(_:)` initializer to create a new instance when you’re sure that the value passed is representable in the new type. For example, an instance of `Int16` can represent the value `500`, so the first conversion in the code sample below succeeds. That same value is too large to represent as an `Int8` instance, so the second conversion fails, triggering a runtime error.\n\n```swift\nlet x: Int = 500\nlet y = Int16(x)\n\/\/ y == 500\n\nlet z = Int8(x)\n\/\/ Error: Not enough bits to represent...\n```\n\nWhen you create a binary integer from a floating-point value using the default initializer, the value is rounded toward zero before the range is checked. In the following example, the value `127.75` is rounded to `127`, which is representable by the `Int8` type.  `128.25` is rounded to `128`, which is not representable as an `Int8` instance, triggering a runtime error.\n\n```swift\nlet e = Int8(127.75)\n\/\/ e == 127\n\nlet f = Int8(128.25)\n\/\/ Error: Double value cannot be converted...\n```\n\n## Exact Conversion\n\nUse the `init?(exactly:)` initializer to create a new instance after checking whether the passed value is representable. Instead of trapping on out-of-range values, using the failable `init?(exactly:)` initializer results in `nil`.\n\n```swift\nlet x = Int16(exactly: 500)\n\/\/ x == Optional(500)\n\nlet y = Int8(exactly: 500)\n\/\/ y == nil\n```\n\nWhen converting floating-point values, the `init?(exactly:)` initializer checks both that the passed value has no fractional part and that the value is representable in the resulting type.\n\n```swift\nlet e = Int8(exactly: 23.0)       \/\/ integral value, representable\n\/\/ e == Optional(23)\n\nlet f = Int8(exactly: 23.75)      \/\/ fractional value, representable\n\/\/ f == nil\n\nlet g = Int8(exactly: 500.0)      \/\/ integral value, nonrepresentable\n\/\/ g == nil\n```\n\n## Clamping Conversion\n\nUse the `init(clamping:)` initializer to create a new instance of a binary integer type where out-of-range values are clamped to the representable range of the type. For a type `T`, the resulting value is in the range `T.min...T.max`.\n\n```swift\nlet x = Int16(clamping: 500)\n\/\/ x == 500\n\nlet y = Int8(clamping: 500)\n\/\/ y == 127\n\nlet z = UInt8(clamping: -500)\n\/\/ z == 0\n```\n\n## Bit Pattern Conversion\n\nUse the `init(truncatingIfNeeded:)` initializer to create a new instance with the same bit pattern as the passed value, extending or truncating the value’s representation as necessary. Note that the value may not be preserved, particularly when converting between signed to unsigned integer types or when the destination type has a smaller bit width than the source type. The following example shows how extending and truncating work for nonnegative integers:\n\n```swift\nlet q: Int16 = 850\n\/\/ q == 0b00000011_01010010\n\nlet r = Int8(truncatingIfNeeded: q)      \/\/ truncate 'q' to fit in 8 bits\n\/\/ r == 82\n\/\/   == 0b01010010\n\nlet s = Int16(truncatingIfNeeded: r)     \/\/ extend 'r' to fill 16 bits\n\/\/ s == 82\n\/\/   == 0b00000000_01010010\n```\n\nAny padding is performed by *sign-extending* the passed value. When nonnegative integers are extended, the result is padded with zeroes. When negative integers are extended, the result is padded with ones. This example shows several extending conversions of a negative value—note that negative values are sign-extended even when converting to an unsigned type.\n\n```swift\nlet t: Int8 = -100\n\/\/ t == -100\n\/\/ t's binary representation == 0b10011100\n\nlet u = UInt8(truncatingIfNeeded: t)\n\/\/ u == 156\n\/\/ u's binary representation == 0b10011100\n\nlet v = Int16(truncatingIfNeeded: t)\n\/\/ v == -100\n\/\/ v's binary representation == 0b11111111_10011100\n\nlet w = UInt16(truncatingIfNeeded: t)\n\/\/ w == 65436\n\/\/ w's binary representation == 0b11111111_10011100\n```\n\n# Comparing Across Integer Types\n\nYou can use relational operators, such as the less-than and equal-to operators (`<` and `==`), to compare instances of different binary integer types. The following example compares instances of the `Int`, `UInt`, and `UInt8` types:\n\n```swift\nlet x: Int = -23\nlet y: UInt = 1_000\nlet z: UInt8 = 23\n\nif x < y {\n    print(\"\\(x) is less than \\(y).\")\n}\n\/\/ Prints \"-23 is less than 1000.\"\n\nif z > x {\n    print(\"\\(z) is greater than \\(x).\")\n}\n\/\/ Prints \"23 is greater than -23.\"\n```\n\n## Creating a Binary Integer\n\n- **init()**: Creates a new value equal to zero.\n\n## Converting Integers\n\n- **init(_:)**: Creates a new instance from the given integer.\n- **init(clamping:)**: Creates a new instance with the representable value that’s closest to the given integer.\n- **init(truncatingIfNeeded:)**: Creates a new instance from the bit pattern of the given instance by sign-extending or truncating to fit this type.\n\n## Converting Floating-Point Values\n\n- **init(_:)**: Creates an integer from the given floating-point value, rounding toward zero.\n\n## Converting with No Loss of Precision\n\n- **init(exactly:)**: Creates an integer from the given floating-point value, if it can be represented exactly.\n\n## Performing Calculations\n\n- **Binary Integer Operators**: Perform arithmetic and bitwise operations or compare values.\n- **quotientAndRemainder(dividingBy:)**: Returns the quotient and remainder of this value divided by the given value.\n- **isMultiple(of:)**: Returns `true` if this value is a multiple of the given value, and `false` otherwise.\n\n## Finding the Sign and Magnitude\n\n- **signum()**: Returns `-1` if this value is negative and `1` if it’s positive; otherwise, `0`.\n\n## Accessing Numeric Constants\n\n- **isSigned**: A Boolean value indicating whether this type is a signed integer type.\n\n## Working with Binary Representation\n\n- **bitWidth**: The number of bits in the current binary representation of this value.\n- **trailingZeroBitCount**: The number of trailing zeros in this value’s binary representation.\n- **words**: A collection containing the words of this value’s binary representation, in order from the least significant to most significant.\n- **Words**: A type that represents the words of a binary integer.\n\n## Operators\n\n- **%(_:_:)**: Returns the remainder of dividing the first value by the second.\n- **^(_:_:)**: Returns the result of performing a bitwise XOR operation on the two given values.\n- **|(_:_:)**: Returns the result of performing a bitwise OR operation on the two given values.\n- **^=(_:_:)**: Stores the result of performing a bitwise XOR operation on the two given values in the left-hand-side variable.\n- **|=(_:_:)**: Stores the result of performing a bitwise OR operation on the two given values in the left-hand-side variable.\n- **%=(_:_:)**: Divides the first value by the second and stores the remainder in the left-hand-side variable.\n- **<<(_:_:)**: Returns the result of shifting a value’s binary representation the specified number of digits to the left.\n- **>>(_:_:)**: Returns the result of shifting a value’s binary representation the specified number of digits to the right.\n- **>>=(_:_:)**: Stores the result of shifting a value’s binary representation the specified number of digits to the right in the left-hand-side variable.\n- **<<=(_:_:)**: Stores the result of shifting a value’s binary representation the specified number of digits to the left in the left-hand-side variable.\n\n## Initializers\n\n- **init(_:format:lenient:)**\n- **init(_:format:lenient:)**\n- **init(_:format:lenient:)**\n- **init(_:strategy:)**: Initialize an instance by parsing `value` with the given `strategy`.\n\n## Instance Methods\n\n- **formatted()**: Format `self` using `IntegerFormatStyle()`\n- **formatted(_:)**: Format `self` with the given format.\n- **formatted(_:)**: Format `self` with the given format. `self` is first converted to `S.FormatInput` type, then format with the given format.\n\n## Default Implementations\n\n- **BinaryInteger Implementations**\n- **Equatable Implementations**\n\n## Integer\n\n- **FixedWidthInteger**: An integer type that uses a fixed size for every instance.\n- **SignedInteger**: An integer type that can represent both positive and negative values.\n- **UnsignedInteger**: An integer type that can represent only nonnegative values.\n\n## Inherits From\n\n- AdditiveArithmetic\n- Comparable\n- CustomStringConvertible\n- Equatable\n- ExpressibleByIntegerLiteral\n- Hashable\n- Numeric\n- Strideable\n\n## Inherited By\n\n- FixedWidthInteger\n- SignedInteger\n- UnsignedInteger\n\n## Conforming Types\n\n- Int\n- Int128\n- Int16\n- Int32\n- Int64\n- Int8\n- UInt\n- UInt128\n- UInt16\n- UInt32\n- UInt64\n- UInt8\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a new value equal to zero.",
          "name" : "init()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init()"
        }
      ],
      "title" : "Creating a Binary Integer"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a new instance from the given integer.",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(_:)-8gmdl"
        },
        {
          "description" : "Creates a new instance with the representable value that’s closest to the given integer.",
          "name" : "init(clamping:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(clamping:)"
        },
        {
          "description" : "Creates a new instance from the bit pattern of the given instance by sign-extending or truncating to fit this type.",
          "name" : "init(truncatingIfNeeded:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(truncatingIfNeeded:)"
        }
      ],
      "title" : "Converting Integers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an integer from the given floating-point value, rounding toward zero.",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(_:)-2ln0u"
        }
      ],
      "title" : "Converting Floating-Point Values"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an integer from the given floating-point value, if it can be represented exactly.",
          "name" : "init(exactly:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(exactly:)"
        }
      ],
      "title" : "Converting with No Loss of Precision"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Perform arithmetic and bitwise operations or compare values.",
          "name" : "Binary Integer Operators",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/binary-integer-operators"
        },
        {
          "description" : "Returns the quotient and remainder of this value divided by the given value.",
          "name" : "quotientAndRemainder(dividingBy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/quotientAndRemainder(dividingBy:)"
        },
        {
          "description" : "Returns `true` if this value is a multiple of the given value, and `false` otherwise.",
          "name" : "isMultiple(of:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/isMultiple(of:)"
        }
      ],
      "title" : "Performing Calculations"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns `-1` if this value is negative and `1` if it’s positive; otherwise, `0`.",
          "name" : "signum()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/signum()"
        }
      ],
      "title" : "Finding the Sign and Magnitude"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A Boolean value indicating whether this type is a signed integer type.",
          "name" : "isSigned",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/isSigned"
        }
      ],
      "title" : "Accessing Numeric Constants"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The number of bits in the current binary representation of this value.",
          "name" : "bitWidth",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/bitWidth"
        },
        {
          "description" : "The number of trailing zeros in this value’s binary representation.",
          "name" : "trailingZeroBitCount",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/trailingZeroBitCount"
        },
        {
          "description" : "A collection containing the words of this value’s binary representation, in order from the least significant to most significant.",
          "name" : "words",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/words-swift.property"
        },
        {
          "description" : "A type that represents the words of a binary integer.",
          "name" : "Words",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/Words-swift.associatedtype"
        }
      ],
      "title" : "Working with Binary Representation"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns the remainder of dividing the first value by the second.",
          "name" : "%(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/_(_:_:)-30ngi"
        },
        {
          "description" : "Returns the result of performing a bitwise XOR operation on the two given values.",
          "name" : "^(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/_(_:_:)-3qw5d"
        },
        {
          "description" : "Returns the result of performing a bitwise OR operation on the two given values.",
          "name" : "|(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/_(_:_:)-6qhsw"
        },
        {
          "description" : "Stores the result of performing a bitwise XOR operation on the two given values in the left-hand-side variable.",
          "name" : "^=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/_=(_:_:)-1fatv"
        },
        {
          "description" : "Stores the result of performing a bitwise OR operation on the two given values in the left-hand-side variable.",
          "name" : "|=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/_=(_:_:)-4vfmj"
        },
        {
          "description" : "Divides the first value by the second and stores the remainder in the left-hand-side variable.",
          "name" : "%=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/_=(_:_:)-79wgi"
        },
        {
          "description" : "Returns the result of shifting a value’s binary representation the specified number of digits to the left.",
          "name" : "<<(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/__(_:_:)-28lmu"
        },
        {
          "description" : "Returns the result of shifting a value’s binary representation the specified number of digits to the right.",
          "name" : ">>(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/__(_:_:)-4vnij"
        },
        {
          "description" : "Stores the result of shifting a value’s binary representation the specified number of digits to the right in the left-hand-side variable.",
          "name" : ">>=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/__=(_:_:)-5lhky"
        },
        {
          "description" : "Stores the result of shifting a value’s binary representation the specified number of digits to the left in the left-hand-side variable.",
          "name" : "<<=(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/__=(_:_:)-9pzpp"
        }
      ],
      "title" : "Operators"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "init(_:format:lenient:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(_:format:lenient:)-2qv61"
        },
        {
          "description" : "",
          "name" : "init(_:format:lenient:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(_:format:lenient:)-50z9r"
        },
        {
          "description" : "",
          "name" : "init(_:format:lenient:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(_:format:lenient:)-86j1g"
        },
        {
          "description" : "Initialize an instance by parsing `value` with the given `strategy`.",
          "name" : "init(_:strategy:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/init(_:strategy:)-207i8"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Format `self` using `IntegerFormatStyle()`",
          "name" : "formatted()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/formatted()"
        },
        {
          "description" : "Format `self` with the given format.",
          "name" : "formatted(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/formatted(_:)-4qd73"
        },
        {
          "description" : "Format `self` with the given format. `self` is first converted to `S.FormatInput` type, then format with the given format.",
          "name" : "formatted(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/formatted(_:)-73k3e"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "BinaryInteger Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/BinaryInteger-Implementations"
        },
        {
          "description" : "",
          "name" : "Equatable Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/BinaryInteger\/Equatable-Implementations"
        }
      ],
      "title" : "Default Implementations"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "An integer type that uses a fixed size for every instance.",
          "name" : "FixedWidthInteger",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/FixedWidthInteger"
        },
        {
          "description" : "An integer type that can represent both positive and negative values.",
          "name" : "SignedInteger",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/SignedInteger"
        },
        {
          "description" : "An integer type that can represent only nonnegative values.",
          "name" : "UnsignedInteger",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/UnsignedInteger"
        }
      ],
      "title" : "Integer"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "AdditiveArithmetic"
        },
        {
          "name" : "Comparable"
        },
        {
          "name" : "CustomStringConvertible"
        },
        {
          "name" : "Equatable"
        },
        {
          "name" : "ExpressibleByIntegerLiteral"
        },
        {
          "name" : "Hashable"
        },
        {
          "name" : "Numeric"
        },
        {
          "name" : "Strideable"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "BinaryInteger",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/binaryinteger"
}