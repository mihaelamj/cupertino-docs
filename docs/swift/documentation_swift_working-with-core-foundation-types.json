{
  "abstract" : "Work directly with memory-managed Core Foundation types in your Swift code, and manually handle retains as needed.",
  "codeExamples" : [
    {
      "code" : "CFStringRef StringByAddingTwoStrings(CFStringRef s1, CFStringRef s2)",
      "language" : "occ"
    },
    {
      "code" : "func StringByAddingTwoStrings(_: CFString!, _: CFString!) -> Unmanaged<CFString>! {\n    \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "let memoryManagedResult = StringByAddingTwoStrings(str1, str2).takeUnretainedValue()\n\/\/ memoryManagedResult is a memory managed CFString",
      "language" : "swift"
    }
  ],
  "contentHash" : "a2828a786cfbaf4afba1b989a03db701a486325080cfbb74b1dc582f4dc2fe73",
  "crawledAt" : "2025-12-04T02:30:10Z",
  "id" : "380CE869-78DC-49BE-BCB5-7753AF8E6F0B",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nWhen you import the Core Foundation framework, its types are imported as Swift classes. Wherever memory management annotations are provided, Swift automatically manages the memory of Core Foundation objects, including Core Foundation objects that you instantiate yourself. In Swift, you can use each pair of toll-free bridged Foundation and Core Foundation types interchangeably. You can also bridge some toll-free bridged Core Foundation types to Swift standard library types if you cast to a bridging Foundation type first. See [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/CocoaEncyclopedia\/Toll-FreeBridgin\/Toll-FreeBridgin.html#\/\/apple_ref\/doc\/uid\/TP40010810-CH2] for more information.\n\n### Use Memory Managed Objects\n\nWhen Swift imports Core Foundation types, the compiler remaps the names of these types. The compiler removes `Ref` from the end of each type name because all Swift classes are reference types; therefore, the suffix is redundant. The `CFTypeRef` type completely remaps to the `AnyObject` type.\n\nCore Foundation objects returned from annotated APIs are automatically memory-managed in Swift—you don’t need to invoke the `CFRetain`, `CFRelease`, or `CFAutorelease` functions yourself.\n\nIf you return Core Foundation objects from your own C functions and Objective-C methods, you can annotate them with either the `CF_RETURNS_RETAINED` or `CF_RETURNS_NOT_RETAINED` macro to automatically insert memory management calls. You can also use the `CF_IMPLICIT_BRIDGING_ENABLED` and `CF_IMPLICIT_BRIDGING_DISABLED` macros to enclose C function declarations that follow the policy for Core Foundation ownership naming, in order to infer memory management.\n\n### Convert Unmanaged Objects to Memory-Managed Objects\n\nWhen Swift imports APIs that have not been annotated, the compiler cannot automatically memory-manage the returned Core Foundation objects. Swift wraps these returned Core Foundation objects in an [doc:\/\/com.apple.Swift\/documentation\/Swift\/Unmanaged] structure. All indirectly returned Core Foundation objects are unmanaged as well. For example, here’s an unannotated C function:\n\nAnd here’s how Swift imports it:\n\nWhen you receive an unmanaged object from an unannotated API, immediately convert it to a memory-managed object before you work with it. That way, Swift can handle memory management for you.\n\nThe `Unmanaged` structure provides two methods to convert an unmanaged object to a memory-managed object—`takeUnretainedValue()` and `takeRetainedValue()`. Both of these methods return the original, unwrapped type of the object. You choose which method to use based on whether the API you are invoking returns an unretained or a retained object.\n\nFor example, suppose the C function above doesn’t retain the `CFString` object before returning it. To start using the object, you use the `takeUnretainedValue()` function.\n\nYou can also invoke the `retain()`, `release()`, and `autorelease()` methods on unmanaged objects, but this approach is not recommended.\n\nFor more information, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/CoreFoundation\/Conceptual\/CFMemoryMgmt\/Concepts\/Ownership.html#\/\/apple_ref\/doc\/uid\/20001148] in [https:\/\/developer.apple.com\/library\/archive\/documentation\/CoreFoundation\/Conceptual\/CFMemoryMgmt\/CFMemoryMgmt.html#\/\/apple_ref\/doc\/uid\/10000127i].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/working-with-core-foundation-types\ncrawled: 2025-12-04T02:30:10Z\n---\n\n# Working with Core Foundation Types\n\n**Article**\n\nWork directly with memory-managed Core Foundation types in your Swift code, and manually handle retains as needed.\n\n## Overview\n\nWhen you import the Core Foundation framework, its types are imported as Swift classes. Wherever memory management annotations are provided, Swift automatically manages the memory of Core Foundation objects, including Core Foundation objects that you instantiate yourself. In Swift, you can use each pair of toll-free bridged Foundation and Core Foundation types interchangeably. You can also bridge some toll-free bridged Core Foundation types to Swift standard library types if you cast to a bridging Foundation type first. See [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/CocoaEncyclopedia\/Toll-FreeBridgin\/Toll-FreeBridgin.html#\/\/apple_ref\/doc\/uid\/TP40010810-CH2] for more information.\n\n### Use Memory Managed Objects\n\nWhen Swift imports Core Foundation types, the compiler remaps the names of these types. The compiler removes `Ref` from the end of each type name because all Swift classes are reference types; therefore, the suffix is redundant. The `CFTypeRef` type completely remaps to the `AnyObject` type.\n\nCore Foundation objects returned from annotated APIs are automatically memory-managed in Swift—you don’t need to invoke the `CFRetain`, `CFRelease`, or `CFAutorelease` functions yourself.\n\nIf you return Core Foundation objects from your own C functions and Objective-C methods, you can annotate them with either the `CF_RETURNS_RETAINED` or `CF_RETURNS_NOT_RETAINED` macro to automatically insert memory management calls. You can also use the `CF_IMPLICIT_BRIDGING_ENABLED` and `CF_IMPLICIT_BRIDGING_DISABLED` macros to enclose C function declarations that follow the policy for Core Foundation ownership naming, in order to infer memory management.\n\n### Convert Unmanaged Objects to Memory-Managed Objects\n\nWhen Swift imports APIs that have not been annotated, the compiler cannot automatically memory-manage the returned Core Foundation objects. Swift wraps these returned Core Foundation objects in an [doc:\/\/com.apple.Swift\/documentation\/Swift\/Unmanaged] structure. All indirectly returned Core Foundation objects are unmanaged as well. For example, here’s an unannotated C function:\n\n```occ\nCFStringRef StringByAddingTwoStrings(CFStringRef s1, CFStringRef s2)\n```\n\nAnd here’s how Swift imports it:\n\n```swift\nfunc StringByAddingTwoStrings(_: CFString!, _: CFString!) -> Unmanaged<CFString>! {\n    \/\/ ...\n}\n```\n\nWhen you receive an unmanaged object from an unannotated API, immediately convert it to a memory-managed object before you work with it. That way, Swift can handle memory management for you.\n\nThe `Unmanaged` structure provides two methods to convert an unmanaged object to a memory-managed object—`takeUnretainedValue()` and `takeRetainedValue()`. Both of these methods return the original, unwrapped type of the object. You choose which method to use based on whether the API you are invoking returns an unretained or a retained object.\n\nFor example, suppose the C function above doesn’t retain the `CFString` object before returning it. To start using the object, you use the `takeUnretainedValue()` function.\n\n```swift\nlet memoryManagedResult = StringByAddingTwoStrings(str1, str2).takeUnretainedValue()\n\/\/ memoryManagedResult is a memory managed CFString\n```\n\nYou can also invoke the `retain()`, `release()`, and `autorelease()` methods on unmanaged objects, but this approach is not recommended.\n\nFor more information, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/CoreFoundation\/Conceptual\/CFMemoryMgmt\/Concepts\/Ownership.html#\/\/apple_ref\/doc\/uid\/20001148] in [https:\/\/developer.apple.com\/library\/archive\/documentation\/CoreFoundation\/Conceptual\/CFMemoryMgmt\/CFMemoryMgmt.html#\/\/apple_ref\/doc\/uid\/10000127i].\n\n## Cocoa Frameworks\n\n- **Working with Foundation Types**: Use bridged Foundation types in your Swift codebase to work with dates, times, and other values.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use bridged Foundation types in your Swift codebase to work with dates, times, and other values.",
          "name" : "Working with Foundation Types",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/working-with-foundation-types"
        }
      ],
      "title" : "Cocoa Frameworks"
    }
  ],
  "source" : "appleJSON",
  "title" : "Working with Core Foundation Types",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/working-with-core-foundation-types"
}