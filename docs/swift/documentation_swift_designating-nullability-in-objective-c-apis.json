{
  "abstract" : "Use nullability annotations or mark regions as annotated to control how Objective-C declarations are imported into Swift.",
  "codeExamples" : [
    {
      "code" : "@interface MyList : NSObject\n- (MyListItem *)itemWithName:(NSString *)name;\n- (NSString *)nameForItem:(MyListItem *)item;\n@property (copy) NSArray<MyListItem *> *allItems;\n@end",
      "language" : "occ"
    },
    {
      "code" : "class MyList: NSObject {\n    func item(withName name: String!) -> MyListItem!\n    func name(for item: MyListItem!) -> String!\n    var allItems: [MyListItem]!\n}",
      "language" : "swift"
    },
    {
      "code" : "@interface MyList : NSObject\n- (nullable MyListItem *)itemWithName:(nonnull NSString *)name;\n- (nullable NSString *)nameForItem:(nonnull MyListItem *)item;\n@property (copy, nonnull) NSArray<MyListItem *> *allItems;\n@end",
      "language" : "occ"
    },
    {
      "code" : "class MyList: NSObject {\n    func item(withName name: String) -> MyListItem?\n    func name(for item: MyListItem) -> String?\n    var allItems: [MyListItem]\n}",
      "language" : "swift"
    },
    {
      "code" : "NS_ASSUME_NONNULL_BEGIN\n\n@interface MyList : NSObject\n- (nullable MyListItem *)itemWithName:(NSString *)name;\n- (nullable NSString *)nameForItem:(MyListItem *)item;\n@property (copy) NSArray<MyListItem *> *allItems;\n@end\n\nNS_ASSUME_NONNULL_END",
      "language" : "occ"
    }
  ],
  "contentHash" : "6007e79885bdcefb828102b18f02bf459cd9423403374eb281a9ab2ee94f1850",
  "crawledAt" : "2025-12-04T04:01:25Z",
  "id" : "2AE35363-F849-4AEF-B10D-5B77BCC8404B",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nIn Objective-C, you work with references to objects by using pointers that can be null, called `nil` in Objective-C. In Swift, all values — including object instances — are guaranteed to be non-null. Instead, you represent a value that could be missing as wrapped in an optional type. When you need to indicate that a value is missing, you use the value `nil`.\n\nYou can annotate declarations in your Objective-C code to indicate whether an instance can have a null or `nil` value. Those annotations change how Swift imports your declarations. For an example of how Swift imports unannotated declarations, consider the following code:\n\nSwift imports each object instance parameter, return value, and property as an implicitly wrapped optional:\n\n### Annotate Nullability of Individual Declarations\n\nYou can use nullability annotations in your Objective-C code to designate whether a parameter type, property type, or return type is nullable. Annotate property declarations, parameter types, and return types that are simple objects or block pointers using the `nullable`, `nonnull`, and `null_resettable` property attributes. If no nullability information is provided for a type, Swift doesn’t distinguish between optional and nonoptional references, and imports the type as an implicitly unwrapped optional.\n\nThis list describes how Swift imports types with different nullability annotations:\n\nThe following code shows the `MyList` type after annotation. The return types of the two methods are annotated as `nullable`, because the methods return `nil` if the list doesn’t contain the given list item or name. All other object instances are annotated as `nonnull`.\n\nWith these annotations, Swift imports the `MyList` type without using any implicitly wrapped optionals:\n\nThe `nullable` and `nonnull` annotations are simplified forms of the `_Nullable` and `_Nonnull` annotations, which you can use in almost any context that you would use the `const` keyword with a pointer type. Complex pointer types, such as `id *`, must be explicitly annotated using these annotations. For example, to specify a nonnullable pointer to a nullable object reference, use `_Nullable id * _Nonnull`.\n\n### Annotate Regions as Nonnullable\n\nYou can simplify the process of annotating your Objective-C code by marking entire regions as audited for nullability. Within a section of code demarcated by the `NS_ASSUME_NONNULL_BEGIN` and `NS_ASSUME_NONNULL_END` macros, you only need to annotate the nullable type declarations. Unannotated declarations within the audited region are treated as nonnullable.\n\nMarking the `MyList` declaration as audited for nullability reduces the number of annotations that are required. Swift imports the type the same way as in the previous section.\n\nNote that `typedef` types aren’t assumed to be nonnull, even within audited regions, because they aren’t inherently nullable.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/designating-nullability-in-objective-c-apis\ncrawled: 2025-12-04T04:01:25Z\n---\n\n# Designating Nullability in Objective-C APIs\n\n**Article**\n\nUse nullability annotations or mark regions as annotated to control how Objective-C declarations are imported into Swift.\n\n## Overview\n\nIn Objective-C, you work with references to objects by using pointers that can be null, called `nil` in Objective-C. In Swift, all values — including object instances — are guaranteed to be non-null. Instead, you represent a value that could be missing as wrapped in an optional type. When you need to indicate that a value is missing, you use the value `nil`.\n\nYou can annotate declarations in your Objective-C code to indicate whether an instance can have a null or `nil` value. Those annotations change how Swift imports your declarations. For an example of how Swift imports unannotated declarations, consider the following code:\n\n```occ\n@interface MyList : NSObject\n- (MyListItem *)itemWithName:(NSString *)name;\n- (NSString *)nameForItem:(MyListItem *)item;\n@property (copy) NSArray<MyListItem *> *allItems;\n@end\n```\n\nSwift imports each object instance parameter, return value, and property as an implicitly wrapped optional:\n\n```swift\nclass MyList: NSObject {\n    func item(withName name: String!) -> MyListItem!\n    func name(for item: MyListItem!) -> String!\n    var allItems: [MyListItem]!\n}\n```\n\n### Annotate Nullability of Individual Declarations\n\nYou can use nullability annotations in your Objective-C code to designate whether a parameter type, property type, or return type is nullable. Annotate property declarations, parameter types, and return types that are simple objects or block pointers using the `nullable`, `nonnull`, and `null_resettable` property attributes. If no nullability information is provided for a type, Swift doesn’t distinguish between optional and nonoptional references, and imports the type as an implicitly unwrapped optional.\n\nThis list describes how Swift imports types with different nullability annotations:\n\n- Nonnullable—Imported as nonoptionals, whether annotated directly or by inclusion in an annotated region\n- Nullable—Imported as optionals\n- Without a nullability annotation or with a null_resettable annotation—Imported as implicitly unwrapped optionals\n\nThe following code shows the `MyList` type after annotation. The return types of the two methods are annotated as `nullable`, because the methods return `nil` if the list doesn’t contain the given list item or name. All other object instances are annotated as `nonnull`.\n\n```occ\n@interface MyList : NSObject\n- (nullable MyListItem *)itemWithName:(nonnull NSString *)name;\n- (nullable NSString *)nameForItem:(nonnull MyListItem *)item;\n@property (copy, nonnull) NSArray<MyListItem *> *allItems;\n@end\n```\n\nWith these annotations, Swift imports the `MyList` type without using any implicitly wrapped optionals:\n\n```swift\nclass MyList: NSObject {\n    func item(withName name: String) -> MyListItem?\n    func name(for item: MyListItem) -> String?\n    var allItems: [MyListItem]\n}\n```\n\nThe `nullable` and `nonnull` annotations are simplified forms of the `_Nullable` and `_Nonnull` annotations, which you can use in almost any context that you would use the `const` keyword with a pointer type. Complex pointer types, such as `id *`, must be explicitly annotated using these annotations. For example, to specify a nonnullable pointer to a nullable object reference, use `_Nullable id * _Nonnull`.\n\n### Annotate Regions as Nonnullable\n\nYou can simplify the process of annotating your Objective-C code by marking entire regions as audited for nullability. Within a section of code demarcated by the `NS_ASSUME_NONNULL_BEGIN` and `NS_ASSUME_NONNULL_END` macros, you only need to annotate the nullable type declarations. Unannotated declarations within the audited region are treated as nonnullable.\n\nMarking the `MyList` declaration as audited for nullability reduces the number of annotations that are required. Swift imports the type the same way as in the previous section.\n\n```occ\nNS_ASSUME_NONNULL_BEGIN\n\n@interface MyList : NSObject\n- (nullable MyListItem *)itemWithName:(NSString *)name;\n- (nullable NSString *)nameForItem:(MyListItem *)item;\n@property (copy) NSArray<MyListItem *> *allItems;\n@end\n\nNS_ASSUME_NONNULL_END\n```\n\nNote that `typedef` types aren’t assumed to be nonnull, even within audited regions, because they aren’t inherently nullable.\n\n## Customizing Objective-C APIs\n\n- **Renaming Objective-C APIs for Swift**: Use the `NS_SWIFT_NAME` macro to customize API names for Swift.\n- **Improving Objective-C API Declarations for Swift**: Use the `NS_REFINED_FOR_SWIFT` macro to change how an API is imported into Swift.\n- **Grouping Related Objective-C Constants**: Add macros to your Objective-C types to group their values in Swift.\n- **Marking API Availability in Objective-C**: Use a macro to denote the availability of an Objective-C API.\n- **Making Objective-C APIs Unavailable in Swift**: Use the `NS_SWIFT_UNAVAILABLE` macro to prevent an API from being used in Swift.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use the `NS_SWIFT_NAME` macro to customize API names for Swift.",
          "name" : "Renaming Objective-C APIs for Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/renaming-objective-c-apis-for-swift"
        },
        {
          "description" : "Use the `NS_REFINED_FOR_SWIFT` macro to change how an API is imported into Swift.",
          "name" : "Improving Objective-C API Declarations for Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/improving-objective-c-api-declarations-for-swift"
        },
        {
          "description" : "Add macros to your Objective-C types to group their values in Swift.",
          "name" : "Grouping Related Objective-C Constants",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/grouping-related-objective-c-constants"
        },
        {
          "description" : "Use a macro to denote the availability of an Objective-C API.",
          "name" : "Marking API Availability in Objective-C",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/marking-api-availability-in-objective-c"
        },
        {
          "description" : "Use the `NS_SWIFT_UNAVAILABLE` macro to prevent an API from being used in Swift.",
          "name" : "Making Objective-C APIs Unavailable in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/making-objective-c-apis-unavailable-in-swift"
        }
      ],
      "title" : "Customizing Objective-C APIs"
    }
  ],
  "source" : "appleJSON",
  "title" : "Designating Nullability in Objective-C APIs",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/designating-nullability-in-objective-c-apis"
}