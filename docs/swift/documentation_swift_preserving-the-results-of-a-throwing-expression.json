{
  "abstract" : "Call the initializer that wraps a throwing expression when you need to serialize or memoize the result.",
  "codeExamples" : [
    {
      "code" : "enum EntropyError: Error {\n    case entropyDepleted\n}\n\nstruct UnreliableRandomGenerator {\n    func random() throws -> Int {\n        if Bool.random() {\n            return Int.random(in: 1...100)\n        } else {\n            throw EntropyError.entropyDepleted\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let singleSample = Result { try UnreliableRandomGenerator().random() }",
      "language" : "swift"
    },
    {
      "code" : "struct RandomnessMonitor {\n    let randomnessSource: UnreliableRandomGenerator\n    var results: [Result<Int, Error>] = []\n\n    init(generator: UnreliableRandomGenerator) {\n        randomnessSource = generator\n    }\n\n    mutating func sample() {\n        let sample = Result { try randomnessSource.random() }\n        results.append(sample)\n    }\n\n    func summary() -> (Double, Double) {\n        let totals = results.reduce((sum: 0, count: 0)) { total, sample in\n            switch sample {\n            case .success(let number):\n                return (total.sum + number, total.count)\n            case .failure:\n                return (total.sum, total.count + 1)\n            }\n        }\n\n        return (\n            average: Double(totals.sum) \/ Double(results.count - totals.count),\n            failureRate: Double(totals.count) \/ Double(results.count)\n        )\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var monitor = RandomnessMonitor(generator: UnreliableRandomGenerator())\n(0..<1000).forEach { _ in monitor.sample() }\nlet (average, failureRate) = monitor.summary()\nprint(\"Average value: \\(average), failure rate: \\(failureRate * 100.0)%.\")\n\/\/ Prints values such as: \"Average value: 47.95, failure rate: 48.69%.\"",
      "language" : "swift"
    }
  ],
  "contentHash" : "aaac6b781ce888ab61ba7158e63e98b622c59dca033f9eb112456a8775d766da",
  "crawledAt" : "2025-12-04T09:59:57Z",
  "id" : "41C45EF3-13EB-4BF6-999D-9388CC0569E5",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nSometimes you need to preserve the entire result of a function call or other expression that can either throw or return a value. For example, you may need to serialize the result or pass it as a value to another part of your app that handles the result data. Use the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result] type in these scenarios to capture the result of a potentially failing operation.\n\n### Identify a Throwing Expression to Preserve\n\nTypically, you use `do-catch` statements to handle throwing expressions immediately, but sometimes you need to store the whole result of the operation for later processing during tasks like analyzing a batch of calls. The following example introduces an API that generates random numbers, but that fails approximately half of the time.\n\n### Convert the Throwing Expression to a Result\n\nYou preserve the return value or thrown error from a throwing expression using the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result] enumeration’s [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/init(catching:)] initializer. Invoke the throwing expression inside the closure you pass to the initializer:\n\nIn most scenarios, you use the preserved result as part of broader functionality in your code. For example, you may run a series of randomness tests and compute the statistical average of both a range of numbers returned from a random number generator, as well as the failure rate of calling the API. In these cases, you need to store the whole result rather than just the success value or that the API call failed.\n\nThe following example uses the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/init(catching:)] initializer in the broader context of saving a series of calls for later statistical analysis:\n\nRunning the analysis on a sufficiently large sample generates an average number near 50 and a failure rate near 50%:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/preserving-the-results-of-a-throwing-expression\ncrawled: 2025-12-04T09:59:57Z\n---\n\n# Preserving the Results of a Throwing Expression\n\n**Article**\n\nCall the initializer that wraps a throwing expression when you need to serialize or memoize the result.\n\n## Overview\n\nSometimes you need to preserve the entire result of a function call or other expression that can either throw or return a value. For example, you may need to serialize the result or pass it as a value to another part of your app that handles the result data. Use the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result] type in these scenarios to capture the result of a potentially failing operation.\n\n### Identify a Throwing Expression to Preserve\n\nTypically, you use `do-catch` statements to handle throwing expressions immediately, but sometimes you need to store the whole result of the operation for later processing during tasks like analyzing a batch of calls. The following example introduces an API that generates random numbers, but that fails approximately half of the time.\n\n```swift\nenum EntropyError: Error {\n    case entropyDepleted\n}\n\nstruct UnreliableRandomGenerator {\n    func random() throws -> Int {\n        if Bool.random() {\n            return Int.random(in: 1...100)\n        } else {\n            throw EntropyError.entropyDepleted\n        }\n    }\n}\n```\n\n### Convert the Throwing Expression to a Result\n\nYou preserve the return value or thrown error from a throwing expression using the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result] enumeration’s [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/init(catching:)] initializer. Invoke the throwing expression inside the closure you pass to the initializer:\n\n```swift\nlet singleSample = Result { try UnreliableRandomGenerator().random() }\n```\n\nIn most scenarios, you use the preserved result as part of broader functionality in your code. For example, you may run a series of randomness tests and compute the statistical average of both a range of numbers returned from a random number generator, as well as the failure rate of calling the API. In these cases, you need to store the whole result rather than just the success value or that the API call failed.\n\nThe following example uses the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Result\/init(catching:)] initializer in the broader context of saving a series of calls for later statistical analysis:\n\n```swift\nstruct RandomnessMonitor {\n    let randomnessSource: UnreliableRandomGenerator\n    var results: [Result<Int, Error>] = []\n\n    init(generator: UnreliableRandomGenerator) {\n        randomnessSource = generator\n    }\n\n    mutating func sample() {\n        let sample = Result { try randomnessSource.random() }\n        results.append(sample)\n    }\n\n    func summary() -> (Double, Double) {\n        let totals = results.reduce((sum: 0, count: 0)) { total, sample in\n            switch sample {\n            case .success(let number):\n                return (total.sum + number, total.count)\n            case .failure:\n                return (total.sum, total.count + 1)\n            }\n        }\n\n        return (\n            average: Double(totals.sum) \/ Double(results.count - totals.count),\n            failureRate: Double(totals.count) \/ Double(results.count)\n        )\n    }\n}\n```\n\nRunning the analysis on a sufficiently large sample generates an average number near 50 and a failure rate near 50%:\n\n```swift\nvar monitor = RandomnessMonitor(generator: UnreliableRandomGenerator())\n(0..<1000).forEach { _ in monitor.sample() }\nlet (average, failureRate) = monitor.summary()\nprint(\"Average value: \\(average), failure rate: \\(failureRate * 100.0)%.\")\n\/\/ Prints values such as: \"Average value: 47.95, failure rate: 48.69%.\"\n```\n\n## Converting a Throwing Expression to a Result\n\n- **init(catching:)**: Creates a new result by evaluating a throwing closure, capturing the returned value as a success, or any thrown error as a failure.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a new result by evaluating a throwing closure, capturing the returned value as a success, or any thrown error as a failure.",
          "name" : "init(catching:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Result\/init(catching:)"
        }
      ],
      "title" : "Converting a Throwing Expression to a Result"
    }
  ],
  "source" : "appleJSON",
  "title" : "Preserving the Results of a Throwing Expression",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/preserving-the-results-of-a-throwing-expression"
}