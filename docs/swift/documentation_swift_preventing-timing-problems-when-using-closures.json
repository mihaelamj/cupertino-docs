{
  "abstract" : "Understand how different API calls to your closures can affect your app.",
  "codeExamples" : [
    {
      "code" : "import Dispatch\nlet queue = DispatchQueue(label: \"com.example.queue\")\n\nfunc now(_ closure: () -> Void) {\n    closure()\n}\n\nfunc later(_ closure: @escaping () -> Void) {\n    queue.asyncAfter(deadline: .now() + 2) {\n        closure()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "later {\n    print(\"A\") \/\/ Eventually prints \"A\"\n}\nprint(\"B\") \/\/ Immediately prints \"B\"\n\nnow {\n    print(\"C\") \/\/ Immediately prints \"C\"\n}\nprint(\"D\") \/\/ Immedately prints \"D\"\n\n\/\/ Prevent the program from exiting immediately if you're running this code in Terminal.\nlet semaphore = DispatchSemaphore(value: 0).wait(timeout: .now() + 10)",
      "language" : "swift"
    },
    {
      "code" : "import Foundation\n\nlet file = FileHandle(forWritingAtPath: \"\/dev\/null\")!\nlet lines = [\"x,y\", \"1,1\", \"2,4\", \"3,9\", \"4,16\"]",
      "language" : "swift"
    },
    {
      "code" : "lines.forEach { line in\n    file.write(\"\\(line)\\n\".data(using: .utf8)!)\n}",
      "language" : "swift"
    },
    {
      "code" : "lines.forEach { line in\n    file.write(\"\\(line)\\n\".data(using: .utf8)!)\n}\n\nfile.closeFile()",
      "language" : "swift"
    },
    {
      "code" : "lines.forEach { line in\n    file.write(\"\\(line)\\n\".data(using: .utf8)!)\n    file.closeFile() \/\/ Error\n}",
      "language" : "swift"
    },
    {
      "code" : "enum Lottery {\n    static var lotteryWinHandler: (() -> Void)?\n\n    @discardableResult static func pickWinner(guess: Int) {\n        print(\"Running the lottery.\")\n        if guess == Int.random(in: 0 ..< 100_000_000), let winHandler = lotteryWinHandler {\n            winHandler()\n            return true\n        }\n\n        return false\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func payBills() {\n    amountOwed = 0\n}\n\nvar amountOwed = 25\nlet myLuckyNumber = 42\n\nLottery.lotteryWinHandler = {\n    print(\"Congratulations!\")\n    payBills()\n}\n\n\/\/ You get 10 chances at winning.\nfor _ in 1...10 {\n    Lottery.pickWinner(guess: myLuckyNumber)\n}\n\nif amountOwed > 0 {\n    fatalError(\"You need to pay your bills before proceeding.\")\n}\n\n\/\/ Code placed below this line runs only if the lottery was won.",
      "language" : "swift"
    }
  ],
  "contentHash" : "a9f53bc74e1aa377a72ff8d65ec7de0145238af6e17a4127557ec88ddd3f44e0",
  "crawledAt" : "2025-12-01T09:23:53Z",
  "id" : "B5975F8B-EED3-4B17-AAAD-1459B57D6909",
  "kind" : "article",
  "module" : "Swift",
  "overview" : "## Overview\n\nMany of the APIs you use in Swift take a closure—or a function passed as an instance—as a parameter. Because closures can contain code that interacts with multiple parts of an app, it’s important to understand the different ways closures can be called by the APIs you pass them to. Closures you pass to APIs can be called synchronously (immediately) or asynchronously (sometime later). They may be called once, many times, or never.\n\n### Understand the Results of Synchronous and Asynchronous Calls\n\nWhen you pass a closure to an API, consider *when* that closure will be called relative to the other code in your app. In synchronous APIs, the result of calling the closure will be available immediately after you pass the closure. In asynchronous APIs, the result won’t be available until sometime later; this difference affects how you write code both *in* your closure as well as the code *following* your closure.\n\nThe example below defines two functions, `now(_:)` and `later(_:)`. You can call both functions the same way: with a trailing closure and no other arguments. Both `now(_:)` and `later(_:)` accept a closure and call it, but `later(_:)` waits a couple seconds before calling its closure.\n\nThe `now(_:)` and `later(_:)` functions represent the two most common categories of APIs you’ll encounter in methods from app frameworks that take closures: synchronous APIs like `now(_:)`, and asynchronous APIs like `later(_:)`.\n\nBecause calling a closure can change the local and global state of your app, the code you write on the lines after passing a closure needs to be written with a careful consideration of *when* that closure is called. Even something as simple as printing a sequence of letters can be affected by the timing of a closure call:\n\nRunning the code in the example above usually prints the letters in the order `B` → `C` → `D` → `A`. Even though the line that prints `A` is first in the code, it’s ordered later in the output. The ordering difference happens due to the way the `now(_:)` and `later(_:)` functions are defined. You need to know how each function calls its closure if you write code that relies on a specific execution order.\n\nYou’ll need to consider this kind of time-based execution problem frequently when using APIs that take closures. In many cases, only one sequence of calls is correct for your app, so it’s important to think through what the state of your app will be, given the APIs you’re using. Use API names and parameter names along with documentation to determine whether an API is synchronous or asynchronous.\n\nA common timing mistake is expecting the results of an asynchronous call to be available within the calling synchronous code. For example, the `later(_:)` method above is comparable to the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] class’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/dataTask(with:completionHandler:)-52wk8] method, which is also asynchronous. A timing scenario you should avoid is calling the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/dataTask(with:completionHandler:)-52wk8] method within your app’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/viewDidLoad()] method and attempting to use the results outside of the closure you pass as the completion handler.\n\n### Don’t Write Code That Makes a One-Time Change in a Closure That’s Called Multiple Times\n\nIf you’re going to pass a closure to an API that might call it multiple times, omit code that’s intended to make a one-time change to external state.\n\nThe example below creates a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle] and an array of data lines to write to the file that the handle refers to:\n\nTo write each line to the file, pass a closure to the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Array\/forEach(_:)] method:\n\nWhen you’re finished using a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle], close it using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()]. The correct placement of the call to [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()] is outside of the closure:\n\nIf you misunderstand the requirements of [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()], you might place the call inside the closure. Doing so crashes your app:\n\n### Don’t Put Critical Code in a Closure That Might Not Be Called\n\nIf there’s a chance that a closure you pass to an API won’t be called, don’t put code that’s critical to continuing your app in the closure.\n\nThe example below defines a `Lottery` enumeration that randomly picks a winning number and calls a completion handler if the right number is guessed:\n\nWriting code that depends on the completion handler being called is dangerous. There’s no guarantee that the random guess will be correct, so important actions like paying bills—scheduled for after you win the lottery—might never happen.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/preventing-timing-problems-when-using-closures\ncrawled: 2025-12-01T09:23:53Z\n---\n\n# Preventing Timing Problems When Using Closures\n\n**Article**\n\nUnderstand how different API calls to your closures can affect your app.\n\n## Overview\n\nMany of the APIs you use in Swift take a closure—or a function passed as an instance—as a parameter. Because closures can contain code that interacts with multiple parts of an app, it’s important to understand the different ways closures can be called by the APIs you pass them to. Closures you pass to APIs can be called synchronously (immediately) or asynchronously (sometime later). They may be called once, many times, or never.\n\n\n\n### Understand the Results of Synchronous and Asynchronous Calls\n\nWhen you pass a closure to an API, consider *when* that closure will be called relative to the other code in your app. In synchronous APIs, the result of calling the closure will be available immediately after you pass the closure. In asynchronous APIs, the result won’t be available until sometime later; this difference affects how you write code both *in* your closure as well as the code *following* your closure.\n\nThe example below defines two functions, `now(_:)` and `later(_:)`. You can call both functions the same way: with a trailing closure and no other arguments. Both `now(_:)` and `later(_:)` accept a closure and call it, but `later(_:)` waits a couple seconds before calling its closure.\n\n```swift\nimport Dispatch\nlet queue = DispatchQueue(label: \"com.example.queue\")\n\nfunc now(_ closure: () -> Void) {\n    closure()\n}\n\nfunc later(_ closure: @escaping () -> Void) {\n    queue.asyncAfter(deadline: .now() + 2) {\n        closure()\n    }\n}\n```\n\nThe `now(_:)` and `later(_:)` functions represent the two most common categories of APIs you’ll encounter in methods from app frameworks that take closures: synchronous APIs like `now(_:)`, and asynchronous APIs like `later(_:)`.\n\nBecause calling a closure can change the local and global state of your app, the code you write on the lines after passing a closure needs to be written with a careful consideration of *when* that closure is called. Even something as simple as printing a sequence of letters can be affected by the timing of a closure call:\n\n```swift\nlater {\n    print(\"A\") \/\/ Eventually prints \"A\"\n}\nprint(\"B\") \/\/ Immediately prints \"B\"\n\nnow {\n    print(\"C\") \/\/ Immediately prints \"C\"\n}\nprint(\"D\") \/\/ Immedately prints \"D\"\n\n\/\/ Prevent the program from exiting immediately if you're running this code in Terminal.\nlet semaphore = DispatchSemaphore(value: 0).wait(timeout: .now() + 10)\n```\n\nRunning the code in the example above usually prints the letters in the order `B` → `C` → `D` → `A`. Even though the line that prints `A` is first in the code, it’s ordered later in the output. The ordering difference happens due to the way the `now(_:)` and `later(_:)` functions are defined. You need to know how each function calls its closure if you write code that relies on a specific execution order.\n\n\n\nYou’ll need to consider this kind of time-based execution problem frequently when using APIs that take closures. In many cases, only one sequence of calls is correct for your app, so it’s important to think through what the state of your app will be, given the APIs you’re using. Use API names and parameter names along with documentation to determine whether an API is synchronous or asynchronous.\n\nA common timing mistake is expecting the results of an asynchronous call to be available within the calling synchronous code. For example, the `later(_:)` method above is comparable to the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession] class’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/dataTask(with:completionHandler:)-52wk8] method, which is also asynchronous. A timing scenario you should avoid is calling the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/dataTask(with:completionHandler:)-52wk8] method within your app’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController\/viewDidLoad()] method and attempting to use the results outside of the closure you pass as the completion handler.\n\n### Don’t Write Code That Makes a One-Time Change in a Closure That’s Called Multiple Times\n\nIf you’re going to pass a closure to an API that might call it multiple times, omit code that’s intended to make a one-time change to external state.\n\nThe example below creates a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle] and an array of data lines to write to the file that the handle refers to:\n\n```swift\nimport Foundation\n\nlet file = FileHandle(forWritingAtPath: \"\/dev\/null\")!\nlet lines = [\"x,y\", \"1,1\", \"2,4\", \"3,9\", \"4,16\"]\n```\n\nTo write each line to the file, pass a closure to the [doc:\/\/com.apple.Swift\/documentation\/Swift\/Array\/forEach(_:)] method:\n\n```swift\nlines.forEach { line in\n    file.write(\"\\(line)\\n\".data(using: .utf8)!)\n}\n```\n\nWhen you’re finished using a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle], close it using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()]. The correct placement of the call to [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()] is outside of the closure:\n\n```swift\nlines.forEach { line in\n    file.write(\"\\(line)\\n\".data(using: .utf8)!)\n}\n\nfile.closeFile()\n```\n\nIf you misunderstand the requirements of [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileHandle\/closeFile()], you might place the call inside the closure. Doing so crashes your app:\n\n```swift\nlines.forEach { line in\n    file.write(\"\\(line)\\n\".data(using: .utf8)!)\n    file.closeFile() \/\/ Error\n}\n```\n\n### Don’t Put Critical Code in a Closure That Might Not Be Called\n\nIf there’s a chance that a closure you pass to an API won’t be called, don’t put code that’s critical to continuing your app in the closure.\n\nThe example below defines a `Lottery` enumeration that randomly picks a winning number and calls a completion handler if the right number is guessed:\n\n```swift\nenum Lottery {\n    static var lotteryWinHandler: (() -> Void)?\n\n    @discardableResult static func pickWinner(guess: Int) {\n        print(\"Running the lottery.\")\n        if guess == Int.random(in: 0 ..< 100_000_000), let winHandler = lotteryWinHandler {\n            winHandler()\n            return true\n        }\n\n        return false\n    }\n}\n```\n\nWriting code that depends on the completion handler being called is dangerous. There’s no guarantee that the random guess will be correct, so important actions like paying bills—scheduled for after you win the lottery—might never happen.\n\n```swift\nfunc payBills() {\n    amountOwed = 0\n}\n\nvar amountOwed = 25\nlet myLuckyNumber = 42\n\nLottery.lotteryWinHandler = {\n    print(\"Congratulations!\")\n    payBills()\n}\n\n\/\/ You get 10 chances at winning.\nfor _ in 1...10 {\n    Lottery.pickWinner(guess: myLuckyNumber)\n}\n\nif amountOwed > 0 {\n    fatalError(\"You need to pay your bills before proceeding.\")\n}\n\n\/\/ Code placed below this line runs only if the lottery was won.\n```\n\n## Data Flow and Control Flow\n\n- **Maintaining State in Your Apps**: Use enumerations to capture and track the state of your app.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use enumerations to capture and track the state of your app.",
          "name" : "Maintaining State in Your Apps",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/maintaining-state-in-your-apps"
        }
      ],
      "title" : "Data Flow and Control Flow"
    }
  ],
  "source" : "appleJSON",
  "title" : "Preventing Timing Problems When Using Closures",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/preventing-timing-problems-when-using-closures"
}