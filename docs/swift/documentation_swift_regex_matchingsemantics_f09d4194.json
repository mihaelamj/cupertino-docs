{
  "abstract" : "Returns a regular expression that matches with the specified semantic level.",
  "codeExamples" : [
    {
      "code" : "let composed = \"qué\"\nlet decomposed = \"que\\u{301}\"\n\nlet queRegex = \/^q..$\/\n\nprint(composed.contains(queRegex))\n\/\/ Prints \"true\"\nprint(decomposed.contains(queRegex))\n\/\/ Prints \"true\"",
      "language" : "swift"
    },
    {
      "code" : "let queRegexScalar = queRegex.matchingSemantics(.unicodeScalar)\nprint(composed.contains(queRegexScalar))\n\/\/ Prints \"true\"\nprint(decomposed.contains(queRegexScalar))\n\/\/ Prints \"false\"",
      "language" : "swift"
    }
  ],
  "contentHash" : "f37723e5c5466301f1af37d70721fb2e538b61bd7e0de61f1a3a23867b832f19",
  "crawledAt" : "2025-12-05T02:21:53Z",
  "declaration" : {
    "code" : "func matchingSemantics(_ semanticLevel: RegexSemanticLevel) -> Regex<Regex<Output>.RegexOutput>",
    "language" : "swift"
  },
  "id" : "79AB02BA-9C74-4429-85CB-69385DBFC6BF",
  "kind" : "method",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nThe modified regular expression.\n\n## Discussion\n\nWhen matching with grapheme cluster semantics (the default), metacharacters like `.` and `\\w`, custom character classes, and character class instances like `.any` match a grapheme cluster when possible, corresponding with the default string representation. In addition, matching with grapheme cluster semantics compares characters using their canonical representation, corresponding with how strings comparison works.\n\nWhen matching with Unicode scalar semantics, metacharacters and character classes always match a single Unicode scalar value, even if that scalar comprises part of a grapheme cluster.\n\nThese semantic levels can lead to different results, especially when working with strings that have decomposed characters. In the following example, `queRegex` matches any 3-character string that begins with `\"q\"`.\n\nWhen using Unicode scalar semantics, however, the regular expression only matches the composed version of the string, because each `.` matches a single Unicode scalar value.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/Regex\/matchingSemantics(_:)\ncrawled: 2025-12-05T02:21:53Z\n---\n\n# matchingSemantics(_:)\n\n**Instance Method**\n\nReturns a regular expression that matches with the specified semantic level.\n\n## Declaration\n\n```swift\nfunc matchingSemantics(_ semanticLevel: RegexSemanticLevel) -> Regex<Regex<Output>.RegexOutput>\n```\n\n## Parameters\n\n- **semanticLevel**: The semantics to use during matching.\n\n## Return Value\n\nThe modified regular expression.\n\n## Discussion\n\nWhen matching with grapheme cluster semantics (the default), metacharacters like `.` and `\\w`, custom character classes, and character class instances like `.any` match a grapheme cluster when possible, corresponding with the default string representation. In addition, matching with grapheme cluster semantics compares characters using their canonical representation, corresponding with how strings comparison works.\n\nWhen matching with Unicode scalar semantics, metacharacters and character classes always match a single Unicode scalar value, even if that scalar comprises part of a grapheme cluster.\n\nThese semantic levels can lead to different results, especially when working with strings that have decomposed characters. In the following example, `queRegex` matches any 3-character string that begins with `\"q\"`.\n\n```swift\nlet composed = \"qué\"\nlet decomposed = \"que\\u{301}\"\n\nlet queRegex = \/^q..$\/\n\nprint(composed.contains(queRegex))\n\/\/ Prints \"true\"\nprint(decomposed.contains(queRegex))\n\/\/ Prints \"true\"\n```\n\nWhen using Unicode scalar semantics, however, the regular expression only matches the composed version of the string, because each `.` matches a single Unicode scalar value.\n\n```swift\nlet queRegexScalar = queRegex.matchingSemantics(.unicodeScalar)\nprint(composed.contains(queRegexScalar))\n\/\/ Prints \"true\"\nprint(decomposed.contains(queRegexScalar))\n\/\/ Prints \"false\"\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "matchingSemantics(_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Regex\/matchingSemantics(_:)"
}