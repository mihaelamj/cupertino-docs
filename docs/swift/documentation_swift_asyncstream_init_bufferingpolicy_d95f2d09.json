{
  "abstract" : "Constructs an asynchronous stream for an element type, using the specified buffering policy and element-producing closure.",
  "codeExamples" : [
    {
      "code" : "let stream = AsyncStream<Int>(Int.self,\n                              bufferingPolicy: .bufferingNewest(5)) { continuation in\n    Task.detached {\n        for _ in 0..<100 {\n            await Task.sleep(1 * 1_000_000_000)\n            continuation.yield(Int.random(in: 1...10))\n        }\n        continuation.finish()\n    }\n}\n\n\/\/ Call point:\nfor await random in stream {\n    print(random)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "abcd91fbca38c4a6e111e2a6e90e668fcca595cd4ec9b6f3269fd1f3560b22cc",
  "crawledAt" : "2025-12-04T14:07:27Z",
  "declaration" : {
    "code" : "init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded, _ build: (AsyncStream<Element>.Continuation) -> Void)",
    "language" : "swift"
  },
  "id" : "13A52DB7-910E-440C-AFDA-0A437E6CB175",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Discussion\n\nThe `AsyncStream.Continuation` received by the `build` closure is appropriate for use in concurrent contexts. It is thread safe to send and finish; all calls to the continuation are serialized. However, calling this from multiple concurrent contexts could result in out-of-order delivery.\n\nThe following example shows an `AsyncStream` created with this initializer that produces 100 random numbers on a one-second interval, calling `yield(_:)` to deliver each element to the awaiting call point. When the `for` loop exits, the stream finishes by calling the continuation’s `finish()` method.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/AsyncStream\/init(_:bufferingPolicy:_:)\ncrawled: 2025-12-04T14:07:27Z\n---\n\n# init(_:bufferingPolicy:_:)\n\n**Initializer**\n\nConstructs an asynchronous stream for an element type, using the specified buffering policy and element-producing closure.\n\n## Declaration\n\n```swift\ninit(_ elementType: Element.Type = Element.self, bufferingPolicy limit: AsyncStream<Element>.Continuation.BufferingPolicy = .unbounded, _ build: (AsyncStream<Element>.Continuation) -> Void)\n```\n\n## Parameters\n\n- **elementType**: The type of element the `AsyncStream` produces.\n- **limit**: A `Continuation.BufferingPolicy` value to set the stream’s buffering behavior. By default, the stream buffers an unlimited number of elements. You can also set the policy to buffer a specified number of oldest or newest elements.\n- **build**: A custom closure that yields values to the `AsyncStream`. This closure receives an `AsyncStream.Continuation` instance that it uses to provide elements to the stream and terminate the stream when finished.\n\n## Discussion\n\nThe `AsyncStream.Continuation` received by the `build` closure is appropriate for use in concurrent contexts. It is thread safe to send and finish; all calls to the continuation are serialized. However, calling this from multiple concurrent contexts could result in out-of-order delivery.\n\nThe following example shows an `AsyncStream` created with this initializer that produces 100 random numbers on a one-second interval, calling `yield(_:)` to deliver each element to the awaiting call point. When the `for` loop exits, the stream finishes by calling the continuation’s `finish()` method.\n\n```swift\nlet stream = AsyncStream<Int>(Int.self,\n                              bufferingPolicy: .bufferingNewest(5)) { continuation in\n    Task.detached {\n        for _ in 0..<100 {\n            await Task.sleep(1 * 1_000_000_000)\n            continuation.yield(Int.random(in: 1...10))\n        }\n        continuation.finish()\n    }\n}\n\n\/\/ Call point:\nfor await random in stream {\n    print(random)\n}\n```\n\n## Creating a Continuation-Based Stream\n\n- **AsyncStream.Continuation.BufferingPolicy**: A strategy that handles exhaustion of a buffer’s capacity.\n- **AsyncStream.Continuation**: A mechanism to interface between synchronous code and an asynchronous stream.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A strategy that handles exhaustion of a buffer’s capacity.",
          "name" : "AsyncStream.Continuation.BufferingPolicy",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/AsyncStream\/Continuation\/BufferingPolicy"
        },
        {
          "description" : "A mechanism to interface between synchronous code and an asynchronous stream.",
          "name" : "AsyncStream.Continuation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/AsyncStream\/Continuation"
        }
      ],
      "title" : "Creating a Continuation-Based Stream"
    }
  ],
  "source" : "appleJSON",
  "title" : "init(_:bufferingPolicy:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/AsyncStream\/init(_:bufferingPolicy:_:)"
}