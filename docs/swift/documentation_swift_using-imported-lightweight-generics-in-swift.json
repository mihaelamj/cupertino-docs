{
  "abstract" : "Understand the constraints of imported Obj-C lightweight generic type declarations.",
  "codeExamples" : [
    {
      "code" : "@property NSArray<NSDate *> *dates;\n@property NSCache<NSObject *, id<NSDiscardableContent>> *cachedData;\n@property NSDictionary <NSString *, NSArray<NSLocale *> *> *supportedLocales;",
      "language" : "occ"
    },
    {
      "code" : "var dates: [Date]\nvar cachedData: NSCache<NSObject, NSDiscardableContent>\nvar supportedLocales: [String: [Locale]]",
      "language" : "swift"
    },
    {
      "code" : "@interface List<T: id<NSCopying>> : NSObject\n- (List<T> *)listByAppendingItemsInList:(List<T> *)otherList;\n@end\n\n@interface ListContainer : NSObject\n- (List<NSValue *> *)listOfValues;\n@end\n\n@interface ListContainer (ObjectList)\n- (List *)listOfObjects;\n@end",
      "language" : "occ"
    },
    {
      "code" : "class List<T: NSCopying> : NSObject {\n    func listByAppendingItemsInList(otherList: List<T>) -> List<T>\n}\n\nclass ListContainer : NSObject {\n    func listOfValues() -> List<NSValue>\n}\n\nextension ListContainer {\n    func listOfObjects() -> List<NSCopying>\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "5e82866c22b175e1cda04216e4be5a102d0a98241076c7f210319478696ffcf6",
  "crawledAt" : "2025-12-04T04:01:39Z",
  "id" : "FEF153BC-E929-4C18-881F-1132044732AF",
  "kind" : "article",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nObjective-C type declarations that use lightweight generic parameterization are imported by Swift with information about the type of their contents preserved. For example, given the following Objective-C property declarations:\n\nHere’s the Swift version of those declarations when you import them:\n\nA parameterized class written in Objective-C is imported into Swift as a generic class with the same number of type parameters. All Objective-C generic type parameters imported by Swift have a type constraint that requires that type to be a class (`T: AnyObject`).\n\nIf the Objective-C generic parameterization specifies class or protocols qualifications, the imported Swift declaration has a constraint that requires that type to be a subclass of the specified class or to conform to the specified protocol. For an unspecialized Objective-C type, Swift infers the generic parameterization for the imported class type constraints. For example, consider the following Objective-C class and category declarations:\n\nWhen you import these declarations into Swift, the `NSCopying` protocol qualification of the `List` type and the `NSValue` class qualification of the `listOfValues` method are preserved. In addition, the unqualified `listOfObjects` method uses the `NSCopying` generic constraint inferred from the `List` type.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/using-imported-lightweight-generics-in-swift\ncrawled: 2025-12-04T04:01:39Z\n---\n\n# Using Imported Lightweight Generics in Swift\n\n**Article**\n\nUnderstand the constraints of imported Obj-C lightweight generic type declarations.\n\n## Overview\n\nObjective-C type declarations that use lightweight generic parameterization are imported by Swift with information about the type of their contents preserved. For example, given the following Objective-C property declarations:\n\n```occ\n@property NSArray<NSDate *> *dates;\n@property NSCache<NSObject *, id<NSDiscardableContent>> *cachedData;\n@property NSDictionary <NSString *, NSArray<NSLocale *> *> *supportedLocales;\n```\n\nHere’s the Swift version of those declarations when you import them:\n\n```swift\nvar dates: [Date]\nvar cachedData: NSCache<NSObject, NSDiscardableContent>\nvar supportedLocales: [String: [Locale]]\n```\n\nA parameterized class written in Objective-C is imported into Swift as a generic class with the same number of type parameters. All Objective-C generic type parameters imported by Swift have a type constraint that requires that type to be a class (`T: AnyObject`).\n\nIf the Objective-C generic parameterization specifies class or protocols qualifications, the imported Swift declaration has a constraint that requires that type to be a subclass of the specified class or to conform to the specified protocol. For an unspecialized Objective-C type, Swift infers the generic parameterization for the imported class type constraints. For example, consider the following Objective-C class and category declarations:\n\n```occ\n@interface List<T: id<NSCopying>> : NSObject\n- (List<T> *)listByAppendingItemsInList:(List<T> *)otherList;\n@end\n\n@interface ListContainer : NSObject\n- (List<NSValue *> *)listOfValues;\n@end\n\n@interface ListContainer (ObjectList)\n- (List *)listOfObjects;\n@end\n```\n\nWhen you import these declarations into Swift, the `NSCopying` protocol qualification of the `List` type and the `NSValue` class qualification of the `listOfValues` method are preserved. In addition, the unqualified `listOfObjects` method uses the `NSCopying` generic constraint inferred from the `List` type.\n\n```swift\nclass List<T: NSCopying> : NSObject {\n    func listByAppendingItemsInList(otherList: List<T>) -> List<T>\n}\n\nclass ListContainer : NSObject {\n    func listOfValues() -> List<NSValue>\n}\n\nextension ListContainer {\n    func listOfObjects() -> List<NSCopying>\n}\n```\n\n## Objective-C APIs\n\n- **Using Imported Protocol-Qualified Classes in Swift**: Learn how imported Objective-C protocol-qualified classes and metaclasses are represented.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Learn how imported Objective-C protocol-qualified classes and metaclasses are represented.",
          "name" : "Using Imported Protocol-Qualified Classes in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/using-imported-protocol-qualified-classes-in-swift"
        }
      ],
      "title" : "Objective-C APIs"
    }
  ],
  "source" : "appleJSON",
  "title" : "Using Imported Lightweight Generics in Swift",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/using-imported-lightweight-generics-in-swift"
}