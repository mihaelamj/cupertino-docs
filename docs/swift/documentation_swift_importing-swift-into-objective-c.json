{
  "abstract" : "Access Swift types and declarations from within your Objective-C codebase.",
  "codeExamples" : [
    {
      "code" : "#import \"ProductModuleName-Swift.h\"",
      "language" : "occ"
    },
    {
      "code" : "#import <ProductName\/ProductModuleName-Swift.h>",
      "language" : "occ"
    },
    {
      "code" : "\/\/ MyObjcClass.h\n@class MySwiftClass;\n@protocol MySwiftProtocol;\n\n@interface MyObjcClass : NSObject\n- (MySwiftClass *)returnSwiftClassInstance;\n- (id <MySwiftProtocol>)returnInstanceAdoptingSwiftProtocol;\n\/\/ ...\n@end",
      "language" : "occ"
    }
  ],
  "contentHash" : "be788d92b52b0d9a1bf54f940163e19fc64b2f6c873cb73219d36045ca78613c",
  "crawledAt" : "2025-12-02T07:34:55Z",
  "id" : "00892126-4C32-4E03-91B0-C1E025F88CD8",
  "kind" : "article",
  "module" : "Swift",
  "overview" : "## Overview\n\nYou can work with types declared in Swift from within the Objective-C code in your project by importing an Xcode-generated header file. This file is an Objective-C header that declares the Swift interfaces in your target, and you can think of it as an umbrella header for your Swift code. You don’t need to do anything special to create the generated header—just import it to use its contents in your Objective-C code.\n\nThe header’s name is generated from your product module name, followed by `\"-Swift.h\"`. By default, this name is the same as your product name, with any nonalphanumeric characters replaced with an underscore (`_`). If the name begins with a number, the first digit is replaced with an underscore.\n\n\n\nThe process for importing Swift declarations into Objective-C code differs slightly depending on whether you’re writing an app or a framework. Both processes are described below.\n\n### Import Code Within an App Target\n\nWhen you’re building an app target, you can import your Swift code into any Objective-C `.m` file within that same target using this syntax and substituting the appropriate name:\n\nBy default, the generated header contains interfaces for Swift declarations marked with the `public` or `open` modifier. If your app target has an Objective-C bridging header, the generated header also includes interfaces marked with the `internal` modifier. Declarations marked with the `private` or `fileprivate` modifier don’t appear in the generated header, and aren’t exposed to the Objective-C runtime unless they are explicitly marked with a `@IBAction`, `@IBOutlet`, or `@objc` attribute. Inside unit test targets, you can access imported internal declarations as if they were public by prepending `@testable` to the product module import statement.\n\nThe Swift interfaces in the generated header include references to all of the Objective-C types used in them, so make sure to import the Objective-C headers for those types first.\n\nWhen building an app target, you can provide a custom name for the product module by changing the Product Module Name build setting. Xcode uses this name when naming the generated header file.\n\n### Import Code Within a Framework Target\n\nTo import a set of Swift files in the same framework target as your Objective-C code, import the Xcode-generated header for your Swift code into any Objective-C `.m` file where you want to use your Swift code.\n\nBecause the generated header is part of the framework’s public interface, only declarations marked with the `public` or `open` modifier appear in the generated header for a framework target. Methods and properties that are marked with the `internal` modifier and declared within a class that inherits from an Objective-C class are accessible to the Objective-C runtime. However, they’re inaccessible at compile time and don’t appear in the generated header for a framework target.\n\nImport Swift code into Objective-C within the same framework:\n\n### Include Swift Classes in Objective-C Headers Using Forward Declarations\n\nWhen declarations in an Objective-C header file refer to a Swift class or protocol that comes from the same target, importing the generated header creates a cyclical reference. To avoid this, use a forward declaration of the Swift class or protocol to reference it in an Objective-C interface.\n\nForward declarations of Swift classes and protocols can be used only as types for method and property declarations.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/importing-swift-into-objective-c\ncrawled: 2025-12-02T07:34:55Z\n---\n\n# Importing Swift into Objective-C\n\n**Article**\n\nAccess Swift types and declarations from within your Objective-C codebase.\n\n## Overview\n\nYou can work with types declared in Swift from within the Objective-C code in your project by importing an Xcode-generated header file. This file is an Objective-C header that declares the Swift interfaces in your target, and you can think of it as an umbrella header for your Swift code. You don’t need to do anything special to create the generated header—just import it to use its contents in your Objective-C code.\n\nThe header’s name is generated from your product module name, followed by `\"-Swift.h\"`. By default, this name is the same as your product name, with any nonalphanumeric characters replaced with an underscore (`_`). If the name begins with a number, the first digit is replaced with an underscore.\n\n\n\nThe process for importing Swift declarations into Objective-C code differs slightly depending on whether you’re writing an app or a framework. Both processes are described below.\n\n### Import Code Within an App Target\n\nWhen you’re building an app target, you can import your Swift code into any Objective-C `.m` file within that same target using this syntax and substituting the appropriate name:\n\n```occ\n#import \"ProductModuleName-Swift.h\"\n```\n\nBy default, the generated header contains interfaces for Swift declarations marked with the `public` or `open` modifier. If your app target has an Objective-C bridging header, the generated header also includes interfaces marked with the `internal` modifier. Declarations marked with the `private` or `fileprivate` modifier don’t appear in the generated header, and aren’t exposed to the Objective-C runtime unless they are explicitly marked with a `@IBAction`, `@IBOutlet`, or `@objc` attribute. Inside unit test targets, you can access imported internal declarations as if they were public by prepending `@testable` to the product module import statement.\n\nThe Swift interfaces in the generated header include references to all of the Objective-C types used in them, so make sure to import the Objective-C headers for those types first.\n\nWhen building an app target, you can provide a custom name for the product module by changing the Product Module Name build setting. Xcode uses this name when naming the generated header file.\n\n### Import Code Within a Framework Target\n\nTo import a set of Swift files in the same framework target as your Objective-C code, import the Xcode-generated header for your Swift code into any Objective-C `.m` file where you want to use your Swift code.\n\nBecause the generated header is part of the framework’s public interface, only declarations marked with the `public` or `open` modifier appear in the generated header for a framework target. Methods and properties that are marked with the `internal` modifier and declared within a class that inherits from an Objective-C class are accessible to the Objective-C runtime. However, they’re inaccessible at compile time and don’t appear in the generated header for a framework target.\n\nImport Swift code into Objective-C within the same framework:\n\n1. Under Build Settings, in Packaging, make sure the Defines Module setting for that framework target is set to Yes.\n2. Import the Swift code from that framework target into any Objective-C `.m` file within that target using this syntax and substituting the appropriate names:\n\n```occ\n#import <ProductName\/ProductModuleName-Swift.h>\n```\n\n### Include Swift Classes in Objective-C Headers Using Forward Declarations\n\nWhen declarations in an Objective-C header file refer to a Swift class or protocol that comes from the same target, importing the generated header creates a cyclical reference. To avoid this, use a forward declaration of the Swift class or protocol to reference it in an Objective-C interface.\n\n```occ\n\/\/ MyObjcClass.h\n@class MySwiftClass;\n@protocol MySwiftProtocol;\n\n@interface MyObjcClass : NSObject\n- (MySwiftClass *)returnSwiftClassInstance;\n- (id <MySwiftProtocol>)returnInstanceAdoptingSwiftProtocol;\n\/\/ ...\n@end\n```\n\nForward declarations of Swift classes and protocols can be used only as types for method and property declarations.\n\n## Swift and Objective-C in the Same Project\n\n- **Importing Objective-C into Swift**: Access classes and other declarations from your Objective-C code in Swift.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Access classes and other declarations from your Objective-C code in Swift.",
          "name" : "Importing Objective-C into Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/importing-objective-c-into-swift"
        }
      ],
      "title" : "Swift and Objective-C in the Same Project"
    }
  ],
  "source" : "appleJSON",
  "title" : "Importing Swift into Objective-C",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/importing-swift-into-objective-c"
}