{
  "abstract" : "Creates a sequence of pairs built out of two underlying sequences.",
  "codeExamples" : [
    {
      "code" : "let words = [\"one\", \"two\", \"three\", \"four\"]\nlet numbers = 1...4\n\nfor (word, number) in zip(words, numbers) {\n    print(\"\\(word): \\(number)\")\n}\n\/\/ Prints \"one: 1\"\n\/\/ Prints \"two: 2\"\n\/\/ Prints \"three: 3\"\n\/\/ Prints \"four: 4\"",
      "language" : "swift"
    },
    {
      "code" : "let naturalNumbers = 1...Int.max\nlet zipped = Array(zip(words, naturalNumbers))\n\/\/ zipped == [(\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4)]",
      "language" : "swift"
    }
  ],
  "contentHash" : "1e4579a6abd0cdd708813aa60efcb098a8d21782d673ea774f3fb80a67fbeb3a",
  "crawledAt" : "2025-12-03T16:52:35Z",
  "declaration" : {
    "code" : "func zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Sequence, Sequence2 : Sequence",
    "language" : "swift"
  },
  "id" : "3E6FD2B2-12BE-49E1-B981-89E0C1D99482",
  "kind" : "function",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Return Value\n\nA sequence of tuple pairs, where the elements of each pair are corresponding elements of `sequence1` and `sequence2`.\n\n## Discussion\n\nIn the `Zip2Sequence` instance returned by this function, the elements of the *i*th pair are the *i*th elements of each underlying sequence. The following example uses the `zip(_:_:)` function to iterate over an array of strings and a countable range at the same time:\n\nIf the two sequences passed to `zip(_:_:)` are different lengths, the resulting sequence is the same length as the shorter sequence. In this example, the resulting array is the same length as `words`:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/zip(_:_:)\ncrawled: 2025-12-03T16:52:35Z\n---\n\n# zip(_:_:)\n\n**Function**\n\nCreates a sequence of pairs built out of two underlying sequences.\n\n## Declaration\n\n```swift\nfunc zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Sequence, Sequence2 : Sequence\n```\n\n## Parameters\n\n- **sequence1**: The first sequence or collection to zip.\n- **sequence2**: The second sequence or collection to zip.\n\n## Return Value\n\nA sequence of tuple pairs, where the elements of each pair are corresponding elements of `sequence1` and `sequence2`.\n\n## Discussion\n\nIn the `Zip2Sequence` instance returned by this function, the elements of the *i*th pair are the *i*th elements of each underlying sequence. The following example uses the `zip(_:_:)` function to iterate over an array of strings and a countable range at the same time:\n\n```swift\nlet words = [\"one\", \"two\", \"three\", \"four\"]\nlet numbers = 1...4\n\nfor (word, number) in zip(words, numbers) {\n    print(\"\\(word): \\(number)\")\n}\n\/\/ Prints \"one: 1\"\n\/\/ Prints \"two: 2\"\n\/\/ Prints \"three: 3\"\n\/\/ Prints \"four: 4\"\n```\n\nIf the two sequences passed to `zip(_:_:)` are different lengths, the resulting sequence is the same length as the shorter sequence. In this example, the resulting array is the same length as `words`:\n\n```swift\nlet naturalNumbers = 1...Int.max\nlet zipped = Array(zip(words, naturalNumbers))\n\/\/ zipped == [(\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4)]\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "zip(_:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/zip(_:_:)"
}