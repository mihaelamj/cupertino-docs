{
  "abstract" : "A type representing an error value that can be thrown.",
  "codeExamples" : [
    {
      "code" : "enum IntParsingError: Error {\n    case overflow\n    case invalidInput(Character)\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Int {\n    init(validating input: String) throws {\n        \/\/ ...\n        let c = _nextCharacter(from: input)\n        if !_isValid(c) {\n            throw IntParsingError.invalidInput(c)\n        }\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "do {\n    let price = try Int(validating: \"$100\")\n} catch IntParsingError.invalidInput(let invalid) {\n    print(\"Invalid character: '\\(invalid)'\")\n} catch IntParsingError.overflow {\n    print(\"Overflow error\")\n} catch {\n    print(\"Other error\")\n}\n\/\/ Prints \"Invalid character: '$'\"",
      "language" : "swift"
    },
    {
      "code" : "struct XMLParsingError: Error {\n    enum Kind {\n        case invalidCharacter\n        case mismatchedTag\n        case internalError\n    }\n\n    let line: Int\n    let column: Int\n    let kind: Kind\n}\n\nfunc parse(_ source: String) throws -> XMLDoc {\n    \/\/ ...\n    throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)\n    \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "do {\n    let xmlDoc = try parse(myXMLData)\n} catch let e as XMLParsingError {\n    print(\"Parsing error: \\(e.kind) [\\(e.line):\\(e.column)]\")\n} catch {\n    print(\"Other error: \\(error)\")\n}\n\/\/ Prints \"Parsing error: mismatchedTag [19:5]\"",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "CancellationError",
    "DecodingError",
    "DistributedActorCodingError",
    "EncodingError",
    "ExecuteDistributedTargetError",
    "LocalTestingDistributedActorSystemError",
    "Never",
    "Unicode.UTF8.ValidationError",
    "Unicode.UTF8.ValidationError.Kind"
  ],
  "contentHash" : "840e86de3d493d8045f1b14a9586fde5447d65b4b680c986f91ebd40aa38e694",
  "crawledAt" : "2025-12-03T20:02:03Z",
  "declaration" : {
    "code" : "protocol Error : Sendable",
    "language" : "swift"
  },
  "id" : "E1D1089B-23DC-4B0B-806F-07E9ECD532CC",
  "inheritedBy" : [
    "DistributedActorSystemError"
  ],
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nAny type that declares conformance to the `Error` protocol can be used to represent an error in Swift’s error handling system. Because the `Error` protocol has no requirements of its own, you can declare conformance on any custom type you create.\n\n# Using Enumerations as Errors\n\nSwift’s enumerations are well suited to represent simple errors. Create an enumeration that conforms to the `Error` protocol with a case for each possible error. If there are additional details about the error that could be helpful for recovery, use associated values to include that information.\n\nThe following example shows an `IntParsingError` enumeration that captures two different kinds of errors that can occur when parsing an integer from a string: overflow, where the value represented by the string is too large for the integer data type, and invalid input, where nonnumeric characters are found within the input.\n\nThe `invalidInput` case includes the invalid character as an associated value.\n\nThe next code sample shows a possible extension to the `Int` type that parses the integer value of a `String` instance, throwing an error when there is a problem during parsing.\n\nWhen calling the new `Int` initializer within a `do` statement, you can use pattern matching to match specific cases of your custom error type and access their associated values, as in the example below.\n\n# Including More Data in Errors\n\nSometimes you may want different error states to include the same common data, such as the position in a file or some of your application’s state. When you do, use a structure to represent errors. The following example uses a structure to represent an error when parsing an XML document, including the line and column numbers where the error occurred:\n\nOnce again, use pattern matching to conditionally catch errors. Here’s how you can catch any `XMLParsingError` errors thrown by the `parse(_:)` function:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/error\ncrawled: 2025-12-03T20:02:03Z\n---\n\n# Error\n\n**Protocol**\n\nA type representing an error value that can be thrown.\n\n## Declaration\n\n```swift\nprotocol Error : Sendable\n```\n\n## Overview\n\nAny type that declares conformance to the `Error` protocol can be used to represent an error in Swift’s error handling system. Because the `Error` protocol has no requirements of its own, you can declare conformance on any custom type you create.\n\n# Using Enumerations as Errors\n\nSwift’s enumerations are well suited to represent simple errors. Create an enumeration that conforms to the `Error` protocol with a case for each possible error. If there are additional details about the error that could be helpful for recovery, use associated values to include that information.\n\nThe following example shows an `IntParsingError` enumeration that captures two different kinds of errors that can occur when parsing an integer from a string: overflow, where the value represented by the string is too large for the integer data type, and invalid input, where nonnumeric characters are found within the input.\n\n```swift\nenum IntParsingError: Error {\n    case overflow\n    case invalidInput(Character)\n}\n```\n\nThe `invalidInput` case includes the invalid character as an associated value.\n\nThe next code sample shows a possible extension to the `Int` type that parses the integer value of a `String` instance, throwing an error when there is a problem during parsing.\n\n```swift\nextension Int {\n    init(validating input: String) throws {\n        \/\/ ...\n        let c = _nextCharacter(from: input)\n        if !_isValid(c) {\n            throw IntParsingError.invalidInput(c)\n        }\n        \/\/ ...\n    }\n}\n```\n\nWhen calling the new `Int` initializer within a `do` statement, you can use pattern matching to match specific cases of your custom error type and access their associated values, as in the example below.\n\n```swift\ndo {\n    let price = try Int(validating: \"$100\")\n} catch IntParsingError.invalidInput(let invalid) {\n    print(\"Invalid character: '\\(invalid)'\")\n} catch IntParsingError.overflow {\n    print(\"Overflow error\")\n} catch {\n    print(\"Other error\")\n}\n\/\/ Prints \"Invalid character: '$'\"\n```\n\n# Including More Data in Errors\n\nSometimes you may want different error states to include the same common data, such as the position in a file or some of your application’s state. When you do, use a structure to represent errors. The following example uses a structure to represent an error when parsing an XML document, including the line and column numbers where the error occurred:\n\n```swift\nstruct XMLParsingError: Error {\n    enum Kind {\n        case invalidCharacter\n        case mismatchedTag\n        case internalError\n    }\n\n    let line: Int\n    let column: Int\n    let kind: Kind\n}\n\nfunc parse(_ source: String) throws -> XMLDoc {\n    \/\/ ...\n    throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)\n    \/\/ ...\n}\n```\n\nOnce again, use pattern matching to conditionally catch errors. Here’s how you can catch any `XMLParsingError` errors thrown by the `parse(_:)` function:\n\n```swift\ndo {\n    let xmlDoc = try parse(myXMLData)\n} catch let e as XMLParsingError {\n    print(\"Parsing error: \\(e.kind) [\\(e.line):\\(e.column)]\")\n} catch {\n    print(\"Other error: \\(error)\")\n}\n\/\/ Prints \"Parsing error: mismatchedTag [19:5]\"\n```\n\n## Describing an Error\n\n- **localizedDescription**: Retrieve the localized description for this error.\n\n## Errors\n\n- **Result**: A value that represents either a success or a failure, including an associated value in each case.\n\n## Inherits From\n\n- Sendable\n- SendableMetatype\n\n## Inherited By\n\n- DistributedActorSystemError\n\n## Conforming Types\n\n- CancellationError\n- DecodingError\n- DistributedActorCodingError\n- EncodingError\n- ExecuteDistributedTargetError\n- LocalTestingDistributedActorSystemError\n- Never\n- Unicode.UTF8.ValidationError\n- Unicode.UTF8.ValidationError.Kind\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Retrieve the localized description for this error.",
          "name" : "localizedDescription",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Error\/localizedDescription"
        }
      ],
      "title" : "Describing an Error"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A value that represents either a success or a failure, including an associated value in each case.",
          "name" : "Result",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Result"
        }
      ],
      "title" : "Errors"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "Sendable"
        },
        {
          "name" : "SendableMetatype"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "Error",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/error"
}