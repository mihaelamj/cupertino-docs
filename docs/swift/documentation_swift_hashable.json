{
  "abstract" : "A type that can be hashed into a `Hasher` to produce an integer hash value.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ A point in an x-y coordinate system.\nstruct GridPoint {\n    var x: Int\n    var y: Int\n}",
      "language" : "swift"
    },
    {
      "code" : "extension GridPoint: Hashable {\n    static func == (lhs: GridPoint, rhs: GridPoint) -> Bool {\n        return lhs.x == rhs.x && lhs.y == rhs.y\n    }\n\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(x)\n        hasher.combine(y)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]\nlet nextTap = GridPoint(x: 0, y: 1)\nif tappedPoints.contains(nextTap) {\n    print(\"Already tapped at (\\(nextTap.x), \\(nextTap.y)).\")\n} else {\n    tappedPoints.insert(nextTap)\n    print(\"New tap detected at (\\(nextTap.x), \\(nextTap.y)).\")\n}\n\/\/ Prints \"New tap detected at (0, 1).\")",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "AnyHashable",
    "AnyKeyPath",
    "Array",
    "ArraySlice",
    "AsyncStream.Continuation",
    "AsyncStream.Continuation.Termination",
    "AsyncThrowingStream.Continuation",
    "AtomicLoadOrdering",
    "AtomicStoreOrdering",
    "AtomicUpdateOrdering",
    "AutoreleasingUnsafeMutablePointer",
    "Bool",
    "Character",
    "ClosedRange",
    "ClosedRange.Index",
    "CodingUserInfoKey",
    "CollectionDifference",
    "CollectionDifference.Change",
    "CollectionDifference.Index",
    "ContiguousArray",
    "ContinuousClock.Instant",
    "Dictionary",
    "Dictionary.Index",
    "DiscontiguousSlice",
    "DiscontiguousSlice.Index",
    "Double",
    "Duration",
    "Duration.TimeFormatStyle",
    "Duration.TimeFormatStyle.Attributed",
    "Duration.TimeFormatStyle.Pattern",
    "Duration.UnitsFormatStyle",
    "Duration.UnitsFormatStyle.Attributed",
    "Duration.UnitsFormatStyle.FractionalPartDisplayStrategy",
    "Duration.UnitsFormatStyle.Unit",
    "Duration.UnitsFormatStyle.UnitWidth",
    "Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy",
    "ExecuteDistributedTargetError.ErrorCode",
    "FlattenSequence.Index",
    "Float",
    "Float16",
    "Float80",
    "FloatingPointClassification",
    "FloatingPointRoundingRule",
    "FloatingPointSign",
    "Int",
    "Int128",
    "Int16",
    "Int32",
    "Int64",
    "Int8",
    "KeyPath",
    "LazyPrefixWhileSequence.Index",
    "LocalTestingActorID",
    "Mirror.DisplayStyle",
    "Never",
    "ObjectIdentifier",
    "ObservationRegistrar",
    "OpaquePointer",
    "Optional",
    "PartialKeyPath",
    "Range",
    "RangeSet",
    "RangeSet.Ranges",
    "ReferenceWritableKeyPath",
    "RegexRepetitionBehavior",
    "RegexSemanticLevel",
    "RegexWordBoundaryKind",
    "RemoteCallTarget",
    "Result",
    "ReversedCollection.Index",
    "SIMD16",
    "SIMD2",
    "SIMD3",
    "SIMD32",
    "SIMD4",
    "SIMD64",
    "SIMD8",
    "SIMDMask",
    "Set",
    "Set.Index",
    "String",
    "String.Comparator",
    "String.Encoding",
    "String.Index",
    "String.IntentInputOptions.CapitalizationType",
    "String.IntentInputOptions.KeyboardType",
    "String.LocalizationValue.Placeholder",
    "String.StandardComparator",
    "Substring",
    "SuspendingClock.Instant",
    "Task",
    "UInt",
    "UInt128",
    "UInt16",
    "UInt32",
    "UInt64",
    "UInt8",
    "Unicode.CanonicalCombiningClass",
    "Unicode.GeneralCategory",
    "Unicode.NumericType",
    "Unicode.Scalar",
    "Unicode.UTF32",
    "Unicode.UTF8.ValidationError",
    "Unicode.UTF8.ValidationError.Kind",
    "UnsafeCurrentTask",
    "UnsafeMutablePointer",
    "UnsafeMutableRawPointer",
    "UnsafePointer",
    "UnsafeRawPointer",
    "WordPair",
    "WritableKeyPath"
  ],
  "contentHash" : "c33c709c4b4cea71b6a601e7bcbfea277ae1fb9df8809e4a83cea249ddbf8d09",
  "crawledAt" : "2025-12-02T18:07:21Z",
  "declaration" : {
    "code" : "protocol Hashable : Equatable",
    "language" : "swift"
  },
  "id" : "8183AD73-B5C1-4E35-9FC0-0E96E624976D",
  "inheritedBy" : [
    "BinaryFloatingPoint",
    "BinaryInteger",
    "DistributedActor",
    "FixedWidthInteger",
    "FloatingPoint",
    "InstantProtocol",
    "SIMD",
    "SignedInteger",
    "StringProtocol",
    "UnsignedInteger"
  ],
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nYou can use any type that conforms to the `Hashable` protocol in a set or as a dictionary key. Many types in the standard library conform to `Hashable`: Strings, integers, floating-point and Boolean values, and even sets are hashable by default. Some other types, such as optionals, arrays and ranges automatically become hashable when their type arguments implement the same.\n\nYour own custom types can be hashable as well. When you define an enumeration without associated values, it gains `Hashable` conformance automatically, and you can add `Hashable` conformance to your other custom types by implementing the `hash(into:)` method. For structs whose stored properties are all `Hashable`, and for enum types that have all-`Hashable` associated values, the compiler is able to provide an implementation of `hash(into:)` automatically.\n\nHashing a value means feeding its essential components into a hash function, represented by the `Hasher` type. Essential components are those that contribute to the type’s implementation of `Equatable`. Two instances that are equal must feed the same values to `Hasher` in `hash(into:)`, in the same order.\n\n# Conforming to the Hashable Protocol\n\nTo use your own custom type in a set or as the key type of a dictionary, add `Hashable` conformance to your type. The `Hashable` protocol inherits from the `Equatable` protocol, so you must also satisfy that protocol’s requirements.\n\nThe compiler automatically synthesizes your custom type’s `Hashable` and requirements when you declare `Hashable` conformance in the type’s original declaration and your type meets these criteria:\n\nTo customize your type’s `Hashable` conformance, to adopt `Hashable` in a type that doesn’t meet the criteria listed above, or to extend an existing type to conform to `Hashable`, implement the `hash(into:)` method in your custom type.\n\nIn your `hash(into:)` implementation, call `combine(_:)` on the provided `Hasher` instance with the essential components of your type. To ensure that your type meets the semantic requirements of the `Hashable` and `Equatable` protocols, it’s a good idea to also customize your type’s `Equatable` conformance to match.\n\nAs an example, consider a `GridPoint` type that describes a location in a grid of buttons. Here’s the initial declaration of the `GridPoint` type:\n\nYou’d like to create a set of the grid points where a user has already tapped. Because the `GridPoint` type is not hashable yet, it can’t be used in a set. To add `Hashable` conformance, provide an `==` operator function and implement the `hash(into:)` method.\n\nThe `hash(into:)` method in this example feeds the grid point’s `x` and `y` properties into the provided hasher. These properties are the same ones used to test for equality in the `==` operator function.\n\nNow that `GridPoint` conforms to the `Hashable` protocol, you can create a set of previously tapped grid points.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/Hashable\ncrawled: 2025-12-02T18:07:21Z\n---\n\n# Hashable\n\n**Protocol**\n\nA type that can be hashed into a `Hasher` to produce an integer hash value.\n\n## Declaration\n\n```swift\nprotocol Hashable : Equatable\n```\n\n## Overview\n\nYou can use any type that conforms to the `Hashable` protocol in a set or as a dictionary key. Many types in the standard library conform to `Hashable`: Strings, integers, floating-point and Boolean values, and even sets are hashable by default. Some other types, such as optionals, arrays and ranges automatically become hashable when their type arguments implement the same.\n\nYour own custom types can be hashable as well. When you define an enumeration without associated values, it gains `Hashable` conformance automatically, and you can add `Hashable` conformance to your other custom types by implementing the `hash(into:)` method. For structs whose stored properties are all `Hashable`, and for enum types that have all-`Hashable` associated values, the compiler is able to provide an implementation of `hash(into:)` automatically.\n\nHashing a value means feeding its essential components into a hash function, represented by the `Hasher` type. Essential components are those that contribute to the type’s implementation of `Equatable`. Two instances that are equal must feed the same values to `Hasher` in `hash(into:)`, in the same order.\n\n# Conforming to the Hashable Protocol\n\nTo use your own custom type in a set or as the key type of a dictionary, add `Hashable` conformance to your type. The `Hashable` protocol inherits from the `Equatable` protocol, so you must also satisfy that protocol’s requirements.\n\nThe compiler automatically synthesizes your custom type’s `Hashable` and requirements when you declare `Hashable` conformance in the type’s original declaration and your type meets these criteria:\n\n- For a `struct`, all its stored properties must conform to `Hashable`.\n- For an `enum`, all its associated values must conform to `Hashable`. (An `enum` without associated values has `Hashable` conformance even without the declaration.)\n\nTo customize your type’s `Hashable` conformance, to adopt `Hashable` in a type that doesn’t meet the criteria listed above, or to extend an existing type to conform to `Hashable`, implement the `hash(into:)` method in your custom type.\n\nIn your `hash(into:)` implementation, call `combine(_:)` on the provided `Hasher` instance with the essential components of your type. To ensure that your type meets the semantic requirements of the `Hashable` and `Equatable` protocols, it’s a good idea to also customize your type’s `Equatable` conformance to match.\n\nAs an example, consider a `GridPoint` type that describes a location in a grid of buttons. Here’s the initial declaration of the `GridPoint` type:\n\n```swift\n\/\/\/ A point in an x-y coordinate system.\nstruct GridPoint {\n    var x: Int\n    var y: Int\n}\n```\n\nYou’d like to create a set of the grid points where a user has already tapped. Because the `GridPoint` type is not hashable yet, it can’t be used in a set. To add `Hashable` conformance, provide an `==` operator function and implement the `hash(into:)` method.\n\n```swift\nextension GridPoint: Hashable {\n    static func == (lhs: GridPoint, rhs: GridPoint) -> Bool {\n        return lhs.x == rhs.x && lhs.y == rhs.y\n    }\n\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(x)\n        hasher.combine(y)\n    }\n}\n```\n\nThe `hash(into:)` method in this example feeds the grid point’s `x` and `y` properties into the provided hasher. These properties are the same ones used to test for equality in the `==` operator function.\n\nNow that `GridPoint` conforms to the `Hashable` protocol, you can create a set of previously tapped grid points.\n\n```swift\nvar tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]\nlet nextTap = GridPoint(x: 0, y: 1)\nif tappedPoints.contains(nextTap) {\n    print(\"Already tapped at (\\(nextTap.x), \\(nextTap.y)).\")\n} else {\n    tappedPoints.insert(nextTap)\n    print(\"New tap detected at (\\(nextTap.x), \\(nextTap.y)).\")\n}\n\/\/ Prints \"New tap detected at (0, 1).\")\n```\n\n## Providing a Hash Value\n\n- **hash(into:)**: Hashes the essential components of this value by feeding them into the given hasher.\n\n## Deprecated\n\n- **hashValue**: The hash value.\n\n## Sets and Dictionaries\n\n- **Hasher**: The universal hash function used by `Set` and `Dictionary`.\n\n## Inherits From\n\n- Equatable\n\n## Inherited By\n\n- BinaryFloatingPoint\n- BinaryInteger\n- DistributedActor\n- FixedWidthInteger\n- FloatingPoint\n- InstantProtocol\n- SIMD\n- SignedInteger\n- StringProtocol\n- UnsignedInteger\n\n## Conforming Types\n\n- AnyHashable\n- AnyKeyPath\n- Array\n- ArraySlice\n- AsyncStream.Continuation\n- AsyncStream.Continuation.Termination\n- AsyncThrowingStream.Continuation\n- AtomicLoadOrdering\n- AtomicStoreOrdering\n- AtomicUpdateOrdering\n- AutoreleasingUnsafeMutablePointer\n- Bool\n- Character\n- ClosedRange\n- ClosedRange.Index\n- CodingUserInfoKey\n- CollectionDifference\n- CollectionDifference.Change\n- CollectionDifference.Index\n- ContiguousArray\n- ContinuousClock.Instant\n- Dictionary\n- Dictionary.Index\n- DiscontiguousSlice\n- DiscontiguousSlice.Index\n- Double\n- Duration\n- Duration.TimeFormatStyle\n- Duration.TimeFormatStyle.Attributed\n- Duration.TimeFormatStyle.Pattern\n- Duration.UnitsFormatStyle\n- Duration.UnitsFormatStyle.Attributed\n- Duration.UnitsFormatStyle.FractionalPartDisplayStrategy\n- Duration.UnitsFormatStyle.Unit\n- Duration.UnitsFormatStyle.UnitWidth\n- Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy\n- ExecuteDistributedTargetError.ErrorCode\n- FlattenSequence.Index\n- Float\n- Float16\n- Float80\n- FloatingPointClassification\n- FloatingPointRoundingRule\n- FloatingPointSign\n- Int\n- Int128\n- Int16\n- Int32\n- Int64\n- Int8\n- KeyPath\n- LazyPrefixWhileSequence.Index\n- LocalTestingActorID\n- Mirror.DisplayStyle\n- Never\n- ObjectIdentifier\n- ObservationRegistrar\n- OpaquePointer\n- Optional\n- PartialKeyPath\n- Range\n- RangeSet\n- RangeSet.Ranges\n- ReferenceWritableKeyPath\n- RegexRepetitionBehavior\n- RegexSemanticLevel\n- RegexWordBoundaryKind\n- RemoteCallTarget\n- Result\n- ReversedCollection.Index\n- SIMD16\n- SIMD2\n- SIMD3\n- SIMD32\n- SIMD4\n- SIMD64\n- SIMD8\n- SIMDMask\n- Set\n- Set.Index\n- String\n- String.Comparator\n- String.Encoding\n- String.Index\n- String.IntentInputOptions.CapitalizationType\n- String.IntentInputOptions.KeyboardType\n- String.LocalizationValue.Placeholder\n- String.StandardComparator\n- Substring\n- SuspendingClock.Instant\n- Task\n- UInt\n- UInt128\n- UInt16\n- UInt32\n- UInt64\n- UInt8\n- Unicode.CanonicalCombiningClass\n- Unicode.GeneralCategory\n- Unicode.NumericType\n- Unicode.Scalar\n- Unicode.UTF32\n- Unicode.UTF8.ValidationError\n- Unicode.UTF8.ValidationError.Kind\n- UnsafeCurrentTask\n- UnsafeMutablePointer\n- UnsafeMutableRawPointer\n- UnsafePointer\n- UnsafeRawPointer\n- WordPair\n- WritableKeyPath\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Hashes the essential components of this value by feeding them into the given hasher.",
          "name" : "hash(into:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Hashable\/hash(into:)"
        }
      ],
      "title" : "Providing a Hash Value"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The hash value.",
          "name" : "hashValue",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Hashable\/hashValue"
        }
      ],
      "title" : "Deprecated"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The universal hash function used by `Set` and `Dictionary`.",
          "name" : "Hasher",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Hasher"
        }
      ],
      "title" : "Sets and Dictionaries"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "Equatable"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "Hashable",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Hashable"
}