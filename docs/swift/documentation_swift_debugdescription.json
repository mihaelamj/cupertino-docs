{
  "abstract" : "Converts description definitions to a debugger Type Summary.",
  "codeExamples" : [
    {
      "code" : "@DebugDescription\nstruct Team: CustomDebugStringConvertible {\n   var name: String\n   var wins, losses: Int\n\n   var debugDescription: String {\n       \"\\(name) [\\(wins)-\\(losses)]\"\n   }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "f45ce5d7961de00abef8bfe395e2aaa6217328e79e7b1ff6b5c76066fa8d618b",
  "crawledAt" : "2025-12-01T21:05:53Z",
  "declaration" : {
    "code" : "@attached(member) @attached(memberAttribute) macro DebugDescription()",
    "language" : "swift"
  },
  "id" : "797EE61F-C051-4B9C-9438-A0BBD01DCE4F",
  "kind" : "macro",
  "module" : "Swift",
  "overview" : "## Overview\n\nThis macro converts compatible description implementations written in Swift to an LLDB format known as a Type Summary. A Type Summary is LLDB’s equivalent to `debugDescription`, with the distinction that it does not execute code inside the debugged process. By avoiding code execution, descriptions can be produced faster, without potential side effects, and shown in situations where code execution is not performed, such as the variable list of an IDE.\n\nConsider this an example. This `Team` struct has a `debugDescription` which summarizes some key details, such as the team’s name. The debugger only computes this string on demand - typically via the `po` command. By applying the `DebugDescription` macro, a matching Type Summary is constructed. This allows the user to show a string like “Rams [11-2]”, without executing `debugDescription`. This improves the usability, performance, and reliability of the debugging experience.\n\nThe `DebugDescription` macro supports both `debugDescription`, `description`, as well as a third option: a property named `lldbDescription`. The first two are implemented when conforming to the `CustomDebugStringConvertible` and `CustomStringConvertible` protocols. The additional `lldbDescription` property is useful when both `debugDescription` and `description` are implemented, but don’t meet the requirements of the `DebugDescription` macro. If `lldbDescription` is implemented, `DebugDescription` choose it over `debugDescription` and `description`. Likewise, `debugDescription` is preferred over `description`.\n\n### Description Requirements\n\nThe description implementation has the following requirements:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/DebugDescription()\ncrawled: 2025-12-01T21:05:53Z\n---\n\n# DebugDescription()\n\n**Macro**\n\nConverts description definitions to a debugger Type Summary.\n\n## Declaration\n\n```swift\n@attached(member) @attached(memberAttribute) macro DebugDescription()\n```\n\n## Overview\n\nThis macro converts compatible description implementations written in Swift to an LLDB format known as a Type Summary. A Type Summary is LLDB’s equivalent to `debugDescription`, with the distinction that it does not execute code inside the debugged process. By avoiding code execution, descriptions can be produced faster, without potential side effects, and shown in situations where code execution is not performed, such as the variable list of an IDE.\n\nConsider this an example. This `Team` struct has a `debugDescription` which summarizes some key details, such as the team’s name. The debugger only computes this string on demand - typically via the `po` command. By applying the `DebugDescription` macro, a matching Type Summary is constructed. This allows the user to show a string like “Rams [11-2]”, without executing `debugDescription`. This improves the usability, performance, and reliability of the debugging experience.\n\n```swift\n@DebugDescription\nstruct Team: CustomDebugStringConvertible {\n   var name: String\n   var wins, losses: Int\n\n   var debugDescription: String {\n       \"\\(name) [\\(wins)-\\(losses)]\"\n   }\n}\n```\n\nThe `DebugDescription` macro supports both `debugDescription`, `description`, as well as a third option: a property named `lldbDescription`. The first two are implemented when conforming to the `CustomDebugStringConvertible` and `CustomStringConvertible` protocols. The additional `lldbDescription` property is useful when both `debugDescription` and `description` are implemented, but don’t meet the requirements of the `DebugDescription` macro. If `lldbDescription` is implemented, `DebugDescription` choose it over `debugDescription` and `description`. Likewise, `debugDescription` is preferred over `description`.\n\n### Description Requirements\n\nThe description implementation has the following requirements:\n\n- The body of the description implementation must a single string expression. String concatenation is not supported, use string interpolation instead.\n- String interpolation can reference stored properties only, functions calls and other arbitrary computation are not supported. Of note, conditional logic and computed properties are not supported.\n- Overloaded string interpolation cannot be used.\n\n## Customizing Your Type’s Reflection\n\n- **CustomReflectable**: A type that explicitly supplies its own mirror.\n- **CustomLeafReflectable**: A type that explicitly supplies its own mirror, but whose descendant classes are not represented in the mirror unless they also override `customMirror`.\n- **CustomPlaygroundDisplayConvertible**: A type that supplies a custom description for playground logging.\n- **PlaygroundQuickLook**: The sum of types that can be used as a Quick Look representation.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that explicitly supplies its own mirror.",
          "name" : "CustomReflectable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/CustomReflectable"
        },
        {
          "description" : "A type that explicitly supplies its own mirror, but whose descendant classes are not represented in the mirror unless they also override `customMirror`.",
          "name" : "CustomLeafReflectable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/CustomLeafReflectable"
        },
        {
          "description" : "A type that supplies a custom description for playground logging.",
          "name" : "CustomPlaygroundDisplayConvertible",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/CustomPlaygroundDisplayConvertible"
        },
        {
          "description" : "The sum of types that can be used as a Quick Look representation.",
          "name" : "PlaygroundQuickLook",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/PlaygroundQuickLook"
        }
      ],
      "title" : "Customizing Your Type’s Reflection"
    }
  ],
  "source" : "appleJSON",
  "title" : "DebugDescription()",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/DebugDescription()"
}