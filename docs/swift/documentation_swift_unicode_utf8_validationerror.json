{
  "abstract" : "The kind and location of a UTF-8 encoding error.",
  "codeExamples" : [
    {
      "code" : "╔════════════════════╦════════╦════════╦════════╦════════╗\n║    Scalar value    ║ Byte 0 ║ Byte 1 ║ Byte 2 ║ Byte 3 ║\n╠════════════════════╬════════╬════════╬════════╬════════╣\n║ U+0000..U+007F     ║ 00..7F ║        ║        ║        ║\n║ U+0080..U+07FF     ║ C2..DF ║ 80..BF ║        ║        ║\n║ U+0800..U+0FFF     ║ E0     ║ A0..BF ║ 80..BF ║        ║\n║ U+1000..U+CFFF     ║ E1..EC ║ 80..BF ║ 80..BF ║        ║\n║ U+D000..U+D7FF     ║ ED     ║ 80..9F ║ 80..BF ║        ║\n║ U+E000..U+FFFF     ║ EE..EF ║ 80..BF ║ 80..BF ║        ║\n║ U+10000..U+3FFFF   ║ F0     ║ 90..BF ║ 80..BF ║ 80..BF ║\n║ U+40000..U+FFFFF   ║ F1..F3 ║ 80..BF ║ 80..BF ║ 80..BF ║\n║ U+100000..U+10FFFF ║ F4     ║ 80..8F ║ 80..BF ║ 80..BF ║\n╚════════════════════╩════════╩════════╩════════╩════════╝",
      "language" : "swift"
    },
    {
      "code" : "╔═════════════════╦══════╦═════╦═════╦═════╦═════╦═════╦═════╦══════╗\n║                 ║  61  ║ F1  ║ 80  ║ 80  ║ E1  ║ 80  ║ C2  ║  62  ║\n╠═════════════════╬══════╬═════╬═════╬═════╬═════╬═════╬═════╬══════╣\n║ Longest range   ║ U+61 ║ err ║     ║     ║     ║     ║     ║ U+62 ║\n║ Maximal subpart ║ U+61 ║ err ║     ║     ║ err ║     ║ err ║ U+62 ║\n║ Error per byte  ║ U+61 ║ err ║ err ║ err ║ err ║ err ║ err ║ U+62 ║\n╚═════════════════╩══════╩═════╩═════╩═════╩═════╩═════╩═════╩══════╝",
      "language" : "swift"
    }
  ],
  "conformsTo" : [
    "Copyable",
    "CustomStringConvertible",
    "Equatable",
    "Error",
    "Hashable",
    "Sendable",
    "SendableMetatype"
  ],
  "contentHash" : "081f3ebd4a78252400c48db099b658bcc94ffec674a0bd355d3dea5eb613e2b7",
  "crawledAt" : "2025-12-04T16:43:37Z",
  "declaration" : {
    "code" : "@frozen struct ValidationError",
    "language" : "swift"
  },
  "id" : "91D0CA06-B02B-4C87-9EE0-11A7D5B85ED5",
  "kind" : "struct",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Overview\n\nValid UTF-8 is represented by this table:\n\n### Classifying errors\n\nAn *unexpected continuation* is when a continuation byte (`10xxxxxx`) occurs in a position that should be the start of a new scalar value. Unexpected continuations can often occur when the input contains arbitrary data instead of textual content. An unexpected continuation at the start of input might mean that the input was not correctly sliced along scalar boundaries or that it does not contain UTF-8.\n\nA *truncated scalar* is a multi-byte sequence that is the start of a valid multi-byte scalar but is cut off before ending correctly. A truncated scalar at the end of the input might mean that only part of the entire input was received.\n\nA *surrogate code point* (`U+D800..U+DFFF`) is invalid UTF-8. Surrogate code points are used by UTF-16 to encode scalars in the supplementary planes. Their presence may mean the input was encoded in a different 8-bit encoding, such as CESU-8, WTF-8, or Java’s Modified UTF-8.\n\nAn *invalid non-surrogate code point* is any code point higher than `U+10FFFF`. This can often occur when the input is arbitrary data instead of textual content.\n\nAn *overlong encoding* occurs when a scalar value that could have been encoded using fewer bytes is encoded in a longer byte sequence. Overlong encodings are invalid UTF-8 and can lead to security issues if not correctly detected:\n\nAn overlong encoding of `NUL`, `0xC0 0x80`, is used in Java’s Modified UTF-8 but is invalid UTF-8. Overlong encoding errors often catch attempts to bypass security measures.\n\n### Reporting the range of the error\n\nThe range of the error reported follows the *Maximal subpart of an ill-formed subsequence* algorithm in which each error is either one byte long or ends before the first byte that is disallowed. See “U+FFFD Substitution of Maximal Subparts” in the Unicode Standard. Unicode started recommending this algorithm in version 6 and is adopted by the W3C.\n\nThe maximal subpart algorithm will produce a single multi-byte range for a truncated scalar (a multi-byte sequence that is the start of a valid multi-byte scalar but is cut off before ending correctly). For all other errors (including overlong encodings, surrogates, and invalid code points), it will produce an error per byte.\n\nSince overlong encodings, surrogates, and invalid code points are erroneous by the second byte (at the latest), the above definition produces the same ranges as defining such a sequence as a truncated scalar error followed by unexpected continuation byte errors. The more semantically-rich classification is reported.\n\nFor example, a surrogate count point sequence `ED A0 80` will be reported as three `.surrogateCodePointByte` errors rather than a `.truncatedScalar` followed by two `.unexpectedContinuationByte` errors.\n\nOther commonly reported error ranges can be constructed from this result. For example, PEP 383’s error-per-byte can be constructed by mapping over the reported range. Similarly, constructing a single error for the longest invalid byte range can be constructed by joining adjacent error ranges.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swift\/unicode\/utf8\/validationerror\ncrawled: 2025-12-04T16:43:37Z\n---\n\n# Unicode.UTF8.ValidationError\n\n**Structure**\n\nThe kind and location of a UTF-8 encoding error.\n\n## Declaration\n\n```swift\n@frozen struct ValidationError\n```\n\n## Overview\n\nValid UTF-8 is represented by this table:\n\n```swift\n╔════════════════════╦════════╦════════╦════════╦════════╗\n║    Scalar value    ║ Byte 0 ║ Byte 1 ║ Byte 2 ║ Byte 3 ║\n╠════════════════════╬════════╬════════╬════════╬════════╣\n║ U+0000..U+007F     ║ 00..7F ║        ║        ║        ║\n║ U+0080..U+07FF     ║ C2..DF ║ 80..BF ║        ║        ║\n║ U+0800..U+0FFF     ║ E0     ║ A0..BF ║ 80..BF ║        ║\n║ U+1000..U+CFFF     ║ E1..EC ║ 80..BF ║ 80..BF ║        ║\n║ U+D000..U+D7FF     ║ ED     ║ 80..9F ║ 80..BF ║        ║\n║ U+E000..U+FFFF     ║ EE..EF ║ 80..BF ║ 80..BF ║        ║\n║ U+10000..U+3FFFF   ║ F0     ║ 90..BF ║ 80..BF ║ 80..BF ║\n║ U+40000..U+FFFFF   ║ F1..F3 ║ 80..BF ║ 80..BF ║ 80..BF ║\n║ U+100000..U+10FFFF ║ F4     ║ 80..8F ║ 80..BF ║ 80..BF ║\n╚════════════════════╩════════╩════════╩════════╩════════╝\n```\n\n### Classifying errors\n\nAn *unexpected continuation* is when a continuation byte (`10xxxxxx`) occurs in a position that should be the start of a new scalar value. Unexpected continuations can often occur when the input contains arbitrary data instead of textual content. An unexpected continuation at the start of input might mean that the input was not correctly sliced along scalar boundaries or that it does not contain UTF-8.\n\nA *truncated scalar* is a multi-byte sequence that is the start of a valid multi-byte scalar but is cut off before ending correctly. A truncated scalar at the end of the input might mean that only part of the entire input was received.\n\nA *surrogate code point* (`U+D800..U+DFFF`) is invalid UTF-8. Surrogate code points are used by UTF-16 to encode scalars in the supplementary planes. Their presence may mean the input was encoded in a different 8-bit encoding, such as CESU-8, WTF-8, or Java’s Modified UTF-8.\n\nAn *invalid non-surrogate code point* is any code point higher than `U+10FFFF`. This can often occur when the input is arbitrary data instead of textual content.\n\nAn *overlong encoding* occurs when a scalar value that could have been encoded using fewer bytes is encoded in a longer byte sequence. Overlong encodings are invalid UTF-8 and can lead to security issues if not correctly detected:\n\n- https:\/\/nvd.nist.gov\/vuln\/detail\/CVE-2008-2938\n- https:\/\/nvd.nist.gov\/vuln\/detail\/CVE-2000-0884\n\nAn overlong encoding of `NUL`, `0xC0 0x80`, is used in Java’s Modified UTF-8 but is invalid UTF-8. Overlong encoding errors often catch attempts to bypass security measures.\n\n### Reporting the range of the error\n\nThe range of the error reported follows the *Maximal subpart of an ill-formed subsequence* algorithm in which each error is either one byte long or ends before the first byte that is disallowed. See “U+FFFD Substitution of Maximal Subparts” in the Unicode Standard. Unicode started recommending this algorithm in version 6 and is adopted by the W3C.\n\nThe maximal subpart algorithm will produce a single multi-byte range for a truncated scalar (a multi-byte sequence that is the start of a valid multi-byte scalar but is cut off before ending correctly). For all other errors (including overlong encodings, surrogates, and invalid code points), it will produce an error per byte.\n\nSince overlong encodings, surrogates, and invalid code points are erroneous by the second byte (at the latest), the above definition produces the same ranges as defining such a sequence as a truncated scalar error followed by unexpected continuation byte errors. The more semantically-rich classification is reported.\n\nFor example, a surrogate count point sequence `ED A0 80` will be reported as three `.surrogateCodePointByte` errors rather than a `.truncatedScalar` followed by two `.unexpectedContinuationByte` errors.\n\nOther commonly reported error ranges can be constructed from this result. For example, PEP 383’s error-per-byte can be constructed by mapping over the reported range. Similarly, constructing a single error for the longest invalid byte range can be constructed by joining adjacent error ranges.\n\n```swift\n╔═════════════════╦══════╦═════╦═════╦═════╦═════╦═════╦═════╦══════╗\n║                 ║  61  ║ F1  ║ 80  ║ 80  ║ E1  ║ 80  ║ C2  ║  62  ║\n╠═════════════════╬══════╬═════╬═════╬═════╬═════╬═════╬═════╬══════╣\n║ Longest range   ║ U+61 ║ err ║     ║     ║     ║     ║     ║ U+62 ║\n║ Maximal subpart ║ U+61 ║ err ║     ║     ║ err ║     ║ err ║ U+62 ║\n║ Error per byte  ║ U+61 ║ err ║ err ║ err ║ err ║ err ║ err ║ U+62 ║\n╚═════════════════╩══════╩═════╩═════╩═════╩═════╩═════╩═════╩══════╝\n```\n\n## Structures\n\n- **Unicode.UTF8.ValidationError.Kind**: The kind of encoding error encountered during validation\n\n## Operators\n\n- **==(_:_:)**: Returns a Boolean value indicating whether two values are equal.\n\n## Initializers\n\n- **init(_:_:)**\n- **init(_:at:)**\n\n## Instance Properties\n\n- **byteOffsets**: The range of offsets into our input containing the error\n- **hashValue**: The hash value.\n- **kind**: The kind of encoding error\n\n## Instance Methods\n\n- **hash(into:)**: Hashes the essential components of this value by feeding them into the given hasher.\n\n## Default Implementations\n\n- **CustomStringConvertible Implementations**\n- **Equatable Implementations**\n\n## Conforms To\n\n- Copyable\n- CustomStringConvertible\n- Equatable\n- Error\n- Hashable\n- Sendable\n- SendableMetatype\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The kind of encoding error encountered during validation",
          "name" : "Unicode.UTF8.ValidationError.Kind",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/Kind-swift.struct"
        }
      ],
      "title" : "Structures"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a Boolean value indicating whether two values are equal.",
          "name" : "==(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/==(_:_:)"
        }
      ],
      "title" : "Operators"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "init(_:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/init(_:_:)"
        },
        {
          "description" : "",
          "name" : "init(_:at:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/init(_:at:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The range of offsets into our input containing the error",
          "name" : "byteOffsets",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/byteOffsets"
        },
        {
          "description" : "The hash value.",
          "name" : "hashValue",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/hashValue"
        },
        {
          "description" : "The kind of encoding error",
          "name" : "kind",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/kind-swift.property"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Hashes the essential components of this value by feeding them into the given hasher.",
          "name" : "hash(into:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/hash(into:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "CustomStringConvertible Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/CustomStringConvertible-Implementations"
        },
        {
          "description" : "",
          "name" : "Equatable Implementations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Unicode\/UTF8\/ValidationError\/Equatable-Implementations"
        }
      ],
      "title" : "Default Implementations"
    }
  ],
  "source" : "appleJSON",
  "title" : "Unicode.UTF8.ValidationError",
  "url" : "https:\/\/developer.apple.com\/documentation\/swift\/unicode\/utf8\/validationerror"
}