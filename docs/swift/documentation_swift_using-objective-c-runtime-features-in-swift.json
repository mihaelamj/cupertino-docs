{
  "abstract" : "Use selectors and key paths to interact with dynamic Objective-C APIs.",
  "codeExamples" : [
    {
      "code" : "import UIKit\nclass MyViewController: UIViewController {\n    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))\n\n    override init(nibName nibNameOrNil: NSNib.Name?, bundle nibBundleOrNil: Bundle?) {\n        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n        let action = #selector(MyViewController.tappedButton)\n        myButton.addTarget(self, action: action, forControlEvents: .touchUpInside)\n    }\n\n    @objc func tappedButton(_ sender: UIButton?) {\n        print(\"tapped button\")\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class Person: NSObject {\n    @objc var name: String\n    @objc var friends: [Person] = []\n    @objc var bestFriend: Person? = nil\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\nlet gabrielle = Person(name: \"Gabrielle\")\nlet jim = Person(name: \"Jim\")\nlet yuanyuan = Person(name: \"Yuanyuan\")\ngabrielle.friends = [jim, yuanyuan]\ngabrielle.bestFriend = yuanyuan\n\n#keyPath(Person.name)\n\/\/ \"name\"\ngabrielle.value(forKey: #keyPath(Person.name))\n\/\/ \"Gabrielle\"\n#keyPath(Person.bestFriend.name)\n\/\/ \"bestFriend.name\"\ngabrielle.value(forKeyPath: #keyPath(Person.bestFriend.name))\n\/\/ \"Yuanyuan\"\n#keyPath(Person.friends.name)\n\/\/ \"friends.name\"\ngabrielle.value(forKeyPath: #keyPath(Person.friends.name))\n\/\/ [\"Yuanyuan\", \"Jim\"]",
      "language" : "swift"
    }
  ],
  "contentHash" : "6f3fdc1701f4a0c95b8dbda6143a5093f210401b47db6ea093c6da717e7c08cc",
  "crawledAt" : "2025-12-01T09:23:57Z",
  "id" : "9513B769-1D57-4C60-991C-677F66DEFC93",
  "kind" : "article",
  "module" : "Swift",
  "overview" : "## Overview\n\nSome Objective-C APIs—like target-action—accept method or property names as parameters, then use those names to dynamically call or access the methods or properties. In Swift, you use the `#selector` and `#keyPath` expressions to represent those method or property names as selectors or key paths, respectively.\n\n### Use Selectors to Arrange Calls to Objective-C Methods\n\nIn Objective-C, a selector is a type that refers to the name of an Objective-C method. In Swift, Objective-C selectors are represented by the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/Selector] structure, and you create them using the `#selector` expression.\n\nIn Swift, you create a selector for an Objective-C method by placing the name of the method within the `#selector` expression: `#selector(MyViewController.tappedButton(_:))`. To construct a selector for a property’s Objective-C getter or setter method, prefix the property name using the `getter:` or `setter:` label, like `#selector(getter: MyViewController.myButton)`. The example below shows a selector being used as part of the target-action pattern to call a method in response to the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIControl\/Event\/touchUpInside] event.\n\nIf you need to disambiguate between overloaded functions, use parenthesized expressions along with the `as` operator to make the `#selector` expression refer unambiguously to a specific overload.\n\n### Use Key Paths to Dynamically Access Objective-C Properties\n\nIn Objective-C, a key is a string that identifies a specific property of an object. A key path is a string of dot-separated keys that specifies a sequence of object properties to traverse. Keys and key paths are frequently used for key-value coding (KVC), a mechanism for indirectly accessing an object’s attributes and relationships using string identifiers.\n\nYou use the `#keyPath` string expression to create compiler-checked keys and key paths that can be used by KVC methods like [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/value(forKey:)] and [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/value(forKeyPath:)]. The `#keyPath` string expression accepts chained method or property references. It also supports chaining through optional values within a chain, such as `#keyPath(Person.bestFriend.name)`. Key paths created using the `#keyPath` string expression don’t pass type information about the properties or methods they reference to the APIs that accept key paths.\n\nThe example below defines a `Person` class, creates two instances of it, and uses several `#keyPath` string expressions to access properties and properties of those properties:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/using-objective-c-runtime-features-in-swift\ncrawled: 2025-12-01T09:23:57Z\n---\n\n# Using Objective-C Runtime Features in Swift\n\n**Article**\n\nUse selectors and key paths to interact with dynamic Objective-C APIs.\n\n## Overview\n\nSome Objective-C APIs—like target-action—accept method or property names as parameters, then use those names to dynamically call or access the methods or properties. In Swift, you use the `#selector` and `#keyPath` expressions to represent those method or property names as selectors or key paths, respectively.\n\n### Use Selectors to Arrange Calls to Objective-C Methods\n\nIn Objective-C, a selector is a type that refers to the name of an Objective-C method. In Swift, Objective-C selectors are represented by the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/Selector] structure, and you create them using the `#selector` expression.\n\nIn Swift, you create a selector for an Objective-C method by placing the name of the method within the `#selector` expression: `#selector(MyViewController.tappedButton(_:))`. To construct a selector for a property’s Objective-C getter or setter method, prefix the property name using the `getter:` or `setter:` label, like `#selector(getter: MyViewController.myButton)`. The example below shows a selector being used as part of the target-action pattern to call a method in response to the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIControl\/Event\/touchUpInside] event.\n\n```swift\nimport UIKit\nclass MyViewController: UIViewController {\n    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))\n\n    override init(nibName nibNameOrNil: NSNib.Name?, bundle nibBundleOrNil: Bundle?) {\n        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n        let action = #selector(MyViewController.tappedButton)\n        myButton.addTarget(self, action: action, forControlEvents: .touchUpInside)\n    }\n\n    @objc func tappedButton(_ sender: UIButton?) {\n        print(\"tapped button\")\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n    }\n}\n```\n\nIf you need to disambiguate between overloaded functions, use parenthesized expressions along with the `as` operator to make the `#selector` expression refer unambiguously to a specific overload.\n\n### Use Key Paths to Dynamically Access Objective-C Properties\n\nIn Objective-C, a key is a string that identifies a specific property of an object. A key path is a string of dot-separated keys that specifies a sequence of object properties to traverse. Keys and key paths are frequently used for key-value coding (KVC), a mechanism for indirectly accessing an object’s attributes and relationships using string identifiers.\n\n\n\nYou use the `#keyPath` string expression to create compiler-checked keys and key paths that can be used by KVC methods like [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/value(forKey:)] and [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/value(forKeyPath:)]. The `#keyPath` string expression accepts chained method or property references. It also supports chaining through optional values within a chain, such as `#keyPath(Person.bestFriend.name)`. Key paths created using the `#keyPath` string expression don’t pass type information about the properties or methods they reference to the APIs that accept key paths.\n\nThe example below defines a `Person` class, creates two instances of it, and uses several `#keyPath` string expressions to access properties and properties of those properties:\n\n```swift\nclass Person: NSObject {\n    @objc var name: String\n    @objc var friends: [Person] = []\n    @objc var bestFriend: Person? = nil\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\nlet gabrielle = Person(name: \"Gabrielle\")\nlet jim = Person(name: \"Jim\")\nlet yuanyuan = Person(name: \"Yuanyuan\")\ngabrielle.friends = [jim, yuanyuan]\ngabrielle.bestFriend = yuanyuan\n\n#keyPath(Person.name)\n\/\/ \"name\"\ngabrielle.value(forKey: #keyPath(Person.name))\n\/\/ \"Gabrielle\"\n#keyPath(Person.bestFriend.name)\n\/\/ \"bestFriend.name\"\ngabrielle.value(forKeyPath: #keyPath(Person.bestFriend.name))\n\/\/ \"Yuanyuan\"\n#keyPath(Person.friends.name)\n\/\/ \"friends.name\"\ngabrielle.value(forKeyPath: #keyPath(Person.friends.name))\n\/\/ [\"Yuanyuan\", \"Jim\"]\n```\n\n## Language Interoperability with Objective-C and C\n\n- **Objective-C and C Code Customization**: Apply macros to your Objective-C APIs to customize how they’re imported into Swift.\n- **Migrating Your Objective-C Code to Swift**: Learn the recommended steps to migrate your code.\n- **Cocoa Design Patterns**: Adopt and interoperate with Cocoa design patterns in your Swift apps.\n- **Handling Dynamically Typed Methods and Objects in Swift**: Cast instances of the Objective-C `id` type to a specific Swift type.\n- **Imported C and Objective-C APIs**: Use native Swift syntax to interoperate with types and functions in C and Objective-C.\n- **Calling Objective-C APIs Asynchronously**: Learn how functions and methods that take a completion handler are converted to Swift asynchronous functions.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Apply macros to your Objective-C APIs to customize how they’re imported into Swift.",
          "name" : "Objective-C and C Code Customization",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/objective-c-and-c-code-customization"
        },
        {
          "description" : "Learn the recommended steps to migrate your code.",
          "name" : "Migrating Your Objective-C Code to Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/migrating-your-objective-c-code-to-swift"
        },
        {
          "description" : "Adopt and interoperate with Cocoa design patterns in your Swift apps.",
          "name" : "Cocoa Design Patterns",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/cocoa-design-patterns"
        },
        {
          "description" : "Cast instances of the Objective-C `id` type to a specific Swift type.",
          "name" : "Handling Dynamically Typed Methods and Objects in Swift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/handling-dynamically-typed-methods-and-objects-in-swift"
        },
        {
          "description" : "Use native Swift syntax to interoperate with types and functions in C and Objective-C.",
          "name" : "Imported C and Objective-C APIs",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/imported-c-and-objective-c-apis"
        },
        {
          "description" : "Learn how functions and methods that take a completion handler are converted to Swift asynchronous functions.",
          "name" : "Calling Objective-C APIs Asynchronously",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/calling-objective-c-apis-asynchronously"
        }
      ],
      "title" : "Language Interoperability with Objective-C and C"
    }
  ],
  "source" : "appleJSON",
  "title" : "Using Objective-C Runtime Features in Swift",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/using-objective-c-runtime-features-in-swift"
}