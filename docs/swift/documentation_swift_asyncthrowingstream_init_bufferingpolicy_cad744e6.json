{
  "abstract" : "Constructs an asynchronous stream for an element type, using the specified buffering policy and element-producing closure.",
  "codeExamples" : [
    {
      "code" : "let stream = AsyncThrowingStream<Int, Error>(Int.self,\n                                             bufferingPolicy: .bufferingNewest(5)) { continuation in\n    Task.detached {\n        for _ in 0..<100 {\n            await Task.sleep(1 * 1_000_000_000)\n            let random = Int.random(in: 1...10)\n            if random % 5 == 0 {\n                continuation.finish(throwing: MyRandomNumberError())\n                return\n            } else {\n                continuation.yield(random)\n            }\n        }\n        continuation.finish()\n    }\n}\n\n\/\/ Call point:\ndo {\n    for try await random in stream {\n        print(random)\n    }\n} catch {\n    print(error)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "1a7be058987ba7c49e39ff5815ddbf7a25a85010701867e20b7a921c8a3c607c",
  "crawledAt" : "2025-12-04T12:38:14Z",
  "declaration" : {
    "code" : "init(_ elementType: Element.Type = Element.self, bufferingPolicy limit: AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded, _ build: (AsyncThrowingStream<Element, Failure>.Continuation) -> Void) where Failure == any Error",
    "language" : "swift"
  },
  "id" : "B5AB6FC8-168D-410D-A794-0405C78A1904",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Discussion\n\nThe `AsyncStream.Continuation` received by the `build` closure is appropriate for use in concurrent contexts. It is thread safe to send and finish; all calls are to the continuation are serialized. However, calling this from multiple concurrent contexts could result in out-of-order delivery.\n\nThe following example shows an `AsyncStream` created with this initializer that produces 100 random numbers on a one-second interval, calling `yield(_:)` to deliver each element to the awaiting call point. When the `for` loop exits, the stream finishes by calling the continuation’s `finish()` method. If the random number is divisible by 5 with no remainder, the stream throws a `MyRandomNumberError`.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/AsyncThrowingStream\/init(_:bufferingPolicy:_:)\ncrawled: 2025-12-04T12:38:14Z\n---\n\n# init(_:bufferingPolicy:_:)\n\n**Initializer**\n\nConstructs an asynchronous stream for an element type, using the specified buffering policy and element-producing closure.\n\n## Declaration\n\n```swift\ninit(_ elementType: Element.Type = Element.self, bufferingPolicy limit: AsyncThrowingStream<Element, Failure>.Continuation.BufferingPolicy = .unbounded, _ build: (AsyncThrowingStream<Element, Failure>.Continuation) -> Void) where Failure == any Error\n```\n\n## Parameters\n\n- **elementType**: The type of element the `AsyncThrowingStream` produces.\n- **limit**: The maximum number of elements to hold in the buffer. By default, this value is unlimited. Use a `Continuation.BufferingPolicy` to buffer a specified number of oldest or newest elements.\n- **build**: A custom closure that yields values to the `AsyncThrowingStream`. This closure receives an `AsyncThrowingStream.Continuation` instance that it uses to provide elements to the stream and terminate the stream when finished.\n\n## Discussion\n\nThe `AsyncStream.Continuation` received by the `build` closure is appropriate for use in concurrent contexts. It is thread safe to send and finish; all calls are to the continuation are serialized. However, calling this from multiple concurrent contexts could result in out-of-order delivery.\n\nThe following example shows an `AsyncStream` created with this initializer that produces 100 random numbers on a one-second interval, calling `yield(_:)` to deliver each element to the awaiting call point. When the `for` loop exits, the stream finishes by calling the continuation’s `finish()` method. If the random number is divisible by 5 with no remainder, the stream throws a `MyRandomNumberError`.\n\n```swift\nlet stream = AsyncThrowingStream<Int, Error>(Int.self,\n                                             bufferingPolicy: .bufferingNewest(5)) { continuation in\n    Task.detached {\n        for _ in 0..<100 {\n            await Task.sleep(1 * 1_000_000_000)\n            let random = Int.random(in: 1...10)\n            if random % 5 == 0 {\n                continuation.finish(throwing: MyRandomNumberError())\n                return\n            } else {\n                continuation.yield(random)\n            }\n        }\n        continuation.finish()\n    }\n}\n\n\/\/ Call point:\ndo {\n    for try await random in stream {\n        print(random)\n    }\n} catch {\n    print(error)\n}\n```\n\n## Creating a Continuation-Based Stream\n\n- **AsyncThrowingStream.Continuation.BufferingPolicy**: A strategy that handles exhaustion of a buffer’s capacity.\n- **AsyncThrowingStream.Continuation**: A mechanism to interface between synchronous code and an asynchronous stream.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A strategy that handles exhaustion of a buffer’s capacity.",
          "name" : "AsyncThrowingStream.Continuation.BufferingPolicy",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/AsyncThrowingStream\/Continuation\/BufferingPolicy"
        },
        {
          "description" : "A mechanism to interface between synchronous code and an asynchronous stream.",
          "name" : "AsyncThrowingStream.Continuation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/AsyncThrowingStream\/Continuation"
        }
      ],
      "title" : "Creating a Continuation-Based Stream"
    }
  ],
  "source" : "appleJSON",
  "title" : "init(_:bufferingPolicy:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/AsyncThrowingStream\/init(_:bufferingPolicy:_:)"
}