{
  "abstract" : "The total number of elements that the array can contain without allocating new storage.",
  "codeExamples" : [
    {
      "code" : "var numbers = [10, 20, 30, 40, 50]\n\/\/ numbers.count == 5\n\/\/ numbers.capacity == 5\n\nnumbers.append(contentsOf: stride(from: 60, through: 100, by: 10))\n\/\/ numbers.count == 10\n\/\/ numbers.capacity == 10",
      "language" : "swift"
    }
  ],
  "contentHash" : "0b5ac9a49ae67ce2d7a3cb2802df6d04bf89e4e9b65eb3b96caef3d4e4d8af3b",
  "crawledAt" : "2025-12-02T20:31:48Z",
  "declaration" : {
    "code" : "var capacity: Int { get }",
    "language" : "swift"
  },
  "id" : "DEDD656F-A2E0-4331-ABDA-E4FFEBEA6F24",
  "kind" : "property",
  "language" : "swift",
  "module" : "Swift",
  "overview" : "## Discussion\n\nEvery array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage’s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.\n\nThe following example creates an array of integers from an array literal, then appends the elements of another collection. Before appending, the array allocates new storage that is large enough store the resulting elements.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Swift\/Array\/capacity\ncrawled: 2025-12-02T20:31:48Z\n---\n\n# capacity\n\n**Instance Property**\n\nThe total number of elements that the array can contain without allocating new storage.\n\n## Declaration\n\n```swift\nvar capacity: Int { get }\n```\n\n## Discussion\n\nEvery array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage’s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.\n\nThe following example creates an array of integers from an array literal, then appends the elements of another collection. Before appending, the array allocates new storage that is large enough store the resulting elements.\n\n```swift\nvar numbers = [10, 20, 30, 40, 50]\n\/\/ numbers.count == 5\n\/\/ numbers.capacity == 5\n\nnumbers.append(contentsOf: stride(from: 60, through: 100, by: 10))\n\/\/ numbers.count == 10\n\/\/ numbers.capacity == 10\n```\n\n## Inspecting an Array\n\n- **isEmpty**: A Boolean value indicating whether the collection is empty.\n- **count**: The number of elements in the array.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A Boolean value indicating whether the collection is empty.",
          "name" : "isEmpty",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/isEmpty"
        },
        {
          "description" : "The number of elements in the array.",
          "name" : "count",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/count"
        }
      ],
      "title" : "Inspecting an Array"
    }
  ],
  "source" : "appleJSON",
  "title" : "capacity",
  "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Array\/capacity"
}