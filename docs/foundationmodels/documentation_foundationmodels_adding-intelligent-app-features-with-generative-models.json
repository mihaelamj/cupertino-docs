{
  "abstract" : "Build robust apps with guided generation and tool calling by adopting the Foundation Models framework.",
  "codeExamples" : [
    {
      "code" : "let landmark: Landmark\nprivate let model = SystemLanguageModel.default\n\nvar body: some View {\n    switch model.availability {\n    case .available:\n        LandmarkTripView(landmark: landmark)\n    case .unavailable(.appleIntelligenceNotEnabled):\n        MessageView(\n            landmark: self.landmark,\n            message: \"\"\"\n                     Trip Planner is unavailable because \\\n                     Apple Intelligence hasn't been turned on.\n                     \"\"\"\n        )\n    case .unavailable(.modelNotReady):\n        MessageView(\n            landmark: self.landmark,\n            message: \"Trip Planner isn't ready yet. Try again later.\"\n        )\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Generable\nstruct Itinerary: Equatable {\n    @Guide(description: \"An exciting name for the trip.\")\n    let title: String\n    @Guide(.anyOf(ModelData.landmarkNames))\n    let destinationName: String\n    let description: String\n    @Guide(description: \"An explanation of how the itinerary meets the person's special requests.\")\n    let rationale: String\n\n    @Guide(description: \"A list of day-by-day plans.\")\n    @Guide(.count(3))\n    let days: [DayPlan]\n}\n\n@Generable\nstruct DayPlan: Equatable {\n    @Guide(description: \"A unique and exciting title for this day plan.\")\n    let title: String\n    let subtitle: String\n    let destination: String\n\n    @Guide(.count(3))\n    let activities: [Activity]\n}\n\n@Generable\nstruct Activity: Equatable {\n    let type: Kind\n    let title: String\n    let description: String\n}\n\n@Generable\nenum Kind {\n    case sightseeing\n    case foodAndDining\n    case shopping\n    case hotelAndLodging\n}",
      "language" : "swift"
    },
    {
      "code" : "init(landmark: Landmark) {\n    self.landmark = landmark\n    Logging.general.log(\"The landmark is... \\(landmark.name)\")\n    let pointOfInterestTool = FindPointsOfInterestTool(landmark: landmark)\n    self.session = LanguageModelSession(\n        tools: [pointOfInterestTool],\n        instructions: Instructions {\n            \"Your job is to create an itinerary for the person.\"\n            \n            \"Each day needs an activity, hotel and restaurant.\"\n            \n            \"\"\"\n            Always use the findPointsOfInterest tool to find businesses \\\n            and activities in \\(landmark.name), especially hotels \\\n            and restaurants.\n            \n            The point of interest categories may include:\n            \"\"\"\n            FindPointsOfInterestTool.categories\n            \n            \"\"\"\n            Here is a description of \\(landmark.name) for your reference \\\n            when considering what activities to generate:\n            \"\"\"\n            landmark.description\n        }\n    )\n    self.pointOfInterestTool = pointOfInterestTool\n}",
      "language" : "swift"
    },
    {
      "code" : "@Observable\nfinal class FindPointsOfInterestTool: Tool {\n    let name = \"findPointsOfInterest\"\n    let description = \"Finds points of interest for a landmark.\"\n    \n    let landmark: Landmark\n    \n    @MainActor var lookupHistory: [Lookup] = []\n    \n    init(landmark: Landmark) {\n        self.landmark = landmark\n    }\n\n@Generable\nenum Category: String, CaseIterable {\n    case campground\n    case hotel\n    case cafe\n    case museum\n    case marina\n    case restaurant\n    case nationalMonument\n}\n\n@Generable\nstruct Arguments {\n    @Guide(description: \"This is the type of destination to look up for.\")\n    let pointOfInterest: Category\n\n    @Guide(description: \"The natural language query of what to search for.\")\n    let naturalLanguageQuery: String\n}",
      "language" : "swift"
    },
    {
      "code" : "private(set) var itinerary: Itinerary.PartiallyGenerated?\n\nfunc suggestItinerary(dayCount: Int) async throws {\n    let stream = session.streamResponse(\n        generating: Itinerary.self,\n        includeSchemaInPrompt: false,\n        options: GenerationOptions(sampling: .greedy)\n    ) {\n        \"Generate a \\(dayCount)-day itinerary to \\(landmark.name).\"\n\n        \"Give it a fun title and description.\"\n\n        \"Here is an example, but don't copy it:\"\n        Itinerary.exampleTripToJapan\n    }\n\n    for try await partialResponse in stream {\n        itinerary = partialResponse.content\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "ForEach(planner.pointOfInterestTool.lookupHistory) { element in\n    HStack {\n        Image(systemName: \"location.magnifyingglass\")\n        Text(\"Searching **\\(element.history.pointOfInterest.rawValue)** in \\(landmark.name)...\")\n    }\n    .transition(.blurReplace)\n}",
      "language" : "swift"
    },
    {
      "code" : "let contentTaggingModel = SystemLanguageModel(useCase: .contentTagging)\n\n.task {\n    if !contentTaggingModel.isAvailable { return }\n    do {\n        let session = LanguageModelSession(model: contentTaggingModel)\n        let stream = session.streamResponse(\n            to: landmark.description,\n            generating: TaggingResponse.self,\n            options: GenerationOptions(sampling: .greedy)\n        )\n        for try await newTags in stream {\n            generatedTags = newTags.content\n        }\n    } catch {\n        Logging.general.error(\"\\(error.localizedDescription)\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Observable @MainActor\nfinal class LocationLookup {\n    private(set) var item: MKMapItem?\n    private(set) var temperatureString: String?\n\n    func performLookup(location: String) {\n        Task {\n            let item = await self.mapItem(atLocation: location)\n            if let location = item?.location {\n                self.temperatureString = await self.weather(atLocation: location)\n            }\n        }\n    }\n    \n    private func mapItem(atLocation location: String) async -> MKMapItem? {\n        let request = MKLocalSearch.Request()\n        request.naturalLanguageQuery = location\n        \n        let search = MKLocalSearch(request: request)\n        do {\n            return try await search.start().mapItems.first\n        } catch {\n            Logging.general.error(\"Failed to look up location: \\(location). Error: \\(error)\")\n        }\n        return nil\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "79b5a553a45035b562c8692bff1237117a3d10c0a5f508a1cf55f1a60da25f1d",
  "crawledAt" : "2025-12-02T15:45:17Z",
  "id" : "F9F1296E-E595-4110-BEC3-CE2CF7D411FA",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Foundation Models",
  "overview" : "## Overview\n\nThis sample project shows how to integrate generative AI capabilities into an app using the Foundation Models framework. The sample app showcases intelligent trip planning features that help people discover landmarks and generate personalized itineraries.\n\nThe app creates an interactive experience where people can:\n\n## Configure the sample code project\n\nTo run this sample, you’ll need to:\n\n## Check model availability\n\nBefore using the on-device model in the app, check that the model is available by creating an instance of [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/SystemLanguageModel] with the [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/SystemLanguageModel\/default] property:\n\nThe app handles two unavailability scenarios: Apple Intelligence isn’t enabled or the model isn’t ready for usage. If Apple Intelligence is off, the app tells the person they need to turn it on and if the model isn’t ready, it tells the person the Trip Planner isn’t ready and to try the app again later.\n\n## Define structured data for generation\n\nThe app starts by defining data structures with specific constraints to control what the model generates. The `Itinerary` type uses the [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Generable] macro to create structured content that includes travel plans with activities, hotels, and restaurants.\n\nThe `@Generable` macro automatically converts Swift types into schemas that the model uses for constrained sampling, so you can specify guides to control the values you associate with it. For example, the app uses [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Guide(description:)] to make sure the model creates an exciting name for the trip. It also uses [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationGuide\/anyOf(_:)] and [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationGuide\/count(_:)] to choose any destination from our `ModelData` and show exactly 3 `DayPlan` objects per destination, respectively.\n\nThe `@Generable` macro automatically creates two versions of each type: the complete structure and a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Generable\/PartiallyGenerated] version which is a mirror of the outer structure except every property is optional. The app uses this `PartiallyGenerated` version when streaming and displaying the itinerary generation.\n\n## Configure the model session\n\nAfter checking that the model is available, the app configures a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession] object with custom tools and detailed instructions in `ItineraryPlanner`. Given a location, the initializer creates the session with structured guidance for generating personalized trip recommendations.\n\nIn a generated itinerary, the model instructions ensure that each day contains an activity, hotel, and restaurant. To get the location-specific businesses and activities, the sample uses a custom tool, called `FindPointsOfInterestTool`, with the chosen landmark. The instructions also call the landmark description property as added context when generating the activities.\n\n## Create a custom tool\n\nYou can use custom tools to extend the functionality of a model. Tool-calling allows the model to interact with external code you create to fetch up-to-date information, ground responses in sources of truth that you provide, and perform side effects.\n\nThe model in this app uses the `FindPointsOfInterestTool` tool to enable dynamic discovery of specific businesses and activities for the chosen landmark. The tool uses the `@Generable` macro to make its categories and arguments available to the model.\n\nWhen you prompt the model with a question or make a request, the model decides whether it can provide an answer or if it needs the help of a tool. The app explicitly instructs the model to always use the `findPointsOfInterestTool` in the `ItineraryPlanner` instructions. This allows the model to automatically call the tool to find relevant hotels, restaurants, and activities for the destinations.\n\n## Stream and display partial responses in real time\n\nThe app shows real-time content generation by streaming partial responses from the model. The `ItineraryPlanner` uses [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession\/streamResponse(generating:includeSchemaInPrompt:options:prompt:)] to generate `Itinerary.PartiallyGenerated` objects so itinerary items are shown incrementally to the person.\n\nYou can opt for specific [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationOptions] to adjust the way the model generates these responses. For generating the itinerary, the app opts for a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationOptions\/SamplingMode\/greedy] sampling mode so the model always results in the same output for a given input. This ensures the prompt generates consistent recommendations for an itinerary specific to the given landmark.\n\nThe app presents the responses in a SwiftUI view. The `ItineraryPlanningView` displays real-time visual feedback as the model searches for points of interest, showing people what’s happening when generating content:\n\nThe app displays messages like “Searching **hotel** in Yosemite…” and “Searching **restaurant** in Yosemite…” to let people know which point of interest category the model provided as input to the tool when actively searching for nearby points of interest. In the background, however, the tool executes and provides updates to the view. The view shows a blurred overlay while generating each day plan, then reveals the full itinerary after the search completes.\n\n## Tag content dynamically\n\nThe app uses content tagging on the provided landmarks to help people quickly understand the characteristics of each destination. A content tagging model produces a list of categorizing tags based on the input text you provide. When you prompt the content tagging model, it produces a tag that uses one to a few lowercase words. The `LandmarkDescriptionView` prompts the content tagging model to automatically generate relevant hashtags for landmark descriptions, like `#nature`, `#hiking`, or `#scenic`, based on each landmark’s description. For more information on initializing content tagging, see [doc:\/\/com.apple.documentation\/documentation\/FoundationModels\/categorizing-and-organizing-data-with-content-tags].\n\n## Integrate with other framework features\n\nYou can combine these generative model features with other Apple frameworks. For example, the `LocationLookup` class uses [doc:\/\/com.apple.documentation\/documentation\/MapKit] to search for addresses for our points of interest, showing how to combine model-generated content with weather information and location data for complete travel planning.\n\nThe model generates location names as text, and the `LocationLookup` class converts them into real, mappable locations using the natural language search capabilities in MapKit.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/FoundationModels\/adding-intelligent-app-features-with-generative-models\ncrawled: 2025-12-02T15:45:17Z\n---\n\n# Adding intelligent app features with generative models\n\n**Sample Code**\n\nBuild robust apps with guided generation and tool calling by adopting the Foundation Models framework.\n\n## Overview\n\nThis sample project shows how to integrate generative AI capabilities into an app using the Foundation Models framework. The sample app showcases intelligent trip planning features that help people discover landmarks and generate personalized itineraries.\n\nThe app creates an interactive experience where people can:\n\n- Browse curated landmarks with rich visual content\n- Generate trip itineraries tailored to a chosen landmark\n- Discover points of interest using a custom tool\n- Experience real-time content generation with streaming responses\n\n\n\n## Configure the sample code project\n\nTo run this sample, you’ll need to:\n\n1. Set the developer team in Xcode for the app target so it automatically manages the provisioning profile. For more information, see [https:\/\/developer.apple.com\/documentation\/xcode\/preparing-your-app-for-distribution#Set-the-bundle-ID] and [https:\/\/developer.apple.com\/documentation\/xcode\/preparing-your-app-for-distribution#Assign-the-project-to-a-team].\n2. In the Developer portal, enable the WeatherKit app service for your bundle ID so the app can access location-based weather information.\n\n## Check model availability\n\nBefore using the on-device model in the app, check that the model is available by creating an instance of [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/SystemLanguageModel] with the [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/SystemLanguageModel\/default] property:\n\n```swift\nlet landmark: Landmark\nprivate let model = SystemLanguageModel.default\n\nvar body: some View {\n    switch model.availability {\n    case .available:\n        LandmarkTripView(landmark: landmark)\n    case .unavailable(.appleIntelligenceNotEnabled):\n        MessageView(\n            landmark: self.landmark,\n            message: \"\"\"\n                     Trip Planner is unavailable because \\\n                     Apple Intelligence hasn't been turned on.\n                     \"\"\"\n        )\n    case .unavailable(.modelNotReady):\n        MessageView(\n            landmark: self.landmark,\n            message: \"Trip Planner isn't ready yet. Try again later.\"\n        )\n    }\n}\n```\n\nThe app handles two unavailability scenarios: Apple Intelligence isn’t enabled or the model isn’t ready for usage. If Apple Intelligence is off, the app tells the person they need to turn it on and if the model isn’t ready, it tells the person the Trip Planner isn’t ready and to try the app again later.\n\n\n\n## Define structured data for generation\n\nThe app starts by defining data structures with specific constraints to control what the model generates. The `Itinerary` type uses the [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Generable] macro to create structured content that includes travel plans with activities, hotels, and restaurants.\n\nThe `@Generable` macro automatically converts Swift types into schemas that the model uses for constrained sampling, so you can specify guides to control the values you associate with it. For example, the app uses [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Guide(description:)] to make sure the model creates an exciting name for the trip. It also uses [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationGuide\/anyOf(_:)] and [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationGuide\/count(_:)] to choose any destination from our `ModelData` and show exactly 3 `DayPlan` objects per destination, respectively.\n\n```swift\n@Generable\nstruct Itinerary: Equatable {\n    @Guide(description: \"An exciting name for the trip.\")\n    let title: String\n    @Guide(.anyOf(ModelData.landmarkNames))\n    let destinationName: String\n    let description: String\n    @Guide(description: \"An explanation of how the itinerary meets the person's special requests.\")\n    let rationale: String\n\n    @Guide(description: \"A list of day-by-day plans.\")\n    @Guide(.count(3))\n    let days: [DayPlan]\n}\n\n@Generable\nstruct DayPlan: Equatable {\n    @Guide(description: \"A unique and exciting title for this day plan.\")\n    let title: String\n    let subtitle: String\n    let destination: String\n\n    @Guide(.count(3))\n    let activities: [Activity]\n}\n\n@Generable\nstruct Activity: Equatable {\n    let type: Kind\n    let title: String\n    let description: String\n}\n\n@Generable\nenum Kind {\n    case sightseeing\n    case foodAndDining\n    case shopping\n    case hotelAndLodging\n}\n```\n\nThe `@Generable` macro automatically creates two versions of each type: the complete structure and a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Generable\/PartiallyGenerated] version which is a mirror of the outer structure except every property is optional. The app uses this `PartiallyGenerated` version when streaming and displaying the itinerary generation.\n\n## Configure the model session\n\nAfter checking that the model is available, the app configures a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession] object with custom tools and detailed instructions in `ItineraryPlanner`. Given a location, the initializer creates the session with structured guidance for generating personalized trip recommendations.\n\n```swift\ninit(landmark: Landmark) {\n    self.landmark = landmark\n    Logging.general.log(\"The landmark is... \\(landmark.name)\")\n    let pointOfInterestTool = FindPointsOfInterestTool(landmark: landmark)\n    self.session = LanguageModelSession(\n        tools: [pointOfInterestTool],\n        instructions: Instructions {\n            \"Your job is to create an itinerary for the person.\"\n            \n            \"Each day needs an activity, hotel and restaurant.\"\n            \n            \"\"\"\n            Always use the findPointsOfInterest tool to find businesses \\\n            and activities in \\(landmark.name), especially hotels \\\n            and restaurants.\n            \n            The point of interest categories may include:\n            \"\"\"\n            FindPointsOfInterestTool.categories\n            \n            \"\"\"\n            Here is a description of \\(landmark.name) for your reference \\\n            when considering what activities to generate:\n            \"\"\"\n            landmark.description\n        }\n    )\n    self.pointOfInterestTool = pointOfInterestTool\n}\n```\n\nIn a generated itinerary, the model instructions ensure that each day contains an activity, hotel, and restaurant. To get the location-specific businesses and activities, the sample uses a custom tool, called `FindPointsOfInterestTool`, with the chosen landmark. The instructions also call the landmark description property as added context when generating the activities.\n\n## Create a custom tool\n\nYou can use custom tools to extend the functionality of a model. Tool-calling allows the model to interact with external code you create to fetch up-to-date information, ground responses in sources of truth that you provide, and perform side effects.\n\nThe model in this app uses the `FindPointsOfInterestTool` tool to enable dynamic discovery of specific businesses and activities for the chosen landmark. The tool uses the `@Generable` macro to make its categories and arguments available to the model.\n\n```swift\n@Observable\nfinal class FindPointsOfInterestTool: Tool {\n    let name = \"findPointsOfInterest\"\n    let description = \"Finds points of interest for a landmark.\"\n    \n    let landmark: Landmark\n    \n    @MainActor var lookupHistory: [Lookup] = []\n    \n    init(landmark: Landmark) {\n        self.landmark = landmark\n    }\n\n@Generable\nenum Category: String, CaseIterable {\n    case campground\n    case hotel\n    case cafe\n    case museum\n    case marina\n    case restaurant\n    case nationalMonument\n}\n\n@Generable\nstruct Arguments {\n    @Guide(description: \"This is the type of destination to look up for.\")\n    let pointOfInterest: Category\n\n    @Guide(description: \"The natural language query of what to search for.\")\n    let naturalLanguageQuery: String\n}\n```\n\nWhen you prompt the model with a question or make a request, the model decides whether it can provide an answer or if it needs the help of a tool. The app explicitly instructs the model to always use the `findPointsOfInterestTool` in the `ItineraryPlanner` instructions. This allows the model to automatically call the tool to find relevant hotels, restaurants, and activities for the destinations.\n\n## Stream and display partial responses in real time\n\nThe app shows real-time content generation by streaming partial responses from the model. The `ItineraryPlanner` uses [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession\/streamResponse(generating:includeSchemaInPrompt:options:prompt:)] to generate `Itinerary.PartiallyGenerated` objects so itinerary items are shown incrementally to the person.\n\nYou can opt for specific [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationOptions] to adjust the way the model generates these responses. For generating the itinerary, the app opts for a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GenerationOptions\/SamplingMode\/greedy] sampling mode so the model always results in the same output for a given input. This ensures the prompt generates consistent recommendations for an itinerary specific to the given landmark.\n\n```swift\nprivate(set) var itinerary: Itinerary.PartiallyGenerated?\n\nfunc suggestItinerary(dayCount: Int) async throws {\n    let stream = session.streamResponse(\n        generating: Itinerary.self,\n        includeSchemaInPrompt: false,\n        options: GenerationOptions(sampling: .greedy)\n    ) {\n        \"Generate a \\(dayCount)-day itinerary to \\(landmark.name).\"\n\n        \"Give it a fun title and description.\"\n\n        \"Here is an example, but don't copy it:\"\n        Itinerary.exampleTripToJapan\n    }\n\n    for try await partialResponse in stream {\n        itinerary = partialResponse.content\n    }\n}\n```\n\nThe app presents the responses in a SwiftUI view. The `ItineraryPlanningView` displays real-time visual feedback as the model searches for points of interest, showing people what’s happening when generating content:\n\n```swift\nForEach(planner.pointOfInterestTool.lookupHistory) { element in\n    HStack {\n        Image(systemName: \"location.magnifyingglass\")\n        Text(\"Searching **\\(element.history.pointOfInterest.rawValue)** in \\(landmark.name)...\")\n    }\n    .transition(.blurReplace)\n}\n```\n\nThe app displays messages like “Searching **hotel** in Yosemite…” and “Searching **restaurant** in Yosemite…” to let people know which point of interest category the model provided as input to the tool when actively searching for nearby points of interest. In the background, however, the tool executes and provides updates to the view. The view shows a blurred overlay while generating each day plan, then reveals the full itinerary after the search completes.\n\n## Tag content dynamically\n\nThe app uses content tagging on the provided landmarks to help people quickly understand the characteristics of each destination. A content tagging model produces a list of categorizing tags based on the input text you provide. When you prompt the content tagging model, it produces a tag that uses one to a few lowercase words. The `LandmarkDescriptionView` prompts the content tagging model to automatically generate relevant hashtags for landmark descriptions, like `#nature`, `#hiking`, or `#scenic`, based on each landmark’s description. For more information on initializing content tagging, see [doc:\/\/com.apple.documentation\/documentation\/FoundationModels\/categorizing-and-organizing-data-with-content-tags].\n\n```swift\nlet contentTaggingModel = SystemLanguageModel(useCase: .contentTagging)\n\n.task {\n    if !contentTaggingModel.isAvailable { return }\n    do {\n        let session = LanguageModelSession(model: contentTaggingModel)\n        let stream = session.streamResponse(\n            to: landmark.description,\n            generating: TaggingResponse.self,\n            options: GenerationOptions(sampling: .greedy)\n        )\n        for try await newTags in stream {\n            generatedTags = newTags.content\n        }\n    } catch {\n        Logging.general.error(\"\\(error.localizedDescription)\")\n    }\n}\n```\n\n## Integrate with other framework features\n\nYou can combine these generative model features with other Apple frameworks. For example, the `LocationLookup` class uses [doc:\/\/com.apple.documentation\/documentation\/MapKit] to search for addresses for our points of interest, showing how to combine model-generated content with weather information and location data for complete travel planning.\n\n```swift\n@Observable @MainActor\nfinal class LocationLookup {\n    private(set) var item: MKMapItem?\n    private(set) var temperatureString: String?\n\n    func performLookup(location: String) {\n        Task {\n            let item = await self.mapItem(atLocation: location)\n            if let location = item?.location {\n                self.temperatureString = await self.weather(atLocation: location)\n            }\n        }\n    }\n    \n    private func mapItem(atLocation location: String) async -> MKMapItem? {\n        let request = MKLocalSearch.Request()\n        request.naturalLanguageQuery = location\n        \n        let search = MKLocalSearch(request: request)\n        do {\n            return try await search.start().mapItems.first\n        } catch {\n            Logging.general.error(\"Failed to look up location: \\(location). Error: \\(error)\")\n        }\n        return nil\n    }\n}\n```\n\nThe model generates location names as text, and the `LocationLookup` class converts them into real, mappable locations using the natural language search capabilities in MapKit.\n\n## Essentials\n\n- **Generating content and performing tasks with Foundation Models**: Enhance the experience in your app by prompting an on-device large language model.\n- **Improving the safety of generative model output**: Create generative experiences that appropriately handle sensitive inputs and respect people.\n- **Supporting languages and locales with Foundation Models**: Generate content in the language people prefer when they interact with your app.\n- **SystemLanguageModel**: An on-device large language model capable of text generation tasks.\n- **SystemLanguageModel.UseCase**: A type that represents the use case for prompting.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Enhance the experience in your app by prompting an on-device large language model.",
          "name" : "Generating content and performing tasks with Foundation Models",
          "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/generating-content-and-performing-tasks-with-foundation-models"
        },
        {
          "description" : "Create generative experiences that appropriately handle sensitive inputs and respect people.",
          "name" : "Improving the safety of generative model output",
          "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/improving-the-safety-of-generative-model-output"
        },
        {
          "description" : "Generate content in the language people prefer when they interact with your app.",
          "name" : "Supporting languages and locales with Foundation Models",
          "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/supporting-languages-and-locales-with-foundation-models"
        },
        {
          "description" : "An on-device large language model capable of text generation tasks.",
          "name" : "SystemLanguageModel",
          "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/SystemLanguageModel"
        },
        {
          "description" : "A type that represents the use case for prompting.",
          "name" : "SystemLanguageModel.UseCase",
          "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/SystemLanguageModel\/UseCase"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding intelligent app features with generative models",
  "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/adding-intelligent-app-features-with-generative-models"
}