{
  "abstract" : "Build tools that enable the model to perform tasks that are specific to your use case.",
  "codeExamples" : [
    {
      "code" : "struct BreadDatabaseTool: Tool {\n    let name = \"searchBreadDatabase\"\n    let description = \"Searches a local database for bread recipes.\"\n\n    @Generable\n    struct Arguments {\n        @Guide(description: \"The type of bread to search for\")\n        var searchTerm: String\n        @Guide(description: \"The number of recipes to get\", .range(1...6))\n        var limit: Int\n    }\n\n    struct Recipe {\n        var name: String\n        var description: String\n        var link: URL\n    }\n    \n    func call(arguments: Arguments) async throws -> [String] {\n        var recipes: [Recipe] = []\n        \n        \/\/ Put your code here to retrieve a list of recipes from your database.\n        \n        let formattedRecipes = recipes.map {\n            \"Recipe for '\\($0.name)': \\($0.description) Link: \\($0.link)\"\n        }\n        return formattedRecipes\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let session = LanguageModelSession(\n    tools: [BreadDatabaseTool()]\n)\n\nlet response = try await session.respond(\n    to: \"Find three sourdough bread recipes\"\n)",
      "language" : "swift"
    },
    {
      "code" : "struct WeatherTool: Tool {\n  let name = \"getWeather\"\n  let description = \"Retrieve the latest weather information for a city\"\n\n  @Generable\n  struct Arguments {\n      @Guide(description: \"The city to get weather information for\")\n      var city: String\n  }\n\n  struct Forecast: Encodable {\n      var city: String\n      var temperature: Int\n  }\n\n  func call(arguments: Arguments) async throws -> String {\n      \/\/ Get a random temperature value. Use `WeatherKit` to get \n      \/\/ a temperature for the city.\n      let temperature = Int.random(in: 30...100)\n      let formattedResult = \"\"\"\n          The forecast for '\\(arguments.city)' is '\\(temperature)' \\\n          degrees Fahrenheit. \n          \"\"\"\n      return formattedResult\n  }\n}\n\n\/\/ Create a session with default instructions that guide the requests.\nlet session = LanguageModelSession(\n    tools: [WeatherTool()],\n    instructions: \"Help the person with getting weather information\"\n)\n\n\/\/ Make a request that compares the temperature between several locations.\nlet response = try await session.respond(\n    to: \"Is it hotter in Boston, Wichita, or Pittsburgh?\"\n)",
      "language" : "swift"
    },
    {
      "code" : "do {\n    let answer = try await session.respond(\"Find a recipe for tomato soup.\")\n} catch let error as LanguageModelSession.ToolCallError {\n        \n    \/\/ Access the name of the tool, like BreadDatabaseTool.\n    print(error.tool.name) \n        \n    \/\/ Access an underlying error that your tool throws and check if the tool \n    \/\/ encounters a specific condition.\n    if case .databaseIsEmpty = error.underlyingError as? SearchBreadDatabaseToolError {\n        \/\/ Display an error in the UI.\n    }\n\n} catch {\n    print(\"Some other error: \\(error)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyHistoryView: View {\n\n    @State\n    var session = LanguageModelSession(\n        tools: [BreadDatabaseTool()]\n    )\n    \n    var body: some View {\n        List(session.transcript) { entry in\n            switch entry {       \n            case .instructions(let instructions):\n                \/\/ Display the instructions the model uses.\n            case .prompt(let prompt):\n                \/\/ Display the prompt made to the model.\n            case .toolCall(let call):\n                \/\/ Display the call details for a tool, like the tool name and arguments.        \n            case .toolOutput(let output):\n                \/\/ Display the output that a tool provides back to the model.        \n            case .response(let response):\n                \/\/ Display the response from the model.\n            }\n        }.task {\n            do {\n                try await session.respond(to: \"Find a milk bread recipe.\")\n            } catch let error {\n                \/\/ Handle the error.\n            }\n        }\n    }\n    \n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "813f0f227f26fe1fa7d4a9da92cb793dd75614a09a2aa0dd4ac2834bd91ad45d",
  "crawledAt" : "2025-12-02T16:04:47Z",
  "id" : "846FBEE0-EDF4-47F4-A8AA-3C7714E78501",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation Models",
  "overview" : "## Overview\n\nTools provide a way to extend the functionality of the model for your own use cases. Tool-calling allows the model to interact with external code you create to fetch up-to-date information, ground responses in sources of truth that you provide, and perform side effects, like turning on dark mode.\n\nYou can create tools that enable the model to:\n\n## Create a custom tool for your task\n\nWhen you prompt the model with a question or make a request, the model decides whether it can provide an answer or if it needs the help of a tool. When the model determines that a tool can help, it calls the tool with additional arguments that the tool can use. After the tool completes the task, it returns control back to the model with information about what the tool did. The model can then use the output of the tool when it provides the final response.\n\nBefore creating a tool, it’s helpful to understand the pattern the framework follows when using the tool you provide. The framework processes a request in six phases:\n\nA tool conforms to [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Tool] and contains the arguments that the tool accepts, and a method that the model calls when it wants to use the tool. You can call [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Tool\/call(arguments:)] concurrently with itself or with other tools. The following example shows a tool that accepts a search term and a number of recipes to retrieve:\n\nWhen you provide descriptions to generable properties, you help the model understand the semantics of the arguments. Keep descriptions as short as possible because long descriptions take up context size and can introduce latency. For more information on managing the context window size, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3193-managing-the-on-device-foundation-model-s-context-window].\n\nTools use guided generation for the [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Tool\/Arguments] property. For more information about guided generation, see [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/generating-swift-data-structures-with-guided-generation].\n\n## Provide a session with the tool you create\n\nWhen you create a session, you can provide a list of tools that are relevant to the task you want to complete. The tools you provide are available for all future interactions with the session. The following example initializes a session with a tool that the model can call when it determines that it would help satisfy the prompt:\n\nTool output can be a string, or a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GeneratedContent] object. The model can call a tool multiple times in parallel to satisfy the request, like when retrieving weather details for several cities:\n\n## Handle errors thrown by a tool\n\nWhen an error happens during tool calling, the session throws a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession\/ToolCallError] with the underlying error and includes the tool that throws the error. This helps you understand the error that happened during the tool call, and any custom error types that your tool produces. You can throw errors from your tools to escape calls when you detect something is wrong, like when the person using your app doesn’t allow access to the required data or a network call is taking longer than expected. Alternatively, your tool can return a string that briefly tells the model what didn’t work, like “Cannot access the database.”\n\n## Inspect the call graph\n\nA session contains an observable [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession\/transcript] property that allows you to track when, and how many times, the model calls your tools. A transcript also provides the ability to construct a representation of the call graph for debugging purposes and pairs well with [doc:\/\/com.apple.documentation\/documentation\/SwiftUI] to visualize session history.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/FoundationModels\/expanding-generation-with-tool-calling\ncrawled: 2025-12-02T16:04:47Z\n---\n\n# Expanding generation with tool calling\n\n**Article**\n\nBuild tools that enable the model to perform tasks that are specific to your use case.\n\n## Overview\n\nTools provide a way to extend the functionality of the model for your own use cases. Tool-calling allows the model to interact with external code you create to fetch up-to-date information, ground responses in sources of truth that you provide, and perform side effects, like turning on dark mode.\n\nYou can create tools that enable the model to:\n\n- Query entries from your app’s database and reference them in its answer.\n- Perform actions within your app, like adjusting the difficulty in a game or making a web request to get additional information.\n- Integrate with other frameworks, like [doc:\/\/com.apple.documentation\/documentation\/Contacts] or [doc:\/\/com.apple.documentation\/documentation\/HealthKit], that use existing privacy and security mechanisms.\n\n## Create a custom tool for your task\n\nWhen you prompt the model with a question or make a request, the model decides whether it can provide an answer or if it needs the help of a tool. When the model determines that a tool can help, it calls the tool with additional arguments that the tool can use. After the tool completes the task, it returns control back to the model with information about what the tool did. The model can then use the output of the tool when it provides the final response.\n\nBefore creating a tool, it’s helpful to understand the pattern the framework follows when using the tool you provide. The framework processes a request in six phases:\n\n1. You present a list of available tools and their parameters to the model.\n2. You submit your prompt to the model.\n3. The model generates arguments to the tool(s) it wants to invoke.\n4. Your tool runs code on behalf of the model, using the model’s generated arguments.\n5. Your tool passes its output back to the model.\n6. The model produces a final response to the prompt, based on the tool output.\n\nA tool conforms to [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Tool] and contains the arguments that the tool accepts, and a method that the model calls when it wants to use the tool. You can call [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Tool\/call(arguments:)] concurrently with itself or with other tools. The following example shows a tool that accepts a search term and a number of recipes to retrieve:\n\n```swift\nstruct BreadDatabaseTool: Tool {\n    let name = \"searchBreadDatabase\"\n    let description = \"Searches a local database for bread recipes.\"\n\n    @Generable\n    struct Arguments {\n        @Guide(description: \"The type of bread to search for\")\n        var searchTerm: String\n        @Guide(description: \"The number of recipes to get\", .range(1...6))\n        var limit: Int\n    }\n\n    struct Recipe {\n        var name: String\n        var description: String\n        var link: URL\n    }\n    \n    func call(arguments: Arguments) async throws -> [String] {\n        var recipes: [Recipe] = []\n        \n        \/\/ Put your code here to retrieve a list of recipes from your database.\n        \n        let formattedRecipes = recipes.map {\n            \"Recipe for '\\($0.name)': \\($0.description) Link: \\($0.link)\"\n        }\n        return formattedRecipes\n    }\n}\n```\n\nWhen you provide descriptions to generable properties, you help the model understand the semantics of the arguments. Keep descriptions as short as possible because long descriptions take up context size and can introduce latency. For more information on managing the context window size, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3193-managing-the-on-device-foundation-model-s-context-window].\n\nTools use guided generation for the [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/Tool\/Arguments] property. For more information about guided generation, see [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/generating-swift-data-structures-with-guided-generation].\n\n## Provide a session with the tool you create\n\nWhen you create a session, you can provide a list of tools that are relevant to the task you want to complete. The tools you provide are available for all future interactions with the session. The following example initializes a session with a tool that the model can call when it determines that it would help satisfy the prompt:\n\n```swift\nlet session = LanguageModelSession(\n    tools: [BreadDatabaseTool()]\n)\n\nlet response = try await session.respond(\n    to: \"Find three sourdough bread recipes\"\n)\n```\n\nTool output can be a string, or a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/GeneratedContent] object. The model can call a tool multiple times in parallel to satisfy the request, like when retrieving weather details for several cities:\n\n```swift\nstruct WeatherTool: Tool {\n  let name = \"getWeather\"\n  let description = \"Retrieve the latest weather information for a city\"\n\n  @Generable\n  struct Arguments {\n      @Guide(description: \"The city to get weather information for\")\n      var city: String\n  }\n\n  struct Forecast: Encodable {\n      var city: String\n      var temperature: Int\n  }\n\n  func call(arguments: Arguments) async throws -> String {\n      \/\/ Get a random temperature value. Use `WeatherKit` to get \n      \/\/ a temperature for the city.\n      let temperature = Int.random(in: 30...100)\n      let formattedResult = \"\"\"\n          The forecast for '\\(arguments.city)' is '\\(temperature)' \\\n          degrees Fahrenheit. \n          \"\"\"\n      return formattedResult\n  }\n}\n\n\/\/ Create a session with default instructions that guide the requests.\nlet session = LanguageModelSession(\n    tools: [WeatherTool()],\n    instructions: \"Help the person with getting weather information\"\n)\n\n\/\/ Make a request that compares the temperature between several locations.\nlet response = try await session.respond(\n    to: \"Is it hotter in Boston, Wichita, or Pittsburgh?\"\n)\n```\n\n## Handle errors thrown by a tool\n\nWhen an error happens during tool calling, the session throws a [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession\/ToolCallError] with the underlying error and includes the tool that throws the error. This helps you understand the error that happened during the tool call, and any custom error types that your tool produces. You can throw errors from your tools to escape calls when you detect something is wrong, like when the person using your app doesn’t allow access to the required data or a network call is taking longer than expected. Alternatively, your tool can return a string that briefly tells the model what didn’t work, like “Cannot access the database.”\n\n```swift\ndo {\n    let answer = try await session.respond(\"Find a recipe for tomato soup.\")\n} catch let error as LanguageModelSession.ToolCallError {\n        \n    \/\/ Access the name of the tool, like BreadDatabaseTool.\n    print(error.tool.name) \n        \n    \/\/ Access an underlying error that your tool throws and check if the tool \n    \/\/ encounters a specific condition.\n    if case .databaseIsEmpty = error.underlyingError as? SearchBreadDatabaseToolError {\n        \/\/ Display an error in the UI.\n    }\n\n} catch {\n    print(\"Some other error: \\(error)\")\n}\n```\n\n## Inspect the call graph\n\nA session contains an observable [doc:\/\/com.apple.foundationmodels\/documentation\/FoundationModels\/LanguageModelSession\/transcript] property that allows you to track when, and how many times, the model calls your tools. A transcript also provides the ability to construct a representation of the call graph for debugging purposes and pairs well with [doc:\/\/com.apple.documentation\/documentation\/SwiftUI] to visualize session history.\n\n```swift\nstruct MyHistoryView: View {\n\n    @State\n    var session = LanguageModelSession(\n        tools: [BreadDatabaseTool()]\n    )\n    \n    var body: some View {\n        List(session.transcript) { entry in\n            switch entry {       \n            case .instructions(let instructions):\n                \/\/ Display the instructions the model uses.\n            case .prompt(let prompt):\n                \/\/ Display the prompt made to the model.\n            case .toolCall(let call):\n                \/\/ Display the call details for a tool, like the tool name and arguments.        \n            case .toolOutput(let output):\n                \/\/ Display the output that a tool provides back to the model.        \n            case .response(let response):\n                \/\/ Display the response from the model.\n            }\n        }.task {\n            do {\n                try await session.respond(to: \"Find a milk bread recipe.\")\n            } catch let error {\n                \/\/ Handle the error.\n            }\n        }\n    }\n    \n}\n```\n\n## Tool calling\n\n- **Generate dynamic game content with guided generation and tools**: Make gameplay more lively with AI generated dialog and encounters personalized to the player.\n- **Tool**: A tool that a model can call to gather information at runtime or perform side effects.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Make gameplay more lively with AI generated dialog and encounters personalized to the player.",
          "name" : "Generate dynamic game content with guided generation and tools",
          "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/generate-dynamic-game-content-with-guided-generation-and-tools"
        },
        {
          "description" : "A tool that a model can call to gather information at runtime or perform side effects.",
          "name" : "Tool",
          "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/Tool"
        }
      ],
      "title" : "Tool calling"
    }
  ],
  "source" : "appleJSON",
  "title" : "Expanding generation with tool calling",
  "url" : "https:\/\/developer.apple.com\/documentation\/FoundationModels\/expanding-generation-with-tool-calling"
}