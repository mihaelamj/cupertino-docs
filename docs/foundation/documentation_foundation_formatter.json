{
  "abstract" : "An abstract class that declares an interface for objects that create, interpret, and validate the textual representation of values.",
  "codeExamples" : [

  ],
  "conformsTo" : [
    "CVarArg",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Equatable",
    "Hashable",
    "NSCoding",
    "NSCopying",
    "NSObjectProtocol"
  ],
  "contentHash" : "93c88f9ca27c24437da783b78af09f7b0fce20dc160939f5903b5a082ddd88c0",
  "crawledAt" : "2025-12-03T05:09:39Z",
  "declaration" : {
    "code" : "class Formatter",
    "language" : "swift"
  },
  "id" : "B47406F9-C272-44E7-8F49-CD0B3E45FBF0",
  "inheritedBy" : [
    "ByteCountFormatter",
    "DateComponentsFormatter",
    "DateFormatter",
    "DateIntervalFormatter",
    "EnergyFormatter",
    "ISO8601DateFormatter",
    "LengthFormatter",
    "ListFormatter",
    "MassFormatter",
    "MeasurementFormatter",
    "NumberFormatter",
    "PersonNameComponentsFormatter",
    "RelativeDateTimeFormatter"
  ],
  "kind" : "class",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nThe Foundation framework provides several concrete subclasses of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Formatter], including [doc:\/\/com.apple.foundation\/documentation\/Foundation\/ByteCountFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/DateFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/DateComponentsFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/DateIntervalFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/MeasurementFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NumberFormatter], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/PersonNameComponentsFormatter].\n\n### Subclassing Notes\n\n[doc:\/\/com.apple.foundation\/documentation\/Foundation\/Formatter] is intended for subclassing. A custom formatter can restrict the input and enhance the display of data in novel ways. For example, you could have a custom formatter that ensures that serial numbers entered by a user conform to predefined formats. Before you decide to create a custom formatter, make sure that you cannot configure the public subclasses to satisfy your requirements.\n\nFor instructions on how to create your own custom formatter, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/DataFormatting\/Articles\/CreatingACustomFormatter.html#\/\/apple_ref\/doc\/uid\/20000196].",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\ncrawled: 2025-12-03T05:09:39Z\n---\n\n# Formatter\n\n**Class**\n\nAn abstract class that declares an interface for objects that create, interpret, and validate the textual representation of values.\n\n## Declaration\n\n```swift\nclass Formatter\n```\n\n## Overview\n\nThe Foundation framework provides several concrete subclasses of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Formatter], including [doc:\/\/com.apple.foundation\/documentation\/Foundation\/ByteCountFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/DateFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/DateComponentsFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/DateIntervalFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/MeasurementFormatter], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NumberFormatter], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/PersonNameComponentsFormatter].\n\n\n\n### Subclassing Notes\n\n[doc:\/\/com.apple.foundation\/documentation\/Foundation\/Formatter] is intended for subclassing. A custom formatter can restrict the input and enhance the display of data in novel ways. For example, you could have a custom formatter that ensures that serial numbers entered by a user conform to predefined formats. Before you decide to create a custom formatter, make sure that you cannot configure the public subclasses to satisfy your requirements.\n\nFor instructions on how to create your own custom formatter, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/DataFormatting\/Articles\/CreatingACustomFormatter.html#\/\/apple_ref\/doc\/uid\/20000196].\n\n## Getting Textual Representations of Object Values\n\n- **string(for:)**: The default implementation of this method raises an exception.\n- **attributedString(for:withDefaultAttributes:)**: The default implementation returns `nil` to indicate that the formatter object does not provide an attributed string.\n- **editingString(for:)**: The default implementation of this method invokes [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Formatter\/string(for:)].\n\n## Getting Object Values for Textual Representations\n\n- **getObjectValue(_:for:errorDescription:)**: The default implementation of this method raises an exception.\n\n## Validating Partial Strings\n\n- **isPartialStringValid(_:newEditingString:errorDescription:)**: Returns a Boolean value that indicates whether a partial string is valid.\n- **isPartialStringValid(_:proposedSelectedRange:originalString:originalSelectedRange:errorDescription:)**: This method should be implemented in subclasses that want to validate user changes to a string in a field, where the user changes are not necessarily at the end of the string, and preserve the selection (or set a different one, such as selecting the erroneous part of the string the user has typed).\n\n## Constants\n\n- **Formatter.Context**: The formatting context for a formatter.\n- **Formatter.UnitStyle**: Specifies the width of the unit, determining the textual representation.\n\n## Inherits From\n\n- NSObject\n\n## Inherited By\n\n- ByteCountFormatter\n- DateComponentsFormatter\n- DateFormatter\n- DateIntervalFormatter\n- EnergyFormatter\n- ISO8601DateFormatter\n- LengthFormatter\n- ListFormatter\n- MassFormatter\n- MeasurementFormatter\n- NumberFormatter\n- PersonNameComponentsFormatter\n- RelativeDateTimeFormatter\n\n## Conforms To\n\n- CVarArg\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Equatable\n- Hashable\n- NSCoding\n- NSCopying\n- NSObjectProtocol\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The default implementation of this method raises an exception.",
          "name" : "string(for:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/string(for:)"
        },
        {
          "description" : "The default implementation returns `nil` to indicate that the formatter object does not provide an attributed string.",
          "name" : "attributedString(for:withDefaultAttributes:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/attributedString(for:withDefaultAttributes:)"
        },
        {
          "description" : "The default implementation of this method invokes [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Formatter\/string(for:)].",
          "name" : "editingString(for:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/editingString(for:)"
        }
      ],
      "title" : "Getting Textual Representations of Object Values"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The default implementation of this method raises an exception.",
          "name" : "getObjectValue(_:for:errorDescription:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/getObjectValue(_:for:errorDescription:)"
        }
      ],
      "title" : "Getting Object Values for Textual Representations"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a Boolean value that indicates whether a partial string is valid.",
          "name" : "isPartialStringValid(_:newEditingString:errorDescription:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/isPartialStringValid(_:newEditingString:errorDescription:)"
        },
        {
          "description" : "This method should be implemented in subclasses that want to validate user changes to a string in a field, where the user changes are not necessarily at the end of the string, and preserve the selection (or set a different one, such as selecting the erroneous part of the string the user has typed).",
          "name" : "isPartialStringValid(_:proposedSelectedRange:originalString:originalSelectedRange:errorDescription:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/isPartialStringValid(_:proposedSelectedRange:originalString:originalSelectedRange:errorDescription:)"
        }
      ],
      "title" : "Validating Partial Strings"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The formatting context for a formatter.",
          "name" : "Formatter.Context",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/Context"
        },
        {
          "description" : "Specifies the width of the unit, determining the textual representation.",
          "name" : "Formatter.UnitStyle",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter\/UnitStyle"
        }
      ],
      "title" : "Constants"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "NSObject"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "Formatter",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Formatter"
}