{
  "abstract" : "A logical condition used to test a set of input values for searching or filtering.",
  "codeExamples" : [
    {
      "code" : "let messagePredicate = #Predicate<Message> { message in\n    message.length < 100 && message.sender == \"Jeremy\"\n}",
      "language" : "swift"
    },
    {
      "code" : "let messagePredicate = #Predicate<Message> { message in\n    message.recipients.contains {\n        $0.firstName == message.sender.firstName\n    }\n}",
      "language" : "swift"
    }
  ],
  "conformsTo" : [
    "Copyable",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Decodable",
    "DecodableWithConfiguration",
    "Encodable",
    "EncodableWithConfiguration",
    "Sendable",
    "SendableMetatype"
  ],
  "contentHash" : "881e276cd86c2515d986b3426a7f9a4ffb6389b03a6c8c07a3371761abb89592",
  "crawledAt" : "2025-12-02T20:26:40Z",
  "declaration" : {
    "code" : "struct Predicate<each Input>",
    "language" : "swift"
  },
  "id" : "3C873641-21FD-4C6E-B7C2-2D5D4B0A137A",
  "kind" : "struct",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nA predicate is a logical condition that evaluates to a Boolean value (true or false).  You use predicates for operations like filtering a collection or searching for matching elements.\n\nTo create a predicate, use the `Predicate(_:)` macro.  For example:\n\nIn the example above, the closure that contains the predicate’s conditions takes one argument — the value being tested. Even though you write the predicate using a closure, the macro transforms that closure into a predicate when you compile. The code in the closure isn’t run as part of your program.\n\nIn the predicate’s definition, you can use the following operations:\n\nA predicate can’t contain any nested declarations, use any flow control such as `for` loops, or modify variables from its enclosing scope. However, it can refer to constants that are in scope.\n\nTo express more complex queries, you can nest expressions in the predicate:\n\nYou can safely encode and decode predicates, pass predicates across concurrency boundaries, and load a predicate from a file. To define a list of types and key paths that are allowed when reading an archived predicate, use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/PredicateCodableConfiguration].\n\nYou can transform a predicate into another representation — for example, to express a predicate in another query language, or to create a modified predicate — using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Predicate\/expression] property.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate\ncrawled: 2025-12-02T20:26:40Z\n---\n\n# Predicate\n\n**Structure**\n\nA logical condition used to test a set of input values for searching or filtering.\n\n## Declaration\n\n```swift\nstruct Predicate<each Input>\n```\n\n## Overview\n\nA predicate is a logical condition that evaluates to a Boolean value (true or false).  You use predicates for operations like filtering a collection or searching for matching elements.\n\nTo create a predicate, use the `Predicate(_:)` macro.  For example:\n\n```swift\nlet messagePredicate = #Predicate<Message> { message in\n    message.length < 100 && message.sender == \"Jeremy\"\n}\n```\n\nIn the example above, the closure that contains the predicate’s conditions takes one argument — the value being tested. Even though you write the predicate using a closure, the macro transforms that closure into a predicate when you compile. The code in the closure isn’t run as part of your program.\n\nIn the predicate’s definition, you can use the following operations:\n\n- Arithmetic (`+`, `-`, `*`, `\/`, `%`)\n- Unary minus (`-`)\n- Range (`...`, `..<`)\n- Comparison (`<`, `<=`, `>`, `>=`, `==`, `!=`)\n- Ternary conditional (`?:`)\n- Conditional expressions\n- Boolean logic (`&&`, `||`, `!`)\n- Swift optionals (`?`, `??`, `!`, `flatMap(_:)`, `if`-`let` expressions)\n- Types (`as`, `as?`, `as!`, `is`)\n- Sequence operations (`allSatisfy()`, `filter()`, `contains()`, `contains(where:)`, `starts(with:)`, `max()`, `min()`)\n- Subscript and member access (`[]`, `.`)\n- String comparisons (`contains(_:)`, `localizedStandardContains(_:)`, `caseInsensitiveCompare(_:)`, `localizedCompare(_:)`)\n\nA predicate can’t contain any nested declarations, use any flow control such as `for` loops, or modify variables from its enclosing scope. However, it can refer to constants that are in scope.\n\nTo express more complex queries, you can nest expressions in the predicate:\n\n```swift\nlet messagePredicate = #Predicate<Message> { message in\n    message.recipients.contains {\n        $0.firstName == message.sender.firstName\n    }\n}\n```\n\nYou can safely encode and decode predicates, pass predicates across concurrency boundaries, and load a predicate from a file. To define a list of types and key paths that are allowed when reading an archived predicate, use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/PredicateCodableConfiguration].\n\nYou can transform a predicate into another representation — for example, to express a predicate in another query language, or to create a modified predicate — using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Predicate\/expression] property.\n\n## Inspecting and transforming a predicate\n\n- **expression**: The component expressions of the predicate.\n\n## Initializers\n\n- **init(_:)**\n\n## Instance Properties\n\n- **variable**\n\n## Instance Methods\n\n- **evaluate(_:)**\n\n## Type Properties\n\n- **false**\n- **true**\n\n## Filltering\n\n- **PredicateError**: An error thrown while evaluating a predicate.\n- **PredicateCodableConfiguration**: A specification of the expected types and key paths found in an archived predicate.\n- **PredicateCodableKeyPathProviding**: A type that provides the expected key paths found in an archived predicate.\n- **PredicateExpression**: A component expression that makes up part of a predicate.\n- **StandardPredicateExpression**: A component expression that makes up part of a predicate, and that’s supported by the standard predicate type.\n- **PredicateExpressions**: The expressions that make up a predicate.\n- **PredicateBindings**: A mapping from a predicates’s input variables to their values.\n- **NSPredicate**: A definition of logical conditions for constraining a search for a fetch or for in-memory filtering.\n- **NSExpression**: An expression for use in a comparison predicate.\n- **NSComparisonPredicate**: A specialized predicate for comparing expressions.\n- **NSCompoundPredicate**: A specialized predicate that evaluates logical combinations of other predicates.\n\n## Conforms To\n\n- Copyable\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Decodable\n- DecodableWithConfiguration\n- Encodable\n- EncodableWithConfiguration\n- Sendable\n- SendableMetatype\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The component expressions of the predicate.",
          "name" : "expression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate\/expression"
        }
      ],
      "title" : "Inspecting and transforming a predicate"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate\/init(_:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "variable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate\/variable"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "evaluate(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate\/evaluate(_:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "false",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate\/false"
        },
        {
          "description" : "",
          "name" : "true",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate\/true"
        }
      ],
      "title" : "Type Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "An error thrown while evaluating a predicate.",
          "name" : "PredicateError",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateError"
        },
        {
          "description" : "A specification of the expected types and key paths found in an archived predicate.",
          "name" : "PredicateCodableConfiguration",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateCodableConfiguration"
        },
        {
          "description" : "A type that provides the expected key paths found in an archived predicate.",
          "name" : "PredicateCodableKeyPathProviding",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateCodableKeyPathProviding"
        },
        {
          "description" : "A component expression that makes up part of a predicate.",
          "name" : "PredicateExpression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateExpression"
        },
        {
          "description" : "A component expression that makes up part of a predicate, and that’s supported by the standard predicate type.",
          "name" : "StandardPredicateExpression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/StandardPredicateExpression"
        },
        {
          "description" : "The expressions that make up a predicate.",
          "name" : "PredicateExpressions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateExpressions"
        },
        {
          "description" : "A mapping from a predicates’s input variables to their values.",
          "name" : "PredicateBindings",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateBindings"
        },
        {
          "description" : "A definition of logical conditions for constraining a search for a fetch or for in-memory filtering.",
          "name" : "NSPredicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSPredicate"
        },
        {
          "description" : "An expression for use in a comparison predicate.",
          "name" : "NSExpression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression"
        },
        {
          "description" : "A specialized predicate for comparing expressions.",
          "name" : "NSComparisonPredicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSComparisonPredicate"
        },
        {
          "description" : "A specialized predicate that evaluates logical combinations of other predicates.",
          "name" : "NSCompoundPredicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSCompoundPredicate"
        }
      ],
      "title" : "Filltering"
    }
  ],
  "source" : "appleJSON",
  "title" : "Predicate",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate"
}