{
  "abstract" : "An expression for use in a comparison predicate.",
  "codeExamples" : [
    {
      "code" : "(expression UNION expression)\n(expression INTERSECT expression)\n(expression MINUS expression)",
      "language" : "objc"
    },
    {
      "code" : "FUNCTION(@\"\/Developer\/Tools\/otest\", @\"lastPathComponent\") => @\"otest\"",
      "language" : "objc"
    }
  ],
  "conformsTo" : [
    "CVarArg",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Equatable",
    "Hashable",
    "NSCoding",
    "NSCopying",
    "NSObjectProtocol",
    "NSSecureCoding"
  ],
  "contentHash" : "786aac9629dcfe3264376ab7e69fd0516e9323f5e7e32e72f4dc24ee461f2878",
  "crawledAt" : "2025-12-06T12:22:47Z",
  "declaration" : {
    "code" : "class NSExpression",
    "language" : "swift"
  },
  "id" : "3DF59994-3555-420D-8922-9C6DF6F63DC1",
  "kind" : "class",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nComparison operations in an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSPredicate] derive from two expressions as instances of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression] class. You create expressions for constant values, key paths, and so on.\n\nGenerally, anywhere in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression] class hierarchy where there’s a composite API and subtypes that may only reasonably respond to a subset of that API, invoking a method that doesn’t make sense for that subtype throws an exception.\n\n### Aggregate Expressions\n\n[doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/aggregate] allows you to create predicates containing expressions that evaluate to collections that contain further expressions. The collection may be an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSArray], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSSet], or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSDictionary] object.\n\nCore Data doesn’t support aggregate expressions.\n\n### Subquery Expressions\n\nThe [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/subquery] creates a subexpression that returns a subset of a collection of objects. This allows you to create sophisticated queries across relationships, such as a search for multiple correlated values on the destination object of a relationship.\n\n### Set Expressions\n\nThe set expressions ([doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/unionSet], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/intersectSet], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/minusSet]) combine results in a manner similar to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSSet] methods.\n\nBoth sides of these expressions must evaluate to a collection; the left side must evaluate to an `NSSet` object, and the right side can be any other collection type.\n\nCore Data doesn’t support set expressions.\n\n### Function Expressions\n\nIn macOS 10.4, [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression] only supports a predefined set of functions: `sum`, `count`, `min`, `max`, and `average`. You access these predefined functions in the predicate syntax using custom keywords (for example, `MAX(1, 5, 10)`).\n\nIn macOS 10.5 and later, function expressions also support arbitrary method invocations. To implement this extended functionality, use the syntax `FUNCTION(receiver, selectorName, arguments, ...),` as in the following example:\n\nAll methods must take one or more `id` arguments and return an `id` value, although you can use the `CAST` expression to convert datatypes with lossy string representations (for example, `CAST(####, \"NSDate\")`). macOS 10.5 extends the `CAST` expression to provide support for casting to classes for use in creating receivers for function expressions.\n\nAlthough Core Data supports evaluation of the predefined functions, it doesn’t support the evaluation of custom predicate functions in the persistent stores (during a fetch).",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/foundation\/nsexpression\ncrawled: 2025-12-06T12:22:47Z\n---\n\n# NSExpression\n\n**Class**\n\nAn expression for use in a comparison predicate.\n\n## Declaration\n\n```swift\nclass NSExpression\n```\n\n## Overview\n\nComparison operations in an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSPredicate] derive from two expressions as instances of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression] class. You create expressions for constant values, key paths, and so on.\n\nGenerally, anywhere in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression] class hierarchy where there’s a composite API and subtypes that may only reasonably respond to a subset of that API, invoking a method that doesn’t make sense for that subtype throws an exception.\n\n### Aggregate Expressions\n\n[doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/aggregate] allows you to create predicates containing expressions that evaluate to collections that contain further expressions. The collection may be an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSArray], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSSet], or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSDictionary] object.\n\nCore Data doesn’t support aggregate expressions.\n\n### Subquery Expressions\n\nThe [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/subquery] creates a subexpression that returns a subset of a collection of objects. This allows you to create sophisticated queries across relationships, such as a search for multiple correlated values on the destination object of a relationship.\n\n### Set Expressions\n\nThe set expressions ([doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/unionSet], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/intersectSet], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum\/minusSet]) combine results in a manner similar to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSSet] methods.\n\nBoth sides of these expressions must evaluate to a collection; the left side must evaluate to an `NSSet` object, and the right side can be any other collection type.\n\n```objc\n(expression UNION expression)\n(expression INTERSECT expression)\n(expression MINUS expression)\n```\n\nCore Data doesn’t support set expressions.\n\n### Function Expressions\n\nIn macOS 10.4, [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSExpression] only supports a predefined set of functions: `sum`, `count`, `min`, `max`, and `average`. You access these predefined functions in the predicate syntax using custom keywords (for example, `MAX(1, 5, 10)`).\n\nIn macOS 10.5 and later, function expressions also support arbitrary method invocations. To implement this extended functionality, use the syntax `FUNCTION(receiver, selectorName, arguments, ...),` as in the following example:\n\n```objc\nFUNCTION(@\"\/Developer\/Tools\/otest\", @\"lastPathComponent\") => @\"otest\"\n```\n\nAll methods must take one or more `id` arguments and return an `id` value, although you can use the `CAST` expression to convert datatypes with lossy string representations (for example, `CAST(####, \"NSDate\")`). macOS 10.5 extends the `CAST` expression to provide support for casting to classes for use in creating receivers for function expressions.\n\nAlthough Core Data supports evaluation of the predefined functions, it doesn’t support the evaluation of custom predicate functions in the persistent stores (during a fetch).\n\n## Creating an Expression\n\n- **init(expressionType:)**: Creates the expression with the specified expression type.\n- **init(format:argumentArray:)**: Creates the expression with the specified expression format and array of arguments.\n- **init(format:arguments:)**: Creates the expression with the specified expression format and arguments list.\n- **init(format:_:)**: Creates the expression with the expression format and arguments list you specify.\n- **init(coder:)**: Creates an expression by decoding from the coder you specify.\n\n## Creating an Expression for a Value\n\n- **init(forConstantValue:)**: Creates an expression that represents a specified constant value.\n- **expressionForEvaluatedObject()**: Creates an expression that represents the object you’re evaluating.\n- **init(forKeyPath:)**: Creates an expression that invokes the value function with a specified key path.\n- **init(forVariable:)**: Creates an expression that extracts a value from the variable bindings dictionary for a specified key.\n- **init(forKeyPath:)**: Creates an expression using a key path you specify.\n- **expressionForAnyKey()**: Creates an expression that represents any key for a Spotlight query.\n\n## Creating a Collection Expression\n\n- **init(forAggregate:)**: Creates an aggregate expression for a specified collection.\n- **init(forUnionSet:with:)**: Creates an expression object that represents the union of a specified set and collection.\n- **init(forIntersectSet:with:)**: Creates an expression object that represents the intersection of a specified set and collection.\n- **init(forMinusSet:with:)**: Creates an expression object that represents the subtraction of a specified collection from a specified set.\n\n## Creating a Subquery\n\n- **init(forSubquery:usingIteratorVariable:predicate:)**: Creates an expression that filters a collection by storing elements in the collection in a specified variable and keeping the elements that the qualifier returns as true.\n\n## Creating a Conditional Expression\n\n- **init(forConditional:trueExpression:falseExpression:)**: Creates an expression that returns a result, depending on the value of predicate.\n\n## Creating an Expression Using Blocks\n\n- **init(block:arguments:)**: Creates an expression object that uses the block for evaluating objects.\n\n## Creating an Expression for a Function\n\n- **init(forFunction:arguments:)**: Creates an expression that invokes one of the predefined functions.\n- **init(forFunction:selectorName:arguments:)**: Creates an expression that returns the result of invoking a selector with a specified name using specified arguments.\n\n## Getting Information About an Expression\n\n- **arguments**: The arguments for the expression.\n- **collection**: The collection of expressions in an aggregate expression, or the collection element of a subquery expression.\n- **constantValue**: The constant value of the expression.\n- **expressionType**: The expression type for the expression.\n- **NSExpression.ExpressionType**: Defines the possible types of an expression.\n- **function**: The function for the expression.\n- **keyPath**: The key path for the expression.\n- **operand**: The operand for the expression.\n- **predicate**: The predicate of a subquery expression.\n- **left**: The left expression of an aggregate expression.\n- **right**: The right expression of an aggregate expression.\n- **variable**: The variable for the expression.\n\n## Evaluating an Expression\n\n- **expressionValue(with:context:)**: Evaluates an expression using a specified object and context.\n- **allowEvaluation()**: Forces a securely decoded expression to allow evaluation.\n- **false**: An expression to evalutate if a conditional expression’s predicate evaluates to false.\n- **true**: An expression to evalutate if a conditional expression’s predicate evaluates to true.\n\n## Accessing the Expression Block\n\n- **expressionBlock**: The block that executes to evaluate the expression.\n\n## Initializers\n\n- **init(_:)**\n\n## Filltering\n\n- **Predicate**: A logical condition used to test a set of input values for searching or filtering.\n- **PredicateError**: An error thrown while evaluating a predicate.\n- **PredicateCodableConfiguration**: A specification of the expected types and key paths found in an archived predicate.\n- **PredicateCodableKeyPathProviding**: A type that provides the expected key paths found in an archived predicate.\n- **PredicateExpression**: A component expression that makes up part of a predicate.\n- **StandardPredicateExpression**: A component expression that makes up part of a predicate, and that’s supported by the standard predicate type.\n- **PredicateExpressions**: The expressions that make up a predicate.\n- **PredicateBindings**: A mapping from a predicates’s input variables to their values.\n- **NSPredicate**: A definition of logical conditions for constraining a search for a fetch or for in-memory filtering.\n- **NSComparisonPredicate**: A specialized predicate for comparing expressions.\n- **NSCompoundPredicate**: A specialized predicate that evaluates logical combinations of other predicates.\n\n## Inherits From\n\n- NSObject\n\n## Conforms To\n\n- CVarArg\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Equatable\n- Hashable\n- NSCoding\n- NSCopying\n- NSObjectProtocol\n- NSSecureCoding\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates the expression with the specified expression type.",
          "name" : "init(expressionType:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(expressionType:)"
        },
        {
          "description" : "Creates the expression with the specified expression format and array of arguments.",
          "name" : "init(format:argumentArray:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(format:argumentArray:)"
        },
        {
          "description" : "Creates the expression with the specified expression format and arguments list.",
          "name" : "init(format:arguments:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(format:arguments:)"
        },
        {
          "description" : "Creates the expression with the expression format and arguments list you specify.",
          "name" : "init(format:_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(format:_:)"
        },
        {
          "description" : "Creates an expression by decoding from the coder you specify.",
          "name" : "init(coder:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(coder:)"
        }
      ],
      "title" : "Creating an Expression"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an expression that represents a specified constant value.",
          "name" : "init(forConstantValue:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forConstantValue:)"
        },
        {
          "description" : "Creates an expression that represents the object you’re evaluating.",
          "name" : "expressionForEvaluatedObject()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/expressionForEvaluatedObject()"
        },
        {
          "description" : "Creates an expression that invokes the value function with a specified key path.",
          "name" : "init(forKeyPath:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forKeyPath:)-1aqf5"
        },
        {
          "description" : "Creates an expression that extracts a value from the variable bindings dictionary for a specified key.",
          "name" : "init(forVariable:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forVariable:)"
        },
        {
          "description" : "Creates an expression using a key path you specify.",
          "name" : "init(forKeyPath:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forKeyPath:)-98by"
        },
        {
          "description" : "Creates an expression that represents any key for a Spotlight query.",
          "name" : "expressionForAnyKey()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/expressionForAnyKey()"
        }
      ],
      "title" : "Creating an Expression for a Value"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an aggregate expression for a specified collection.",
          "name" : "init(forAggregate:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forAggregate:)"
        },
        {
          "description" : "Creates an expression object that represents the union of a specified set and collection.",
          "name" : "init(forUnionSet:with:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forUnionSet:with:)"
        },
        {
          "description" : "Creates an expression object that represents the intersection of a specified set and collection.",
          "name" : "init(forIntersectSet:with:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forIntersectSet:with:)"
        },
        {
          "description" : "Creates an expression object that represents the subtraction of a specified collection from a specified set.",
          "name" : "init(forMinusSet:with:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forMinusSet:with:)"
        }
      ],
      "title" : "Creating a Collection Expression"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an expression that filters a collection by storing elements in the collection in a specified variable and keeping the elements that the qualifier returns as true.",
          "name" : "init(forSubquery:usingIteratorVariable:predicate:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forSubquery:usingIteratorVariable:predicate:)"
        }
      ],
      "title" : "Creating a Subquery"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an expression that returns a result, depending on the value of predicate.",
          "name" : "init(forConditional:trueExpression:falseExpression:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forConditional:trueExpression:falseExpression:)"
        }
      ],
      "title" : "Creating a Conditional Expression"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an expression object that uses the block for evaluating objects.",
          "name" : "init(block:arguments:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(block:arguments:)"
        }
      ],
      "title" : "Creating an Expression Using Blocks"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates an expression that invokes one of the predefined functions.",
          "name" : "init(forFunction:arguments:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forFunction:arguments:)"
        },
        {
          "description" : "Creates an expression that returns the result of invoking a selector with a specified name using specified arguments.",
          "name" : "init(forFunction:selectorName:arguments:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(forFunction:selectorName:arguments:)"
        }
      ],
      "title" : "Creating an Expression for a Function"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The arguments for the expression.",
          "name" : "arguments",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/arguments"
        },
        {
          "description" : "The collection of expressions in an aggregate expression, or the collection element of a subquery expression.",
          "name" : "collection",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/collection"
        },
        {
          "description" : "The constant value of the expression.",
          "name" : "constantValue",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/constantValue"
        },
        {
          "description" : "The expression type for the expression.",
          "name" : "expressionType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/expressionType-swift.property"
        },
        {
          "description" : "Defines the possible types of an expression.",
          "name" : "NSExpression.ExpressionType",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/ExpressionType-swift.enum"
        },
        {
          "description" : "The function for the expression.",
          "name" : "function",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/function"
        },
        {
          "description" : "The key path for the expression.",
          "name" : "keyPath",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/keyPath"
        },
        {
          "description" : "The operand for the expression.",
          "name" : "operand",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/operand"
        },
        {
          "description" : "The predicate of a subquery expression.",
          "name" : "predicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/predicate"
        },
        {
          "description" : "The left expression of an aggregate expression.",
          "name" : "left",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/left"
        },
        {
          "description" : "The right expression of an aggregate expression.",
          "name" : "right",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/right"
        },
        {
          "description" : "The variable for the expression.",
          "name" : "variable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/variable"
        }
      ],
      "title" : "Getting Information About an Expression"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Evaluates an expression using a specified object and context.",
          "name" : "expressionValue(with:context:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/expressionValue(with:context:)"
        },
        {
          "description" : "Forces a securely decoded expression to allow evaluation.",
          "name" : "allowEvaluation()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/allowEvaluation()"
        },
        {
          "description" : "An expression to evalutate if a conditional expression’s predicate evaluates to false.",
          "name" : "false",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/false"
        },
        {
          "description" : "An expression to evalutate if a conditional expression’s predicate evaluates to true.",
          "name" : "true",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/true"
        }
      ],
      "title" : "Evaluating an Expression"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The block that executes to evaluate the expression.",
          "name" : "expressionBlock",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/expressionBlock"
        }
      ],
      "title" : "Accessing the Expression Block"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "init(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSExpression\/init(_:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A logical condition used to test a set of input values for searching or filtering.",
          "name" : "Predicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Predicate"
        },
        {
          "description" : "An error thrown while evaluating a predicate.",
          "name" : "PredicateError",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateError"
        },
        {
          "description" : "A specification of the expected types and key paths found in an archived predicate.",
          "name" : "PredicateCodableConfiguration",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateCodableConfiguration"
        },
        {
          "description" : "A type that provides the expected key paths found in an archived predicate.",
          "name" : "PredicateCodableKeyPathProviding",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateCodableKeyPathProviding"
        },
        {
          "description" : "A component expression that makes up part of a predicate.",
          "name" : "PredicateExpression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateExpression"
        },
        {
          "description" : "A component expression that makes up part of a predicate, and that’s supported by the standard predicate type.",
          "name" : "StandardPredicateExpression",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/StandardPredicateExpression"
        },
        {
          "description" : "The expressions that make up a predicate.",
          "name" : "PredicateExpressions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateExpressions"
        },
        {
          "description" : "A mapping from a predicates’s input variables to their values.",
          "name" : "PredicateBindings",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/PredicateBindings"
        },
        {
          "description" : "A definition of logical conditions for constraining a search for a fetch or for in-memory filtering.",
          "name" : "NSPredicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSPredicate"
        },
        {
          "description" : "A specialized predicate for comparing expressions.",
          "name" : "NSComparisonPredicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSComparisonPredicate"
        },
        {
          "description" : "A specialized predicate that evaluates logical combinations of other predicates.",
          "name" : "NSCompoundPredicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSCompoundPredicate"
        }
      ],
      "title" : "Filltering"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "NSObject"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "NSExpression",
  "url" : "https:\/\/developer.apple.com\/documentation\/foundation\/nsexpression"
}