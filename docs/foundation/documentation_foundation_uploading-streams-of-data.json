{
  "abstract" : "Send a stream of data to a server.",
  "codeExamples" : [
    {
      "code" : "lazy var session: URLSession = URLSession(configuration: .default,\n                                          delegate: self,\n                                          delegateQueue: .main)\n",
      "language" : "swift"
    },
    {
      "code" : "let url = URL(string: \"http:\/\/127.0.0.1:12345\")!\nvar request = URLRequest(url: url,\n                         cachePolicy: .reloadIgnoringLocalCacheData,\n                         timeoutInterval: 10)\nrequest.httpMethod = \"POST\"\nlet uploadTask = session.uploadTask(withStreamedRequest: request)\nuploadTask.resume()",
      "language" : "swift"
    },
    {
      "code" : "struct Streams {\n    let input: InputStream\n    let output: OutputStream\n}\nlazy var boundStreams: Streams = {\n    var inputOrNil: InputStream? = nil\n    var outputOrNil: OutputStream? = nil\n    Stream.getBoundStreams(withBufferSize: 4096,\n                           inputStream: &inputOrNil,\n                           outputStream: &outputOrNil)\n    guard let input = inputOrNil, let output = outputOrNil else {\n        fatalError(\"On return of `getBoundStreams`, both `inputStream` and `outputStream` will contain non-nil streams.\")\n    }\n    \/\/ configure and open output stream\n    output.delegate = self\n    output.schedule(in: .current, forMode: .default)\n    output.open()\n    return Streams(input: input, output: output)\n}()\n",
      "language" : "swift"
    },
    {
      "code" : "func urlSession(_ session: URLSession, task: URLSessionTask,\n                needNewBodyStream completionHandler: @escaping (InputStream?) -> Void) {\n    completionHandler(boundStreams.input)\n}",
      "language" : "swift"
    },
    {
      "code" : "func stream(_ aStream: Stream, handle eventCode: Stream.Event) {\n    guard aStream == boundStreams.output else {\n        return\n    }\n    if eventCode.contains(.hasSpaceAvailable) {\n        canWrite = true\n    }\n    if eventCode.contains(.errorOccurred) {\n        \/\/ Close the streams and alert the user that the upload failed.\n    }\n}\n",
      "language" : "swift"
    },
    {
      "code" : "timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) {\n    [weak self] timer in\n    guard let self = self else { return }\n\n    if self.canWrite {\n        let message = \"*** \\(Date())\\r\\n\"\n        guard let messageData = message.data(using: .utf8) else { return }\n        let messageCount = messageData.count\n        let bytesWritten: Int = messageData.withUnsafeBytes() { (buffer: UnsafePointer<UInt8>) in\n            self.canWrite = false\n            return self.boundStreams.output.write(buffer, maxLength: messageCount)\n        }\n        if bytesWritten < messageCount {\n            \/\/ Handle writing less data than expected.\n        }\n    }\n}\n",
      "language" : "swift"
    }
  ],
  "contentHash" : "947112e84affe9ae57941f9b75ffe322c842de622b5175e77cc9f404b338a2fe",
  "crawledAt" : "2025-12-02T15:47:15Z",
  "id" : "66BA77E7-BC46-4D94-8826-6DB52A97BEF9",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nStreaming media apps and long-running apps that send continual updates use an ongoing stream to upload data, rather than sending a single block of data or a flat file. You can configure an instance of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionUploadTask] (a subclass of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask]) to work with a stream that you provide, and then fill this stream with data indefinitely.\n\nThe task gets the stream by calling your session’s delegate, so you need to create a session and set your own code as its delegate.\n\n### Create a URL session\n\nBegin by creating a URLSession and providing it with a delegate. The following example creates a URL session with the default [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionConfiguration] and sets `self` as the delegate. You’ll implement [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate] later, in [doc:\/\/com.apple.foundation\/documentation\/Foundation\/uploading-streams-of-data#Provide-the-stream-to-the-upload-task].\n\nCreating a URLSession with a delegate\n\n### Create a streaming upload task\n\nCreate the upload task with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/uploadTask(withStreamedRequest:)]. This takes a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLRequest] specifying the URL you want to upload to, along with other parameters. You start the task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()]. The following example shows how to create and start an upload task, connecting to a server on the local machine (`127.0.0.1`) listening on port `12345`.\n\nCreating an upload task\n\n### Use a bound pair of streams to provide an input stream\n\nYou provide the streaming data to the upload task as an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/InputStream]. The task reads data from this stream and uploads it to the destination.\n\nA good way to provide data to the input stream is to use a *bound pair* of streams. The bound pair contains an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream] that you write data to. Thanks to the binding of the streams, the data you write to the output stream is made available to the input stream, which the task can then read from. [\/documentation\/foundation\/url_loading_system\/uploading_streams_of_data#3037791] shows this arrangement.\n\n\n\nThe following example shows a structure called `Streams` that consists of an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/InputStream] and an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream]. The listing creates a property of this type, called `boundStreams`, by calling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/getBoundStreams(withBufferSize:inputStream:outputStream:)] method of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream] class, passing in in-out references for the input and output streams.\n\nCreating a bound pair of input and output streams\n\nWhen you create the bound pair, make sure you specify a buffer size large enough to hold any data you write to the output stream, prior to the data being read from the input stream. The following example uses a 4096-byte buffer.\n\nThe listing also sets `self` as the output stream’s delegate. Declare that your class implements the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] protocol in order to receive events that indicate when the output stream is ready to receive new data. You’ll provide the implementation of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] later, in [doc:\/\/com.apple.foundation\/documentation\/Foundation\/uploading-streams-of-data#Write-data-to-the-stream-when-its-ready].\n\n### Provide the stream to the upload task\n\nYou provide the input stream to the upload task in your implementation of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:needNewBodyStream:)], which is called after you start the upload task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()]. The callback passes in a completion handler, which you call directly, passing in the `boundStreams.input` stream you created earlier. The following example shows an implementation of this method.\n\nProviding the input stream to the upload task in the delegate callback\n\n### Write data to the stream when it’s ready\n\nWrite data to an output stream only when the stream is ready for it. You get notified of the stream’s readiness in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate\/stream(_:handle:)]. When this callback sends [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] as its `eventCode` parameter, the stream is ready to accept more data.\n\nIf you’re not ready to write while handling the event, and would prefer to write on your own schedule, you can set a flag variable and check it later to determine whether it’s is safe to write to the stream. The following example illustrates this technique. It handles the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event by just setting a private `canWrite` property to `true.`\n\nWhile handling stream events, also check whether `eventCode` is [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/errorOccurred]. This means that the stream has failed. When this happens, close the streams and abandon the upload.\n\nHandling StreamDelegate events\n\nOnce you’re handling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event, you can write to the stream whenever you know it’s ready to receive more data. You write to the stream by calling its [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream\/write(_:maxLength:)] method, providing a reference to the raw bytes to be written, and the maximum number of bytes to write.\n\nThe following example uses a timer to wait for the private `canWrite` property to become true. Once this is the case, the code creates a string representing the current date and converts it to raw bytes. The listing then calls [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream\/write(_:maxLength:)] to send these bytes to the output stream. Because this output stream is bound to an input stream, the upload task can then automatically read these bytes from the input stream and send them to the destination URL.\n\nCreating a timer to write to the output stream when the stream has space available\n\nOnce you write to the output stream, you can’t write again until your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] receives a new [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event. This example enforces this constraint by setting the class’ `canWrite` property to `false`. It will be reset to `true` when a new [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event is received by the output stream’s delegate, as shown earlier in `Handling StreamDelegate events`.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/uploading-streams-of-data\ncrawled: 2025-12-02T15:47:15Z\n---\n\n# Uploading streams of data\n\n**Article**\n\nSend a stream of data to a server.\n\n## Overview\n\nStreaming media apps and long-running apps that send continual updates use an ongoing stream to upload data, rather than sending a single block of data or a flat file. You can configure an instance of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionUploadTask] (a subclass of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask]) to work with a stream that you provide, and then fill this stream with data indefinitely.\n\nThe task gets the stream by calling your session’s delegate, so you need to create a session and set your own code as its delegate.\n\n### Create a URL session\n\nBegin by creating a URLSession and providing it with a delegate. The following example creates a URL session with the default [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionConfiguration] and sets `self` as the delegate. You’ll implement [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate] later, in [doc:\/\/com.apple.foundation\/documentation\/Foundation\/uploading-streams-of-data#Provide-the-stream-to-the-upload-task].\n\nCreating a URLSession with a delegate\n\n```swift\nlazy var session: URLSession = URLSession(configuration: .default,\n                                          delegate: self,\n                                          delegateQueue: .main)\n\n```\n\n### Create a streaming upload task\n\nCreate the upload task with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/uploadTask(withStreamedRequest:)]. This takes a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLRequest] specifying the URL you want to upload to, along with other parameters. You start the task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()]. The following example shows how to create and start an upload task, connecting to a server on the local machine (`127.0.0.1`) listening on port `12345`.\n\nCreating an upload task\n\n```swift\nlet url = URL(string: \"http:\/\/127.0.0.1:12345\")!\nvar request = URLRequest(url: url,\n                         cachePolicy: .reloadIgnoringLocalCacheData,\n                         timeoutInterval: 10)\nrequest.httpMethod = \"POST\"\nlet uploadTask = session.uploadTask(withStreamedRequest: request)\nuploadTask.resume()\n```\n\n### Use a bound pair of streams to provide an input stream\n\nYou provide the streaming data to the upload task as an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/InputStream]. The task reads data from this stream and uploads it to the destination.\n\nA good way to provide data to the input stream is to use a *bound pair* of streams. The bound pair contains an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream] that you write data to. Thanks to the binding of the streams, the data you write to the output stream is made available to the input stream, which the task can then read from. [\/documentation\/foundation\/url_loading_system\/uploading_streams_of_data#3037791] shows this arrangement.\n\n\n\nThe following example shows a structure called `Streams` that consists of an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/InputStream] and an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream]. The listing creates a property of this type, called `boundStreams`, by calling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/getBoundStreams(withBufferSize:inputStream:outputStream:)] method of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream] class, passing in in-out references for the input and output streams.\n\nCreating a bound pair of input and output streams\n\n```swift\nstruct Streams {\n    let input: InputStream\n    let output: OutputStream\n}\nlazy var boundStreams: Streams = {\n    var inputOrNil: InputStream? = nil\n    var outputOrNil: OutputStream? = nil\n    Stream.getBoundStreams(withBufferSize: 4096,\n                           inputStream: &inputOrNil,\n                           outputStream: &outputOrNil)\n    guard let input = inputOrNil, let output = outputOrNil else {\n        fatalError(\"On return of `getBoundStreams`, both `inputStream` and `outputStream` will contain non-nil streams.\")\n    }\n    \/\/ configure and open output stream\n    output.delegate = self\n    output.schedule(in: .current, forMode: .default)\n    output.open()\n    return Streams(input: input, output: output)\n}()\n\n```\n\nWhen you create the bound pair, make sure you specify a buffer size large enough to hold any data you write to the output stream, prior to the data being read from the input stream. The following example uses a 4096-byte buffer.\n\nThe listing also sets `self` as the output stream’s delegate. Declare that your class implements the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] protocol in order to receive events that indicate when the output stream is ready to receive new data. You’ll provide the implementation of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] later, in [doc:\/\/com.apple.foundation\/documentation\/Foundation\/uploading-streams-of-data#Write-data-to-the-stream-when-its-ready].\n\n\n\n### Provide the stream to the upload task\n\nYou provide the input stream to the upload task in your implementation of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:needNewBodyStream:)], which is called after you start the upload task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()]. The callback passes in a completion handler, which you call directly, passing in the `boundStreams.input` stream you created earlier. The following example shows an implementation of this method.\n\nProviding the input stream to the upload task in the delegate callback\n\n```swift\nfunc urlSession(_ session: URLSession, task: URLSessionTask,\n                needNewBodyStream completionHandler: @escaping (InputStream?) -> Void) {\n    completionHandler(boundStreams.input)\n}\n```\n\n### Write data to the stream when it’s ready\n\nWrite data to an output stream only when the stream is ready for it. You get notified of the stream’s readiness in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate\/stream(_:handle:)]. When this callback sends [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] as its `eventCode` parameter, the stream is ready to accept more data.\n\nIf you’re not ready to write while handling the event, and would prefer to write on your own schedule, you can set a flag variable and check it later to determine whether it’s is safe to write to the stream. The following example illustrates this technique. It handles the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event by just setting a private `canWrite` property to `true.`\n\nWhile handling stream events, also check whether `eventCode` is [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/errorOccurred]. This means that the stream has failed. When this happens, close the streams and abandon the upload.\n\nHandling StreamDelegate events\n\n```swift\nfunc stream(_ aStream: Stream, handle eventCode: Stream.Event) {\n    guard aStream == boundStreams.output else {\n        return\n    }\n    if eventCode.contains(.hasSpaceAvailable) {\n        canWrite = true\n    }\n    if eventCode.contains(.errorOccurred) {\n        \/\/ Close the streams and alert the user that the upload failed.\n    }\n}\n\n```\n\nOnce you’re handling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event, you can write to the stream whenever you know it’s ready to receive more data. You write to the stream by calling its [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream\/write(_:maxLength:)] method, providing a reference to the raw bytes to be written, and the maximum number of bytes to write.\n\nThe following example uses a timer to wait for the private `canWrite` property to become true. Once this is the case, the code creates a string representing the current date and converts it to raw bytes. The listing then calls [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OutputStream\/write(_:maxLength:)] to send these bytes to the output stream. Because this output stream is bound to an input stream, the upload task can then automatically read these bytes from the input stream and send them to the destination URL.\n\nCreating a timer to write to the output stream when the stream has space available\n\n```swift\ntimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) {\n    [weak self] timer in\n    guard let self = self else { return }\n\n    if self.canWrite {\n        let message = \"*** \\(Date())\\r\\n\"\n        guard let messageData = message.data(using: .utf8) else { return }\n        let messageCount = messageData.count\n        let bytesWritten: Int = messageData.withUnsafeBytes() { (buffer: UnsafePointer<UInt8>) in\n            self.canWrite = false\n            return self.boundStreams.output.write(buffer, maxLength: messageCount)\n        }\n        if bytesWritten < messageCount {\n            \/\/ Handle writing less data than expected.\n        }\n    }\n}\n\n```\n\n\n\nOnce you write to the output stream, you can’t write again until your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/StreamDelegate] receives a new [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event. This example enforces this constraint by setting the class’ `canWrite` property to `false`. It will be reset to `true` when a new [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Stream\/Event\/hasSpaceAvailable] event is received by the output stream’s delegate, as shown earlier in `Handling StreamDelegate events`.\n\n## Uploading\n\n- **Building a resumable upload server with SwiftNIO**: Support HTTP resumable upload protocol in SwiftNIO by translating resumable uploads to regular uploads.\n- **Uploading data to a website**: Post data from your app to servers.\n- **Pausing and resuming uploads**: Pause and resume an upload without starting over, even when the connection is interrupted.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Support HTTP resumable upload protocol in SwiftNIO by translating resumable uploads to regular uploads.",
          "name" : "Building a resumable upload server with SwiftNIO",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/building-a-resumable-upload-server-with-swiftnio"
        },
        {
          "description" : "Post data from your app to servers.",
          "name" : "Uploading data to a website",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/uploading-data-to-a-website"
        },
        {
          "description" : "Pause and resume an upload without starting over, even when the connection is interrupted.",
          "name" : "Pausing and resuming uploads",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/pausing-and-resuming-uploads"
        }
      ],
      "title" : "Uploading"
    }
  ],
  "source" : "appleJSON",
  "title" : "Uploading streams of data",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/uploading-streams-of-data"
}