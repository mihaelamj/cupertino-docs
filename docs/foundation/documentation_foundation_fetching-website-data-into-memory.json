{
  "abstract" : "Receive data directly into memory by creating a data task from a URL session.",
  "codeExamples" : [
    {
      "code" : "func startLoad() {\n    let url = URL(string: \"https:\/\/www.example.com\/\")!\n    let task = URLSession.shared.dataTask(with: url) { data, response, error in\n        if let error = error {\n            self.handleClientError(error)\n            return\n        }\n        guard let httpResponse = response as? HTTPURLResponse,\n            (200...299).contains(httpResponse.statusCode) else {\n            self.handleServerError(response)\n            return\n        }\n        if let mimeType = httpResponse.mimeType, mimeType == \"text\/html\",\n            let data = data,\n            let string = String(data: data, encoding: .utf8) {\n            DispatchQueue.main.async {\n                self.webView.loadHTMLString(string, baseURL: url)\n            }\n        }\n    }\n    task.resume()\n}\n",
      "language" : "swift"
    },
    {
      "code" : "private lazy var session: URLSession = {\n    let configuration = URLSessionConfiguration.default\n    configuration.waitsForConnectivity = true\n    return URLSession(configuration: configuration,\n                      delegate: self, delegateQueue: nil)\n}()",
      "language" : "swift"
    },
    {
      "code" : "var receivedData: Data?\n\nfunc startLoad() {\n    loadButton.isEnabled = false\n    let url = URL(string: \"https:\/\/www.example.com\/\")!\n    receivedData = Data()\n    let task = session.dataTask(with: url)\n    task.resume()\n}\n\n\/\/ delegate methods\n\nfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse,\n                completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {\n    guard let response = response as? HTTPURLResponse,\n        (200...299).contains(response.statusCode),\n        let mimeType = response.mimeType,\n        mimeType == \"text\/html\" else {\n        completionHandler(.cancel)\n        return\n    }\n    completionHandler(.allow)\n}\n\nfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {\n    self.receivedData?.append(data)\n}\n\nfunc urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n    DispatchQueue.main.async {\n        self.loadButton.isEnabled = true\n        if let error = error {\n            handleClientError(error)\n        } else if let receivedData = self.receivedData,\n            let string = String(data: receivedData, encoding: .utf8) {\n            self.webView.loadHTMLString(string, baseURL: task.currentRequest?.url)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "dda01bc61c4302637f449bb1e0c10436b36f25ebc67992e7816a8bcf8d7f2f32",
  "crawledAt" : "2025-12-02T06:11:14Z",
  "id" : "B8CC2BF2-FEE0-4F7D-8E67-654D9D4728BB",
  "kind" : "article",
  "module" : "Foundation",
  "overview" : "## Overview\n\nFor small interactions with remote servers, you can use the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataTask] class to receive response data into memory (as opposed to using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadTask] class, which stores the data directly to the file system). A data task is ideal for uses like calling a web service endpoint.\n\nYou use a URL session instance to create the task. If your needs are fairly simple, you can use the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/shared] instance of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] class. If you want to interact with the transfer through delegate callbacks, you’ll need to create a session instead of using the shared instance. You use a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionConfiguration] instance when creating a session, also passing in a class that implements [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate] or one of its subprotocols. Sessions can be reused to create multiple tasks, so for each unique configuration you need, create a session and store it as a property.\n\nOnce you have a session, you create a data task with one of the `dataTask()` methods. Tasks are created in a suspended state, and can be started by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()].\n\n### Receive results with a completion handler\n\nThe simplest way to fetch data is to create a data task that uses a completion handler. With this arrangement, the task delivers the server’s response, data, and possibly errors to a completion handler block that you provide.  shows the relationship between a session and a task, and how results are delivered to the completion handler.\n\n\n\nTo create a data task that uses a completion handler, call the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/dataTask(with:)-10dy7] method of `URLSession`. Your completion handler needs to do three things:\n\nThe following example shows a `startLoad()` method for fetching a URL’s contents. It starts by using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] class’s shared instance to create a data task that delivers its results to a completion handler. After checking for local and server errors, this handler converts the data to a string, and uses it to populate a `WKWebView` outlet. Of course, your app might have other uses for fetched data, like parsing it into a data model.\n\nCreating a completion handler to receive data-loading results\n\n### Receive transfer details and results with a delegate\n\nFor a greater level of access to the task’s activity as it proceeds, when creating the data task, you can set a delegate on the session, rather than providing a completion handler.  shows this arrangement.\n\n\n\nWith this approach, portions of the data are provided to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate\/urlSession(_:dataTask:didReceive:)] method of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate] as they arrive, until the transfer finishes or fails with an error. The delegate also receives other kinds of events as the transfer proceeds.\n\nYou need to create your own `URLSession` instance when using the delegate approach, rather than using the `URLSession` class’s simple `shared` instance. Creating a new session allows you to set your own class as the session’s delegate, as shown in the following example.\n\nDeclare that your class implements one or more of the delegate protocols ([doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate]). Then create the URL session instance with the initializer [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/init(configuration:delegate:delegateQueue:)]. You can customize the configuration instance used with this initializer. For example, it’s a good idea to set [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionConfiguration\/waitsForConnectivity] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. That way, the session waits for suitable connectivity, rather than failing immediately if the required connectivity is unavailable.\n\nCreating a URLSession that uses a delegate\n\nThe following example shows a `startLoad()` method that uses this session to start a data task, and uses delegate callbacks to handle received data and errors.  This listing implements three delegate callbacks:\n\nUsing a delegate with a URL session data task\n\nThe various delegate protocols offer methods beyond those shown in the above code, for handling authentication challenges, following redirects, and other special cases. `Using a URL Session`, in the `URLSession` discussion, describes the various callbacks that may occur during a transfer.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/fetching-website-data-into-memory\ncrawled: 2025-12-02T06:11:14Z\n---\n\n# Fetching website data into memory\n\n**Article**\n\nReceive data directly into memory by creating a data task from a URL session.\n\n## Overview\n\nFor small interactions with remote servers, you can use the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataTask] class to receive response data into memory (as opposed to using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadTask] class, which stores the data directly to the file system). A data task is ideal for uses like calling a web service endpoint.\n\nYou use a URL session instance to create the task. If your needs are fairly simple, you can use the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/shared] instance of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] class. If you want to interact with the transfer through delegate callbacks, you’ll need to create a session instead of using the shared instance. You use a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionConfiguration] instance when creating a session, also passing in a class that implements [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate] or one of its subprotocols. Sessions can be reused to create multiple tasks, so for each unique configuration you need, create a session and store it as a property.\n\n\n\nOnce you have a session, you create a data task with one of the `dataTask()` methods. Tasks are created in a suspended state, and can be started by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()].\n\n### Receive results with a completion handler\n\nThe simplest way to fetch data is to create a data task that uses a completion handler. With this arrangement, the task delivers the server’s response, data, and possibly errors to a completion handler block that you provide.  shows the relationship between a session and a task, and how results are delivered to the completion handler.\n\n\n\nTo create a data task that uses a completion handler, call the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/dataTask(with:)-10dy7] method of `URLSession`. Your completion handler needs to do three things:\n\n1. Verify that the `error` parameter is `nil`. If not, a transport error has occurred; handle the error and exit.\n2. Check the `response` parameter to verify that the status code indicates success and that the MIME type is an expected value. If not, handle the server error and exit.\n3. Use the `data` instance as needed.\n\nThe following example shows a `startLoad()` method for fetching a URL’s contents. It starts by using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] class’s shared instance to create a data task that delivers its results to a completion handler. After checking for local and server errors, this handler converts the data to a string, and uses it to populate a `WKWebView` outlet. Of course, your app might have other uses for fetched data, like parsing it into a data model.\n\nCreating a completion handler to receive data-loading results\n\n```swift\nfunc startLoad() {\n    let url = URL(string: \"https:\/\/www.example.com\/\")!\n    let task = URLSession.shared.dataTask(with: url) { data, response, error in\n        if let error = error {\n            self.handleClientError(error)\n            return\n        }\n        guard let httpResponse = response as? HTTPURLResponse,\n            (200...299).contains(httpResponse.statusCode) else {\n            self.handleServerError(response)\n            return\n        }\n        if let mimeType = httpResponse.mimeType, mimeType == \"text\/html\",\n            let data = data,\n            let string = String(data: data, encoding: .utf8) {\n            DispatchQueue.main.async {\n                self.webView.loadHTMLString(string, baseURL: url)\n            }\n        }\n    }\n    task.resume()\n}\n\n```\n\n\n\n### Receive transfer details and results with a delegate\n\nFor a greater level of access to the task’s activity as it proceeds, when creating the data task, you can set a delegate on the session, rather than providing a completion handler.  shows this arrangement.\n\n\n\nWith this approach, portions of the data are provided to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate\/urlSession(_:dataTask:didReceive:)] method of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate] as they arrive, until the transfer finishes or fails with an error. The delegate also receives other kinds of events as the transfer proceeds.\n\nYou need to create your own `URLSession` instance when using the delegate approach, rather than using the `URLSession` class’s simple `shared` instance. Creating a new session allows you to set your own class as the session’s delegate, as shown in the following example.\n\nDeclare that your class implements one or more of the delegate protocols ([doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate]). Then create the URL session instance with the initializer [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/init(configuration:delegate:delegateQueue:)]. You can customize the configuration instance used with this initializer. For example, it’s a good idea to set [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionConfiguration\/waitsForConnectivity] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. That way, the session waits for suitable connectivity, rather than failing immediately if the required connectivity is unavailable.\n\nCreating a URLSession that uses a delegate\n\n```swift\nprivate lazy var session: URLSession = {\n    let configuration = URLSessionConfiguration.default\n    configuration.waitsForConnectivity = true\n    return URLSession(configuration: configuration,\n                      delegate: self, delegateQueue: nil)\n}()\n```\n\nThe following example shows a `startLoad()` method that uses this session to start a data task, and uses delegate callbacks to handle received data and errors.  This listing implements three delegate callbacks:\n\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate\/urlSession(_:dataTask:didReceive:completionHandler:)] verifies that the response has a succesful HTTP status code, and that the MIME type is `text\/html` or `text\/plain`. If either of these is not the case, the task is canceled; otherwise, it’s allowed to proceed.\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDataDelegate\/urlSession(_:dataTask:didReceive:)] takes each `Data` instance received by the task and appends it to a buffer called `receivedData`.\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:didCompleteWithError:)] first looks to see if a transport-level error has occurred. If there is no error, it attempts to convert the `receivedData` buffer to a string and set it as the contents of `webView`.\n\nUsing a delegate with a URL session data task\n\n```swift\nvar receivedData: Data?\n\nfunc startLoad() {\n    loadButton.isEnabled = false\n    let url = URL(string: \"https:\/\/www.example.com\/\")!\n    receivedData = Data()\n    let task = session.dataTask(with: url)\n    task.resume()\n}\n\n\/\/ delegate methods\n\nfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse,\n                completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {\n    guard let response = response as? HTTPURLResponse,\n        (200...299).contains(response.statusCode),\n        let mimeType = response.mimeType,\n        mimeType == \"text\/html\" else {\n        completionHandler(.cancel)\n        return\n    }\n    completionHandler(.allow)\n}\n\nfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {\n    self.receivedData?.append(data)\n}\n\nfunc urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n    DispatchQueue.main.async {\n        self.loadButton.isEnabled = true\n        if let error = error {\n            handleClientError(error)\n        } else if let receivedData = self.receivedData,\n            let string = String(data: receivedData, encoding: .utf8) {\n            self.webView.loadHTMLString(string, baseURL: task.currentRequest?.url)\n        }\n    }\n}\n```\n\nThe various delegate protocols offer methods beyond those shown in the above code, for handling authentication challenges, following redirects, and other special cases. `Using a URL Session`, in the `URLSession` discussion, describes the various callbacks that may occur during a transfer.\n\n## Essentials\n\n- **Analyzing HTTP traffic with Instruments**: Measure HTTP-based network performance and usage of your apps.\n- **URLSession**: An object that coordinates a group of related, network data transfer tasks.\n- **URLSessionTask**: A task, like downloading a specific resource, performed in a URL session.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Measure HTTP-based network performance and usage of your apps.",
          "name" : "Analyzing HTTP traffic with Instruments",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/analyzing-http-traffic-with-instruments"
        },
        {
          "description" : "An object that coordinates a group of related, network data transfer tasks.",
          "name" : "URLSession",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLSession"
        },
        {
          "description" : "A task, like downloading a specific resource, performed in a URL session.",
          "name" : "URLSessionTask",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLSessionTask"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Fetching website data into memory",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/fetching-website-data-into-memory"
}