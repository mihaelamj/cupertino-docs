{
  "abstract" : "Create, send, and receive user activities directly.",
  "codeExamples" : [
    {
      "code" : "<key>NSUserActivityTypes<\/key>\n<array>\n    <string>com.example.myapp.create-shape<\/string>\n    <string>com.example.myapp.edit-shape<\/string>\n    <string>com.example.myapp.edit-document-properties<\/string>\n<\/array>",
      "language" : "other"
    },
    {
      "code" : "let activity = NSUserActivity(activityType: \"com.example.myapp.create-shape\")\nactivity?.isEligibleForHandoff = true\nactivity?.requiredUserInfoKeys = [\"shape-type\"]\nactivity.title = NSLocalizedString(\"Creating shape\", comment: \"Creating shape activity\")",
      "language" : "swift"
    },
    {
      "code" : "override func updateUserActivityState(_ activity: NSUserActivity) {\n    if activity.activityType == \"com.example.myapp.create-shape\" {\n        let updateDict:  [AnyHashable : Any] = [\n            \"shape-type\" : currentShapeType(),\n            \"activity-version\" : 1\n        ]\n        activity.addUserInfoEntries(from: updateDict)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func application(_ application: UIApplication, continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n    guard let topNav = application.keyWindow?.rootViewController as? UINavigationController,\n        let shapesVC = topNav.viewControllers.first as? MyShapesViewController else {\n            return false\n    }\n    restorationHandler([shapesVC])\n    return true\n}\n",
      "language" : "swift"
    },
    {
      "code" : "override func restoreUserActivityState(_ userActivity: NSUserActivity) {    super.restoreUserActivityState(userActivity)\n    guard userActivity.activityType == \"com.example.myapp.create-shape\",\n        let type = userActivity.userInfo?[\"shape-type\"] as? String,\n        let version = userActivity.userInfo?[\"activity-version\"] as? Int,\n        version >= 1 else {\n            return\n    }\n    \n    createShape(type: type)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "8b6176e22ea27913f9c710e8f867f8b586dcb40ea3754d358e478d3787ee43b7",
  "crawledAt" : "2025-12-02T15:47:17Z",
  "id" : "B14E7EE9-19EF-4FB8-ACF7-4B2393525B02",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nUse Handoff to transfer activities the user starts on one iOS, watchOS, or macOS device to a different device. For example, a vector graphics app on macOS can send details about an in-progress editing action to the user’s iPhone so that editing can continue there.\n\n\n\nYou implement Handoff in your app by:\n\n### Declare Handoff Activities in Your App’s Info.plist\n\nStart by identifying which activities make sense to use with Handoff. Choose activities that represent what the user is doing at some point in time, like creating a shape or editing document properties. Choose a universally-unique identifier string for each of your activities, using a reverse-DNS pattern, like `com.example.app.activity-name`.\n\nYou use your app’s `Info.plist` file to declare that your app can receive an activity from Handoff. Create a new top-level entry in this file with the key [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Reference\/InfoPlistKeyReference\/Articles\/CocoaKeys.html#\/\/apple_ref\/doc\/uid\/TP40009251-SW28] and with the type `Array`. Each member of the array should be a `String` whose value is one of your activity identifiers. The following example shows the `Info.plist` XML source of a `NSUserActivityTypes` entry that declares three activities that the app can continue:\n\nYour app doesn’t need to send and receive the same set of identifiers on all platforms. For example, you might have a large macOS app and a suite of smaller iOS apps. In this case, the macOS app might handle all your activities, while each iOS app would handle a subset of these activities. Also, while watchOS can send user activities, it cannot receive them, so watchOS apps don’t declare an `NSUserActivityTypes` property.\n\nYour app can have many activities, each of which has different details to send to Handoff. Identify what information you’ll need to recreate the activity on the receiving device. Be careful to only include the transient details of the user activity, and not any information that the app needs to store permanently. For example, if a user is working on a document, the activity should indicate the document—and possibly what part of the document—the user is editing. Don’t include the document itself as part of the activity, since the user could launch your app without Handoff, such as by tapping or clicking its app icon. Instead, use techniques like iCloud Drive to share documents between the user’s devices.\n\n### Create User Activity Objects\n\nAt runtime, create instances of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity] for each of your app’s activities. Use the same identifier strings that you used in the `Info.plist` to indicate which activities your app can continue.\n\nThe [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity] class contains a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary that you use to recreate the activity on other devices. The activity type also has a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/requiredUserInfoKeys] property that you populate with the minimal set of dictionary keys to make the activity restorable. The activity also contains a user-readable [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/title] property that you should set. If the activity also supports search, the system displays this title in the search results.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder] (macOS) and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder] (iOS) classes define a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/userActivity] property. Since [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSViewController] and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController] are subclasses of these responder types, you can set this property to represent the activity the controller is managing. Your app can share a single activity across multiple view controllers. Conversely, if a single view controller supports multiple activities, you can reassign the view controller’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/userActivity] to different [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity] instances as needed.\n\n### Update Activities While the User is Active\n\nAs your user interacts with your app, update the user activity to save the state of their interaction. If you have set the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/userActivity] property of a responder, the system automatically calls its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/updateUserActivityState(_:)] (iOS) or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder\/updateUserActivityState(_:)] (macOS) method. Override this method to write new values to the activity’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary.\n\nThe keys and values you use in [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] must be of the types [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSArray], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSData], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSDate], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSDictionary], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSNull], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSNumber], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSSet], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSString], or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSURL] (or their Swift-bridged equivalents). Create a dictionary with any data needed to recreate the activity on the other device, then call [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/addUserInfoEntries(from:)] to update the activity. It’s also a good idea to provide a key-value pair that versions the dictionary itself. That way, you can change the activity’s dictionary representation later and be able to detect incompatible versions.\n\nTransfer as small a payload in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] as possible, keeping the total size under 3KB. If you must transfer more data than this, use continuation streams to connect the two devices directly (see Working with continuation streams).\n\n### Receive User Activities in the Application Delegate\n\nWhen the user launches your app from Handoff on another device, the app receives callbacks to methods in its application delegate. You implement these methods to accept the activity and restore its state in your app.\n\nAfter launching your app, Handoff calls the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:willContinueUserActivityWithType:)] method of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate\/application(_:willContinueUserActivityWithType:)] method of [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate] (macOS). Implement this method by updating your UI to indicate to your user that it is receiving the activity from the other device. If Handoff fails for some reason, the system calls [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFailToContinueUserActivityWithType:error:)] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate\/application(_:didFailToContinueUserActivityWithType:error:)] (macOS).\n\nHandoff provides the activity to your app in the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:continue:restorationHandler:)] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate\/application(_:continue:restorationHandler:)] (macOS) delegate method. Implement the method by creating an array of view controllers that need to update for the activity, and provide this array to the completion handler. Return [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] if your implementation successfully handled the activity, or [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] if it did not. The following example shows an iOS app delegate finding its top view controller and providing it to the completion handler.\n\n### Continue the Activity in Your App\n\nEach view controller provided to the completion handler in the previous step receives a call to its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/restoreUserActivityState(_:)] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSUserActivityRestoring\/restoreUserActivityState(_:)] (macOS) method. Use this method to update the view controller’s state to match the state of the originating device. If you have several activity types, use the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/activityType] to determine which activity you are handling. Then, get the values from the activity’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary to update the view controller’s state.\n\nFor URLs transferred in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary, you must first call [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/startAccessingSecurityScopedResource()] and it must return [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] before you can access the URL. Call [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/stopAccessingSecurityScopedResource()] when you finish using the URL. Also be aware that the system modifies `file:` URLs pointing to iCloud documents, so that they point to the same document on the receiving device.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/implementing-handoff-in-your-app\ncrawled: 2025-12-02T15:47:17Z\n---\n\n# Implementing Handoff in Your App\n\n**Article**\n\nCreate, send, and receive user activities directly.\n\n## Overview\n\nUse Handoff to transfer activities the user starts on one iOS, watchOS, or macOS device to a different device. For example, a vector graphics app on macOS can send details about an in-progress editing action to the user’s iPhone so that editing can continue there.\n\n\n\nYou implement Handoff in your app by:\n\n- Representing user activities as instances of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity].\n- Updating the activity instances as the user performs actions in your app.\n- Receiving activities from Handoff in your app on other devices.\n\n\n\n### Declare Handoff Activities in Your App’s Info.plist\n\nStart by identifying which activities make sense to use with Handoff. Choose activities that represent what the user is doing at some point in time, like creating a shape or editing document properties. Choose a universally-unique identifier string for each of your activities, using a reverse-DNS pattern, like `com.example.app.activity-name`.\n\nYou use your app’s `Info.plist` file to declare that your app can receive an activity from Handoff. Create a new top-level entry in this file with the key [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Reference\/InfoPlistKeyReference\/Articles\/CocoaKeys.html#\/\/apple_ref\/doc\/uid\/TP40009251-SW28] and with the type `Array`. Each member of the array should be a `String` whose value is one of your activity identifiers. The following example shows the `Info.plist` XML source of a `NSUserActivityTypes` entry that declares three activities that the app can continue:\n\n```other\n<key>NSUserActivityTypes<\/key>\n<array>\n    <string>com.example.myapp.create-shape<\/string>\n    <string>com.example.myapp.edit-shape<\/string>\n    <string>com.example.myapp.edit-document-properties<\/string>\n<\/array>\n```\n\nYour app doesn’t need to send and receive the same set of identifiers on all platforms. For example, you might have a large macOS app and a suite of smaller iOS apps. In this case, the macOS app might handle all your activities, while each iOS app would handle a subset of these activities. Also, while watchOS can send user activities, it cannot receive them, so watchOS apps don’t declare an `NSUserActivityTypes` property.\n\nYour app can have many activities, each of which has different details to send to Handoff. Identify what information you’ll need to recreate the activity on the receiving device. Be careful to only include the transient details of the user activity, and not any information that the app needs to store permanently. For example, if a user is working on a document, the activity should indicate the document—and possibly what part of the document—the user is editing. Don’t include the document itself as part of the activity, since the user could launch your app without Handoff, such as by tapping or clicking its app icon. Instead, use techniques like iCloud Drive to share documents between the user’s devices.\n\n### Create User Activity Objects\n\nAt runtime, create instances of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity] for each of your app’s activities. Use the same identifier strings that you used in the `Info.plist` to indicate which activities your app can continue.\n\nThe [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity] class contains a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary that you use to recreate the activity on other devices. The activity type also has a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/requiredUserInfoKeys] property that you populate with the minimal set of dictionary keys to make the activity restorable. The activity also contains a user-readable [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/title] property that you should set. If the activity also supports search, the system displays this title in the search results.\n\n```swift\nlet activity = NSUserActivity(activityType: \"com.example.myapp.create-shape\")\nactivity?.isEligibleForHandoff = true\nactivity?.requiredUserInfoKeys = [\"shape-type\"]\nactivity.title = NSLocalizedString(\"Creating shape\", comment: \"Creating shape activity\")\n```\n\nThe [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder] (macOS) and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder] (iOS) classes define a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/userActivity] property. Since [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSViewController] and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController] are subclasses of these responder types, you can set this property to represent the activity the controller is managing. Your app can share a single activity across multiple view controllers. Conversely, if a single view controller supports multiple activities, you can reassign the view controller’s [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/userActivity] to different [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity] instances as needed.\n\n### Update Activities While the User is Active\n\nAs your user interacts with your app, update the user activity to save the state of their interaction. If you have set the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/userActivity] property of a responder, the system automatically calls its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/updateUserActivityState(_:)] (iOS) or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSResponder\/updateUserActivityState(_:)] (macOS) method. Override this method to write new values to the activity’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary.\n\nThe keys and values you use in [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] must be of the types [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSArray], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSData], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSDate], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSDictionary], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSNull], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSNumber], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSSet], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSString], or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSURL] (or their Swift-bridged equivalents). Create a dictionary with any data needed to recreate the activity on the other device, then call [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/addUserInfoEntries(from:)] to update the activity. It’s also a good idea to provide a key-value pair that versions the dictionary itself. That way, you can change the activity’s dictionary representation later and be able to detect incompatible versions.\n\n```swift\noverride func updateUserActivityState(_ activity: NSUserActivity) {\n    if activity.activityType == \"com.example.myapp.create-shape\" {\n        let updateDict:  [AnyHashable : Any] = [\n            \"shape-type\" : currentShapeType(),\n            \"activity-version\" : 1\n        ]\n        activity.addUserInfoEntries(from: updateDict)\n    }\n}\n```\n\nTransfer as small a payload in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] as possible, keeping the total size under 3KB. If you must transfer more data than this, use continuation streams to connect the two devices directly (see Working with continuation streams).\n\n### Receive User Activities in the Application Delegate\n\nWhen the user launches your app from Handoff on another device, the app receives callbacks to methods in its application delegate. You implement these methods to accept the activity and restore its state in your app.\n\nAfter launching your app, Handoff calls the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:willContinueUserActivityWithType:)] method of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate\/application(_:willContinueUserActivityWithType:)] method of [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate] (macOS). Implement this method by updating your UI to indicate to your user that it is receiving the activity from the other device. If Handoff fails for some reason, the system calls [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:didFailToContinueUserActivityWithType:error:)] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate\/application(_:didFailToContinueUserActivityWithType:error:)] (macOS).\n\n\n\nHandoff provides the activity to your app in the [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationDelegate\/application(_:continue:restorationHandler:)] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationDelegate\/application(_:continue:restorationHandler:)] (macOS) delegate method. Implement the method by creating an array of view controllers that need to update for the activity, and provide this array to the completion handler. Return [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] if your implementation successfully handled the activity, or [doc:\/\/com.apple.documentation\/documentation\/Swift\/false] if it did not. The following example shows an iOS app delegate finding its top view controller and providing it to the completion handler.\n\n```swift\nfunc application(_ application: UIApplication, continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n    guard let topNav = application.keyWindow?.rootViewController as? UINavigationController,\n        let shapesVC = topNav.viewControllers.first as? MyShapesViewController else {\n            return false\n    }\n    restorationHandler([shapesVC])\n    return true\n}\n\n```\n\n### Continue the Activity in Your App\n\nEach view controller provided to the completion handler in the previous step receives a call to its [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIResponder\/restoreUserActivityState(_:)] (iOS), or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSUserActivityRestoring\/restoreUserActivityState(_:)] (macOS) method. Use this method to update the view controller’s state to match the state of the originating device. If you have several activity types, use the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/activityType] to determine which activity you are handling. Then, get the values from the activity’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary to update the view controller’s state.\n\n```swift\noverride func restoreUserActivityState(_ userActivity: NSUserActivity) {    super.restoreUserActivityState(userActivity)\n    guard userActivity.activityType == \"com.example.myapp.create-shape\",\n        let type = userActivity.userInfo?[\"shape-type\"] as? String,\n        let version = userActivity.userInfo?[\"activity-version\"] as? Int,\n        version >= 1 else {\n            return\n    }\n    \n    createShape(type: type)\n}\n```\n\nFor URLs transferred in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSUserActivity\/userInfo] dictionary, you must first call [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/startAccessingSecurityScopedResource()] and it must return [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] before you can access the URL. Call [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/stopAccessingSecurityScopedResource()] when you finish using the URL. Also be aware that the system modifies `file:` URLs pointing to iCloud documents, so that they point to the same document on the receiving device.\n\n## Activity Sharing\n\n- **Continuing User Activities with Handoff**: Define and manage which of your app’s activities can be continued between devices.\n- **NSUserActivity**: A representation of the state of your app at a moment in time.\n- **NSUserActivityDelegate**: The interface through which a user activity instance notifies its delegate of updates.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Define and manage which of your app’s activities can be continued between devices.",
          "name" : "Continuing User Activities with Handoff",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/continuing-user-activities-with-handoff"
        },
        {
          "description" : "A representation of the state of your app at a moment in time.",
          "name" : "NSUserActivity",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSUserActivity"
        },
        {
          "description" : "The interface through which a user activity instance notifies its delegate of updates.",
          "name" : "NSUserActivityDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSUserActivityDelegate"
        }
      ],
      "title" : "Activity Sharing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Implementing Handoff in Your App",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/implementing-handoff-in-your-app"
}