{
  "abstract" : "Make your data types encodable and decodable for compatibility with external representations such as JSON.",
  "codeExamples" : [
    {
      "code" : "struct Landmark {\n    var name: String\n    var foundingYear: Int\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n    \n    \/\/ Landmark now supports the Codable methods init(from:) and encode(to:), \n    \/\/ even though they aren't written as part of its declaration.\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Coordinate: Codable {\n    var latitude: Double\n    var longitude: Double\n}\n\nstruct Landmark: Codable {\n    \/\/ Double, String, and Int all conform to Codable.\n    var name: String\n    var foundingYear: Int\n    \n    \/\/ Adding a property of a custom Codable type maintains overall Codable conformance.\n    var location: Coordinate\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n    var location: Coordinate\n    \n    \/\/ Landmark is still codable after adding these properties.\n    var vantagePoints: [Coordinate]\n    var metadata: [String: String]\n    var website: URL?\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Landmark: Encodable {\n    var name: String\n    var foundingYear: Int\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Landmark: Decodable {\n    var name: String\n    var foundingYear: Int\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n    var location: Coordinate\n    var vantagePoints: [Coordinate]\n    \n    enum CodingKeys: String, CodingKey {\n        case name = \"title\"\n        case foundingYear = \"founding_date\"\n        \n        case location\n        case vantagePoints\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Coordinate {\n    var latitude: Double\n    var longitude: Double\n    var elevation: Double\n\n    enum CodingKeys: String, CodingKey {\n        case latitude\n        case longitude\n        case additionalInfo\n    }\n    \n    enum AdditionalInfoKeys: String, CodingKey {\n        case elevation\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Coordinate: Decodable {\n    init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: CodingKeys.self)\n        latitude = try values.decode(Double.self, forKey: .latitude)\n        longitude = try values.decode(Double.self, forKey: .longitude)\n        \n        let additionalInfo = try values.nestedContainer(keyedBy: AdditionalInfoKeys.self, forKey: .additionalInfo)\n        elevation = try additionalInfo.decode(Double.self, forKey: .elevation)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension Coordinate: Encodable {\n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        try container.encode(latitude, forKey: .latitude)\n        try container.encode(longitude, forKey: .longitude)\n        \n        var additionalInfo = container.nestedContainer(keyedBy: AdditionalInfoKeys.self, forKey: .additionalInfo)\n        try additionalInfo.encode(elevation, forKey: .elevation)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "c5bf7bd4aa7021f69dd6cc66349d12936e54a6f2b7c0eeaf3b56947d0033b310",
  "crawledAt" : "2025-12-03T07:36:43Z",
  "id" : "E8FA71A3-B5B2-47B2-9927-CE4D2EECAFAD",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nMany programming tasks involve sending data over a network connection, saving data to disk, or submitting data to APIs and services. These tasks often require data to be encoded and decoded to and from an intermediate format while the data is being transferred.\n\nThe Swift standard library defines a standardized approach to data encoding and decoding. You adopt this approach by implementing the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols on your custom types. Adopting these protocols lets implementations of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encoder] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decoder] protocols take your data and encode or decode it to and from an external representation such as JSON or property list. To support both encoding and decoding, declare conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable], which combines the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols. This process is known as making your types *codable*.\n\n### Encode and Decode Automatically\n\nThe simplest way to make a type codable is to declare its properties using types that are already [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable]. These types include standard library types like [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Double]; and Foundation types like [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Date], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Data], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL]. Any type whose properties are codable automatically conforms to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] just by declaring that conformance.\n\nConsider a `Landmark` structure that stores the name and founding year of a landmark:\n\nAdding [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] to the inheritance list for `Landmark` triggers an automatic conformance that satisfies all of the protocol requirements from [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable]:\n\nAdopting [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] on your own types enables you to serialize them to and from any of the built-in data formats, and any formats provided by custom encoders and decoders. For example, the `Landmark` structure can be encoded using both the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/PropertyListEncoder] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/JSONEncoder] classes, even though `Landmark` itself contains no code to specifically handle property lists or JSON.\n\nThe same principle applies to custom types made up of other custom types that are codable. As long as all of its properties are [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable], any custom type can also be [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable].\n\nThe example below shows how automatic [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] conformance applies when a `location` property is added to the `Landmark` structure:\n\nBuilt-in types such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array],  [doc:\/\/com.apple.documentation\/documentation\/Swift\/Dictionary], and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Optional] also conform to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] whenever they contain codable types. You can add an array of `Coordinate` instances to `Landmark`, and the entire structure will still satisfy [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable].\n\nThe example below shows how automatic conformance still applies when adding multiple properties using built-in codable types within `Landmark`:\n\n### Encode or Decode Exclusively\n\nIn some cases, you may not need [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable]’s support for bidirectional encoding and decoding.  For example, some apps only need to make calls to a remote network API and do not need to decode a response containing the same type. Declare conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] if you only need to support the encoding of data. Conversely, declare conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] if you only need to read data of a given type.\n\nThe examples below show alternative declarations of the `Landmark` structure that only encode or decode data:\n\n### Choose Properties to Encode and Decode Using Coding Keys\n\nCodable types can declare a special nested enumeration named `CodingKeys` that conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/CodingKey] protocol. When this enumeration is present, its cases serve as the authoritative list of properties that must be included when instances of a codable type are encoded or decoded. The names of the enumeration cases should match the names you’ve given to the corresponding properties in your type.\n\nOmit properties from the `CodingKeys` enumeration if they won’t be present when decoding instances, or if certain properties shouldn’t be included in an encoded representation. A property omitted from `CodingKeys` needs a default value in order for its containing type to receive automatic conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] or [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable].\n\nIf the keys used in your serialized data format don’t match the property names from your data type, provide alternative keys by specifying [doc:\/\/com.apple.documentation\/documentation\/Swift\/String] as the raw-value type for the `CodingKeys` enumeration.  The string you use as a raw value for each enumeration case is the key name used during encoding and decoding. The association between the case name and its raw value lets you name your data structures according to the Swift [https:\/\/swift.org\/documentation\/api-design-guidelines\/] rather than having to match the names, punctuation, and capitalization of the serialization format you’re modeling.\n\nThe example below uses alternative keys for the `name` and `foundingYear` properties of the `Landmark` structure when encoding and decoding:\n\n### Encode and Decode Manually\n\nIf the structure of your Swift type differs from the structure of its encoded form, you can provide a custom implementation of [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] to define your own encoding and decoding logic.\n\nIn the examples below, the `Coordinate` structure is expanded to support an `elevation` property that’s nested inside of an `additionalInfo` container:\n\nBecause the encoded form of the `Coordinate` type contains a second level of nested information, the type’s adoption of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols uses two enumerations that each list the complete set of coding keys used on a particular level.\n\nIn the example below, the `Coordinate` structure is extended to conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocol by implementing its required initializer, [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable\/init(from:)]:\n\nThe initializer populates a `Coordinate` instance by using methods on the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decoder] instance it receives as a parameter. The `Coordinate` instance’s two properties are initialized using the keyed container APIs provided by the Swift standard library.\n\nThe example below shows how the `Coordinate` structure can be extended to conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] protocol by implementing its required method, [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable\/encode(to:)]:\n\nThis implementation of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable\/encode(to:)] method reverses the decoding operation from the previous example.\n\nFor more information about the container types used when customizing the encoding and decoding process, see [doc:\/\/com.apple.documentation\/documentation\/Swift\/KeyedEncodingContainerProtocol] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnkeyedEncodingContainer].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/encoding-and-decoding-custom-types\ncrawled: 2025-12-03T07:36:43Z\n---\n\n# Encoding and Decoding Custom Types\n\n**Article**\n\nMake your data types encodable and decodable for compatibility with external representations such as JSON.\n\n## Overview\n\nMany programming tasks involve sending data over a network connection, saving data to disk, or submitting data to APIs and services. These tasks often require data to be encoded and decoded to and from an intermediate format while the data is being transferred.\n\nThe Swift standard library defines a standardized approach to data encoding and decoding. You adopt this approach by implementing the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols on your custom types. Adopting these protocols lets implementations of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encoder] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decoder] protocols take your data and encode or decode it to and from an external representation such as JSON or property list. To support both encoding and decoding, declare conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable], which combines the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols. This process is known as making your types *codable*.\n\n### Encode and Decode Automatically\n\nThe simplest way to make a type codable is to declare its properties using types that are already [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable]. These types include standard library types like [doc:\/\/com.apple.documentation\/documentation\/Swift\/String], [doc:\/\/com.apple.documentation\/documentation\/Swift\/Int], and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Double]; and Foundation types like [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Date], [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Data], and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL]. Any type whose properties are codable automatically conforms to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] just by declaring that conformance.\n\nConsider a `Landmark` structure that stores the name and founding year of a landmark:\n\n```swift\nstruct Landmark {\n    var name: String\n    var foundingYear: Int\n}\n```\n\nAdding [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] to the inheritance list for `Landmark` triggers an automatic conformance that satisfies all of the protocol requirements from [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable]:\n\n```swift\nstruct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n    \n    \/\/ Landmark now supports the Codable methods init(from:) and encode(to:), \n    \/\/ even though they aren't written as part of its declaration.\n}\n```\n\nAdopting [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] on your own types enables you to serialize them to and from any of the built-in data formats, and any formats provided by custom encoders and decoders. For example, the `Landmark` structure can be encoded using both the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/PropertyListEncoder] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/JSONEncoder] classes, even though `Landmark` itself contains no code to specifically handle property lists or JSON.\n\nThe same principle applies to custom types made up of other custom types that are codable. As long as all of its properties are [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable], any custom type can also be [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable].\n\nThe example below shows how automatic [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] conformance applies when a `location` property is added to the `Landmark` structure:\n\n```swift\nstruct Coordinate: Codable {\n    var latitude: Double\n    var longitude: Double\n}\n\nstruct Landmark: Codable {\n    \/\/ Double, String, and Int all conform to Codable.\n    var name: String\n    var foundingYear: Int\n    \n    \/\/ Adding a property of a custom Codable type maintains overall Codable conformance.\n    var location: Coordinate\n}\n```\n\nBuilt-in types such as [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array],  [doc:\/\/com.apple.documentation\/documentation\/Swift\/Dictionary], and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Optional] also conform to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] whenever they contain codable types. You can add an array of `Coordinate` instances to `Landmark`, and the entire structure will still satisfy [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable].\n\nThe example below shows how automatic conformance still applies when adding multiple properties using built-in codable types within `Landmark`:\n\n```swift\nstruct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n    var location: Coordinate\n    \n    \/\/ Landmark is still codable after adding these properties.\n    var vantagePoints: [Coordinate]\n    var metadata: [String: String]\n    var website: URL?\n}\n```\n\n### Encode or Decode Exclusively\n\nIn some cases, you may not need [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable]’s support for bidirectional encoding and decoding.  For example, some apps only need to make calls to a remote network API and do not need to decode a response containing the same type. Declare conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] if you only need to support the encoding of data. Conversely, declare conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] if you only need to read data of a given type.\n\nThe examples below show alternative declarations of the `Landmark` structure that only encode or decode data:\n\n```swift\nstruct Landmark: Encodable {\n    var name: String\n    var foundingYear: Int\n}\n```\n\n```swift\nstruct Landmark: Decodable {\n    var name: String\n    var foundingYear: Int\n}\n```\n\n### Choose Properties to Encode and Decode Using Coding Keys\n\nCodable types can declare a special nested enumeration named `CodingKeys` that conforms to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/CodingKey] protocol. When this enumeration is present, its cases serve as the authoritative list of properties that must be included when instances of a codable type are encoded or decoded. The names of the enumeration cases should match the names you’ve given to the corresponding properties in your type.\n\nOmit properties from the `CodingKeys` enumeration if they won’t be present when decoding instances, or if certain properties shouldn’t be included in an encoded representation. A property omitted from `CodingKeys` needs a default value in order for its containing type to receive automatic conformance to [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] or [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable].\n\nIf the keys used in your serialized data format don’t match the property names from your data type, provide alternative keys by specifying [doc:\/\/com.apple.documentation\/documentation\/Swift\/String] as the raw-value type for the `CodingKeys` enumeration.  The string you use as a raw value for each enumeration case is the key name used during encoding and decoding. The association between the case name and its raw value lets you name your data structures according to the Swift [https:\/\/swift.org\/documentation\/api-design-guidelines\/] rather than having to match the names, punctuation, and capitalization of the serialization format you’re modeling.\n\nThe example below uses alternative keys for the `name` and `foundingYear` properties of the `Landmark` structure when encoding and decoding:\n\n```swift\nstruct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n    var location: Coordinate\n    var vantagePoints: [Coordinate]\n    \n    enum CodingKeys: String, CodingKey {\n        case name = \"title\"\n        case foundingYear = \"founding_date\"\n        \n        case location\n        case vantagePoints\n    }\n}\n```\n\n### Encode and Decode Manually\n\nIf the structure of your Swift type differs from the structure of its encoded form, you can provide a custom implementation of [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] to define your own encoding and decoding logic.\n\nIn the examples below, the `Coordinate` structure is expanded to support an `elevation` property that’s nested inside of an `additionalInfo` container:\n\n```swift\nstruct Coordinate {\n    var latitude: Double\n    var longitude: Double\n    var elevation: Double\n\n    enum CodingKeys: String, CodingKey {\n        case latitude\n        case longitude\n        case additionalInfo\n    }\n    \n    enum AdditionalInfoKeys: String, CodingKey {\n        case elevation\n    }\n}\n```\n\nBecause the encoded form of the `Coordinate` type contains a second level of nested information, the type’s adoption of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocols uses two enumerations that each list the complete set of coding keys used on a particular level.\n\nIn the example below, the `Coordinate` structure is extended to conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocol by implementing its required initializer, [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable\/init(from:)]:\n\n```swift\nextension Coordinate: Decodable {\n    init(from decoder: Decoder) throws {\n        let values = try decoder.container(keyedBy: CodingKeys.self)\n        latitude = try values.decode(Double.self, forKey: .latitude)\n        longitude = try values.decode(Double.self, forKey: .longitude)\n        \n        let additionalInfo = try values.nestedContainer(keyedBy: AdditionalInfoKeys.self, forKey: .additionalInfo)\n        elevation = try additionalInfo.decode(Double.self, forKey: .elevation)\n    }\n}\n```\n\nThe initializer populates a `Coordinate` instance by using methods on the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decoder] instance it receives as a parameter. The `Coordinate` instance’s two properties are initialized using the keyed container APIs provided by the Swift standard library.\n\nThe example below shows how the `Coordinate` structure can be extended to conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable] protocol by implementing its required method, [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable\/encode(to:)]:\n\n```swift\nextension Coordinate: Encodable {\n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        try container.encode(latitude, forKey: .latitude)\n        try container.encode(longitude, forKey: .longitude)\n        \n        var additionalInfo = container.nestedContainer(keyedBy: AdditionalInfoKeys.self, forKey: .additionalInfo)\n        try additionalInfo.encode(elevation, forKey: .elevation)\n    }\n}\n```\n\nThis implementation of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Encodable\/encode(to:)] method reverses the decoding operation from the previous example.\n\nFor more information about the container types used when customizing the encoding and decoding process, see [doc:\/\/com.apple.documentation\/documentation\/Swift\/KeyedEncodingContainerProtocol] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/UnkeyedEncodingContainer].\n\n## Adopting Codability\n\n- **Codable**: A type that can convert itself into and out of an external representation.\n- **NSCoding**: A protocol that enables an object to be encoded and decoded for archiving and distribution.\n- **NSSecureCoding**: A protocol that enables encoding and decoding in a manner that is robust against object substitution attacks.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that can convert itself into and out of an external representation.",
          "name" : "Codable",
          "url" : "https:\/\/developer.apple.com\/documentation\/Swift\/Codable"
        },
        {
          "description" : "A protocol that enables an object to be encoded and decoded for archiving and distribution.",
          "name" : "NSCoding",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSCoding"
        },
        {
          "description" : "A protocol that enables encoding and decoding in a manner that is robust against object substitution attacks.",
          "name" : "NSSecureCoding",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSSecureCoding"
        }
      ],
      "title" : "Adopting Codability"
    }
  ],
  "source" : "appleJSON",
  "title" : "Encoding and Decoding Custom Types",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/encoding-and-decoding-custom-types"
}