{
  "abstract" : "Respond appropriately when a server demands authentication for a URL request.",
  "codeExamples" : [
    {
      "code" : "let authMethod = challenge.protectionSpace.authenticationMethod\nguard authMethod == NSURLAuthenticationMethodHTTPBasic else {\n    completionHandler(.performDefaultHandling, nil)\n    return\n}",
      "language" : "swift"
    },
    {
      "code" : "func credentialsFromUI() -> URLCredential? {\n    guard let username = usernameField.text, !username.isEmpty,\n        let password = passwordField.text, !password.isEmpty else {\n            return nil\n    }\n    return URLCredential(user: username, password: password,\n                         persistence: .forSession)\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let credential = credentialOrNil else {\n    completionHandler(.cancelAuthenticationChallenge, nil)\n    return\n}\ncompletionHandler(.useCredential, credential)",
      "language" : "swift"
    }
  ],
  "contentHash" : "7fb52977fd16be3f127d9d49bdb039118628a6e574e965261644c98ec2f76db0",
  "crawledAt" : "2025-12-04T16:24:37Z",
  "id" : "FCE7E72C-71D0-422A-A246-0F2628576C99",
  "kind" : "collection",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nWhen your app makes a request with a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask], the server may respond with one or more demands for credentials before continuing. The session task attempts to handle this for you. If it can’t, it calls your session’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/delegate] to handle the challenges.\n\nImplement the delegate methods described in this article to answer challenges issued by a server that your app connects to. If you don’t implement a delegate, your request may be denied by the server, and you receive a response with HTTP status code `401` (Forbidden) instead of the data you expect.\n\n### Determine the appropriate delegate method\n\nImplement one or both delegate authentication methods, depending on the nature of the challenge(s) you receive.\n\nAs a simple example, consider what happens when you request an `http` URL protected by HTTP Basic authentication, as defined in [https:\/\/tools.ietf.org\/html\/rfc7617]. Because this is a task-specific challenge, you handle this by implementing [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:didReceive:completionHandler:)].\n\n[\/documentation\/foundation\/url_loading_system\/handling_an_authentication_challenge#2948287] outlines a strategy for responding to the HTTP Basic challenge.\n\n\n\nThe following sections implement this strategy.\n\n### Determine the type of authentication challenge\n\nWhen you receive an authentication challenge, use your delegate method to determine the type of challenge. The delegate method receives a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge] instance that describes the challenge being issued. This instance contains a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/protectionSpace] property whose [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/authenticationMethod] property indicates the kind of challenge being issued (such as a request for a username and password, or a client certificate). You use this value to determine whether you can handle the challenge.\n\nYou respond to the challenge by directly invoking the completion handler passed in to the challenge, passing an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition] indicating your response to the challenge. You use the disposition argument to provide a credential, cancel the request, or allow the default handling to proceed, whichever is appropriate.\n\nThe following example tests the authentication method to see if it is the expected type, HTTP Basic. If the `authenticationMethod` property indicates some other kind of challenge, it calls the completion handler with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/performDefaultHandling] disposition. Telling the task to use its default handling may satisfy the challenge; otherwise, the task will move on to the next challenge in the response and call this delegate again. This process continues until the task reaches the HTTP Basic challenge that you expect to handle.\n\nChecking the authentication method of an authentication challenge\n\n### Create a credential instance\n\nTo successfully answer the challenge, you need to submit a credential appropriate to type of challenge you have received. For HTTP Basic and HTTP Digest challenges, you provide a username and password. The following example shows a helper method that attempts to create a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential] instance from user-interface fields, if they are filled in.\n\nCreating a URLCredential from user interface values\n\nIn this example, the returned [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential] has [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential\/Persistence-swift.enum\/forSession] persistence, so it’s only stored by the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] instance that created the task. You would need to supply new [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential] instances for tasks created by other session instances, and on future runs of the app.\n\n### Call the completion handler\n\nOnce you’ve tried to create a credential instance, you must call the completion handler to answer the challenge.\n\nThe following example shows both these options.\n\nInvoking the authentication challenge completion Handler\n\nIf you supply a credential that is accepted by the server, the task begins uploading or downloading data.\n\n### Handle failures gracefully\n\nIf the credential is refused, the system calls your delegate method again. When this happens, the callback provides your rejected credential as the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/proposedCredential] property of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge] parameter. The challenge instance also includes a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/previousFailureCount] property, which indicates how many times the credential has been rejected. You can use these properties to determine what to do next. For example, if the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/previousFailureCount] is greater than zero, you could use the user string of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/proposedCredential] to populate a user\/password reentry UI.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/handling-an-authentication-challenge\ncrawled: 2025-12-04T16:24:37Z\n---\n\n# Handling an authentication challenge\n\nRespond appropriately when a server demands authentication for a URL request.\n\n## Overview\n\nWhen your app makes a request with a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask], the server may respond with one or more demands for credentials before continuing. The session task attempts to handle this for you. If it can’t, it calls your session’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/delegate] to handle the challenges.\n\nImplement the delegate methods described in this article to answer challenges issued by a server that your app connects to. If you don’t implement a delegate, your request may be denied by the server, and you receive a response with HTTP status code `401` (Forbidden) instead of the data you expect.\n\n### Determine the appropriate delegate method\n\nImplement one or both delegate authentication methods, depending on the nature of the challenge(s) you receive.\n\n- Implement the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate\/urlSession(_:didReceive:completionHandler:)] method of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate] to handle session-wide challenges. These are challenges like Transport Layer Security (TLS) validation. Once you’ve successfully handled this kind of challenge, your action remains in effect for all tasks created from that [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession].\n- Implement the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:didReceive:completionHandler:)] method of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate] to handle task-specific challenges. These are challenges like demands for username\/password authentication. Each task created from a given session may issue its own challenges.\n\n\n\nAs a simple example, consider what happens when you request an `http` URL protected by HTTP Basic authentication, as defined in [https:\/\/tools.ietf.org\/html\/rfc7617]. Because this is a task-specific challenge, you handle this by implementing [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:didReceive:completionHandler:)].\n\n\n\n[\/documentation\/foundation\/url_loading_system\/handling_an_authentication_challenge#2948287] outlines a strategy for responding to the HTTP Basic challenge.\n\n\n\nThe following sections implement this strategy.\n\n### Determine the type of authentication challenge\n\nWhen you receive an authentication challenge, use your delegate method to determine the type of challenge. The delegate method receives a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge] instance that describes the challenge being issued. This instance contains a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/protectionSpace] property whose [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/authenticationMethod] property indicates the kind of challenge being issued (such as a request for a username and password, or a client certificate). You use this value to determine whether you can handle the challenge.\n\nYou respond to the challenge by directly invoking the completion handler passed in to the challenge, passing an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition] indicating your response to the challenge. You use the disposition argument to provide a credential, cancel the request, or allow the default handling to proceed, whichever is appropriate.\n\nThe following example tests the authentication method to see if it is the expected type, HTTP Basic. If the `authenticationMethod` property indicates some other kind of challenge, it calls the completion handler with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/performDefaultHandling] disposition. Telling the task to use its default handling may satisfy the challenge; otherwise, the task will move on to the next challenge in the response and call this delegate again. This process continues until the task reaches the HTTP Basic challenge that you expect to handle.\n\nChecking the authentication method of an authentication challenge\n\n```swift\nlet authMethod = challenge.protectionSpace.authenticationMethod\nguard authMethod == NSURLAuthenticationMethodHTTPBasic else {\n    completionHandler(.performDefaultHandling, nil)\n    return\n}\n```\n\n### Create a credential instance\n\nTo successfully answer the challenge, you need to submit a credential appropriate to type of challenge you have received. For HTTP Basic and HTTP Digest challenges, you provide a username and password. The following example shows a helper method that attempts to create a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential] instance from user-interface fields, if they are filled in.\n\nCreating a URLCredential from user interface values\n\n```swift\nfunc credentialsFromUI() -> URLCredential? {\n    guard let username = usernameField.text, !username.isEmpty,\n        let password = passwordField.text, !password.isEmpty else {\n            return nil\n    }\n    return URLCredential(user: username, password: password,\n                         persistence: .forSession)\n}\n```\n\nIn this example, the returned [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential] has [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential\/Persistence-swift.enum\/forSession] persistence, so it’s only stored by the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] instance that created the task. You would need to supply new [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential] instances for tasks created by other session instances, and on future runs of the app.\n\n### Call the completion handler\n\nOnce you’ve tried to create a credential instance, you must call the completion handler to answer the challenge.\n\n- If you can’t create a credential, or if the user explicitly canceled, call the completion handler and pass the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/cancelAuthenticationChallenge] disposition.\n- If you can create a credential instance, use the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/useCredential] disposition to pass it to the completion handler.\n\nThe following example shows both these options.\n\nInvoking the authentication challenge completion Handler\n\n```swift\nguard let credential = credentialOrNil else {\n    completionHandler(.cancelAuthenticationChallenge, nil)\n    return\n}\ncompletionHandler(.useCredential, credential)\n```\n\nIf you supply a credential that is accepted by the server, the task begins uploading or downloading data.\n\n\n\n### Handle failures gracefully\n\nIf the credential is refused, the system calls your delegate method again. When this happens, the callback provides your rejected credential as the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/proposedCredential] property of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge] parameter. The challenge instance also includes a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/previousFailureCount] property, which indicates how many times the credential has been rejected. You can use these properties to determine what to do next. For example, if the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/previousFailureCount] is greater than zero, you could use the user string of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/proposedCredential] to populate a user\/password reentry UI.\n\n## Creating URL credentials\n\n- **Performing manual server trust authentication**: Evaluate the server’s security credentials in your app.\n\n## Authentication and credentials\n\n- **URLAuthenticationChallenge**: A challenge from a server requiring authentication from the client.\n- **URLCredential**: `A`n authentication credential consisting of information specific to the type of credential and the type of persistent storage to use, if any.\n- **URLCredentialStorage**: The manager of a shared credentials cache.\n- **URLProtectionSpace**: A server or an area on a server, commonly referred to as a realm, that requires authentication.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Evaluate the server’s security credentials in your app.",
          "name" : "Performing manual server trust authentication",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/performing-manual-server-trust-authentication"
        }
      ],
      "title" : "Creating URL credentials"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A challenge from a server requiring authentication from the client.",
          "name" : "URLAuthenticationChallenge",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLAuthenticationChallenge"
        },
        {
          "description" : "`A`n authentication credential consisting of information specific to the type of credential and the type of persistent storage to use, if any.",
          "name" : "URLCredential",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLCredential"
        },
        {
          "description" : "The manager of a shared credentials cache.",
          "name" : "URLCredentialStorage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLCredentialStorage"
        },
        {
          "description" : "A server or an area on a server, commonly referred to as a realm, that requires authentication.",
          "name" : "URLProtectionSpace",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLProtectionSpace"
        }
      ],
      "title" : "Authentication and credentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Handling an authentication challenge",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/handling-an-authentication-challenge"
}