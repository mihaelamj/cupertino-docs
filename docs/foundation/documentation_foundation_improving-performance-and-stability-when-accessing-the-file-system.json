{
  "abstract" : "Prevent data loss and app crashes by interacting with the file system in a coordinated, asynchronous manner and by avoiding unnecessary disk I\/O.",
  "codeExamples" : [
    {
      "code" : "\/\/ Create a background queue for the system to use\n\/\/ when invoking each file coordinator's accessor \n\/\/ closure.\nlet queue = OperationQueue()\nqueue.underlyingQueue = .global(qos: .utility)\n\n\/\/ Iterate over the file URLs.\nfor url in fileURLs {\n    \/\/ Create a file coordinator and specify the appropriate\n    \/\/ file access intent and queue.\n    let intent = NSFileAccessIntent.readingIntent(with: url)\n    let coordinator = NSFileCoordinator()\n    coordinator.coordinate(with: [intent],\n                           queue: queue) { error in\n        if let error {\n            \/\/ If there's an error, handle it here.\n        } else {\n            \/\/ Otherwise, process the file.\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "2edcf5e994a89757d4043a32b3647885f8575b1b6b5804901e8148ebe9bdcd2b",
  "crawledAt" : "2025-12-04T17:55:27Z",
  "id" : "73F9EA2C-AAB8-4EBD-894A-05B80C692E0D",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nA device’s file system is a shared resource available to all running processes. If multiple processes (or multiple threads in the same process) attempt to act on the same file simultaneously, data corruption or loss may occur, and your app may even crash.\n\nTo establish safe and efficient file access, avoid performing immediate file I\/O on the app’s main thread. Use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] to choreograph file access, opt for the I\/O-free variants of file-related APIs, and implement the prefetching mechanisms of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionView] and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView] to efficiently prepare file-related data for display.\n\n### Coordinate file access to reduce hangs\n\nA *blocking call* is a task that may temporarily suspend the calling thread’s execution, such as checking whether a file or directory exists. When a blocking call originates from the app’s main thread, the suspended execution manifests as user interface hangs and high scroll hitch rates, negatively impacting the user experience. The duration of this specific blocking call is often indeterminate if the related files are external to the device, such as those in iCloud Drive or other file providers, or on a mounted USB drive or SMB server.\n\nAdopt [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFilePresenter] to coordinate safe file access across different threads and processes. A *file coordinator* notifies interested file presenters whenever a file they care about is due to change. Each presenter then has an opportunity to perform any work necessary to safeguard their integrity. The file coordinator waits on all file presenters to respond before it executes the requested actions on the file. By specifying a background operation queue, the coordinator works asynchronously and is therefore safe to call from the main thread. For more information, see [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator\/coordinate(with:queue:byAccessor:)].\n\n### Prefetch displayable file data to maintain a low scroll hitch rate\n\nIf your app displays list- or collection-based layouts of any size, adopt [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionView] — and the corresponding data source and prefetching protocols — to provide a smooth scrolling experience. An object that implements the data source protocol provides the view with items to display, whereas an object that implements the prefetching protocol is responsible for preparing and caching the data for those items.\n\nThe system provides a few milliseconds to prepare content for a cell, and exceeding that may cause elevated scroll hitch rates or dropped frames. Dropped frames in particular indicate that the system is performing file I\/O in data source protocol methods such as [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionViewDataSource\/collectionView(_:cellForItemAt:)], which the system invokes on the main thread. To avoid such issues, delegate all file I\/O to [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] and invoke the necessary reads (and writes) in one or more of the methods that the view’s prefetching protocol defines.\n\nFor more information, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionViewDataSourcePrefetching], [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableViewDataSourcePrefetching], and the sample code [doc:\/\/com.apple.documentation\/documentation\/UIKit\/prefetching-collection-view-data].\n\n### Request access to multiple files in parallel to boost efficiency\n\nWhen taking some action on a list of files, an app may iterate over that list and process each file sequentially, such as in a `for` or `while` loop. However, accessing files that are external to the device, such as those in iCloud Drive, may result in expensive, blocking network requests as the system must download the files before it can make them available for your app to use.\n\nTo minimize the impact, don’t perform any file I\/O in the loop. Instead, use each iteration of the loop to create an instance of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] and specify a background queue for the system to use when it invokes that coordinator’s `accessor` closure. By adopting this approach, you enable the system to download any remote files in a concurrent, nonblocking way, as the following example shows:\n\n### Provide directory hints for file URLs to avoid wasteful I\/O\n\nMany convenience methods make it possible to create URLs that represent files and directories in the file system, local or otherwise. If you know that the destination of such a URL is a directory, use the method variants that require the `isDirectory` parameter and specify [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] as the value. If you use a more succinct method that omits the parameter, the system performs a potentially blocking call to the file system to determine if the URL’s destination is a file or a directory.\n\nIf you are using Swift and your app targets iOS 16 and later (or macOS 13 and later), use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/init(filePath:directoryHint:relativeTo:)] to create file URLs — and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/appending(path:directoryHint:)] to modify existing URLs — and specify a value other than `inferFromPath` for the `directoryHint` parameter. For earlier versions, opt for the nonblocking variants of the methods in the following table.\n\nThe following table lists the blocking and nonblocking method variants.\n\nAdditionally, APIs that traverse directory hierarchies may also block, and the duration of the block depends entirely on the depth of the traversed hierarchy. For that reason, only call these APIs from a background thread.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/improving-performance-and-stability-when-accessing-the-file-system\ncrawled: 2025-12-04T17:55:27Z\n---\n\n# Improving performance and stability when accessing the file system\n\n**Article**\n\nPrevent data loss and app crashes by interacting with the file system in a coordinated, asynchronous manner and by avoiding unnecessary disk I\/O.\n\n## Overview\n\nA device’s file system is a shared resource available to all running processes. If multiple processes (or multiple threads in the same process) attempt to act on the same file simultaneously, data corruption or loss may occur, and your app may even crash.\n\nTo establish safe and efficient file access, avoid performing immediate file I\/O on the app’s main thread. Use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] to choreograph file access, opt for the I\/O-free variants of file-related APIs, and implement the prefetching mechanisms of [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionView] and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView] to efficiently prepare file-related data for display.\n\n### Coordinate file access to reduce hangs\n\nA *blocking call* is a task that may temporarily suspend the calling thread’s execution, such as checking whether a file or directory exists. When a blocking call originates from the app’s main thread, the suspended execution manifests as user interface hangs and high scroll hitch rates, negatively impacting the user experience. The duration of this specific blocking call is often indeterminate if the related files are external to the device, such as those in iCloud Drive or other file providers, or on a mounted USB drive or SMB server.\n\nAdopt [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFilePresenter] to coordinate safe file access across different threads and processes. A *file coordinator* notifies interested file presenters whenever a file they care about is due to change. Each presenter then has an opportunity to perform any work necessary to safeguard their integrity. The file coordinator waits on all file presenters to respond before it executes the requested actions on the file. By specifying a background operation queue, the coordinator works asynchronously and is therefore safe to call from the main thread. For more information, see [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator\/coordinate(with:queue:byAccessor:)].\n\n### Prefetch displayable file data to maintain a low scroll hitch rate\n\nIf your app displays list- or collection-based layouts of any size, adopt [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableView] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionView] — and the corresponding data source and prefetching protocols — to provide a smooth scrolling experience. An object that implements the data source protocol provides the view with items to display, whereas an object that implements the prefetching protocol is responsible for preparing and caching the data for those items.\n\nThe system provides a few milliseconds to prepare content for a cell, and exceeding that may cause elevated scroll hitch rates or dropped frames. Dropped frames in particular indicate that the system is performing file I\/O in data source protocol methods such as [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionViewDataSource\/collectionView(_:cellForItemAt:)], which the system invokes on the main thread. To avoid such issues, delegate all file I\/O to [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] and invoke the necessary reads (and writes) in one or more of the methods that the view’s prefetching protocol defines.\n\nFor more information, see [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UICollectionViewDataSourcePrefetching], [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UITableViewDataSourcePrefetching], and the sample code [doc:\/\/com.apple.documentation\/documentation\/UIKit\/prefetching-collection-view-data].\n\n### Request access to multiple files in parallel to boost efficiency\n\nWhen taking some action on a list of files, an app may iterate over that list and process each file sequentially, such as in a `for` or `while` loop. However, accessing files that are external to the device, such as those in iCloud Drive, may result in expensive, blocking network requests as the system must download the files before it can make them available for your app to use.\n\nTo minimize the impact, don’t perform any file I\/O in the loop. Instead, use each iteration of the loop to create an instance of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSFileCoordinator] and specify a background queue for the system to use when it invokes that coordinator’s `accessor` closure. By adopting this approach, you enable the system to download any remote files in a concurrent, nonblocking way, as the following example shows:\n\n```swift\n\/\/ Create a background queue for the system to use\n\/\/ when invoking each file coordinator's accessor \n\/\/ closure.\nlet queue = OperationQueue()\nqueue.underlyingQueue = .global(qos: .utility)\n\n\/\/ Iterate over the file URLs.\nfor url in fileURLs {\n    \/\/ Create a file coordinator and specify the appropriate\n    \/\/ file access intent and queue.\n    let intent = NSFileAccessIntent.readingIntent(with: url)\n    let coordinator = NSFileCoordinator()\n    coordinator.coordinate(with: [intent],\n                           queue: queue) { error in\n        if let error {\n            \/\/ If there's an error, handle it here.\n        } else {\n            \/\/ Otherwise, process the file.\n        }\n    }\n}\n```\n\n### Provide directory hints for file URLs to avoid wasteful I\/O\n\nMany convenience methods make it possible to create URLs that represent files and directories in the file system, local or otherwise. If you know that the destination of such a URL is a directory, use the method variants that require the `isDirectory` parameter and specify [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] as the value. If you use a more succinct method that omits the parameter, the system performs a potentially blocking call to the file system to determine if the URL’s destination is a file or a directory.\n\nIf you are using Swift and your app targets iOS 16 and later (or macOS 13 and later), use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/init(filePath:directoryHint:relativeTo:)] to create file URLs — and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL\/appending(path:directoryHint:)] to modify existing URLs — and specify a value other than `inferFromPath` for the `directoryHint` parameter. For earlier versions, opt for the nonblocking variants of the methods in the following table.\n\nThe following table lists the blocking and nonblocking method variants.\n\n\n\nAdditionally, APIs that traverse directory hierarchies may also block, and the duration of the block depends entirely on the depth of the traversed hierarchy. For that reason, only call these APIs from a background thread.\n\n## File system operations\n\n- **Using the file system effectively**: Gain access to benefits like automatic backup or purging by using purpose-built directories provided by the system.\n- **FileManager**: A convenient interface to the contents of the file system, and the primary means of interacting with it.\n- **FileManagerDelegate**: The interface a file manager’s delegate uses to intervene during operations or if an error occurs.\n- **About Apple File System**: Use high-level APIs to get the most out of Apple File System.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Gain access to benefits like automatic backup or purging by using purpose-built directories provided by the system.",
          "name" : "Using the file system effectively",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/using-the-file-system-effectively"
        },
        {
          "description" : "A convenient interface to the contents of the file system, and the primary means of interacting with it.",
          "name" : "FileManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/FileManager"
        },
        {
          "description" : "The interface a file manager’s delegate uses to intervene during operations or if an error occurs.",
          "name" : "FileManagerDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/FileManagerDelegate"
        },
        {
          "description" : "Use high-level APIs to get the most out of Apple File System.",
          "name" : "About Apple File System",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/about-apple-file-system"
        }
      ],
      "title" : "File system operations"
    }
  ],
  "source" : "appleJSON",
  "title" : "Improving performance and stability when accessing the file system",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/improving-performance-and-stability-when-accessing-the-file-system"
}