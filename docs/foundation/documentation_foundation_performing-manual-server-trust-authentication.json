{
  "abstract" : "Evaluate the server’s security credentials in your app.",
  "codeExamples" : [
    {
      "code" : "let protectionSpace = challenge.protectionSpace\nguard protectionSpace.authenticationMethod ==\n    NSURLAuthenticationMethodServerTrust,\n    protectionSpace.host.contains(\"example.com\") else {\n        completionHandler(.performDefaultHandling, nil)\n        return\n}",
      "language" : "swift"
    },
    {
      "code" : "guard let serverTrust = protectionSpace.serverTrust else {\n    completionHandler(.performDefaultHandling, nil)\n    return\n}\nif checkValidity(of: serverTrust) {\n    let credential = URLCredential(trust: serverTrust)\n    completionHandler(.useCredential, credential)\n} else {\n    \/\/ Show a UI here warning the user the server credentials are\n    \/\/ invalid, and cancel the load.\n    completionHandler(.cancelAuthenticationChallenge, nil)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "c5597c9bd1550bdab2ef2dad1b1e9a60ebf772814abc976da97e8cae88f61b4c",
  "crawledAt" : "2025-12-06T03:18:30Z",
  "id" : "0AEBD5EE-7E8C-4FCA-80F5-6C326C7E0EFD",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nWhen you use a secure connection (such as `https`) with a URL request, your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate] receives an authentication challenge with an authentication type of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSURLAuthenticationMethodServerTrust]. Unlike other challenges where the server is asking your app to authenticate itself, this is an opportunity for you to authenticate the server’s credentials.\n\n### Determine when manual server trust evaluation is appropriate\n\nIn most cases, you should let the URL Loading System’s default handling evaluate the server trust. You get this behavior when you either don’t have a delegate or don’t handle authentication challenges. However, performing your own evaluation may be useful for scenarios like the following:\n\n[\/documentation\/foundation\/url_loading_system\/handling_an_authentication_challenge\/performing_manual_server_trust_authentication#2959678] illustrates how an app performs manual credential evaluation by providing a delegate method to handle the authentication challenge. This bypasses the default handling. Instead, the delegate directly compares the server certificate or its public key against a copy of the certificate or key (or a hash of either of these) stored in the app bundle itself. If the delegate decides the server credential is valid, it accepts the server trust and allows the connection to continue.\n\n\n\n### Handle server trust authentication challenges\n\nTo perform manual server trust authentication, implement the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate\/urlSession(_:didReceive:completionHandler:)]. When this method is called, the first things your implementation needs to do are to check that:\n\nThe following example shows how to test these conditions, given the `challenge` parameter passed to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate\/urlSession(_:didReceive:completionHandler:)] callback. It gets the challenge’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/protectionSpace] and uses it to perform the two checks listed above. First, it gets the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/authenticationMethod] from the protection space and checks that the type of authentication is [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSURLAuthenticationMethodServerTrust]. Then it makes sure the protection space’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/host] matches the expected name `example.com`. If either of these conditions are not met, it calls the `completionHandler` with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/performDefaultHandling] disposition to allow the system to handle the challenge.\n\nTesting the challenge type and host name of a server trust authentication challenge.\n\n### Evaluate the credential in the challenge\n\nTo access the server’s credential, get the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/serverTrust] property (an instance of the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecTrust] class) from the protection space. The following example shows how to access the server trust and accept or reject it. The listing starts by attempting to get the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/serverTrust] property from the protection space, and falls back to default handling if the property is `nil`. Next, it passes the server trust to a private helper method `checkValidity(of:)` that compares the certificate or public key in the server trust to known-good values stored in the app bundle.\n\nEvaluating credentials in a server trust instance.\n\nOnce the code determines the validity of the server trust, it takes one of two actions:\n\n### Create a long-term server authentication strategy\n\nIf you determine that you need to evaluate server trust manually in some or all cases,  plan for what your app will do if you need to change your server credentials. Keep the following guidelines in mind:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/performing-manual-server-trust-authentication\ncrawled: 2025-12-06T03:18:30Z\n---\n\n# Performing manual server trust authentication\n\n**Article**\n\nEvaluate the server’s security credentials in your app.\n\n## Overview\n\nWhen you use a secure connection (such as `https`) with a URL request, your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate] receives an authentication challenge with an authentication type of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSURLAuthenticationMethodServerTrust]. Unlike other challenges where the server is asking your app to authenticate itself, this is an opportunity for you to authenticate the server’s credentials.\n\n\n\n### Determine when manual server trust evaluation is appropriate\n\nIn most cases, you should let the URL Loading System’s default handling evaluate the server trust. You get this behavior when you either don’t have a delegate or don’t handle authentication challenges. However, performing your own evaluation may be useful for scenarios like the following:\n\n- You want to accept server credentials that would otherwise be rejected by the system. For example, your app makes a secure connection to a development server that uses a self-signed certificate, which would ordinarily not match anything in the system’s trust store.\n- You want to reject credentials that would otherwise be accepted by the system. For example, you want to “pin” your app to a set of specific keys or certificates under your control, rather than accept any valid credential.\n\n[\/documentation\/foundation\/url_loading_system\/handling_an_authentication_challenge\/performing_manual_server_trust_authentication#2959678] illustrates how an app performs manual credential evaluation by providing a delegate method to handle the authentication challenge. This bypasses the default handling. Instead, the delegate directly compares the server certificate or its public key against a copy of the certificate or key (or a hash of either of these) stored in the app bundle itself. If the delegate decides the server credential is valid, it accepts the server trust and allows the connection to continue.\n\n\n\n\n\n### Handle server trust authentication challenges\n\nTo perform manual server trust authentication, implement the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate\/urlSession(_:didReceive:completionHandler:)]. When this method is called, the first things your implementation needs to do are to check that:\n\n- The challenge type is server trust, and not some other kind of challenge.\n- The challenge’s host name matches the host that you want to perform manual credential evaluation for.\n\nThe following example shows how to test these conditions, given the `challenge` parameter passed to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDelegate\/urlSession(_:didReceive:completionHandler:)] callback. It gets the challenge’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLAuthenticationChallenge\/protectionSpace] and uses it to perform the two checks listed above. First, it gets the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/authenticationMethod] from the protection space and checks that the type of authentication is [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSURLAuthenticationMethodServerTrust]. Then it makes sure the protection space’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/host] matches the expected name `example.com`. If either of these conditions are not met, it calls the `completionHandler` with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/performDefaultHandling] disposition to allow the system to handle the challenge.\n\nTesting the challenge type and host name of a server trust authentication challenge.\n\n```swift\nlet protectionSpace = challenge.protectionSpace\nguard protectionSpace.authenticationMethod ==\n    NSURLAuthenticationMethodServerTrust,\n    protectionSpace.host.contains(\"example.com\") else {\n        completionHandler(.performDefaultHandling, nil)\n        return\n}\n```\n\n### Evaluate the credential in the challenge\n\nTo access the server’s credential, get the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/serverTrust] property (an instance of the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecTrust] class) from the protection space. The following example shows how to access the server trust and accept or reject it. The listing starts by attempting to get the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLProtectionSpace\/serverTrust] property from the protection space, and falls back to default handling if the property is `nil`. Next, it passes the server trust to a private helper method `checkValidity(of:)` that compares the certificate or public key in the server trust to known-good values stored in the app bundle.\n\nEvaluating credentials in a server trust instance.\n\n```swift\nguard let serverTrust = protectionSpace.serverTrust else {\n    completionHandler(.performDefaultHandling, nil)\n    return\n}\nif checkValidity(of: serverTrust) {\n    let credential = URLCredential(trust: serverTrust)\n    completionHandler(.useCredential, credential)\n} else {\n    \/\/ Show a UI here warning the user the server credentials are\n    \/\/ invalid, and cancel the load.\n    completionHandler(.cancelAuthenticationChallenge, nil)\n}\n```\n\nOnce the code determines the validity of the server trust, it takes one of two actions:\n\n- If the server trust’s credential is valid, create a new [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLCredential] instance from the server trust. Then call the `completionHandler` with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/useCredential] disposition, passing in the newly-created credential. This tells the system to accept the server’s credentials.\n- If the challenge’s credential is invalid, call the `completionHandler` with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/AuthChallengeDisposition\/cancelAuthenticationChallenge] disposition. This tells the system to reject the server’s credentials.\n\n\n\n### Create a long-term server authentication strategy\n\nIf you determine that you need to evaluate server trust manually in some or all cases,  plan for what your app will do if you need to change your server credentials. Keep the following guidelines in mind:\n\n- Compare the server’s credentials against a public key, instead of storing a single certificate in your app bundle. This will allow you to reissue a certificate for the same key and update the server, rather than needing to update the app.\n- Compare the issuing certificate authority’s (CA’s) keys, rather than using the leaf key. This way, you can deploy certificates containing new keys signed by the same CA.\n- Use a set of keys or CAs, so you can rotate server credentials more gracefully.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Performing manual server trust authentication",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/performing-manual-server-trust-authentication"
}