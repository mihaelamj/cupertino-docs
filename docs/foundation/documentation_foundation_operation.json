{
  "abstract" : "An abstract class that represents the code and data associated with a single task.",
  "codeExamples" : [

  ],
  "conformsTo" : [
    "CVarArg",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Equatable",
    "Hashable",
    "NSObjectProtocol",
    "Sendable",
    "SendableMetatype"
  ],
  "contentHash" : "e2f136a78dc79ec567f7cd28b1a6636d018c18388632dc6958220a90833ea17e",
  "crawledAt" : "2025-12-04T16:22:32Z",
  "declaration" : {
    "code" : "class Operation",
    "language" : "swift"
  },
  "id" : "C4D9D551-CBFF-4737-A2A2-74379640D4B1",
  "inheritedBy" : [
    "BlockOperation"
  ],
  "kind" : "class",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nBecause the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation] class is an abstract class, you do not use it directly but instead subclass or use one of the system-defined subclasses ([doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSInvocationOperation] or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/BlockOperation]) to perform the actual task. Despite being abstract, the base implementation of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation] does include significant logic to coordinate the safe execution of your task. The presence of this built-in logic allows you to focus on the actual implementation of your task, rather than on the glue code needed to ensure it works correctly with other system objects.\n\nAn operation object is a single-shot object—that is, it executes its task once and cannot be used to execute it again. You typically execute operations by adding them to an operation queue (an instance of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue] class). An operation queue executes its operations either directly, by running them on secondary threads, or indirectly using the `libdispatch` library (also known as Grand Central Dispatch). For more information about how queues execute operations, see [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue].\n\nIf you do not want to use an operation queue, you can execute an operation yourself by calling its [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method directly from your code. Executing operations manually does put more of a burden on your code, because starting an operation that is not in the ready state triggers an exception. The [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isReady] property reports on the operation’s readiness.\n\n### Operation Dependencies\n\nDependencies are a convenient way to execute operations in a specific order. You can add and remove dependencies for an operation using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/addDependency(_:)] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/removeDependency(_:)] methods. By default, an operation object that has dependencies is not considered ready until all of its dependent operation objects have finished executing. Once the last dependent operation finishes, however, the operation object becomes ready and able to execute.\n\nThe dependencies supported by `NSOperation` make no distinction about whether a dependent operation finished successfully or unsuccessfully. (In other words, canceling an operation similarly marks it as finished.) It is up to you to determine whether an operation with dependencies should proceed in cases where its dependent operations were cancelled or did not complete their task successfully. This may require you to incorporate some additional error tracking capabilities into your operation objects.\n\n### KVO-Compliant Properties\n\nThe `NSOperation` class is key-value coding (KVC) and key-value observing (KVO) compliant for several of its properties. As needed, you can observe these properties to control other parts of your application. To observe the properties, use the following key paths:\n\nAlthough you can attach observers to these properties, you should not use Cocoa bindings to bind them to elements of your application’s user interface. Code associated with your user interface typically must execute only in your application’s main thread. Because an operation may execute in any thread, KVO notifications associated with that operation may similarly occur in any thread.\n\nIf you provide custom implementations for any of the preceding properties, your implementations must maintain KVC and KVO compliance. If you define additional properties for your `NSOperation` objects, it is recommended that you make those properties KVC and KVO compliant as well. For information on how to support key-value coding, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i]. For information on how to support key-value observing, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i].\n\n### Multicore Considerations\n\nThe `NSOperation` class is itself multicore aware. It is therefore safe to call the methods of an `NSOperation` object from multiple threads without creating additional locks to synchronize access to the object. This behavior is necessary because an operation typically runs in a separate thread from the one that created and is monitoring it.\n\nWhen you subclass `NSOperation`, you must make sure that any overridden methods remain safe to call from multiple threads. If you implement custom methods in your subclass, such as custom data accessors, you must also make sure those methods are thread-safe. Thus, access to any data variables in the operation must be synchronized to prevent potential data corruption. For more information about synchronization, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/Multithreading\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/10000057i].\n\n### Asynchronous Versus Synchronous Operations\n\nIf you plan on executing an operation object manually, instead of adding it to a queue, you can design your operation to execute in a synchronous or asynchronous manner. Operation objects are synchronous by default. In a synchronous operation, the operation object does not create a separate thread on which to run its task. When you call the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of a synchronous operation directly from your code, the operation executes immediately in the current thread. By the time the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of such an object returns control to the caller, the task itself is complete.\n\nWhen you call the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of an asynchronous operation, that method may return before the corresponding task is completed. An asynchronous operation object is responsible for scheduling its task on a separate thread. The operation could do that by starting a new thread directly, by calling an asynchronous method, or by submitting a block to a dispatch queue for execution. It does not actually matter if the operation is ongoing when control returns to the caller, only that it could be ongoing.\n\nIf you always plan to use queues to execute your operations, it is simpler to define them as synchronous. If you execute operations manually, though, you might want to define your operation objects as asynchronous. Defining an asynchronous operation requires more work, because you have to monitor the ongoing state of your task and report changes in that state using KVO notifications. But defining asynchronous operations is useful in cases where you want to ensure that a manually executed operation does not block the calling thread.\n\nWhen you add an operation to an operation queue, the queue ignores the value of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isAsynchronous] property and always calls the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method from a separate thread. Therefore, if you always run operations by adding them to an operation queue, there is no reason to make them asynchronous.\n\nFor information on how to define both synchronous and asynchronous operations, see the subclassing notes.\n\n### Subclassing Notes\n\nThe `NSOperation` class provides the basic logic to track the execution state of your operation but otherwise must be subclassed to do any real work. How you create your subclass depends on whether your operation is designed to execute concurrently or non-concurrently.\n\n#### Methods to Override\n\nFor non-concurrent operations, you typically override only one method:\n\nInto this method, you place the code needed to perform the given task. Of course, you should also define a custom initialization method to make it easier to create instances of your custom class. You might also want to define getter and setter methods to access the data from the operation. However, if you do define custom getter and setter methods, you must make sure those methods can be called safely from multiple threads.\n\nIf you are creating a concurrent operation, you need to override the following methods and properties at a minimum:\n\nIn a concurrent operation, your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method is responsible for starting the operation in an asynchronous manner. Whether you spawn a thread or call an asynchronous function, you do it from this method. Upon starting the operation, your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method should also update the execution state of the operation as reported by the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] property. You do this by sending out KVO notifications for the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] key path, which lets interested clients know that the operation is now running. Your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] property must also provide the status in a thread-safe manner.\n\nUpon completion or cancellation of its task, your concurrent operation object must generate KVO notifications for both the `isExecuting` and `isFinished` key paths to mark the final change of state for your operation. (In the case of cancellation, it is still important to update the `isFinished` key path, even if the operation did not completely finish its task. Queued operations must report that they are finished before they can be removed from a queue.) In addition to generating KVO notifications, your overrides of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] properties should also continue to report accurate values based on the state of your operation.\n\nFor additional information and guidance on how to define concurrent operations, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/ConcurrencyProgrammingGuide\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40008091].\n\nEven for concurrent operations, there should be little need to override methods other than those described above. However, if you customize the dependency features of operations, you might have to override additional methods and provide additional KVO notifications. In the case of dependencies, this would likely only require providing notifications for the `isReady` key path. Because the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/dependencies] property contains the list of dependent operations, changes to it are already handled by the default `NSOperation` class.\n\n#### Maintaining Operation Object States\n\nOperation objects maintain state information internally to determine when it is safe to execute and also to notify external clients of the progression through the operation’s life cycle. Your custom subclasses maintains this state information to ensure the correct execution of operations in your code. The key paths associated with an operation’s states are:\n\nIn most cases, you do not have to manage the state of this key path yourself. If the readiness of your operations is determined by factors other than dependent operations, however—such as by some external condition in your program—you can provide your own implementation of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isReady] property and track your operation’s readiness yourself. It is often simpler though just to create operation objects only when your external state allows it.\n\nIn macOS 10.6 and later, if you cancel an operation while it is waiting on the completion of one or more dependent operations, those dependencies are thereafter ignored and the value of this property is updated to reflect that it is now ready to run. This behavior gives an operation queue the chance to flush cancelled operations out of its queue more quickly.\n\nIf you replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of your operation object, you must also replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] property and generate KVO notifications when the execution state of your operation changes.\n\nIf you replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method or your operation object, you must also replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] property and generate KVO notifications when the operation finishes executing or is cancelled.\n\n#### Responding to the Cancel Command\n\nOnce you add an operation to a queue, the operation is out of your hands. The queue takes over and handles the scheduling of that task. However, if you decide later that you do not want to execute the operation after all—because the user pressed a cancel button in a progress panel or quit the application, for example—you can cancel the operation to prevent it from consuming CPU time needlessly. You do this by calling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/cancel()] method of the operation object itself or by calling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue\/cancelAllOperations()] method of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue] class.\n\nCanceling an operation does not immediately force it to stop what it is doing. Although respecting the value in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isCancelled] property is expected of all operations, your code must explicitly check the value in this property and abort as needed. The default implementation of `NSOperation` includes checks for cancellation. For example, if you cancel an operation before its [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method is called, the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method exits without starting the task.\n\nYou should always support cancellation semantics in any custom code you write. In particular, your main task code should periodically check the value of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isCancelled] property. If the property reports the value [doc:\/\/com.apple.documentation\/documentation\/Swift\/true], your operation object should clean up and exit as quickly as possible. If you implement a custom [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method, that method should include early checks for cancellation and behave appropriately. Your custom [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method must be prepared to handle this type of early cancellation.\n\nIn addition to simply exiting when an operation is cancelled, it is also important that you move a cancelled operation to the appropriate final state. Specifically, if you manage the values for the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] properties yourself (perhaps because you are implementing a concurrent operation), you must update those properties accordingly. Specifically, you must change the value returned by [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] and the value returned by [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/false]. You must make these changes even if the operation was cancelled before it started executing.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\ncrawled: 2025-12-04T16:22:32Z\n---\n\n# Operation\n\n**Class**\n\nAn abstract class that represents the code and data associated with a single task.\n\n## Declaration\n\n```swift\nclass Operation\n```\n\n## Overview\n\nBecause the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation] class is an abstract class, you do not use it directly but instead subclass or use one of the system-defined subclasses ([doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSInvocationOperation] or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/BlockOperation]) to perform the actual task. Despite being abstract, the base implementation of [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation] does include significant logic to coordinate the safe execution of your task. The presence of this built-in logic allows you to focus on the actual implementation of your task, rather than on the glue code needed to ensure it works correctly with other system objects.\n\nAn operation object is a single-shot object—that is, it executes its task once and cannot be used to execute it again. You typically execute operations by adding them to an operation queue (an instance of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue] class). An operation queue executes its operations either directly, by running them on secondary threads, or indirectly using the `libdispatch` library (also known as Grand Central Dispatch). For more information about how queues execute operations, see [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue].\n\nIf you do not want to use an operation queue, you can execute an operation yourself by calling its [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method directly from your code. Executing operations manually does put more of a burden on your code, because starting an operation that is not in the ready state triggers an exception. The [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isReady] property reports on the operation’s readiness.\n\n### Operation Dependencies\n\nDependencies are a convenient way to execute operations in a specific order. You can add and remove dependencies for an operation using the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/addDependency(_:)] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/removeDependency(_:)] methods. By default, an operation object that has dependencies is not considered ready until all of its dependent operation objects have finished executing. Once the last dependent operation finishes, however, the operation object becomes ready and able to execute.\n\nThe dependencies supported by `NSOperation` make no distinction about whether a dependent operation finished successfully or unsuccessfully. (In other words, canceling an operation similarly marks it as finished.) It is up to you to determine whether an operation with dependencies should proceed in cases where its dependent operations were cancelled or did not complete their task successfully. This may require you to incorporate some additional error tracking capabilities into your operation objects.\n\n### KVO-Compliant Properties\n\nThe `NSOperation` class is key-value coding (KVC) and key-value observing (KVO) compliant for several of its properties. As needed, you can observe these properties to control other parts of your application. To observe the properties, use the following key paths:\n\n- `isCancelled` - read-only\n- `isAsynchronous` - read-only\n- `isExecuting` - read-only\n- `isFinished` - read-only\n- `isReady` - read-only\n- `dependencies` - read-only\n- `queuePriority` - readable and writable\n- `completionBlock` - readable and writable\n\nAlthough you can attach observers to these properties, you should not use Cocoa bindings to bind them to elements of your application’s user interface. Code associated with your user interface typically must execute only in your application’s main thread. Because an operation may execute in any thread, KVO notifications associated with that operation may similarly occur in any thread.\n\nIf you provide custom implementations for any of the preceding properties, your implementations must maintain KVC and KVO compliance. If you define additional properties for your `NSOperation` objects, it is recommended that you make those properties KVC and KVO compliant as well. For information on how to support key-value coding, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/KeyValueCoding\/index.html#\/\/apple_ref\/doc\/uid\/10000107i]. For information on how to support key-value observing, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/KeyValueObserving\/KeyValueObserving.html#\/\/apple_ref\/doc\/uid\/10000177i].\n\n### Multicore Considerations\n\nThe `NSOperation` class is itself multicore aware. It is therefore safe to call the methods of an `NSOperation` object from multiple threads without creating additional locks to synchronize access to the object. This behavior is necessary because an operation typically runs in a separate thread from the one that created and is monitoring it.\n\nWhen you subclass `NSOperation`, you must make sure that any overridden methods remain safe to call from multiple threads. If you implement custom methods in your subclass, such as custom data accessors, you must also make sure those methods are thread-safe. Thus, access to any data variables in the operation must be synchronized to prevent potential data corruption. For more information about synchronization, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Cocoa\/Conceptual\/Multithreading\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/10000057i].\n\n### Asynchronous Versus Synchronous Operations\n\nIf you plan on executing an operation object manually, instead of adding it to a queue, you can design your operation to execute in a synchronous or asynchronous manner. Operation objects are synchronous by default. In a synchronous operation, the operation object does not create a separate thread on which to run its task. When you call the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of a synchronous operation directly from your code, the operation executes immediately in the current thread. By the time the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of such an object returns control to the caller, the task itself is complete.\n\nWhen you call the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of an asynchronous operation, that method may return before the corresponding task is completed. An asynchronous operation object is responsible for scheduling its task on a separate thread. The operation could do that by starting a new thread directly, by calling an asynchronous method, or by submitting a block to a dispatch queue for execution. It does not actually matter if the operation is ongoing when control returns to the caller, only that it could be ongoing.\n\nIf you always plan to use queues to execute your operations, it is simpler to define them as synchronous. If you execute operations manually, though, you might want to define your operation objects as asynchronous. Defining an asynchronous operation requires more work, because you have to monitor the ongoing state of your task and report changes in that state using KVO notifications. But defining asynchronous operations is useful in cases where you want to ensure that a manually executed operation does not block the calling thread.\n\nWhen you add an operation to an operation queue, the queue ignores the value of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isAsynchronous] property and always calls the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method from a separate thread. Therefore, if you always run operations by adding them to an operation queue, there is no reason to make them asynchronous.\n\nFor information on how to define both synchronous and asynchronous operations, see the subclassing notes.\n\n### Subclassing Notes\n\nThe `NSOperation` class provides the basic logic to track the execution state of your operation but otherwise must be subclassed to do any real work. How you create your subclass depends on whether your operation is designed to execute concurrently or non-concurrently.\n\n#### Methods to Override\n\nFor non-concurrent operations, you typically override only one method:\n\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/main()]\n\nInto this method, you place the code needed to perform the given task. Of course, you should also define a custom initialization method to make it easier to create instances of your custom class. You might also want to define getter and setter methods to access the data from the operation. However, if you do define custom getter and setter methods, you must make sure those methods can be called safely from multiple threads.\n\nIf you are creating a concurrent operation, you need to override the following methods and properties at a minimum:\n\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()]\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isAsynchronous]\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting]\n- [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished]\n\nIn a concurrent operation, your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method is responsible for starting the operation in an asynchronous manner. Whether you spawn a thread or call an asynchronous function, you do it from this method. Upon starting the operation, your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method should also update the execution state of the operation as reported by the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] property. You do this by sending out KVO notifications for the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] key path, which lets interested clients know that the operation is now running. Your [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] property must also provide the status in a thread-safe manner.\n\nUpon completion or cancellation of its task, your concurrent operation object must generate KVO notifications for both the `isExecuting` and `isFinished` key paths to mark the final change of state for your operation. (In the case of cancellation, it is still important to update the `isFinished` key path, even if the operation did not completely finish its task. Queued operations must report that they are finished before they can be removed from a queue.) In addition to generating KVO notifications, your overrides of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] properties should also continue to report accurate values based on the state of your operation.\n\nFor additional information and guidance on how to define concurrent operations, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/General\/Conceptual\/ConcurrencyProgrammingGuide\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40008091].\n\n\n\nEven for concurrent operations, there should be little need to override methods other than those described above. However, if you customize the dependency features of operations, you might have to override additional methods and provide additional KVO notifications. In the case of dependencies, this would likely only require providing notifications for the `isReady` key path. Because the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/dependencies] property contains the list of dependent operations, changes to it are already handled by the default `NSOperation` class.\n\n#### Maintaining Operation Object States\n\nOperation objects maintain state information internally to determine when it is safe to execute and also to notify external clients of the progression through the operation’s life cycle. Your custom subclasses maintains this state information to ensure the correct execution of operations in your code. The key paths associated with an operation’s states are:\n\n\n\nIn most cases, you do not have to manage the state of this key path yourself. If the readiness of your operations is determined by factors other than dependent operations, however—such as by some external condition in your program—you can provide your own implementation of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isReady] property and track your operation’s readiness yourself. It is often simpler though just to create operation objects only when your external state allows it.\n\nIn macOS 10.6 and later, if you cancel an operation while it is waiting on the completion of one or more dependent operations, those dependencies are thereafter ignored and the value of this property is updated to reflect that it is now ready to run. This behavior gives an operation queue the chance to flush cancelled operations out of its queue more quickly.\n\n\n\nIf you replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method of your operation object, you must also replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] property and generate KVO notifications when the execution state of your operation changes.\n\n\n\nIf you replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method or your operation object, you must also replace the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] property and generate KVO notifications when the operation finishes executing or is cancelled.\n\n\n\n#### Responding to the Cancel Command\n\nOnce you add an operation to a queue, the operation is out of your hands. The queue takes over and handles the scheduling of that task. However, if you decide later that you do not want to execute the operation after all—because the user pressed a cancel button in a progress panel or quit the application, for example—you can cancel the operation to prevent it from consuming CPU time needlessly. You do this by calling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/cancel()] method of the operation object itself or by calling the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue\/cancelAllOperations()] method of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/OperationQueue] class.\n\nCanceling an operation does not immediately force it to stop what it is doing. Although respecting the value in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isCancelled] property is expected of all operations, your code must explicitly check the value in this property and abort as needed. The default implementation of `NSOperation` includes checks for cancellation. For example, if you cancel an operation before its [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method is called, the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method exits without starting the task.\n\n\n\nYou should always support cancellation semantics in any custom code you write. In particular, your main task code should periodically check the value of the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isCancelled] property. If the property reports the value [doc:\/\/com.apple.documentation\/documentation\/Swift\/true], your operation object should clean up and exit as quickly as possible. If you implement a custom [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method, that method should include early checks for cancellation and behave appropriately. Your custom [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/start()] method must be prepared to handle this type of early cancellation.\n\nIn addition to simply exiting when an operation is cancelled, it is also important that you move a cancelled operation to the appropriate final state. Specifically, if you manage the values for the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] properties yourself (perhaps because you are implementing a concurrent operation), you must update those properties accordingly. Specifically, you must change the value returned by [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isFinished] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true] and the value returned by [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Operation\/isExecuting] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/false]. You must make these changes even if the operation was cancelled before it started executing.\n\n## Executing the Operation\n\n- **start()**: Begins the execution of the operation.\n- **main()**: Performs the receiver’s non-concurrent task.\n- **completionBlock**: The block to execute after the operation’s main task is completed.\n\n## Canceling Operations\n\n- **cancel()**: Advises the operation object that it should stop executing its task.\n\n## Getting the Operation Status\n\n- **isCancelled**: A Boolean value indicating whether the operation has been cancelled\n- **isExecuting**: A Boolean value indicating whether the operation is currently executing.\n- **isFinished**: A Boolean value indicating whether the operation has finished executing its task.\n- **isConcurrent**: A Boolean value indicating whether the operation executes its task asynchronously.\n- **isAsynchronous**: A Boolean value indicating whether the operation executes its task asynchronously.\n- **isReady**: A Boolean value indicating whether the operation can be performed now.\n- **name**: The name of the operation.\n\n## Managing Dependencies\n\n- **addDependency(_:)**: Makes the receiver dependent on the completion of the specified operation.\n- **removeDependency(_:)**: Removes the receiver’s dependence on the specified operation.\n- **dependencies**: An array of the operation objects that must finish executing before the current object can begin executing.\n\n## Configuring the Execution Priority\n\n- **qualityOfService**: The relative amount of importance for granting system resources to the operation.\n- **threadPriority**: The thread priority to use when executing the operation\n- **queuePriority**: The execution priority of the operation in an operation queue.\n\n## Waiting on an Operation Object\n\n- **waitUntilFinished()**: Blocks execution of the current thread until the operation object finishes its task.\n\n## Constants\n\n- **Operation.QueuePriority**: These constants let you prioritize the order in which operations execute.\n- **QualityOfService**: Constants that indicate the nature and importance of work to the system.\n\n## Operations\n\n- **OperationQueue**: A queue that regulates the execution of operations.\n- **BlockOperation**: An operation that manages the concurrent execution of one or more blocks.\n\n## Inherits From\n\n- NSObject\n\n## Inherited By\n\n- BlockOperation\n\n## Conforms To\n\n- CVarArg\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Equatable\n- Hashable\n- NSObjectProtocol\n- Sendable\n- SendableMetatype\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Begins the execution of the operation.",
          "name" : "start()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/start()"
        },
        {
          "description" : "Performs the receiver’s non-concurrent task.",
          "name" : "main()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/main()"
        },
        {
          "description" : "The block to execute after the operation’s main task is completed.",
          "name" : "completionBlock",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/completionBlock"
        }
      ],
      "title" : "Executing the Operation"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Advises the operation object that it should stop executing its task.",
          "name" : "cancel()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/cancel()"
        }
      ],
      "title" : "Canceling Operations"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A Boolean value indicating whether the operation has been cancelled",
          "name" : "isCancelled",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/isCancelled"
        },
        {
          "description" : "A Boolean value indicating whether the operation is currently executing.",
          "name" : "isExecuting",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/isExecuting"
        },
        {
          "description" : "A Boolean value indicating whether the operation has finished executing its task.",
          "name" : "isFinished",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/isFinished"
        },
        {
          "description" : "A Boolean value indicating whether the operation executes its task asynchronously.",
          "name" : "isConcurrent",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/isConcurrent"
        },
        {
          "description" : "A Boolean value indicating whether the operation executes its task asynchronously.",
          "name" : "isAsynchronous",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/isAsynchronous"
        },
        {
          "description" : "A Boolean value indicating whether the operation can be performed now.",
          "name" : "isReady",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/isReady"
        },
        {
          "description" : "The name of the operation.",
          "name" : "name",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/name"
        }
      ],
      "title" : "Getting the Operation Status"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Makes the receiver dependent on the completion of the specified operation.",
          "name" : "addDependency(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/addDependency(_:)"
        },
        {
          "description" : "Removes the receiver’s dependence on the specified operation.",
          "name" : "removeDependency(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/removeDependency(_:)"
        },
        {
          "description" : "An array of the operation objects that must finish executing before the current object can begin executing.",
          "name" : "dependencies",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/dependencies"
        }
      ],
      "title" : "Managing Dependencies"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The relative amount of importance for granting system resources to the operation.",
          "name" : "qualityOfService",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/qualityOfService"
        },
        {
          "description" : "The thread priority to use when executing the operation",
          "name" : "threadPriority",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/threadPriority"
        },
        {
          "description" : "The execution priority of the operation in an operation queue.",
          "name" : "queuePriority",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/queuePriority-swift.property"
        }
      ],
      "title" : "Configuring the Execution Priority"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Blocks execution of the current thread until the operation object finishes its task.",
          "name" : "waitUntilFinished()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/waitUntilFinished()"
        }
      ],
      "title" : "Waiting on an Operation Object"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "These constants let you prioritize the order in which operations execute.",
          "name" : "Operation.QueuePriority",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation\/QueuePriority-swift.enum"
        },
        {
          "description" : "Constants that indicate the nature and importance of work to the system.",
          "name" : "QualityOfService",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/QualityOfService"
        }
      ],
      "title" : "Constants"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A queue that regulates the execution of operations.",
          "name" : "OperationQueue",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/OperationQueue"
        },
        {
          "description" : "An operation that manages the concurrent execution of one or more blocks.",
          "name" : "BlockOperation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/BlockOperation"
        }
      ],
      "title" : "Operations"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "NSObject"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "Operation",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/Operation"
}