{
  "abstract" : "Download files directly to the filesystem.",
  "codeExamples" : [
    {
      "code" : "let downloadTask = URLSession.shared.downloadTask(with: url) {\n    urlOrNil, responseOrNil, errorOrNil in\n    \/\/ check for and handle errors:\n    \/\/ * errorOrNil should be nil\n    \/\/ * responseOrNil should be an HTTPURLResponse with statusCode in 200..<299\n    \n    guard let fileURL = urlOrNil else { return }\n    do {\n        let documentsURL = try\n            FileManager.default.url(for: .documentDirectory,\n                                    in: .userDomainMask,\n                                    appropriateFor: nil,\n                                    create: false)\n        let savedURL = documentsURL.appendingPathComponent(fileURL.lastPathComponent)\n        try FileManager.default.moveItem(at: fileURL, to: savedURL)\n    } catch {\n        print (\"file error: \\(error)\")\n    }\n}\ndownloadTask.resume()\n",
      "language" : "swift"
    },
    {
      "code" : "private lazy var urlSession = URLSession(configuration: .default,\n                                         delegate: self,\n                                         delegateQueue: nil)\n",
      "language" : "swift"
    },
    {
      "code" : "private func startDownload(url: URL) {\n    let downloadTask = urlSession.downloadTask(with: url)\n    downloadTask.resume()\n    self.downloadTask = downloadTask\n}\n",
      "language" : "swift"
    },
    {
      "code" : "func urlSession(_ session: URLSession,\n                downloadTask: URLSessionDownloadTask,\n                didWriteData bytesWritten: Int64,\n                totalBytesWritten: Int64,\n                totalBytesExpectedToWrite: Int64) {\n     if downloadTask == self.downloadTask {\n        let calculatedProgress = Float(totalBytesWritten) \/ Float(totalBytesExpectedToWrite)\n        DispatchQueue.main.async {\n            self.progressLabel.text = self.percentFormatter.string(from:\n                NSNumber(value: calculatedProgress))\n    }\n}\n",
      "language" : "swift"
    },
    {
      "code" : "func urlSession(_ session: URLSession,\n                downloadTask: URLSessionDownloadTask,\n                didFinishDownloadingTo location: URL) {\n    \/\/ check for and handle errors:\n    \/\/ * downloadTask.response should be an HTTPURLResponse with statusCode in 200..<299\n\n    do {\n        let documentsURL = try\n            FileManager.default.url(for: .documentDirectory,\n                                    in: .userDomainMask,\n                                    appropriateFor: nil,\n                                    create: false)\n        let savedURL = documentsURL.appendingPathComponent(\n            location.lastPathComponent)\n        try FileManager.default.moveItem(at: location, to: savedURL)\n    } catch {\n        \/\/ handle filesystem error\n    }\n}\n",
      "language" : "swift"
    }
  ],
  "contentHash" : "730faf2c4eb59071eec79173e4f594b13765603742213edeab2081936ae64e90",
  "crawledAt" : "2025-12-04T16:24:33Z",
  "id" : "B8D84233-36F7-4A78-859A-A46EE74E62F4",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nFor network resources that are already stored as files, like images and documents, you can use download tasks to fetch these items directly to the local filesystem.\n\n### For simple downloads, use a completion handler\n\nTo download files, you create a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadTask] from a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]. If you don’t care about receiving progress updates or other delegate callbacks during the download, you can use a completion handler. The task calls the completion handler when the download ends, either at the end of a successful download or when downloading fails.\n\nYour completion handler may receive a client-side error, indicating a local problem like not being able to reach the network. If there is no client-side error, you also receive a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLResponse], which you should inspect to ensure that it indicates a successful response from the server.\n\nIf the download is successful, your completion handler receives a URL indicating the location of the downloaded file on the local filesystem. This storage is temporary. If you want to preserve the file, you *must* copy or move it from this location before returning from the completion handler.\n\nThe following example shows a simple example of creating a download task with a completion handler. If no errors are indicated, the completion handler moves the downloaded file to the app’s `Documents` directory. Start the task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()].\n\nCreating a download task with a completion handler\n\n### To receive progress updates, use a delegate\n\nIf you want to receive progress updates as the download proceeds, you must use a delegate. Instead of receiving the results in a completion handler, you receive callbacks to your implementations of methods from the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate] protocols.\n\nCreate your own [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] instance, and set its `delegate` property. The following example shows a lazily instantiated `urlSession` property that sets `self` as its delegate.\n\nCreating a URL session with a delegate\n\nTo start downloading, use this [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] to create a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadTask], and then start the task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()], as shown in in the following example.\n\nCreating and starting a download task that uses a delegate\n\n### Receive progress updates\n\nOnce the download starts, you receive periodic progress updates in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate\/urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)]. You can use the byte counts provided by this callback to update a progress UI in your app.\n\nThe following example shows an implementation of this callback method. This implementation calculates the fractional progress of the download, and uses it to update a label that shows progress as a percentage. Because the callback is performed on an unknown Grand Central Dispatch queue, you *must* explicitly perform the UI update on the main queue.\n\nUsing a delegate method to update download progress in a UI\n\n### Handle download completion or errors in your delegate\n\nWhen you use a delegate instead of a completion handler, you handle the completion of the download by implementing [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate\/urlSession(_:downloadTask:didFinishDownloadingTo:)]. Check the `downloadTask`‘s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/response] property to ensure that the server response indicates success. If so, the `location` parameter provides a local URL where the file has been stored. This location is valid only until the end of the callback. This means you *must* either read the file immediately, or move it to another location such as the app’s `Documents` directory before you return from the callback method. The following example shows how to preserve the downloaded file.\n\nSaving the downloaded file in the delegate callback\n\nIf a client-side error occurs, your delegate receives it in a callback to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:didCompleteWithError:)] delegate method. On the other hand, if the download completes successfully, this method is called after [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate\/urlSession(_:downloadTask:didFinishDownloadingTo:)] and the error is `nil`.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/downloading-files-from-websites\ncrawled: 2025-12-04T16:24:33Z\n---\n\n# Downloading files from websites\n\n**Article**\n\nDownload files directly to the filesystem.\n\n## Overview\n\nFor network resources that are already stored as files, like images and documents, you can use download tasks to fetch these items directly to the local filesystem.\n\n\n\n### For simple downloads, use a completion handler\n\nTo download files, you create a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadTask] from a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]. If you don’t care about receiving progress updates or other delegate callbacks during the download, you can use a completion handler. The task calls the completion handler when the download ends, either at the end of a successful download or when downloading fails.\n\nYour completion handler may receive a client-side error, indicating a local problem like not being able to reach the network. If there is no client-side error, you also receive a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLResponse], which you should inspect to ensure that it indicates a successful response from the server.\n\nIf the download is successful, your completion handler receives a URL indicating the location of the downloaded file on the local filesystem. This storage is temporary. If you want to preserve the file, you *must* copy or move it from this location before returning from the completion handler.\n\nThe following example shows a simple example of creating a download task with a completion handler. If no errors are indicated, the completion handler moves the downloaded file to the app’s `Documents` directory. Start the task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()].\n\nCreating a download task with a completion handler\n\n```swift\nlet downloadTask = URLSession.shared.downloadTask(with: url) {\n    urlOrNil, responseOrNil, errorOrNil in\n    \/\/ check for and handle errors:\n    \/\/ * errorOrNil should be nil\n    \/\/ * responseOrNil should be an HTTPURLResponse with statusCode in 200..<299\n    \n    guard let fileURL = urlOrNil else { return }\n    do {\n        let documentsURL = try\n            FileManager.default.url(for: .documentDirectory,\n                                    in: .userDomainMask,\n                                    appropriateFor: nil,\n                                    create: false)\n        let savedURL = documentsURL.appendingPathComponent(fileURL.lastPathComponent)\n        try FileManager.default.moveItem(at: fileURL, to: savedURL)\n    } catch {\n        print (\"file error: \\(error)\")\n    }\n}\ndownloadTask.resume()\n\n```\n\n\n\n### To receive progress updates, use a delegate\n\nIf you want to receive progress updates as the download proceeds, you must use a delegate. Instead of receiving the results in a completion handler, you receive callbacks to your implementations of methods from the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate] protocols.\n\nCreate your own [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] instance, and set its `delegate` property. The following example shows a lazily instantiated `urlSession` property that sets `self` as its delegate.\n\nCreating a URL session with a delegate\n\n```swift\nprivate lazy var urlSession = URLSession(configuration: .default,\n                                         delegate: self,\n                                         delegateQueue: nil)\n\n```\n\nTo start downloading, use this [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] to create a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadTask], and then start the task by calling [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/resume()], as shown in in the following example.\n\nCreating and starting a download task that uses a delegate\n\n```swift\nprivate func startDownload(url: URL) {\n    let downloadTask = urlSession.downloadTask(with: url)\n    downloadTask.resume()\n    self.downloadTask = downloadTask\n}\n\n```\n\n### Receive progress updates\n\nOnce the download starts, you receive periodic progress updates in the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate] method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate\/urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)]. You can use the byte counts provided by this callback to update a progress UI in your app.\n\nThe following example shows an implementation of this callback method. This implementation calculates the fractional progress of the download, and uses it to update a label that shows progress as a percentage. Because the callback is performed on an unknown Grand Central Dispatch queue, you *must* explicitly perform the UI update on the main queue.\n\nUsing a delegate method to update download progress in a UI\n\n```swift\nfunc urlSession(_ session: URLSession,\n                downloadTask: URLSessionDownloadTask,\n                didWriteData bytesWritten: Int64,\n                totalBytesWritten: Int64,\n                totalBytesExpectedToWrite: Int64) {\n     if downloadTask == self.downloadTask {\n        let calculatedProgress = Float(totalBytesWritten) \/ Float(totalBytesExpectedToWrite)\n        DispatchQueue.main.async {\n            self.progressLabel.text = self.percentFormatter.string(from:\n                NSNumber(value: calculatedProgress))\n    }\n}\n\n```\n\n\n\n### Handle download completion or errors in your delegate\n\nWhen you use a delegate instead of a completion handler, you handle the completion of the download by implementing [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate\/urlSession(_:downloadTask:didFinishDownloadingTo:)]. Check the `downloadTask`‘s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTask\/response] property to ensure that the server response indicates success. If so, the `location` parameter provides a local URL where the file has been stored. This location is valid only until the end of the callback. This means you *must* either read the file immediately, or move it to another location such as the app’s `Documents` directory before you return from the callback method. The following example shows how to preserve the downloaded file.\n\nSaving the downloaded file in the delegate callback\n\n```swift\nfunc urlSession(_ session: URLSession,\n                downloadTask: URLSessionDownloadTask,\n                didFinishDownloadingTo location: URL) {\n    \/\/ check for and handle errors:\n    \/\/ * downloadTask.response should be an HTTPURLResponse with statusCode in 200..<299\n\n    do {\n        let documentsURL = try\n            FileManager.default.url(for: .documentDirectory,\n                                    in: .userDomainMask,\n                                    appropriateFor: nil,\n                                    create: false)\n        let savedURL = documentsURL.appendingPathComponent(\n            location.lastPathComponent)\n        try FileManager.default.moveItem(at: location, to: savedURL)\n    } catch {\n        \/\/ handle filesystem error\n    }\n}\n\n```\n\nIf a client-side error occurs, your delegate receives it in a callback to the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionTaskDelegate\/urlSession(_:task:didCompleteWithError:)] delegate method. On the other hand, if the download completes successfully, this method is called after [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSessionDownloadDelegate\/urlSession(_:downloadTask:didFinishDownloadingTo:)] and the error is `nil`.\n\n## Downloading\n\n- **Pausing and resuming downloads**: Allow the user to resume a download without starting over.\n- **Downloading files in the background**: Create tasks that download files while your app is inactive.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Allow the user to resume a download without starting over.",
          "name" : "Pausing and resuming downloads",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/pausing-and-resuming-downloads"
        },
        {
          "description" : "Create tasks that download files while your app is inactive.",
          "name" : "Downloading files in the background",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/downloading-files-in-the-background"
        }
      ],
      "title" : "Downloading"
    }
  ],
  "source" : "appleJSON",
  "title" : "Downloading files from websites",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/downloading-files-from-websites"
}