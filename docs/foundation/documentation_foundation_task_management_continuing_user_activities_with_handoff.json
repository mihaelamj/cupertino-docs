{
  "abstract" : "Define and manage which of your app’s activities can be continued between devices.",
  "codeExamples" : [
    {
      "code" : "<key>NSUserActivityTypes<\/key>\n<array>\n  <string>com.example.apple-samplecode.HandoffMapViewer.map-viewing<\/string>\n  <string>com.example.apple-samplecode.HandoffMapViewer.store-editing<\/string>\n<\/array>"
    },
    {
      "code" : "userActivity = mapViewingActivity\nmapViewingActivity.needsSave = true\nmapViewingActivity.becomeCurrent()",
      "language" : "swift"
    },
    {
      "code" : "func updateViewingRegion(_ region: MKCoordinateRegion) {\n    let updateDict = [\n        NSUserActivity.regionCenterLatitudeKeyString: region.center.latitude,\n        NSUserActivity.regionCenterLongitudeKeyString: region.center.longitude,\n        NSUserActivity.regionSpanLatitudeKeyString: region.span.latitudeDelta,\n        NSUserActivity.regionSpanLongitudeKeyString: region.span.longitudeDelta]\n    addUserInfoEntries(from: updateDict)\n}",
      "language" : "swift"
    },
    {
      "code" : "func application(_ application: UIApplication, continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n    guard let topNav = application.keyWindow?.rootViewController as? UINavigationController,\n        let mapVC = topNav.viewControllers.first as? MapViewController else {\n        return false\n    }\n    \n    mapVC.loadView()\n    restorationHandler([mapVC])\n    return true\n}",
      "language" : "swift"
    },
    {
      "code" : "func application(_ application: NSApplication, continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool {\n    guard let mapVC = application.keyWindow?.windowController?.contentViewController as? MapViewController else {\n        return false\n    }\n    \n    mapVC.loadView()\n    restorationHandler([mapVC])\n    return true\n}",
      "language" : "swift"
    },
    {
      "code" : "func viewingRegion() -> MKCoordinateRegion? {\n    guard let centerLatitude = userInfo?[NSUserActivity.regionCenterLatitudeKeyString] as? CLLocationDegrees,\n        let centerLongitude = userInfo?[NSUserActivity.regionCenterLongitudeKeyString] as? CLLocationDegrees,\n        let spanLatitude = userInfo?[NSUserActivity.regionSpanLatitudeKeyString] as? CLLocationDegrees,\n        let spanLongitude = userInfo?[NSUserActivity.regionSpanLongitudeKeyString] as? CLLocationDegrees else {\n            return nil\n    }\n    return MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: centerLatitude,\n                                                             longitude: centerLongitude),\n                              span: MKCoordinateSpan(latitudeDelta: spanLatitude,\n                                                     longitudeDelta: spanLongitude))\n}",
      "language" : "swift"
    },
    {
      "code" : "func userActivityWasContinued(_ userActivity: NSUserActivity) {\n    DispatchQueue.main.async {[weak self] in\n        if let detailVC = self?.presentedViewController as? StoreDetailViewController,\n           userActivity.activityType == NSUserActivity.storeEditingActivityType {\n            detailVC.dismiss(animated: true)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "f6dfd21380112762c2ab61d4226bea5d9567dea2ab2bf9235f795b9c89294447",
  "crawledAt" : "2025-12-02T16:05:57Z",
  "id" : "B3F5360F-BAE6-4E8B-99B5-79B8442724BF",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nThis sample app searches for Apple Store locations and shows them on a map. The user can choose a store’s map annotation to see its address and mark it as a favorite. As the user changes visible regions or inspects individual stores, the app uses Handoff to share these activities with the user’s other devices. If the user changes devices, they can use Handoff to launch the app and return to what they were doing on the original device.\n\n\n\nThe sample project builds for both macOS and iOS, so you can run it on a Mac, iPhone, and iPad. The project does not contain a watchOS or tvOS app.\n\n### Configure the Sample Code Project\n\n`HandoffMapViewer` must be run on actual devices; the iOS version cannot run in Simulator.\n\nTo configure your Mac to run the sample code project, open System Preferences and do the following:\n\nTo configure your iOS devices to run the sample code project, open the Settings app and do the following:\n\nTo configure the sample code project so that it can run on your devices, open the `HandoffMapViewer.xcodeproj` project in Xcode and do the following:\n\n### Define User Activities\n\nYou implement Handoff by determining specific activities that a user can perform in your app, and whose state you can reproduce on a second device. The sample app has two user activities:\n\nYou use the app’s `Info.plist` to tell Handoff which activities your app can continue, by providing an entry with the key name `NSUserActivityTypes`. The type of this entry is `Array`, and each member is a `String` representing a supported Handoff activity. In the sample app, the macOS and iOS targets include the `map-viewing` and `store-editing` activities in their `Info.plist` files.\n\n### Manage User Activities\n\nAt runtime, you represent a user activity with the `NSUserActivity`  type. You initialize a user activity object with a string identifier, the same one used earlier in the `Info.plist`.  This object also has an `isEligibleForHandoff` property that exposes the activity to Handoff, and a `userInfo`  dictionary containing data needed to recreate the app’s state on the receiving device.\n\nIn the sample app, the `MapViewController` manages two `NSUserActivity` instances: one each for the `map-viewing` and `store-editing` activities. When the map region changes, it sets the `userActivity` property (defined in `NSViewController` for macOS and `UIViewController` for iOS) to the `map-viewing` activity. It makes this the current activity, replacing any other activity that may have previously been sent to Handoff, and sets `needsSave` to `true`, indicating that the activity has new data to send to remote devices.\n\nCalling `needsSave`  on the view controller’s `userActivity` eventually results in a callback to the method `updateUserActivityState(_:)`, declared in `UIResponder` on iOS and `NSResponder` on macOS. This is the app’s opportunity to refresh the activity object’s `userInfo` before Handoff receives the activity. The implementation in the sample app calls a convenience function `updateViewingRegion(_:)`,  defined in an extension on `NSUserActivity`, to encode the map view’s `MKCoordinateRegion` into key-value entries in the `userInfo` dictionary.\n\n### Receive User Activities\n\nWhen you move to another device, macOS or iOS indicates that a Handoff activity is available. macOS displays a Handoff icon at the beginning of the Dock, with a badge indicating the type of source device. On iOS, the Handoff banner appears at the bottom of the screen in the app switcher, showing the app and source device name.\n\nWhen you launch the app using the Handoff prompts, the system calls methods in `UIApplicationDelegate` (iOS) or `NSApplicationDelegate` (macOS) to provide the Handoff activity. The `application(_:continue:restorationHandler:)` method provides the activity, along with a completion handler that you call with an array of view controllers that can handle the activity.  The implementation in the iOS app delegate just finds and passes the first view controller, an instance of `MapViewController`.\n\nThe implementation in the macOS app delegate is similar, except that it traverses the key window’s hierarchy, rather than the iOS navigation controller stack:\n\n### Update the App’s State\n\nThe view controllers receive the `NSUserActivity` in the `restoreUserActivityState(_:)` method. `MapViewController` inspects the activity to determine whether it is the map-viewing or the store-editing activity, and then updates the UI as needed. The map-viewing activity case resets the map region, by creating a new `MKCoordinateRegion` from the values in the `userInfo`.\n\nIn the case of the store-editing activity, the view controller also retrieves the store’s URL and location coordinates from the `userInfo`. The app waits until the map adds a `MKAnnotationView` for the store being edited, so it knows where to anchor the popover.\n\n### Update the Original Device’s State (Optional)\n\nThe `NSUserActivity` class has a `delegate` property of type `NSUserActivityDelegate`. This notifies the originating device when you continue an activity on another device. The originating device can use this to clean up its own UI state.\n\nIn the sample app, tapping a pin for an Apple Store shows a popover with details about the store and a switch (iOS) or checkbox (macOS) to mark the store as a favorite. The `MapViewContoller` represents this activity as the `storeEditingActivity` property, and sets itself as the activity’s delegate. When you continue editing on a second device, the delegate on the originating device receives a notification that this activity has been continued, and dismisses its own popover.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/foundation\/task_management\/continuing_user_activities_with_handoff\ncrawled: 2025-12-02T16:05:57Z\n---\n\n# Continuing User Activities with Handoff\n\n**Sample Code**\n\nDefine and manage which of your app’s activities can be continued between devices.\n\n## Overview\n\nThis sample app searches for Apple Store locations and shows them on a map. The user can choose a store’s map annotation to see its address and mark it as a favorite. As the user changes visible regions or inspects individual stores, the app uses Handoff to share these activities with the user’s other devices. If the user changes devices, they can use Handoff to launch the app and return to what they were doing on the original device.\n\n\n\nThe sample project builds for both macOS and iOS, so you can run it on a Mac, iPhone, and iPad. The project does not contain a watchOS or tvOS app.\n\n### Configure the Sample Code Project\n\n`HandoffMapViewer` must be run on actual devices; the iOS version cannot run in Simulator.\n\nTo configure your Mac to run the sample code project, open System Preferences and do the following:\n\n1. In Bluetooth settings, click Turn Bluetooth On.\n2. In iCloud settings, verify that you are signed into iCloud. If you are not, click Sign In and enter your Apple ID and password.\n3. In General settings, select “Allow Handoff between this Mac and your iCloud devices”.\n\nTo configure your iOS devices to run the sample code project, open the Settings app and do the following:\n\n1. In Bluetooth settings, tap to turn on Bluetooth.\n2. In the user banner at the top of Settings, tap to sign in with your Apple ID if you haven’t already. Then tap to turn on  iCloud.\n3. In General settings, tap to turn on Handoff.\n\nTo configure the sample code project so that it can run on your devices, open the `HandoffMapViewer.xcodeproj` project in Xcode and do the following:\n\n1. Select the `HandoffMapViewer` project at the top of the Project Navigator, select the `HandoffMapViewerMac` target, select the “General” tab, and change the Bundle Identifier to a unique value, such as one that uses your organization’s name instead of `com.example`.\n2. With the `HandoffMapViewer` project still selected in the Project Navigator, select the `HandoffMapViewerIOS` target, select the “General” tab, and change the Bundle Identifier to the same value you used in the previous step.\n3. To run the macOS version, build the `HandoffMapViewerMac` target, and run it locally, or copy the application file from the `Products` folder to another Mac and run it there.\n4. To run the iOS version, build the `HandoffMapViewerIOS` target and run it on one of your connected iOS devices.\n\n### Define User Activities\n\nYou implement Handoff by determining specific activities that a user can perform in your app, and whose state you can reproduce on a second device. The sample app has two user activities:\n\n- Viewing a map region.\n- Viewing the details of a specific Apple Store and editing its “favorite” value.\n\n\n\nYou use the app’s `Info.plist` to tell Handoff which activities your app can continue, by providing an entry with the key name `NSUserActivityTypes`. The type of this entry is `Array`, and each member is a `String` representing a supported Handoff activity. In the sample app, the macOS and iOS targets include the `map-viewing` and `store-editing` activities in their `Info.plist` files.\n\n```\n<key>NSUserActivityTypes<\/key>\n<array>\n  <string>com.example.apple-samplecode.HandoffMapViewer.map-viewing<\/string>\n  <string>com.example.apple-samplecode.HandoffMapViewer.store-editing<\/string>\n<\/array>\n```\n\n### Manage User Activities\n\nAt runtime, you represent a user activity with the `NSUserActivity`  type. You initialize a user activity object with a string identifier, the same one used earlier in the `Info.plist`.  This object also has an `isEligibleForHandoff` property that exposes the activity to Handoff, and a `userInfo`  dictionary containing data needed to recreate the app’s state on the receiving device.\n\nIn the sample app, the `MapViewController` manages two `NSUserActivity` instances: one each for the `map-viewing` and `store-editing` activities. When the map region changes, it sets the `userActivity` property (defined in `NSViewController` for macOS and `UIViewController` for iOS) to the `map-viewing` activity. It makes this the current activity, replacing any other activity that may have previously been sent to Handoff, and sets `needsSave` to `true`, indicating that the activity has new data to send to remote devices.\n\n```swift\nuserActivity = mapViewingActivity\nmapViewingActivity.needsSave = true\nmapViewingActivity.becomeCurrent()\n```\n\nCalling `needsSave`  on the view controller’s `userActivity` eventually results in a callback to the method `updateUserActivityState(_:)`, declared in `UIResponder` on iOS and `NSResponder` on macOS. This is the app’s opportunity to refresh the activity object’s `userInfo` before Handoff receives the activity. The implementation in the sample app calls a convenience function `updateViewingRegion(_:)`,  defined in an extension on `NSUserActivity`, to encode the map view’s `MKCoordinateRegion` into key-value entries in the `userInfo` dictionary.\n\n```swift\nfunc updateViewingRegion(_ region: MKCoordinateRegion) {\n    let updateDict = [\n        NSUserActivity.regionCenterLatitudeKeyString: region.center.latitude,\n        NSUserActivity.regionCenterLongitudeKeyString: region.center.longitude,\n        NSUserActivity.regionSpanLatitudeKeyString: region.span.latitudeDelta,\n        NSUserActivity.regionSpanLongitudeKeyString: region.span.longitudeDelta]\n    addUserInfoEntries(from: updateDict)\n}\n```\n\n### Receive User Activities\n\nWhen you move to another device, macOS or iOS indicates that a Handoff activity is available. macOS displays a Handoff icon at the beginning of the Dock, with a badge indicating the type of source device. On iOS, the Handoff banner appears at the bottom of the screen in the app switcher, showing the app and source device name.\n\nWhen you launch the app using the Handoff prompts, the system calls methods in `UIApplicationDelegate` (iOS) or `NSApplicationDelegate` (macOS) to provide the Handoff activity. The `application(_:continue:restorationHandler:)` method provides the activity, along with a completion handler that you call with an array of view controllers that can handle the activity.  The implementation in the iOS app delegate just finds and passes the first view controller, an instance of `MapViewController`.\n\n```swift\nfunc application(_ application: UIApplication, continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n    guard let topNav = application.keyWindow?.rootViewController as? UINavigationController,\n        let mapVC = topNav.viewControllers.first as? MapViewController else {\n        return false\n    }\n    \n    mapVC.loadView()\n    restorationHandler([mapVC])\n    return true\n}\n```\n\nThe implementation in the macOS app delegate is similar, except that it traverses the key window’s hierarchy, rather than the iOS navigation controller stack:\n\n```swift\nfunc application(_ application: NSApplication, continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([NSUserActivityRestoring]) -> Void) -> Bool {\n    guard let mapVC = application.keyWindow?.windowController?.contentViewController as? MapViewController else {\n        return false\n    }\n    \n    mapVC.loadView()\n    restorationHandler([mapVC])\n    return true\n}\n```\n\n### Update the App’s State\n\nThe view controllers receive the `NSUserActivity` in the `restoreUserActivityState(_:)` method. `MapViewController` inspects the activity to determine whether it is the map-viewing or the store-editing activity, and then updates the UI as needed. The map-viewing activity case resets the map region, by creating a new `MKCoordinateRegion` from the values in the `userInfo`.\n\n```swift\nfunc viewingRegion() -> MKCoordinateRegion? {\n    guard let centerLatitude = userInfo?[NSUserActivity.regionCenterLatitudeKeyString] as? CLLocationDegrees,\n        let centerLongitude = userInfo?[NSUserActivity.regionCenterLongitudeKeyString] as? CLLocationDegrees,\n        let spanLatitude = userInfo?[NSUserActivity.regionSpanLatitudeKeyString] as? CLLocationDegrees,\n        let spanLongitude = userInfo?[NSUserActivity.regionSpanLongitudeKeyString] as? CLLocationDegrees else {\n            return nil\n    }\n    return MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: centerLatitude,\n                                                             longitude: centerLongitude),\n                              span: MKCoordinateSpan(latitudeDelta: spanLatitude,\n                                                     longitudeDelta: spanLongitude))\n}\n```\n\nIn the case of the store-editing activity, the view controller also retrieves the store’s URL and location coordinates from the `userInfo`. The app waits until the map adds a `MKAnnotationView` for the store being edited, so it knows where to anchor the popover.\n\n### Update the Original Device’s State (Optional)\n\nThe `NSUserActivity` class has a `delegate` property of type `NSUserActivityDelegate`. This notifies the originating device when you continue an activity on another device. The originating device can use this to clean up its own UI state.\n\nIn the sample app, tapping a pin for an Apple Store shows a popover with details about the store and a switch (iOS) or checkbox (macOS) to mark the store as a favorite. The `MapViewContoller` represents this activity as the `storeEditingActivity` property, and sets itself as the activity’s delegate. When you continue editing on a second device, the delegate on the originating device receives a notification that this activity has been continued, and dismisses its own popover.\n\n```swift\nfunc userActivityWasContinued(_ userActivity: NSUserActivity) {\n    DispatchQueue.main.async {[weak self] in\n        if let detailVC = self?.presentedViewController as? StoreDetailViewController,\n           userActivity.activityType == NSUserActivity.storeEditingActivityType {\n            detailVC.dismiss(animated: true)\n        }\n    }\n}\n```\n\n\n\n## Activity Sharing\n\n- **Implementing Handoff in Your App**: Create, send, and receive user activities directly.\n- **NSUserActivity**: A representation of the state of your app at a moment in time.\n- **NSUserActivityDelegate**: The interface through which a user activity instance notifies its delegate of updates.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create, send, and receive user activities directly.",
          "name" : "Implementing Handoff in Your App",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/implementing-handoff-in-your-app"
        },
        {
          "description" : "A representation of the state of your app at a moment in time.",
          "name" : "NSUserActivity",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSUserActivity"
        },
        {
          "description" : "The interface through which a user activity instance notifies its delegate of updates.",
          "name" : "NSUserActivityDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NSUserActivityDelegate"
        }
      ],
      "title" : "Activity Sharing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Continuing User Activities with Handoff",
  "url" : "https:\/\/developer.apple.com\/documentation\/foundation\/task_management\/continuing_user_activities_with_handoff"
}