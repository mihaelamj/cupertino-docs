{
  "abstract" : "Use a chain of asynchronous operators to receive and process data fetched from a URL.",
  "codeExamples" : [
    {
      "code" : "struct User: Codable {\n    let name: String\n    let userID: String\n}\nlet url = URL(string: \"https:\/\/example.com\/endpoint\")!\ncancellable = urlSession\n    .dataTaskPublisher(for: url)\n    .tryMap() { element -> Data in\n        guard let httpResponse = element.response as? HTTPURLResponse,\n            httpResponse.statusCode == 200 else {\n                throw URLError(.badServerResponse)\n            }\n        return element.data\n        }\n    .decode(type: User.self, decoder: JSONDecoder())\n    .sink(receiveCompletion: { print (\"Received completion: \\($0).\") },\n          receiveValue: { user in print (\"Received user: \\(user).\")})",
      "language" : "swift"
    },
    {
      "code" : "let pub = urlSession\n    .dataTaskPublisher(for: url)\n    .retry(1)\n    .catch() { _ in\n        self.fallbackUrlSession.dataTaskPublisher(for: fallbackURL)\n    }\ncancellable = pub\n    .sink(receiveCompletion: { print(\"Received completion: \\($0).\") },\n          receiveValue: { print(\"Received data: \\($0.data).\") })",
      "language" : "swift"
    },
    {
      "code" : "cancellable = urlSession\n    .dataTaskPublisher(for: url)\n    .receive(on: DispatchQueue.main)\n    .sink(receiveCompletion: { print (\"Received completion: \\($0).\") },\n          receiveValue: { print (\"Received data: \\($0.data).\")})",
      "language" : "swift"
    },
    {
      "code" : "let sharedPublisher = urlSession\n    .dataTaskPublisher(for: url)\n    .share()\n\ncancellable1 = sharedPublisher\n    .tryMap() {\n        guard $0.data.count > 0 else { throw URLError(.zeroByteResource) }\n        return $0.data\n    }\n    .decode(type: User.self, decoder: JSONDecoder())\n    .receive(on: DispatchQueue.main)\n    .sink(receiveCompletion: { print (\"Received completion 1: \\($0).\") },\n          receiveValue: { print (\"Received id: \\($0.userID).\")})\n\ncancellable2 = sharedPublisher\n    .map() {\n        $0.response\n    }\n    .sink(receiveCompletion: { print (\"Received completion 2: \\($0).\") },\n           receiveValue: { response in\n            if let httpResponse = response as? HTTPURLResponse {\n                print (\"Received HTTP status: \\(httpResponse.statusCode).\")\n            } else {\n                print (\"Response was not an HTTPURLResponse.\")\n            }\n    }\n)\n",
      "language" : "swift"
    }
  ],
  "contentHash" : "5962150456fceae45c134d829853894cf95c86ae1cf1e33b000cca41198e0585",
  "crawledAt" : "2025-12-04T19:02:09Z",
  "id" : "2A0FE4F1-8F23-482A-99A9-80203A051D82",
  "kind" : "article",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nPerforming tasks with URL sessions is inherently asynchronous; it takes time to fetch data from network endpoints, file systems, and other URL-based sources. The URL Loading System accounts for this by delivering results asynchronously to delegates or completion handlers. The [doc:\/\/com.apple.documentation\/documentation\/Combine] framework also handles asynchronicity; using it to process your URL task results simplifies and empowers your code.\n\n### Create a data task publisher\n\n[doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] offers a Combine publisher, [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], which publishes the results of fetching data from a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL] or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLRequest]. You create this publisher with the method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/dataTaskPublisher(for:)-5kiir]. When the task completes, it publishes either:\n\nUnlike the completion handler passed to [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/dataTask(with:completionHandler:)-52wk8], the types received by your code aren’t optionals, since the publisher has already unwrapped the data or error.\n\nWhen using [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]’s completion handler-based code, you need to do all your work in the handler closure: error-handling, data parsing, and so on. When you instead use the data task publisher, you can move many of these responsibilities to Combine operators.\n\n### Convert incoming raw data to your types with Combine operators\n\nWhen a data task completes successfully, it delivers a block of raw [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Data] to your app. Most apps need to convert this data to their own types. Combine provides operators to perform these conversions, allowing you to declare a chain of processing operations.\n\nThe data task publisher produces a tuple that contains a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Data] and a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLResponse]. You can use the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/map(_:)-99evh] operator to convert the contents of this tuple to another type. If you want to inspect the response before inspecing the data, use [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/tryMap(_:)] and throw an error if the response is unacceptable.\n\nTo convert raw data to your own types that conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocol, use Combine’s [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/decode(type:decoder:)] operator.\n\nThe following example combines both these operators to parse JSON data from a URL endpoint into a custom `User` type:\n\n### Retry transient errors and catch and replace persistent errors\n\nAny app that uses the network should expect to encounter errors, and your app should handle them gracefully. Because transient network errors are fairly common, you may want to immediately retry a failed data task. With [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]‘s completion handler idiom, you need to create a whole new task to perform a retry. With the data task publisher, you can instead use Combine’s [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/retry(_:)] operator. This handles errors by recreating the subscription to the upstream publisher a specified number of times. However, since network operations are expensive, only retry a small number of times, and ensure all requests are idempotent.\n\nYou can also use Combine operators to replace the error, rather than letting it reach the subscriber:\n\nThe following example shows both of these techniques, retrying a failed request once, and using a fallback URL after that. If either the original request, the retry, or the fallback request succeeds, the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/sink(receiveValue:)] operator receives data from the endpoint. If all three fail, the sink receives a [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscribers\/Completion\/failure(_:)].\n\n### Move work between dispatch queues with scheduling operators\n\nWhen using [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]’s delegate and completion handler idioms, the session calls back to your code on a fixed [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/delegateQueue]. Sometimes, this means your callback code has to manually use dispatch queues or other scheduling APIs to put work on a specific queue.\n\nWith [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], you can use Combine’s scheduling operators instead. Use [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/receive(on:options:)] to specify how you want later operators in the chain and your subscriber, to schedule the work. [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/DispatchQueue] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/RunLoop] both implement Combine’s [doc:\/\/com.apple.documentation\/documentation\/Combine\/Scheduler] protocol, so you can use them to receive URL session data. The following snippet ensures that the sink logs its results on the main dispatch queue.\n\n### Share the result of a data task publisher with multiple subscribers\n\nYou may want to use data from the URL endpoint in different parts of your application. Because network requests are expensive, don’t reissue them needlessly. Combine lets you use multiple subscribers to a single [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], while allowing the publisher to service all of them with a single request.\n\nTo support multiple downstream subscribers, use the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()] operator. This operator works like a combination of the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publishers\/Multicast] and [doc:\/\/com.apple.documentation\/documentation\/Combine\/PassthroughSubject] publishers. You can connect multiple operator chains or subscribers to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()] operator, and any upstream publisher only sees one downstream. In the case of a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], this means it only performs the data task once.\n\nThe following example uses a URL session data task for two unrelated purposes. One subscriber uses the returned data to parse the custom `User` type seen earlier, and logs it on the main dispatch queue. A second subscriber is only concerned with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLResponse], which it inspects to print an HTTP status code, and doesn’t care which queue it uses. By using [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()], the data task publisher can serve both subscribers with a single load from the URL endpoint.\n\nTo prove that this code only loads the data once, temporarily put a [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/print(_:to:)] debugging operator before the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()] operator. When the app runs, Xcode’s console output shows it receives only a single value from the data task publisher, even though both subscribers receive their expected results.\n\nBe aware that the URL session starts loading data as soon as the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher] has unsatisfied demand from a downstream subscriber. In this case, that happens when the first sink subscriber attaches. If you need extra time to attach other subscribers, use [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/makeConnectable()] to wrap the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publishers\/Share] publisher with a [doc:\/\/com.apple.documentation\/documentation\/Combine\/ConnectablePublisher]. After connecting all subscribers, call [doc:\/\/com.apple.documentation\/documentation\/Combine\/ConnectablePublisher\/connect()] on the connectable publisher to allow the data load to begin.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Foundation\/processing-url-session-data-task-results-with-combine\ncrawled: 2025-12-04T19:02:09Z\n---\n\n# Processing URL session data task results with Combine\n\n**Article**\n\nUse a chain of asynchronous operators to receive and process data fetched from a URL.\n\n## Overview\n\nPerforming tasks with URL sessions is inherently asynchronous; it takes time to fetch data from network endpoints, file systems, and other URL-based sources. The URL Loading System accounts for this by delivering results asynchronously to delegates or completion handlers. The [doc:\/\/com.apple.documentation\/documentation\/Combine] framework also handles asynchronicity; using it to process your URL task results simplifies and empowers your code.\n\n### Create a data task publisher\n\n[doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession] offers a Combine publisher, [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], which publishes the results of fetching data from a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URL] or [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLRequest]. You create this publisher with the method [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/dataTaskPublisher(for:)-5kiir]. When the task completes, it publishes either:\n\n- A tuple that contains the fetched data and a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLResponse], if the task succeeds.\n- An error, if the task fails.\n\nUnlike the completion handler passed to [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/dataTask(with:completionHandler:)-52wk8], the types received by your code aren’t optionals, since the publisher has already unwrapped the data or error.\n\nWhen using [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]’s completion handler-based code, you need to do all your work in the handler closure: error-handling, data parsing, and so on. When you instead use the data task publisher, you can move many of these responsibilities to Combine operators.\n\n### Convert incoming raw data to your types with Combine operators\n\nWhen a data task completes successfully, it delivers a block of raw [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Data] to your app. Most apps need to convert this data to their own types. Combine provides operators to perform these conversions, allowing you to declare a chain of processing operations.\n\nThe data task publisher produces a tuple that contains a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Data] and a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLResponse]. You can use the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/map(_:)-99evh] operator to convert the contents of this tuple to another type. If you want to inspect the response before inspecing the data, use [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/tryMap(_:)] and throw an error if the response is unacceptable.\n\nTo convert raw data to your own types that conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Decodable] protocol, use Combine’s [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/decode(type:decoder:)] operator.\n\nThe following example combines both these operators to parse JSON data from a URL endpoint into a custom `User` type:\n\n```swift\nstruct User: Codable {\n    let name: String\n    let userID: String\n}\nlet url = URL(string: \"https:\/\/example.com\/endpoint\")!\ncancellable = urlSession\n    .dataTaskPublisher(for: url)\n    .tryMap() { element -> Data in\n        guard let httpResponse = element.response as? HTTPURLResponse,\n            httpResponse.statusCode == 200 else {\n                throw URLError(.badServerResponse)\n            }\n        return element.data\n        }\n    .decode(type: User.self, decoder: JSONDecoder())\n    .sink(receiveCompletion: { print (\"Received completion: \\($0).\") },\n          receiveValue: { user in print (\"Received user: \\(user).\")})\n```\n\n### Retry transient errors and catch and replace persistent errors\n\nAny app that uses the network should expect to encounter errors, and your app should handle them gracefully. Because transient network errors are fairly common, you may want to immediately retry a failed data task. With [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]‘s completion handler idiom, you need to create a whole new task to perform a retry. With the data task publisher, you can instead use Combine’s [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/retry(_:)] operator. This handles errors by recreating the subscription to the upstream publisher a specified number of times. However, since network operations are expensive, only retry a small number of times, and ensure all requests are idempotent.\n\nYou can also use Combine operators to replace the error, rather than letting it reach the subscriber:\n\n- [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/catch(_:)] replaces the error with another publisher. You can use this with another [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], such as one that loads data from a fallback URL.\n- [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/replaceError(with:)] replaces the error with an element you provide. If it makes sense in your application, you can use this to provide a substitute for the value you expected to load from the URL.\n\nThe following example shows both of these techniques, retrying a failed request once, and using a fallback URL after that. If either the original request, the retry, or the fallback request succeeds, the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/sink(receiveValue:)] operator receives data from the endpoint. If all three fail, the sink receives a [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscribers\/Completion\/failure(_:)].\n\n```swift\nlet pub = urlSession\n    .dataTaskPublisher(for: url)\n    .retry(1)\n    .catch() { _ in\n        self.fallbackUrlSession.dataTaskPublisher(for: fallbackURL)\n    }\ncancellable = pub\n    .sink(receiveCompletion: { print(\"Received completion: \\($0).\") },\n          receiveValue: { print(\"Received data: \\($0.data).\") })\n```\n\n### Move work between dispatch queues with scheduling operators\n\nWhen using [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession]’s delegate and completion handler idioms, the session calls back to your code on a fixed [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/delegateQueue]. Sometimes, this means your callback code has to manually use dispatch queues or other scheduling APIs to put work on a specific queue.\n\nWith [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], you can use Combine’s scheduling operators instead. Use [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/receive(on:options:)] to specify how you want later operators in the chain and your subscriber, to schedule the work. [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/DispatchQueue] and [doc:\/\/com.apple.foundation\/documentation\/Foundation\/RunLoop] both implement Combine’s [doc:\/\/com.apple.documentation\/documentation\/Combine\/Scheduler] protocol, so you can use them to receive URL session data. The following snippet ensures that the sink logs its results on the main dispatch queue.\n\n```swift\ncancellable = urlSession\n    .dataTaskPublisher(for: url)\n    .receive(on: DispatchQueue.main)\n    .sink(receiveCompletion: { print (\"Received completion: \\($0).\") },\n          receiveValue: { print (\"Received data: \\($0.data).\")})\n```\n\n### Share the result of a data task publisher with multiple subscribers\n\nYou may want to use data from the URL endpoint in different parts of your application. Because network requests are expensive, don’t reissue them needlessly. Combine lets you use multiple subscribers to a single [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], while allowing the publisher to service all of them with a single request.\n\nTo support multiple downstream subscribers, use the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()] operator. This operator works like a combination of the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publishers\/Multicast] and [doc:\/\/com.apple.documentation\/documentation\/Combine\/PassthroughSubject] publishers. You can connect multiple operator chains or subscribers to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()] operator, and any upstream publisher only sees one downstream. In the case of a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher], this means it only performs the data task once.\n\nThe following example uses a URL session data task for two unrelated purposes. One subscriber uses the returned data to parse the custom `User` type seen earlier, and logs it on the main dispatch queue. A second subscriber is only concerned with the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLResponse], which it inspects to print an HTTP status code, and doesn’t care which queue it uses. By using [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()], the data task publisher can serve both subscribers with a single load from the URL endpoint.\n\n```swift\nlet sharedPublisher = urlSession\n    .dataTaskPublisher(for: url)\n    .share()\n\ncancellable1 = sharedPublisher\n    .tryMap() {\n        guard $0.data.count > 0 else { throw URLError(.zeroByteResource) }\n        return $0.data\n    }\n    .decode(type: User.self, decoder: JSONDecoder())\n    .receive(on: DispatchQueue.main)\n    .sink(receiveCompletion: { print (\"Received completion 1: \\($0).\") },\n          receiveValue: { print (\"Received id: \\($0.userID).\")})\n\ncancellable2 = sharedPublisher\n    .map() {\n        $0.response\n    }\n    .sink(receiveCompletion: { print (\"Received completion 2: \\($0).\") },\n           receiveValue: { response in\n            if let httpResponse = response as? HTTPURLResponse {\n                print (\"Received HTTP status: \\(httpResponse.statusCode).\")\n            } else {\n                print (\"Response was not an HTTPURLResponse.\")\n            }\n    }\n)\n\n```\n\nTo prove that this code only loads the data once, temporarily put a [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/print(_:to:)] debugging operator before the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/share()] operator. When the app runs, Xcode’s console output shows it receives only a single value from the data task publisher, even though both subscribers receive their expected results.\n\nBe aware that the URL session starts loading data as soon as the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/URLSession\/DataTaskPublisher] has unsatisfied demand from a downstream subscriber. In this case, that happens when the first sink subscriber attaches. If you need extra time to attach other subscribers, use [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publisher\/makeConnectable()] to wrap the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Publishers\/Share] publisher with a [doc:\/\/com.apple.documentation\/documentation\/Combine\/ConnectablePublisher]. After connecting all subscribers, call [doc:\/\/com.apple.documentation\/documentation\/Combine\/ConnectablePublisher\/connect()] on the connectable publisher to allow the data load to begin.\n\n## Performing tasks as a Combine Publisher\n\n- **dataTaskPublisher(for:)**: Returns a publisher that wraps a URL session data task for a given URL request.\n- **dataTaskPublisher(for:)**: Returns a publisher that wraps a URL session data task for a given URL.\n- **URLSession.DataTaskPublisher**: A publisher that delivers the results of performing URL session data tasks.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Returns a publisher that wraps a URL session data task for a given URL request.",
          "name" : "dataTaskPublisher(for:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLSession\/dataTaskPublisher(for:)-61v3e"
        },
        {
          "description" : "Returns a publisher that wraps a URL session data task for a given URL.",
          "name" : "dataTaskPublisher(for:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLSession\/dataTaskPublisher(for:)-5kiir"
        },
        {
          "description" : "A publisher that delivers the results of performing URL session data tasks.",
          "name" : "URLSession.DataTaskPublisher",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/URLSession\/DataTaskPublisher"
        }
      ],
      "title" : "Performing tasks as a Combine Publisher"
    }
  ],
  "source" : "appleJSON",
  "title" : "Processing URL session data task results with Combine",
  "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/processing-url-session-data-task-results-with-combine"
}