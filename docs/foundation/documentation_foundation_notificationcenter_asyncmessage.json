{
  "abstract" : "A protocol for creating types that you can post to a notification center, which posts them to an arbitrary isolation.",
  "codeExamples" : [
    {
      "code" : "struct EventDidStart: NotificationCenter.AsyncMessage {\n    typealias Subject = Event\n}",
      "language" : "swift"
    },
    {
      "code" : "extension NotificationCenter.MessageIdentifier where Self == NotificationCenter.BaseMessageIdentifier<EventDidStart> {\n    static var didStart: Self { .init() }\n}",
      "language" : "swift"
    },
    {
      "code" : "let observerToken = NotificationCenter.default.addObserver(of: importantEvent, for: .didStart)",
      "language" : "swift"
    },
    {
      "code" : "let observerToken = NotificationCenter.default.addObserver(of: Event.self, for: .didStart)",
      "language" : "swift"
    },
    {
      "code" : "NotificationCenter.default.removeObserver(observerToken)",
      "language" : "swift"
    },
    {
      "code" : "struct EventDidFinish: NotificationCenter.AsyncMessage {\n    typealias Subject = Event\n    static var name: Notification.Name { Notification.Name(\"eventDidFinish\") }\n\n    var duration: Int\n\n    static func makeNotification(_ message: Self) -> Notification {\n        return Notification(name: Self.name, userInfo: [\"duration\": NSNumber(message.duration)])\n    }\n\n    static func makeMessage(_ notification: Notification) -> Self? {\n        guard let userInfo = notification.userInfo,\n              let duration = userInfo[\"duration\"] as? Int\n        else {\n            return nil\n        }\n\n        return Self(duration: duration)\n    }\n}",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "Bundle.DidLoadMessage",
    "Calendar.CalendarDayChangedMessage",
    "FileHandle.ConnectionAcceptedMessage",
    "FileHandle.DataAvailableMessage",
    "FileHandle.ReadCompletionMessage",
    "FileHandle.ReadToEndOfFileCompletionMessage",
    "HTTPCookieStorage.CookiesChangedMessage",
    "NSBundleResourceRequest.LowDiskSpaceMessage",
    "NSMetadataQuery.DidFinishGatheringMessage",
    "NSMetadataQuery.DidStartGatheringMessage",
    "Port.DidBecomeInvalidMessage",
    "Process.DidTerminateMessage",
    "ProcessInfo.PowerStateDidChangeMessage",
    "ProcessInfo.ThermalStateDidChangeMessage",
    "UserDefaults.DidChangeMessage"
  ],
  "contentHash" : "56a4b2608d93dae12457ffaa03cd2b3d763cbced122a8ab341abd77ba803ca4c",
  "crawledAt" : "2025-12-06T02:12:05Z",
  "declaration" : {
    "code" : "protocol AsyncMessage : Sendable",
    "language" : "swift"
  },
  "id" : "F1A8591F-A7E7-41C5-8C0C-C47BAC70EAB7",
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Foundation",
  "overview" : "## Overview\n\nYou post types conforming to `AsyncMessage` to a notification center using `post(_:subject:)` and observe them with `addObserver(of:for:using:)`.\n\nThe notification center delivers `AsyncMessage` types asynchronously when posted. Asynchronous delivery isn’t suitable for messages with time-critical deliveries, such as a message that must have its observers called before a certain action takes place.\n\nFor types that post on the main actor, use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/MainActorMessage].\n\nEach `AsyncMessage` is associated with a specific `Subject` type.\n\nFor example, an `AsyncMessage` associated with the type `Event` could use the following declaration:\n\n`AsyncMessage` can use an optional [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/MessageIdentifier] type for context-aware observer registration:\n\nWith this identifier, observers can receive information about a specific instance by registering for this message with a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter]:\n\nOr an observer can receive information about any instance with:\n\nThe notification center ties observation the lifetime of the returned [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/ObservationToken] and automatically de-registers the observer if the token goes out of scope. You can also remove observation explicitly:\n\n### Notification Interoperability\n\n`AsyncMessage` includes optional interoperability with [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification], enabling posters and observers of both types to pass information.\n\nIt does this by offering a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/makeMessage(_:)] method that collects values from a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification]‘s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/userInfo] and populates properties on a new message. In the other direction, a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/makeNotification(_:)] method collects the message’s defined properties and loads them into a new notification’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/userInfo] dictionary.\n\nFor example, if there exists a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification] posted on an arbitrary isolation identified by the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/Name-swift.typealias] `\"eventDidFinish\"` with a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/userInfo] dictionary containing the key `\"duration\"` as an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSNumber], an app could post and observe the notification with the following [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/AsyncMessage]:\n\nWith this definition, an observer for this `AsyncMessage` type receives information even if the poster used the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification] equivalent, and vice versa.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/foundation\/notificationcenter\/asyncmessage\ncrawled: 2025-12-06T02:12:05Z\n---\n\n# NotificationCenter.AsyncMessage\n\n**Protocol**\n\nA protocol for creating types that you can post to a notification center, which posts them to an arbitrary isolation.\n\n## Declaration\n\n```swift\nprotocol AsyncMessage : Sendable\n```\n\n## Overview\n\nYou post types conforming to `AsyncMessage` to a notification center using `post(_:subject:)` and observe them with `addObserver(of:for:using:)`.\n\nThe notification center delivers `AsyncMessage` types asynchronously when posted. Asynchronous delivery isn’t suitable for messages with time-critical deliveries, such as a message that must have its observers called before a certain action takes place.\n\nFor types that post on the main actor, use [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/MainActorMessage].\n\nEach `AsyncMessage` is associated with a specific `Subject` type.\n\nFor example, an `AsyncMessage` associated with the type `Event` could use the following declaration:\n\n```swift\nstruct EventDidStart: NotificationCenter.AsyncMessage {\n    typealias Subject = Event\n}\n```\n\n`AsyncMessage` can use an optional [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/MessageIdentifier] type for context-aware observer registration:\n\n```swift\nextension NotificationCenter.MessageIdentifier where Self == NotificationCenter.BaseMessageIdentifier<EventDidStart> {\n    static var didStart: Self { .init() }\n}\n```\n\nWith this identifier, observers can receive information about a specific instance by registering for this message with a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter]:\n\n```swift\nlet observerToken = NotificationCenter.default.addObserver(of: importantEvent, for: .didStart)\n```\n\nOr an observer can receive information about any instance with:\n\n```swift\nlet observerToken = NotificationCenter.default.addObserver(of: Event.self, for: .didStart)\n```\n\nThe notification center ties observation the lifetime of the returned [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/ObservationToken] and automatically de-registers the observer if the token goes out of scope. You can also remove observation explicitly:\n\n```swift\nNotificationCenter.default.removeObserver(observerToken)\n```\n\n### Notification Interoperability\n\n`AsyncMessage` includes optional interoperability with [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification], enabling posters and observers of both types to pass information.\n\nIt does this by offering a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/makeMessage(_:)] method that collects values from a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification]‘s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/userInfo] and populates properties on a new message. In the other direction, a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/makeNotification(_:)] method collects the message’s defined properties and loads them into a new notification’s [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/userInfo] dictionary.\n\nFor example, if there exists a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification] posted on an arbitrary isolation identified by the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/Name-swift.typealias] `\"eventDidFinish\"` with a [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification\/userInfo] dictionary containing the key `\"duration\"` as an [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NSNumber], an app could post and observe the notification with the following [doc:\/\/com.apple.foundation\/documentation\/Foundation\/NotificationCenter\/AsyncMessage]:\n\n```swift\nstruct EventDidFinish: NotificationCenter.AsyncMessage {\n    typealias Subject = Event\n    static var name: Notification.Name { Notification.Name(\"eventDidFinish\") }\n\n    var duration: Int\n\n    static func makeNotification(_ message: Self) -> Notification {\n        return Notification(name: Self.name, userInfo: [\"duration\": NSNumber(message.duration)])\n    }\n\n    static func makeMessage(_ notification: Notification) -> Self? {\n        guard let userInfo = notification.userInfo,\n              let duration = userInfo[\"duration\"] as? Int\n        else {\n            return nil\n        }\n\n        return Self(duration: duration)\n    }\n}\n```\n\nWith this definition, an observer for this `AsyncMessage` type receives information even if the poster used the [doc:\/\/com.apple.foundation\/documentation\/Foundation\/Notification] equivalent, and vice versa.\n\n## Declaring the message name and subject\n\n- **name**: A optional name corresponding to this type, used to interoperate with notification posters and observers.\n- **Subject**: A type which you can optionally post and observe along with this `AsyncMessage`.\n\n## Converting between messages and notifications\n\n- **makeMessage(_:)**: Converts a posted notification into this asynchronous message type for any observers.\n- **makeNotification(_:)**: Converts a posted asynchronous message into a notification for any observers.\n\n## Declaring a message\n\n- **NotificationCenter.MainActorMessage**: A protocol for creating types that you can post to a notification center and bind to the main actor.\n\n## Inherits From\n\n- Sendable\n- SendableMetatype\n\n## Conforming Types\n\n- Bundle.DidLoadMessage\n- Calendar.CalendarDayChangedMessage\n- FileHandle.ConnectionAcceptedMessage\n- FileHandle.DataAvailableMessage\n- FileHandle.ReadCompletionMessage\n- FileHandle.ReadToEndOfFileCompletionMessage\n- HTTPCookieStorage.CookiesChangedMessage\n- NSBundleResourceRequest.LowDiskSpaceMessage\n- NSMetadataQuery.DidFinishGatheringMessage\n- NSMetadataQuery.DidStartGatheringMessage\n- Port.DidBecomeInvalidMessage\n- Process.DidTerminateMessage\n- ProcessInfo.PowerStateDidChangeMessage\n- ProcessInfo.ThermalStateDidChangeMessage\n- UserDefaults.DidChangeMessage\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A optional name corresponding to this type, used to interoperate with notification posters and observers.",
          "name" : "name",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/name"
        },
        {
          "description" : "A type which you can optionally post and observe along with this `AsyncMessage`.",
          "name" : "Subject",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/Subject"
        }
      ],
      "title" : "Declaring the message name and subject"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Converts a posted notification into this asynchronous message type for any observers.",
          "name" : "makeMessage(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/makeMessage(_:)"
        },
        {
          "description" : "Converts a posted asynchronous message into a notification for any observers.",
          "name" : "makeNotification(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NotificationCenter\/AsyncMessage\/makeNotification(_:)"
        }
      ],
      "title" : "Converting between messages and notifications"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A protocol for creating types that you can post to a notification center and bind to the main actor.",
          "name" : "NotificationCenter.MainActorMessage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/NotificationCenter\/MainActorMessage"
        }
      ],
      "title" : "Declaring a message"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "Sendable"
        },
        {
          "name" : "SendableMetatype"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "NotificationCenter.AsyncMessage",
  "url" : "https:\/\/developer.apple.com\/documentation\/foundation\/notificationcenter\/asyncmessage"
}