{
  "abstract" : "Create an interactive mesh with low-level mesh and low-level texture.",
  "codeExamples" : [
    {
      "code" : "struct PlaneVertex {\n    simd_float3 position;\n    simd_float3 normal;\n};",
      "language" : "cpp"
    },
    {
      "code" : "\/\/\/ The number of vertices in each dimension of the plane mesh.\nlet dimensions: SIMD2<UInt32>\n\n...\n\n\/\/\/ Creates a low-level mesh with `PlaneVertex` vertices.\nprivate func createMesh() throws -> LowLevelMesh {\n    \/\/ Define the vertex attributes of `PlaneVertex`.\n    let positionAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.position) ?? 0\n    let normalAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.normal) ?? 16\n    \n    let positionAttribute = LowLevelMesh.Attribute(semantic: .position, format: .float3, offset: positionAttributeOffset)\n    let normalAttribute = LowLevelMesh.Attribute(semantic: .normal, format: .float3, offset: normalAttributeOffset)\n    \n    let vertexAttributes = [positionAttribute, normalAttribute]\n    \n    \/\/ Define the vertex layouts of `PlaneVertex`.\n    let vertexLayouts = [LowLevelMesh.Layout(bufferIndex: 0, bufferStride: MemoryLayout<PlaneVertex>.stride)]\n    \n    \/\/ Derive the vertex and index counts from the dimensions.\n    let vertexCount = Int(dimensions.x * dimensions.y)\n    let indicesPerTriangle = 3\n    let trianglesPerCell = 2\n    let cellCount = Int((dimensions.x - 1) * (dimensions.y - 1))\n    let indexCount = indicesPerTriangle * trianglesPerCell * cellCount\n    \n    \/\/ Create a low-level mesh with the necessary `PlaneVertex` capacity.\n    let meshDescriptor = LowLevelMesh.Descriptor(vertexCapacity: vertexCount,\n                                                 vertexAttributes: vertexAttributes,\n                                                 vertexLayouts: vertexLayouts,\n                                                 indexCapacity: indexCount)\n    return try LowLevelMesh(descriptor: meshDescriptor)\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ComputeUpdateContext {\n    \/\/\/ The number of seconds elapsed since the last frame.\n    let deltaTime: TimeInterval\n    \/\/\/ The command buffer for the current frame.\n    let commandBuffer: MTLCommandBuffer\n    \/\/\/ The compute command encoder for the current frame.\n    let computeEncoder: MTLComputeCommandEncoder\n}",
      "language" : "swift"
    },
    {
      "code" : "class HeightMapMesh: ComputeSystem {\n    ...\n\n    \/\/\/ Updates the height map mesh by generating a height map, deriving normals from it, and then setting the vertex positions and normals.\n    func update(computeContext: ComputeUpdateContext) {\n        ...\n        \n        \/\/ Generate the height map height values.\n        heightMap.generateHeight(computeContext: computeContext, heightMapComputeParams: heightMapComputeParams)\n        \/\/ Update the height map normal directions.\n        heightMap.updateNormals(computeContext: computeContext, heightMapComputeParams: heightMapComputeParams)\n        \n        \/\/ Update the vertex positions and normals.\n        updateVertices(computeContext: computeContext)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct HeightMap {\n    ...\n   \n    \/\/\/ The low-level texture that stores the height and normal information of the height map.\n    var heightMapTexture: LowLevelTexture\n    \n    init(dimensions: SIMD2<UInt32>) throws {\n        \/\/ Initialize the texture with an RGBA pixel format where the alpha channel stores height,\n        \/\/ while the red, green, and blue channels store the surface normal direction.\n        let textureDescriptor = LowLevelTexture.Descriptor(pixelFormat: .rgba32Float,\n                                                           width: Int(dimensions.x),\n                                                           height: Int(dimensions.y),\n                                                           textureUsage: [.shaderRead, .shaderWrite])\n        self.heightMapTexture = try LowLevelTexture(descriptor: textureDescriptor)\n    }\n    \n    ...\n}",
      "language" : "swift"
    },
    {
      "code" : "[[kernel]]\nvoid generateSineWaveHeightMap(texture2d<float, access::read> heightMapIn [[texture(0)]],\n                               texture2d<float, access::write> heightMapOut [[texture(1)]],\n                               constant float &time [[buffer(2)]],\n                               constant float &amplitude [[buffer(3)]],\n                               uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (pixelCoords.x >= heightMapIn.get_width() || pixelCoords.y >= heightMapIn.get_height()) { return; }\n    \n    \/\/ Compute texture coordinates ranging from 0 to 1 along each axis.\n    float2 uv = float2(pixelCoords.x \/ (heightMapIn.get_width() - 1.0),\n                       pixelCoords.y \/ (heightMapIn.get_height() - 1.0));\n    \n    \/\/ Get the distance to the center of the texture in texture coordinate space.\n    float distanceToCenter = length(uv - 0.5);\n    \/\/ Normalize the distance to a range from 0 to 2π along the horizontal and vertical axes.\n    float normalizedDistanceToCenter = (distanceToCenter \/ 0.5) * (2 * M_PI_F);\n\n    \/\/ Get sine as a function of the normalized distance to the center of the texture times the wave count,\n    \/\/ subtracting time to animate it outward over time.\n    float waveCount = 3;\n    float sine = sin(normalizedDistanceToCenter * waveCount - time);\n    \/\/ Convert sine to the range 0 to 1.\n    float sine01 = (sine + 1) \/ 2;\n    \n    \/\/ Generate height from the sine function.\n    float height = amplitude * sine01;\n    \n    \/\/ Read the current height map data.\n    float4 heightMapData = heightMapIn.read(pixelCoords);\n    \/\/ Update the alpha channel with the new height.\n    heightMapData.a = height;\n    \/\/ Write the updated height data to height map.\n    heightMapOut.write(heightMapData, pixelCoords);\n}",
      "language" : "cpp"
    },
    {
      "code" : "class SineWaveHeightMapGenerator: HeightMapGenerator {\n    \/\/\/ Compute pipeline corresponding to the Metal compute shader function `generateSineWaveHeightMap`.\n    \/\/\/\n    \/\/\/ See `SineWaveComputeShader.metal`.\n    private let sineWaveHeightPipeline: MTLComputePipelineState = makeComputePipeline(named: \"generateSineWaveHeightMap\")!\n    \n    \/\/\/ The number of seconds elapsed since the person reset this generator.\n    private var time: Float = 0\n    \n    \/\/\/ The amplitude of the sine wave this generator generates.\n    private var amplitude: Float = 0.05\n\n    ...\n    \n    \/\/\/ Dispatches a Metal compute shader to generate a height map in the shape of a sine wave.\n    func generateHeightMap(computeContext: ComputeUpdateContext,\n                           heightMapTexture: LowLevelTexture,\n                           heightMapComputeParams: HeightMapComputeParams) {\n        \/\/ Get deltaTime.\n        let deltaTime = Float(computeContext.deltaTime)\n        \/\/ Get the command buffer and compute encoder.\n        let commandBuffer = computeContext.commandBuffer\n        let computeEncoder = computeContext.computeEncoder\n        \/\/ Get the threadgroups.\n        let threadgroups = heightMapComputeParams.threadgroups\n        let threadsPerThreadgroup = heightMapComputeParams.threadsPerThreadgroup\n        \n        \/\/ Increment time.\n        time += deltaTime\n        \n        \/\/ Set the compute shader pipeline to `generateSineWaveHeightMap`.\n        computeEncoder.setComputePipelineState(sineWaveHeightPipeline)\n        \n        \/\/ Pass a readable version of the height map texture to the compute shader.\n        computeEncoder.setTexture(heightMapTexture.read(), index: 0)\n        \/\/ Pass a writable version of the height map texture to the compute shader.\n        computeEncoder.setTexture(heightMapTexture.replace(using: commandBuffer), index: 1)\n        \n        \/\/ Pass the time to the compute shader.\n        computeEncoder.setBytes(&time, length: MemoryLayout<Float>.size, index: 2)\n        \/\/ Pass the amplitude to the compute shader.\n        computeEncoder.setBytes(&amplitude, length: MemoryLayout<Float>.size, index: 3)\n        \n        \/\/ Dispatch the compute shader.\n        computeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ The device Metal selects as the default.\nlet metalDevice: MTLDevice? = MTLCreateSystemDefaultDevice()\n\n...\n\n\/\/\/ Makes a compute pipeline for the compute function with the given name.\nfunc makeComputePipeline(named name: String) -> MTLComputePipelineState? {\n    guard let function = metalDevice?.makeDefaultLibrary()?.makeFunction(name: name) else {\n        return nil\n    }\n    return try? metalDevice?.makeComputePipelineState(function: function)\n}",
      "language" : "swift"
    },
    {
      "code" : "protocol HeightMapGenerator {\n    \/\/\/ Resets the height map.\n    func reset()\n    \n    \/\/\/ Generates the height map.\n    func generateHeightMap(computeContext: ComputeUpdateContext,\n                           heightMapTexture: LowLevelTexture,\n                           heightMapComputeParams: HeightMapComputeParams)\n}",
      "language" : "swift"
    },
    {
      "code" : "struct HeightMap {\n    ...\n    \n    \/\/\/ The generator that generates the height values of the height map.\n    var heightMapGenerator: HeightMapGenerator = SineWaveHeightMapGenerator()\n\n    \/\/\/ The low-level texture that stores the height and normal information of the height map.\n    var heightMapTexture: LowLevelTexture\n    \n    ...\n    \n    \/\/\/ Generates the height values in the alpha channel of the height map using the current `heightMapGenerator`.\n    func generateHeight(computeContext: ComputeUpdateContext, heightMapComputeParams: HeightMapComputeParams) {\n        heightMapGenerator.generateHeightMap(computeContext: computeContext,\n                                             heightMapTexture: heightMapTexture,\n                                             heightMapComputeParams: heightMapComputeParams)\n    }\n    \n    ...\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MeshParams {\n    simd_uint2 dimensions;\n    simd_float2 size;\n    float maxVertexDepth;\n};",
      "language" : "cpp"
    },
    {
      "code" : "[[kernel]]\nvoid setVertexData(constant MeshParams &params [[buffer(0)]],\n                   device PlaneVertex *vertices [[buffer(1)]],\n                   texture2d<float, access::read> heightMap [[texture(2)]],\n                   uint2 vertexCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (any(vertexCoords >= params.dimensions)) { return; }\n    \n    \/\/ Calculate the 1D vertex buffer index given its 2D x, y coordinates.\n    uint vertexIndex = vertexCoords.x + params.dimensions.x * vertexCoords.y;\n    \/\/ Get the current vertex.\n    device PlaneVertex &vert = vertices[vertexIndex];\n    \n    \/\/ Sample the height map pixel corresponding to this vertex.\n    float4 heightMapData = heightMap.read(vertexCoords);\n    \/\/ Extract the normal direction and the height.\n    float3 normal = heightMapData.rgb;\n    float height = heightMapData.a;\n    \n    \/\/ Convert the x and y vertex coordinates to the range [0, 1].\n    float2 vertexCoords01 = float2(vertexCoords) \/ float2(params.dimensions - 1);\n    \n    \/\/ Get the x and y position from the size.\n    float2 xyPosition = params.size * vertexCoords01 - params.size \/ 2;\n    \/\/ Get the z position from the height, clamping it within\n    \/\/ the bounds of the mesh that `maxVertexDepth` defines.\n    float zPosition = clamp(height, 0., params.maxVertexDepth);\n    \n    \/\/ Update the vertex position and normal.\n    vert.position = float3(xyPosition, zPosition);\n    vert.normal = normal;\n}",
      "language" : "cpp"
    },
    {
      "code" : "private func updateVertices(computeContext: ComputeUpdateContext) {\n    \/\/ Set the compute shader pipeline to `setVertexData`.\n    computeContext.computeEncoder.setComputePipelineState(setVerticesPipeline)\n    \n    \/\/ Pass the mesh parameters to the compute shader.\n    computeContext.computeEncoder.setBytes(&meshParams, length: MemoryLayout<MeshParams>.size, index: 0)\n    \/\/ Pass the vertex buffer to the compute shader.\n    let vertexBuffer = planeMesh.mesh.replace(bufferIndex: 0, using: computeContext.commandBuffer)\n    computeContext.computeEncoder.setBuffer(vertexBuffer, offset: 0, index: 1)\n    \/\/ Pass the height map to the compute shader.\n    computeContext.computeEncoder.setTexture(heightMap.heightMapTexture.read(), index: 2)\n    \n    \/\/ Dispatch the compute shader.\n    computeContext.computeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)\n}",
      "language" : "swift"
    },
    {
      "code" : "class HeightMapMeshEntity: Entity, HasModel {\n    \/\/\/ The height map mesh this entity renders.\n    var heightMapMesh: HeightMapMesh?\n    \n    \/\/\/ Sets up the entity by creating a `HeightMapMesh` and adding the necessary components.\n    private func setup(size: SIMD2<Float>, dimensions: SIMD2<UInt32>, maxVertexDepth: Float) {\n        \/\/ Try to create a `HeightMapMesh` and get its low-level mesh.\n        guard let heightMapMesh = try? HeightMapMesh(size: size, dimensions: dimensions, maxVertexDepth: maxVertexDepth),\n              let planeMesh = try? MeshResource(from: heightMapMesh.planeMesh.mesh) else {\n            assertionFailure(\"Failed to create height map mesh and get its low-level mesh.\")\n            return\n        }\n        self.heightMapMesh = heightMapMesh\n        \n        \/\/ Add a compute system component with the height map mesh as its compute system.\n        self.components.set(ComputeSystemComponent(computeSystem: heightMapMesh))\n\n        \/\/ Add a model component with the plane mesh.\n        self.components.set(ModelComponent(mesh: planeMesh, materials: [SimpleMaterial()]))\n\n        \/\/ Make this entity capable of receiving gestures by giving it an input target component and a collider.\n        self.components.set(InputTargetComponent())\n        let collisionBoxDepth: Float = 0.025\n        let collisionBox = ShapeResource.generateBox(width: size.x, height: size.y, depth: collisionBoxDepth)\n            .offsetBy(translation: [0, 0, -collisionBoxDepth \/ 2])\n        self.components.set(CollisionComponent(shapes: [collisionBox]))\n    }\n    \n    \/\/\/ The custom initializer.\n    \/\/\/\n    \/\/\/ Sets up the `heightMapMesh` with given size, dimensions, and maximum vertex depth.\n    init(size: SIMD2<Float>, dimensions: SIMD2<UInt32>, maxVertexDepth: Float) {\n        super.init()\n        setup(size: size, dimensions: dimensions, maxVertexDepth: maxVertexDepth)\n    }\n    \n    \/\/\/ The default initializer.\n    required init() {\n        super.init()\n        setup(size: [1, 1], dimensions: [512, 512], maxVertexDepth: 1)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : ".gesture(\n    DragGesture()\n        .targetedToEntity(heightMapMeshEntity)\n        .onChanged({ value in\n            let interactionPosition = value.convert(value.location3D,\n                                                    from: .local,\n                                                    to: heightMapMeshEntity)\n            heightMapMeshEntity.heightMapMesh?.interactionPosition = interactionPosition\n            heightMapMeshEntity.heightMapMesh?.isInteractionHappening = true\n        })\n        .onEnded({ value in\n            heightMapMeshEntity.heightMapMesh?.isInteractionHappening = false\n        })\n)",
      "language" : "swift"
    },
    {
      "code" : "struct WaterParams {\n    float deltaTime;\n    float waterSpeed;\n    simd_float2 disturbancePosition;\n    float disturbanceRadius;\n    float disturbanceAmount;\n    simd_uint2 dimensions;\n    simd_float2 size;\n    simd_float2 cellSize;\n};",
      "language" : "cpp"
    },
    {
      "code" : "class WaterSurfaceHeightMapGenerator: HeightMapGenerator {\n    ...\n\n    \/\/ Disturbs the water surface by dispatching a compute shader that increases\/decreases the height\n    \/\/ of the water around the disturbance position.\n    func disturbWaterSurface(computeContext: ComputeUpdateContext,\n                             heightMapTexture: LowLevelTexture,\n                             heightMapComputeParams: HeightMapComputeParams,\n                             waterParams: inout WaterParams) {\n        \/\/ Dispatch the disturbance compute function.\n        computeContext.computeEncoder.setComputePipelineState(disturbWaterSurfacePipeline)\n        computeContext.computeEncoder.setBytes(&waterParams, length: MemoryLayout<WaterParams>.size, index: 0)\n        computeContext.computeEncoder.setTexture(heightMapTexture.read(), index: 1)\n        computeContext.computeEncoder.setTexture(heightMapTexture.replace(using: computeContext.commandBuffer), index: 2)\n        computeContext.computeEncoder.dispatchThreadgroups(heightMapComputeParams.threadgroups,\n                                                           threadsPerThreadgroup: heightMapComputeParams.threadsPerThreadgroup)\n    }\n    \n    ...\n    \n    func generateHeightMap(computeContext: ComputeUpdateContext,\n                           heightMapTexture: LowLevelTexture,\n                           heightMapComputeParams: HeightMapComputeParams) {\n        ...\n        \n        \/\/ Disturb the water surface downward at the position the person is interacting with it,\n        \/\/ if an interaction is happening.\n        if heightMapComputeParams.isInteractionHappening {\n            waterParams.disturbancePosition = simd_make_float2(heightMapComputeParams.interactionPosition)\n            waterParams.disturbanceRadius = 7 * waterParams.cellSize.x\n            waterParams.disturbanceAmount = 250 * waterParams.cellSize.x * waterParams.deltaTime\n            disturbWaterSurface(computeContext: computeContext,\n                                heightMapTexture: heightMapTexture,\n                                heightMapComputeParams: heightMapComputeParams,\n                                waterParams: &waterParams)\n        }\n        \n        ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "[[kernel]]\nvoid disturbWaterSurface(constant WaterParams &params [[buffer(0)]],\n                         texture2d<float, access::read> heightMapIn [[texture(1)]],\n                         texture2d<float, access::write> heightMapOut [[texture(2)]],\n                         uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (any(pixelCoords >= params.dimensions)) { return; }\n\n    \/\/ Get the current state of the height map.\n    float4 heightMapData = heightMapIn.read(pixelCoords);\n    \n    \/\/ Convert the position of the current pixel to the same coordinate space as the disturbance position.\n    float2 currentPosition = float2(remap(pixelCoords.x, float2(0, params.dimensions.x - 1), float2(-params.size.x \/ 2, params.size.x \/ 2)),\n                                    remap(pixelCoords.y, float2(0, params.dimensions.y - 1), float2(-params.size.y \/ 2, params.size.y \/ 2)));\n    \/\/ Disturb the height of the water closer to the disturbance position.\n    float distance = length(currentPosition-params.disturbancePosition);\n    if (distance <= params.disturbanceRadius) {\n        heightMapData.a -= params.disturbanceAmount * pow((params.disturbanceRadius-distance)\/(params.disturbanceRadius), 2);\n    }\n    \n    \/\/ Write modified height map data back to the height map.\n    heightMapOut.write(heightMapData, pixelCoords);\n}",
      "language" : "cpp"
    }
  ],
  "contentHash" : "1611644efe0a992babe2d2399b2fbb3fc90f20f3780e359e0850f03709e1ce0f",
  "crawledAt" : "2025-12-02T20:15:01Z",
  "id" : "6CD768EB-4C7B-485C-B385-6BDED267EBE0",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nThis sample app demonstrates how to create geometry that moves and changes shape in real time—to simulate the appearance of fabric, terrain, or water, for example, like in the following images:\n\nTo create dynamic, interactive geometry, the app leverages low-level meshes and textures. Using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh] and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture] types, you can customize their data layouts and update their contents directly in real time with Metal compute shaders. You define the compute shaders and the types they operate on using [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf] (MSL), which is a derivative of C++.\n\nThe app starts by generating a plane mesh with [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh], and it reconfigures the vertices within that mesh by reading data from a low-level texture that stores its height and normal map. As the app runs, it updates both the mesh and texture on the GPU in every frame. The sample demonstrates three unique height map generation functions, including a sine wave that oscillates outward over time, as well as a terrain editor and a water simulation that each respond to a person’s input.\n\n## Define a custom vertex structure\n\nThe sample defines the custom vertex data structure for its plane mesh in an MSL header file:\n\nIn this example, the vertex has a 3D position and a 3D normal vector, but you can define your app’s vertex type with different names and other data.\n\n## Create a low-level mesh with a descriptor\n\nThe sample creates the plane low-level mesh by defining its vertex attributes, vertex layouts, and the number of vertices and indices it has capacity for:\n\nIn this case, determining the exact vertex and index capacities of the mesh is straightforward given its dimensions. For more complex meshes, or meshes you add vertices to or remove vertices from at runtime, you can estimate the maximum vertex capacity and resize the mesh if its vertex count ever exceeds that number.\n\nSee [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/creating-a-plane-with-low-level-mesh] for more information on how the sample creates this mesh, including how it fills the mesh’s vertex and index buffers with data, like in the following image:\n\n\n\n## Create a compute shader dispatch system\n\nThe sample defines a custom `ComputeUpdateContext` structure that contains the necessary context for dispatching compute shader functions in every frame:\n\nThe sample dispatches compute shader functions in every frame by passing this structure to each `ComputeSystem` in the app (see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/passing-metal-command-objects-around-your-application]).\n\n`HeightMapMesh` is an example of a `ComputeSystem`. It implements the `ComputeSystem`  protocol’s `update` method to dispatch compute shaders that generate a height map and modify the vertex positions and normals of a mesh in each frame:\n\n## Create a low-level texture height map\n\nThe sample creates a height map with [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture] by specifying its pixel format, dimensions, and usage:\n\nThe low-level texture has the same dimensions as the plane low-level mesh, such that each pixel in the texture corresponds to a vertex in the mesh.\n\n## Write height data to the low-level texture\n\nThe sample writes height data to the low-level texture in every frame on the GPU by dispatching Metal compute shaders. For example, the compute shader function `generateSineWaveHeightMap` writes height values to the texture in the shape of a sine wave moving outward from the center of the texture over time:\n\nThe following video shows the texture the `generateSineWaveHeightMap` compute function creates:\n\nThe sample dispatches this compute shader function in `SineWaveHeightMapGenerator`, passing in both the height map low-level texture, the time, and the amplitude:\n\nThe sample defines the `makeComputePipeline` method as follows:\n\nSee [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/creating-a-dynamic-height-map-with-low-level-texture] for further details, along with a description of how the sample derives surface normal directions from the height map.\n\n## Generate additional height maps\n\nThe sample abstracts the generation of height maps by defining a `HeightMapGenerator` protocol:\n\nYou can adopt this protocol to create custom height map generators. These height map generators can generate custom height maps by dispatching compute shader functions, with the given `computeContext`, that write height data to the alpha channel of the given `heightMapTexture`.\n\nThe following videos show the custom height map textures the `TerrainHeightMapGenerator` and `WaterSurfaceHeightMapGenerator` create:\n\nThe `HeightMap` structure calls the `generateHeightMap` method of its active height map generator, passing in the height map low-level texture and the compute update context necessary to dispatch compute shader functions with the texture:\n\n## Update the mesh vertex data on the GPU\n\nThe sample defines a structure containing the information necessary to update the mesh’s vertex data on the GPU:\n\nThese parameters are suitable for updating the vertices of the plane low-level mesh on the GPU, but you can define parameters that conform to your custom mesh and vertex format. Declare this structure in an MSL header file so that you can send it to the GPU (see [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/passing-structured-data-to-a-metal-compute-function#Import-the-struct-in-a-bridging-header]).\n\nNext, the sample updates the position and normal of each vertex in the low-level mesh with a compute shader function that reads this information from the height map low-level texture:\n\nHere, the `maxVertexDepth` parameter defines the maximum z offset position for vertices, so that they remain within the bounds of the mesh (see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/creating-a-plane-with-low-level-mesh]). You can take your own approach to ensuring your vertices remain within bounds.\n\nThe sample passes the mesh parameters, vertex buffer, and height map to the compute function before dispatching it:\n\n## Display the mesh with an entity\n\nThe sample creates a custom `HeightMapMeshEntity` class with a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent] to display the `HeightMapMesh`:\n\nThe following video shows a `HeightMapMeshEntity` displaying the mesh its `HeightMapMesh` generates with the `SineWaveHeightMapGenerator`.\n\n## Make the mesh and texture interactive\n\nThe sample allows the mesh to respond to a person’s interactions by passing interaction data to the GPU, which uses it to modify the height map, which in turn updates the vertices of the mesh.\n\nTo start, the sample captures the person’s interaction position and state with a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/DragGesture], passing that information to `HeightMapMesh`:\n\n`HeightMapMesh` passes this interaction information to the active `HeightMapGenerator`, which can use it to generate its height map.\n\nFor example, `WaterSurfaceHeightMapGenerator` takes the interaction position and passes it to a compute shader with a custom structure that the sample defines in an MSL header file:\n\nIt dispatches a compute shader to disturb the height of the water at the `interactionPosition` whenever an interaction is happening, by storing the interaction position in this structure’s `disturbancePosition` property:\n\nThe `disturbWaterSurface` compute shader function subtracts height from the height map around the disturbance position, simulating the effect of the person’s interaction pushing the water downward:\n\nThe following video shows the result of using the person’s interaction position to dynamically alter the height map:\n\nThe app uses a similar technique to allow the person to edit the terrain height map, like in the following video:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/realitykit\/generating-interactive-geometry-with-realitykit\ncrawled: 2025-12-02T20:15:01Z\n---\n\n# Generating interactive geometry with RealityKit\n\n**Sample Code**\n\nCreate an interactive mesh with low-level mesh and low-level texture.\n\n## Overview\n\nThis sample app demonstrates how to create geometry that moves and changes shape in real time—to simulate the appearance of fabric, terrain, or water, for example, like in the following images:\n\n\n\nTo create dynamic, interactive geometry, the app leverages low-level meshes and textures. Using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh] and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture] types, you can customize their data layouts and update their contents directly in real time with Metal compute shaders. You define the compute shaders and the types they operate on using [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf] (MSL), which is a derivative of C++.\n\nThe app starts by generating a plane mesh with [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh], and it reconfigures the vertices within that mesh by reading data from a low-level texture that stores its height and normal map. As the app runs, it updates both the mesh and texture on the GPU in every frame. The sample demonstrates three unique height map generation functions, including a sine wave that oscillates outward over time, as well as a terrain editor and a water simulation that each respond to a person’s input.\n\n## Define a custom vertex structure\n\nThe sample defines the custom vertex data structure for its plane mesh in an MSL header file:\n\n```cpp\nstruct PlaneVertex {\n    simd_float3 position;\n    simd_float3 normal;\n};\n```\n\nIn this example, the vertex has a 3D position and a 3D normal vector, but you can define your app’s vertex type with different names and other data.\n\n## Create a low-level mesh with a descriptor\n\nThe sample creates the plane low-level mesh by defining its vertex attributes, vertex layouts, and the number of vertices and indices it has capacity for:\n\n```swift\n\/\/\/ The number of vertices in each dimension of the plane mesh.\nlet dimensions: SIMD2<UInt32>\n\n...\n\n\/\/\/ Creates a low-level mesh with `PlaneVertex` vertices.\nprivate func createMesh() throws -> LowLevelMesh {\n    \/\/ Define the vertex attributes of `PlaneVertex`.\n    let positionAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.position) ?? 0\n    let normalAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.normal) ?? 16\n    \n    let positionAttribute = LowLevelMesh.Attribute(semantic: .position, format: .float3, offset: positionAttributeOffset)\n    let normalAttribute = LowLevelMesh.Attribute(semantic: .normal, format: .float3, offset: normalAttributeOffset)\n    \n    let vertexAttributes = [positionAttribute, normalAttribute]\n    \n    \/\/ Define the vertex layouts of `PlaneVertex`.\n    let vertexLayouts = [LowLevelMesh.Layout(bufferIndex: 0, bufferStride: MemoryLayout<PlaneVertex>.stride)]\n    \n    \/\/ Derive the vertex and index counts from the dimensions.\n    let vertexCount = Int(dimensions.x * dimensions.y)\n    let indicesPerTriangle = 3\n    let trianglesPerCell = 2\n    let cellCount = Int((dimensions.x - 1) * (dimensions.y - 1))\n    let indexCount = indicesPerTriangle * trianglesPerCell * cellCount\n    \n    \/\/ Create a low-level mesh with the necessary `PlaneVertex` capacity.\n    let meshDescriptor = LowLevelMesh.Descriptor(vertexCapacity: vertexCount,\n                                                 vertexAttributes: vertexAttributes,\n                                                 vertexLayouts: vertexLayouts,\n                                                 indexCapacity: indexCount)\n    return try LowLevelMesh(descriptor: meshDescriptor)\n}\n```\n\nIn this case, determining the exact vertex and index capacities of the mesh is straightforward given its dimensions. For more complex meshes, or meshes you add vertices to or remove vertices from at runtime, you can estimate the maximum vertex capacity and resize the mesh if its vertex count ever exceeds that number.\n\nSee [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/creating-a-plane-with-low-level-mesh] for more information on how the sample creates this mesh, including how it fills the mesh’s vertex and index buffers with data, like in the following image:\n\n\n\n## Create a compute shader dispatch system\n\nThe sample defines a custom `ComputeUpdateContext` structure that contains the necessary context for dispatching compute shader functions in every frame:\n\n```swift\nstruct ComputeUpdateContext {\n    \/\/\/ The number of seconds elapsed since the last frame.\n    let deltaTime: TimeInterval\n    \/\/\/ The command buffer for the current frame.\n    let commandBuffer: MTLCommandBuffer\n    \/\/\/ The compute command encoder for the current frame.\n    let computeEncoder: MTLComputeCommandEncoder\n}\n```\n\nThe sample dispatches compute shader functions in every frame by passing this structure to each `ComputeSystem` in the app (see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/passing-metal-command-objects-around-your-application]).\n\n`HeightMapMesh` is an example of a `ComputeSystem`. It implements the `ComputeSystem`  protocol’s `update` method to dispatch compute shaders that generate a height map and modify the vertex positions and normals of a mesh in each frame:\n\n```swift\nclass HeightMapMesh: ComputeSystem {\n    ...\n\n    \/\/\/ Updates the height map mesh by generating a height map, deriving normals from it, and then setting the vertex positions and normals.\n    func update(computeContext: ComputeUpdateContext) {\n        ...\n        \n        \/\/ Generate the height map height values.\n        heightMap.generateHeight(computeContext: computeContext, heightMapComputeParams: heightMapComputeParams)\n        \/\/ Update the height map normal directions.\n        heightMap.updateNormals(computeContext: computeContext, heightMapComputeParams: heightMapComputeParams)\n        \n        \/\/ Update the vertex positions and normals.\n        updateVertices(computeContext: computeContext)\n    }\n}\n```\n\n## Create a low-level texture height map\n\nThe sample creates a height map with [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture] by specifying its pixel format, dimensions, and usage:\n\n```swift\nstruct HeightMap {\n    ...\n   \n    \/\/\/ The low-level texture that stores the height and normal information of the height map.\n    var heightMapTexture: LowLevelTexture\n    \n    init(dimensions: SIMD2<UInt32>) throws {\n        \/\/ Initialize the texture with an RGBA pixel format where the alpha channel stores height,\n        \/\/ while the red, green, and blue channels store the surface normal direction.\n        let textureDescriptor = LowLevelTexture.Descriptor(pixelFormat: .rgba32Float,\n                                                           width: Int(dimensions.x),\n                                                           height: Int(dimensions.y),\n                                                           textureUsage: [.shaderRead, .shaderWrite])\n        self.heightMapTexture = try LowLevelTexture(descriptor: textureDescriptor)\n    }\n    \n    ...\n}\n```\n\nThe low-level texture has the same dimensions as the plane low-level mesh, such that each pixel in the texture corresponds to a vertex in the mesh.\n\n## Write height data to the low-level texture\n\nThe sample writes height data to the low-level texture in every frame on the GPU by dispatching Metal compute shaders. For example, the compute shader function `generateSineWaveHeightMap` writes height values to the texture in the shape of a sine wave moving outward from the center of the texture over time:\n\n```cpp\n[[kernel]]\nvoid generateSineWaveHeightMap(texture2d<float, access::read> heightMapIn [[texture(0)]],\n                               texture2d<float, access::write> heightMapOut [[texture(1)]],\n                               constant float &time [[buffer(2)]],\n                               constant float &amplitude [[buffer(3)]],\n                               uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (pixelCoords.x >= heightMapIn.get_width() || pixelCoords.y >= heightMapIn.get_height()) { return; }\n    \n    \/\/ Compute texture coordinates ranging from 0 to 1 along each axis.\n    float2 uv = float2(pixelCoords.x \/ (heightMapIn.get_width() - 1.0),\n                       pixelCoords.y \/ (heightMapIn.get_height() - 1.0));\n    \n    \/\/ Get the distance to the center of the texture in texture coordinate space.\n    float distanceToCenter = length(uv - 0.5);\n    \/\/ Normalize the distance to a range from 0 to 2π along the horizontal and vertical axes.\n    float normalizedDistanceToCenter = (distanceToCenter \/ 0.5) * (2 * M_PI_F);\n\n    \/\/ Get sine as a function of the normalized distance to the center of the texture times the wave count,\n    \/\/ subtracting time to animate it outward over time.\n    float waveCount = 3;\n    float sine = sin(normalizedDistanceToCenter * waveCount - time);\n    \/\/ Convert sine to the range 0 to 1.\n    float sine01 = (sine + 1) \/ 2;\n    \n    \/\/ Generate height from the sine function.\n    float height = amplitude * sine01;\n    \n    \/\/ Read the current height map data.\n    float4 heightMapData = heightMapIn.read(pixelCoords);\n    \/\/ Update the alpha channel with the new height.\n    heightMapData.a = height;\n    \/\/ Write the updated height data to height map.\n    heightMapOut.write(heightMapData, pixelCoords);\n}\n```\n\nThe following video shows the texture the `generateSineWaveHeightMap` compute function creates:\n\n\n\nThe sample dispatches this compute shader function in `SineWaveHeightMapGenerator`, passing in both the height map low-level texture, the time, and the amplitude:\n\n```swift\nclass SineWaveHeightMapGenerator: HeightMapGenerator {\n    \/\/\/ Compute pipeline corresponding to the Metal compute shader function `generateSineWaveHeightMap`.\n    \/\/\/\n    \/\/\/ See `SineWaveComputeShader.metal`.\n    private let sineWaveHeightPipeline: MTLComputePipelineState = makeComputePipeline(named: \"generateSineWaveHeightMap\")!\n    \n    \/\/\/ The number of seconds elapsed since the person reset this generator.\n    private var time: Float = 0\n    \n    \/\/\/ The amplitude of the sine wave this generator generates.\n    private var amplitude: Float = 0.05\n\n    ...\n    \n    \/\/\/ Dispatches a Metal compute shader to generate a height map in the shape of a sine wave.\n    func generateHeightMap(computeContext: ComputeUpdateContext,\n                           heightMapTexture: LowLevelTexture,\n                           heightMapComputeParams: HeightMapComputeParams) {\n        \/\/ Get deltaTime.\n        let deltaTime = Float(computeContext.deltaTime)\n        \/\/ Get the command buffer and compute encoder.\n        let commandBuffer = computeContext.commandBuffer\n        let computeEncoder = computeContext.computeEncoder\n        \/\/ Get the threadgroups.\n        let threadgroups = heightMapComputeParams.threadgroups\n        let threadsPerThreadgroup = heightMapComputeParams.threadsPerThreadgroup\n        \n        \/\/ Increment time.\n        time += deltaTime\n        \n        \/\/ Set the compute shader pipeline to `generateSineWaveHeightMap`.\n        computeEncoder.setComputePipelineState(sineWaveHeightPipeline)\n        \n        \/\/ Pass a readable version of the height map texture to the compute shader.\n        computeEncoder.setTexture(heightMapTexture.read(), index: 0)\n        \/\/ Pass a writable version of the height map texture to the compute shader.\n        computeEncoder.setTexture(heightMapTexture.replace(using: commandBuffer), index: 1)\n        \n        \/\/ Pass the time to the compute shader.\n        computeEncoder.setBytes(&time, length: MemoryLayout<Float>.size, index: 2)\n        \/\/ Pass the amplitude to the compute shader.\n        computeEncoder.setBytes(&amplitude, length: MemoryLayout<Float>.size, index: 3)\n        \n        \/\/ Dispatch the compute shader.\n        computeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)\n    }\n}\n```\n\nThe sample defines the `makeComputePipeline` method as follows:\n\n```swift\n\/\/\/ The device Metal selects as the default.\nlet metalDevice: MTLDevice? = MTLCreateSystemDefaultDevice()\n\n...\n\n\/\/\/ Makes a compute pipeline for the compute function with the given name.\nfunc makeComputePipeline(named name: String) -> MTLComputePipelineState? {\n    guard let function = metalDevice?.makeDefaultLibrary()?.makeFunction(name: name) else {\n        return nil\n    }\n    return try? metalDevice?.makeComputePipelineState(function: function)\n}\n```\n\nSee [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/creating-a-dynamic-height-map-with-low-level-texture] for further details, along with a description of how the sample derives surface normal directions from the height map.\n\n## Generate additional height maps\n\nThe sample abstracts the generation of height maps by defining a `HeightMapGenerator` protocol:\n\n```swift\nprotocol HeightMapGenerator {\n    \/\/\/ Resets the height map.\n    func reset()\n    \n    \/\/\/ Generates the height map.\n    func generateHeightMap(computeContext: ComputeUpdateContext,\n                           heightMapTexture: LowLevelTexture,\n                           heightMapComputeParams: HeightMapComputeParams)\n}\n```\n\nYou can adopt this protocol to create custom height map generators. These height map generators can generate custom height maps by dispatching compute shader functions, with the given `computeContext`, that write height data to the alpha channel of the given `heightMapTexture`.\n\nThe following videos show the custom height map textures the `TerrainHeightMapGenerator` and `WaterSurfaceHeightMapGenerator` create:\n\n\n\nThe `HeightMap` structure calls the `generateHeightMap` method of its active height map generator, passing in the height map low-level texture and the compute update context necessary to dispatch compute shader functions with the texture:\n\n```swift\nstruct HeightMap {\n    ...\n    \n    \/\/\/ The generator that generates the height values of the height map.\n    var heightMapGenerator: HeightMapGenerator = SineWaveHeightMapGenerator()\n\n    \/\/\/ The low-level texture that stores the height and normal information of the height map.\n    var heightMapTexture: LowLevelTexture\n    \n    ...\n    \n    \/\/\/ Generates the height values in the alpha channel of the height map using the current `heightMapGenerator`.\n    func generateHeight(computeContext: ComputeUpdateContext, heightMapComputeParams: HeightMapComputeParams) {\n        heightMapGenerator.generateHeightMap(computeContext: computeContext,\n                                             heightMapTexture: heightMapTexture,\n                                             heightMapComputeParams: heightMapComputeParams)\n    }\n    \n    ...\n}\n```\n\n## Update the mesh vertex data on the GPU\n\nThe sample defines a structure containing the information necessary to update the mesh’s vertex data on the GPU:\n\n```cpp\nstruct MeshParams {\n    simd_uint2 dimensions;\n    simd_float2 size;\n    float maxVertexDepth;\n};\n```\n\nThese parameters are suitable for updating the vertices of the plane low-level mesh on the GPU, but you can define parameters that conform to your custom mesh and vertex format. Declare this structure in an MSL header file so that you can send it to the GPU (see [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/passing-structured-data-to-a-metal-compute-function#Import-the-struct-in-a-bridging-header]).\n\nNext, the sample updates the position and normal of each vertex in the low-level mesh with a compute shader function that reads this information from the height map low-level texture:\n\n```cpp\n[[kernel]]\nvoid setVertexData(constant MeshParams &params [[buffer(0)]],\n                   device PlaneVertex *vertices [[buffer(1)]],\n                   texture2d<float, access::read> heightMap [[texture(2)]],\n                   uint2 vertexCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (any(vertexCoords >= params.dimensions)) { return; }\n    \n    \/\/ Calculate the 1D vertex buffer index given its 2D x, y coordinates.\n    uint vertexIndex = vertexCoords.x + params.dimensions.x * vertexCoords.y;\n    \/\/ Get the current vertex.\n    device PlaneVertex &vert = vertices[vertexIndex];\n    \n    \/\/ Sample the height map pixel corresponding to this vertex.\n    float4 heightMapData = heightMap.read(vertexCoords);\n    \/\/ Extract the normal direction and the height.\n    float3 normal = heightMapData.rgb;\n    float height = heightMapData.a;\n    \n    \/\/ Convert the x and y vertex coordinates to the range [0, 1].\n    float2 vertexCoords01 = float2(vertexCoords) \/ float2(params.dimensions - 1);\n    \n    \/\/ Get the x and y position from the size.\n    float2 xyPosition = params.size * vertexCoords01 - params.size \/ 2;\n    \/\/ Get the z position from the height, clamping it within\n    \/\/ the bounds of the mesh that `maxVertexDepth` defines.\n    float zPosition = clamp(height, 0., params.maxVertexDepth);\n    \n    \/\/ Update the vertex position and normal.\n    vert.position = float3(xyPosition, zPosition);\n    vert.normal = normal;\n}\n```\n\nHere, the `maxVertexDepth` parameter defines the maximum z offset position for vertices, so that they remain within the bounds of the mesh (see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/creating-a-plane-with-low-level-mesh]). You can take your own approach to ensuring your vertices remain within bounds.\n\nThe sample passes the mesh parameters, vertex buffer, and height map to the compute function before dispatching it:\n\n```swift\nprivate func updateVertices(computeContext: ComputeUpdateContext) {\n    \/\/ Set the compute shader pipeline to `setVertexData`.\n    computeContext.computeEncoder.setComputePipelineState(setVerticesPipeline)\n    \n    \/\/ Pass the mesh parameters to the compute shader.\n    computeContext.computeEncoder.setBytes(&meshParams, length: MemoryLayout<MeshParams>.size, index: 0)\n    \/\/ Pass the vertex buffer to the compute shader.\n    let vertexBuffer = planeMesh.mesh.replace(bufferIndex: 0, using: computeContext.commandBuffer)\n    computeContext.computeEncoder.setBuffer(vertexBuffer, offset: 0, index: 1)\n    \/\/ Pass the height map to the compute shader.\n    computeContext.computeEncoder.setTexture(heightMap.heightMapTexture.read(), index: 2)\n    \n    \/\/ Dispatch the compute shader.\n    computeContext.computeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)\n}\n```\n\n## Display the mesh with an entity\n\nThe sample creates a custom `HeightMapMeshEntity` class with a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent] to display the `HeightMapMesh`:\n\n```swift\nclass HeightMapMeshEntity: Entity, HasModel {\n    \/\/\/ The height map mesh this entity renders.\n    var heightMapMesh: HeightMapMesh?\n    \n    \/\/\/ Sets up the entity by creating a `HeightMapMesh` and adding the necessary components.\n    private func setup(size: SIMD2<Float>, dimensions: SIMD2<UInt32>, maxVertexDepth: Float) {\n        \/\/ Try to create a `HeightMapMesh` and get its low-level mesh.\n        guard let heightMapMesh = try? HeightMapMesh(size: size, dimensions: dimensions, maxVertexDepth: maxVertexDepth),\n              let planeMesh = try? MeshResource(from: heightMapMesh.planeMesh.mesh) else {\n            assertionFailure(\"Failed to create height map mesh and get its low-level mesh.\")\n            return\n        }\n        self.heightMapMesh = heightMapMesh\n        \n        \/\/ Add a compute system component with the height map mesh as its compute system.\n        self.components.set(ComputeSystemComponent(computeSystem: heightMapMesh))\n\n        \/\/ Add a model component with the plane mesh.\n        self.components.set(ModelComponent(mesh: planeMesh, materials: [SimpleMaterial()]))\n\n        \/\/ Make this entity capable of receiving gestures by giving it an input target component and a collider.\n        self.components.set(InputTargetComponent())\n        let collisionBoxDepth: Float = 0.025\n        let collisionBox = ShapeResource.generateBox(width: size.x, height: size.y, depth: collisionBoxDepth)\n            .offsetBy(translation: [0, 0, -collisionBoxDepth \/ 2])\n        self.components.set(CollisionComponent(shapes: [collisionBox]))\n    }\n    \n    \/\/\/ The custom initializer.\n    \/\/\/\n    \/\/\/ Sets up the `heightMapMesh` with given size, dimensions, and maximum vertex depth.\n    init(size: SIMD2<Float>, dimensions: SIMD2<UInt32>, maxVertexDepth: Float) {\n        super.init()\n        setup(size: size, dimensions: dimensions, maxVertexDepth: maxVertexDepth)\n    }\n    \n    \/\/\/ The default initializer.\n    required init() {\n        super.init()\n        setup(size: [1, 1], dimensions: [512, 512], maxVertexDepth: 1)\n    }\n}\n```\n\nThe following video shows a `HeightMapMeshEntity` displaying the mesh its `HeightMapMesh` generates with the `SineWaveHeightMapGenerator`.\n\n\n\n## Make the mesh and texture interactive\n\nThe sample allows the mesh to respond to a person’s interactions by passing interaction data to the GPU, which uses it to modify the height map, which in turn updates the vertices of the mesh.\n\nTo start, the sample captures the person’s interaction position and state with a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/DragGesture], passing that information to `HeightMapMesh`:\n\n```swift\n.gesture(\n    DragGesture()\n        .targetedToEntity(heightMapMeshEntity)\n        .onChanged({ value in\n            let interactionPosition = value.convert(value.location3D,\n                                                    from: .local,\n                                                    to: heightMapMeshEntity)\n            heightMapMeshEntity.heightMapMesh?.interactionPosition = interactionPosition\n            heightMapMeshEntity.heightMapMesh?.isInteractionHappening = true\n        })\n        .onEnded({ value in\n            heightMapMeshEntity.heightMapMesh?.isInteractionHappening = false\n        })\n)\n```\n\n`HeightMapMesh` passes this interaction information to the active `HeightMapGenerator`, which can use it to generate its height map.\n\nFor example, `WaterSurfaceHeightMapGenerator` takes the interaction position and passes it to a compute shader with a custom structure that the sample defines in an MSL header file:\n\n```cpp\nstruct WaterParams {\n    float deltaTime;\n    float waterSpeed;\n    simd_float2 disturbancePosition;\n    float disturbanceRadius;\n    float disturbanceAmount;\n    simd_uint2 dimensions;\n    simd_float2 size;\n    simd_float2 cellSize;\n};\n```\n\nIt dispatches a compute shader to disturb the height of the water at the `interactionPosition` whenever an interaction is happening, by storing the interaction position in this structure’s `disturbancePosition` property:\n\n```swift\nclass WaterSurfaceHeightMapGenerator: HeightMapGenerator {\n    ...\n\n    \/\/ Disturbs the water surface by dispatching a compute shader that increases\/decreases the height\n    \/\/ of the water around the disturbance position.\n    func disturbWaterSurface(computeContext: ComputeUpdateContext,\n                             heightMapTexture: LowLevelTexture,\n                             heightMapComputeParams: HeightMapComputeParams,\n                             waterParams: inout WaterParams) {\n        \/\/ Dispatch the disturbance compute function.\n        computeContext.computeEncoder.setComputePipelineState(disturbWaterSurfacePipeline)\n        computeContext.computeEncoder.setBytes(&waterParams, length: MemoryLayout<WaterParams>.size, index: 0)\n        computeContext.computeEncoder.setTexture(heightMapTexture.read(), index: 1)\n        computeContext.computeEncoder.setTexture(heightMapTexture.replace(using: computeContext.commandBuffer), index: 2)\n        computeContext.computeEncoder.dispatchThreadgroups(heightMapComputeParams.threadgroups,\n                                                           threadsPerThreadgroup: heightMapComputeParams.threadsPerThreadgroup)\n    }\n    \n    ...\n    \n    func generateHeightMap(computeContext: ComputeUpdateContext,\n                           heightMapTexture: LowLevelTexture,\n                           heightMapComputeParams: HeightMapComputeParams) {\n        ...\n        \n        \/\/ Disturb the water surface downward at the position the person is interacting with it,\n        \/\/ if an interaction is happening.\n        if heightMapComputeParams.isInteractionHappening {\n            waterParams.disturbancePosition = simd_make_float2(heightMapComputeParams.interactionPosition)\n            waterParams.disturbanceRadius = 7 * waterParams.cellSize.x\n            waterParams.disturbanceAmount = 250 * waterParams.cellSize.x * waterParams.deltaTime\n            disturbWaterSurface(computeContext: computeContext,\n                                heightMapTexture: heightMapTexture,\n                                heightMapComputeParams: heightMapComputeParams,\n                                waterParams: &waterParams)\n        }\n        \n        ...\n    }\n}\n```\n\nThe `disturbWaterSurface` compute shader function subtracts height from the height map around the disturbance position, simulating the effect of the person’s interaction pushing the water downward:\n\n```cpp\n[[kernel]]\nvoid disturbWaterSurface(constant WaterParams &params [[buffer(0)]],\n                         texture2d<float, access::read> heightMapIn [[texture(1)]],\n                         texture2d<float, access::write> heightMapOut [[texture(2)]],\n                         uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (any(pixelCoords >= params.dimensions)) { return; }\n\n    \/\/ Get the current state of the height map.\n    float4 heightMapData = heightMapIn.read(pixelCoords);\n    \n    \/\/ Convert the position of the current pixel to the same coordinate space as the disturbance position.\n    float2 currentPosition = float2(remap(pixelCoords.x, float2(0, params.dimensions.x - 1), float2(-params.size.x \/ 2, params.size.x \/ 2)),\n                                    remap(pixelCoords.y, float2(0, params.dimensions.y - 1), float2(-params.size.y \/ 2, params.size.y \/ 2)));\n    \/\/ Disturb the height of the water closer to the disturbance position.\n    float distance = length(currentPosition-params.disturbancePosition);\n    if (distance <= params.disturbanceRadius) {\n        heightMapData.a -= params.disturbanceAmount * pow((params.disturbanceRadius-distance)\/(params.disturbanceRadius), 2);\n    }\n    \n    \/\/ Write modified height map data back to the height map.\n    heightMapOut.write(heightMapData, pixelCoords);\n}\n```\n\nThe following video shows the result of using the person’s interaction position to dynamically alter the height map:\n\n\n\nThe app uses a similar technique to allow the person to edit the terrain height map, like in the following video:\n\n\n\n## Scene content\n\n- **Hello World**: Use windows, volumes, and immersive spaces to teach people about the Earth.\n- **Enabling video reflections in an immersive environment**: Create a more immersive experience by adding video reflections in a custom environment.\n- **Creating a spatial drawing app with RealityKit**: Use low-level mesh and texture APIs to achieve fast updates to a person’s brush strokes by integrating RealityKit with ARKit and SwiftUI.\n- **Combining 2D and 3D views in an immersive app**: Use attachments to place 2D content relative to 3D content in your visionOS app.\n- **Transforming RealityKit entities using gestures**: Build a RealityKit component to support standard visionOS gestures on any entity.\n- **Responding to gestures on an entity**: Respond to gestures performed on RealityKit entities using input target and collision components.\n- **Models and meshes**: Display virtual objects in your scene with mesh-based models.\n- **Materials, textures, and shaders**: Apply textures to the surface of your scene’s 3D objects to give each object a unique appearance.\n- **Anchors**: Lock virtual content to the real world.\n- **Lights and cameras**: Control the lighting and point of view for a scene.\n- **Content synchronization**: Synchronize the contents of entities locally or across the network.\n- **Audio**: Create personalized and realistic spatial audio experiences.\n- **Videos**: Present videos in your RealityKit experiences.\n- **Images**: Present images and spatial scenes in your RealityKit experiences.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use windows, volumes, and immersive spaces to teach people about the Earth.",
          "name" : "Hello World",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/World"
        },
        {
          "description" : "Create a more immersive experience by adding video reflections in a custom environment.",
          "name" : "Enabling video reflections in an immersive environment",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/enabling-video-reflections-in-an-immersive-environment"
        },
        {
          "description" : "Use low-level mesh and texture APIs to achieve fast updates to a person’s brush strokes by integrating RealityKit with ARKit and SwiftUI.",
          "name" : "Creating a spatial drawing app with RealityKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/creating-a-spatial-drawing-app-with-realitykit"
        },
        {
          "description" : "Use attachments to place 2D content relative to 3D content in your visionOS app.",
          "name" : "Combining 2D and 3D views in an immersive app",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/combining-2d-and-3d-views-in-an-immersive-app"
        },
        {
          "description" : "Build a RealityKit component to support standard visionOS gestures on any entity.",
          "name" : "Transforming RealityKit entities using gestures",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/transforming-realitykit-entities-with-gestures"
        },
        {
          "description" : "Respond to gestures performed on RealityKit entities using input target and collision components.",
          "name" : "Responding to gestures on an entity",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/responding-to-gestures-on-an-entity"
        },
        {
          "description" : "Display virtual objects in your scene with mesh-based models.",
          "name" : "Models and meshes",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-models-and-meshes"
        },
        {
          "description" : "Apply textures to the surface of your scene’s 3D objects to give each object a unique appearance.",
          "name" : "Materials, textures, and shaders",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-materials-and-shaders"
        },
        {
          "description" : "Lock virtual content to the real world.",
          "name" : "Anchors",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-anchors"
        },
        {
          "description" : "Control the lighting and point of view for a scene.",
          "name" : "Lights and cameras",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-lights-and-cameras"
        },
        {
          "description" : "Synchronize the contents of entities locally or across the network.",
          "name" : "Content synchronization",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-content-synchronization"
        },
        {
          "description" : "Create personalized and realistic spatial audio experiences.",
          "name" : "Audio",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-audio"
        },
        {
          "description" : "Present videos in your RealityKit experiences.",
          "name" : "Videos",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-videos"
        },
        {
          "description" : "Present images and spatial scenes in your RealityKit experiences.",
          "name" : "Images",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/scene-content-images"
        }
      ],
      "title" : "Scene content"
    }
  ],
  "source" : "appleJSON",
  "title" : "Generating interactive geometry with RealityKit",
  "url" : "https:\/\/developer.apple.com\/documentation\/realitykit\/generating-interactive-geometry-with-realitykit"
}