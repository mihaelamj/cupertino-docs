{
  "abstract" : "Create a low-level texture and update its pixel data on the GPU to form a dynamic height and normal map.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ The low-level texture that stores the height and normal information of the height map.\nvar heightMapTexture: LowLevelTexture\n\ninit(dimensions: SIMD2<UInt32>) throws {\n    \/\/ Initialize the texture with an RGBA pixel format where the alpha channel stores height,\n    \/\/ while the red, green, and blue channels store the surface normal direction.\n    let textureDescriptor = LowLevelTexture.Descriptor(pixelFormat: .rgba32Float,\n                                                       width: Int(dimensions.x),\n                                                       height: Int(dimensions.y),\n                                                       textureUsage: [.shaderRead, .shaderWrite])\n    self.heightMapTexture = try LowLevelTexture(descriptor: textureDescriptor)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Generates a height map in the shape of a sine wave moving outward from the center of the texture.\n[[kernel]]\nvoid generateSineWaveHeightMap(texture2d<float, access::read> heightMapIn [[texture(0)]],\n                               texture2d<float, access::write> heightMapOut [[texture(1)]],\n                               constant float &time [[buffer(2)]],\n                               constant float &amplitude [[buffer(3)]],\n                               uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (pixelCoords.x >= heightMapIn.get_width() || pixelCoords.y >= heightMapIn.get_height()) { return; }\n    \n    \/\/ Compute texture coordinates ranging from 0 to 1 along each axis.\n    float2 uv = float2(pixelCoords.x \/ (heightMapIn.get_width() - 1.0),\n                       pixelCoords.y \/ (heightMapIn.get_height() - 1.0));\n    \n    \/\/ Get the distance to the center of the texture in texture coordinate space.\n    float distanceToCenter = length(uv - 0.5);\n    \/\/ Normalize the distance to a range from 0 to 2π along the horizontal and vertical axes.\n    float normalizedDistanceToCenter = (distanceToCenter \/ 0.5) * (2 * M_PI_F);\n\n    \/\/ Get sine as a function of the normalized distance to the center of the texture times the wave count,\n    \/\/ subtracting time to animate it outward over time.\n    float waveCount = 3;\n    float sine = sin(normalizedDistanceToCenter * waveCount - time);\n    \/\/ Convert sine to the range 0 to 1.\n    float sine01 = (sine + 1) \/ 2;\n    \n    \/\/ Generate height from the sine function.\n    float height = amplitude * sine01;\n    \n    \/\/ Read the current height map data.\n    float4 heightMapData = heightMapIn.read(pixelCoords);\n    \/\/ Update the alpha channel with the new height.\n    heightMapData.a = height;\n    \/\/ Write the updated height data to height map.\n    heightMapOut.write(heightMapData, pixelCoords);\n}",
      "language" : "cpp"
    },
    {
      "code" : "\/\/\/ The device Metal selects as the default.\nlet metalDevice: MTLDevice? = MTLCreateSystemDefaultDevice()\n\n\/\/\/ Makes a compute pipeline for the compute function with the given name.\nfunc makeComputePipeline(named name: String) -> MTLComputePipelineState? {\n    guard let function = metalDevice?.makeDefaultLibrary()?.makeFunction(name: name) else {\n        return nil\n    }\n    return try? metalDevice?.makeComputePipelineState(function: function)\n}",
      "language" : "swift"
    },
    {
      "code" : "private let sineWaveHeightPipeline: MTLComputePipelineState = makeComputePipeline(named: \"generateSineWaveHeightMap\")!",
      "language" : "swift"
    },
    {
      "code" : "let threadWidth = sineWaveHeightPipeline.threadExecutionWidth\nlet threadHeight = sineWaveHeightPipeline.maxTotalThreadsPerThreadgroup \/ threadWidth\nlet threadsPerThreadgroup = MTLSize(width: threadWidth, height: threadHeight, depth: 1)\nlet threadgroups = MTLSize(width: (Int(dimensions.x) + threadWidth - 1) \/ threadWidth,\n                           height: (Int(dimensions.y) + threadHeight - 1) \/ threadHeight,\n                           depth: 1)",
      "language" : "swift"
    },
    {
      "code" : "private var time: Float = 0\nprivate var amplitude: Float = 0.05",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Increment time.\ntime += deltaTime\n\n\/\/ Set the compute shader pipeline to `generateSineWaveHeightMap`.\ncomputeEncoder.setComputePipelineState(sineWaveHeightPipeline)\n\n\/\/ Pass a readable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.read(), index: 0)\n\/\/ Pass a writable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.replace(using: commandBuffer), index: 1)\n\n\/\/ Pass the time to the compute shader.\ncomputeEncoder.setBytes(&time, length: MemoryLayout<Float>.size, index: 2)\n\/\/ Pass the amplitude to the compute shader.\ncomputeEncoder.setBytes(&amplitude, length: MemoryLayout<Float>.size, index: 3)\n\n\/\/ Dispatch the compute shader.\ncomputeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Derives normal directions from a height map, storing them in the texture's rgb channels.\n[[kernel]]\nvoid deriveNormalsFromHeightMap(texture2d<float, access::read> heightMapIn [[texture(0)]],\n                                texture2d<float, access::write> heightMapOut [[texture(1)]],\n                                constant float2 &cellSize [[buffer(2)]],\n                                uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Get the dimensions of the height map.\n    uint2 dimensions = uint2(heightMapIn.get_width(), heightMapIn.get_height());\n    \n    \/\/ Skip out-of-bounds threads.\n    if (any(pixelCoords >= dimensions)) { return; }\n    \n    \/\/ The current pixel coordinate minus one in both dimensions, guaranteed to be in bounds.\n    uint2 pixelCoordsMinusOne = max(pixelCoords, 1) - 1;\n    \/\/ The current pixel coordinate plus one in both dimensions, guaranteed to be in bounds.\n    uint2 pixelCoordsPlusOne = min(pixelCoords + 1, dimensions - 1);\n    \n    \/\/ Sample the current pixel along with its four neighbors.\n    float height = heightMapIn.read(pixelCoords).a;\n    float leftHeight = heightMapIn.read(uint2(pixelCoordsMinusOne.x, pixelCoords.y)).a;\n    float rightHeight = heightMapIn.read(uint2(pixelCoordsPlusOne.x, pixelCoords.y)).a;\n    float bottomHeight = heightMapIn.read(uint2(pixelCoords.x, pixelCoordsMinusOne.y)).a;\n    float topHeight = heightMapIn.read(uint2(pixelCoords.x, pixelCoordsPlusOne.y)).a;\n    \n    \/\/ Compute the normal direction using central differences.\n    float3 normal = normalize(float3((leftHeight - rightHeight) \/ (cellSize.x * 2),\n                                     (bottomHeight - topHeight) \/ (cellSize.y * 2),\n                                     1));\n    \n    \/\/ Write the normal direction to the height map.\n    heightMapOut.write(float4(normal, height), pixelCoords);\n}",
      "language" : "cpp"
    },
    {
      "code" : "private let deriveNormalsPipeline: MTLComputePipelineState = makeComputePipeline(named: \"deriveNormalsFromHeightMap\")!",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Set the compute shader pipeline to `deriveNormalsFromHeightMap`.\ncomputeEncoder.setComputePipelineState(deriveNormalsPipeline)\n\n\/\/ Pass a readable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.read(), index: 0)\n\/\/ Pass a writable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.replace(using: commandBuffer), index: 1)\n\n\/\/ Pass the cell size to the compute shader.\ncomputeEncoder.setBytes(&cellSize, length: MemoryLayout<SIMD2<Float>>.size, index: 2)\n\n\/\/ Dispatch the compute shader.\ncomputeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)",
      "language" : "swift"
    }
  ],
  "contentHash" : "7f9ff5fc8eb27db87b622eb7581873e68458f8089351ab04d7535c71655990c6",
  "crawledAt" : "2025-12-02T20:12:56Z",
  "id" : "694E0D0E-9EED-43B6-BBEA-9045B3E9545C",
  "kind" : "article",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nA height map is a texture in which each pixel stores height information describing the shape of a surface. You can read height data from a height map to offset the vertices of a mesh, as well as derive the surface normal directions. Generally speaking, height maps are static textures that remain unmodified at runtime; however, by leveraging [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture], you can create a dynamic height map that you write height data to in every frame on the GPU. Additionally, you can derive surface normals from your height map every time you update it, allowing for a variety of dynamic and interactive effects.\n\nCreate a height map with [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture], and write height data to its alpha channel in every frame by dispatching a Metal compute shader. Derive normal directions from the height map and store them in the red, green, and blue channels of the texture. See [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] for an example of how you can dynamically modify the vertices of a low-level mesh with this height and normal map texture.\n\n## Create a low-level texture\n\nCreate a height map [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture] by describing its pixel format, width, height, and usage:\n\nInitialize this texture with a pixel format of [https:\/\/developer.apple.com\/documentation\/metal\/mtlpixelformat\/rgba32float] so that each pixel in the texture has four 32-bit floats, composing its red, green, blue, and alpha channels. You can store height in the alpha channel, and the surface normal direction in the red, green, and blue channels.\n\n## Write height data to the low-level texture with a compute shader\n\nWrite height data to the texture on the GPU by dispatching a Metal compute shader. For example, you can create a height map with waves that oscillate outward from the center of the texture by setting the height of each pixel to the sine of the pixel’s distance from the center:\n\nInclude the height map texture as a parameter of this function twice, both in a readable and a writable format, so that you can update the alpha channel of each pixel without updating the red, green, and blue channels.\n\nThe following video shows the alpha channel of texture this compute shader function creates:\n\n## Dispatch the compute shader\n\nCreate a helper method that makes the [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputepipelinestate] for a given compute shader function:\n\nGet the [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputepipelinestate] for the `generateSineWaveHeightMap` compute shader function:\n\nNext, calculate the number of threads and threadgroups to dispatch:\n\nThen, define the time and amplitude parameters:\n\nFinally, dispatch the `generateSineWaveHeightMap` function in every frame with an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputecommandencoder], passing it both a readable and a writable version of the height map [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture], as well as the time and the amplitude:\n\nSee [https:\/\/developer.apple.com\/documentation\/metal\/performing_calculations_on_a_gpu] for general information about dispatching Metal shaders, as well as [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/passing-metal-command-objects-around-your-application] for specifics on how to obtain the compute encoder, command buffer, and delta time parameters.\n\n## Derive surface normals from the height map texture\n\nYou can derive surface normal directions directly from the height map and store them in its red, green, and blue channels.\n\nDerive the normal direction at each pixel in the height map by computing the difference between the pixel’s neighboring height values:\n\nGet the [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputepipelinestate] for this compute function:\n\nFinally, dispatch this compute function with an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputecommandencoder], passing in both a readable and a writable version of the height map low-level texture:\n\nIn this example, `cellSize` describes the size of the texture’s pixels in the same units as the height. In the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] sample, this is the size of the cells that compose the plane mesh, or rather the distance between the vertices of the mesh.\n\nThe following video shows the normal map the compute shader function derives from the sine wave height map:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/creating-a-dynamic-height-map-with-low-level-texture\ncrawled: 2025-12-02T20:12:56Z\n---\n\n# Creating a dynamic height and normal map with low-level texture\n\n**Article**\n\nCreate a low-level texture and update its pixel data on the GPU to form a dynamic height and normal map.\n\n## Overview\n\nA height map is a texture in which each pixel stores height information describing the shape of a surface. You can read height data from a height map to offset the vertices of a mesh, as well as derive the surface normal directions. Generally speaking, height maps are static textures that remain unmodified at runtime; however, by leveraging [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture], you can create a dynamic height map that you write height data to in every frame on the GPU. Additionally, you can derive surface normals from your height map every time you update it, allowing for a variety of dynamic and interactive effects.\n\nCreate a height map with [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture], and write height data to its alpha channel in every frame by dispatching a Metal compute shader. Derive normal directions from the height map and store them in the red, green, and blue channels of the texture. See [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] for an example of how you can dynamically modify the vertices of a low-level mesh with this height and normal map texture.\n\n## Create a low-level texture\n\nCreate a height map [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture] by describing its pixel format, width, height, and usage:\n\n```swift\n\/\/\/ The low-level texture that stores the height and normal information of the height map.\nvar heightMapTexture: LowLevelTexture\n\ninit(dimensions: SIMD2<UInt32>) throws {\n    \/\/ Initialize the texture with an RGBA pixel format where the alpha channel stores height,\n    \/\/ while the red, green, and blue channels store the surface normal direction.\n    let textureDescriptor = LowLevelTexture.Descriptor(pixelFormat: .rgba32Float,\n                                                       width: Int(dimensions.x),\n                                                       height: Int(dimensions.y),\n                                                       textureUsage: [.shaderRead, .shaderWrite])\n    self.heightMapTexture = try LowLevelTexture(descriptor: textureDescriptor)\n}\n```\n\nInitialize this texture with a pixel format of [https:\/\/developer.apple.com\/documentation\/metal\/mtlpixelformat\/rgba32float] so that each pixel in the texture has four 32-bit floats, composing its red, green, blue, and alpha channels. You can store height in the alpha channel, and the surface normal direction in the red, green, and blue channels.\n\n## Write height data to the low-level texture with a compute shader\n\nWrite height data to the texture on the GPU by dispatching a Metal compute shader. For example, you can create a height map with waves that oscillate outward from the center of the texture by setting the height of each pixel to the sine of the pixel’s distance from the center:\n\n```cpp\n\/\/\/ Generates a height map in the shape of a sine wave moving outward from the center of the texture.\n[[kernel]]\nvoid generateSineWaveHeightMap(texture2d<float, access::read> heightMapIn [[texture(0)]],\n                               texture2d<float, access::write> heightMapOut [[texture(1)]],\n                               constant float &time [[buffer(2)]],\n                               constant float &amplitude [[buffer(3)]],\n                               uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Skip out-of-bounds threads.\n    \/\/ https:\/\/developer.apple.com\/documentation\/metal\/compute_passes\/calculating_threadgroup_and_grid_sizes\n    if (pixelCoords.x >= heightMapIn.get_width() || pixelCoords.y >= heightMapIn.get_height()) { return; }\n    \n    \/\/ Compute texture coordinates ranging from 0 to 1 along each axis.\n    float2 uv = float2(pixelCoords.x \/ (heightMapIn.get_width() - 1.0),\n                       pixelCoords.y \/ (heightMapIn.get_height() - 1.0));\n    \n    \/\/ Get the distance to the center of the texture in texture coordinate space.\n    float distanceToCenter = length(uv - 0.5);\n    \/\/ Normalize the distance to a range from 0 to 2π along the horizontal and vertical axes.\n    float normalizedDistanceToCenter = (distanceToCenter \/ 0.5) * (2 * M_PI_F);\n\n    \/\/ Get sine as a function of the normalized distance to the center of the texture times the wave count,\n    \/\/ subtracting time to animate it outward over time.\n    float waveCount = 3;\n    float sine = sin(normalizedDistanceToCenter * waveCount - time);\n    \/\/ Convert sine to the range 0 to 1.\n    float sine01 = (sine + 1) \/ 2;\n    \n    \/\/ Generate height from the sine function.\n    float height = amplitude * sine01;\n    \n    \/\/ Read the current height map data.\n    float4 heightMapData = heightMapIn.read(pixelCoords);\n    \/\/ Update the alpha channel with the new height.\n    heightMapData.a = height;\n    \/\/ Write the updated height data to height map.\n    heightMapOut.write(heightMapData, pixelCoords);\n}\n```\n\nInclude the height map texture as a parameter of this function twice, both in a readable and a writable format, so that you can update the alpha channel of each pixel without updating the red, green, and blue channels.\n\nThe following video shows the alpha channel of texture this compute shader function creates:\n\n\n\n## Dispatch the compute shader\n\nCreate a helper method that makes the [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputepipelinestate] for a given compute shader function:\n\n```swift\n\/\/\/ The device Metal selects as the default.\nlet metalDevice: MTLDevice? = MTLCreateSystemDefaultDevice()\n\n\/\/\/ Makes a compute pipeline for the compute function with the given name.\nfunc makeComputePipeline(named name: String) -> MTLComputePipelineState? {\n    guard let function = metalDevice?.makeDefaultLibrary()?.makeFunction(name: name) else {\n        return nil\n    }\n    return try? metalDevice?.makeComputePipelineState(function: function)\n}\n```\n\nGet the [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputepipelinestate] for the `generateSineWaveHeightMap` compute shader function:\n\n```swift\nprivate let sineWaveHeightPipeline: MTLComputePipelineState = makeComputePipeline(named: \"generateSineWaveHeightMap\")!\n```\n\nNext, calculate the number of threads and threadgroups to dispatch:\n\n```swift\nlet threadWidth = sineWaveHeightPipeline.threadExecutionWidth\nlet threadHeight = sineWaveHeightPipeline.maxTotalThreadsPerThreadgroup \/ threadWidth\nlet threadsPerThreadgroup = MTLSize(width: threadWidth, height: threadHeight, depth: 1)\nlet threadgroups = MTLSize(width: (Int(dimensions.x) + threadWidth - 1) \/ threadWidth,\n                           height: (Int(dimensions.y) + threadHeight - 1) \/ threadHeight,\n                           depth: 1)\n```\n\nThen, define the time and amplitude parameters:\n\n```swift\nprivate var time: Float = 0\nprivate var amplitude: Float = 0.05\n```\n\nFinally, dispatch the `generateSineWaveHeightMap` function in every frame with an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputecommandencoder], passing it both a readable and a writable version of the height map [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelTexture], as well as the time and the amplitude:\n\n```swift\n\/\/ Increment time.\ntime += deltaTime\n\n\/\/ Set the compute shader pipeline to `generateSineWaveHeightMap`.\ncomputeEncoder.setComputePipelineState(sineWaveHeightPipeline)\n\n\/\/ Pass a readable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.read(), index: 0)\n\/\/ Pass a writable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.replace(using: commandBuffer), index: 1)\n\n\/\/ Pass the time to the compute shader.\ncomputeEncoder.setBytes(&time, length: MemoryLayout<Float>.size, index: 2)\n\/\/ Pass the amplitude to the compute shader.\ncomputeEncoder.setBytes(&amplitude, length: MemoryLayout<Float>.size, index: 3)\n\n\/\/ Dispatch the compute shader.\ncomputeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)\n```\n\nSee [https:\/\/developer.apple.com\/documentation\/metal\/performing_calculations_on_a_gpu] for general information about dispatching Metal shaders, as well as [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/passing-metal-command-objects-around-your-application] for specifics on how to obtain the compute encoder, command buffer, and delta time parameters.\n\n## Derive surface normals from the height map texture\n\nYou can derive surface normal directions directly from the height map and store them in its red, green, and blue channels.\n\n\n\nDerive the normal direction at each pixel in the height map by computing the difference between the pixel’s neighboring height values:\n\n```cpp\n\/\/\/ Derives normal directions from a height map, storing them in the texture's rgb channels.\n[[kernel]]\nvoid deriveNormalsFromHeightMap(texture2d<float, access::read> heightMapIn [[texture(0)]],\n                                texture2d<float, access::write> heightMapOut [[texture(1)]],\n                                constant float2 &cellSize [[buffer(2)]],\n                                uint2 pixelCoords [[thread_position_in_grid]]) {\n    \/\/ Get the dimensions of the height map.\n    uint2 dimensions = uint2(heightMapIn.get_width(), heightMapIn.get_height());\n    \n    \/\/ Skip out-of-bounds threads.\n    if (any(pixelCoords >= dimensions)) { return; }\n    \n    \/\/ The current pixel coordinate minus one in both dimensions, guaranteed to be in bounds.\n    uint2 pixelCoordsMinusOne = max(pixelCoords, 1) - 1;\n    \/\/ The current pixel coordinate plus one in both dimensions, guaranteed to be in bounds.\n    uint2 pixelCoordsPlusOne = min(pixelCoords + 1, dimensions - 1);\n    \n    \/\/ Sample the current pixel along with its four neighbors.\n    float height = heightMapIn.read(pixelCoords).a;\n    float leftHeight = heightMapIn.read(uint2(pixelCoordsMinusOne.x, pixelCoords.y)).a;\n    float rightHeight = heightMapIn.read(uint2(pixelCoordsPlusOne.x, pixelCoords.y)).a;\n    float bottomHeight = heightMapIn.read(uint2(pixelCoords.x, pixelCoordsMinusOne.y)).a;\n    float topHeight = heightMapIn.read(uint2(pixelCoords.x, pixelCoordsPlusOne.y)).a;\n    \n    \/\/ Compute the normal direction using central differences.\n    float3 normal = normalize(float3((leftHeight - rightHeight) \/ (cellSize.x * 2),\n                                     (bottomHeight - topHeight) \/ (cellSize.y * 2),\n                                     1));\n    \n    \/\/ Write the normal direction to the height map.\n    heightMapOut.write(float4(normal, height), pixelCoords);\n}\n```\n\nGet the [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputepipelinestate] for this compute function:\n\n```swift\nprivate let deriveNormalsPipeline: MTLComputePipelineState = makeComputePipeline(named: \"deriveNormalsFromHeightMap\")!\n```\n\nFinally, dispatch this compute function with an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputecommandencoder], passing in both a readable and a writable version of the height map low-level texture:\n\n```swift\n\/\/ Set the compute shader pipeline to `deriveNormalsFromHeightMap`.\ncomputeEncoder.setComputePipelineState(deriveNormalsPipeline)\n\n\/\/ Pass a readable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.read(), index: 0)\n\/\/ Pass a writable version of the height map texture to the compute shader.\ncomputeEncoder.setTexture(heightMapTexture.replace(using: commandBuffer), index: 1)\n\n\/\/ Pass the cell size to the compute shader.\ncomputeEncoder.setBytes(&cellSize, length: MemoryLayout<SIMD2<Float>>.size, index: 2)\n\n\/\/ Dispatch the compute shader.\ncomputeEncoder.dispatchThreadgroups(threadgroups, threadsPerThreadgroup: threadsPerThreadgroup)\n```\n\nIn this example, `cellSize` describes the size of the texture’s pixels in the same units as the height. In the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] sample, this is the size of the cells that compose the plane mesh, or rather the distance between the vertices of the mesh.\n\nThe following video shows the normal map the compute shader function derives from the sine wave height map:\n\n\n\n## Texture drawing\n\n- **Rendering a windowed game in stereo**: Bring an iOS or iPadOS game to visionOS and enhance it.\n- **LowLevelTexture**: A container for texture data allowing you to create and update textures using your own format.\n- **LowLevelTexture.Descriptor**: An object that you use to configure new `LowLevelTexture` objects.\n- **TextureResource.Drawable**: A drawable associated with a drawable queue\n- **TextureResource.DrawableQueue**: A drawable queue that may be used to update a texture resource dynamically\n- **TextureResource.DrawableQueue.Descriptor**: Describes the texture managed by the drawable queue\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Bring an iOS or iPadOS game to visionOS and enhance it.",
          "name" : "Rendering a windowed game in stereo",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/rendering-a-windowed-game-in-stereo"
        },
        {
          "description" : "A container for texture data allowing you to create and update textures using your own format.",
          "name" : "LowLevelTexture",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelTexture"
        },
        {
          "description" : "An object that you use to configure new `LowLevelTexture` objects.",
          "name" : "LowLevelTexture.Descriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelTexture\/Descriptor-swift.struct"
        },
        {
          "description" : "A drawable associated with a drawable queue",
          "name" : "TextureResource.Drawable",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/TextureResource\/Drawable"
        },
        {
          "description" : "A drawable queue that may be used to update a texture resource dynamically",
          "name" : "TextureResource.DrawableQueue",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/TextureResource\/DrawableQueue-swift.class"
        },
        {
          "description" : "Describes the texture managed by the drawable queue",
          "name" : "TextureResource.DrawableQueue.Descriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/TextureResource\/DrawableQueue-swift.class\/Descriptor"
        }
      ],
      "title" : "Texture drawing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a dynamic height and normal map with low-level texture",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/creating-a-dynamic-height-map-with-low-level-texture"
}