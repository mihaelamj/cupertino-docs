{
  "abstract" : "Adapt a platformer game for RealityKit’s powerful ECS and modularity.",
  "codeExamples" : [
    {
      "code" : "\/\/ Create a basic movement component for a character.\nvar moveComponent = CharacterMovementComponent(characterProxy: \"Max\")\n\n\/\/ Add the component to your character entity.\ncharacter.components.set(moveComponent)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Example: Processing touch input from a virtual thumbstick.\nThumbStickView(updatingValue: $movementThumbstick)\n    .onChange(of: movementThumbstick) { _, newValue in\n        \/\/ Convert 2D input to 3D movement direction.\n        let movementVector: SIMD3<Float> = [Float(newValue.x), 0, Float(newValue.y)] \/ 5\n        character.components[CharacterMovementComponent.self]?.controllerDirection = movementVector\n    }\n\n\/\/ Example: Processing keyboard input.\nfunc processKeyboardInput(wasd: SIMD2<Float>) {\n    \/\/ Convert WASD input to 3D movement direction.\n    character.components[CharacterMovementComponent.self]?.wasdDirection = [wasd.x, 0, wasd.y]\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Define animations for different character states.\nvar animations = [CharacterStateComponent.CharacterState: AnimationResource]()\nanimations[.idle] = idleAnimation.repeat()\nanimations[.walking] = walkAnimation.repeat()\nanimations[.jump] = jumpAnimation.combineWithAudio(named: \"jump\")\n\n\/\/ Create and add the state component to your character.\nlet stateComponent = CharacterStateComponent(animations: animations)\ncharacter.components.set(stateComponent)\n\n\/\/ Trigger actions through the movement component.\ncharacter.components[CharacterMovementComponent.self]?.jumpPressed = true",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create a simple world camera component to follow a character.\nvar worldCameraComponent = WorldCameraComponent(\n    azimuth: .pi,    \/\/ Position behind the character.\n    elevation: 0.2,  \/\/ Slightly above the character.\n    radius: 3        \/\/ Position 3 meters away from the character.\n)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Apply a softer movement in the y-axis, avoiding sharp movements when the character jumps.\nlet followSmoothing: SIMD3<Float> = [3, 1.2, 3]\n\n\/\/ Create a camera entity with both components.\nlet worldCamera = Entity(components:\n    worldCameraComponent,\n    FollowComponent(targetId: target.id, smoothing: )\n)\n\n#if !os(visionOS)\n\/\/ Add the actual camera component for rendering on non-visionOS platforms.\nworldCamera.addChild(Entity(components: PerspectiveCameraComponent()))\n#endif",
      "language" : "swift"
    },
    {
      "code" : "let wanderPathPoints: [SIMD3<Float>] = [\n    [-1, -0.25, 13], [ 1, -0.25, 13],\n    [-1, -0.25, 12], [ 1, -0.25, 12],\n    [-1, -0.25, 11], [ 1, -0.25, 11],\n    [-1, -0.25, 10], [ 1, -0.25, 10]\n]\nlet stayOnPath = GKPath(points: wanderPathPoints, radius: 0.75, cyclical: true)\nlet centerGoal = GKGoal(toStayOn: stayOnPath, maxPredictionTime: 1)\nlet chasingType: AgentComponent.AgentType = .chasing(id: hero.id, distance: 3, speed: 3)",
      "language" : "swift"
    },
    {
      "code" : "let chasingComponent = AgentComponent(\n    agentType: chasingType,\n    wanderSpeed: 3, wanderGoal: GKGoal(toWander: 1),\n    centerGoal: centerGoal,\n    constraints: .position(y: .exact(-0.25))\n)\nchasing.components.set(chasingComponent)",
      "language" : "swift"
    },
    {
      "code" : "xcrun scntool --convert max.scn --format usdz",
      "language" : "sh"
    },
    {
      "code" : "xcrun scntool --convert max.scn --format usdz --append-animation max_spin.scn",
      "language" : "sh"
    },
    {
      "code" : "var immersionStyle: ProgressiveImmersionStyle {\n    .progressive(\n        0.1...0.5,\n        initialAmount: 0.15,\n        aspectRatio: .portrait\n    )\n}",
      "language" : "swift"
    },
    {
      "code" : "ImmersiveSpace(id: appModel.immersiveSpaceID) {\n    \/\/ ...\n}.immersionStyle(\n    selection: .constant(self.immersionStyle),\n    in: self.immersionStyle\n)",
      "language" : "swift"
    },
    {
      "code" : "var supportsFullGame: Bool {\n    \/\/ Check if the device supports Apple GPU Family 2 or later.\n    return MTLCreateSystemDefaultDevice()?.supportsFamily(.apple2) ?? false\n}",
      "language" : "swift"
    },
    {
      "code" : "if supportsFullGame {\n    RealityView { content in\n        \/\/ Full game experience.\n    }\n} else {\n    \/\/ Fallback experience.\n    gameNotSupportedUI()\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "0ab7487f54633139e6b3ec2f94ae3969ab0109cd25a479ea7ead3dcb33136977",
  "crawledAt" : "2025-12-03T07:17:06Z",
  "id" : "3A6F9853-9BB2-4CF8-AE4E-E5BB49F791F3",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nThis sample project demonstrates a cross-platform 3D platformer game implemented in two ways: one using the SceneKit framework, and another built with the RealityKit framework. By seeing both versions side by side, you can directly compare implementation approaches and understand the migration path from SceneKit to RealityKit.\n\nThe RealityKit version showcases modern Swift development practices, including:\n\nWhether you’re maintaining an existing SceneKit project or planning a new 3D experience, this sample demonstrates how RealityKit enables more maintainable and performant 3D applications across Apple platforms.\n\n## Understand SceneKit deprecation\n\nSceneKit is soft-deprecated. This means that your existing apps and games continue to work, and you aren’t required to take immediate action.\n\nBut the implications of any deprecation, however soft, are still significant:\n\nFor any project with a long-term vision, or for those looking to harness the latest innovations, migrate to another native framework like RealityKit.\n\n## Design modular Swift packages\n\nThe core architectural strength of RealityKit comes from its modular design, which you can leverage through Swift packages. Each package encapsulates specific functionality, making the codebase more maintainable, testable, and reusable. This approach aligns perfectly with RealityKit’s ECS architecture:\n\n### Explore key packages in the sample project\n\nThe sample project demonstrates how to organize RealityKit functionality into cohesive, reusable Swift packages:\n\nThis modular approach enables clean separation of concerns, promotes code reusability, and makes complex systems more understandable and maintainable.\n\n### Implement character movement and input handling\n\nThe `CharacterMovement` package provides a flexible system for controlling character movement in 3D space, supporting multiple input methods across different platforms. This package simplifies one of the most complex aspects of migrating from SceneKit: implementing responsive character controls.\n\nAt its core is the `CharacterMovementComponent`, which stores motion data and input state:\n\nThe component handles multiple input sources simultaneously, combining them for smooth control:\n\nThe package also handles character state management, transitioning between animations based on movement:\n\nThis package enables the main character, Max, to move around the scene, and animate as he does so.\n\n### Configure camera management\n\nWith most platforms, you can add a camera component, such as `PerspectiveCameraComponent`, to an entity to change the perspective, but this isn’t possible on visionOS because the person wearing an Apple Vision Pro is the camera. To get around this factor, the app instead moves the world and physics simulation root entities around the wearer.\n\nThe `WorldCamera` package provides a component-based solution for positioning a camera around an entity of interest in 3D space, particularly useful for third-person games, while accounting for platform differences.\n\nThe `WorldCameraComponent` manages spherical coordinate positioning around a target:\n\nTo avoid jarring behaviors, the system can also implement soft camera movements by having the camera follow a target. The `WorldCamera` package provides a `FollowComponent` to perform smooth transitions as the target moves:\n\nThis approach ensures that on platforms like iOS and macOS, the camera moves around the world, while on visionOS, the world moves around the wearer for a comfortable immersive experience that prevents motion sickness and maintains proper spatial awareness.\n\n### Create enemy AI and agency\n\nThe `AgentComponent` package adds autonomous behavior to enemy entities, allowing them to chase or flee from the player character.\n\nThis example defines a patrol area for an enemy:\n\nNext, the app creates an `AgentComponent` with behavior parameters and applies it to the entity:\n\n## Convert SceneKit assets to USD\n\nWhen migrating from SceneKit to RealityKit, asset conversion is a critical step. When building a RealityKit app, Universal Scene Description (USD) is the format of choice for 3D content across all Apple platforms.\n\nMost digital content creation tools offer good support for USD, so the best choice is exporting your assets directly to USD, and importing them into your app or game. If you don’t have access to the original asset files and only have assets in SCN file format, you can use `scntool` to convert your 3D models to USD.\n\nYou can invoke `scntool` by typing `xcrun scntool` into a terminal window:\n\n\n\nTo convert an SCN asset to USDZ, you can use:\n\nIf you have a separate SCN file, which contains animation data, you can append this too:\n\n## Implement Portrait mode for immersive spaces on visionOS\n\nThe RealityKit version of the sample demonstrates how to leverage visionOS-specific features to enhance immersive experiences, particularly through the use of immersive spaces with Portrait mode.\n\nPortrait mode provides a grounded experience where users can still see their physical surroundings while engaging with immersive content, perfect for games like platformers.\n\nPyro Panda uses the new portrait aspect ratio for immersive spaces by first declaring a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ProgressiveImmersionStyle] with the aspect ratio [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ProgressiveImmersionAspectRatio\/portrait]:\n\nThe app assigns this immersion style to the `ImmersiveWindow`, to apply the portrait styling:\n\nThis implementation preserves the person’s awareness of their physical environment when playing the game, while still making the experience immersive.\n\n## Handle hardware compatibility\n\nRealityKit is built for modern hardware, with capabilities that may exceed what older devices can handle. The sample shows you how to gracefully handle hardware compatibility:\n\nWith this simple check, the app provides an appropriate experience based on hardware capabilities:\n\nThis approach ensures your RealityKit application performs well across all supported devices while maximizing modern hardware capabilities.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/realitykit\/bringing-your-scenekit-projects-to-realitykit\ncrawled: 2025-12-03T07:17:06Z\n---\n\n# Bringing your SceneKit projects to RealityKit\n\n**Sample Code**\n\nAdapt a platformer game for RealityKit’s powerful ECS and modularity.\n\n## Overview\n\nThis sample project demonstrates a cross-platform 3D platformer game implemented in two ways: one using the SceneKit framework, and another built with the RealityKit framework. By seeing both versions side by side, you can directly compare implementation approaches and understand the migration path from SceneKit to RealityKit.\n\nThe RealityKit version showcases modern Swift development practices, including:\n\n- Modular architecture through Swift packages\n- Entity-Component-System (ECS) design patterns\n- Cross-platform compatibility, including specialized features for visionOS\n- SwiftUI integration for user interface elements\n- Input handling systems for multiple device types\n\n\n\nWhether you’re maintaining an existing SceneKit project or planning a new 3D experience, this sample demonstrates how RealityKit enables more maintainable and performant 3D applications across Apple platforms.\n\n\n\n## Understand SceneKit deprecation\n\nSceneKit is soft-deprecated. This means that your existing apps and games continue to work, and you aren’t required to take immediate action.\n\nBut the implications of any deprecation, however soft, are still significant:\n\n- SceneKit is unlikely to gain new capabilities, integrations, or API paradigms.\n- SceneKit’s critical security or stability issues might be addressed, but general bug fixes or performance optimizations are unlikely.\n\nFor any project with a long-term vision, or for those looking to harness the latest innovations, migrate to another native framework like RealityKit.\n\n## Design modular Swift packages\n\nThe core architectural strength of RealityKit comes from its modular design, which you can leverage through Swift packages. Each package encapsulates specific functionality, making the codebase more maintainable, testable, and reusable. This approach aligns perfectly with RealityKit’s ECS architecture:\n\n- **Entities** are lightweight containers.\n- **Components** hold pure data, defining properties or state.\n- **Systems** encapsulate all the logic, operating on entities with specific components.\n\n### Explore key packages in the sample project\n\nThe sample project demonstrates how to organize RealityKit functionality into cohesive, reusable Swift packages:\n\n- **AgentComponent** moves entities according to agency goals and constraints, enabling AI-driven behaviors.\n- **CharacterMovement** updates playable entities with transform updates and animation playback.\n- **ControllerInput** handles and delivers controller input to RealityKit entities.\n- **WASDInput** processes keyboard input for RealityKit entities.\n- **WorldCamera** manages the scene’s active camera and handles repositioning for portals or immersive spaces.\n- **PyroPanda** contains all Reality Composer Pro content for the game.\n- **ThumbStickView** provides UI components for touchscreen thumbstick control.\n\nThis modular approach enables clean separation of concerns, promotes code reusability, and makes complex systems more understandable and maintainable.\n\n### Implement character movement and input handling\n\nThe `CharacterMovement` package provides a flexible system for controlling character movement in 3D space, supporting multiple input methods across different platforms. This package simplifies one of the most complex aspects of migrating from SceneKit: implementing responsive character controls.\n\nAt its core is the `CharacterMovementComponent`, which stores motion data and input state:\n\n```swift\n\/\/ Create a basic movement component for a character.\nvar moveComponent = CharacterMovementComponent(characterProxy: \"Max\")\n\n\/\/ Add the component to your character entity.\ncharacter.components.set(moveComponent)\n```\n\nThe component handles multiple input sources simultaneously, combining them for smooth control:\n\n```swift\n\/\/ Example: Processing touch input from a virtual thumbstick.\nThumbStickView(updatingValue: $movementThumbstick)\n    .onChange(of: movementThumbstick) { _, newValue in\n        \/\/ Convert 2D input to 3D movement direction.\n        let movementVector: SIMD3<Float> = [Float(newValue.x), 0, Float(newValue.y)] \/ 5\n        character.components[CharacterMovementComponent.self]?.controllerDirection = movementVector\n    }\n\n\/\/ Example: Processing keyboard input.\nfunc processKeyboardInput(wasd: SIMD2<Float>) {\n    \/\/ Convert WASD input to 3D movement direction.\n    character.components[CharacterMovementComponent.self]?.wasdDirection = [wasd.x, 0, wasd.y]\n}\n```\n\nThe package also handles character state management, transitioning between animations based on movement:\n\n```swift\n\/\/ Define animations for different character states.\nvar animations = [CharacterStateComponent.CharacterState: AnimationResource]()\nanimations[.idle] = idleAnimation.repeat()\nanimations[.walking] = walkAnimation.repeat()\nanimations[.jump] = jumpAnimation.combineWithAudio(named: \"jump\")\n\n\/\/ Create and add the state component to your character.\nlet stateComponent = CharacterStateComponent(animations: animations)\ncharacter.components.set(stateComponent)\n\n\/\/ Trigger actions through the movement component.\ncharacter.components[CharacterMovementComponent.self]?.jumpPressed = true\n```\n\nThis package enables the main character, Max, to move around the scene, and animate as he does so.\n\n\n\n### Configure camera management\n\nWith most platforms, you can add a camera component, such as `PerspectiveCameraComponent`, to an entity to change the perspective, but this isn’t possible on visionOS because the person wearing an Apple Vision Pro is the camera. To get around this factor, the app instead moves the world and physics simulation root entities around the wearer.\n\nThe `WorldCamera` package provides a component-based solution for positioning a camera around an entity of interest in 3D space, particularly useful for third-person games, while accounting for platform differences.\n\nThe `WorldCameraComponent` manages spherical coordinate positioning around a target:\n\n```swift\n\/\/ Create a simple world camera component to follow a character.\nvar worldCameraComponent = WorldCameraComponent(\n    azimuth: .pi,    \/\/ Position behind the character.\n    elevation: 0.2,  \/\/ Slightly above the character.\n    radius: 3        \/\/ Position 3 meters away from the character.\n)\n```\n\nTo avoid jarring behaviors, the system can also implement soft camera movements by having the camera follow a target. The `WorldCamera` package provides a `FollowComponent` to perform smooth transitions as the target moves:\n\n```swift\n\/\/ Apply a softer movement in the y-axis, avoiding sharp movements when the character jumps.\nlet followSmoothing: SIMD3<Float> = [3, 1.2, 3]\n\n\/\/ Create a camera entity with both components.\nlet worldCamera = Entity(components:\n    worldCameraComponent,\n    FollowComponent(targetId: target.id, smoothing: )\n)\n\n#if !os(visionOS)\n\/\/ Add the actual camera component for rendering on non-visionOS platforms.\nworldCamera.addChild(Entity(components: PerspectiveCameraComponent()))\n#endif\n```\n\nThis approach ensures that on platforms like iOS and macOS, the camera moves around the world, while on visionOS, the world moves around the wearer for a comfortable immersive experience that prevents motion sickness and maintains proper spatial awareness.\n\n\n\n\n\n### Create enemy AI and agency\n\nThe `AgentComponent` package adds autonomous behavior to enemy entities, allowing them to chase or flee from the player character.\n\nThis example defines a patrol area for an enemy:\n\n```swift\nlet wanderPathPoints: [SIMD3<Float>] = [\n    [-1, -0.25, 13], [ 1, -0.25, 13],\n    [-1, -0.25, 12], [ 1, -0.25, 12],\n    [-1, -0.25, 11], [ 1, -0.25, 11],\n    [-1, -0.25, 10], [ 1, -0.25, 10]\n]\nlet stayOnPath = GKPath(points: wanderPathPoints, radius: 0.75, cyclical: true)\nlet centerGoal = GKGoal(toStayOn: stayOnPath, maxPredictionTime: 1)\nlet chasingType: AgentComponent.AgentType = .chasing(id: hero.id, distance: 3, speed: 3)\n```\n\nNext, the app creates an `AgentComponent` with behavior parameters and applies it to the entity:\n\n```swift\nlet chasingComponent = AgentComponent(\n    agentType: chasingType,\n    wanderSpeed: 3, wanderGoal: GKGoal(toWander: 1),\n    centerGoal: centerGoal,\n    constraints: .position(y: .exact(-0.25))\n)\nchasing.components.set(chasingComponent)\n```\n\n\n\n## Convert SceneKit assets to USD\n\nWhen migrating from SceneKit to RealityKit, asset conversion is a critical step. When building a RealityKit app, Universal Scene Description (USD) is the format of choice for 3D content across all Apple platforms.\n\nMost digital content creation tools offer good support for USD, so the best choice is exporting your assets directly to USD, and importing them into your app or game. If you don’t have access to the original asset files and only have assets in SCN file format, you can use `scntool` to convert your 3D models to USD.\n\nYou can invoke `scntool` by typing `xcrun scntool` into a terminal window:\n\n\n\nTo convert an SCN asset to USDZ, you can use:\n\n```sh\nxcrun scntool --convert max.scn --format usdz\n```\n\nIf you have a separate SCN file, which contains animation data, you can append this too:\n\n```sh\nxcrun scntool --convert max.scn --format usdz --append-animation max_spin.scn\n```\n\n## Implement Portrait mode for immersive spaces on visionOS\n\nThe RealityKit version of the sample demonstrates how to leverage visionOS-specific features to enhance immersive experiences, particularly through the use of immersive spaces with Portrait mode.\n\nPortrait mode provides a grounded experience where users can still see their physical surroundings while engaging with immersive content, perfect for games like platformers.\n\nPyro Panda uses the new portrait aspect ratio for immersive spaces by first declaring a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ProgressiveImmersionStyle] with the aspect ratio [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ProgressiveImmersionAspectRatio\/portrait]:\n\n```swift\nvar immersionStyle: ProgressiveImmersionStyle {\n    .progressive(\n        0.1...0.5,\n        initialAmount: 0.15,\n        aspectRatio: .portrait\n    )\n}\n```\n\nThe app assigns this immersion style to the `ImmersiveWindow`, to apply the portrait styling:\n\n```swift\nImmersiveSpace(id: appModel.immersiveSpaceID) {\n    \/\/ ...\n}.immersionStyle(\n    selection: .constant(self.immersionStyle),\n    in: self.immersionStyle\n)\n```\n\n\n\nThis implementation preserves the person’s awareness of their physical environment when playing the game, while still making the experience immersive.\n\n## Handle hardware compatibility\n\nRealityKit is built for modern hardware, with capabilities that may exceed what older devices can handle. The sample shows you how to gracefully handle hardware compatibility:\n\n```swift\nvar supportsFullGame: Bool {\n    \/\/ Check if the device supports Apple GPU Family 2 or later.\n    return MTLCreateSystemDefaultDevice()?.supportsFamily(.apple2) ?? false\n}\n```\n\nWith this simple check, the app provides an appropriate experience based on hardware capabilities:\n\n```swift\nif supportsFullGame {\n    RealityView { content in\n        \/\/ Full game experience.\n    }\n} else {\n    \/\/ Fallback experience.\n    gameNotSupportedUI()\n}\n```\n\nThis approach ensures your RealityKit application performs well across all supported devices while maximizing modern hardware capabilities.\n\n## Sample code links\n\n- **Creating a Spaceship game**: Build an immersive game using RealityKit audio, simulation, and rendering features.\n- **BOT-anist**: Build a multiplatform app that uses windows, volumes, and animations to create a robot botanist’s greenhouse.\n- **Rendering a windowed game in stereo**: Bring an iOS or iPadOS game to visionOS and enhance it.\n- **Happy Beam**: Leverage a Full Space to create a fun game using ARKit.\n- **Swift Splash**: Use RealityKit to create an interactive ride in visionOS.\n- **Destination Video**: Leverage SwiftUI to build an immersive media experience in a multiplatform app.\n- **Creating a game with scene understanding**: Create AR games and experiences that interact with real-world objects on LiDAR-equipped iOS devices.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Build an immersive game using RealityKit audio, simulation, and rendering features.",
          "name" : "Creating a Spaceship game",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/creating-a-spaceship-game"
        },
        {
          "description" : "Build a multiplatform app that uses windows, volumes, and animations to create a robot botanist’s greenhouse.",
          "name" : "BOT-anist",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/BOT-anist"
        },
        {
          "description" : "Bring an iOS or iPadOS game to visionOS and enhance it.",
          "name" : "Rendering a windowed game in stereo",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/rendering-a-windowed-game-in-stereo"
        },
        {
          "description" : "Leverage a Full Space to create a fun game using ARKit.",
          "name" : "Happy Beam",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/happybeam"
        },
        {
          "description" : "Use RealityKit to create an interactive ride in visionOS.",
          "name" : "Swift Splash",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/swift-splash"
        },
        {
          "description" : "Leverage SwiftUI to build an immersive media experience in a multiplatform app.",
          "name" : "Destination Video",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/destination-video"
        },
        {
          "description" : "Create AR games and experiences that interact with real-world objects on LiDAR-equipped iOS devices.",
          "name" : "Creating a game with scene understanding",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/creating-a-game-with-scene-understanding"
        }
      ],
      "title" : "Sample code links"
    }
  ],
  "source" : "appleJSON",
  "title" : "Bringing your SceneKit projects to RealityKit",
  "url" : "https:\/\/developer.apple.com\/documentation\/realitykit\/bringing-your-scenekit-projects-to-realitykit"
}