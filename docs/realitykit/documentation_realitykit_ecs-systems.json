{
  "abstract" : "Apply behaviors and physical effects to the entities in a RealityKit scene.",
  "codeExamples" : [

  ],
  "contentHash" : "e86713c9e6759b2b0ef5a5d85867f4f972a9013f2f45e34819ada1257eb48ece",
  "crawledAt" : "2025-12-02T17:33:39Z",
  "id" : "5C97ACC5-A8FD-4037-8E01-72952CE844FE",
  "kind" : "collection",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nIn the Entity-Component-System (ECS) paradigm, the behavior of entities is often implemented using *systems*. A [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System] has an [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System\/update(context:)] method that fires every frame and applies its logic to all entities that meet certain criteria. For example, a game might have a system that controls applying damage to entities from different sources. The same system might make changes to the player’s character, non-player characters, and even inanimate objects that can be damaged or broken. Systems typically work together with one or more components. The system’s component both identifies which entities the system effects and also stores any per-entity data the system needs to work. A damage system, for example, might work with a damage component that stores health or hit points. To make an entity damageable, all you have to do is add the damage component to it, which can be done at runtime. The damage system queries for entities that contain the damage component and applies the appropriate health or hit point change to each of them.\n\nIn traditional object-oriented design, the behavior of an object is usually implemented by writing methods on each object. Using that approach, the code to apply damage to an entity would reside on the entity subclasses. There are two drawbacks to the traditional approach when it comes to the design of games and other immersive experiences.\n\nFirst, if multiple objects require the same behavior, but are implemented as different entity classes without a common ancestor other than [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity], that logic has to be duplicated on all the objects and the duplicated code has to be kept in sync as it changes.\n\nSecond, having to call behavior methods individually on every relevant entity in the scene can negatively impact performance. By placing logic that potentially effects multiple types of entities into a single [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System], we reduce the overhead required to implement the logic. It also allows us to do any per-frame calculations that are the same for all entities only once per frame, eliminating the need to do those calculations for every entity in the scene that can be damaged.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/ecs-systems\ncrawled: 2025-12-02T17:33:39Z\n---\n\n# Systems\n\n**API Collection**\n\nApply behaviors and physical effects to the entities in a RealityKit scene.\n\n## Overview\n\nIn the Entity-Component-System (ECS) paradigm, the behavior of entities is often implemented using *systems*. A [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System] has an [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System\/update(context:)] method that fires every frame and applies its logic to all entities that meet certain criteria. For example, a game might have a system that controls applying damage to entities from different sources. The same system might make changes to the player’s character, non-player characters, and even inanimate objects that can be damaged or broken. Systems typically work together with one or more components. The system’s component both identifies which entities the system effects and also stores any per-entity data the system needs to work. A damage system, for example, might work with a damage component that stores health or hit points. To make an entity damageable, all you have to do is add the damage component to it, which can be done at runtime. The damage system queries for entities that contain the damage component and applies the appropriate health or hit point change to each of them.\n\nIn traditional object-oriented design, the behavior of an object is usually implemented by writing methods on each object. Using that approach, the code to apply damage to an entity would reside on the entity subclasses. There are two drawbacks to the traditional approach when it comes to the design of games and other immersive experiences.\n\nFirst, if multiple objects require the same behavior, but are implemented as different entity classes without a common ancestor other than [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity], that logic has to be duplicated on all the objects and the duplicated code has to be kept in sync as it changes.\n\nSecond, having to call behavior methods individually on every relevant entity in the scene can negatively impact performance. By placing logic that potentially effects multiple types of entities into a single [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System], we reduce the overhead required to implement the logic. It also allows us to do any per-frame calculations that are the same for all entities only once per frame, eliminating the need to do those calculations for every entity in the scene that can be damaged.\n\n## System configuration\n\n- **Implementing systems for entities in a scene**: Apply behaviors and physical effects to the objects and characters in a RealityKit scene with the Entity Component System (ECS).\n- **Animating entity rotation with a system**: Rotate an entity around an axis using a Component and a System.\n- **System**: An object that affects multiple entities in every update of a RealityKit scene.\n- **SystemUpdateCondition**: A condition which causes a system to update.\n- **SceneUpdateContext**: An object that contains information about the scene to update.\n\n## Entity queries\n\n- **EntityQuery**: An object that retrieves entities from a scene.\n- **QueryPredicate**: An object that defines the criteria for an entity query.\n- **QueryResult**: An object that returns the results of an entity query.\n\n## Scene management and logic\n\n- **Scenes**: The context that holds all RealityKit entities.\n- **Events**: Respond to things happening in your RealityKit scene by subscribing to specific event types.\n- **Entity actions**: Create simple, reusable actions that can change your app state, RealityKit scene, or animate an entity.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Apply behaviors and physical effects to the objects and characters in a RealityKit scene with the Entity Component System (ECS).",
          "name" : "Implementing systems for entities in a scene",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/implementing-systems-for-entities-in-a-scene"
        },
        {
          "description" : "Rotate an entity around an axis using a Component and a System.",
          "name" : "Animating entity rotation with a system",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/animated-rotation-with-a-system"
        },
        {
          "description" : "An object that affects multiple entities in every update of a RealityKit scene.",
          "name" : "System",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/System"
        },
        {
          "description" : "A condition which causes a system to update.",
          "name" : "SystemUpdateCondition",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/SystemUpdateCondition"
        },
        {
          "description" : "An object that contains information about the scene to update.",
          "name" : "SceneUpdateContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/SceneUpdateContext"
        }
      ],
      "title" : "System configuration"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object that retrieves entities from a scene.",
          "name" : "EntityQuery",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/EntityQuery"
        },
        {
          "description" : "An object that defines the criteria for an entity query.",
          "name" : "QueryPredicate",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/QueryPredicate"
        },
        {
          "description" : "An object that returns the results of an entity query.",
          "name" : "QueryResult",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/QueryResult"
        }
      ],
      "title" : "Entity queries"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The context that holds all RealityKit entities.",
          "name" : "Scenes",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ecs-scenes"
        },
        {
          "description" : "Respond to things happening in your RealityKit scene by subscribing to specific event types.",
          "name" : "Events",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ecs-events"
        },
        {
          "description" : "Create simple, reusable actions that can change your app state, RealityKit scene, or animate an entity.",
          "name" : "Entity actions",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ecs-entity-actions"
        }
      ],
      "title" : "Scene management and logic"
    }
  ],
  "source" : "appleJSON",
  "title" : "Systems",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ecs-systems"
}