{
  "abstract" : "Target specific CPU metrics with adjustments to your app and its content.",
  "codeExamples" : [
    {
      "code" : "entity.synchronization = nil",
      "language" : "swift"
    }
  ],
  "contentHash" : "e89aa79cc49621e67aa4636ed8f457d50795f612c369bece69bb0a14b60b1a45",
  "crawledAt" : "2025-12-02T17:33:52Z",
  "id" : "E834CE2A-BDE0-41BC-A6B1-BEB859418991",
  "kind" : "article",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nIf your app’s main thread consumes more than 16.6 ms per frame, it won’t be able to achieve 60 fps. You can use the CPU metrics measured by RealityKit, as described in [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/improving-the-performance-of-a-realitykit-app], to decide where you need to focus your efforts to reach this goal.\n\nNote that with multithreaded rendering, keeping the main CPU thread below 16.6 ms doesn’t guarantee 60 fps. If the render thread also takes a long time, RealityKit might occasionally drop a frame to prevent the main thread from getting too far ahead.\n\nFor the best user experience, keep both the main and render threads below about 12 ms on average. It’s helpful to keep the average time consumed well below the 16.6 ms limit to handle situations where the CPU load increases suddenly, such as when the user triggers multiple complex effects simultaneously. Also, the closer you run to the hardware’s limit, the more likely the system might have to throttle the frame rate to avoid overheating.\n\n### Improve render thread time by merging meshes\n\nThe bulk of CPU render time involves setting up draw calls and command buffers, preparing render targets, and encoding buffers for submission to the GPU. Because RealityKit invokes a draw call for each mesh, having more meshes consumes more CPU time. To reduce render thread time, merge meshes that share a material when possible.\n\nRealityKit does this for you automatically to the extent that it can when you load an entity in a usdz file as a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity], for example using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadModel(named:in:)] method. But you can help by minimizing the number of distinct meshes in your models in the first place.\n\nOn the other hand, merging meshes may reduce opportunities for visibility culling and other optimizations, which can lead to increased GPU utilization. This is because while RealityKit avoids rendering off-screen meshes, it does render the entirety of any mesh that’s even partially visible. So consider carefully how you merge meshes. For example, it usually doesn’t make sense to merge two meshes that are physically separated by a large distance.\n\n### Improve ecs time by flattening your assets\n\nThe CPU does ECS work for rendering, animation, physics, assets, networking, and audio on every frame, for every entity with related components. You can reduce this work by flattening your assets as much as possible. That is, combine an entity and its attached descendants into a single entity.\n\nWhen loading entities stored in usdz files as [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity] instances, RealityKit automatically flattens the model for you, as described in [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/loading-entities-from-a-file]. Do this unless you need programmatic access to the descendant entities.\n\n### Improve physics time by reducing collisions\n\nModel entities employ physics to move and interact in ways that appear natural to the user. The CPU carries out the necessary calculations, the cost of which comes primarily from detecting collisions. You can usually reduce the physics portion of your app’s CPU utilization by minimizing the number of collisions in the scene and simplifying collision shapes:\n\n### Improve network time by reducing synchronization traffic\n\nSynchronizing data among devices enables rich multiuser experiences. However, network access comes at a cost. It’s typically best to maximize locality, performing computations on the device where you need the data, and synchronizing as little as possible.\n\nOn the other hand, data synchronization can be a better option than repeated calculation of the same data. For example, it might be better to perform an expensive calculation that produces a small number of bytes only once, and share the result with other devices.\n\nWhen using synchronization, try to minimize the number of synchronized entities. Each entity that requires synchronization consumes CPU time. You can turn off synchronization for a particular entity by deleting its `RealityKit\/Entity\/synchronization` component:\n\nWithin an entity, the system automatically synchronizes properties of all built-in components, as well the properties of custom components that adopt the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol. If you want to avoid synchronizing data for a particular custom component, skip the codable conformance.\n\n### Improve audio time by reducing audio complexity\n\nAudio sources tied to objects in the environment help to make a scene feel immersive. But if you find that audio processing consumes too much CPU time, take steps to minimize the performance impact of audio:\n\n### Improve asset time by streamlining the asset pipeline\n\nReduce or defer the performance cost of loading or creating assets:\n\nFor more information about loading entities, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/loading-entities-from-a-file].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/reducing-cpu-utilization-in-your-realitykit-app\ncrawled: 2025-12-02T17:33:52Z\n---\n\n# Reducing CPU Utilization in Your RealityKit App\n\n**Article**\n\nTarget specific CPU metrics with adjustments to your app and its content.\n\n## Overview\n\nIf your app’s main thread consumes more than 16.6 ms per frame, it won’t be able to achieve 60 fps. You can use the CPU metrics measured by RealityKit, as described in [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/improving-the-performance-of-a-realitykit-app], to decide where you need to focus your efforts to reach this goal.\n\nNote that with multithreaded rendering, keeping the main CPU thread below 16.6 ms doesn’t guarantee 60 fps. If the render thread also takes a long time, RealityKit might occasionally drop a frame to prevent the main thread from getting too far ahead.\n\nFor the best user experience, keep both the main and render threads below about 12 ms on average. It’s helpful to keep the average time consumed well below the 16.6 ms limit to handle situations where the CPU load increases suddenly, such as when the user triggers multiple complex effects simultaneously. Also, the closer you run to the hardware’s limit, the more likely the system might have to throttle the frame rate to avoid overheating.\n\n### Improve render thread time by merging meshes\n\nThe bulk of CPU render time involves setting up draw calls and command buffers, preparing render targets, and encoding buffers for submission to the GPU. Because RealityKit invokes a draw call for each mesh, having more meshes consumes more CPU time. To reduce render thread time, merge meshes that share a material when possible.\n\nRealityKit does this for you automatically to the extent that it can when you load an entity in a usdz file as a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity], for example using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadModel(named:in:)] method. But you can help by minimizing the number of distinct meshes in your models in the first place.\n\nOn the other hand, merging meshes may reduce opportunities for visibility culling and other optimizations, which can lead to increased GPU utilization. This is because while RealityKit avoids rendering off-screen meshes, it does render the entirety of any mesh that’s even partially visible. So consider carefully how you merge meshes. For example, it usually doesn’t make sense to merge two meshes that are physically separated by a large distance.\n\n\n\n### Improve ecs time by flattening your assets\n\nThe CPU does ECS work for rendering, animation, physics, assets, networking, and audio on every frame, for every entity with related components. You can reduce this work by flattening your assets as much as possible. That is, combine an entity and its attached descendants into a single entity.\n\nWhen loading entities stored in usdz files as [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity] instances, RealityKit automatically flattens the model for you, as described in [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/loading-entities-from-a-file]. Do this unless you need programmatic access to the descendant entities.\n\n### Improve physics time by reducing collisions\n\nModel entities employ physics to move and interact in ways that appear natural to the user. The CPU carries out the necessary calculations, the cost of which comes primarily from detecting collisions. You can usually reduce the physics portion of your app’s CPU utilization by minimizing the number of collisions in the scene and simplifying collision shapes:\n\n- Reduce the number of rigid bodies. Design your app to minimize the number of objects in the scene that can collide.\n- Isolate rigid bodies into distinct areas to cut down on the number of ways objects can collide. A box that holds 200 rigid bodies generates a lot more collisions than 4 boxes each containing 50 rigid bodies.\n- Use care when calling [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/generateCollisionShapes(recursive:)] to recursively create collision shapes. You might be able to manually construct simpler collision shapes that are less computationally complex for some meshes.\n- Choose the right collision shape. Some shapes, like those with complex hulls, can drastically increase computational effort. Experiment with different shapes to see how they affect physics computation time.\n\n### Improve network time by reducing synchronization traffic\n\nSynchronizing data among devices enables rich multiuser experiences. However, network access comes at a cost. It’s typically best to maximize locality, performing computations on the device where you need the data, and synchronizing as little as possible.\n\nOn the other hand, data synchronization can be a better option than repeated calculation of the same data. For example, it might be better to perform an expensive calculation that produces a small number of bytes only once, and share the result with other devices.\n\nWhen using synchronization, try to minimize the number of synchronized entities. Each entity that requires synchronization consumes CPU time. You can turn off synchronization for a particular entity by deleting its `RealityKit\/Entity\/synchronization` component:\n\n```swift\nentity.synchronization = nil\n```\n\nWithin an entity, the system automatically synchronizes properties of all built-in components, as well the properties of custom components that adopt the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] protocol. If you want to avoid synchronizing data for a particular custom component, skip the codable conformance.\n\n\n\n### Improve audio time by reducing audio complexity\n\nAudio sources tied to objects in the environment help to make a scene feel immersive. But if you find that audio processing consumes too much CPU time, take steps to minimize the performance impact of audio:\n\n- Limit the number of audio sources in the scene at any given time. For example, you might remove distant audio sources, or merge multiple audio sources into one.\n- Prefer static audio sources whenever possible. Audio sources that move require frequently updated audio transforms.\n- Avoid adding a large number of audio components to a scene all at once, which can cause a spike in CPU activity. Instead, space out the initializations, or do them before the user begins interacting with the environment.\n\n### Improve asset time by streamlining the asset pipeline\n\nReduce or defer the performance cost of loading or creating assets:\n\n- Prefer Reality files over usdz files. Reality files provide better performance.\n- Avoid loading or creating assets during active AR operation. For example, consider preloading data while the user chooses from options on a menu.\n- Use asynchronous loads, with methods like [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadModelAsync(named:in:)], to prevent blocking your main thread.\n- Share resources, like instances of [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/MeshResource], rather than creating new instances of the same resource for each entity.\n- Consider breaking large assets into a collection of smaller assets. Smaller assets load faster, giving you the flexibility to distribute asset loading over time, if it makes sense for your app.\n\nFor more information about loading entities, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/loading-entities-from-a-file].\n\n## Performance improvements\n\n- **Improving the Performance of a RealityKit App**: Measure CPU and GPU utilization to find ways to improve your app’s performance.\n- **Reducing GPU Utilization in Your RealityKit App**: Prevent the GPU from limiting your app’s frame rate by reducing the complexity of your render.\n- **Construct an immersive environment for visionOS**: Build efficient custom worlds for your app.\n- **Passing Metal command objects around your application**: Build a system that creates and passes Metal command objects to entities dispatching Metal compute shaders.\n- **Resource**: A shared resource you use to configure a component, like a material, mesh, or texture.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Measure CPU and GPU utilization to find ways to improve your app’s performance.",
          "name" : "Improving the Performance of a RealityKit App",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/improving-the-performance-of-a-realitykit-app"
        },
        {
          "description" : "Prevent the GPU from limiting your app’s frame rate by reducing the complexity of your render.",
          "name" : "Reducing GPU Utilization in Your RealityKit App",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/reducing-gpu-utilization-in-your-realitykit-app"
        },
        {
          "description" : "Build efficient custom worlds for your app.",
          "name" : "Construct an immersive environment for visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/construct-an-immersive-environment-for-visionOS"
        },
        {
          "description" : "Build a system that creates and passes Metal command objects to entities dispatching Metal compute shaders.",
          "name" : "Passing Metal command objects around your application",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/passing-metal-command-objects-around-your-application"
        },
        {
          "description" : "A shared resource you use to configure a component, like a material, mesh, or texture.",
          "name" : "Resource",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/Resource"
        }
      ],
      "title" : "Performance improvements"
    }
  ],
  "source" : "appleJSON",
  "title" : "Reducing CPU Utilization in Your RealityKit App",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/reducing-cpu-utilization-in-your-realitykit-app"
}