{
  "abstract" : "Create a low-level mesh and set its vertex positions and normals to form a plane.",
  "codeExamples" : [
    {
      "code" : "struct PlaneVertex {\n    simd_float3 position;\n    simd_float3 normal;\n};",
      "language" : "cpp"
    },
    {
      "code" : "struct PlaneMesh {\n    \/\/\/ The plane low-level mesh.\n    var mesh: LowLevelMesh!\n    \/\/\/ The size of the plane mesh.\n    let size: SIMD2<Float>\n    \/\/\/ The number of vertices in each dimension of the plane mesh.\n    let dimensions: SIMD2<UInt32>\n    \/\/\/ The maximum offset depth for the vertices of the plane mesh.\n    \/\/\/\n    \/\/\/ Use this to ensure the bounds of the plane encompass its vertices, even if they are offset.\n    let maxVertexDepth: Float\n    \n    ...\n    \n    \/\/\/ Initializes the plane mesh by creating a low-level mesh and filling its vertex and index buffers\n    \/\/\/ to form a plane with given size and dimensions.\n    init(size: SIMD2<Float>, dimensions: SIMD2<UInt32>, maxVertexDepth: Float = 1) throws {\n        self.size = size\n        self.dimensions = dimensions\n        self.maxVertexDepth = maxVertexDepth\n        \n        \/\/ Create the low-level mesh.\n        self.mesh = try createMesh()\n\n        \/\/ Fill the mesh's vertex buffer with data.\n        initializeVertexData()\n        \n        \/\/ Fill the mesh's index buffer with data.\n        initializeIndexData()\n        \n        \/\/ Initialize the mesh parts.\n        initializeMeshParts()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Creates a low-level mesh with `PlaneVertex` vertices.\nprivate func createMesh() throws -> LowLevelMesh {\n    \/\/ Define the vertex attributes of `PlaneVertex`.\n    let positionAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.position) ?? 0\n    let normalAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.normal) ?? 16\n    \n    let positionAttribute = LowLevelMesh.Attribute(semantic: .position, format: .float3, offset: positionAttributeOffset)\n    let normalAttribute = LowLevelMesh.Attribute(semantic: .normal, format: .float3, offset: normalAttributeOffset)\n    \n    let vertexAttributes = [positionAttribute, normalAttribute]\n    \n    \/\/ Define the vertex layouts of `PlaneVertex`.\n    let vertexLayouts = [LowLevelMesh.Layout(bufferIndex: 0, bufferStride: MemoryLayout<PlaneVertex>.stride)]",
      "language" : "swift"
    },
    {
      "code" : "    \/\/ Derive the vertex and index count from the dimensions.\n    let vertexCount = Int(dimensions.x * dimensions.y)\n    let indicesPerTriangle = 3\n    let trianglesPerCell = 2\n    let cellCount = Int((dimensions.x - 1) * (dimensions.y - 1))\n    let indexCount = indicesPerTriangle * trianglesPerCell * cellCount",
      "language" : "swift"
    },
    {
      "code" : "    \/\/ Create a low-level mesh with the necessary `PlaneVertex` capacity.\n    let meshDescriptor = LowLevelMesh.Descriptor(vertexCapacity: vertexCount,\n                                                 vertexAttributes: vertexAttributes,\n                                                 vertexLayouts: vertexLayouts,\n                                                 indexCapacity: indexCount)\n    return try LowLevelMesh(descriptor: meshDescriptor)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Converts a 2D vertex coordinate to a 1D vertex buffer index.\nprivate func vertexIndex(_ xCoord: UInt32, _ yCoord: UInt32) -> UInt32 {\n    xCoord + dimensions.x * yCoord\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Initialize the vertices of the mesh, positioning them to form an xy-plane with the given size.\nprivate func initializeVertexData() {\n    \/\/ Initialize mesh vertex positions and normals.\n    mesh.withUnsafeMutableBytes(bufferIndex: 0) { rawBytes in\n        \/\/ Convert `rawBytes` into a `PlaneVertex` buffer pointer.\n        let vertices = rawBytes.bindMemory(to: PlaneVertex.self)\n        \n        \/\/ Define the normal direction for the vertices.\n        let normalDirection: SIMD3<Float> = [0, 0, 1]\n\n        \/\/ Iterate through each vertex.\n        for xCoord in 0..<dimensions.x {\n            for yCoord in 0..<dimensions.y {\n                \/\/ Remap the x and y vertex coordinates to the range [0, 1].\n                let xCoord01 = Float(xCoord) \/ Float(dimensions.x - 1)\n                let yCoord01 = Float(yCoord) \/ Float(dimensions.y - 1)\n                \n                \/\/ Derive the vertex position from the remapped vertex coordinates and the size.\n                let xPosition = size.x * xCoord01 - size.x \/ 2\n                let yPosition = size.y * yCoord01 - size.y \/ 2\n                let zPosition = Float(0)\n                \n                \/\/ Get the current vertex from the vertex coordinates and set its position and normal.\n                let vertexIndex = Int(vertexIndex(xCoord, yCoord))\n                vertices[vertexIndex].position = [xPosition, yPosition, zPosition]\n                vertices[vertexIndex].normal = normalDirection\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Initializes the indices of the mesh two triangles at a time for each cell in the mesh.\nprivate func initializeIndexData() {\n    mesh.withUnsafeMutableIndices { rawIndices in\n        \/\/ Convert `rawIndices` into a UInt32 pointer.\n        guard var indices = rawIndices.baseAddress?.assumingMemoryBound(to: UInt32.self) else { return }\n        \n        \/\/ Iterate through each cell.\n        for xCoord in 0..<dimensions.x - 1 {\n            for yCoord in 0..<dimensions.y - 1 {\n                \/*\n                   Each cell in the plane mesh consists of two triangles:\n                    \n                              topLeft     topRight\n                                     |\\ ̅ ̅|\n                     1st Triangle--> | \\ | <-- 2nd Triangle\n                                     | ̲ ̲\\|\n                  +y       bottomLeft     bottomRight\n                   ^\n                   |\n                   *---> +x\n                 \n                 *\/\n                let bottomLeft = vertexIndex(xCoord, yCoord)\n                let bottomRight = vertexIndex(xCoord + 1, yCoord)\n                let topLeft = vertexIndex(xCoord, yCoord + 1)\n                let topRight = vertexIndex(xCoord + 1, yCoord + 1)\n                \n                \/\/ Create the 1st triangle with a counterclockwise winding order.\n                indices[0] = bottomLeft\n                indices[1] = bottomRight\n                indices[2] = topLeft\n                \n                \/\/ Create the 2nd triangle with a counterclockwise winding order.\n                indices[3] = topLeft\n                indices[4] = bottomRight\n                indices[5] = topRight\n                \n                indices += 6\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Initializes mesh parts, indicating topology and bounds.\nfunc initializeMeshParts() {\n    \/\/ Create a bounding box that encompasses the plane's size and max vertex depth.\n    let bounds = BoundingBox(min: [-size.x \/ 2, -size.y \/ 2, 0],\n                             max: [size.x \/ 2, size.y \/ 2, maxVertexDepth])\n    \n    mesh.parts.replaceAll([LowLevelMesh.Part(indexCount: mesh.descriptor.indexCapacity,\n                                             topology: .triangle,\n                                             bounds: bounds)])\n}",
      "language" : "swift"
    },
    {
      "code" : "RealityView { content in\n    \/\/ Create a plane mesh.\n    if let planeMesh = try? PlaneMesh(size: [1, 1], dimensions: [16, 16]),\n       let mesh = try? MeshResource(from: planeMesh.mesh) {\n        \/\/ Create an entity with the plane mesh.\n        let planeEntity = Entity()\n        let planeModel = ModelComponent(mesh: mesh, materials: [SimpleMaterial()])\n        planeEntity.components.set(planeModel)\n        \n        \/\/ Add the plane entity to the scene.\n        content.add(planeEntity)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ded8b90a53dcfc24b991a65bce0e151be2c3f754b5c4087869b6037e0ba57400",
  "crawledAt" : "2025-12-02T20:21:05Z",
  "id" : "6F4759CF-3656-44AE-BF10-924C792886C7",
  "kind" : "article",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nA plane mesh is an excellent starting point for a variety of interactive applications, such as a cloth or water simulation. However, to achieve these dynamic effects you need to modify the mesh’s vertices in every frame, which is inefficient without direct access to the underlying GPU buffers. [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh] addresses this inefficiency by allowing you to create a custom vertex format and vertex buffer layout, which you can update in real time on the GPU by dispatching Metal compute shaders.\n\nConstruct a plane mesh by defining a custom vertex structure and creating a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh] with enough vertex and index capacity to store the vertices. Position the vertices of the mesh in the shape of a plane by filling in the index and vertex buffers with data. See [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] for further applications of this mesh, including a terrain editor and water simulation.\n\n## Define a custom vertex structure\n\nStart by defining a custom vertex structure in a [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf] header file:\n\nIn this example, the vertex has a 3D position and a 3D normal vector, but you can further customize your vertex structure with different names and additional data, such as color and UV data.\n\nMake `PlaneVertex` accessible in both Swift files and Metal files by referencing it in a bridging file. See [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/passing-structured-data-to-a-metal-compute-function#Import-the-struct-in-a-bridging-header] for more information about bridging files.\n\n## Define a plane mesh structure\n\nDefine a structure that constructs the plane low-level mesh with size and dimensions:\n\nSee the following sections for the implementation details of each of the methods in the structure’s initializer.\n\n## Create the low-level mesh\n\nStart by specifying the layout of the vertex data with a [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/attribute] array and a [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/layout] array:\n\nThese arrays define which properties in your custom vertex structure represent the different components of the vertex, such as position, normal, color, and so on, as well as their memory layout.\n\nNext, derive the number of vertices and indices in the mesh from its dimensions:\n\nFinally, create the low-level mesh by describing its vertex capacity, attributes, layouts, and index capacity:\n\n## Initialize the data in the mesh’s vertex and index buffers\n\nPrepare the mesh for rendering by filling in its vertex and index buffers with data on the CPU, as in the following image:\n\n\n\nStart by defining a helper method that converts a two-dimensional vertex coordinate to a one-dimensional vertex buffer array index:\n\nNext, initialize the vertices of the low-level mesh by setting their normal directions and positioning them to form a plane with the given size:\n\nLoop over the vertices within the [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/withunsafemutablebytes(bufferindex:_:)] callback for best performance, as calling this method repeatedly is costly.\n\nFinally, fill the index buffer by iterating through each cell in the mesh and adding the vertices of the two triangles that make up the cell in a counterclockwise winding order:\n\nLoop over the indices within the [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/withunsafemutableindices(_:)] callback for best performance.\n\n## Initialize the mesh parts\n\nInitialize the mesh parts by specifying the mesh’s index count, topology, and bounds:\n\nIn this example, the `maxVertexDepth` property specifies the maximum offset depth for the vertices. The mesh’s bounding box relies on this value to ensure it will encompass the vertices at all times, even if they are offset from their original positions.\n\n## Create an entity with the low-level mesh\n\nView `PlaneMesh`’s low-level mesh by creating a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/MeshResource] from it and adding that to the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent] of an entity in the scene:\n\nThe following image shows the result of rendering a `PlaneMesh`’s low-level mesh in the scene:\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/realitykit\/creating-a-plane-with-low-level-mesh\ncrawled: 2025-12-02T20:21:05Z\n---\n\n# Creating a plane with low-level mesh\n\n**Article**\n\nCreate a low-level mesh and set its vertex positions and normals to form a plane.\n\n## Overview\n\nA plane mesh is an excellent starting point for a variety of interactive applications, such as a cloth or water simulation. However, to achieve these dynamic effects you need to modify the mesh’s vertices in every frame, which is inefficient without direct access to the underlying GPU buffers. [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh] addresses this inefficiency by allowing you to create a custom vertex format and vertex buffer layout, which you can update in real time on the GPU by dispatching Metal compute shaders.\n\nConstruct a plane mesh by defining a custom vertex structure and creating a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/LowLevelMesh] with enough vertex and index capacity to store the vertices. Position the vertices of the mesh in the shape of a plane by filling in the index and vertex buffers with data. See [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] for further applications of this mesh, including a terrain editor and water simulation.\n\n## Define a custom vertex structure\n\nStart by defining a custom vertex structure in a [https:\/\/developer.apple.com\/metal\/Metal-Shading-Language-Specification.pdf] header file:\n\n```cpp\nstruct PlaneVertex {\n    simd_float3 position;\n    simd_float3 normal;\n};\n```\n\nIn this example, the vertex has a 3D position and a 3D normal vector, but you can further customize your vertex structure with different names and additional data, such as color and UV data.\n\nMake `PlaneVertex` accessible in both Swift files and Metal files by referencing it in a bridging file. See [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/passing-structured-data-to-a-metal-compute-function#Import-the-struct-in-a-bridging-header] for more information about bridging files.\n\n## Define a plane mesh structure\n\nDefine a structure that constructs the plane low-level mesh with size and dimensions:\n\n```swift\nstruct PlaneMesh {\n    \/\/\/ The plane low-level mesh.\n    var mesh: LowLevelMesh!\n    \/\/\/ The size of the plane mesh.\n    let size: SIMD2<Float>\n    \/\/\/ The number of vertices in each dimension of the plane mesh.\n    let dimensions: SIMD2<UInt32>\n    \/\/\/ The maximum offset depth for the vertices of the plane mesh.\n    \/\/\/\n    \/\/\/ Use this to ensure the bounds of the plane encompass its vertices, even if they are offset.\n    let maxVertexDepth: Float\n    \n    ...\n    \n    \/\/\/ Initializes the plane mesh by creating a low-level mesh and filling its vertex and index buffers\n    \/\/\/ to form a plane with given size and dimensions.\n    init(size: SIMD2<Float>, dimensions: SIMD2<UInt32>, maxVertexDepth: Float = 1) throws {\n        self.size = size\n        self.dimensions = dimensions\n        self.maxVertexDepth = maxVertexDepth\n        \n        \/\/ Create the low-level mesh.\n        self.mesh = try createMesh()\n\n        \/\/ Fill the mesh's vertex buffer with data.\n        initializeVertexData()\n        \n        \/\/ Fill the mesh's index buffer with data.\n        initializeIndexData()\n        \n        \/\/ Initialize the mesh parts.\n        initializeMeshParts()\n    }\n}\n```\n\nSee the following sections for the implementation details of each of the methods in the structure’s initializer.\n\n## Create the low-level mesh\n\nStart by specifying the layout of the vertex data with a [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/attribute] array and a [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/layout] array:\n\n```swift\n\/\/\/ Creates a low-level mesh with `PlaneVertex` vertices.\nprivate func createMesh() throws -> LowLevelMesh {\n    \/\/ Define the vertex attributes of `PlaneVertex`.\n    let positionAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.position) ?? 0\n    let normalAttributeOffset = MemoryLayout.offset(of: \\PlaneVertex.normal) ?? 16\n    \n    let positionAttribute = LowLevelMesh.Attribute(semantic: .position, format: .float3, offset: positionAttributeOffset)\n    let normalAttribute = LowLevelMesh.Attribute(semantic: .normal, format: .float3, offset: normalAttributeOffset)\n    \n    let vertexAttributes = [positionAttribute, normalAttribute]\n    \n    \/\/ Define the vertex layouts of `PlaneVertex`.\n    let vertexLayouts = [LowLevelMesh.Layout(bufferIndex: 0, bufferStride: MemoryLayout<PlaneVertex>.stride)]\n```\n\nThese arrays define which properties in your custom vertex structure represent the different components of the vertex, such as position, normal, color, and so on, as well as their memory layout.\n\nNext, derive the number of vertices and indices in the mesh from its dimensions:\n\n```swift\n    \/\/ Derive the vertex and index count from the dimensions.\n    let vertexCount = Int(dimensions.x * dimensions.y)\n    let indicesPerTriangle = 3\n    let trianglesPerCell = 2\n    let cellCount = Int((dimensions.x - 1) * (dimensions.y - 1))\n    let indexCount = indicesPerTriangle * trianglesPerCell * cellCount\n```\n\nFinally, create the low-level mesh by describing its vertex capacity, attributes, layouts, and index capacity:\n\n```swift\n    \/\/ Create a low-level mesh with the necessary `PlaneVertex` capacity.\n    let meshDescriptor = LowLevelMesh.Descriptor(vertexCapacity: vertexCount,\n                                                 vertexAttributes: vertexAttributes,\n                                                 vertexLayouts: vertexLayouts,\n                                                 indexCapacity: indexCount)\n    return try LowLevelMesh(descriptor: meshDescriptor)\n}\n```\n\n## Initialize the data in the mesh’s vertex and index buffers\n\nPrepare the mesh for rendering by filling in its vertex and index buffers with data on the CPU, as in the following image:\n\n\n\n\n\nStart by defining a helper method that converts a two-dimensional vertex coordinate to a one-dimensional vertex buffer array index:\n\n```swift\n\/\/\/ Converts a 2D vertex coordinate to a 1D vertex buffer index.\nprivate func vertexIndex(_ xCoord: UInt32, _ yCoord: UInt32) -> UInt32 {\n    xCoord + dimensions.x * yCoord\n}\n```\n\nNext, initialize the vertices of the low-level mesh by setting their normal directions and positioning them to form a plane with the given size:\n\n```swift\n\/\/\/ Initialize the vertices of the mesh, positioning them to form an xy-plane with the given size.\nprivate func initializeVertexData() {\n    \/\/ Initialize mesh vertex positions and normals.\n    mesh.withUnsafeMutableBytes(bufferIndex: 0) { rawBytes in\n        \/\/ Convert `rawBytes` into a `PlaneVertex` buffer pointer.\n        let vertices = rawBytes.bindMemory(to: PlaneVertex.self)\n        \n        \/\/ Define the normal direction for the vertices.\n        let normalDirection: SIMD3<Float> = [0, 0, 1]\n\n        \/\/ Iterate through each vertex.\n        for xCoord in 0..<dimensions.x {\n            for yCoord in 0..<dimensions.y {\n                \/\/ Remap the x and y vertex coordinates to the range [0, 1].\n                let xCoord01 = Float(xCoord) \/ Float(dimensions.x - 1)\n                let yCoord01 = Float(yCoord) \/ Float(dimensions.y - 1)\n                \n                \/\/ Derive the vertex position from the remapped vertex coordinates and the size.\n                let xPosition = size.x * xCoord01 - size.x \/ 2\n                let yPosition = size.y * yCoord01 - size.y \/ 2\n                let zPosition = Float(0)\n                \n                \/\/ Get the current vertex from the vertex coordinates and set its position and normal.\n                let vertexIndex = Int(vertexIndex(xCoord, yCoord))\n                vertices[vertexIndex].position = [xPosition, yPosition, zPosition]\n                vertices[vertexIndex].normal = normalDirection\n            }\n        }\n    }\n}\n```\n\nLoop over the vertices within the [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/withunsafemutablebytes(bufferindex:_:)] callback for best performance, as calling this method repeatedly is costly.\n\nFinally, fill the index buffer by iterating through each cell in the mesh and adding the vertices of the two triangles that make up the cell in a counterclockwise winding order:\n\n```swift\n\/\/\/ Initializes the indices of the mesh two triangles at a time for each cell in the mesh.\nprivate func initializeIndexData() {\n    mesh.withUnsafeMutableIndices { rawIndices in\n        \/\/ Convert `rawIndices` into a UInt32 pointer.\n        guard var indices = rawIndices.baseAddress?.assumingMemoryBound(to: UInt32.self) else { return }\n        \n        \/\/ Iterate through each cell.\n        for xCoord in 0..<dimensions.x - 1 {\n            for yCoord in 0..<dimensions.y - 1 {\n                \/*\n                   Each cell in the plane mesh consists of two triangles:\n                    \n                              topLeft     topRight\n                                     |\\ ̅ ̅|\n                     1st Triangle--> | \\ | <-- 2nd Triangle\n                                     | ̲ ̲\\|\n                  +y       bottomLeft     bottomRight\n                   ^\n                   |\n                   *---> +x\n                 \n                 *\/\n                let bottomLeft = vertexIndex(xCoord, yCoord)\n                let bottomRight = vertexIndex(xCoord + 1, yCoord)\n                let topLeft = vertexIndex(xCoord, yCoord + 1)\n                let topRight = vertexIndex(xCoord + 1, yCoord + 1)\n                \n                \/\/ Create the 1st triangle with a counterclockwise winding order.\n                indices[0] = bottomLeft\n                indices[1] = bottomRight\n                indices[2] = topLeft\n                \n                \/\/ Create the 2nd triangle with a counterclockwise winding order.\n                indices[3] = topLeft\n                indices[4] = bottomRight\n                indices[5] = topRight\n                \n                indices += 6\n            }\n        }\n    }\n}\n```\n\nLoop over the indices within the [https:\/\/developer.apple.com\/documentation\/realitykit\/lowlevelmesh\/withunsafemutableindices(_:)] callback for best performance.\n\n\n\n## Initialize the mesh parts\n\nInitialize the mesh parts by specifying the mesh’s index count, topology, and bounds:\n\n```swift\n\/\/\/ Initializes mesh parts, indicating topology and bounds.\nfunc initializeMeshParts() {\n    \/\/ Create a bounding box that encompasses the plane's size and max vertex depth.\n    let bounds = BoundingBox(min: [-size.x \/ 2, -size.y \/ 2, 0],\n                             max: [size.x \/ 2, size.y \/ 2, maxVertexDepth])\n    \n    mesh.parts.replaceAll([LowLevelMesh.Part(indexCount: mesh.descriptor.indexCapacity,\n                                             topology: .triangle,\n                                             bounds: bounds)])\n}\n```\n\nIn this example, the `maxVertexDepth` property specifies the maximum offset depth for the vertices. The mesh’s bounding box relies on this value to ensure it will encompass the vertices at all times, even if they are offset from their original positions.\n\n\n\n## Create an entity with the low-level mesh\n\nView `PlaneMesh`’s low-level mesh by creating a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/MeshResource] from it and adding that to the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent] of an entity in the scene:\n\n```swift\nRealityView { content in\n    \/\/ Create a plane mesh.\n    if let planeMesh = try? PlaneMesh(size: [1, 1], dimensions: [16, 16]),\n       let mesh = try? MeshResource(from: planeMesh.mesh) {\n        \/\/ Create an entity with the plane mesh.\n        let planeEntity = Entity()\n        let planeModel = ModelComponent(mesh: mesh, materials: [SimpleMaterial()])\n        planeEntity.components.set(planeModel)\n        \n        \/\/ Add the plane entity to the scene.\n        content.add(planeEntity)\n    }\n}\n```\n\nThe following image shows the result of rendering a `PlaneMesh`’s low-level mesh in the scene:\n\n\n\n## Updatable meshes\n\n- **Integrating virtual objects with your environment**: Create an immersive game using native anchor support, environmental blending, model manipulation, and mesh instance duplication.\n- **Creating a spatial drawing app with RealityKit**: Use low-level mesh and texture APIs to achieve fast updates to a person’s brush strokes by integrating RealityKit with ARKit and SwiftUI.\n- **LowLevelMesh**: A container for vertex data that you can use to create and update meshes using your own format.\n- **LowLevelMesh.Descriptor**: An object that describes the data format and layout of the buffers in a low-level mesh.\n- **LowLevelMesh.Part**: An object that describes a range of primitives to display, and their material index.\n- **LowLevelMesh.Layout**: An object that describes a set of attributes that share a buffer index, offset, and stride.\n- **LowLevelMesh.Attribute**: An object that determines how to store vertex attribute data in memory and map it to RealityKit shader attributes.\n- **LowLevelMesh.VertexSemantic**: Designates the intended usage of a vertex attribute.\n- **LowLevelMesh.PartsCollection**: An object that holds a mutable collection low-level mesh parts.\n- **LowLevelBuffer**\n- **LowLevelInstanceData**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create an immersive game using native anchor support, environmental blending, model manipulation, and mesh instance duplication.",
          "name" : "Integrating virtual objects with your environment",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/integrating-virtual-objects-with-your-environment"
        },
        {
          "description" : "Use low-level mesh and texture APIs to achieve fast updates to a person’s brush strokes by integrating RealityKit with ARKit and SwiftUI.",
          "name" : "Creating a spatial drawing app with RealityKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/creating-a-spatial-drawing-app-with-realitykit"
        },
        {
          "description" : "A container for vertex data that you can use to create and update meshes using your own format.",
          "name" : "LowLevelMesh",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelMesh"
        },
        {
          "description" : "An object that describes the data format and layout of the buffers in a low-level mesh.",
          "name" : "LowLevelMesh.Descriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelMesh\/Descriptor-swift.struct"
        },
        {
          "description" : "An object that describes a range of primitives to display, and their material index.",
          "name" : "LowLevelMesh.Part",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelMesh\/Part"
        },
        {
          "description" : "An object that describes a set of attributes that share a buffer index, offset, and stride.",
          "name" : "LowLevelMesh.Layout",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelMesh\/Layout"
        },
        {
          "description" : "An object that determines how to store vertex attribute data in memory and map it to RealityKit shader attributes.",
          "name" : "LowLevelMesh.Attribute",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelMesh\/Attribute"
        },
        {
          "description" : "Designates the intended usage of a vertex attribute.",
          "name" : "LowLevelMesh.VertexSemantic",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelMesh\/VertexSemantic"
        },
        {
          "description" : "An object that holds a mutable collection low-level mesh parts.",
          "name" : "LowLevelMesh.PartsCollection",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelMesh\/PartsCollection"
        },
        {
          "description" : "",
          "name" : "LowLevelBuffer",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelBuffer"
        },
        {
          "description" : "",
          "name" : "LowLevelInstanceData",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/LowLevelInstanceData"
        }
      ],
      "title" : "Updatable meshes"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a plane with low-level mesh",
  "url" : "https:\/\/developer.apple.com\/documentation\/realitykit\/creating-a-plane-with-low-level-mesh"
}