{
  "abstract" : "Create entities that behave and react like physical objects in a RealityKit view.",
  "codeExamples" : [
    {
      "code" : "import SwiftUI\n\n@main\nstruct PhysicsBodiesApp: App {\n    var body: some Scene {\n        WindowGroup {\n            MainView()\n        }.windowStyle(.volumetric)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var body: some View {\n    GeometryReader3D { geometry in\n        RealityView { content in\n            addSpheres(content)\n            content.add(containmentCollisionBox)\n        } update: { content in\n            let localFrame = geometry.frame(in: .local)\n            let sceneFrame = content.convert(localFrame,\n                                             from: .local, to: .scene)\n\n            containmentCollisionBox.update(sceneFrame)\n        }.gesture(ForceDragGesture())\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let sphereEntity = ModelEntity(\n    mesh: MeshResource.generateSphere(radius: sphereRadius),\n    materials: [metallicSphereMaterial()]\n)",
      "language" : "swift"
    },
    {
      "code" : "private func metallicSphereMaterial(\n    hue: CGFloat = CGFloat.random(in: (0.0)...(1.0))\n) -> PhysicallyBasedMaterial {\n    var material = PhysicallyBasedMaterial()\n\n    let color = RealityKit.Material.Color(\n        hue: hue,\n        saturation: CGFloat.random(in: (0.5)...(1.0)),\n        brightness: 0.9,\n        alpha: 1.0)\n\n    material.baseColor = PhysicallyBasedMaterial.BaseColor(tint: color)\n    material.metallic = 1.0\n    material.roughness = 0.5\n    material.clearcoat = 1.0\n    material.clearcoatRoughness = 0.1\n\n    return material\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create the physics body from the same shape.\nlet shape = ShapeResource.generateSphere(radius: sphereRadius)\nsphereEntity.components.set(CollisionComponent(shapes: [shape]))\n\nvar physics = PhysicsBodyComponent(\n    shapes: [shape],\n    density: 10_000\n)\n\n\/\/ Make each sphere float in the air by turning off gravity.\nphysics.isAffectedByGravity = false\n\n\/\/ Add the physics component to the sphere.\nsphereEntity.components.set(physics)",
      "language" : "swift"
    },
    {
      "code" : "sphereEntity.components.set(SphereAttractionComponent())",
      "language" : "swift"
    },
    {
      "code" : "struct SphereAttractionSystem: System {\n    let entityQuery: EntityQuery\n\n    init(scene: RealityKit.Scene) {\n        let attractionComponentType = SphereAttractionComponent.self\n        entityQuery = EntityQuery(where: .has(attractionComponentType))\n    }\n\n    func update(context: SceneUpdateContext) {\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func update(context: SceneUpdateContext) {\n    let sphereEntities = context.entities(\n        matching: entityQuery,\n        updatingSystemWhen: .rendering\n    )\n\n    for case let sphere as ModelEntity in sphereEntities {\n        var aggregateForce: SIMD3<Float>\n\n        \/\/ Start with a force back to the center.\n        let centerForceStrength = Float(0.05)\n        let position = sphere.position(relativeTo: nil)\n        let distance = length_squared(position)\n\n        \/\/ Set the initial force with the inverse-square law.\n        aggregateForce = normalize(position) \/ distanceSquared\n\n        \/\/ Direct the force back to the center by negating the position vector.\n        aggregateForce *= -centerForceStrength\n        \n        let neighbors = context.entities(matching: entityQuery,\n                                         updatingSystemWhen: .rendering)\n\n        for neighbor in neighbors where neighbor != sphere {\n\n            let spherePosition = sphere.position(relativeTo: nil)\n            let neighborPosition = neighbor.position(relativeTo: nil)\n\n            let distance = length(neighborPosition - spherePosition)\n\n            \/\/ Calculate the force from the sphere to the neighbor.\n            let forceFactor = Float(0.1)\n            let forceVector = normalize(neighborPosition - spherePosition)\n            let neighborForce = forceFactor * forceVector \/ pow(distance, 2)\n            aggregateForce += neighborForce\n        }\n\n        \/\/ Add the combined force from all the sphere's neighbors.\n        sphere.addForce(aggregateForce, relativeTo: nil)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func update(_ boundingBox: BoundingBox) {\n    \/\/ ...\n\n    \/\/ Define the constants for the faces' geometry for convenience.\n    let min = boundingBox.min\n    let max = boundingBox.max\n    let center = boundingBox.center\n\n    let lHandFace = SIMD3<Float>(x: min.x, y: center.y, z: center.z)\n    let rHandFace = SIMD3<Float>(x: max.x, y: center.y, z: center.z)\n    let lowerFace = SIMD3<Float>(x: center.x, y: min.y, z: center.z)\n    let upperFace = SIMD3<Float>(x: center.x, y: max.y, z: center.z)\n    let nearFace = SIMD3<Float>(x: center.x, y: center.y, z: min.z)\n    let afarFace = SIMD3<Float>(x: center.x, y: center.y, z: max.z)\n\n    \/\/ Make each box relatively thin.\n    let thickness = Float(1E-3)\n\n    \/\/ Configure the size for the left and right faces.\n    var size = boundingBox.extents\n    size.x = thickness\n\n    \/\/ Create the left face of the collision containment cube.\n    var face = Entity.boxWithCollisionPhysics(lHandFace, size)\n    addChild(face)\n\n    \/\/ Create the right face of the collision containment cube.\n    face = Entity.boxWithCollisionPhysics(rHandFace, size)\n    addChild(face)\n\n    \/\/ Configure the size for the top and bottom faces.\n    size = boundingBox.extents\n    size.y = thickness\n\n   \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "import RealityKit\n\n\/\/\/ The default mass for a new box.\nprivate let defaultMass1Kg = Float(1.0)\n\nextension Entity {\n    \/\/ ...\n    static func boxWithCollisionPhysics(\n        _ location: SIMD3<Float>,\n        _ boxSize: SIMD3<Float>,\n        boxMass: Float = defaultMass1Kg\n    ) -> Entity {\n        \/\/ Create an entity for the box.\n        let boxEntity = Entity()\n\n        \/\/ Create the box's shape from the size.\n        let boxShape = ShapeResource.generateBox(size: boxSize)\n\n        \/\/ Create a collision component with the box's shape.\n        let collisionComponent = CollisionComponent(\n            shapes: [boxShape],\n            isStatic: true)\n\n        \/\/ Create a physics body component with the box's shape.\n        let physicsBodyComponent = PhysicsBodyComponent(\n            shapes: [boxShape],\n            mass: boxMass,\n            mode: PhysicsBodyMode.static\n        )\n\n        \/\/ Set the entity's position in the scene.\n        boxEntity.position = location\n\n        \/\/ Add the collision physics to the box entity.\n        boxEntity.components.set(collisionComponent)\n        boxEntity.components.set(physicsBodyComponent)\n        return boxEntity\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport RealityKit\n\nstruct ForceDragGesture: Gesture {\n\n    var body: some Gesture {\n        EntityDragGesture { entity, targetPosition in\n            guard let modelEntity = entity as? ModelEntity else { return }\n\n            let spherePosition = entity.position(relativeTo: nil)\n\n            let direction = targetPosition - spherePosition\n            var strength = length(direction)\n            if strength < 1.0 {\n                strength *= strength\n            }\n\n            let forceFactor: Float = 3000\n            let force = forceFactor * strength * simd_normalize(direction)\n            modelEntity.addForce(force, relativeTo: nil)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Highlight the sphere when a person looks at it.\nsphereEntity.components.set(HoverEffectComponent())\n\n\/\/ Configure the sphere to receive gesture inputs.\nsphereEntity.components.set(InputTargetComponent())",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport RealityKit\n\nstruct RelocateDragGesture: Gesture {\n    var body: some Gesture {\n        EntityDragGesture { entity, targetPosition in\n            entity.setPosition(targetPosition, relativeTo: nil)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "64042d810ec65fcef466ad28069dff9965b3ca9aecb7c1baf240fda11c4fd3c1",
  "crawledAt" : "2025-12-02T19:57:16Z",
  "id" : "8AFC9B67-0A14-4E18-AEF5-A854114411B9",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nThis sample demonstrates how to simulate multiple physical objects that collide with each other by creating a volumetric window with sphere entities that each have a collision component and a physics body component.\n\nThe sample also adds a custom component and system that applies an attraction force between the spheres, and gesture support so that a person can move the spheres within the volume.\n\n### Add a volumetric window to your app\n\nThe app starts by creating a scene that includes a window group with a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowStyle\/volumetric] style so that the spheres behave like physical objects in the environment.\n\nVolumetric windows are viewable from all sides and have a constant size in the environment. If you want to prioritize visibility from a distance rather than from all sides, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowStyle\/plain] window style instead. Plain windows are resizable, which can help people see the contents of a window from a distance, but there’s one optimal viewing angle.\n\nThe app’s main view creates the spheres and an invisible containment box that keeps the spheres from drifting out of the volume.\n\nSwiftUI calls the view’s `update` closure when one of its inputs change, such as `geometry` in this example, which is a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/GeometryReader3D] instance. The closure updates the collision box by passing the view’s current position and size in scene coordinates. To do this, the closure:\n\nCoordinate values in SwiftUI are typically in the hundreds of points, while coordinates in RealityKit often have much smaller values, typically fractions of a meter.\n\nThe view also adds a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/DragGesture] instance so that a person can move a sphere around and make it collide with the other spheres in the volume.\n\n### Create a model entity with a physics body\n\nThe app creates each sphere as a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity] instance with a spherical mesh.\n\nAlternatively, you can create an [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] instance and add a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent] to it, which is the equivalent of a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity].\n\nTo customize each sphere’s appearance, the app configures a material. The app applies a unique material with a random color to each sphere by creating and configuring a new [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial] instance.\n\nThe app configures each material so that is has a shiny, metallic look. It sets:\n\nCustomizing the attributes of materials, including color, roughness, and reflectiveness, adds a realistic appearance to the items in your scene.\n\nTo make the spheres interact with the physics system, the app adds a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CollisionComponent] and  a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent] to each sphere’s entity.\n\nThe collision component includes the entity in the scene’s physics simulation. The physics body component defines the entity’s physical shape and mass. By default, entities with a physics body component react to gravity, but the app makes the spheres float in the scene by setting the component’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent\/isAffectedByGravity] property to `false`.\n\n### Add attraction forces between all the spheres by creating a custom system\n\nThe app simulates forces of attraction between the spheres by defining two types:\n\nThe app adds each sphere to the system by setting the custom component to the sphere’s component set.\n\nThe sample’s `SphereAttractionComponent` structure conforms to the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System] protocol by implementing the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System\/init(scene:)] initializer and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System\/update(context:)] method it requires.\n\nThe app simulates an attractive force between each sphere and all the other spheres in the scene in the custom system’s `update()` method.\n\nWhen the app runs, the spheres move towards each other and clump together within the volume.\n\nFor more information about systems, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ecs-systems] and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/implementing-systems-for-entities-in-a-scene].\n\n### Keep the spheres in the volume by creating an invisible container with physics\n\nThe app prevents the spheres from moving out of the volume by creating a relatively thin box for each of the volume’s six boundaries.\n\nThe sample’s `ContainmentCollisionBox` class, which inherits from [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity], creates the six faces of the containment box in its `update(_:)` method.\n\nThe method creates each face by calling the `boxWithCollisionPhysics(_:_:boxMass:)` method the sample adds to [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] in an extension.\n\nThe method configures each face to physically interact with the spheres in the scene by adding an instance of [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CollisionComponent] and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent] to the face’s entity.\n\n\n\n\n\n### Add human interaction by including a gesture\n\nThe app lets a person move the spheres within the volume by adding a `ForceDragGesture` instance to the main view.\n\nThe type applies a force to the sphere where a drag gesture begins, which increases with the distance between the sphere and drag gesture’s current position, similar to a spring.\n\nTo enable gestures on the Entities, the sample adds an [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/InputTargetComponent] as well as a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/HoverEffectComponent] to provide feedback when a person looks at a sphere:\n\nThe `ForceDragGesture` type depends on the sample’s `EntityDragGesture` type, which handles the logic to start and end a drag gesture and updates its current position during the drag.\n\nThe sample also defines another gesture type, `RelocateDragGesture` which moves a sphere entity by changing its location, instead of applying a force.\n\nThis gesture effectively applies the equivalent of an infinite force, which can quickly move the sphere and the spheres it collides with. It directly modifies a sphere’s location and bypasses physics.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/realitykit\/simulating-physics-with-collisions-in-your-visionos-app\ncrawled: 2025-12-02T19:57:16Z\n---\n\n# Simulating physics with collisions in your visionOS app\n\n**Sample Code**\n\nCreate entities that behave and react like physical objects in a RealityKit view.\n\n## Overview\n\nThis sample demonstrates how to simulate multiple physical objects that collide with each other by creating a volumetric window with sphere entities that each have a collision component and a physics body component.\n\n\n\nThe sample also adds a custom component and system that applies an attraction force between the spheres, and gesture support so that a person can move the spheres within the volume.\n\n### Add a volumetric window to your app\n\nThe app starts by creating a scene that includes a window group with a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowStyle\/volumetric] style so that the spheres behave like physical objects in the environment.\n\n```swift\nimport SwiftUI\n\n@main\nstruct PhysicsBodiesApp: App {\n    var body: some Scene {\n        WindowGroup {\n            MainView()\n        }.windowStyle(.volumetric)\n    }\n}\n```\n\nVolumetric windows are viewable from all sides and have a constant size in the environment. If you want to prioritize visibility from a distance rather than from all sides, use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowStyle\/plain] window style instead. Plain windows are resizable, which can help people see the contents of a window from a distance, but there’s one optimal viewing angle.\n\nThe app’s main view creates the spheres and an invisible containment box that keeps the spheres from drifting out of the volume.\n\n```swift\nvar body: some View {\n    GeometryReader3D { geometry in\n        RealityView { content in\n            addSpheres(content)\n            content.add(containmentCollisionBox)\n        } update: { content in\n            let localFrame = geometry.frame(in: .local)\n            let sceneFrame = content.convert(localFrame,\n                                             from: .local, to: .scene)\n\n            containmentCollisionBox.update(sceneFrame)\n        }.gesture(ForceDragGesture())\n    }\n}\n```\n\nSwiftUI calls the view’s `update` closure when one of its inputs change, such as `geometry` in this example, which is a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/GeometryReader3D] instance. The closure updates the collision box by passing the view’s current position and size in scene coordinates. To do this, the closure:\n\n- Retrieves the view’s current position and size in SwiftUI coordinates, in points, as a [doc:\/\/com.apple.documentation\/documentation\/Spatial\/Rect3D] instance by calling the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/GeometryProxy3D\/frame(in:)] method of the `geometryReader` that contains the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/RealityView]\n- Converts the 3D rectangle from points to RealityKit scene coordinates, in meters, by calling the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/RealityViewContent] instance’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/RealityCoordinateSpaceConverting\/convert(_:from:to:)-3fumk] method\n\nCoordinate values in SwiftUI are typically in the hundreds of points, while coordinates in RealityKit often have much smaller values, typically fractions of a meter.\n\nThe view also adds a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/DragGesture] instance so that a person can move a sphere around and make it collide with the other spheres in the volume.\n\n### Create a model entity with a physics body\n\nThe app creates each sphere as a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity] instance with a spherical mesh.\n\n```swift\nlet sphereEntity = ModelEntity(\n    mesh: MeshResource.generateSphere(radius: sphereRadius),\n    materials: [metallicSphereMaterial()]\n)\n```\n\nAlternatively, you can create an [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] instance and add a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent] to it, which is the equivalent of a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelEntity].\n\nTo customize each sphere’s appearance, the app configures a material. The app applies a unique material with a random color to each sphere by creating and configuring a new [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial] instance.\n\n```swift\nprivate func metallicSphereMaterial(\n    hue: CGFloat = CGFloat.random(in: (0.0)...(1.0))\n) -> PhysicallyBasedMaterial {\n    var material = PhysicallyBasedMaterial()\n\n    let color = RealityKit.Material.Color(\n        hue: hue,\n        saturation: CGFloat.random(in: (0.5)...(1.0)),\n        brightness: 0.9,\n        alpha: 1.0)\n\n    material.baseColor = PhysicallyBasedMaterial.BaseColor(tint: color)\n    material.metallic = 1.0\n    material.roughness = 0.5\n    material.clearcoat = 1.0\n    material.clearcoatRoughness = 0.1\n\n    return material\n}\n```\n\nThe app configures each material so that is has a shiny, metallic look. It sets:\n\n- [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial\/baseColor-swift.property] to a random hue within a range of 80-100%.\n- [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial\/metallic-swift.property] to `1.0`, which makes the material reflective.\n- [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial\/roughness-swift.property] of `0.5`, a relatively high value, which makes the reflections blurrier.\n- [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial\/clearcoat-swift.property] to `1.0`, which gives the material white reflections on top of the metallic ones.\n- The [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial\/clearcoatRoughness-swift.property] to `0.1`, a relatively low value, which gives sharp clear coat reflections.\n\nCustomizing the attributes of materials, including color, roughness, and reflectiveness, adds a realistic appearance to the items in your scene.\n\n\n\nTo make the spheres interact with the physics system, the app adds a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CollisionComponent] and  a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent] to each sphere’s entity.\n\n```swift\n\/\/ Create the physics body from the same shape.\nlet shape = ShapeResource.generateSphere(radius: sphereRadius)\nsphereEntity.components.set(CollisionComponent(shapes: [shape]))\n\nvar physics = PhysicsBodyComponent(\n    shapes: [shape],\n    density: 10_000\n)\n\n\/\/ Make each sphere float in the air by turning off gravity.\nphysics.isAffectedByGravity = false\n\n\/\/ Add the physics component to the sphere.\nsphereEntity.components.set(physics)\n```\n\nThe collision component includes the entity in the scene’s physics simulation. The physics body component defines the entity’s physical shape and mass. By default, entities with a physics body component react to gravity, but the app makes the spheres float in the scene by setting the component’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent\/isAffectedByGravity] property to `false`.\n\n### Add attraction forces between all the spheres by creating a custom system\n\nThe app simulates forces of attraction between the spheres by defining two types:\n\n- `SphereAttractionSystem`\n- `SphereAttractionComponent`\n\nThe app adds each sphere to the system by setting the custom component to the sphere’s component set.\n\n```swift\nsphereEntity.components.set(SphereAttractionComponent())\n```\n\nThe sample’s `SphereAttractionComponent` structure conforms to the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System] protocol by implementing the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System\/init(scene:)] initializer and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System\/update(context:)] method it requires.\n\n```swift\nstruct SphereAttractionSystem: System {\n    let entityQuery: EntityQuery\n\n    init(scene: RealityKit.Scene) {\n        let attractionComponentType = SphereAttractionComponent.self\n        entityQuery = EntityQuery(where: .has(attractionComponentType))\n    }\n\n    func update(context: SceneUpdateContext) {\n        \/\/ ...\n    }\n}\n```\n\nThe app simulates an attractive force between each sphere and all the other spheres in the scene in the custom system’s `update()` method.\n\n```swift\nfunc update(context: SceneUpdateContext) {\n    let sphereEntities = context.entities(\n        matching: entityQuery,\n        updatingSystemWhen: .rendering\n    )\n\n    for case let sphere as ModelEntity in sphereEntities {\n        var aggregateForce: SIMD3<Float>\n\n        \/\/ Start with a force back to the center.\n        let centerForceStrength = Float(0.05)\n        let position = sphere.position(relativeTo: nil)\n        let distance = length_squared(position)\n\n        \/\/ Set the initial force with the inverse-square law.\n        aggregateForce = normalize(position) \/ distanceSquared\n\n        \/\/ Direct the force back to the center by negating the position vector.\n        aggregateForce *= -centerForceStrength\n        \n        let neighbors = context.entities(matching: entityQuery,\n                                         updatingSystemWhen: .rendering)\n\n        for neighbor in neighbors where neighbor != sphere {\n\n            let spherePosition = sphere.position(relativeTo: nil)\n            let neighborPosition = neighbor.position(relativeTo: nil)\n\n            let distance = length(neighborPosition - spherePosition)\n\n            \/\/ Calculate the force from the sphere to the neighbor.\n            let forceFactor = Float(0.1)\n            let forceVector = normalize(neighborPosition - spherePosition)\n            let neighborForce = forceFactor * forceVector \/ pow(distance, 2)\n            aggregateForce += neighborForce\n        }\n\n        \/\/ Add the combined force from all the sphere's neighbors.\n        sphere.addForce(aggregateForce, relativeTo: nil)\n    }\n}\n```\n\nWhen the app runs, the spheres move towards each other and clump together within the volume.\n\n\n\nFor more information about systems, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ecs-systems] and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/implementing-systems-for-entities-in-a-scene].\n\n### Keep the spheres in the volume by creating an invisible container with physics\n\nThe app prevents the spheres from moving out of the volume by creating a relatively thin box for each of the volume’s six boundaries.\n\nThe sample’s `ContainmentCollisionBox` class, which inherits from [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity], creates the six faces of the containment box in its `update(_:)` method.\n\n```swift\nfunc update(_ boundingBox: BoundingBox) {\n    \/\/ ...\n\n    \/\/ Define the constants for the faces' geometry for convenience.\n    let min = boundingBox.min\n    let max = boundingBox.max\n    let center = boundingBox.center\n\n    let lHandFace = SIMD3<Float>(x: min.x, y: center.y, z: center.z)\n    let rHandFace = SIMD3<Float>(x: max.x, y: center.y, z: center.z)\n    let lowerFace = SIMD3<Float>(x: center.x, y: min.y, z: center.z)\n    let upperFace = SIMD3<Float>(x: center.x, y: max.y, z: center.z)\n    let nearFace = SIMD3<Float>(x: center.x, y: center.y, z: min.z)\n    let afarFace = SIMD3<Float>(x: center.x, y: center.y, z: max.z)\n\n    \/\/ Make each box relatively thin.\n    let thickness = Float(1E-3)\n\n    \/\/ Configure the size for the left and right faces.\n    var size = boundingBox.extents\n    size.x = thickness\n\n    \/\/ Create the left face of the collision containment cube.\n    var face = Entity.boxWithCollisionPhysics(lHandFace, size)\n    addChild(face)\n\n    \/\/ Create the right face of the collision containment cube.\n    face = Entity.boxWithCollisionPhysics(rHandFace, size)\n    addChild(face)\n\n    \/\/ Configure the size for the top and bottom faces.\n    size = boundingBox.extents\n    size.y = thickness\n\n   \/\/ ...\n}\n```\n\nThe method creates each face by calling the `boxWithCollisionPhysics(_:_:boxMass:)` method the sample adds to [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] in an extension.\n\n```swift\nimport RealityKit\n\n\/\/\/ The default mass for a new box.\nprivate let defaultMass1Kg = Float(1.0)\n\nextension Entity {\n    \/\/ ...\n    static func boxWithCollisionPhysics(\n        _ location: SIMD3<Float>,\n        _ boxSize: SIMD3<Float>,\n        boxMass: Float = defaultMass1Kg\n    ) -> Entity {\n        \/\/ Create an entity for the box.\n        let boxEntity = Entity()\n\n        \/\/ Create the box's shape from the size.\n        let boxShape = ShapeResource.generateBox(size: boxSize)\n\n        \/\/ Create a collision component with the box's shape.\n        let collisionComponent = CollisionComponent(\n            shapes: [boxShape],\n            isStatic: true)\n\n        \/\/ Create a physics body component with the box's shape.\n        let physicsBodyComponent = PhysicsBodyComponent(\n            shapes: [boxShape],\n            mass: boxMass,\n            mode: PhysicsBodyMode.static\n        )\n\n        \/\/ Set the entity's position in the scene.\n        boxEntity.position = location\n\n        \/\/ Add the collision physics to the box entity.\n        boxEntity.components.set(collisionComponent)\n        boxEntity.components.set(physicsBodyComponent)\n        return boxEntity\n    }\n}\n```\n\nThe method configures each face to physically interact with the spheres in the scene by adding an instance of [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CollisionComponent] and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent] to the face’s entity.\n\n\n\n\n\n\n\n### Add human interaction by including a gesture\n\nThe app lets a person move the spheres within the volume by adding a `ForceDragGesture` instance to the main view.\n\n```swift\nimport SwiftUI\nimport RealityKit\n\nstruct ForceDragGesture: Gesture {\n\n    var body: some Gesture {\n        EntityDragGesture { entity, targetPosition in\n            guard let modelEntity = entity as? ModelEntity else { return }\n\n            let spherePosition = entity.position(relativeTo: nil)\n\n            let direction = targetPosition - spherePosition\n            var strength = length(direction)\n            if strength < 1.0 {\n                strength *= strength\n            }\n\n            let forceFactor: Float = 3000\n            let force = forceFactor * strength * simd_normalize(direction)\n            modelEntity.addForce(force, relativeTo: nil)\n        }\n    }\n}\n```\n\nThe type applies a force to the sphere where a drag gesture begins, which increases with the distance between the sphere and drag gesture’s current position, similar to a spring.\n\n\n\nTo enable gestures on the Entities, the sample adds an [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/InputTargetComponent] as well as a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/HoverEffectComponent] to provide feedback when a person looks at a sphere:\n\n```swift\n\/\/ Highlight the sphere when a person looks at it.\nsphereEntity.components.set(HoverEffectComponent())\n\n\/\/ Configure the sphere to receive gesture inputs.\nsphereEntity.components.set(InputTargetComponent())\n```\n\nThe `ForceDragGesture` type depends on the sample’s `EntityDragGesture` type, which handles the logic to start and end a drag gesture and updates its current position during the drag.\n\nThe sample also defines another gesture type, `RelocateDragGesture` which moves a sphere entity by changing its location, instead of applying a force.\n\n```swift\nimport SwiftUI\nimport RealityKit\n\nstruct RelocateDragGesture: Gesture {\n    var body: some Gesture {\n        EntityDragGesture { entity, targetPosition in\n            entity.setPosition(targetPosition, relativeTo: nil)\n        }\n    }\n}\n```\n\nThis gesture effectively applies the equivalent of an infinite force, which can quickly move the sphere and the spheres it collides with. It directly modifies a sphere’s location and bypasses physics.\n\n\n\n## Collision shapes and groups\n\n- **Configuring Collision in RealityKit**: Use collision groups and collision filters to control which objects collide.\n- **CollisionComponent**: A component that gives an entity the ability to collide with other entities that also have collision components.\n- **CollisionComponent.Mode**: A mode that dictates how much collision data is collected for a given entity.\n- **ShapeResource**: A representation of a shape.\n- **ShapeResourceError**\n- **CollisionGroup**: A bitmask used to define the collision group to which an entity belongs.\n- **CollisionFilter**: A set of masks that determine whether entities can collide during simulations.\n- **TriggerVolume**: An invisible 3D shape that detects when objects enter or exit a given region of space.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use collision groups and collision filters to control which objects collide.",
          "name" : "Configuring Collision in RealityKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/configuring-collision-in-realitykit"
        },
        {
          "description" : "A component that gives an entity the ability to collide with other entities that also have collision components.",
          "name" : "CollisionComponent",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CollisionComponent"
        },
        {
          "description" : "A mode that dictates how much collision data is collected for a given entity.",
          "name" : "CollisionComponent.Mode",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CollisionComponent\/Mode-swift.enum"
        },
        {
          "description" : "A representation of a shape.",
          "name" : "ShapeResource",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ShapeResource"
        },
        {
          "description" : "",
          "name" : "ShapeResourceError",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ShapeResourceError"
        },
        {
          "description" : "A bitmask used to define the collision group to which an entity belongs.",
          "name" : "CollisionGroup",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CollisionGroup"
        },
        {
          "description" : "A set of masks that determine whether entities can collide during simulations.",
          "name" : "CollisionFilter",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CollisionFilter"
        },
        {
          "description" : "An invisible 3D shape that detects when objects enter or exit a given region of space.",
          "name" : "TriggerVolume",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/TriggerVolume"
        }
      ],
      "title" : "Collision shapes and groups"
    }
  ],
  "source" : "appleJSON",
  "title" : "Simulating physics with collisions in your visionOS app",
  "url" : "https:\/\/developer.apple.com\/documentation\/realitykit\/simulating-physics-with-collisions-in-your-visionos-app"
}