{
  "abstract" : "Load Reality Composer files that aren’t part of your Xcode project.",
  "codeExamples" : [
    {
      "code" : "func createRealityURL(filename: String, \n                      fileExtension: String, \n                      sceneName:String) -> URL? {\n    \/\/ Create a URL that points to the specified Reality file. \n    guard let realityFileURL = Bundle.main.url(forResource: filename, \n                                               withExtension: fileExtension) else {\n        print(\"Error finding Reality file \\(filename).\\(fileExtension)\")\n        return nil\n    }\n\n    \/\/ Append the scene name to the URL to point to \n    \/\/ a single scene within the file.\n    let realityFileSceneURL = realityFileURL.appendingPathComponent(sceneName, \n                                                                    isDirectory: false)\n    return realityFileSceneURL\n} ",
      "language" : "swift"
    },
    {
      "code" : "var streams = [Combine.AnyCancellable]()",
      "language" : "swift"
    },
    {
      "code" : "func loadRealityComposerSceneAsync (filename: String,\n                                    fileExtension: String,\n                                    sceneName: String,\n                                    completion: @escaping (Swift.Result<(Entity & HasAnchoring)?, Swift.Error>) -> Void) {\n\n    guard let realityFileSceneURL = createRealityURL(filename: filename, fileExtension: fileExtension, sceneName: sceneName) else {\n        print(\"Error: Unable to find specified file in application bundle\")\n        return\n    }\n\n    let loadRequest = Entity.loadAnchorAsync(contentsOf: realityFileSceneURL)\n    let cancellable = loadRequest.sink(receiveCompletion: { (loadCompletion) in\n        if case let .failure(error) = loadCompletion {\n            completion(.failure(error))\n        }\n    }, receiveValue: { (entity) in\n        completion(.success(entity))\n    })\n    cancellable.store(in: &streams)\n}",
      "language" : "swift"
    },
    {
      "code" : "func loadRealityComposerScene (filename: String,\n                                fileExtension: String,\n                                sceneName: String) -> (Entity & HasAnchoring)? {\n    guard let realitySceneURL = createRealityURL(filename: filename,\n                                                 fileExtension: fileExtension,\n                                                 sceneName: sceneName) else {\n        return nil\n    }\n    let loadedAnchor = try? Entity.loadAnchor(contentsOf: realitySceneURL)\n\n    return loadedAnchor\n}\n",
      "language" : "swift"
    },
    {
      "code" : "extension ViewController : Subscriber {\n\n    \/\/ loadModelAsync loads a ModelEntity, so declare \n    \/\/ that as the Input type.\n    typealias Input = ModelEntity\n\n    \/\/ If loadModelAsync fails, it returns an Error instance, \n    \/\/ so declare Error as the Failure associated-object type.\n    typealias Failure = Error\n\n    \/\/ The publisher has finished, so ask it for the result \n    \/\/ as a single item.\n    func receive(subscription: Subscription) {\n        subscription.request(.max(1))\n    }\n\n    \/\/ You receive the model here and assign it to a property\n    \/\/ so you can use it outside of this method. \n    func receive(_ input: ModelEntity) -> Subscribers.Demand {\n        \/\/ Assign to robot, a property declared in your \n        \/\/ main view-controller class\n        robot = input\n        return .none\n    }\n\n    \/\/ When the publisher is done - either it has sent the \n    \/\/ model or it has errored - this method is called.\n    func receive(completion: Subscribers.Completion<Error>) {\n        switch (completion) {\n            case .failure(let error):\n                print(\"Error loading model: \\(error)\")\n            case .finished:\n                print(\"Model loaded successfully\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let request = Entity.loadModelAsync(contentsOf: robotURL)\nrequest.receive(subscriber: self)",
      "language" : "swift"
    },
    {
      "code" : "var loadedModel: Entity?\nif let theURL = Bundle.main.url(forResource: \"myModel\", withExtension: \"usdz\") {\n    let loadedModel = try? Entity.loadModel(contentsOf: theURL)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ca72ddde6ccf3fd2c817d787f33dc48c096f3b501de6deac922f7fac8a6dcdbe",
  "crawledAt" : "2025-12-02T20:15:12Z",
  "id" : "08D1923D-87E5-4099-A8BD-D194D31723E6",
  "kind" : "article",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nAlthough Xcode generates loading methods for all Reality Composer files in your Xcode project, there are times when you need to load them without the benefit of those generated loader methods. This scenario can happen, for example, when loading content downloaded as part of an in-app purchase bundle from the App Store.\n\nYou can manually load scenes synchronously or asynchronously. Unless your Reality Composer scene is very small, use the asynchronous method, which loads scenes in the background. Synchronous loading occurs on the main thread, so your app may become unresponsive if you use that method to load even moderately complex scenes.\n\n### Create a scene URL\n\nRegardless of whether you plan to load the scene synchronously or asynchronously, the first step is to create a URL that points to the Reality file that contains the scene you want to load. Then append the name of the scene to the URL.\n\nHere’s an example of building a URL to load a scene from a Reality file inside your app’s bundle:\n\n### Load the scene asynchronously from the URL\n\n[doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] provides the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadAnchorAsync(contentsOf:withName:)] method for loading scenes asynchronously from a URL. Loading in this manner uses the Combine framework and returns an [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object that you use to cancel scene loading.\n\nYou must maintain a strong reference to the returned [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object until loading has completed. Otherwise, the load process cancels as soon as the returned [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object is deallocated. To keep a strong reference to the returned [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object, store it in an array.\n\nThis example shows how to declare an array variable in your view controller or coordinator class to hold instances of [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable]:\n\nLoad your scene asynchronously, storing the [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object in that array using the [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable\/store(in:)-6cr9i] method instead of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array\/append(_:)] method. In this way, you ensure that the system won’t cancel your load operation.\n\nThis example shows how to asynchronously load a scene from a [https:\/\/developer.apple.com\/library\/archive\/documentation\/Carbon\/Conceptual\/LaunchServicesConcepts\/LSCGlossary\/LSCGlossary.html#\/\/apple_ref\/doc\/uid\/TP30000999-CH205-CBABFJEB]:\n\n### Load the scene synchronously from the URL\n\nCall the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadAnchor(contentsOf:withName:)] method on [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] and pass in a scene URL.\n\n### Load a USDZ file asynchronously\n\nYou can load USDZ files asynchronously in the background using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadModelAsync(contentsOf:withName:)] method on [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity]. Asynchronous loading of USDZ files also requires the [doc:\/\/com.apple.documentation\/documentation\/Combine] framework. To receive the scene once it’s loaded, the receiving class must conform to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscriber] protocol.\n\nThis example shows you how to conform a view controller to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscriber] protocol so it can receive the asynchronously loaded scene:\n\nOnce you set up your view controller as a [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscriber], you can start loading a USDZ file as in this example:\n\nFor more information on using the [doc:\/\/com.apple.documentation\/documentation\/Combine] Framework, see [doc:\/\/com.apple.documentation\/documentation\/Combine\/receiving-and-handling-events-with-combine].\n\n### Load a USDZ file synchronously\n\nYou can also load individual 3D models from USDZ files for use in your Reality Composer scenes. This is especially useful, for example, for loading objects that you might spawn multiple times in response to user input. In that case, you don’t want the asset loaded as part of your Reality Composer scene. Instead, you want to load it separately and add it to your scene when needed.\n\nYou can load a model synchronously using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadModel(contentsOf:withName:)] function on [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity], as in this example:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/loading-reality-composer-files-manually-without-generated-code\ncrawled: 2025-12-02T20:15:12Z\n---\n\n# Loading Reality Composer files manually without generated code\n\n**Article**\n\nLoad Reality Composer files that aren’t part of your Xcode project.\n\n## Overview\n\nAlthough Xcode generates loading methods for all Reality Composer files in your Xcode project, there are times when you need to load them without the benefit of those generated loader methods. This scenario can happen, for example, when loading content downloaded as part of an in-app purchase bundle from the App Store.\n\nYou can manually load scenes synchronously or asynchronously. Unless your Reality Composer scene is very small, use the asynchronous method, which loads scenes in the background. Synchronous loading occurs on the main thread, so your app may become unresponsive if you use that method to load even moderately complex scenes.\n\n### Create a scene URL\n\nRegardless of whether you plan to load the scene synchronously or asynchronously, the first step is to create a URL that points to the Reality file that contains the scene you want to load. Then append the name of the scene to the URL.\n\nHere’s an example of building a URL to load a scene from a Reality file inside your app’s bundle:\n\n```swift\nfunc createRealityURL(filename: String, \n                      fileExtension: String, \n                      sceneName:String) -> URL? {\n    \/\/ Create a URL that points to the specified Reality file. \n    guard let realityFileURL = Bundle.main.url(forResource: filename, \n                                               withExtension: fileExtension) else {\n        print(\"Error finding Reality file \\(filename).\\(fileExtension)\")\n        return nil\n    }\n\n    \/\/ Append the scene name to the URL to point to \n    \/\/ a single scene within the file.\n    let realityFileSceneURL = realityFileURL.appendingPathComponent(sceneName, \n                                                                    isDirectory: false)\n    return realityFileSceneURL\n} \n```\n\n### Load the scene asynchronously from the URL\n\n[doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] provides the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadAnchorAsync(contentsOf:withName:)] method for loading scenes asynchronously from a URL. Loading in this manner uses the Combine framework and returns an [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object that you use to cancel scene loading.\n\nYou must maintain a strong reference to the returned [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object until loading has completed. Otherwise, the load process cancels as soon as the returned [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object is deallocated. To keep a strong reference to the returned [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object, store it in an array.\n\nThis example shows how to declare an array variable in your view controller or coordinator class to hold instances of [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable]:\n\n```swift\nvar streams = [Combine.AnyCancellable]()\n```\n\nLoad your scene asynchronously, storing the [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable] object in that array using the [doc:\/\/com.apple.documentation\/documentation\/Combine\/AnyCancellable\/store(in:)-6cr9i] method instead of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array\/append(_:)] method. In this way, you ensure that the system won’t cancel your load operation.\n\nThis example shows how to asynchronously load a scene from a [https:\/\/developer.apple.com\/library\/archive\/documentation\/Carbon\/Conceptual\/LaunchServicesConcepts\/LSCGlossary\/LSCGlossary.html#\/\/apple_ref\/doc\/uid\/TP30000999-CH205-CBABFJEB]:\n\n```swift\nfunc loadRealityComposerSceneAsync (filename: String,\n                                    fileExtension: String,\n                                    sceneName: String,\n                                    completion: @escaping (Swift.Result<(Entity & HasAnchoring)?, Swift.Error>) -> Void) {\n\n    guard let realityFileSceneURL = createRealityURL(filename: filename, fileExtension: fileExtension, sceneName: sceneName) else {\n        print(\"Error: Unable to find specified file in application bundle\")\n        return\n    }\n\n    let loadRequest = Entity.loadAnchorAsync(contentsOf: realityFileSceneURL)\n    let cancellable = loadRequest.sink(receiveCompletion: { (loadCompletion) in\n        if case let .failure(error) = loadCompletion {\n            completion(.failure(error))\n        }\n    }, receiveValue: { (entity) in\n        completion(.success(entity))\n    })\n    cancellable.store(in: &streams)\n}\n```\n\n\n\n### Load the scene synchronously from the URL\n\nCall the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadAnchor(contentsOf:withName:)] method on [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity] and pass in a scene URL.\n\n```swift\nfunc loadRealityComposerScene (filename: String,\n                                fileExtension: String,\n                                sceneName: String) -> (Entity & HasAnchoring)? {\n    guard let realitySceneURL = createRealityURL(filename: filename,\n                                                 fileExtension: fileExtension,\n                                                 sceneName: sceneName) else {\n        return nil\n    }\n    let loadedAnchor = try? Entity.loadAnchor(contentsOf: realitySceneURL)\n\n    return loadedAnchor\n}\n\n```\n\n### Load a USDZ file asynchronously\n\nYou can load USDZ files asynchronously in the background using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadModelAsync(contentsOf:withName:)] method on [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity]. Asynchronous loading of USDZ files also requires the [doc:\/\/com.apple.documentation\/documentation\/Combine] framework. To receive the scene once it’s loaded, the receiving class must conform to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscriber] protocol.\n\nThis example shows you how to conform a view controller to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscriber] protocol so it can receive the asynchronously loaded scene:\n\n```swift\nextension ViewController : Subscriber {\n\n    \/\/ loadModelAsync loads a ModelEntity, so declare \n    \/\/ that as the Input type.\n    typealias Input = ModelEntity\n\n    \/\/ If loadModelAsync fails, it returns an Error instance, \n    \/\/ so declare Error as the Failure associated-object type.\n    typealias Failure = Error\n\n    \/\/ The publisher has finished, so ask it for the result \n    \/\/ as a single item.\n    func receive(subscription: Subscription) {\n        subscription.request(.max(1))\n    }\n\n    \/\/ You receive the model here and assign it to a property\n    \/\/ so you can use it outside of this method. \n    func receive(_ input: ModelEntity) -> Subscribers.Demand {\n        \/\/ Assign to robot, a property declared in your \n        \/\/ main view-controller class\n        robot = input\n        return .none\n    }\n\n    \/\/ When the publisher is done - either it has sent the \n    \/\/ model or it has errored - this method is called.\n    func receive(completion: Subscribers.Completion<Error>) {\n        switch (completion) {\n            case .failure(let error):\n                print(\"Error loading model: \\(error)\")\n            case .finished:\n                print(\"Model loaded successfully\")\n        }\n    }\n}\n```\n\nOnce you set up your view controller as a [doc:\/\/com.apple.documentation\/documentation\/Combine\/Subscriber], you can start loading a USDZ file as in this example:\n\n```swift\nlet request = Entity.loadModelAsync(contentsOf: robotURL)\nrequest.receive(subscriber: self)\n```\n\nFor more information on using the [doc:\/\/com.apple.documentation\/documentation\/Combine] Framework, see [doc:\/\/com.apple.documentation\/documentation\/Combine\/receiving-and-handling-events-with-combine].\n\n### Load a USDZ file synchronously\n\nYou can also load individual 3D models from USDZ files for use in your Reality Composer scenes. This is especially useful, for example, for loading objects that you might spawn multiple times in response to user input. In that case, you don’t want the asset loaded as part of your Reality Composer scene. Instead, you want to load it separately and add it to your scene when needed.\n\nYou can load a model synchronously using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity\/loadModel(contentsOf:withName:)] function on [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/Entity], as in this example:\n\n```swift\nvar loadedModel: Entity?\nif let theURL = Bundle.main.url(forResource: \"myModel\", withExtension: \"usdz\") {\n    let loadedModel = try? Entity.loadModel(contentsOf: theURL)\n}\n```\n\n## Scene creation\n\n- **Loading Reality Composer files using generated code**: Leverage automatically generated code to load scenes from Xcode.\n- **Adding elements to a 3D scene**: Add assets to your scene from Reality Composer’s library, or import custom assets.\n- **Configuring elements in a scene**: Define the appearance and behavior of objects in a scene.\n- **Arranging elements in a scene**: Manipulate objects to complete your Reality Composer scene.\n- **Adding procedural assets to a scene**: Create procedurally generated shape primitives to your Reality Composer scene.\n- **Improving the Accessibility of RealityKit Apps**: Incorporate assistive technologies in your augmented reality app.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Leverage automatically generated code to load scenes from Xcode.",
          "name" : "Loading Reality Composer files using generated code",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/loading-reality-composer-files-using-generated-code"
        },
        {
          "description" : "Add assets to your scene from Reality Composer’s library, or import custom assets.",
          "name" : "Adding elements to a 3D scene",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/adding-elements-to-a-3d-scene"
        },
        {
          "description" : "Define the appearance and behavior of objects in a scene.",
          "name" : "Configuring elements in a scene",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/configuring-elements-in-a-scene"
        },
        {
          "description" : "Manipulate objects to complete your Reality Composer scene.",
          "name" : "Arranging elements in a scene",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/arranging-elements-in-a-scene"
        },
        {
          "description" : "Create procedurally generated shape primitives to your Reality Composer scene.",
          "name" : "Adding procedural assets to a scene",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/adding-procedural-assets-to-a-scene"
        },
        {
          "description" : "Incorporate assistive technologies in your augmented reality app.",
          "name" : "Improving the Accessibility of RealityKit Apps",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/improving-the-accessibility-of-realitykit-apps"
        }
      ],
      "title" : "Scene creation"
    }
  ],
  "source" : "appleJSON",
  "title" : "Loading Reality Composer files manually without generated code",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/loading-reality-composer-files-manually-without-generated-code"
}