{
  "abstract" : "Send nontexture data from Swift to your Metal shaders using a shared header file.",
  "codeExamples" : [
    {
      "code" : "#include <simd\/simd.h>\n\n#ifndef MyArguments_h\n#define MyArguments_h\nstruct MyArguments\n{\n    float widgetTolerance\n    uint32_t widgetHeight;\n};\n#endif \/* MyArguments_h *\/",
      "language" : "occ"
    },
    {
      "code" : "#import \"MyArguments.h\"",
      "language" : "occ"
    },
    {
      "code" : "$(PROJECT_DIR)\/$(PROJECT_NAME)\/MyProject-Bridging-Header.h",
      "language" : "other"
    },
    {
      "code" : "var args = MyArguments(widgetTolerance: 0.3493, widgetHeight: 5)\nencoder.setBytes(&args, length: MemoryLayout<MyArguments>.stride, index: 0)",
      "language" : "swift"
    },
    {
      "code" : "#include <metal_stdlib>\n#include \"MyArguments.h\" \n\nusing namespace metal;",
      "language" : "other"
    },
    {
      "code" : "[[kernel]]\nvoid myPostProcess(uint2 gid [[thread_position_in_grid]],\n                         texture2d<half, access::read> inColor [[texture(0)]],\n                         texture2d<half, access::write> outColor [[texture(1)]],\n                         constant MyArguments *args [[buffer(0)]])\n{\n    auto widgetHeight = args->widgetHeight;\n    auto widgetTolerance = args->widgetTolerance;\n\n    \/\/ Your compute function logic goes here.\n}",
      "language" : "other"
    }
  ],
  "contentHash" : "8e22c0bbeeb7f315391794663dbbab2bcd4411c9fc8aad865c8e5d30000d8114",
  "crawledAt" : "2025-12-02T15:55:39Z",
  "id" : "0D9DD515-517B-4011-A32A-8AE6D543C366",
  "kind" : "article",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\n[doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder] provides [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setTexture(_:index:)] to pass image data to a Metal compute function. Compute functions can access those textures using `[[texture(`*index*`)]]`. The compute command encoder doesn’t, however, provide an easy way to pass structured data to a compute function. You pass all nonimage data as an unstructured buffer using the encoder’s [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] methods. It’s possible to use [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] to pass data contained in a Swift struct to your compute function, which can receive it as a Metal struct as long as the two structs use the same exact memory layout. By using a bridging header and defining the struct in C, Metal and Swift can import the same header file and use the same struct with the same layout in memory.\n\n### Create a header file\n\nCreate a new header file in your Xcode project. In the file, define a C struct with the properties you need to send from Swift to your Metal compute function. The struct should only contain simple datatypes. Don’t pass textures, samplers, or other complex objects in your struct. Also, don’t use any datatype that doesn’t have a consistent size in both Metal and Swift and on all devices. An `int` datatype, for example, can have different sizes on different devices. Instead, use datatypes like `int32_t`, `uint16_t`, or `float`, which are the same size everywhere.\n\n### Import the struct in a bridging header\n\nIf your project already has a bridging header, import the struct header file in it. If your project doesn’t have a bridging header, create a new header file in your project to import the struct’s header. By importing using a bridging header, Swift sees the C struct as a Swift struct. Because Metal is a superset of C++, which is a superset of C, Metal interprets the same struct as a Metal struct.\n\nIf you created a new bridging header, you must tell Xcode that it’s your project’s bridging header. To do that, go to the build settings for your target and look for a setting called Objective-C Bridging Header. Set it to the path of the bridging header file you created. Don’t use an absolute path. Instead, create a path relative to `$(PROJECT_DIR)`, which points to your project’s main directory. Your entry should look something like this:\n\n### Encode the swift struct as bytes\n\nIn your Swift code, create an instance of the struct to hold the values to send to your compute function. Then, in the code that dispatches your compute function, call [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] and pass the struct as a data buffer before you call [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/dispatchThreads(_:threadsPerThreadgroup:)] to execute the compute function.\n\n### Retrieve the buffer in the compute function\n\nIn the Metal file that contains your compute function, include the new header file after including *metal_stdlib*.\n\nIn your compute function, retrieve the buffer using `[[buffer(`*index*`)]]` and cast it to your struct. Metal allows you to do that as a function parameter, or you can retrieve it in the body of your function and store it in a variable. Make sure the index value you pass to `[[buffer(`*index*`)]]` matches the index value you used in your [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] call. Your compute function can access members of the retrieved struct using the `->` operator.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/passing-structured-data-to-a-metal-compute-function\ncrawled: 2025-12-02T15:55:39Z\n---\n\n# Passing Structured Data to a Metal Compute Function\n\n**Article**\n\nSend nontexture data from Swift to your Metal shaders using a shared header file.\n\n## Overview\n\n[doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder] provides [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setTexture(_:index:)] to pass image data to a Metal compute function. Compute functions can access those textures using `[[texture(`*index*`)]]`. The compute command encoder doesn’t, however, provide an easy way to pass structured data to a compute function. You pass all nonimage data as an unstructured buffer using the encoder’s [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] methods. It’s possible to use [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] to pass data contained in a Swift struct to your compute function, which can receive it as a Metal struct as long as the two structs use the same exact memory layout. By using a bridging header and defining the struct in C, Metal and Swift can import the same header file and use the same struct with the same layout in memory.\n\n\n\n### Create a header file\n\nCreate a new header file in your Xcode project. In the file, define a C struct with the properties you need to send from Swift to your Metal compute function. The struct should only contain simple datatypes. Don’t pass textures, samplers, or other complex objects in your struct. Also, don’t use any datatype that doesn’t have a consistent size in both Metal and Swift and on all devices. An `int` datatype, for example, can have different sizes on different devices. Instead, use datatypes like `int32_t`, `uint16_t`, or `float`, which are the same size everywhere.\n\n```occ\n#include <simd\/simd.h>\n\n#ifndef MyArguments_h\n#define MyArguments_h\nstruct MyArguments\n{\n    float widgetTolerance\n    uint32_t widgetHeight;\n};\n#endif \/* MyArguments_h *\/\n```\n\n### Import the struct in a bridging header\n\nIf your project already has a bridging header, import the struct header file in it. If your project doesn’t have a bridging header, create a new header file in your project to import the struct’s header. By importing using a bridging header, Swift sees the C struct as a Swift struct. Because Metal is a superset of C++, which is a superset of C, Metal interprets the same struct as a Metal struct.\n\n```occ\n#import \"MyArguments.h\"\n```\n\nIf you created a new bridging header, you must tell Xcode that it’s your project’s bridging header. To do that, go to the build settings for your target and look for a setting called Objective-C Bridging Header. Set it to the path of the bridging header file you created. Don’t use an absolute path. Instead, create a path relative to `$(PROJECT_DIR)`, which points to your project’s main directory. Your entry should look something like this:\n\n```other\n$(PROJECT_DIR)\/$(PROJECT_NAME)\/MyProject-Bridging-Header.h\n```\n\n### Encode the swift struct as bytes\n\nIn your Swift code, create an instance of the struct to hold the values to send to your compute function. Then, in the code that dispatches your compute function, call [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] and pass the struct as a data buffer before you call [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/dispatchThreads(_:threadsPerThreadgroup:)] to execute the compute function.\n\n```swift\nvar args = MyArguments(widgetTolerance: 0.3493, widgetHeight: 5)\nencoder.setBytes(&args, length: MemoryLayout<MyArguments>.stride, index: 0)\n```\n\n### Retrieve the buffer in the compute function\n\nIn the Metal file that contains your compute function, include the new header file after including *metal_stdlib*.\n\n```other\n#include <metal_stdlib>\n#include \"MyArguments.h\" \n\nusing namespace metal;\n```\n\nIn your compute function, retrieve the buffer using `[[buffer(`*index*`)]]` and cast it to your struct. Metal allows you to do that as a function parameter, or you can retrieve it in the body of your function and store it in a variable. Make sure the index value you pass to `[[buffer(`*index*`)]]` matches the index value you used in your [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder\/setBytes(_:length:index:)] call. Your compute function can access members of the retrieved struct using the `->` operator.\n\n```other\n[[kernel]]\nvoid myPostProcess(uint2 gid [[thread_position_in_grid]],\n                         texture2d<half, access::read> inColor [[texture(0)]],\n                         texture2d<half, access::write> outColor [[texture(1)]],\n                         constant MyArguments *args [[buffer(0)]])\n{\n    auto widgetHeight = args->widgetHeight;\n    auto widgetTolerance = args->widgetTolerance;\n\n    \/\/ Your compute function logic goes here.\n}\n```\n\n## Metal effects\n\n- **Using Metal performance shaders to create custom postprocess effects**: Leverage the Metal Performance Shaders framework to create special rendering effects for your RealityKit scenes.\n- **Implementing special rendering effects with RealityKit postprocessing**: Implement a variety of postprocessing techniques to alter RealityKit rendering.\n- **Checking the pixel format of a postprocess effect’s output texture**: Make sure your postprocess effect works on all devices.\n- **Implementing postprocess effects using Metal compute functions**: Create custom shaders to implement postprocess effects.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Leverage the Metal Performance Shaders framework to create special rendering effects for your RealityKit scenes.",
          "name" : "Using Metal performance shaders to create custom postprocess effects",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/using-metal-performance-shaders-to-create-custom-postprocess-effects"
        },
        {
          "description" : "Implement a variety of postprocessing techniques to alter RealityKit rendering.",
          "name" : "Implementing special rendering effects with RealityKit postprocessing",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/implementing-special-rendering-effects-with-realitykit-postprocessing"
        },
        {
          "description" : "Make sure your postprocess effect works on all devices.",
          "name" : "Checking the pixel format of a postprocess effect’s output texture",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/checking-the-pixel-format-of-a-postprocess-effect-s-output-texture"
        },
        {
          "description" : "Create custom shaders to implement postprocess effects.",
          "name" : "Implementing postprocess effects using Metal compute functions",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/implementing-postprocess-effects-using-metal-compute-functions"
        }
      ],
      "title" : "Metal effects"
    }
  ],
  "source" : "appleJSON",
  "title" : "Passing Structured Data to a Metal Compute Function",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/passing-structured-data-to-a-metal-compute-function"
}