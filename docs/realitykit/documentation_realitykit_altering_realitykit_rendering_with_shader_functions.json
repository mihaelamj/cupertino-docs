{
  "abstract" : "Create rendering effects by writing surface shaders and geometry modifiers.",
  "codeExamples" : [
    {
      "code" : "\/\/ Get the first float in the custom vector, which contains the animation\n\/\/ progress for this entity as a value between 0.0 and 1.0.\nfloat animationProgress = params.uniforms().custom_parameter()[0];",
      "language" : "other"
    },
    {
      "code" : "\/\/ If the value is greater than 1.0, the dissolve has completed, so there's\n\/\/ no reason to draw anything. Discard the fragment to ensure that\n\/\/ RealityKit draws nothing for this fragment.\nif (animationProgress >= 1.0) {\n    discard_fragment();\n    return;\n}",
      "language" : "other"
    },
    {
      "code" : "\/\/ Replicate PhysicallyBasedMaterial's behavior for each of the physically\n\/\/ based rendering (PBR) attributes supported by CustomMaterial.\nbaseColorPassThrough(params);\nnormalPassThrough(params);\nroughnessPassThrough(params);\nmetallicPassThrough(params);\nspecularPassThrough(params);\nambientOcclusionPassThrough(params);\nclearcoatPassThrough(params);\nemissiveColorPassThrough(params);",
      "language" : "other"
    },
    {
      "code" : "\/\/ Because the project loaded this entity from a USDZ file, get and\n\/\/ flip the UV coordinates. This is equivalent to:\n\/\/\n\/\/     float2 uv = params.geometry().uv0();\n\/\/     uv.y = 1.0 - uv.y;\nauto uv = getFlippedUVs(params);\n\n\/\/ Sample the opacity texture value. The sampled value controls how\n\/\/ different parts of the entity dissolve. The lighter the color of the\n\/\/ texture the later in the dissolve it becomes invisible. Changing the\n\/\/ material's custom texture will yield different dissolve effects.\nfloat textureColor = params.textures().custom().sample(textureSampler, uv).r;\n\n\/\/ Implement the dissolve so that all pixels are either opaque or\n\/\/ dissolved (fully transparent). Render any value above the threshold\n\/\/ as transparent, and any value below the threshold as opaque.\nfloat threshold = 1.0 - animationProgress;\nif (textureColor < threshold) {\n    params.surface().set_opacity(1.0);\n} else {\n    \/\/ Setting the opacity to 0.0 using PBR (.lit or clearcoat) results\n    \/\/ in a transparent glass-like object. This means that RealityKit\n    \/\/ might render some value for this fragment due to specular\n    \/\/ highlights or clearcoat. To render nothing for this fragment,\n    \/\/ completely discard transparent fragments to avoid the possibility\n    \/\/ of RealityKit rendering a value for this fragment.\n    discard_fragment();\n    \n    \/\/ Once the fragment is discarded, there's no reason to continue.\n    return;\n}",
      "language" : "other"
    },
    {
      "code" : "[[visible]]\nvoid ExpandGeometryModifier(realitykit::geometry_parameters params)\n{\n    \/\/ Retrieve the progress value from the material.\n    auto uniforms = params.uniforms();\n    float progress = uniforms.custom_parameter()[0];\n    \n    \/\/ If the progress value is 0.0 or less, the entity isn't animating, so\n    \/\/ there's no work to do.\n    if (progress <= 0.0) {\n        return;\n    }\n    \n    \/\/ Get the current vertex's normal vector.\n    auto vertexNormal = params.geometry().normal();\n    \n    \/\/ Offset the vertex along the normal. The distance is based on the progress\n    \/\/ value.\n    params.geometry().set_model_position_offset(vertexNormal * progress * 3.0);\n    \n}",
      "language" : "other"
    },
    {
      "code" : "\/\/\/ Creates references to the Metal device and Metal library, which are needed to load shader functions.\nprivate func initializeMetal() {\n    guard let maybeDevice = MTLCreateSystemDefaultDevice() else {\n        fatalError(\"Error creating default metal device.\")\n    }\n    device = maybeDevice\n    guard let maybeLibrary = maybeDevice.makeDefaultLibrary() else {\n        fatalError(\"Error creating default metal library\")\n    }\n    library = maybeLibrary\n}",
      "language" : "swift"
    },
    {
      "code" : "let surfaceShader = CustomMaterial.SurfaceShader(\n    named: \"DissolveSurfaceShader\",\n    in: library\n)\n\nlet geometryModifier = CustomMaterial.GeometryModifier(\n    named: \"ExpandGeometryModifier\",\n    in: library\n)",
      "language" : "swift"
    },
    {
      "code" : "do {\n    try robotTemplate.modifyMaterials {\n        \n        \/\/ Create a custom material based on the material ($0) that\n        \/\/ RealityKit created automatically when loading the Reality\n        \/\/ Composer file, and assign it.\n        var customMaterial = try CustomMaterial(from: $0,\n                                                surfaceShader: surfaceShader,\n                                                geometryModifier: geometryModifier)\n        \n        \/\/ Use the first value of the custom vector to pass the\n        \/\/ progress value to the shader functions.\n        customMaterial.custom.value[0] = 0.0\n        \n        \/\/ Load the texture to pass to the shader functions, using\n        \/\/ the custom texture slot.\n        if let textureResource = try? TextureResource.load(named: \"texture.jpg\") {\n            let texture = CustomMaterial.Texture(textureResource)\n            customMaterial.custom.texture = .init(texture)\n        }\n        \n        return customMaterial\n    }\n} catch {\n    fatalError(\"Error creating custom material.\")\n}\n",
      "language" : "swift"
    },
    {
      "code" : "private func incrementPopProgress(entity: Entity) async {\n    let popDuration = 0.18\n    let start = Date.now.timeIntervalSince1970\n    var done = false\n    \n    while !done {\n        let progress = (Date.now.timeIntervalSince1970 - start) \/ popDuration\n        if progress > 1.0 {\n            done = true\n        }\n        await Task { @MainActor in\n            entity.setCustomVector(vector: SIMD4<Float>(x: Float(progress), y: 0.0, z: 0.0, w: 0.0))\n        }.value\n    }\n    \n    await Task { @MainActor in\n        \/\/ The entity is invisible at this point, but it still responds to\n        \/\/ taps unless it's disabled.\n        entity.isEnabled = false\n        \n        \/\/ Play a fun sound as the robot pops.\n        ApplicationActions.shared.playPop()\n    }.value\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "46c2e58f223bd913a71697d27386c7e1ccf98fe95d63f6a3e2000f862d2cc1d2",
  "crawledAt" : "2025-12-02T15:50:06Z",
  "id" : "623E2CEC-E51E-4A37-B0A4-599A2DD8FA03",
  "kind" : "unknown",
  "language" : "swift",
  "overview" : "## Overview\n\nIn iOS 15 and later, and macOS 12 and later, you can write Metal functions to alter the way RealityKit renders entities that uses a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial]. Custom materials require a Metal function called a *surface shader*, which sets the final rendering attributes for each of the entity’s fragments. A *fragment* is a pixel that is potentially affected by rendering that entity. Custom materials also support an optional Metal function called a *geometry modifier* that can move vertices or alter other vertex data, such as vertex colors or UV coordinates.\n\nThis sample demonstrates using custom materials with Metal functions to create special rendering effects. In this project, several toy robot entities are placed on a detected horizontal plane. Tapping a robot causes it to rapidly expand and become transparent so it appears to pop like a bubble. This project demonstrates creating a custom material from the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial] on a loaded model, using the material’s custom texture and vector properties to pass data to shader functions, and writing a surface shader and a geometry modifier to actually implement the rendering effects.\n\nFor more information on using custom materials, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/modifying-realitykit-rendering-using-custom-materials]\n\n### Configure the Sample Code Project\n\nBecause this sample app uses RealityKit, you can’t run it in Simulator — you’ll need to run it on a device. To run this sample, you’ll need the following:\n\n### Create a Surface Shader to Animate Transparency\n\nThe surface shader in this project overrides RealityKit’s default transparency behavior to implement the dissolve effect that makes the robots disappear. The shader is contained in the `DissolveSurfaceShader.metal` file. The dissolve process is controlled by a value between `0.0` and `1.0` that you pass to the shader function using the first component of the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/custom-swift.property] property’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/Custom-swift.struct\/value] vector. The first thing the surface shader does is retrieve that value.\n\n\n\nIf the progress value is `1.0` or greater, the dissolve is complete and there’s nothing to render, so the shader returns.\n\n\n\nA custom material’s surface shader is responsible for setting all of the rendering attributes of the current fragment. This project uses a robot model from RealityComposer that uses physically based rendering (PBR). In order to replicate that behavior, the shader has to set all of the properties used by `PhysicallyBasedMaterial` to ensure that RealityKit renders the model correctly. The project calls several Metal functions contained in the `CustomMaterialHelpers.metal` file that emulate the logic used by the RealityKit’s `PhysicallyBasedMaterial` shaders.\n\n\n\nNext, the surface shader implements a texture-driven dissolve by checking if the retrieved progress value is greater than `0.0`. If it is, the shader samples a UV-mapped value from the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/custom-swift.property] property’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/Custom-swift.struct\/texture]. If the sampled value is less than a threshold calculated from the dissolve progress, the fragment is rendered opaque; otherwise, the fragment is discarded, which allows anything behind the fragment to show through.\n\n\n\n### Write a Geometry Modifier that Expands an Entity\n\nThis project uses a geometry modifier to scale the robot entity along its vertex normals. By scaling along normals instead of scaling uniformly, the entity expands in a way that resembles an expanding bubble. The geometry modifier determines how much to scale the entity based on the same progress value retrieved in the surface shader.\n\n\n\n### Create a Custom Material\n\nWith the shader functions written, the next step is to create a custom material in Swift. To load the surface shader and geometry modifier, get a reference to the Metal library that contains the project’s shader functions.\n\n\n\nNext, use that Metal library to get references to both of the shader functions.\n\n\n\nBecause there are multiple entities using the same effect, the next step is to retrieve all of the robot entities from the scene. Reality Composer and USDZ both support multiple *levels of detail* (LOD) for models, which means that the robot entity potentially has multiple child entities that contain different versions of the model with different amounts of detail. RealityKit automatically swaps to lower-detailed versions of the entity when the entity is further away from the camera.\n\nTo make sure RealityKit uses this custom material regardless of which LOD model is being displayed, iterate over the entity’s children looking for a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent], which indicates a renderable non-primitive entity. When you find a model component, create a new custom material based on its existing [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial]. RealityKit automatically creates a `PhysicallyBasedMaterial` instance for each material in the USDZ or .reality file. After creating the material, load the custom image texture and add it to the material, then set the first value of the custom vector to `0.0` to indicate that the entity isn’t yet animating.\n\n\n\n### Animate the Dissolve\n\nWhen the user taps on one of the robots in the scene, the project animates the custom vector value used by the two shader functions over a short period of time. RealityKit automatically sends the updated values to the shader functions every frame, which causes the robots scale and dissolve. Once the animation is finished, it plays a “pop” sound.\n\n",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/realitykit\/altering_realitykit_rendering_with_shader_functions\ncrawled: 2025-12-02T15:50:06Z\n---\n\n# Altering RealityKit Rendering with Shader Functions\n\n**Sample Code**\n\nCreate rendering effects by writing surface shaders and geometry modifiers.\n\n## Overview\n\nIn iOS 15 and later, and macOS 12 and later, you can write Metal functions to alter the way RealityKit renders entities that uses a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial]. Custom materials require a Metal function called a *surface shader*, which sets the final rendering attributes for each of the entity’s fragments. A *fragment* is a pixel that is potentially affected by rendering that entity. Custom materials also support an optional Metal function called a *geometry modifier* that can move vertices or alter other vertex data, such as vertex colors or UV coordinates.\n\nThis sample demonstrates using custom materials with Metal functions to create special rendering effects. In this project, several toy robot entities are placed on a detected horizontal plane. Tapping a robot causes it to rapidly expand and become transparent so it appears to pop like a bubble. This project demonstrates creating a custom material from the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial] on a loaded model, using the material’s custom texture and vector properties to pass data to shader functions, and writing a surface shader and a geometry modifier to actually implement the rendering effects.\n\nFor more information on using custom materials, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/modifying-realitykit-rendering-using-custom-materials]\n\n### Configure the Sample Code Project\n\nBecause this sample app uses RealityKit, you can’t run it in Simulator — you’ll need to run it on a device. To run this sample, you’ll need the following:\n\n- A Mac running macOS 12 or later\n- Xcode 13 or later\n- An iOS device running iOS or iPadOS 15 or later\n\n### Create a Surface Shader to Animate Transparency\n\nThe surface shader in this project overrides RealityKit’s default transparency behavior to implement the dissolve effect that makes the robots disappear. The shader is contained in the `DissolveSurfaceShader.metal` file. The dissolve process is controlled by a value between `0.0` and `1.0` that you pass to the shader function using the first component of the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/custom-swift.property] property’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/Custom-swift.struct\/value] vector. The first thing the surface shader does is retrieve that value.\n\n```other\n\/\/ Get the first float in the custom vector, which contains the animation\n\/\/ progress for this entity as a value between 0.0 and 1.0.\nfloat animationProgress = params.uniforms().custom_parameter()[0];\n```\n\n\n\nIf the progress value is `1.0` or greater, the dissolve is complete and there’s nothing to render, so the shader returns.\n\n```other\n\/\/ If the value is greater than 1.0, the dissolve has completed, so there's\n\/\/ no reason to draw anything. Discard the fragment to ensure that\n\/\/ RealityKit draws nothing for this fragment.\nif (animationProgress >= 1.0) {\n    discard_fragment();\n    return;\n}\n```\n\n\n\nA custom material’s surface shader is responsible for setting all of the rendering attributes of the current fragment. This project uses a robot model from RealityComposer that uses physically based rendering (PBR). In order to replicate that behavior, the shader has to set all of the properties used by `PhysicallyBasedMaterial` to ensure that RealityKit renders the model correctly. The project calls several Metal functions contained in the `CustomMaterialHelpers.metal` file that emulate the logic used by the RealityKit’s `PhysicallyBasedMaterial` shaders.\n\n```other\n\/\/ Replicate PhysicallyBasedMaterial's behavior for each of the physically\n\/\/ based rendering (PBR) attributes supported by CustomMaterial.\nbaseColorPassThrough(params);\nnormalPassThrough(params);\nroughnessPassThrough(params);\nmetallicPassThrough(params);\nspecularPassThrough(params);\nambientOcclusionPassThrough(params);\nclearcoatPassThrough(params);\nemissiveColorPassThrough(params);\n```\n\n\n\nNext, the surface shader implements a texture-driven dissolve by checking if the retrieved progress value is greater than `0.0`. If it is, the shader samples a UV-mapped value from the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/custom-swift.property] property’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/Custom-swift.struct\/texture]. If the sampled value is less than a threshold calculated from the dissolve progress, the fragment is rendered opaque; otherwise, the fragment is discarded, which allows anything behind the fragment to show through.\n\n```other\n\/\/ Because the project loaded this entity from a USDZ file, get and\n\/\/ flip the UV coordinates. This is equivalent to:\n\/\/\n\/\/     float2 uv = params.geometry().uv0();\n\/\/     uv.y = 1.0 - uv.y;\nauto uv = getFlippedUVs(params);\n\n\/\/ Sample the opacity texture value. The sampled value controls how\n\/\/ different parts of the entity dissolve. The lighter the color of the\n\/\/ texture the later in the dissolve it becomes invisible. Changing the\n\/\/ material's custom texture will yield different dissolve effects.\nfloat textureColor = params.textures().custom().sample(textureSampler, uv).r;\n\n\/\/ Implement the dissolve so that all pixels are either opaque or\n\/\/ dissolved (fully transparent). Render any value above the threshold\n\/\/ as transparent, and any value below the threshold as opaque.\nfloat threshold = 1.0 - animationProgress;\nif (textureColor < threshold) {\n    params.surface().set_opacity(1.0);\n} else {\n    \/\/ Setting the opacity to 0.0 using PBR (.lit or clearcoat) results\n    \/\/ in a transparent glass-like object. This means that RealityKit\n    \/\/ might render some value for this fragment due to specular\n    \/\/ highlights or clearcoat. To render nothing for this fragment,\n    \/\/ completely discard transparent fragments to avoid the possibility\n    \/\/ of RealityKit rendering a value for this fragment.\n    discard_fragment();\n    \n    \/\/ Once the fragment is discarded, there's no reason to continue.\n    return;\n}\n```\n\n\n\n### Write a Geometry Modifier that Expands an Entity\n\nThis project uses a geometry modifier to scale the robot entity along its vertex normals. By scaling along normals instead of scaling uniformly, the entity expands in a way that resembles an expanding bubble. The geometry modifier determines how much to scale the entity based on the same progress value retrieved in the surface shader.\n\n```other\n[[visible]]\nvoid ExpandGeometryModifier(realitykit::geometry_parameters params)\n{\n    \/\/ Retrieve the progress value from the material.\n    auto uniforms = params.uniforms();\n    float progress = uniforms.custom_parameter()[0];\n    \n    \/\/ If the progress value is 0.0 or less, the entity isn't animating, so\n    \/\/ there's no work to do.\n    if (progress <= 0.0) {\n        return;\n    }\n    \n    \/\/ Get the current vertex's normal vector.\n    auto vertexNormal = params.geometry().normal();\n    \n    \/\/ Offset the vertex along the normal. The distance is based on the progress\n    \/\/ value.\n    params.geometry().set_model_position_offset(vertexNormal * progress * 3.0);\n    \n}\n```\n\n\n\n### Create a Custom Material\n\nWith the shader functions written, the next step is to create a custom material in Swift. To load the surface shader and geometry modifier, get a reference to the Metal library that contains the project’s shader functions.\n\n```swift\n\/\/\/ Creates references to the Metal device and Metal library, which are needed to load shader functions.\nprivate func initializeMetal() {\n    guard let maybeDevice = MTLCreateSystemDefaultDevice() else {\n        fatalError(\"Error creating default metal device.\")\n    }\n    device = maybeDevice\n    guard let maybeLibrary = maybeDevice.makeDefaultLibrary() else {\n        fatalError(\"Error creating default metal library\")\n    }\n    library = maybeLibrary\n}\n```\n\n\n\nNext, use that Metal library to get references to both of the shader functions.\n\n```swift\nlet surfaceShader = CustomMaterial.SurfaceShader(\n    named: \"DissolveSurfaceShader\",\n    in: library\n)\n\nlet geometryModifier = CustomMaterial.GeometryModifier(\n    named: \"ExpandGeometryModifier\",\n    in: library\n)\n```\n\n\n\nBecause there are multiple entities using the same effect, the next step is to retrieve all of the robot entities from the scene. Reality Composer and USDZ both support multiple *levels of detail* (LOD) for models, which means that the robot entity potentially has multiple child entities that contain different versions of the model with different amounts of detail. RealityKit automatically swaps to lower-detailed versions of the entity when the entity is further away from the camera.\n\nTo make sure RealityKit uses this custom material regardless of which LOD model is being displayed, iterate over the entity’s children looking for a [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ModelComponent], which indicates a renderable non-primitive entity. When you find a model component, create a new custom material based on its existing [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial]. RealityKit automatically creates a `PhysicallyBasedMaterial` instance for each material in the USDZ or .reality file. After creating the material, load the custom image texture and add it to the material, then set the first value of the custom vector to `0.0` to indicate that the entity isn’t yet animating.\n\n```swift\ndo {\n    try robotTemplate.modifyMaterials {\n        \n        \/\/ Create a custom material based on the material ($0) that\n        \/\/ RealityKit created automatically when loading the Reality\n        \/\/ Composer file, and assign it.\n        var customMaterial = try CustomMaterial(from: $0,\n                                                surfaceShader: surfaceShader,\n                                                geometryModifier: geometryModifier)\n        \n        \/\/ Use the first value of the custom vector to pass the\n        \/\/ progress value to the shader functions.\n        customMaterial.custom.value[0] = 0.0\n        \n        \/\/ Load the texture to pass to the shader functions, using\n        \/\/ the custom texture slot.\n        if let textureResource = try? TextureResource.load(named: \"texture.jpg\") {\n            let texture = CustomMaterial.Texture(textureResource)\n            customMaterial.custom.texture = .init(texture)\n        }\n        \n        return customMaterial\n    }\n} catch {\n    fatalError(\"Error creating custom material.\")\n}\n\n```\n\n\n\n### Animate the Dissolve\n\nWhen the user taps on one of the robots in the scene, the project animates the custom vector value used by the two shader functions over a short period of time. RealityKit automatically sends the updated values to the shader functions every frame, which causes the robots scale and dissolve. Once the animation is finished, it plays a “pop” sound.\n\n```swift\nprivate func incrementPopProgress(entity: Entity) async {\n    let popDuration = 0.18\n    let start = Date.now.timeIntervalSince1970\n    var done = false\n    \n    while !done {\n        let progress = (Date.now.timeIntervalSince1970 - start) \/ popDuration\n        if progress > 1.0 {\n            done = true\n        }\n        await Task { @MainActor in\n            entity.setCustomVector(vector: SIMD4<Float>(x: Float(progress), y: 0.0, z: 0.0, w: 0.0))\n        }.value\n    }\n    \n    await Task { @MainActor in\n        \/\/ The entity is invisible at this point, but it still responds to\n        \/\/ taps unless it's disabled.\n        entity.isEnabled = false\n        \n        \/\/ Play a fun sound as the robot pops.\n        ApplicationActions.shared.playPop()\n    }.value\n}\n```\n\n\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Altering RealityKit Rendering with Shader Functions",
  "url" : "https:\/\/developer.apple.com\/documentation\/realitykit\/altering_realitykit_rendering_with_shader_functions"
}