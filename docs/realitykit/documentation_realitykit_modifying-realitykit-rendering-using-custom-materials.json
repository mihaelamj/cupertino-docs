{
  "abstract" : "Write Metal shader functions to implement custom rendering effects.",
  "codeExamples" : [
    {
      "code" : "#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\n\nusing namespace metal;\n\n[[visible]]\nvoid myEmptyShader(realitykit::surface_parameters params)\n{\n\n}",
      "language" : "cpp"
    },
    {
      "code" : "#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\n\nusing namespace metal;\n\nconstexpr sampler textureSampler(address::clamp_to_edge, filter::bicubic);\n\n[[visible]]\nvoid mySurfaceShader(realitykit::surface_parameters params)\n{\n    \/\/ Retrieve the base color tint from the entity's material.\n    half3 baseColorTint = (half3)params.material_constants().base_color_tint();\n\n    \/\/ Retrieve the entity's texture coordinates.\n    float2 uv = params.geometry().uv0();\n\n    \/\/ Flip the texture coordinates y-axis. This is only needed for entities\n    \/\/ loaded from USDZ or .reality files.\n    uv.y = 1.0 - uv.y;\n\n    \/\/ Sample a value from the material's base color texture based on the \n    \/\/ flipped UV coordinates.\n    auto tex = params.textures();\n    half3 color = (half3)tex.base_color().sample(textureSampler, uv).rgb;\n\n    \/\/ Multiply the tint by the sampled value from the texture, and\n    \/\/ assign the result to the shader's base color property.\n    color *= baseColorTint;\n    params.surface().set_base_color(color);\n}",
      "language" : "cpp"
    },
    {
      "code" : "#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\nusing namespace metal;\n\n[[visible]]\nvoid emptyGeometryModifier(realitykit::geometry_parameters params)\n{\n}",
      "language" : "cpp"
    },
    {
      "code" : "#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\nusing namespace metal;\n\n[[visible]]\nvoid simpleGeometryModifier(realitykit::geometry_parameters params)\n{\n    float3 zOffset = float3(0.0, 0.0, params.uniforms().time() \/ 50.0);\n    params.geometry().set_world_position_offset(zOffset);\n}",
      "language" : "cpp"
    },
    {
      "code" : "\/\/ Get the Metal Device.\nguard let device = MTLCreateSystemDefaultDevice() else {\n    fatalError(\"Error creating default metal device.\")\n}\n\n\/\/ Get a reference to the Metal library.\nlet library = device.makeDefaultLibrary()\n\n\/\/ Load a geometry modifier function named myGeometryModifier.\nlet geometryModifier = CustomMaterial.GeometryModifier(named: \"myGeometryModifier\", \n                                                       in: library)\n\n\/\/ Load a surface shader function named mySurfaceShader.\nlet surfaceShader = CustomMaterial.SurfaceShader(named: \"mySurfaceShader\", \n                                                 in: library)",
      "language" : "swift"
    },
    {
      "code" : "let customMaterial: CustomMaterial\ndo {\n    try customMaterial = CustomMaterial(surfaceShader: surfaceShader,\n                                        geometryModifier: geometryModifier,\n                                        lightingModel: .lit)\n} catch {\n    fatalError(error.localizedDescription)\n}\n\nlet mesh = MeshResource.generateSphere(radius: 0.5 )\nlet modelEntity = ModelEntity(mesh: mesh, materials: [customMaterial])",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Load a USDZ from the file system.\nguard let robot = try? Entity.load(named: \"Robot\") else { \n    return \n}\n\n\/\/ Make sure the entity has a ModelComponent.\nguard var modelComponent = robot.components[ModelComponent.self] else { \n    return \n}\n\n\/\/ Loop through the entity's materials and replace the existing material with\n\/\/ one based on the original material.\nguard let customMaterials = try? modelComponent.materials.map({ material -> CustomMaterial in\n    let customMaterial = try CustomMaterial(from: material, surfaceShader: surfaceShader)\n    return customMaterial\n}) else { return}\nmodelComponent.materials = customMaterials\nrobot.components[ModelComponent.self] = modelComponent",
      "language" : "swift"
    }
  ],
  "contentHash" : "8ce8ed03089572cc7c22c6a4daab9302a6ccfc8fa652c5a7e60896eb190cd59e",
  "crawledAt" : "2025-12-02T20:13:02Z",
  "id" : "60C544CD-AB04-47C5-8388-1B29312C593C",
  "kind" : "article",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nRealityKit provides several types of materials that render entities using different techniques. Two examples are [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial], which renders entities in highly realistic fashion, and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/UnlitMaterial], which renders without any shadow or lighting effects. On iOS 15 and later, [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial] allows you to write shader functions in Metal to modify how RealityKit renders an entity, while still leveraging RealityKit’s built-in shader pipeline.\n\nCustom materials support two types of custom Metal shader functions: *surface shaders* and *geometry modifiers*. Surface shaders are responsible for specifying the final attributes of each pixel that RealityKit draws to render the entity. They also support an optional geometry modifier, which you can use to manipulate the location of the model’s vertices, allowing you to dynamically change the size or shape of the entity.\n\nIn shader programming, the term *fragment* refers to a one-pixel portion of an entity. *Fragment shaders* run on the GPU and are responsible for rendering those pixel-size chunks. RealityKit’s built-in fragment shader fires once for every one of the entity’s fragments. In other words, it fires once for every screen pixel potentially affected by rendering that entity. As a result, your surface shader function also fires once for every fragment. RealityKit’s fragment shader calls your surface shader, meaning that surface shaders are also called once for each of the entity’s fragments.\n\nThe other type of Metal shader that RealityKit uses is the *vertex shader*. Vertex shaders fire once for every vertex in the entity. If you supply a geometry modifier when creating a custom material, RealityKit’s vertex shader calls it. Geometry modifiers fire once for every vertex in the entity.\n\nFor more information on writing Metal shaders, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/Debugging-the-shaders-within-a-draw-command-or-compute-dispatch].\n\n### Write a surface shader\n\nTo use a custom material, first write a surface shader in Metal. Start by adding a new file to your Xcode project using the Metal File template. You can use any function name you want for your surface shader, but you must prefix your function with the `[[visible]]` keyword. Your function must have no return value and take a single parameter of type `realitykit::surface_parameters`.\n\nThe following code listing shows an empty surface shader:\n\nThe one parameter that RealityKit passes to your surface shader provides access to all input from the entity’s material, as well as interpolated versions of all of the entity’s per-vertex values, such as UV coordinates and vertex colors. When accessed from a surface shader, Metal returns an interpolated version of per-vertex data, based on the fragment’s position relative to the three vertices that make up its triangle. The following illustration demonstrates how that interpolation works for vertex colors.\n\n\n\nSpecify output using the various `set_` functions on the parameter’s `surface()` property. For example, to set the base color value for the current fragment, call `params.surface().set_base_color()`. The custom material’s lighting model determines which `set_` functions it supports. Your surface shader must call at least one supported `set_` function or nothing renders. For a list of which `set_` functions each lighting model supports, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/lightingModel-swift.property].\n\nHere are the accessor methods on `realitykit::surface_parameters`, along with what you use them for:\n\nThe following surface shader calculates and sets the fragment’s base color based on the `tint` and `color` values from the material’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/BaseColor-swift.struct] property.\n\n### Write a geometry modifier\n\nIf you need to modify the vertex positions or other vertex values for your entity, write a geometry modifier function. Otherwise, you can create your custom material with only a surface shader. To write a geometry modifier, create a new Metal file in your Xcode project, or add a new function to the same file that contains your surface shader.\n\nAs with surface shaders, you can name your geometry modifier function anything you want, but you must prefix it with the `[[visible]]` keyword. A geometry shader must have no return value and take a single parameter of type `realitykit::geometry_parameters`.\n\nThe following code shows an empty geometry modifier.\n\nTo move vertices before RealityKit renders your entity, call `params.geometry().set_model_position_offset()` or `params.geometry().set_world_position_offset()` with the amount to offset the vertex. Changes made in the geometry modifier only affect how RealityKit renders the model; they don’t affect the original entity in the RealityKit scene. For example, moving a model to a new location in the geometry modifier won’t affect its location for collision detection or other physics calculation.\n\nThe following example implements a simple geometry shader that moves every vertex along the z-axis by an amount calculated from the elapsed time.\n\n### Load the custom shaders\n\nTo create a custom material for an entity, first load the Metal library that contains your shader functions, then load the functions by name, as the following sample code demonstrates:\n\n### Choose a lighting model\n\nEvery custom material needs a *lighting model*, which determines the basic approach RealityKit uses to render an entity with a custom material. The lighting model affects how the entity looks and which output functions your surface shader can use. There are three options:\n\n### Create and use the custom material\n\nIn your Swift code, create a custom material using your loaded shader functions and selected lighting model. To create a custom material from scratch, use [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/init(surfaceShader:geometryModifier:lightingModel:)], as the following code demonstrates:\n\nAlternatively, you can create a custom material from a model’s existing material. When working with entities loaded from USDZ or `.reality` files, this approach preserves all of the material attributes from the original file. The following code demonstrates loading a model and creating a custom material based on the entity’s existing material:\n\nYou can download RealityKit’s custom shader Metal API documentation from [https:\/\/developer.apple.com\/metal\/Metal-RealityKit-APIs.pdf].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/modifying-realitykit-rendering-using-custom-materials\ncrawled: 2025-12-02T20:13:02Z\n---\n\n# Modifying RealityKit rendering using custom materials\n\n**Article**\n\nWrite Metal shader functions to implement custom rendering effects.\n\n## Overview\n\nRealityKit provides several types of materials that render entities using different techniques. Two examples are [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicallyBasedMaterial], which renders entities in highly realistic fashion, and [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/UnlitMaterial], which renders without any shadow or lighting effects. On iOS 15 and later, [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial] allows you to write shader functions in Metal to modify how RealityKit renders an entity, while still leveraging RealityKit’s built-in shader pipeline.\n\n\n\nCustom materials support two types of custom Metal shader functions: *surface shaders* and *geometry modifiers*. Surface shaders are responsible for specifying the final attributes of each pixel that RealityKit draws to render the entity. They also support an optional geometry modifier, which you can use to manipulate the location of the model’s vertices, allowing you to dynamically change the size or shape of the entity.\n\nIn shader programming, the term *fragment* refers to a one-pixel portion of an entity. *Fragment shaders* run on the GPU and are responsible for rendering those pixel-size chunks. RealityKit’s built-in fragment shader fires once for every one of the entity’s fragments. In other words, it fires once for every screen pixel potentially affected by rendering that entity. As a result, your surface shader function also fires once for every fragment. RealityKit’s fragment shader calls your surface shader, meaning that surface shaders are also called once for each of the entity’s fragments.\n\nThe other type of Metal shader that RealityKit uses is the *vertex shader*. Vertex shaders fire once for every vertex in the entity. If you supply a geometry modifier when creating a custom material, RealityKit’s vertex shader calls it. Geometry modifiers fire once for every vertex in the entity.\n\nFor more information on writing Metal shaders, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/Debugging-the-shaders-within-a-draw-command-or-compute-dispatch].\n\n### Write a surface shader\n\nTo use a custom material, first write a surface shader in Metal. Start by adding a new file to your Xcode project using the Metal File template. You can use any function name you want for your surface shader, but you must prefix your function with the `[[visible]]` keyword. Your function must have no return value and take a single parameter of type `realitykit::surface_parameters`.\n\nThe following code listing shows an empty surface shader:\n\n```cpp\n#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\n\nusing namespace metal;\n\n[[visible]]\nvoid myEmptyShader(realitykit::surface_parameters params)\n{\n\n}\n```\n\nThe one parameter that RealityKit passes to your surface shader provides access to all input from the entity’s material, as well as interpolated versions of all of the entity’s per-vertex values, such as UV coordinates and vertex colors. When accessed from a surface shader, Metal returns an interpolated version of per-vertex data, based on the fragment’s position relative to the three vertices that make up its triangle. The following illustration demonstrates how that interpolation works for vertex colors.\n\n\n\nSpecify output using the various `set_` functions on the parameter’s `surface()` property. For example, to set the base color value for the current fragment, call `params.surface().set_base_color()`. The custom material’s lighting model determines which `set_` functions it supports. Your surface shader must call at least one supported `set_` function or nothing renders. For a list of which `set_` functions each lighting model supports, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/lightingModel-swift.property].\n\nHere are the accessor methods on `realitykit::surface_parameters`, along with what you use them for:\n\n\n\nThe following surface shader calculates and sets the fragment’s base color based on the `tint` and `color` values from the material’s [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/BaseColor-swift.struct] property.\n\n```cpp\n#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\n\nusing namespace metal;\n\nconstexpr sampler textureSampler(address::clamp_to_edge, filter::bicubic);\n\n[[visible]]\nvoid mySurfaceShader(realitykit::surface_parameters params)\n{\n    \/\/ Retrieve the base color tint from the entity's material.\n    half3 baseColorTint = (half3)params.material_constants().base_color_tint();\n\n    \/\/ Retrieve the entity's texture coordinates.\n    float2 uv = params.geometry().uv0();\n\n    \/\/ Flip the texture coordinates y-axis. This is only needed for entities\n    \/\/ loaded from USDZ or .reality files.\n    uv.y = 1.0 - uv.y;\n\n    \/\/ Sample a value from the material's base color texture based on the \n    \/\/ flipped UV coordinates.\n    auto tex = params.textures();\n    half3 color = (half3)tex.base_color().sample(textureSampler, uv).rgb;\n\n    \/\/ Multiply the tint by the sampled value from the texture, and\n    \/\/ assign the result to the shader's base color property.\n    color *= baseColorTint;\n    params.surface().set_base_color(color);\n}\n```\n\n### Write a geometry modifier\n\nIf you need to modify the vertex positions or other vertex values for your entity, write a geometry modifier function. Otherwise, you can create your custom material with only a surface shader. To write a geometry modifier, create a new Metal file in your Xcode project, or add a new function to the same file that contains your surface shader.\n\nAs with surface shaders, you can name your geometry modifier function anything you want, but you must prefix it with the `[[visible]]` keyword. A geometry shader must have no return value and take a single parameter of type `realitykit::geometry_parameters`.\n\nThe following code shows an empty geometry modifier.\n\n```cpp\n#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\nusing namespace metal;\n\n[[visible]]\nvoid emptyGeometryModifier(realitykit::geometry_parameters params)\n{\n}\n```\n\nTo move vertices before RealityKit renders your entity, call `params.geometry().set_model_position_offset()` or `params.geometry().set_world_position_offset()` with the amount to offset the vertex. Changes made in the geometry modifier only affect how RealityKit renders the model; they don’t affect the original entity in the RealityKit scene. For example, moving a model to a new location in the geometry modifier won’t affect its location for collision detection or other physics calculation.\n\nThe following example implements a simple geometry shader that moves every vertex along the z-axis by an amount calculated from the elapsed time.\n\n```cpp\n#include <metal_stdlib>\n#include <RealityKit\/RealityKit.h>\nusing namespace metal;\n\n[[visible]]\nvoid simpleGeometryModifier(realitykit::geometry_parameters params)\n{\n    float3 zOffset = float3(0.0, 0.0, params.uniforms().time() \/ 50.0);\n    params.geometry().set_world_position_offset(zOffset);\n}\n```\n\n\n\n### Load the custom shaders\n\nTo create a custom material for an entity, first load the Metal library that contains your shader functions, then load the functions by name, as the following sample code demonstrates:\n\n```swift\n\/\/ Get the Metal Device.\nguard let device = MTLCreateSystemDefaultDevice() else {\n    fatalError(\"Error creating default metal device.\")\n}\n\n\/\/ Get a reference to the Metal library.\nlet library = device.makeDefaultLibrary()\n\n\/\/ Load a geometry modifier function named myGeometryModifier.\nlet geometryModifier = CustomMaterial.GeometryModifier(named: \"myGeometryModifier\", \n                                                       in: library)\n\n\/\/ Load a surface shader function named mySurfaceShader.\nlet surfaceShader = CustomMaterial.SurfaceShader(named: \"mySurfaceShader\", \n                                                 in: library)\n```\n\n### Choose a lighting model\n\nEvery custom material needs a *lighting model*, which determines the basic approach RealityKit uses to render an entity with a custom material. The lighting model affects how the entity looks and which output functions your surface shader can use. There are three options:\n\n\n\n### Create and use the custom material\n\nIn your Swift code, create a custom material using your loaded shader functions and selected lighting model. To create a custom material from scratch, use [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/CustomMaterial\/init(surfaceShader:geometryModifier:lightingModel:)], as the following code demonstrates:\n\n```swift\nlet customMaterial: CustomMaterial\ndo {\n    try customMaterial = CustomMaterial(surfaceShader: surfaceShader,\n                                        geometryModifier: geometryModifier,\n                                        lightingModel: .lit)\n} catch {\n    fatalError(error.localizedDescription)\n}\n\nlet mesh = MeshResource.generateSphere(radius: 0.5 )\nlet modelEntity = ModelEntity(mesh: mesh, materials: [customMaterial])\n```\n\nAlternatively, you can create a custom material from a model’s existing material. When working with entities loaded from USDZ or `.reality` files, this approach preserves all of the material attributes from the original file. The following code demonstrates loading a model and creating a custom material based on the entity’s existing material:\n\n```swift\n\/\/ Load a USDZ from the file system.\nguard let robot = try? Entity.load(named: \"Robot\") else { \n    return \n}\n\n\/\/ Make sure the entity has a ModelComponent.\nguard var modelComponent = robot.components[ModelComponent.self] else { \n    return \n}\n\n\/\/ Loop through the entity's materials and replace the existing material with\n\/\/ one based on the original material.\nguard let customMaterials = try? modelComponent.materials.map({ material -> CustomMaterial in\n    let customMaterial = try CustomMaterial(from: material, surfaceShader: surfaceShader)\n    return customMaterial\n}) else { return}\nmodelComponent.materials = customMaterials\nrobot.components[ModelComponent.self] = modelComponent\n```\n\nYou can download RealityKit’s custom shader Metal API documentation from [https:\/\/developer.apple.com\/metal\/Metal-RealityKit-APIs.pdf].\n\n## Shaders\n\n- **ShaderGraphMaterial**: A material that comes from a shader graph in a Reality Composer Pro project, or a MaterialX shader.\n- **ShaderGraphMaterial.FaceCulling**: An alias for the cull mode object that’s appropriate for this material class.\n- **ShaderGraphMaterial.TriangleFillMode**: An alias for the triangle fill mode object that’s appropriate for this material class.\n- **CustomMaterial**: A material that works with custom Metal shader functions.\n- **CustomMaterial.SurfaceShader**: The custom material’s surface shader function.\n- **CustomMaterial.GeometryModifier**: The custom material’s optional shader function that can manipulate an entity’s vertex data.\n- **MaterialFunction**: The abstract superclass for objects representing compute functions for RealityKit custom materials .\n- **CustomMaterial.Program**: An object that represents the backing shader compilation required for custom materials.\n- **CustomMaterial.Program.Descriptor**: An object that specifies all parameters necessary to initialize `CustomMaterial` programs\n- **CustomShaderStage**\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A material that comes from a shader graph in a Reality Composer Pro project, or a MaterialX shader.",
          "name" : "ShaderGraphMaterial",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ShaderGraphMaterial"
        },
        {
          "description" : "An alias for the cull mode object that’s appropriate for this material class.",
          "name" : "ShaderGraphMaterial.FaceCulling",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ShaderGraphMaterial\/FaceCulling-swift.typealias"
        },
        {
          "description" : "An alias for the triangle fill mode object that’s appropriate for this material class.",
          "name" : "ShaderGraphMaterial.TriangleFillMode",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/ShaderGraphMaterial\/TriangleFillMode-swift.typealias"
        },
        {
          "description" : "A material that works with custom Metal shader functions.",
          "name" : "CustomMaterial",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CustomMaterial"
        },
        {
          "description" : "The custom material’s surface shader function.",
          "name" : "CustomMaterial.SurfaceShader",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CustomMaterial\/SurfaceShader"
        },
        {
          "description" : "The custom material’s optional shader function that can manipulate an entity’s vertex data.",
          "name" : "CustomMaterial.GeometryModifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CustomMaterial\/GeometryModifier"
        },
        {
          "description" : "The abstract superclass for objects representing compute functions for RealityKit custom materials .",
          "name" : "MaterialFunction",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/MaterialFunction"
        },
        {
          "description" : "An object that represents the backing shader compilation required for custom materials.",
          "name" : "CustomMaterial.Program",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CustomMaterial\/Program-swift.class"
        },
        {
          "description" : "An object that specifies all parameters necessary to initialize `CustomMaterial` programs",
          "name" : "CustomMaterial.Program.Descriptor",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CustomMaterial\/Program-swift.class\/Descriptor-swift.struct"
        },
        {
          "description" : "",
          "name" : "CustomShaderStage",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/CustomShaderStage"
        }
      ],
      "title" : "Shaders"
    }
  ],
  "source" : "appleJSON",
  "title" : "Modifying RealityKit rendering using custom materials",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/modifying-realitykit-rendering-using-custom-materials"
}