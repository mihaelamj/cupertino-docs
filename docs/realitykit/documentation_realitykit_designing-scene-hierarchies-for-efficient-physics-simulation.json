{
  "abstract" : "Configure your RealityKit scenes to avoid performance bottlenecks.",
  "codeExamples" : [
    {
      "code" : "arView.physicsOrigin = entity",
      "language" : "swift"
    },
    {
      "code" : "    let boxAnchor = try! Experience.loadBox()\n    arView.scene.anchors.append(boxAnchor)\n    if let physicsRoot = boxAnchor.findEntity(named: \"Physics Root\") {\n        self.arView.physicsOrigin = physicsRoot\n    }",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Apply impulse to shoot the object up.\nlet impulseStrength = 10\nlet impulseDirection = SIMD3<Float>(0, 1, 0)\nmodel.applyLinearImpulse(impulseStrength * impulseDirection, relativeTo: arView.physicsOrigin)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Use the initializer with density instead of mass.\nmodel.physicsBody = .init(shapes: [boxShape], density: 200)",
      "language" : "swift"
    }
  ],
  "contentHash" : "aeeb6cdd926dcbc2e46b67daa11859a5f48295c608d33ada2cb3f3183edb1747",
  "crawledAt" : "2025-12-01T12:06:48Z",
  "id" : "05715B58-C412-4A3F-A96E-31CEB9ABCBC5",
  "kind" : "article",
  "module" : "RealityKit",
  "overview" : "## Overview\n\n[doc:\/\/com.apple.RealityKit\/documentation\/RealityKit] simulates physical interactions between the virtual objects in your scene, as well as between virtual objects and detected surfaces in the real world, such as floors, walls, or tabletops. On iOS devices with a LiDAR Scanner, RealityKit can even simulate interactions between virtual objects and scanned real-world geometry.\n\nSimulating real-world physics can be computationally expensive, however, so set up your project to maximize performance.\n\n### Design scenes with flat hierarchies\n\nMake sure every entity in your scene that participates in the physics simulation is a child of the scene root, if possible, and avoid having unnecessary entities in your scene hierarchy.\n\nFor scenes created in Reality Composer, minimize the use of groups for objects that participate in the physics simulation. Grouping objects creates implicit parent-child relationships and invisible parent entities, both of which can negatively impact performance.\n\n### Assign a physics origin\n\nBy default, RealityKit uses the scene’s root entity as the origin of the physics simulation and simulates objects at their actual size. You can alternatively designate a different entity in your scene to be the *physics origin* by using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ARView\/physicsOrigin] property of your [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ARView]. Designating an entity as the physics origin means that all physics calculations are relative to the specified entity rather than the scene’s root entity. For more information about when to specify a separate physics origin, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/handling-different-sized-objects-in-physics-simulations].\n\nWhen you set the physics origin, you can modify the scale, position, and orientation of the scene in the view without affecting the physics simulation. You can also use transform values that are different from the values used in the visible scene. For example, you can create a tabletop AR experience with characters that are a few inches tall but behave as if they’re much larger.\n\nYou can’t specify a different physics origin using Reality Composer. Instead, designate an entity in a loaded Reality Composer scene as the physics entity or add a new entity to the loaded scene to act as the physics origin.\n\nThis example shows how to retrieve a named entity from your Reality Composer scene and specify it as the physics origin:\n\n### Prefer impulses over forces\n\nRealityKit provides two different mechanisms for applying force to an entity: *forces* and *impulses*. An impulse represents a constant amount of force applied over a specific unit of time. RealityKit applies forces for the entire duration of the current frame, but it applies an impulse all at once. Using forces gives different results depending on the current rendering framerate, while applying an impulse gives consistent results regardless of the framerate. Using impulses results in consistent, predictable behavior on any device at any frame rate.\n\nAdditionally, the effect of adding a force isn’t visible until after the next simulation update occurs, while the result of applying an impulse is visible immediately.\n\n### Apply forces and impulses relative to the physics origin\n\nWhen changing velocities or applying forces or impulses to simulated objects, apply the changes relative to the physics origin. Specifying units relative to the physics origin eliminates the need to account for scale changes made to the rendered scene.\n\n[doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsMotionComponent] internally stores velocity values relative to the physics origin. Specifying forces and impulses relative to the physics origin eliminates the need for the physics engine to convert or translate values and therefore results in better performance.\n\n### Avoid extreme differences in size and mass\n\nRealityKit’s physics simulations work best if the size and mass ratios don’t exceed one order of magnitude.\n\nAdditionally, the physics simulation works best if the smallest dimension of each object is at least `0.05` units in size and the largest dimension of each object is no more than `10` units in size. If you need objects outside of this range, create objects that are inside this range and then scale the physics origin at runtime.\n\n### Increase density instead of mass\n\nFor best results, keep the mass of your scene’s objects at their calculated mass. Entities with substantially increased mass result in a proportional increase in momentum, which can make the physics simulation unstable. To simulate heavy, dense objects like gold or lead, leave the mass at its calculated value and increase the entity’s density property. The pre-defined physics materials available in Reality Composer use density to simulate heavy materials.\n\nThe [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent\/init(shapes:density:material:mode:)] initializer automatically computes mass based on volume and density, Water has a density of about 1000 kg\/m³ and steel has a density of 7800 kg\/m³. When setting the mass of an object, keep in mind that real-world objects aren’t always completely solid, and can be hollow. Densities of less than 1000 kg\/m³ work well in most scenarios.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/designing-scene-hierarchies-for-efficient-physics-simulation\ncrawled: 2025-12-01T12:06:48Z\n---\n\n# Designing scene hierarchies for efficient physics simulation\n\n**Article**\n\nConfigure your RealityKit scenes to avoid performance bottlenecks.\n\n## Overview\n\n[doc:\/\/com.apple.RealityKit\/documentation\/RealityKit] simulates physical interactions between the virtual objects in your scene, as well as between virtual objects and detected surfaces in the real world, such as floors, walls, or tabletops. On iOS devices with a LiDAR Scanner, RealityKit can even simulate interactions between virtual objects and scanned real-world geometry.\n\nSimulating real-world physics can be computationally expensive, however, so set up your project to maximize performance.\n\n### Design scenes with flat hierarchies\n\nMake sure every entity in your scene that participates in the physics simulation is a child of the scene root, if possible, and avoid having unnecessary entities in your scene hierarchy.\n\nFor scenes created in Reality Composer, minimize the use of groups for objects that participate in the physics simulation. Grouping objects creates implicit parent-child relationships and invisible parent entities, both of which can negatively impact performance.\n\n\n\n### Assign a physics origin\n\nBy default, RealityKit uses the scene’s root entity as the origin of the physics simulation and simulates objects at their actual size. You can alternatively designate a different entity in your scene to be the *physics origin* by using the [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ARView\/physicsOrigin] property of your [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/ARView]. Designating an entity as the physics origin means that all physics calculations are relative to the specified entity rather than the scene’s root entity. For more information about when to specify a separate physics origin, see [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/handling-different-sized-objects-in-physics-simulations].\n\n```swift\narView.physicsOrigin = entity\n```\n\nWhen you set the physics origin, you can modify the scale, position, and orientation of the scene in the view without affecting the physics simulation. You can also use transform values that are different from the values used in the visible scene. For example, you can create a tabletop AR experience with characters that are a few inches tall but behave as if they’re much larger.\n\n\n\nYou can’t specify a different physics origin using Reality Composer. Instead, designate an entity in a loaded Reality Composer scene as the physics entity or add a new entity to the loaded scene to act as the physics origin.\n\nThis example shows how to retrieve a named entity from your Reality Composer scene and specify it as the physics origin:\n\n```swift\n    let boxAnchor = try! Experience.loadBox()\n    arView.scene.anchors.append(boxAnchor)\n    if let physicsRoot = boxAnchor.findEntity(named: \"Physics Root\") {\n        self.arView.physicsOrigin = physicsRoot\n    }\n```\n\n### Prefer impulses over forces\n\nRealityKit provides two different mechanisms for applying force to an entity: *forces* and *impulses*. An impulse represents a constant amount of force applied over a specific unit of time. RealityKit applies forces for the entire duration of the current frame, but it applies an impulse all at once. Using forces gives different results depending on the current rendering framerate, while applying an impulse gives consistent results regardless of the framerate. Using impulses results in consistent, predictable behavior on any device at any frame rate.\n\nAdditionally, the effect of adding a force isn’t visible until after the next simulation update occurs, while the result of applying an impulse is visible immediately.\n\n### Apply forces and impulses relative to the physics origin\n\nWhen changing velocities or applying forces or impulses to simulated objects, apply the changes relative to the physics origin. Specifying units relative to the physics origin eliminates the need to account for scale changes made to the rendered scene.\n\n[doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsMotionComponent] internally stores velocity values relative to the physics origin. Specifying forces and impulses relative to the physics origin eliminates the need for the physics engine to convert or translate values and therefore results in better performance.\n\n```swift\n\/\/ Apply impulse to shoot the object up.\nlet impulseStrength = 10\nlet impulseDirection = SIMD3<Float>(0, 1, 0)\nmodel.applyLinearImpulse(impulseStrength * impulseDirection, relativeTo: arView.physicsOrigin)\n```\n\n### Avoid extreme differences in size and mass\n\nRealityKit’s physics simulations work best if the size and mass ratios don’t exceed one order of magnitude.\n\n- The largest object in your scene should be no more than 10 times the size of the smallest object.\n- The heaviest object in your scene should be no more than 10 times the mass of your lightest object.\n\nAdditionally, the physics simulation works best if the smallest dimension of each object is at least `0.05` units in size and the largest dimension of each object is no more than `10` units in size. If you need objects outside of this range, create objects that are inside this range and then scale the physics origin at runtime.\n\n### Increase density instead of mass\n\nFor best results, keep the mass of your scene’s objects at their calculated mass. Entities with substantially increased mass result in a proportional increase in momentum, which can make the physics simulation unstable. To simulate heavy, dense objects like gold or lead, leave the mass at its calculated value and increase the entity’s density property. The pre-defined physics materials available in Reality Composer use density to simulate heavy materials.\n\n```swift\n\/\/ Use the initializer with density instead of mass.\nmodel.physicsBody = .init(shapes: [boxShape], density: 200)\n```\n\nThe [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/PhysicsBodyComponent\/init(shapes:density:material:mode:)] initializer automatically computes mass based on volume and density, Water has a density of about 1000 kg\/m³ and steel has a density of 7800 kg\/m³. When setting the mass of an object, keep in mind that real-world objects aren’t always completely solid, and can be hollow. Densities of less than 1000 kg\/m³ work well in most scenarios.\n\n## Simulation setup\n\n- **Handling different-sized objects in physics simulations**: Set up a scene hierarchy for accurate physics simulations.\n- **PhysicsSimulationComponent**: A component that controls localized physics simulations.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Set up a scene hierarchy for accurate physics simulations.",
          "name" : "Handling different-sized objects in physics simulations",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/handling-different-sized-objects-in-physics-simulations"
        },
        {
          "description" : "A component that controls localized physics simulations.",
          "name" : "PhysicsSimulationComponent",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/PhysicsSimulationComponent"
        }
      ],
      "title" : "Simulation setup"
    }
  ],
  "source" : "appleJSON",
  "title" : "Designing scene hierarchies for efficient physics simulation",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/designing-scene-hierarchies-for-efficient-physics-simulation"
}