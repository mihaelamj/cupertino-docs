{
  "abstract" : "Build a system that creates and passes Metal command objects to entities dispatching Metal compute shaders.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ A structure containing the context a `ComputeSystem` needs to dispatch compute commands in every frame.\nstruct ComputeUpdateContext {\n    \/\/\/ The number of seconds elapsed since the last frame.\n    let deltaTime: TimeInterval\n    \/\/\/ The command buffer for the current frame.\n    let commandBuffer: MTLCommandBuffer\n    \/\/\/ The compute command encoder for the current frame.\n    let computeEncoder: MTLComputeCommandEncoder\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ A protocol that enables its adoptees to dispatch their own compute commands in every frame.\nprotocol ComputeSystem {\n    @MainActor\n    func update(computeContext: ComputeUpdateContext)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ A component that contains a `ComputeSystem`.\nstruct ComputeSystemComponent: Component {\n    let computeSystem: ComputeSystem\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ A class that updates the `ComputeSystem` of each `ComputeSystemComponent` with `ComputeUpdateContext` in every frame.\nclass ComputeDispatchSystem: System {\n    \/\/\/ The application's command queue.\n    \/\/\/\n    \/\/\/ A single, global command queue to use throughout the entire application.\n    static let commandQueue: MTLCommandQueue? = makeCommandQueue(labeled: \"Compute Dispatch System Command Queue\")\n    \n    \/\/\/ The query this system uses to get all entities with a `ComputeSystemComponent` in every frame.\n    let query = EntityQuery(where: .has(ComputeSystemComponent.self))\n    \n    required init(scene: Scene) { }\n    \n    \/\/\/ Updates all compute systems with the current frame's `ComputeUpdateContext`.\n    func update(context: SceneUpdateContext) {\n        \/\/ Get all entities with a `ComputeSystemComponent` in every frame.\n        let computeSystemEntities = context.entities(matching: query, updatingSystemWhen: .rendering)\n        \n        \/\/ Create the command buffer and compute encoder responsible for dispatching all compute commands this frame.\n        guard let commandBuffer = Self.commandQueue?.makeCommandBuffer(),\n              let computeEncoder = commandBuffer.makeComputeCommandEncoder() else {\n            return\n        }\n        \n        \/\/ Enqueue the command buffer.\n        commandBuffer.enqueue()\n        \n        \/\/ Dispatch all compute systems to encode their compute commands.\n        let computeContext = ComputeUpdateContext(deltaTime: context.deltaTime,\n                                                  commandBuffer: commandBuffer,\n                                                  computeEncoder: computeEncoder)\n        for computeSystemEntity in computeSystemEntities {\n            if let computeSystemComponent = computeSystemEntity.components[ComputeSystemComponent.self] {\n                computeSystemComponent.computeSystem.update(computeContext: computeContext)\n            }\n        }\n        \n        \/\/ Stop encoding compute commands and commit them to run on the GPU.\n        computeEncoder.endEncoding()\n        commandBuffer.commit()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ The device Metal selects as the default.\nlet metalDevice: MTLDevice? = MTLCreateSystemDefaultDevice()\n\n\/\/\/ Makes a command queue with the given label.\nfunc makeCommandQueue(labeled label: String) -> MTLCommandQueue? {\n    guard let metalDevice, let queue = metalDevice.makeCommandQueue() else {\n        return nil\n    }\n    queue.label = label\n    return queue\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyComputeSystem: ComputeSystem {\n    func update(computeContext: ComputeUpdateContext) {\n        \/\/ Dispatch compute shader functions here.\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "ComputeDispatchSystem.registerSystem()",
      "language" : "swift"
    },
    {
      "code" : "let myComputeSystem = MyComputeSystem()\nlet myComputeEntity = Entity()\nmyComputeEntity.components.set(ComputeSystemComponent(computeSystem: myComputeSystem))",
      "language" : "swift"
    }
  ],
  "contentHash" : "832a6fd43da5c791b3423260b68ecbc9a0e1811098aa29011b2df0b130b4e888",
  "crawledAt" : "2025-12-02T17:33:53Z",
  "id" : "F0FA38B4-B153-4F00-A550-D9124990DB34",
  "kind" : "article",
  "language" : "swift",
  "module" : "RealityKit",
  "overview" : "## Overview\n\nTo dispatch a Metal compute shader function, you need a command queue, a command buffer, and a compute command encoder. Creating these command objects comes at a cost, so avoid making them on demand whenever you need to dispatch a compute shader function (see [https:\/\/developer.apple.com\/documentation\/metal\/gpu_devices_and_work_submission\/setting_up_a_command_structure]). Instead, for single-threaded apps, employ a single command queue for the entirety of the application, as well as a single command buffer and compute command encoder for all compute commands that you dispatch in every frame.\n\nThe [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] sample demonstrates one possible approach to managing the life cycle and injection of these command objects throughout an application. Leverage RealityKit’s [https:\/\/developer.apple.com\/documentation\/realitykit\/system] (ECS) to pass an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcommandbuffer] and an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputecommandencoder] to each entity dispatching compute shaders in every frame, while maintaining a single global [https:\/\/developer.apple.com\/documentation\/metal\/mtlcommandqueue] for the entire application.\n\n## Define a compute system protocol\n\nStart by creating a structure that contains the context necessary to dispatch compute shader functions in every frame:\n\nYou can choose not to include the `deltaTime` property in your structure, or you can add additional properties, such as [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/SceneUpdateContext].\n\nNext, define a protocol with an update method that takes `ComputeUpdateContext` as a parameter:\n\n## Dispatch compute systems with RealityKit’s ECS\n\nCreate a component that holds a `ComputeSystem`:\n\nThen, create a custom [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System] that finds all entities with a `ComputeSystemComponent` in every frame and passes that frame’s `ComputeUpdateContext` to their `ComputeSystem` instances:\n\nIn this example, a helper method assists in the creation of the Metal command queue:\n\n## Create a custom compute system\n\nYou can dispatch your compute shader functions in every frame by creating a custom `ComputeSystem` and implementing its `update` method:\n\nBe sure to register the `ComputeDispatchSystem` so that the `update` method fires every frame:\n\nFinally, attach your custom `ComputeSystem` to an entity with a `ComputeSystemComponent`:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/RealityKit\/passing-metal-command-objects-around-your-application\ncrawled: 2025-12-02T17:33:53Z\n---\n\n# Passing Metal command objects around your application\n\n**Article**\n\nBuild a system that creates and passes Metal command objects to entities dispatching Metal compute shaders.\n\n## Overview\n\nTo dispatch a Metal compute shader function, you need a command queue, a command buffer, and a compute command encoder. Creating these command objects comes at a cost, so avoid making them on demand whenever you need to dispatch a compute shader function (see [https:\/\/developer.apple.com\/documentation\/metal\/gpu_devices_and_work_submission\/setting_up_a_command_structure]). Instead, for single-threaded apps, employ a single command queue for the entirety of the application, as well as a single command buffer and compute command encoder for all compute commands that you dispatch in every frame.\n\nThe [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/generating-interactive-geometry-with-realitykit] sample demonstrates one possible approach to managing the life cycle and injection of these command objects throughout an application. Leverage RealityKit’s [https:\/\/developer.apple.com\/documentation\/realitykit\/system] (ECS) to pass an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcommandbuffer] and an [https:\/\/developer.apple.com\/documentation\/metal\/mtlcomputecommandencoder] to each entity dispatching compute shaders in every frame, while maintaining a single global [https:\/\/developer.apple.com\/documentation\/metal\/mtlcommandqueue] for the entire application.\n\n## Define a compute system protocol\n\nStart by creating a structure that contains the context necessary to dispatch compute shader functions in every frame:\n\n```swift\n\/\/\/ A structure containing the context a `ComputeSystem` needs to dispatch compute commands in every frame.\nstruct ComputeUpdateContext {\n    \/\/\/ The number of seconds elapsed since the last frame.\n    let deltaTime: TimeInterval\n    \/\/\/ The command buffer for the current frame.\n    let commandBuffer: MTLCommandBuffer\n    \/\/\/ The compute command encoder for the current frame.\n    let computeEncoder: MTLComputeCommandEncoder\n}\n```\n\nYou can choose not to include the `deltaTime` property in your structure, or you can add additional properties, such as [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/SceneUpdateContext].\n\nNext, define a protocol with an update method that takes `ComputeUpdateContext` as a parameter:\n\n```swift\n\/\/\/ A protocol that enables its adoptees to dispatch their own compute commands in every frame.\nprotocol ComputeSystem {\n    @MainActor\n    func update(computeContext: ComputeUpdateContext)\n}\n```\n\n## Dispatch compute systems with RealityKit’s ECS\n\nCreate a component that holds a `ComputeSystem`:\n\n```swift\n\/\/\/ A component that contains a `ComputeSystem`.\nstruct ComputeSystemComponent: Component {\n    let computeSystem: ComputeSystem\n}\n```\n\nThen, create a custom [doc:\/\/com.apple.RealityKit\/documentation\/RealityKit\/System] that finds all entities with a `ComputeSystemComponent` in every frame and passes that frame’s `ComputeUpdateContext` to their `ComputeSystem` instances:\n\n```swift\n\/\/\/ A class that updates the `ComputeSystem` of each `ComputeSystemComponent` with `ComputeUpdateContext` in every frame.\nclass ComputeDispatchSystem: System {\n    \/\/\/ The application's command queue.\n    \/\/\/\n    \/\/\/ A single, global command queue to use throughout the entire application.\n    static let commandQueue: MTLCommandQueue? = makeCommandQueue(labeled: \"Compute Dispatch System Command Queue\")\n    \n    \/\/\/ The query this system uses to get all entities with a `ComputeSystemComponent` in every frame.\n    let query = EntityQuery(where: .has(ComputeSystemComponent.self))\n    \n    required init(scene: Scene) { }\n    \n    \/\/\/ Updates all compute systems with the current frame's `ComputeUpdateContext`.\n    func update(context: SceneUpdateContext) {\n        \/\/ Get all entities with a `ComputeSystemComponent` in every frame.\n        let computeSystemEntities = context.entities(matching: query, updatingSystemWhen: .rendering)\n        \n        \/\/ Create the command buffer and compute encoder responsible for dispatching all compute commands this frame.\n        guard let commandBuffer = Self.commandQueue?.makeCommandBuffer(),\n              let computeEncoder = commandBuffer.makeComputeCommandEncoder() else {\n            return\n        }\n        \n        \/\/ Enqueue the command buffer.\n        commandBuffer.enqueue()\n        \n        \/\/ Dispatch all compute systems to encode their compute commands.\n        let computeContext = ComputeUpdateContext(deltaTime: context.deltaTime,\n                                                  commandBuffer: commandBuffer,\n                                                  computeEncoder: computeEncoder)\n        for computeSystemEntity in computeSystemEntities {\n            if let computeSystemComponent = computeSystemEntity.components[ComputeSystemComponent.self] {\n                computeSystemComponent.computeSystem.update(computeContext: computeContext)\n            }\n        }\n        \n        \/\/ Stop encoding compute commands and commit them to run on the GPU.\n        computeEncoder.endEncoding()\n        commandBuffer.commit()\n    }\n}\n```\n\nIn this example, a helper method assists in the creation of the Metal command queue:\n\n```swift\n\/\/\/ The device Metal selects as the default.\nlet metalDevice: MTLDevice? = MTLCreateSystemDefaultDevice()\n\n\/\/\/ Makes a command queue with the given label.\nfunc makeCommandQueue(labeled label: String) -> MTLCommandQueue? {\n    guard let metalDevice, let queue = metalDevice.makeCommandQueue() else {\n        return nil\n    }\n    queue.label = label\n    return queue\n}\n```\n\n## Create a custom compute system\n\nYou can dispatch your compute shader functions in every frame by creating a custom `ComputeSystem` and implementing its `update` method:\n\n```swift\nstruct MyComputeSystem: ComputeSystem {\n    func update(computeContext: ComputeUpdateContext) {\n        \/\/ Dispatch compute shader functions here.\n    }\n}\n```\n\nBe sure to register the `ComputeDispatchSystem` so that the `update` method fires every frame:\n\n```swift\nComputeDispatchSystem.registerSystem()\n```\n\nFinally, attach your custom `ComputeSystem` to an entity with a `ComputeSystemComponent`:\n\n```swift\nlet myComputeSystem = MyComputeSystem()\nlet myComputeEntity = Entity()\nmyComputeEntity.components.set(ComputeSystemComponent(computeSystem: myComputeSystem))\n```\n\n## Performance improvements\n\n- **Improving the Performance of a RealityKit App**: Measure CPU and GPU utilization to find ways to improve your app’s performance.\n- **Reducing GPU Utilization in Your RealityKit App**: Prevent the GPU from limiting your app’s frame rate by reducing the complexity of your render.\n- **Reducing CPU Utilization in Your RealityKit App**: Target specific CPU metrics with adjustments to your app and its content.\n- **Construct an immersive environment for visionOS**: Build efficient custom worlds for your app.\n- **Resource**: A shared resource you use to configure a component, like a material, mesh, or texture.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Measure CPU and GPU utilization to find ways to improve your app’s performance.",
          "name" : "Improving the Performance of a RealityKit App",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/improving-the-performance-of-a-realitykit-app"
        },
        {
          "description" : "Prevent the GPU from limiting your app’s frame rate by reducing the complexity of your render.",
          "name" : "Reducing GPU Utilization in Your RealityKit App",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/reducing-gpu-utilization-in-your-realitykit-app"
        },
        {
          "description" : "Target specific CPU metrics with adjustments to your app and its content.",
          "name" : "Reducing CPU Utilization in Your RealityKit App",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/reducing-cpu-utilization-in-your-realitykit-app"
        },
        {
          "description" : "Build efficient custom worlds for your app.",
          "name" : "Construct an immersive environment for visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/construct-an-immersive-environment-for-visionOS"
        },
        {
          "description" : "A shared resource you use to configure a component, like a material, mesh, or texture.",
          "name" : "Resource",
          "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/Resource"
        }
      ],
      "title" : "Performance improvements"
    }
  ],
  "source" : "appleJSON",
  "title" : "Passing Metal command objects around your application",
  "url" : "https:\/\/developer.apple.com\/documentation\/RealityKit\/passing-metal-command-objects-around-your-application"
}