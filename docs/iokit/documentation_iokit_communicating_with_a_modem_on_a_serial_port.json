{
  "abstract" : "Find and connect to a modem attached to a serial port using IOKit.",
  "codeExamples" : [
    {
      "code" : "classesToMatch = IOServiceMatching(kIOSerialBSDServiceValue);\nif (classesToMatch == NULL) {\n    printf(\"IOServiceMatching returned a NULL dictionary.\\n\");\n}\nelse {\n    \/\/ Look for devices that claim to be modems.\n    CFDictionarySetValue(classesToMatch,\n                         CFSTR(kIOSerialBSDTypeKey),\n                         CFSTR(kIOSerialBSDModemType));\n}\n\n\/\/ Get an iterator across all matching devices.\nkernResult = IOServiceGetMatchingServices(kIOMasterPortDefault, classesToMatch, matchingServices);",
      "language" : "occ"
    },
    {
      "code" : "fileDescriptor = open(bsdPath, O_RDWR | O_NOCTTY | O_NONBLOCK);\nif (fileDescriptor == -1) {\n    printf(\"Error opening serial port %s - %s(%d).\\n\",\n           bsdPath, strerror(errno), errno);\n    goto error;\n}",
      "language" : "occ"
    },
    {
      "code" : "if (tcdrain(fileDescriptor) == -1) {\n    printf(\"Error waiting for drain - %s(%d).\\n\",\n           strerror(errno), errno);\n}\n\n\/\/ Traditionally it is good practice to reset a serial port back to\n\/\/ the state in which you found it. This is why the original termios struct\n\/\/ was saved.\nif (tcsetattr(fileDescriptor, TCSANOW, &gOriginalTTYAttrs) == -1) {\n    printf(\"Error resetting tty attributes - %s(%d).\\n\",\n           strerror(errno), errno);\n}\n\nclose(fileDescriptor);",
      "language" : "occ"
    }
  ],
  "contentHash" : "bba2105b7e1b7217be75c20f094977a52ed46964cafebb84e7a16785d45a9ae3",
  "crawledAt" : "2025-12-02T15:33:13Z",
  "id" : "A7765951-4563-4208-8B53-CAE63F6D384E",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "IOKit",
  "overview" : "## Overview\n\nThis sample project creates a command-line program that uses IOKit to discover a modem on a serial port and to send and receive data. Run the program within Xcode and use the console to monitor the progress of the communication.\n\n### Discover Attached Modems\n\nIOKit provides a matching service for various types of I\/O devices, including serial ports and modems. The sample code’s `findModems()` function uses `kIOSerialBSDServiceValue` to locate a serial device. Once located, the code identifies the type of serial device as a modem with `kIOSerialBSDModemType`.\n\nThe `findModems()` function returns an IOKit iterator that `getModemPath()` uses to locate the first available modem and obtain its formal BSD device path.\n\nIf the function fails to find a modem or can’t obtain the device, the program prematurely quits.\n\n### Open the Serial Port and Initialize the Modem\n\nAfter the `findModems` function finds the modem, `openSerialPort()` uses the low-level `open()` call to connect to the BSD file path discovered earlier. This function also captures the state of the serial port and saves it for later restoration.\n\nThis code allows the function to set up communication parameters such as baud rate, blocking characteristics, and handshaking lines.\n\nIf the call succeeds, it returns a BSD file descriptor. The `initalizeModem()` function then takes the file descriptor and sends the attention (`AT`) command to the modem using the low-level `write()` function. It then calls the `read()` function to obtain a response that confirms the modem is present.\n\n### Close the Serial Port\n\nThe `closeSerialPort()` function takes the passed file descriptor and waits for all output to flush, then restores the serial port to its original state and closes the file descriptor.\n\nThis action terminates communication to the modem and concludes the use of the serial port.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/iokit\/communicating_with_a_modem_on_a_serial_port\ncrawled: 2025-12-02T15:33:13Z\n---\n\n# Communicating with a Modem on a Serial Port\n\n**Sample Code**\n\nFind and connect to a modem attached to a serial port using IOKit.\n\n## Overview\n\nThis sample project creates a command-line program that uses IOKit to discover a modem on a serial port and to send and receive data. Run the program within Xcode and use the console to monitor the progress of the communication.\n\n### Discover Attached Modems\n\nIOKit provides a matching service for various types of I\/O devices, including serial ports and modems. The sample code’s `findModems()` function uses `kIOSerialBSDServiceValue` to locate a serial device. Once located, the code identifies the type of serial device as a modem with `kIOSerialBSDModemType`.\n\n```occ\nclassesToMatch = IOServiceMatching(kIOSerialBSDServiceValue);\nif (classesToMatch == NULL) {\n    printf(\"IOServiceMatching returned a NULL dictionary.\\n\");\n}\nelse {\n    \/\/ Look for devices that claim to be modems.\n    CFDictionarySetValue(classesToMatch,\n                         CFSTR(kIOSerialBSDTypeKey),\n                         CFSTR(kIOSerialBSDModemType));\n}\n\n\/\/ Get an iterator across all matching devices.\nkernResult = IOServiceGetMatchingServices(kIOMasterPortDefault, classesToMatch, matchingServices);\n```\n\nThe `findModems()` function returns an IOKit iterator that `getModemPath()` uses to locate the first available modem and obtain its formal BSD device path.\n\nIf the function fails to find a modem or can’t obtain the device, the program prematurely quits.\n\n### Open the Serial Port and Initialize the Modem\n\nAfter the `findModems` function finds the modem, `openSerialPort()` uses the low-level `open()` call to connect to the BSD file path discovered earlier. This function also captures the state of the serial port and saves it for later restoration.\n\n```occ\nfileDescriptor = open(bsdPath, O_RDWR | O_NOCTTY | O_NONBLOCK);\nif (fileDescriptor == -1) {\n    printf(\"Error opening serial port %s - %s(%d).\\n\",\n           bsdPath, strerror(errno), errno);\n    goto error;\n}\n```\n\nThis code allows the function to set up communication parameters such as baud rate, blocking characteristics, and handshaking lines.\n\nIf the call succeeds, it returns a BSD file descriptor. The `initalizeModem()` function then takes the file descriptor and sends the attention (`AT`) command to the modem using the low-level `write()` function. It then calls the `read()` function to obtain a response that confirms the modem is present.\n\n### Close the Serial Port\n\nThe `closeSerialPort()` function takes the passed file descriptor and waits for all output to flush, then restores the serial port to its original state and closes the file descriptor.\n\n```occ\nif (tcdrain(fileDescriptor) == -1) {\n    printf(\"Error waiting for drain - %s(%d).\\n\",\n           strerror(errno), errno);\n}\n\n\/\/ Traditionally it is good practice to reset a serial port back to\n\/\/ the state in which you found it. This is why the original termios struct\n\/\/ was saved.\nif (tcsetattr(fileDescriptor, TCSANOW, &gOriginalTTYAttrs) == -1) {\n    printf(\"Error resetting tty attributes - %s(%d).\\n\",\n           strerror(errno), errno);\n}\n\nclose(fileDescriptor);\n```\n\nThis action terminates communication to the modem and concludes the use of the serial port.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Communicating with a Modem on a Serial Port",
  "url" : "https:\/\/developer.apple.com\/documentation\/iokit\/communicating_with_a_modem_on_a_serial_port"
}