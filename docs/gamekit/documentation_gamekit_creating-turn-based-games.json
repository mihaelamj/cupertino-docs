{
  "abstract" : "Develop games where multiple players take turns and can exchange data while waiting for their turn.",
  "codeExamples" : [
    {
      "code" : "\/\/ Register for turn-based invitations and other events.\nGKLocalPlayer.local.register(self)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create a match request.\nlet request = GKMatchRequest()\nrequest.minPlayers = minPlayers\nrequest.maxPlayers = maxPlayers\nif playersToInvite != nil {\n    request.recipients = playersToInvite\n}\n\n\/\/ Present the interface where the player selects opponents and starts the game.\nlet viewController = GKTurnBasedMatchmakerViewController(matchRequest: request)\nviewController.turnBasedMatchmakerDelegate = self\nrootViewController?.present(viewController, animated: true) { }",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Update the interface depending on whether it's the local player's turn.\nmyTurn = GKLocalPlayer.local == match.currentParticipant?.player ? true : false",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Retain the match ID so action methods can load the current match object later.\ncurrentMatchID = match.matchID",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Load the most recent match object from the match ID.\nlet match = try await GKTurnBasedMatch.load(withID: currentMatchID!)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create the game data to store in Game Center.\nlet gameData = (encodeGameData() ?? match.matchData)!\n\n\/\/ Remove the current participant from the match participants.\nlet nextParticipants = activeParticipants.filter {\n    $0 != match.currentParticipant\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Pass the turn to the next participant.\ntry await match.endTurn(withNextParticipants: nextParticipants, turnTimeout: GKTurnTimeoutDefault,\n                        match: gameData)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ If the player starts the match, the opponent hasn't accepted the invitation and has no player object.\nlet participant = participants.first\nif (participant != nil) && (participant?.status != .matching) && (participant?.player != nil) {\n    if opponent == nil {\n        \/\/ Load the opponent's avatar and create the opponent object.\n        let image = try await participant?.player?.loadPhoto(for: GKPlayer.PhotoSize.small)\n        opponent = Participant(player: (participant?.player)!,\n                               avatar: Image(uiImage: image!))\n    }\n    \n    \/\/ Restore the current game data from the match object.\n    decodeGameData(matchData: match.matchData!)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create the game data to store in Game Center.\nlet gameData = (encodeGameData() ?? match.matchData)!\n\n\/\/ Remove the participants who quit and the current participant.\nlet nextParticipants = match.participants.filter {\n  ($0.status != .done) && ($0 != match.currentParticipant)\n}\n\n\/\/ Forfeit the match.\ntry await match.participantQuitInTurn(\n    with: GKTurnBasedMatch.Outcome.quit,\n    nextParticipants: nextParticipants,\n    turnTimeout: GKTurnTimeoutDefault,\n    match: gameData)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Forfeit the match while it's not the local player's turn.\ntry await match.participantQuitOutOfTurn(with: GKTurnBasedMatch.Outcome.quit)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Remove participants who quit or otherwise aren't in the match.\nlet nextParticipants = match.participants.filter {\n    $0.status != .done\n}\n\n\/\/ End the match if active participants drop below the minimum.\nif nextParticipants.count < minPlayers {\n    \/\/ Set the match outcomes for the active participants.\n    for participant in nextParticipants {\n        participant.matchOutcome = .won\n    }\n    \n    \/\/ End the match in turn.\n    try await match.endMatchInTurn(withMatch: match.matchData!)\n    \n    \/\/ Notify the local player when the match ends.\n    youWon = true\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create the exchange data.\nguard let data = content.data(using: .utf8) else { return }\n\n\/\/ Load the most recent match object from the match ID.\nlet match = try await GKTurnBasedMatch.load(withID: currentMatchID!)\n\n\/\/ Remove the local player (the sender) from the recipients;\n\/\/ otherwise, GameKit doesn't send the exchange request.\nlet participants = match.participants.filter {\n    localParticipant?.player.displayName != $0.player?.displayName\n}\n\n\/\/ Send the exchange request with the message.\ntry await match.sendExchange(to: participants, data: data,\n                             localizableMessageKey: \"This is my text message.\",\n                             arguments: [], timeout: GKTurnTimeoutDefault)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Unpack the exchange data and display the message in the chat view.\nlet content = String(decoding: exchange.data!, as: UTF8.self)\nlet message = Message(content: content, playerName: exchange.sender.player?.displayName ?? \"unknown\", isLocalPlayer: false)",
      "language" : "swift"
    },
    {
      "code" : "try await exchange.reply(withLocalizableMessageKey: \"I accept the exchange request.\", arguments: [], data: Data())",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Check whether the local player is the current participant who can save exchanges.\nguard myTurn else { return }",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Resolve the game data to pass to all participants.\nlet gameData = (encodeGameData() ?? match.matchData)!\n\n\/\/ Save and forward the game data with the latest items.\nTask {\n    try await match.saveMergedMatch(gameData, withResolvedExchanges: completedExchanges)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "904b5ce31b8599855436f4be632eb4e0ac7b69ba7d4984fca91667aaba0749ef",
  "crawledAt" : "2025-12-02T15:30:30Z",
  "id" : "1004C8E6-D0CB-4097-AD68-B39AD68036A9",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "GameKit",
  "overview" : "## Overview\n\nThis sample code project uses the GameKit framework to create a simple turn-based game where two players take turns incrementing a counter until a player stops playing or forfeits the match. The game uses the turn-based matchmaker interface for starting and managing multiple turn-based matches. This game also uses the GameKit exchanges feature for participants in a turn-based game to message and exchange data.\n\nTo create your own turn-based game, replace the SwiftUI files with your gameplay interface, and modify the `TurnBasedGame` class to support your game.\n\n### Configure the sample code project\n\nTo configure the sample code project, perform the following steps in Xcode:\n\n### Initialize the player and register for turn-based events\n\nBefore using any GameKit APIs, the game needs to initialize the local player by presenting an interface for them to sign in to Game Center on their device. The `TurnBasedGame.authenticatePlayer()` method handles the initialization flow and, when complete, registers for turn-based game events.\n\n### Start a turn-based match\n\nTo start or join an existing match, the player taps the Start Match button on the content view. Then the `TurnBasedGame.startMatch()` action method creates a match request and presents a [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatchmakerViewController] interface where the player can invite friends or automatch to fill empty slots.\n\nAfter the player selects opponents in the Game Center interface, GameKit dismisses the view controller and invokes the `GKTurnBasedEventListener.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] protocol method, passing a new [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch] object. This method handles a variety of turn-based events throughout the match.\n\nThe first time GameKit invokes the `player(_:receivedTurnEventFor:didBecomeActive:)` method, the local player is the current participant. This method sets the `myTurn` property to `true`, which enables the Take Turn button in the game view interface.\n\nGameKit doesn’t send invitations to the match until the participant who starts the match takes the first turn. Therefore, this method displays a placeholder name and avatar for the opponent until the opponent joins the match.\n\nInstead of retaining the `GKTurnBasedMatch` object, which can change during the course of the match, this method retains the match ID so the game can fetch the current match object as necessary later.\n\n### Pass the turn to the next participant\n\nWhen the current participant taps the Take Turn button, the `TurnBasedGame.takeTurn()` action method increments the count and passes the turn to the opponent.\n\nFirst the `takeTurn()` method loads the current match object using the match ID it retains in the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method.\n\nThis method passes the turn to the opponent using the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/endTurn(withNextParticipants:turnTimeout:match:completionHandler:)] method. It passes the next participant an array containing just the opponent, and a `Data` representation of the game state that contains the current count.\n\nThen pass the next participants and the game data, specifying a timeout in case the receipients don’t respond, to the `endTurn(withNextParticipants:turnTimeout:match:completionHandler:)` method.\n\nThe first time the game passes the turn, GameKit sends invitations to all the participants.\n\n### Accept turn-based match invitations\n\nWhen the opponent taps the Accept button in the dialog that GameKit displays on their device, GameKit invokes the `GKTurnBasedEventListener.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method.\n\nWhen the local player accepts the invitation, the other participant’s status is [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedParticipant\/Status-swift.enum\/active] and its player property is non-`nil`, allowing this method to get the opponent’s name and load their avatar from the `GKPlayer` object.\n\nThe match object also contains data, such as the current count, that this method encodes to update the game view interface. The `TurnBasedGame.encodeGameData()` and `TurnBasedGame.decodeGameData()` methods store just the game properties that you need to continue playing when GameKit sends turn-based events between participants.\n\n### Forfeit a turn-based match\n\nIf a participant taps the Forfeit button, the `TurnBasedGame.forfeitMatch()` action method quits the match whether it’s the participant’s turn or not. Because only the current participant can update the match data, GameKit provides two different methods to leave a match.\n\nWhen it’s the local player’s turn, the `forfeitMatch()` method creates a `Data` representation of the game data, selects the next participants, and invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/participantQuitInTurn(with:nextParticipants:turnTimeout:match:completionHandler:)] method, passing [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/Outcome\/quit] as the outcome.\n\nWhen it’s not the local player’s turn, the `forfeitMatch()` method calls the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/participantQuitOutOfTurn(with:withCompletionHandler:)] method.\n\nBoth of these methods change the status of the participant to [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedParticipant\/Status-swift.enum\/done] and generate a turn-based event that invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method. If there aren’t enough participants to continue (when there’s only one participant remaining in the match), this method sets the outcome of the recipient to [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/Outcome\/won] and ends the game.\n\nThe `takeTurn()` action method also ends the match with a win if there aren’t enough participants to continue.\n\n### Exchange data between participants\n\nParticipants can message other participants and exchange items while they’re waiting for the current participant to take their turn. When a participant taps the message bubble in the game view, the chat view sheet appears so the participant can send a text message to the opponent.\n\nThe `TurnBasedGame.sendMessage()` method sends the text message as the data in an exchange request. It passes the data, a localizable message, and a response timeout to the `GKTurnBasedMatch.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/sendExchange(to:data:localizableMessageKey:arguments:timeout:completionHandler:)] method.\n\nIn the recipient’s game instance, GameKit invokes the `GKTurnBasedEventListener.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedExchangeRequest:for:)] protocol method, passing the player, the exchange object, and the match object. This method displays the message to the recipient when they have the chat view sheet open. Otherwise, the message appears in the chat view thread the next time the participant opens it.\n\nFor expedience, this method immediately accepts the exchange request when the exchange status is [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedExchangeStatus\/active].\n\n### Save completed exchanges\n\nIn the sample, each participant starts with 50 items next to their names. To exchange items, a participant clicks the Exchange Item button below the Send Reminder button. The same code that accepts the chat messages also automatically accepts the exchange item request.\n\nWhen participants reply to exchange requests, GameKit invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedExchangeReplies:forCompletedExchange:for:)] protocol method in the current participant and the sender’s game instance. In this sample, the `player(_:receivedExchangeReplies:forCompletedExchange:for:)` method invokes the `TurnBasedGame.saveExchanges()` method.\n\nBecause GameKit requires that the current participant save completed exchanges before ending a match, the `takeTurn()` method also invokes the `saveExchanges(for:)` method before ending a match.\n\nBecause only the current participant can save exchanges, the `saveExchanges(for:)` method first checks whether the local player is the current participant before continuing.\n\nThis method resolves the exchange by transferring one item from the recipient to the sender of the exchange request. Then it adds the participant’s exchange items to the game data, and passes it with the completed exchanges to the `GKTurnBasedMatch.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/saveMergedMatch(_:withResolvedExchanges:completionHandler:)] method.\n\nThe `saveMergedMatch(_:withResolvedExchanges:completionHandler:)` method removes the completed exchange objects from the `GKTurnBasedMatch` object’s [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/completedExchanges] and [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/exchanges] properties.\n\nBecause the match data changes, GameKit invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method in the other participants’ game instances. The `player(_:receivedTurnEventFor:didBecomeActive:)` method unpacks the match data and displays the exchanged items.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/GameKit\/creating-turn-based-games\ncrawled: 2025-12-02T15:30:30Z\n---\n\n# Creating turn-based games\n\n**Sample Code**\n\nDevelop games where multiple players take turns and can exchange data while waiting for their turn.\n\n## Overview\n\nThis sample code project uses the GameKit framework to create a simple turn-based game where two players take turns incrementing a counter until a player stops playing or forfeits the match. The game uses the turn-based matchmaker interface for starting and managing multiple turn-based matches. This game also uses the GameKit exchanges feature for participants in a turn-based game to message and exchange data.\n\nTo create your own turn-based game, replace the SwiftUI files with your gameplay interface, and modify the `TurnBasedGame` class to support your game.\n\n### Configure the sample code project\n\nTo configure the sample code project, perform the following steps in Xcode:\n\n1. If necessary, change the Bundle Identifier to a unique ID on the Signing & Capabilities pane.\n2. Add your Apple ID account and assign the target to a team so Xcode can enable Game Center.\n3. In App Store Connect, create an app record that matches the bundle ID (see [https:\/\/developer.apple.com\/help\/app-store-connect\/create-an-app-record\/add-a-new-app] in App Store Connect Help).\n4. Connect two iOS devices to your Mac.\n5. If necessary, click Register Device in the Signing & Capabilities pane to create the provisioning profile.\n6. Build and run the sample on the two iOS devices.\n7. If the Welcome to Game Center sheet appears, sign in using a different Apple ID on each device.\n\n### Initialize the player and register for turn-based events\n\nBefore using any GameKit APIs, the game needs to initialize the local player by presenting an interface for them to sign in to Game Center on their device. The `TurnBasedGame.authenticatePlayer()` method handles the initialization flow and, when complete, registers for turn-based game events.\n\n```swift\n\/\/ Register for turn-based invitations and other events.\nGKLocalPlayer.local.register(self)\n```\n\n### Start a turn-based match\n\nTo start or join an existing match, the player taps the Start Match button on the content view. Then the `TurnBasedGame.startMatch()` action method creates a match request and presents a [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatchmakerViewController] interface where the player can invite friends or automatch to fill empty slots.\n\n```swift\n\/\/ Create a match request.\nlet request = GKMatchRequest()\nrequest.minPlayers = minPlayers\nrequest.maxPlayers = maxPlayers\nif playersToInvite != nil {\n    request.recipients = playersToInvite\n}\n\n\/\/ Present the interface where the player selects opponents and starts the game.\nlet viewController = GKTurnBasedMatchmakerViewController(matchRequest: request)\nviewController.turnBasedMatchmakerDelegate = self\nrootViewController?.present(viewController, animated: true) { }\n```\n\nAfter the player selects opponents in the Game Center interface, GameKit dismisses the view controller and invokes the `GKTurnBasedEventListener.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] protocol method, passing a new [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch] object. This method handles a variety of turn-based events throughout the match.\n\nThe first time GameKit invokes the `player(_:receivedTurnEventFor:didBecomeActive:)` method, the local player is the current participant. This method sets the `myTurn` property to `true`, which enables the Take Turn button in the game view interface.\n\n```swift\n\/\/ Update the interface depending on whether it's the local player's turn.\nmyTurn = GKLocalPlayer.local == match.currentParticipant?.player ? true : false\n```\n\nGameKit doesn’t send invitations to the match until the participant who starts the match takes the first turn. Therefore, this method displays a placeholder name and avatar for the opponent until the opponent joins the match.\n\nInstead of retaining the `GKTurnBasedMatch` object, which can change during the course of the match, this method retains the match ID so the game can fetch the current match object as necessary later.\n\n```swift\n\/\/ Retain the match ID so action methods can load the current match object later.\ncurrentMatchID = match.matchID\n```\n\n### Pass the turn to the next participant\n\nWhen the current participant taps the Take Turn button, the `TurnBasedGame.takeTurn()` action method increments the count and passes the turn to the opponent.\n\nFirst the `takeTurn()` method loads the current match object using the match ID it retains in the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method.\n\n```swift\n\/\/ Load the most recent match object from the match ID.\nlet match = try await GKTurnBasedMatch.load(withID: currentMatchID!)\n```\n\nThis method passes the turn to the opponent using the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/endTurn(withNextParticipants:turnTimeout:match:completionHandler:)] method. It passes the next participant an array containing just the opponent, and a `Data` representation of the game state that contains the current count.\n\n```swift\n\/\/ Create the game data to store in Game Center.\nlet gameData = (encodeGameData() ?? match.matchData)!\n\n\/\/ Remove the current participant from the match participants.\nlet nextParticipants = activeParticipants.filter {\n    $0 != match.currentParticipant\n}\n```\n\nThen pass the next participants and the game data, specifying a timeout in case the receipients don’t respond, to the `endTurn(withNextParticipants:turnTimeout:match:completionHandler:)` method.\n\n```swift\n\/\/ Pass the turn to the next participant.\ntry await match.endTurn(withNextParticipants: nextParticipants, turnTimeout: GKTurnTimeoutDefault,\n                        match: gameData)\n```\n\n\n\nThe first time the game passes the turn, GameKit sends invitations to all the participants.\n\n### Accept turn-based match invitations\n\nWhen the opponent taps the Accept button in the dialog that GameKit displays on their device, GameKit invokes the `GKTurnBasedEventListener.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method.\n\nWhen the local player accepts the invitation, the other participant’s status is [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedParticipant\/Status-swift.enum\/active] and its player property is non-`nil`, allowing this method to get the opponent’s name and load their avatar from the `GKPlayer` object.\n\n```swift\n\/\/ If the player starts the match, the opponent hasn't accepted the invitation and has no player object.\nlet participant = participants.first\nif (participant != nil) && (participant?.status != .matching) && (participant?.player != nil) {\n    if opponent == nil {\n        \/\/ Load the opponent's avatar and create the opponent object.\n        let image = try await participant?.player?.loadPhoto(for: GKPlayer.PhotoSize.small)\n        opponent = Participant(player: (participant?.player)!,\n                               avatar: Image(uiImage: image!))\n    }\n    \n    \/\/ Restore the current game data from the match object.\n    decodeGameData(matchData: match.matchData!)\n}\n```\n\nThe match object also contains data, such as the current count, that this method encodes to update the game view interface. The `TurnBasedGame.encodeGameData()` and `TurnBasedGame.decodeGameData()` methods store just the game properties that you need to continue playing when GameKit sends turn-based events between participants.\n\n### Forfeit a turn-based match\n\nIf a participant taps the Forfeit button, the `TurnBasedGame.forfeitMatch()` action method quits the match whether it’s the participant’s turn or not. Because only the current participant can update the match data, GameKit provides two different methods to leave a match.\n\nWhen it’s the local player’s turn, the `forfeitMatch()` method creates a `Data` representation of the game data, selects the next participants, and invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/participantQuitInTurn(with:nextParticipants:turnTimeout:match:completionHandler:)] method, passing [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/Outcome\/quit] as the outcome.\n\n```swift\n\/\/ Create the game data to store in Game Center.\nlet gameData = (encodeGameData() ?? match.matchData)!\n\n\/\/ Remove the participants who quit and the current participant.\nlet nextParticipants = match.participants.filter {\n  ($0.status != .done) && ($0 != match.currentParticipant)\n}\n\n\/\/ Forfeit the match.\ntry await match.participantQuitInTurn(\n    with: GKTurnBasedMatch.Outcome.quit,\n    nextParticipants: nextParticipants,\n    turnTimeout: GKTurnTimeoutDefault,\n    match: gameData)\n```\n\nWhen it’s not the local player’s turn, the `forfeitMatch()` method calls the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/participantQuitOutOfTurn(with:withCompletionHandler:)] method.\n\n```swift\n\/\/ Forfeit the match while it's not the local player's turn.\ntry await match.participantQuitOutOfTurn(with: GKTurnBasedMatch.Outcome.quit)\n```\n\nBoth of these methods change the status of the participant to [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedParticipant\/Status-swift.enum\/done] and generate a turn-based event that invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method. If there aren’t enough participants to continue (when there’s only one participant remaining in the match), this method sets the outcome of the recipient to [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/Outcome\/won] and ends the game.\n\n```swift\n\/\/ Remove participants who quit or otherwise aren't in the match.\nlet nextParticipants = match.participants.filter {\n    $0.status != .done\n}\n\n\/\/ End the match if active participants drop below the minimum.\nif nextParticipants.count < minPlayers {\n    \/\/ Set the match outcomes for the active participants.\n    for participant in nextParticipants {\n        participant.matchOutcome = .won\n    }\n    \n    \/\/ End the match in turn.\n    try await match.endMatchInTurn(withMatch: match.matchData!)\n    \n    \/\/ Notify the local player when the match ends.\n    youWon = true\n}\n```\n\nThe `takeTurn()` action method also ends the match with a win if there aren’t enough participants to continue.\n\n### Exchange data between participants\n\nParticipants can message other participants and exchange items while they’re waiting for the current participant to take their turn. When a participant taps the message bubble in the game view, the chat view sheet appears so the participant can send a text message to the opponent.\n\nThe `TurnBasedGame.sendMessage()` method sends the text message as the data in an exchange request. It passes the data, a localizable message, and a response timeout to the `GKTurnBasedMatch.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/sendExchange(to:data:localizableMessageKey:arguments:timeout:completionHandler:)] method.\n\n```swift\n\/\/ Create the exchange data.\nguard let data = content.data(using: .utf8) else { return }\n\n\/\/ Load the most recent match object from the match ID.\nlet match = try await GKTurnBasedMatch.load(withID: currentMatchID!)\n\n\/\/ Remove the local player (the sender) from the recipients;\n\/\/ otherwise, GameKit doesn't send the exchange request.\nlet participants = match.participants.filter {\n    localParticipant?.player.displayName != $0.player?.displayName\n}\n\n\/\/ Send the exchange request with the message.\ntry await match.sendExchange(to: participants, data: data,\n                             localizableMessageKey: \"This is my text message.\",\n                             arguments: [], timeout: GKTurnTimeoutDefault)\n```\n\nIn the recipient’s game instance, GameKit invokes the `GKTurnBasedEventListener.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedExchangeRequest:for:)] protocol method, passing the player, the exchange object, and the match object. This method displays the message to the recipient when they have the chat view sheet open. Otherwise, the message appears in the chat view thread the next time the participant opens it.\n\n```swift\n\/\/ Unpack the exchange data and display the message in the chat view.\nlet content = String(decoding: exchange.data!, as: UTF8.self)\nlet message = Message(content: content, playerName: exchange.sender.player?.displayName ?? \"unknown\", isLocalPlayer: false)\n```\n\nFor expedience, this method immediately accepts the exchange request when the exchange status is [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedExchangeStatus\/active].\n\n```swift\ntry await exchange.reply(withLocalizableMessageKey: \"I accept the exchange request.\", arguments: [], data: Data())\n```\n\n### Save completed exchanges\n\nIn the sample, each participant starts with 50 items next to their names. To exchange items, a participant clicks the Exchange Item button below the Send Reminder button. The same code that accepts the chat messages also automatically accepts the exchange item request.\n\nWhen participants reply to exchange requests, GameKit invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedExchangeReplies:forCompletedExchange:for:)] protocol method in the current participant and the sender’s game instance. In this sample, the `player(_:receivedExchangeReplies:forCompletedExchange:for:)` method invokes the `TurnBasedGame.saveExchanges()` method.\n\nBecause GameKit requires that the current participant save completed exchanges before ending a match, the `takeTurn()` method also invokes the `saveExchanges(for:)` method before ending a match.\n\nBecause only the current participant can save exchanges, the `saveExchanges(for:)` method first checks whether the local player is the current participant before continuing.\n\n```swift\n\/\/ Check whether the local player is the current participant who can save exchanges.\nguard myTurn else { return }\n```\n\nThis method resolves the exchange by transferring one item from the recipient to the sender of the exchange request. Then it adds the participant’s exchange items to the game data, and passes it with the completed exchanges to the `GKTurnBasedMatch.`[doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/saveMergedMatch(_:withResolvedExchanges:completionHandler:)] method.\n\n```swift\n\/\/ Resolve the game data to pass to all participants.\nlet gameData = (encodeGameData() ?? match.matchData)!\n\n\/\/ Save and forward the game data with the latest items.\nTask {\n    try await match.saveMergedMatch(gameData, withResolvedExchanges: completedExchanges)\n}\n```\n\nThe `saveMergedMatch(_:withResolvedExchanges:completionHandler:)` method removes the completed exchange objects from the `GKTurnBasedMatch` object’s [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/completedExchanges] and [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedMatch\/exchanges] properties.\n\nBecause the match data changes, GameKit invokes the [doc:\/\/com.apple.documentation\/documentation\/GameKit\/GKTurnBasedEventListener\/player(_:receivedTurnEventFor:didBecomeActive:)] method in the other participants’ game instances. The `player(_:receivedTurnEventFor:didBecomeActive:)` method unpacks the match data and displays the exchanged items.\n\n## Turn-based games\n\n- **Starting turn-based matches and passing turns between players**: Let Game Center store and forward match data between players in a turn-based game.\n- **Sending messages to players in turn-based games**: Notify players of match events by sending messages and game data.\n- **Exchanging data between players in turn-based games**: Add the ability for players to exchange game data and send messages while waiting for their turns.\n- **GKTurnBasedMatchmakerViewController**: An interface that allows a player to invite other players to a turn-based match and automatch to fill any empty slots.\n- **GKTurnBasedMatch**: An object that encapsulates the match data for games where players take turns.\n- **GKTurnBasedParticipant**: A participant in a turn-based match.\n- **GKTurnBasedEventListener**: The protocol that handles turn-based and data-exchange events between participants in a match.\n- **GKTurnBasedExchange**: Exchange request information that participants send in a turn-based match.\n- **GKTurnBasedExchangeReply**: Details about a recipient’s response to an exchange request.\n- **GKGameCenterBadgingDisabled**: A Boolean value indicating whether GameKit can add badges to a turn-based game icon.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Let Game Center store and forward match data between players in a turn-based game.",
          "name" : "Starting turn-based matches and passing turns between players",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/starting-turn-based-matches-and-passing-turns-between-players"
        },
        {
          "description" : "Notify players of match events by sending messages and game data.",
          "name" : "Sending messages to players in turn-based games",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/sending-messages-to-players-in-turn-based-games"
        },
        {
          "description" : "Add the ability for players to exchange game data and send messages while waiting for their turns.",
          "name" : "Exchanging data between players in turn-based games",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/exchanging-data-between-players-in-turn-based-games"
        },
        {
          "description" : "An interface that allows a player to invite other players to a turn-based match and automatch to fill any empty slots.",
          "name" : "GKTurnBasedMatchmakerViewController",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/GKTurnBasedMatchmakerViewController"
        },
        {
          "description" : "An object that encapsulates the match data for games where players take turns.",
          "name" : "GKTurnBasedMatch",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/GKTurnBasedMatch"
        },
        {
          "description" : "A participant in a turn-based match.",
          "name" : "GKTurnBasedParticipant",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/GKTurnBasedParticipant"
        },
        {
          "description" : "The protocol that handles turn-based and data-exchange events between participants in a match.",
          "name" : "GKTurnBasedEventListener",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/GKTurnBasedEventListener"
        },
        {
          "description" : "Exchange request information that participants send in a turn-based match.",
          "name" : "GKTurnBasedExchange",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/GKTurnBasedExchange"
        },
        {
          "description" : "Details about a recipient’s response to an exchange request.",
          "name" : "GKTurnBasedExchangeReply",
          "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/GKTurnBasedExchangeReply"
        },
        {
          "description" : "A Boolean value indicating whether GameKit can add badges to a turn-based game icon.",
          "name" : "GKGameCenterBadgingDisabled",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/GKGameCenterBadgingDisabled"
        }
      ],
      "title" : "Turn-based games"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating turn-based games",
  "url" : "https:\/\/developer.apple.com\/documentation\/GameKit\/creating-turn-based-games"
}