{
  "abstract" : "A distributed actor system underpins and implements all functionality of distributed actors.",
  "codeExamples" : [
    {
      "code" : "distributed actor Greeter {\n  init(name: String, actorSystem: ActorSystem) {\n    self.name = name\n    self.actorSystem = actorSystem \/\/ required (!) initialization of implicit actorSystem property\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "distributed actor ShowcaseIDInit {\n  \/\/ let actorSystem: ActorSystem \/\/ synthesized;\n\n  \/\/ typealias ID = ActorSystem.ActorID\n  \/\/ let id: ID \/\/ synthesized; implements `Identifiable.id` requirement\n\n  init(actorSystem: ActorSystem) {\n    self.actorSystem = actorSystem\n    \/\/ ...\n    \/\/ self.id = actorSystem.assignID(Self.self) \/\/ synthesized;\n    \/\/ ...\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Synthesized inside a distributed actor's deinit:\ndeinit {\n  \/\/ actorSystem.resignID(self.id)\n}",
      "language" : "swift"
    }
  ],
  "conformingTypes" : [
    "LocalTestingDistributedActorSystem"
  ],
  "contentHash" : "5baada7d6e78bd428cd30b1a7b7edce3f642c3b820d1b8daebf554312d962084",
  "crawledAt" : "2025-12-03T07:56:32Z",
  "declaration" : {
    "code" : "protocol DistributedActorSystem<SerializationRequirement> : Sendable",
    "language" : "swift"
  },
  "id" : "EC9BA494-2D03-450C-8CDA-C0A7F0535A63",
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Distributed",
  "overview" : "## Overview\n\nA [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] is always initialized in association with some concrete actor system. That actor system instance is then used to manage the identity of the actor, as well as handle all remote interactions of the distributed actor.\n\n## Using a DistributedActorSystem library\n\nFrom a library user’s perspective (e.g. someone using a `ClusterSystem` or `SampleWebSocketActorSystem`), the basic use of a distributed actor system is fairly opaque.\n\nAny distributed actor must declare what actor system it is able to operate with. This is done either by a `typealias ActorSystem` in the body of such `distributed actor` declaration, or a module-wide global `typealias DefaultDistributedActorSystem`. Refer to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] documentation to learn more about the tradeoffs of these approaches.\n\nOnce an actor has declared the system it is able to work with, an instance of the system must be provided at initialization time, in order for the system to be able to take over the actor’s identity management.\n\nFor example, a simple distributed actor may look like this:\n\nNotice that every distributed actor initializer must initialize the synthesized [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property]. This property is later used for identity management and other remote interactions of the actor. For more details refer to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] which explains more about declaring distributed actors.\n\nFor more details about how the specific actor system implementation deals with remote message transports and serialization, please refer to the specific system’s documentation.\n\n## Implementing a DistributedActorSystem\n\nThis section is dedicated to distributed actor system library authors, and generally can be skipped over by library users, as it explains the interactions of synthesized code and specific distributed actor system methods and how they must be implemented.\n\nMethods discussed in this section are generally not intended to be called directly, but instead will have calls generated to them from distributed actor declarations in appropriate places (such as initializers, `distributed func` calls, or `distributed` computed properties).\n\n### Assigning and Resigning Actor Identifiers\n\nDuring a local distributed actor’s initialization (i.e. any `init` of a `distributed actor`), the actor system will be invoked in order to assign an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] for this actor.\n\nA call to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/assignID(_:)] is made during the initialization of the distributed actor. The snippet below showcases this, though no guarantees are made at this point about the exact placement of this call.\n\nThe result of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/assignID(_:)] is then directly stored in the synthesized `id` property of the actor.\n\nThe actor system should assign *globally unique* identifiers to types, such that they may be properly resolved from any process in the distributed actor system. The exact shape of the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] is left up to the library to decide. It can be as small as an integer based identifier, or as large as a series of key-value pairs identifying the actor.\n\nThe actor system must retain a mapping from the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] to the specific actor *instance* which it is given in [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/actorReady(_:)] in order to implement the `resolve(id:using:)` method, which is how incoming and outgoing remote calls are made possible.\n\nUsers have no control over this assignment, nor are they allowed to set the `id` property explicitly. The [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] is used to implement the distributed actor’s `Hashable`, `Equatable`, and even `Codable` conformance (which is synthesized if and only if the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] is `Codable` itself).\n\nManually invoking `assignID` and `resignID` is generally not recommended but isn’t strictly a programmer error, and it is up to the actor system to decide how to deal with such calls.\n\nOnce the `distributed actor` deinitializes, a call to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/resignID(_:)] will be made. Generally this is made from the distributed actor’s `deinit`, however in the case of throwing initializers it may also happen during such failed init, in order to release the ID that is no longer used.\n\nAfter an ID is resigned, it technically could be used to identify another instance. For example, an advanced actor system implementation could use such approach to implement actors which are created “ad-hoc” and always contain the appropriate ID, and if one isn’t allocated yet for such ID, it could *then* create one on demand and make sure it is assigned the required ID.\n\n### Readying Distributed Actors\n\nOnce a `distributed actor` has been *fully initialized* during its initializer, a call to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/actorReady(_:)] is synthesized. This call is made after the actor’s properties (including all user-declared properties) have been initialized, but before other user-defined code in the initializer gets a chance to run.\n\nThe `actorReady(_)` call on the actor system is a signal to the actor system that this actor *instance* is now ready and may be resolved and interacted with via the actor system. Generally, a distributed actor system implementation will *weakly retain* the actors it has readied, because retaining them strongly would mean that they will never be deallocated (and thus never resign their ID’s).\n\nNext, we will discuss the just mentioned `resolve` method, which is closely tied to readying actors.\n\n### Resolving (potentially remote) Distributed Actors\n\nAn important aspect of any distributed actor system is being able to turn a [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] type and [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] into a reference to an actor (instance), regardless where the actor is located. The ID should have enough information stored to be able to make the decision of *where* the actor is located, without having to contact remote nodes. Specifically, the implementation of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/resolve(id:as:)] is *not* `async` and should *not* perform long running or blocking operations in order to return.\n\nThe actor system’s [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/resolve(id:as:)] method is called by the compiler whenever end-users call the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor]‘s [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/resolve(id:using:)] method. The return types of those methods differ, as the actor system’s return type is `Act?` (and it may throw if unable to resolve the `ActorID`).\n\nThe actor system’s `resolve` returning `nil` means that the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] passed to it refers to a *remote* distributed actor. The Swift runtime reacts to this by creating a remote actor reference (sometimes called a “proxy”).\n\n### Handling remote calls\n\nFinally, calls on a *remote* distributed actor reference’s distributed methods are turned into invocations of `remoteCall(on:target:invocation:returning:throwing:)` (or `remoteCallVoid(on:target:invocation:throwing:)` for Void returning methods).\n\nImplementing the remote calls correctly and efficiently is the important task for a distributed actor system library.\n\nImplementations of remote calls generally will serialize `actor.id`, `target` and `invocation` into some form of wire envelope, and send it over the network (or process boundary) using some transport mechanism of their choice. As they do so, they need to suspend the `remoteCall` function, and resume it once a reply to the call arrives. Unless the transport layer is also async\/await aware, this will often require making use of a `CheckedContinuation`.\n\nWhile implementing remote calls please keep in mind any potential failure scenarios that may occur, such as message loss, connection failures and similar issues. Such situations should all be surfaced by resuming the `remoteCall` by throwing an error conforming to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystemError].\n\nWhile it is not *required* to conform error thrown out of these methods to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystemError], the general guideline about conforming errors to this protocol is that errors which are outside of the user’s control, but are thrown because transport or actor system issues, should conform to it. This is to simplify separating “business logic errors” from transport errors.\n\n### Further reading\n\nFor an even more in-depth explanation about the inner workings of a distributed actor system, you can refer to the following Swift Evolution proposals:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\ncrawled: 2025-12-03T07:56:32Z\n---\n\n# DistributedActorSystem\n\n**Protocol**\n\nA distributed actor system underpins and implements all functionality of distributed actors.\n\n## Declaration\n\n```swift\nprotocol DistributedActorSystem<SerializationRequirement> : Sendable\n```\n\n## Overview\n\nA [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] is always initialized in association with some concrete actor system. That actor system instance is then used to manage the identity of the actor, as well as handle all remote interactions of the distributed actor.\n\n## Using a DistributedActorSystem library\n\nFrom a library user’s perspective (e.g. someone using a `ClusterSystem` or `SampleWebSocketActorSystem`), the basic use of a distributed actor system is fairly opaque.\n\nAny distributed actor must declare what actor system it is able to operate with. This is done either by a `typealias ActorSystem` in the body of such `distributed actor` declaration, or a module-wide global `typealias DefaultDistributedActorSystem`. Refer to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] documentation to learn more about the tradeoffs of these approaches.\n\nOnce an actor has declared the system it is able to work with, an instance of the system must be provided at initialization time, in order for the system to be able to take over the actor’s identity management.\n\nFor example, a simple distributed actor may look like this:\n\n```swift\ndistributed actor Greeter {\n  init(name: String, actorSystem: ActorSystem) {\n    self.name = name\n    self.actorSystem = actorSystem \/\/ required (!) initialization of implicit actorSystem property\n  }\n}\n```\n\nNotice that every distributed actor initializer must initialize the synthesized [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property]. This property is later used for identity management and other remote interactions of the actor. For more details refer to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] which explains more about declaring distributed actors.\n\nFor more details about how the specific actor system implementation deals with remote message transports and serialization, please refer to the specific system’s documentation.\n\n\n\n## Implementing a DistributedActorSystem\n\nThis section is dedicated to distributed actor system library authors, and generally can be skipped over by library users, as it explains the interactions of synthesized code and specific distributed actor system methods and how they must be implemented.\n\nMethods discussed in this section are generally not intended to be called directly, but instead will have calls generated to them from distributed actor declarations in appropriate places (such as initializers, `distributed func` calls, or `distributed` computed properties).\n\n### Assigning and Resigning Actor Identifiers\n\nDuring a local distributed actor’s initialization (i.e. any `init` of a `distributed actor`), the actor system will be invoked in order to assign an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] for this actor.\n\nA call to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/assignID(_:)] is made during the initialization of the distributed actor. The snippet below showcases this, though no guarantees are made at this point about the exact placement of this call.\n\n```swift\ndistributed actor ShowcaseIDInit {\n  \/\/ let actorSystem: ActorSystem \/\/ synthesized;\n\n  \/\/ typealias ID = ActorSystem.ActorID\n  \/\/ let id: ID \/\/ synthesized; implements `Identifiable.id` requirement\n\n  init(actorSystem: ActorSystem) {\n    self.actorSystem = actorSystem\n    \/\/ ...\n    \/\/ self.id = actorSystem.assignID(Self.self) \/\/ synthesized;\n    \/\/ ...\n  }\n}\n```\n\nThe result of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/assignID(_:)] is then directly stored in the synthesized `id` property of the actor.\n\nThe actor system should assign *globally unique* identifiers to types, such that they may be properly resolved from any process in the distributed actor system. The exact shape of the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] is left up to the library to decide. It can be as small as an integer based identifier, or as large as a series of key-value pairs identifying the actor.\n\nThe actor system must retain a mapping from the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] to the specific actor *instance* which it is given in [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/actorReady(_:)] in order to implement the `resolve(id:using:)` method, which is how incoming and outgoing remote calls are made possible.\n\nUsers have no control over this assignment, nor are they allowed to set the `id` property explicitly. The [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] is used to implement the distributed actor’s `Hashable`, `Equatable`, and even `Codable` conformance (which is synthesized if and only if the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] is `Codable` itself).\n\n\n\nManually invoking `assignID` and `resignID` is generally not recommended but isn’t strictly a programmer error, and it is up to the actor system to decide how to deal with such calls.\n\nOnce the `distributed actor` deinitializes, a call to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/resignID(_:)] will be made. Generally this is made from the distributed actor’s `deinit`, however in the case of throwing initializers it may also happen during such failed init, in order to release the ID that is no longer used.\n\n```swift\n\/\/ Synthesized inside a distributed actor's deinit:\ndeinit {\n  \/\/ actorSystem.resignID(self.id)\n}\n```\n\nAfter an ID is resigned, it technically could be used to identify another instance. For example, an advanced actor system implementation could use such approach to implement actors which are created “ad-hoc” and always contain the appropriate ID, and if one isn’t allocated yet for such ID, it could *then* create one on demand and make sure it is assigned the required ID.\n\n### Readying Distributed Actors\n\nOnce a `distributed actor` has been *fully initialized* during its initializer, a call to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/actorReady(_:)] is synthesized. This call is made after the actor’s properties (including all user-declared properties) have been initialized, but before other user-defined code in the initializer gets a chance to run.\n\n\n\nThe `actorReady(_)` call on the actor system is a signal to the actor system that this actor *instance* is now ready and may be resolved and interacted with via the actor system. Generally, a distributed actor system implementation will *weakly retain* the actors it has readied, because retaining them strongly would mean that they will never be deallocated (and thus never resign their ID’s).\n\n\n\nNext, we will discuss the just mentioned `resolve` method, which is closely tied to readying actors.\n\n### Resolving (potentially remote) Distributed Actors\n\nAn important aspect of any distributed actor system is being able to turn a [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] type and [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] into a reference to an actor (instance), regardless where the actor is located. The ID should have enough information stored to be able to make the decision of *where* the actor is located, without having to contact remote nodes. Specifically, the implementation of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/resolve(id:as:)] is *not* `async` and should *not* perform long running or blocking operations in order to return.\n\n\n\nThe actor system’s [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/resolve(id:as:)] method is called by the compiler whenever end-users call the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor]‘s [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/resolve(id:using:)] method. The return types of those methods differ, as the actor system’s return type is `Act?` (and it may throw if unable to resolve the `ActorID`).\n\nThe actor system’s `resolve` returning `nil` means that the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] passed to it refers to a *remote* distributed actor. The Swift runtime reacts to this by creating a remote actor reference (sometimes called a “proxy”).\n\n### Handling remote calls\n\nFinally, calls on a *remote* distributed actor reference’s distributed methods are turned into invocations of `remoteCall(on:target:invocation:returning:throwing:)` (or `remoteCallVoid(on:target:invocation:throwing:)` for Void returning methods).\n\nImplementing the remote calls correctly and efficiently is the important task for a distributed actor system library.\n\nImplementations of remote calls generally will serialize `actor.id`, `target` and `invocation` into some form of wire envelope, and send it over the network (or process boundary) using some transport mechanism of their choice. As they do so, they need to suspend the `remoteCall` function, and resume it once a reply to the call arrives. Unless the transport layer is also async\/await aware, this will often require making use of a `CheckedContinuation`.\n\nWhile implementing remote calls please keep in mind any potential failure scenarios that may occur, such as message loss, connection failures and similar issues. Such situations should all be surfaced by resuming the `remoteCall` by throwing an error conforming to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystemError].\n\nWhile it is not *required* to conform error thrown out of these methods to [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystemError], the general guideline about conforming errors to this protocol is that errors which are outside of the user’s control, but are thrown because transport or actor system issues, should conform to it. This is to simplify separating “business logic errors” from transport errors.\n\n### Further reading\n\nFor an even more in-depth explanation about the inner workings of a distributed actor system, you can refer to the following Swift Evolution proposals:\n\n- [https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0336-distributed-actor-isolation.md]\n- [https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0344-distributed-actor-runtime.md]\n\n## Associated Types\n\n- **ActorID**: The type ID that will be assigned to any distributed actor managed by this actor system.\n- **InvocationDecoder**: Type of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedTargetInvocationDecoder] that should be used when decoding invocations during [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/executeDistributedTarget(on:target:invocationDecoder:handler:)] calls.\n- **InvocationEncoder**: Type of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedTargetInvocationEncoder] that should be used when the Swift runtime needs to encode a distributed target call into an encoder, before passing it off to `remoteCall(...)`.\n- **ResultHandler**: The type of the result handler which will be offered the results returned by a distributed function invocation called via [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/executeDistributedTarget(on:target:invocationDecoder:handler:)].\n- **SerializationRequirement**: The serialization requirement that will be applied to all distributed targets used with this system.\n\n## Instance Methods\n\n- **actorReady(_:)**: Invoked during a distributed actor’s initialization, as soon as it becomes fully initialized.\n- **assignID(_:)**: Assign an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] for the passed actor type.\n- **executeDistributedTarget(on:target:invocationDecoder:handler:)**: Prepare and execute a call to the distributed function identified by the passed arguments, on the passed `actor`, and collect its results using the `ResultHandler`.\n- **invokeHandlerOnReturn(handler:resultBuffer:metatype:)**: Implementation synthesized by the compiler. Not intended to be invoked explicitly from user code!\n- **makeInvocationEncoder()**: Invoked by the Swift runtime when a distributed remote call is about to be made.\n- **remoteCall(on:target:invocation:throwing:returning:)**: Invoked by the Swift runtime when making a remote call.\n- **remoteCallVoid(on:target:invocation:throwing:)**: Invoked by the Swift runtime when making a remote call.\n- **resignID(_:)**: Called during when a distributed actor is deinitialized, or fails to initialize completely (e.g. by throwing out of an `init` that did not completely initialize all of the actors stored properties yet).\n- **resolve(id:as:)**: Resolves a local or remote [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] to a reference to given actor, or throws if unable to.\n\n## Distributed Actors\n\n- **DistributedActor**: Common protocol to which all distributed actors conform implicitly.\n- **Resolvable()**: Enables the attached to protocol to be resolved as remote distributed actor reference.\n- **buildDefaultDistributedRemoteActorExecutor(_:)**: Obtain the unowned `SerialExecutor` that is used by by remote distributed actor references. The executor is shared between all remote default executor remote distributed actors, and it will crash if any job is enqueued on it.\n\n## Inherits From\n\n- Sendable\n- SendableMetatype\n\n## Conforming Types\n\n- LocalTestingDistributedActorSystem\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The type ID that will be assigned to any distributed actor managed by this actor system.",
          "name" : "ActorID",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/ActorID"
        },
        {
          "description" : "Type of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedTargetInvocationDecoder] that should be used when decoding invocations during [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/executeDistributedTarget(on:target:invocationDecoder:handler:)] calls.",
          "name" : "InvocationDecoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/InvocationDecoder"
        },
        {
          "description" : "Type of [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedTargetInvocationEncoder] that should be used when the Swift runtime needs to encode a distributed target call into an encoder, before passing it off to `remoteCall(...)`.",
          "name" : "InvocationEncoder",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/InvocationEncoder"
        },
        {
          "description" : "The type of the result handler which will be offered the results returned by a distributed function invocation called via [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/executeDistributedTarget(on:target:invocationDecoder:handler:)].",
          "name" : "ResultHandler",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/ResultHandler"
        },
        {
          "description" : "The serialization requirement that will be applied to all distributed targets used with this system.",
          "name" : "SerializationRequirement",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/SerializationRequirement"
        }
      ],
      "title" : "Associated Types"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Invoked during a distributed actor’s initialization, as soon as it becomes fully initialized.",
          "name" : "actorReady(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/actorReady(_:)"
        },
        {
          "description" : "Assign an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] for the passed actor type.",
          "name" : "assignID(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/assignID(_:)"
        },
        {
          "description" : "Prepare and execute a call to the distributed function identified by the passed arguments, on the passed `actor`, and collect its results using the `ResultHandler`.",
          "name" : "executeDistributedTarget(on:target:invocationDecoder:handler:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/executeDistributedTarget(on:target:invocationDecoder:handler:)"
        },
        {
          "description" : "Implementation synthesized by the compiler. Not intended to be invoked explicitly from user code!",
          "name" : "invokeHandlerOnReturn(handler:resultBuffer:metatype:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/invokeHandlerOnReturn(handler:resultBuffer:metatype:)"
        },
        {
          "description" : "Invoked by the Swift runtime when a distributed remote call is about to be made.",
          "name" : "makeInvocationEncoder()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/makeInvocationEncoder()"
        },
        {
          "description" : "Invoked by the Swift runtime when making a remote call.",
          "name" : "remoteCall(on:target:invocation:throwing:returning:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/remoteCall(on:target:invocation:throwing:returning:)"
        },
        {
          "description" : "Invoked by the Swift runtime when making a remote call.",
          "name" : "remoteCallVoid(on:target:invocation:throwing:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/remoteCallVoid(on:target:invocation:throwing:)"
        },
        {
          "description" : "Called during when a distributed actor is deinitialized, or fails to initialize completely (e.g. by throwing out of an `init` that did not completely initialize all of the actors stored properties yet).",
          "name" : "resignID(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/resignID(_:)"
        },
        {
          "description" : "Resolves a local or remote [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] to a reference to given actor, or throws if unable to.",
          "name" : "resolve(id:as:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem\/resolve(id:as:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Common protocol to which all distributed actors conform implicitly.",
          "name" : "DistributedActor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor"
        },
        {
          "description" : "Enables the attached to protocol to be resolved as remote distributed actor reference.",
          "name" : "Resolvable()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/Resolvable()"
        },
        {
          "description" : "Obtain the unowned `SerialExecutor` that is used by by remote distributed actor references. The executor is shared between all remote default executor remote distributed actors, and it will crash if any job is enqueued on it.",
          "name" : "buildDefaultDistributedRemoteActorExecutor(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/buildDefaultDistributedRemoteActorExecutor(_:)"
        }
      ],
      "title" : "Distributed Actors"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "Sendable"
        },
        {
          "name" : "SendableMetatype"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "DistributedActorSystem",
  "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem"
}