{
  "abstract" : "Common protocol to which all distributed actors conform implicitly.",
  "codeExamples" : [
    {
      "code" : "distributed actor Greeter {\n  typealias ActorSystem = GreetingSystem \/\/ which conforms to DistributedActorSystem\n\n  func greet() -> String { \"Hello!\" }\n}",
      "language" : "swift"
    },
    {
      "code" : "import Distributed\nimport AmazingActorSystemLibrary\n\ntypealias DefaultDistributedActorSystem = AmazingActorSystem\n\ndistributed actor Greeter {} \/\/ ActorSystem == AmazingActorSystem",
      "language" : "swift"
    },
    {
      "code" : "typealias DefaultDistributedActorSystem = AmazingActorSystem\n\ndistributed actor Amazing {\n  \/\/ ActorSystem == AmazingActorSystem\n}\n\ndistributed actor Superb {\n  typealias ActorSystem = SuperbActorSystem\n}",
      "language" : "swift"
    },
    {
      "code" : "init(name: String, actorSystem: Self.ActorSystem) {\n  self.name = name\n  self.actorSystem = actorSystem\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ BAD\ninit(name: String, actorSystem: Self.ActorSystem) {\n  self.name = name\n  \/\/ BAD, will cause compile-time error; the `actorSystem` was not initialized.\n}",
      "language" : "swift"
    },
    {
      "code" : "decoder.userInfo[.actorSystemKey] as? ActorSystem\n\nThe such obtained actor system is then used to ``resolve(id:using:)`` the decoded ``ID``.\n\nUse the ``CodingUserInfoKey\/actorSystemKey`` to provide the necessary\nactor system for the decoding initializer when decoding a distributed actor.\n\n- SeeAlso: ``DistributedActorSystem``\n- SeeAlso: ``Actor``\n- SeeAlso: ``AnyActor``",
      "language" : "swift"
    }
  ],
  "contentHash" : "18a2370f4db67fe816b5d23b94640c2843e51aca9d699c2a252f85030a604905",
  "crawledAt" : "2025-12-04T14:26:25Z",
  "declaration" : {
    "code" : "protocol DistributedActor : AnyObject, Hashable, Identifiable, Sendable",
    "language" : "swift"
  },
  "id" : "2E0CAF19-A30E-4A71-877A-BDD8477903E9",
  "kind" : "protocol",
  "language" : "swift",
  "module" : "Distributed",
  "overview" : "## Overview\n\nThe `DistributedActor` protocol generalizes over all distributed actor types. Distributed actor types implicitly conform to this protocol.\n\nIt is not possible to conform to this protocol by any other declaration other than a `distributed actor`.\n\nIt is possible to require a type to conform to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] protocol by refining it with another protocol, or by using a generic constraint.\n\n## Synthesized properties\n\nFor every concrete distributed actor declaration, the compiler synthesizes two properties: `actorSystem` and `id`. They witness the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property] and [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] protocol requirements of the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] protocol.\n\nIt is not possible to implement these properties explicitly in user code. These properties are `nonisolated` and accessible even if the instance is *remote*, because *all* distributed actor references must store the actor system remote calls will be delivered through, as well as the id identifying the target of those calls.\n\n## The ActorSystem associated type\n\nEvery distributed actor must declare what type of actor system it is part of by implementing the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] associated type requirement.\n\nThis causes a number of other properties of the actor to be inferred:\n\nA distributed actor must declare what type of actor system it is ready to work with by fulfilling the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] type member requirement:\n\n### The DefaultDistributedActorSystem type alias\n\nSince it is fairly common to only be using one specific type of actor system within a module or entire codebase, it is possible to declare the default type of actor system all distributed actors will be using in a module by declaring a `DefaultDistributedActorSystem` module wide typealias:\n\nThis declaration makes all `distributed actor` declarations that do not explicitly specify an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] type alias to assume the `AmazingActorSystem` as their `ActorSystem`.\n\nIt is possible for a specific actor to override the system it is using, by declaring an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] type alias as usual:\n\nIn general the `DefaultDistributedActorSystem` should not be declared public, as picking the default should be left up to each specific module of a project.\n\n## Default initializer\n\nWhile classes and actors receive a synthesized *argument-free default initializer* (`init()`), distributed actors synthesize a default initializer that accepts a distributed actor system the actor is part of: `init(actorSystem:)`.\n\nThe accepted actor system must be of the `Self.ActorSystem` type, which must conform to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem] protocol. This is required because distributed actors are always managed by a concrete distributed actor system and cannot exist on their own without one.\n\nIt is possible to explicitly declare a parameter-free initializer (`init()`), however the `actorSystem` property still must be assigned a concrete actor system instance the actor shall be part of.\n\nIn general it is recommended to always have an `actorSystem` parameter as the last non-defaulted non-closure parameter in every actor’s initializer parameter list. This way it is simple to swap in a “test actor system” instance in unit tests, and avoid relying on global state which could make testing more difficult.\n\n## Implicit properties\n\nEvery concrete `distributed actor` type receives two synthesized properties, which implement the protocol requirements of this protocol: `id` and `actorSystem`.\n\n### Property: Actor System\n\nThe [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property] property is an important part of every distributed actor’s lifecycle management.\n\nBoth initialization as well as de-initialization require interactions with the actor system, and it is the actor system that handles all remote interactions of an actor, by both sending or receiving remote calls made on the actor.\n\nThe [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property] property must be assigned in every designated initializer of a distributed actor explicitly. It is highly recommended to make it a parameter of every distributed actor initializer, and simply forward the value to the stored property, like this:\n\nForgetting to initialize the actor system, will result in a compile time error:\n\n### Property: Distributed Actor Identity\n\n[doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] is assigned by the actor system during the distributed actor’s initialization, and cannot be set or mutated by the actor itself.\n\n[doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] is the effective identity of the actor, and is used in equality checks, as well as the actor’s synthesized `Codable` conformance if the `ID` type conforms to `Codable`.\n\n## Automatic Conformances\n\n### Hashable and Identifiable conformance\n\nEvery distributed actor conforms to the `Hashable` and `Identifiable` protocols. Its identity is strictly driven by its [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id], and therefore hash and equality implementations directly delegate to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] property.\n\nComparing a local distributed actor instance and a remote reference to it (both using the same [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id]) always returns true, as they both conceptually point at the same distributed actor.\n\nIt is not possible to implement these protocols relying on the actual actor’s state, because it may be remote and the state may not be available. In other words, since these protocols must be implemented using `nonisolated` functions, only `nonisolated` `id` and `actorSystem` properties are accessible for their implementations.\n\n### Implicit Codable conformance\n\nIf created with an actor system whose [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] is `Codable`, the compiler will synthesize code for the concrete distributed actor to conform to `Codable` as well.\n\nThis is necessary to support distributed calls where the `SerializationRequirement` is `Codable` and thus users may want to pass actors as arguments to remote calls.\n\nThe synthesized implementations use a single `SingleValueEncodingContainer` to encode\/decode the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] property of the actor. The `Decoder` required `Decoder\/init(from:)` is implemented by retrieving an actor system from the decoders’ `userInfo`, effectively like as follows:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/distributed\/distributedactor\ncrawled: 2025-12-04T14:26:25Z\n---\n\n# DistributedActor\n\n**Protocol**\n\nCommon protocol to which all distributed actors conform implicitly.\n\n## Declaration\n\n```swift\nprotocol DistributedActor : AnyObject, Hashable, Identifiable, Sendable\n```\n\n## Overview\n\nThe `DistributedActor` protocol generalizes over all distributed actor types. Distributed actor types implicitly conform to this protocol.\n\nIt is not possible to conform to this protocol by any other declaration other than a `distributed actor`.\n\nIt is possible to require a type to conform to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] protocol by refining it with another protocol, or by using a generic constraint.\n\n## Synthesized properties\n\nFor every concrete distributed actor declaration, the compiler synthesizes two properties: `actorSystem` and `id`. They witness the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property] and [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] protocol requirements of the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor] protocol.\n\nIt is not possible to implement these properties explicitly in user code. These properties are `nonisolated` and accessible even if the instance is *remote*, because *all* distributed actor references must store the actor system remote calls will be delivered through, as well as the id identifying the target of those calls.\n\n## The ActorSystem associated type\n\nEvery distributed actor must declare what type of actor system it is part of by implementing the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] associated type requirement.\n\nThis causes a number of other properties of the actor to be inferred:\n\n- the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/SerializationRequirement] that will be used at compile time to verify `distributed` target declarations are well formed,\n- if the distributed actor is `Codable`, based on the `ID` being Codable or not,\n- the type of the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] accepted in the synthesized default initializer.\n\nA distributed actor must declare what type of actor system it is ready to work with by fulfilling the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] type member requirement:\n\n```swift\ndistributed actor Greeter {\n  typealias ActorSystem = GreetingSystem \/\/ which conforms to DistributedActorSystem\n\n  func greet() -> String { \"Hello!\" }\n}\n```\n\n### The DefaultDistributedActorSystem type alias\n\nSince it is fairly common to only be using one specific type of actor system within a module or entire codebase, it is possible to declare the default type of actor system all distributed actors will be using in a module by declaring a `DefaultDistributedActorSystem` module wide typealias:\n\n```swift\nimport Distributed\nimport AmazingActorSystemLibrary\n\ntypealias DefaultDistributedActorSystem = AmazingActorSystem\n\ndistributed actor Greeter {} \/\/ ActorSystem == AmazingActorSystem\n```\n\nThis declaration makes all `distributed actor` declarations that do not explicitly specify an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] type alias to assume the `AmazingActorSystem` as their `ActorSystem`.\n\nIt is possible for a specific actor to override the system it is using, by declaring an [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype] type alias as usual:\n\n```swift\ntypealias DefaultDistributedActorSystem = AmazingActorSystem\n\ndistributed actor Amazing {\n  \/\/ ActorSystem == AmazingActorSystem\n}\n\ndistributed actor Superb {\n  typealias ActorSystem = SuperbActorSystem\n}\n```\n\nIn general the `DefaultDistributedActorSystem` should not be declared public, as picking the default should be left up to each specific module of a project.\n\n## Default initializer\n\nWhile classes and actors receive a synthesized *argument-free default initializer* (`init()`), distributed actors synthesize a default initializer that accepts a distributed actor system the actor is part of: `init(actorSystem:)`.\n\nThe accepted actor system must be of the `Self.ActorSystem` type, which must conform to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem] protocol. This is required because distributed actors are always managed by a concrete distributed actor system and cannot exist on their own without one.\n\nIt is possible to explicitly declare a parameter-free initializer (`init()`), however the `actorSystem` property still must be assigned a concrete actor system instance the actor shall be part of.\n\nIn general it is recommended to always have an `actorSystem` parameter as the last non-defaulted non-closure parameter in every actor’s initializer parameter list. This way it is simple to swap in a “test actor system” instance in unit tests, and avoid relying on global state which could make testing more difficult.\n\n## Implicit properties\n\nEvery concrete `distributed actor` type receives two synthesized properties, which implement the protocol requirements of this protocol: `id` and `actorSystem`.\n\n### Property: Actor System\n\nThe [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property] property is an important part of every distributed actor’s lifecycle management.\n\nBoth initialization as well as de-initialization require interactions with the actor system, and it is the actor system that handles all remote interactions of an actor, by both sending or receiving remote calls made on the actor.\n\nThe [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property] property must be assigned in every designated initializer of a distributed actor explicitly. It is highly recommended to make it a parameter of every distributed actor initializer, and simply forward the value to the stored property, like this:\n\n```swift\ninit(name: String, actorSystem: Self.ActorSystem) {\n  self.name = name\n  self.actorSystem = actorSystem\n}\n```\n\nForgetting to initialize the actor system, will result in a compile time error:\n\n```swift\n\/\/ BAD\ninit(name: String, actorSystem: Self.ActorSystem) {\n  self.name = name\n  \/\/ BAD, will cause compile-time error; the `actorSystem` was not initialized.\n}\n```\n\n### Property: Distributed Actor Identity\n\n[doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] is assigned by the actor system during the distributed actor’s initialization, and cannot be set or mutated by the actor itself.\n\n[doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] is the effective identity of the actor, and is used in equality checks, as well as the actor’s synthesized `Codable` conformance if the `ID` type conforms to `Codable`.\n\n## Automatic Conformances\n\n### Hashable and Identifiable conformance\n\nEvery distributed actor conforms to the `Hashable` and `Identifiable` protocols. Its identity is strictly driven by its [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id], and therefore hash and equality implementations directly delegate to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] property.\n\nComparing a local distributed actor instance and a remote reference to it (both using the same [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id]) always returns true, as they both conceptually point at the same distributed actor.\n\nIt is not possible to implement these protocols relying on the actual actor’s state, because it may be remote and the state may not be available. In other words, since these protocols must be implemented using `nonisolated` functions, only `nonisolated` `id` and `actorSystem` properties are accessible for their implementations.\n\n### Implicit Codable conformance\n\nIf created with an actor system whose [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem\/ActorID] is `Codable`, the compiler will synthesize code for the concrete distributed actor to conform to `Codable` as well.\n\nThis is necessary to support distributed calls where the `SerializationRequirement` is `Codable` and thus users may want to pass actors as arguments to remote calls.\n\nThe synthesized implementations use a single `SingleValueEncodingContainer` to encode\/decode the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id] property of the actor. The `Decoder` required `Decoder\/init(from:)` is implemented by retrieving an actor system from the decoders’ `userInfo`, effectively like as follows:\n\n```swift\ndecoder.userInfo[.actorSystemKey] as? ActorSystem\n\nThe such obtained actor system is then used to ``resolve(id:using:)`` the decoded ``ID``.\n\nUse the ``CodingUserInfoKey\/actorSystemKey`` to provide the necessary\nactor system for the decoding initializer when decoding a distributed actor.\n\n- SeeAlso: ``DistributedActorSystem``\n- SeeAlso: ``Actor``\n- SeeAlso: ``AnyActor``\n```\n\n## Associated Types\n\n- **ActorSystem**: The type of transport used to communicate with actors of this type.\n- **SerializationRequirement**: The serialization requirement to apply to all distributed declarations inside the actor.\n\n## Initializers\n\n- **init(from:)**: Initializes an instance of this distributed actor by decoding its [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id], and passing it to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem] obtained from `decoder.userInfo[actorSystemKey]`.\n\n## Instance Properties\n\n- **actorSystem**: The [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem] that is managing this distributed actor.\n- **asLocalActor**: Produces an erased `any Actor` reference to this known to be local distributed actor.\n- **id**: Logical identity of this distributed actor.\n- **unownedExecutor**: Retrieve the executor for this distributed actor as an optimized, unowned reference. This API is equivalent to `Actor\/unownedExecutor`, however, by default, it intentionally returns `nil` if this actor is a reference to a remote distributed actor, because the executor for remote references is effectively never g\n\n## Instance Methods\n\n- **assertIsolated(_:file:line:)**: Stops program execution if the current task is not executing on this actor’s serial executor.\n- **assumeIsolated(_:file:line:)**: Assume that the current task is executing on this (local) distributed actor’s serial executor, or stop program execution otherwise.\n- **encode(to:)**: Encodes the `actor.id` as a single value into the passed `encoder`.\n- **preconditionIsolated(_:file:line:)**: Stops program execution if the current task is not executing on this actor’s serial executor.\n- **whenLocal(_:)**: Executes the passed ‘body’ only when the distributed actor is local instance.\n\n## Type Methods\n\n- **resolve(id:using:)**: Resolves the passed in `id` against the `system`, returning either a local or remote actor reference.\n\n## Distributed Actors\n\n- **DistributedActorSystem**: A distributed actor system underpins and implements all functionality of distributed actors.\n- **Resolvable()**: Enables the attached to protocol to be resolved as remote distributed actor reference.\n- **buildDefaultDistributedRemoteActorExecutor(_:)**: Obtain the unowned `SerialExecutor` that is used by by remote distributed actor references. The executor is shared between all remote default executor remote distributed actors, and it will crash if any job is enqueued on it.\n\n## Inherits From\n\n- Equatable\n- Hashable\n- Identifiable\n- Sendable\n- SendableMetatype\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The type of transport used to communicate with actors of this type.",
          "name" : "ActorSystem",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/ActorSystem-swift.associatedtype"
        },
        {
          "description" : "The serialization requirement to apply to all distributed declarations inside the actor.",
          "name" : "SerializationRequirement",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/SerializationRequirement"
        }
      ],
      "title" : "Associated Types"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Initializes an instance of this distributed actor by decoding its [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActor\/id], and passing it to the [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem] obtained from `decoder.userInfo[actorSystemKey]`.",
          "name" : "init(from:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/init(from:)"
        }
      ],
      "title" : "Initializers"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The [doc:\/\/com.apple.Swift\/documentation\/Distributed\/DistributedActorSystem] that is managing this distributed actor.",
          "name" : "actorSystem",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/actorSystem-swift.property"
        },
        {
          "description" : "Produces an erased `any Actor` reference to this known to be local distributed actor.",
          "name" : "asLocalActor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/asLocalActor"
        },
        {
          "description" : "Logical identity of this distributed actor.",
          "name" : "id",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/id"
        },
        {
          "description" : "Retrieve the executor for this distributed actor as an optimized, unowned reference. This API is equivalent to `Actor\/unownedExecutor`, however, by default, it intentionally returns `nil` if this actor is a reference to a remote distributed actor, because the executor for remote references is effectively never g",
          "name" : "unownedExecutor",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/unownedExecutor"
        }
      ],
      "title" : "Instance Properties"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Stops program execution if the current task is not executing on this actor’s serial executor.",
          "name" : "assertIsolated(_:file:line:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/assertIsolated(_:file:line:)"
        },
        {
          "description" : "Assume that the current task is executing on this (local) distributed actor’s serial executor, or stop program execution otherwise.",
          "name" : "assumeIsolated(_:file:line:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/assumeIsolated(_:file:line:)"
        },
        {
          "description" : "Encodes the `actor.id` as a single value into the passed `encoder`.",
          "name" : "encode(to:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/encode(to:)"
        },
        {
          "description" : "Stops program execution if the current task is not executing on this actor’s serial executor.",
          "name" : "preconditionIsolated(_:file:line:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/preconditionIsolated(_:file:line:)"
        },
        {
          "description" : "Executes the passed ‘body’ only when the distributed actor is local instance.",
          "name" : "whenLocal(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/whenLocal(_:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Resolves the passed in `id` against the `system`, returning either a local or remote actor reference.",
          "name" : "resolve(id:using:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActor\/resolve(id:using:)"
        }
      ],
      "title" : "Type Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A distributed actor system underpins and implements all functionality of distributed actors.",
          "name" : "DistributedActorSystem",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/DistributedActorSystem"
        },
        {
          "description" : "Enables the attached to protocol to be resolved as remote distributed actor reference.",
          "name" : "Resolvable()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/Resolvable()"
        },
        {
          "description" : "Obtain the unowned `SerialExecutor` that is used by by remote distributed actor references. The executor is shared between all remote default executor remote distributed actors, and it will crash if any job is enqueued on it.",
          "name" : "buildDefaultDistributedRemoteActorExecutor(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/Distributed\/buildDefaultDistributedRemoteActorExecutor(_:)"
        }
      ],
      "title" : "Distributed Actors"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "Equatable"
        },
        {
          "name" : "Hashable"
        },
        {
          "name" : "Identifiable"
        },
        {
          "name" : "Sendable"
        },
        {
          "name" : "SendableMetatype"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "DistributedActor",
  "url" : "https:\/\/developer.apple.com\/documentation\/distributed\/distributedactor"
}