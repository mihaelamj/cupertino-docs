{
  "abstract" : "Sets the delegate that will accept captured buffers and the dispatch queue on which the delegate will be called.",
  "codeExamples" : [

  ],
  "contentHash" : "c7aa065a9a287748ac2d4740e40bfdfe0186c34c4bc55ad4a6107da8e161e586",
  "crawledAt" : "2025-11-30T21:43:02Z",
  "declaration" : {
    "code" : "func setSampleBufferDelegate(_ sampleBufferDelegate: (any AVCaptureAudioDataOutputSampleBufferDelegate)?, queue sampleBufferCallbackQueue: dispatch_queue_t?)",
    "language" : "swift"
  },
  "id" : "884B34B7-BE3F-4E02-93BD-FD82BBBC4504",
  "kind" : "method",
  "module" : "AVFoundation",
  "overview" : "## Discussion\n\nWhen a new audio sample buffer is captured it is vended to the sample buffer delegate using the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureAudioDataOutputSampleBufferDelegate\/captureOutput(_:didOutput:from:)] delegate method. All delegate methods are called on the specified dispatch queue.\n\nIf the queue is blocked when new samples are captured, those samples will be automatically dropped when they become sufficiently late. This allows you to process existing samples on the same queue without having to manage the potential memory usage increases that would otherwise occur when that processing is unable to keep up with the rate of incoming samples.\n\nIf you need to minimize the chances of samples being dropped, you should specify a queue on which a sufficiently small amount of processing is being done outside of receiving sample buffers. When migrating extra processing to another queue, you are responsible for ensuring that memory usage does not grow without bound from samples that have not been processed.\n\n### Special considerations\n\nThis method uses [doc:\/\/com.apple.documentation\/documentation\/dispatch\/1496306-dispatch_retain] and [doc:\/\/com.apple.documentation\/documentation\/dispatch\/1496328-dispatch_release] to manage the queue.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureAudioDataOutput\/setSampleBufferDelegate(_:queue:)\ncrawled: 2025-11-30T21:43:02Z\n---\n\n# setSampleBufferDelegate(_:queue:)\n\n**Instance Method**\n\nSets the delegate that will accept captured buffers and the dispatch queue on which the delegate will be called.\n\n## Declaration\n\n```swift\nfunc setSampleBufferDelegate(_ sampleBufferDelegate: (any AVCaptureAudioDataOutputSampleBufferDelegate)?, queue sampleBufferCallbackQueue: dispatch_queue_t?)\n```\n\n## Parameters\n\n- **sampleBufferDelegate**: An object conforming to the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureAudioDataOutputSampleBufferDelegate] protocol that will receive sample buffers after they are captured.\n- **sampleBufferCallbackQueue**: You must pass a serial dispatch to guarantee that audio samples will be delivered in order.\n\nThe value may not be `NULL`, except when setting the `sampleBufferDelegate` to `nil`.\n\n## Discussion\n\nWhen a new audio sample buffer is captured it is vended to the sample buffer delegate using the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureAudioDataOutputSampleBufferDelegate\/captureOutput(_:didOutput:from:)] delegate method. All delegate methods are called on the specified dispatch queue.\n\nIf the queue is blocked when new samples are captured, those samples will be automatically dropped when they become sufficiently late. This allows you to process existing samples on the same queue without having to manage the potential memory usage increases that would otherwise occur when that processing is unable to keep up with the rate of incoming samples.\n\nIf you need to minimize the chances of samples being dropped, you should specify a queue on which a sufficiently small amount of processing is being done outside of receiving sample buffers. When migrating extra processing to another queue, you are responsible for ensuring that memory usage does not grow without bound from samples that have not been processed.\n\n### Special considerations\n\nThis method uses [doc:\/\/com.apple.documentation\/documentation\/dispatch\/1496306-dispatch_retain] and [doc:\/\/com.apple.documentation\/documentation\/dispatch\/1496328-dispatch_release] to manage the queue.\n\n## Receiving captured audio data\n\n- **sampleBufferDelegate**: The capture object’s delegate.\n- **sampleBufferCallbackQueue**: The queue on which delegate callbacks are invoked\n- **AVCaptureAudioDataOutputSampleBufferDelegate**: Methods for receiving audio sample data from an audio capture.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The capture object’s delegate.",
          "name" : "sampleBufferDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureAudioDataOutput\/sampleBufferDelegate"
        },
        {
          "description" : "The queue on which delegate callbacks are invoked",
          "name" : "sampleBufferCallbackQueue",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureAudioDataOutput\/sampleBufferCallbackQueue"
        },
        {
          "description" : "Methods for receiving audio sample data from an audio capture.",
          "name" : "AVCaptureAudioDataOutputSampleBufferDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureAudioDataOutputSampleBufferDelegate"
        }
      ],
      "title" : "Receiving captured audio data"
    }
  ],
  "source" : "appleJSON",
  "title" : "setSampleBufferDelegate(_:queue:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureAudioDataOutput\/setSampleBufferDelegate(_:queue:)"
}