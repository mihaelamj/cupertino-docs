{
  "abstract" : "Play HTTP Live Streams and persist streams on disk for offline playback using AVFoundation.",
  "codeExamples" : [
    {
      "code" : "override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n    super.prepare(for: segue, sender: sender)\n\n    if segue.identifier == AssetListTableViewController.presentPlayerViewControllerSegueID {\n        guard let cell = sender as? AssetListTableViewCell,\n            let playerViewControler = segue.destination as? AVPlayerViewController else { return }\n\n        \/*\n         Grab a reference for the destinationViewController to use in later delegate callbacks from\n         AssetPlaybackManager.\n         *\/\n        playerViewController = playerViewControler\n\n        \/\/ Load the new Asset to playback into AssetPlaybackManager.\n        AssetPlaybackManager.sharedManager.setAssetForPlayback(cell.asset)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private var asset: Asset? {\n    willSet {\n        \/\/\/ Remove any previous KVO observer.\n        guard let urlAssetObserver = urlAssetObserver else { return }\n        \n        urlAssetObserver.invalidate()\n    }\n    \n    didSet {\n        if let asset {\n            Task {\n                do {\n                    if try await asset.urlAsset.load(.isPlayable) {\n                        playerItem = AVPlayerItem(asset: asset.urlAsset)\n                        player.replaceCurrentItem(with: playerItem)\n                    } else {\n                        \/\/ The asset isn't playable, so reset the player state.\n                        resetPlayer()\n                    }\n                } catch {\n                    logger.error(\"Unable to load `isPlayable` property.\")\n                }\n            }\n        } else {\n            resetPlayer()\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "playerItemObserver = playerItem?.observe(\\AVPlayerItem.status, options: [.new, .initial]) { [weak self] (item, _) in\n    guard let strongSelf = self else { return }\n    \n    if item.status == .readyToPlay {\n        if !strongSelf.readyForPlayback {\n            strongSelf.readyForPlayback = true\n            strongSelf.delegate?.streamPlaybackManager(strongSelf, playerReadyToPlay: strongSelf.player)\n        }\n    } else if item.status == .failed {\n        let error = item.error\n        \n        logger.error(\"Error: \\(String(describing: error?.localizedDescription))\")\n    }",
      "language" : "swift"
    },
    {
      "code" : "func downloadStream(for asset: Asset) async throws {\n\n    \/\/ Get the default media selections for the asset's media selection groups.\n    let preferredMediaSelection = try await asset.urlAsset.load(.preferredMediaSelection)\n\n    \/*\n     Creates and initializes an `AVAssetDownloadTask` using an `AVAssetDownloadConfiguration` to download multiple `AVMediaSelections`\n     on an `AVURLAsset`.\n     The `primaryContentConfiguration` in `AVAssetDownloadConfiguration` requests for a variant with bitrate greater than one of the\n     lower bitrate variants in the asset.\n     *\/\n    let config = AVAssetDownloadConfiguration(asset: asset.urlAsset, title: asset.stream.name)\n    \/\/\/ Primary content configuration setup.\n    let primaryQualifier = AVAssetVariantQualifier(predicate: NSPredicate(format: \"peakBitRate > 265000\"))\n    config.primaryContentConfiguration.variantQualifiers = [primaryQualifier]\n    \n    \/\/\/ Creation of `AVAssetDownloadTask` with the above configured `AVAssetDownloadConfiguration`.\n    let task = assetDownloadURLSession.makeAssetDownloadTask(downloadConfiguration: config)\n\n    \/\/\/ To better track the `AVAssetDownloadTask`, set the `taskDescription` to something unique for the sample.\n    task.taskDescription = asset.stream.name\n\n    activeDownloadsMap[task] = asset\n    \n    \/\/\/ Use `task.progress` value to provide download progress updates in the UI.\n    let progressObservation: NSKeyValueObservation = task.progress.observe(\\.fractionCompleted) { progress, _ in\n        Task { @MainActor in\n            var userInfo = [String: Any]()\n            userInfo[Asset.Keys.name] = asset.stream.name\n            userInfo[Asset.Keys.percentDownloaded] = progress.fractionCompleted\n            NotificationCenter.default.post(name: .AssetDownloadProgress, object: nil, userInfo: userInfo)\n        }\n    }\n    self.progressObservers.append(progressObservation)\n\n    task.resume()\n\n    var userInfo = [String: Any]()\n    userInfo[Asset.Keys.name] = asset.stream.name\n    userInfo[Asset.Keys.downloadState] = Asset.DownloadState.downloading.rawValue\n    userInfo[Asset.Keys.downloadSelectionDisplayName] = await displayNamesForSelectedMediaOptions(preferredMediaSelection)\n\n    NotificationCenter.default.post(name: .AssetDownloadStateChanged, object: nil, userInfo: userInfo)\n}",
      "language" : "swift"
    },
    {
      "code" : "func cancelDownload(for asset: Asset) {\n    var task: AVAssetDownloadTask?\n\n    for (taskKey, assetVal) in activeDownloadsMap where asset == assetVal {\n        task = taskKey\n        break\n    }\n\n    task?.cancel()\n}",
      "language" : "swift"
    },
    {
      "code" : "func deleteAsset(_ asset: Asset) {\n    let userDefaults = UserDefaults.standard\n\n    do {\n        if let localFileLocation = localAssetForStream(withName: asset.stream.name)?.urlAsset.url {\n            try FileManager.default.removeItem(at: localFileLocation)\n\n            userDefaults.removeObject(forKey: asset.stream.name)\n\n            var userInfo = [String: Any]()\n            userInfo[Asset.Keys.name] = asset.stream.name\n            userInfo[Asset.Keys.downloadState] = Asset.DownloadState.notDownloaded.rawValue\n\n            NotificationCenter.default.post(name: .AssetDownloadStateChanged, object: nil,\n                                            userInfo: userInfo)\n        }\n    } catch {\n        logger.error(\"An error occured deleting the file: \\(error)\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var totalDurationWatched: Double {\n    \/\/ Compute total duration watched by iterating through the AccessLog events.\n    var totalDurationWatched = 0.0\n    if accessLog != nil && !accessLog!.events.isEmpty {\n        for event in accessLog!.events where event.durationWatched > 0 {\n                totalDurationWatched += event.durationWatched\n        }\n    }\n    return totalDurationWatched\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "2202a86bfccf28b4cb0fcdbe0685c247f3d54f2e06a5f63fc00642a762a41790",
  "crawledAt" : "2025-12-02T15:48:20Z",
  "id" : "19D6F3B7-E7A2-40F3-B9FB-A7F0FC886B24",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "AVFoundation",
  "overview" : "## Overview\n\nThis sample provides a catalog of HTTP Live Streams (HLS) that you can play by tapping the row in the table corresponding to the stream. To manage the download of a stream, tap the button associated with the stream in the table. Tapping the button causes a transition to a new view controller which provides an interface to initiate a download, cancel an already running download, or delete a downloaded stream from the device.\n\nThe sample creates and initializes an [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVAssetDownloadConfiguration] and creates a [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVAssetDownloadTask] using the download configuration for the download of a stream. The example shows how to set a primary [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVAssetDownloadContentConfiguration] and at least one auxiliary content configuration to be downloaded.\n\n### Configure the sample code project\n\nBuild and run the sample on an actual device or a simulator device running iOS 15 or later.\n\nIf you want to add your own streams to test with this sample, add an entry into the `Streams.plist` file in the Xcode project. There are two important keys you need to provide values for:\n\nIf any of the streams you add aren’t hosted securely, you’ll need to add an Application Transport Security (ATS) exception in the `Info.plist` file in the Xcode project. For more information on ATS and the relevant property list keys see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSAppTransportSecurity]\n\n### Play a stream\n\nTo play an item, tap one of the rows in the table. Tapping the item causes a transition to a new view controller. As part of that transition, the table view creates an `AssetPlaybackManager` and assigns the appropriate asset to it, as shown in the following example:\n\nAssigning an asset to the `AssetPlaybackManager` causes it to create an `AVPlayerItem` for the asset, removing any previous asset in the process:\n\nThe `AssetPlaybackManager` uses KVO to monitor the `AVPlayerItem` object’s `status` and initiates playback when the `status` becomes ready to play:\n\n### Download a stream\n\nWhen the person initiates a download by tapping the button in the corresponding stream’s table view cell, an instance of `AssetPersistenceManager` calls the following function to create an `AVAssetDownloadTask` object with an `AVAssetDownloadConfiguration` to download multiple [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVMediaSelection] for the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVURLAsset] of the stream:\n\n### Cancel an in-progress download\n\nTap the button in the corresponding stream’s table view cell to reveal the accessory view, then tap Cancel to stop downloading the stream. The following function in `AssetPersistenceManager` cancels the download by calling the `URLSessionTask` [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionTask\/cancel()] method.\n\n### Remove a downloaded stream from disk\n\nTap the button in the corresponding stream’s table view cell to reveal the accessory view, then tap Delete to delete the downloaded stream file. The following function in `AssetPersistenceManager` removes a downloaded stream on the device. First the asset URL corresponding to the file on the device is identified, then the `FileManager` [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileManager\/removeItem(at:)] method is called to remove the downloaded stream at the specified URL.\n\n### Measure playback performance\n\nFor example, here’s the code to calculate the total time spent playing the stream, obtained from the `AVPlayerItemAccessLog`:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AVFoundation\/using-avfoundation-to-play-and-persist-http-live-streams\ncrawled: 2025-12-02T15:48:20Z\n---\n\n# Using AVFoundation to play and persist HTTP live streams\n\n**Sample Code**\n\nPlay HTTP Live Streams and persist streams on disk for offline playback using AVFoundation.\n\n## Overview\n\nThis sample provides a catalog of HTTP Live Streams (HLS) that you can play by tapping the row in the table corresponding to the stream. To manage the download of a stream, tap the button associated with the stream in the table. Tapping the button causes a transition to a new view controller which provides an interface to initiate a download, cancel an already running download, or delete a downloaded stream from the device.\n\nThe sample creates and initializes an [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVAssetDownloadConfiguration] and creates a [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVAssetDownloadTask] using the download configuration for the download of a stream. The example shows how to set a primary [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVAssetDownloadContentConfiguration] and at least one auxiliary content configuration to be downloaded.\n\n\n\n### Configure the sample code project\n\nBuild and run the sample on an actual device or a simulator device running iOS 15 or later.\n\nIf you want to add your own streams to test with this sample, add an entry into the `Streams.plist` file in the Xcode project. There are two important keys you need to provide values for:\n\n\n\nIf any of the streams you add aren’t hosted securely, you’ll need to add an Application Transport Security (ATS) exception in the `Info.plist` file in the Xcode project. For more information on ATS and the relevant property list keys see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSAppTransportSecurity]\n\n### Play a stream\n\nTo play an item, tap one of the rows in the table. Tapping the item causes a transition to a new view controller. As part of that transition, the table view creates an `AssetPlaybackManager` and assigns the appropriate asset to it, as shown in the following example:\n\n```swift\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n    super.prepare(for: segue, sender: sender)\n\n    if segue.identifier == AssetListTableViewController.presentPlayerViewControllerSegueID {\n        guard let cell = sender as? AssetListTableViewCell,\n            let playerViewControler = segue.destination as? AVPlayerViewController else { return }\n\n        \/*\n         Grab a reference for the destinationViewController to use in later delegate callbacks from\n         AssetPlaybackManager.\n         *\/\n        playerViewController = playerViewControler\n\n        \/\/ Load the new Asset to playback into AssetPlaybackManager.\n        AssetPlaybackManager.sharedManager.setAssetForPlayback(cell.asset)\n    }\n}\n```\n\nAssigning an asset to the `AssetPlaybackManager` causes it to create an `AVPlayerItem` for the asset, removing any previous asset in the process:\n\n```swift\nprivate var asset: Asset? {\n    willSet {\n        \/\/\/ Remove any previous KVO observer.\n        guard let urlAssetObserver = urlAssetObserver else { return }\n        \n        urlAssetObserver.invalidate()\n    }\n    \n    didSet {\n        if let asset {\n            Task {\n                do {\n                    if try await asset.urlAsset.load(.isPlayable) {\n                        playerItem = AVPlayerItem(asset: asset.urlAsset)\n                        player.replaceCurrentItem(with: playerItem)\n                    } else {\n                        \/\/ The asset isn't playable, so reset the player state.\n                        resetPlayer()\n                    }\n                } catch {\n                    logger.error(\"Unable to load `isPlayable` property.\")\n                }\n            }\n        } else {\n            resetPlayer()\n        }\n    }\n}\n```\n\nThe `AssetPlaybackManager` uses KVO to monitor the `AVPlayerItem` object’s `status` and initiates playback when the `status` becomes ready to play:\n\n```swift\nplayerItemObserver = playerItem?.observe(\\AVPlayerItem.status, options: [.new, .initial]) { [weak self] (item, _) in\n    guard let strongSelf = self else { return }\n    \n    if item.status == .readyToPlay {\n        if !strongSelf.readyForPlayback {\n            strongSelf.readyForPlayback = true\n            strongSelf.delegate?.streamPlaybackManager(strongSelf, playerReadyToPlay: strongSelf.player)\n        }\n    } else if item.status == .failed {\n        let error = item.error\n        \n        logger.error(\"Error: \\(String(describing: error?.localizedDescription))\")\n    }\n```\n\n### Download a stream\n\nWhen the person initiates a download by tapping the button in the corresponding stream’s table view cell, an instance of `AssetPersistenceManager` calls the following function to create an `AVAssetDownloadTask` object with an `AVAssetDownloadConfiguration` to download multiple [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVMediaSelection] for the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVURLAsset] of the stream:\n\n```swift\nfunc downloadStream(for asset: Asset) async throws {\n\n    \/\/ Get the default media selections for the asset's media selection groups.\n    let preferredMediaSelection = try await asset.urlAsset.load(.preferredMediaSelection)\n\n    \/*\n     Creates and initializes an `AVAssetDownloadTask` using an `AVAssetDownloadConfiguration` to download multiple `AVMediaSelections`\n     on an `AVURLAsset`.\n     The `primaryContentConfiguration` in `AVAssetDownloadConfiguration` requests for a variant with bitrate greater than one of the\n     lower bitrate variants in the asset.\n     *\/\n    let config = AVAssetDownloadConfiguration(asset: asset.urlAsset, title: asset.stream.name)\n    \/\/\/ Primary content configuration setup.\n    let primaryQualifier = AVAssetVariantQualifier(predicate: NSPredicate(format: \"peakBitRate > 265000\"))\n    config.primaryContentConfiguration.variantQualifiers = [primaryQualifier]\n    \n    \/\/\/ Creation of `AVAssetDownloadTask` with the above configured `AVAssetDownloadConfiguration`.\n    let task = assetDownloadURLSession.makeAssetDownloadTask(downloadConfiguration: config)\n\n    \/\/\/ To better track the `AVAssetDownloadTask`, set the `taskDescription` to something unique for the sample.\n    task.taskDescription = asset.stream.name\n\n    activeDownloadsMap[task] = asset\n    \n    \/\/\/ Use `task.progress` value to provide download progress updates in the UI.\n    let progressObservation: NSKeyValueObservation = task.progress.observe(\\.fractionCompleted) { progress, _ in\n        Task { @MainActor in\n            var userInfo = [String: Any]()\n            userInfo[Asset.Keys.name] = asset.stream.name\n            userInfo[Asset.Keys.percentDownloaded] = progress.fractionCompleted\n            NotificationCenter.default.post(name: .AssetDownloadProgress, object: nil, userInfo: userInfo)\n        }\n    }\n    self.progressObservers.append(progressObservation)\n\n    task.resume()\n\n    var userInfo = [String: Any]()\n    userInfo[Asset.Keys.name] = asset.stream.name\n    userInfo[Asset.Keys.downloadState] = Asset.DownloadState.downloading.rawValue\n    userInfo[Asset.Keys.downloadSelectionDisplayName] = await displayNamesForSelectedMediaOptions(preferredMediaSelection)\n\n    NotificationCenter.default.post(name: .AssetDownloadStateChanged, object: nil, userInfo: userInfo)\n}\n```\n\n\n\n### Cancel an in-progress download\n\nTap the button in the corresponding stream’s table view cell to reveal the accessory view, then tap Cancel to stop downloading the stream. The following function in `AssetPersistenceManager` cancels the download by calling the `URLSessionTask` [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSessionTask\/cancel()] method.\n\n```swift\nfunc cancelDownload(for asset: Asset) {\n    var task: AVAssetDownloadTask?\n\n    for (taskKey, assetVal) in activeDownloadsMap where asset == assetVal {\n        task = taskKey\n        break\n    }\n\n    task?.cancel()\n}\n```\n\n### Remove a downloaded stream from disk\n\nTap the button in the corresponding stream’s table view cell to reveal the accessory view, then tap Delete to delete the downloaded stream file. The following function in `AssetPersistenceManager` removes a downloaded stream on the device. First the asset URL corresponding to the file on the device is identified, then the `FileManager` [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileManager\/removeItem(at:)] method is called to remove the downloaded stream at the specified URL.\n\n```swift\nfunc deleteAsset(_ asset: Asset) {\n    let userDefaults = UserDefaults.standard\n\n    do {\n        if let localFileLocation = localAssetForStream(withName: asset.stream.name)?.urlAsset.url {\n            try FileManager.default.removeItem(at: localFileLocation)\n\n            userDefaults.removeObject(forKey: asset.stream.name)\n\n            var userInfo = [String: Any]()\n            userInfo[Asset.Keys.name] = asset.stream.name\n            userInfo[Asset.Keys.downloadState] = Asset.DownloadState.notDownloaded.rawValue\n\n            NotificationCenter.default.post(name: .AssetDownloadStateChanged, object: nil,\n                                            userInfo: userInfo)\n        }\n    } catch {\n        logger.error(\"An error occured deleting the file: \\(error)\")\n    }\n}\n```\n\n### Measure playback performance\n\n\n\nFor example, here’s the code to calculate the total time spent playing the stream, obtained from the `AVPlayerItemAccessLog`:\n\n```swift\nvar totalDurationWatched: Double {\n    \/\/ Compute total duration watched by iterating through the AccessLog events.\n    var totalDurationWatched = 0.0\n    if accessLog != nil && !accessLog!.events.isEmpty {\n        for event in accessLog!.events where event.durationWatched > 0 {\n                totalDurationWatched += event.durationWatched\n        }\n    }\n    return totalDurationWatched\n}\n```\n\n## Asset downloading\n\n- **AVAssetDownloadURLSession**: A URL session that creates and executes asset download tasks.\n- **AVAssetDownloadTask**: A session used to download HTTP Live Streaming assets.\n- **AVAggregateAssetDownloadTask**: A task that downloads multiple media selections for an asset.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A URL session that creates and executes asset download tasks.",
          "name" : "AVAssetDownloadURLSession",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVAssetDownloadURLSession"
        },
        {
          "description" : "A session used to download HTTP Live Streaming assets.",
          "name" : "AVAssetDownloadTask",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVAssetDownloadTask"
        },
        {
          "description" : "A task that downloads multiple media selections for an asset.",
          "name" : "AVAggregateAssetDownloadTask",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVAggregateAssetDownloadTask"
        }
      ],
      "title" : "Asset downloading"
    }
  ],
  "source" : "appleJSON",
  "title" : "Using AVFoundation to play and persist HTTP live streams",
  "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/using-avfoundation-to-play-and-persist-http-live-streams"
}