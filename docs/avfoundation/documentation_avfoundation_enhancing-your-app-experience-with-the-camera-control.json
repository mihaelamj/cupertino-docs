{
  "abstract" : "Provide direct access to your camera app’s features to help people quickly capture the perfect shot.",
  "codeExamples" : [
    {
      "code" : "\/\/ Retrieve the capture device to configure.\nguard let device = activeVideoInput?.device else { return }\n\n\/\/ Create a control to adjust the device's video zoom factor.\nlet systemZoomSlider = AVCaptureSystemZoomSlider(device: device) { zoomFactor in\n    \/\/ Calculate and display a zoom value.\n    let displayZoom = device.displayVideoZoomFactorMultiplier * zoomFactor\n    \/\/ Update the user interface.\n}\n\n\/\/ Create a control to adjust the device's exposure bias.\nlet systemBiasSlider = AVCaptureSystemExposureBiasSlider(device: device)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create a control to adjust a capture device's lens position.\nlet focusSlider = AVCaptureSlider(\"Focus\", symbolName: \"scope\", in: 0...1)\n\n\/\/ Retrieve the titles from a list of camera filters.\nlet titles = filters.map { $0.localizedTitle }\n\n\/\/ Create a control to select from a list of camera filters.\nlet filterPicker = AVCaptureIndexPicker(\"Filters\", symbolName: \"camera.filters\", localizedIndexTitles: titles)",
      "language" : "swift"
    },
    {
      "code" : "actor CameraService {\n    \n    private let captureSession = AVCaptureSession()\n\n    \/\/ A serial dispatch queue to use as the actor's executor.\n    private let sessionQueue = DispatchSerialQueue(label: \"com.myapp.sessionQueue\")\n    \n    nonisolated var unownedExecutor: UnownedSerialExecutor {\n        sessionQueue.asUnownedSerialExecutor()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create a control to adjust a capture device's lens position.\nlet focusSlider = AVCaptureSlider(\"Focus\", symbolName: \"scope\", in: 0...1)\n\/\/ Perform the slider's action on the session queue.\nfocusSlider.setActionQueue(sessionQueue) { lensPosition in\n    do {\n        try device.lockForConfiguration()\n        device.setFocusModeLocked(lensPosition: lensPosition)\n        device.unlockForConfiguration()\n    } catch {\n        print(\"Unable to change the lens position: \\(error)\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func configureControls(_ controls: [AVCaptureControl]) {\n    \n    \/\/ Verify the host system supports controls; otherwise, return early.\n    guard captureSession.supportsControls else { return }\n    \n    \/\/ Begin configuring the capture session.\n    captureSession.beginConfiguration()\n    \n    \/\/ Remove previously configured controls, if any.\n    for control in captureSession.controls {\n        captureSession.removeControl(control)\n    }\n    \n    \/\/ Iterate over the passed in controls.\n    for control in controls {\n        \/\/ Add the control to the capture session if possible.\n        if captureSession.canAddControl(control) {\n            captureSession.addControl(control)\n        } else {\n            print(\"Unable to add control \\(control).\")\n        }\n    }\n    \n    \/\/ Commit the capture session configuration.\n    captureSession.commitConfiguration()\n}",
      "language" : "swift"
    },
    {
      "code" : "func sessionControlsDidBecomeActive(_ session: AVCaptureSession) {\n    \/\/ The system presented controls.\n}\n\nfunc sessionControlsWillEnterFullscreenAppearance(_ session: AVCaptureSession) {\n    \/\/ Hide user interface that distracts from control interactions.\n}\n\nfunc sessionControlsWillExitFullscreenAppearance(_ session: AVCaptureSession) {\n    \/\/ Restore previously hidden user interface.\n}\n\nfunc sessionControlsDidBecomeInactive(_ session: AVCaptureSession) {\n    \/\/ The system dismissed controls.\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "ea8fad7712c09ed770a516cd83b424f80d4b5047a86824957ded669b4c597d75",
  "crawledAt" : "2025-12-03T19:49:31Z",
  "id" : "9D9541DC-A013-4CB3-A4A9-408E16A2130C",
  "kind" : "article",
  "language" : "swift",
  "module" : "AVFoundation",
  "overview" : "## Overview\n\niPhone 16 devices provide a new hardware interface — the Camera Control — that enables direct interaction with the camera system. By default, iOS configures the Camera Control to launch and control the Camera app. By adopting support for this feature, you can bring this same level of integration to your camera app.\n\nInteracting with the Camera Control reveals a new controls interface like shown below. A single light press of the Camera Control presents an overlay that enables a person to adjust the value of a particular control like the camera’s zoom or exposure. Then by lightly double tapping the button, the user can switch between the controls the app provides by sliding their finger on the Camera Control.\n\n\n\nThe items this menu presents are instances of [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureControl], used to define the abstract interface for control objects. This article describes the framework’s available control types and how to configure your app to use them.\n\n### Adopt system controls\n\nThe framework provides two ready-to-use control implementations that support common camera app features:\n\nBoth control types determine their range by querying the associated device’s active format for a system-recommended value. When a device format changes, such as switching from a photo to a video format, the controls update their values accordingly.\n\nConfiguring your app to use these controls provides user interfaces like shown below:\n\n\n\nAdopting system controls is straightforward. You create an instance by passing it an [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDevice] object to configure and, optionally, an action to perform after a change occurs. The system calls this action on the `@MainActor` so your app can update its user interface in response to value changes.\n\n### Define custom controls\n\nThe framework also provides two general-purpose control types that you use to define custom controls:\n\nCreate an instance of these controls by specifying a localized title that describes the control’s action, a symbol name from the SF Symbols library that defines its visual representation, and a collection of values:\n\nConfiguring your app to use these controls provides user interfaces like shown below:\n\n\n\nEach control type defines a `value` property that represents its current state, which it updates in response to user interaction. If the state a control represents can change from elsewhere in your app, such as other UI that selects a camera filter, update the control’s `value` property accordingly to keep its state in sync.\n\nYou define a control’s behavior by calling its [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSlider\/setActionQueue(_:action:)] method, which takes an action to perform and a delegate queue on which to call it. Because camera apps typically use multiple actors to define key parts of their functionality, specifying the dispatch queue to use provides the flexibility to target a control’s behavior as necessary. For example, an app that isolates its camera behavior to a `CameraService` actor can define a serial dispatch queue to use as the actor’s executor as shown below:\n\nThe app can then define a control’s action to target the session queue as follows:\n\n### Configure the capture session\n\nYou make controls available to the system by adding them to your app’s capture session. Like the interfaces [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSession] defines for configuring a session’s inputs and outputs, it provides similar API for configuring capture controls as shown here:\n\nAn app can only configure controls when supported by the host platform, so the example begins by determining support before proceeding. It then removes any previously configured controls from the session. Finally, it iterates over the controls and adds each supported instance to the capture session.\n\n### Specify a controls delegate\n\nFor the system to present the configured controls, a capture session needs to define a controls delegate. The framework provides the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSessionControlsDelegate] protocol for this purpose that defines the following methods to respond to control activation and presentation events:\n\nThe protocol defines methods to respond to activation state changes, which indicate when the system presents and dismisses controls. It also defines methods to respond to the fullscreen presentation of controls. When controls enter a fullscreen state, apps should minimize camera UI to help people focus on the control interaction. Similarly, when controls exit this state, apps should restore the previous user interface.\n\nAfter adopting this protocol in your app, set the delegate by calling the capture session’s [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSession\/setControlsDelegate(_:queue:)] method. You pass this method the delegate object and a dispatch queue for the system to use to call its methods.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AVFoundation\/enhancing-your-app-experience-with-the-camera-control\ncrawled: 2025-12-03T19:49:31Z\n---\n\n# Enhancing your app experience with the Camera Control\n\n**Article**\n\nProvide direct access to your camera app’s features to help people quickly capture the perfect shot.\n\n## Overview\n\niPhone 16 devices provide a new hardware interface — the Camera Control — that enables direct interaction with the camera system. By default, iOS configures the Camera Control to launch and control the Camera app. By adopting support for this feature, you can bring this same level of integration to your camera app.\n\n\n\nInteracting with the Camera Control reveals a new controls interface like shown below. A single light press of the Camera Control presents an overlay that enables a person to adjust the value of a particular control like the camera’s zoom or exposure. Then by lightly double tapping the button, the user can switch between the controls the app provides by sliding their finger on the Camera Control.\n\n\n\nThe items this menu presents are instances of [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureControl], used to define the abstract interface for control objects. This article describes the framework’s available control types and how to configure your app to use them.\n\n\n\n### Adopt system controls\n\nThe framework provides two ready-to-use control implementations that support common camera app features:\n\n- [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSystemZoomSlider]: A continuous slider that modifies the value of a camera device’s [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDevice\/videoZoomFactor] property.\n- [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSystemExposureBiasSlider]: A continuous slider that modifies the value of the camera device’s [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDevice\/exposureTargetBias] property.\n\nBoth control types determine their range by querying the associated device’s active format for a system-recommended value. When a device format changes, such as switching from a photo to a video format, the controls update their values accordingly.\n\nConfiguring your app to use these controls provides user interfaces like shown below:\n\n\n\nAdopting system controls is straightforward. You create an instance by passing it an [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDevice] object to configure and, optionally, an action to perform after a change occurs. The system calls this action on the `@MainActor` so your app can update its user interface in response to value changes.\n\n```swift\n\/\/ Retrieve the capture device to configure.\nguard let device = activeVideoInput?.device else { return }\n\n\/\/ Create a control to adjust the device's video zoom factor.\nlet systemZoomSlider = AVCaptureSystemZoomSlider(device: device) { zoomFactor in\n    \/\/ Calculate and display a zoom value.\n    let displayZoom = device.displayVideoZoomFactorMultiplier * zoomFactor\n    \/\/ Update the user interface.\n}\n\n\/\/ Create a control to adjust the device's exposure bias.\nlet systemBiasSlider = AVCaptureSystemExposureBiasSlider(device: device)\n```\n\n### Define custom controls\n\nThe framework also provides two general-purpose control types that you use to define custom controls:\n\n- [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSlider]: A continuous slider that selects a floating-point value from a bounded range.\n- [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureIndexPicker]: A control that selects a value by index from a mutually exclusive set.\n\nCreate an instance of these controls by specifying a localized title that describes the control’s action, a symbol name from the SF Symbols library that defines its visual representation, and a collection of values:\n\n```swift\n\/\/ Create a control to adjust a capture device's lens position.\nlet focusSlider = AVCaptureSlider(\"Focus\", symbolName: \"scope\", in: 0...1)\n\n\/\/ Retrieve the titles from a list of camera filters.\nlet titles = filters.map { $0.localizedTitle }\n\n\/\/ Create a control to select from a list of camera filters.\nlet filterPicker = AVCaptureIndexPicker(\"Filters\", symbolName: \"camera.filters\", localizedIndexTitles: titles)\n```\n\nConfiguring your app to use these controls provides user interfaces like shown below:\n\n\n\nEach control type defines a `value` property that represents its current state, which it updates in response to user interaction. If the state a control represents can change from elsewhere in your app, such as other UI that selects a camera filter, update the control’s `value` property accordingly to keep its state in sync.\n\nYou define a control’s behavior by calling its [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSlider\/setActionQueue(_:action:)] method, which takes an action to perform and a delegate queue on which to call it. Because camera apps typically use multiple actors to define key parts of their functionality, specifying the dispatch queue to use provides the flexibility to target a control’s behavior as necessary. For example, an app that isolates its camera behavior to a `CameraService` actor can define a serial dispatch queue to use as the actor’s executor as shown below:\n\n```swift\nactor CameraService {\n    \n    private let captureSession = AVCaptureSession()\n\n    \/\/ A serial dispatch queue to use as the actor's executor.\n    private let sessionQueue = DispatchSerialQueue(label: \"com.myapp.sessionQueue\")\n    \n    nonisolated var unownedExecutor: UnownedSerialExecutor {\n        sessionQueue.asUnownedSerialExecutor()\n    }\n}\n```\n\nThe app can then define a control’s action to target the session queue as follows:\n\n```swift\n\/\/ Create a control to adjust a capture device's lens position.\nlet focusSlider = AVCaptureSlider(\"Focus\", symbolName: \"scope\", in: 0...1)\n\/\/ Perform the slider's action on the session queue.\nfocusSlider.setActionQueue(sessionQueue) { lensPosition in\n    do {\n        try device.lockForConfiguration()\n        device.setFocusModeLocked(lensPosition: lensPosition)\n        device.unlockForConfiguration()\n    } catch {\n        print(\"Unable to change the lens position: \\(error)\")\n    }\n}\n```\n\n### Configure the capture session\n\nYou make controls available to the system by adding them to your app’s capture session. Like the interfaces [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSession] defines for configuring a session’s inputs and outputs, it provides similar API for configuring capture controls as shown here:\n\n```swift\nfunc configureControls(_ controls: [AVCaptureControl]) {\n    \n    \/\/ Verify the host system supports controls; otherwise, return early.\n    guard captureSession.supportsControls else { return }\n    \n    \/\/ Begin configuring the capture session.\n    captureSession.beginConfiguration()\n    \n    \/\/ Remove previously configured controls, if any.\n    for control in captureSession.controls {\n        captureSession.removeControl(control)\n    }\n    \n    \/\/ Iterate over the passed in controls.\n    for control in controls {\n        \/\/ Add the control to the capture session if possible.\n        if captureSession.canAddControl(control) {\n            captureSession.addControl(control)\n        } else {\n            print(\"Unable to add control \\(control).\")\n        }\n    }\n    \n    \/\/ Commit the capture session configuration.\n    captureSession.commitConfiguration()\n}\n```\n\nAn app can only configure controls when supported by the host platform, so the example begins by determining support before proceeding. It then removes any previously configured controls from the session. Finally, it iterates over the controls and adds each supported instance to the capture session.\n\n\n\n### Specify a controls delegate\n\nFor the system to present the configured controls, a capture session needs to define a controls delegate. The framework provides the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSessionControlsDelegate] protocol for this purpose that defines the following methods to respond to control activation and presentation events:\n\n```swift\nfunc sessionControlsDidBecomeActive(_ session: AVCaptureSession) {\n    \/\/ The system presented controls.\n}\n\nfunc sessionControlsWillEnterFullscreenAppearance(_ session: AVCaptureSession) {\n    \/\/ Hide user interface that distracts from control interactions.\n}\n\nfunc sessionControlsWillExitFullscreenAppearance(_ session: AVCaptureSession) {\n    \/\/ Restore previously hidden user interface.\n}\n\nfunc sessionControlsDidBecomeInactive(_ session: AVCaptureSession) {\n    \/\/ The system dismissed controls.\n}\n```\n\nThe protocol defines methods to respond to activation state changes, which indicate when the system presents and dismisses controls. It also defines methods to respond to the fullscreen presentation of controls. When controls enter a fullscreen state, apps should minimize camera UI to help people focus on the control interaction. Similarly, when controls exit this state, apps should restore the previous user interface.\n\nAfter adopting this protocol in your app, set the delegate by calling the capture session’s [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSession\/setControlsDelegate(_:queue:)] method. You pass this method the delegate object and a dispatch queue for the system to use to call its methods.\n\n## Capture controls\n\n- **AVCaptureControl**: An abstract base class for controls that interact with the camera system.\n- **AVCaptureSystemZoomSlider**: A control that adjusts the video zoom factor of a capture device within the system-recommended range.\n- **AVCaptureSystemExposureBiasSlider**: A control that adjusts the exposure bias of a capture device within the system-recommended range.\n- **AVCaptureSlider**: A slider control that selects a value from a bounded range.\n- **AVCaptureIndexPicker**: A control for selecting from a set of mutually exclusive values by index.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An abstract base class for controls that interact with the camera system.",
          "name" : "AVCaptureControl",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureControl"
        },
        {
          "description" : "A control that adjusts the video zoom factor of a capture device within the system-recommended range.",
          "name" : "AVCaptureSystemZoomSlider",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureSystemZoomSlider"
        },
        {
          "description" : "A control that adjusts the exposure bias of a capture device within the system-recommended range.",
          "name" : "AVCaptureSystemExposureBiasSlider",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureSystemExposureBiasSlider"
        },
        {
          "description" : "A slider control that selects a value from a bounded range.",
          "name" : "AVCaptureSlider",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureSlider"
        },
        {
          "description" : "A control for selecting from a set of mutually exclusive values by index.",
          "name" : "AVCaptureIndexPicker",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureIndexPicker"
        }
      ],
      "title" : "Capture controls"
    }
  ],
  "source" : "appleJSON",
  "title" : "Enhancing your app experience with the Camera Control",
  "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/enhancing-your-app-experience-with-the-camera-control"
}