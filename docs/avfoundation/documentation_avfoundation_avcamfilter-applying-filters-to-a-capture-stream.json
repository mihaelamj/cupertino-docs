{
  "abstract" : "Render a capture stream with rose-colored filtering and depth effects.",
  "codeExamples" : [
    {
      "code" : "let width = CVPixelBufferGetWidth(previewPixelBuffer)\nlet height = CVPixelBufferGetHeight(previewPixelBuffer)\n\nif textureCache == nil {\n    createTextureCache()\n}\nvar cvTextureOut: CVMetalTexture?\nCVMetalTextureCacheCreateTextureFromImage(kCFAllocatorDefault,\n                                          textureCache!,\n                                          previewPixelBuffer,\n                                          nil,\n                                          .bgra8Unorm,\n                                          width,\n                                          height,\n                                          0,\n                                          &cvTextureOut)",
      "language" : "swift"
    },
    {
      "code" : "var pixelBuffers = [CVPixelBuffer]()\nvar error: CVReturn = kCVReturnSuccess\nlet auxAttributes = [kCVPixelBufferPoolAllocationThresholdKey as String: allocationThreshold] as NSDictionary\nvar pixelBuffer: CVPixelBuffer?\nwhile error == kCVReturnSuccess {\n    error = CVPixelBufferPoolCreatePixelBufferWithAuxAttributes(kCFAllocatorDefault, pool, auxAttributes, &pixelBuffer)\n    if let pixelBuffer = pixelBuffer {\n        pixelBuffers.append(pixelBuffer)\n    }\n    pixelBuffer = nil\n}\npixelBuffers.removeAll()",
      "language" : "swift"
    },
    {
      "code" : "func prepare(with inputFormatDescription: CMFormatDescription, outputRetainedBufferCountHint: Int)\n\n\/\/ Release resources.\nfunc reset()\n\n\/\/ The format description of the output pixel buffers.\nvar outputFormatDescription: CMFormatDescription? { get }\n\n\/\/ The format description of the input pixel buffers.\nvar inputFormatDescription: CMFormatDescription? { get }\n\n\/\/ Render the pixel buffer.\nfunc render(pixelBuffer: CVPixelBuffer) -> CVPixelBuffer?",
      "language" : "swift"
    },
    {
      "code" : "ciContext = CIContext()\nrosyFilter = CIFilter(name: \"CIColorMatrix\")\nrosyFilter!.setValue(CIVector(x: 0, y: 0, z: 0, w: 0), forKey: \"inputGVector\")",
      "language" : "swift"
    },
    {
      "code" : "guard let inputTexture = makeTextureFromCVPixelBuffer(pixelBuffer: pixelBuffer, textureFormat: .bgra8Unorm),\n    let outputTexture = makeTextureFromCVPixelBuffer(pixelBuffer: outputPixelBuffer, textureFormat: .bgra8Unorm) else {\n        return nil\n}\n\n\/\/ Set up command queue, buffer, and encoder.\nguard let commandQueue = commandQueue,\n    let commandBuffer = commandQueue.makeCommandBuffer(),\n    let commandEncoder = commandBuffer.makeComputeCommandEncoder() else {\n        print(\"Failed to create a Metal command queue.\")\n        CVMetalTextureCacheFlush(textureCache!, 0)\n        return nil\n}\n\ncommandEncoder.label = \"Rosy Metal\"\ncommandEncoder.setComputePipelineState(computePipelineState!)\ncommandEncoder.setTexture(inputTexture, index: 0)\ncommandEncoder.setTexture(outputTexture, index: 1)\n\n\/\/ Set up the thread groups.\nlet width = computePipelineState!.threadExecutionWidth\nlet height = computePipelineState!.maxTotalThreadsPerThreadgroup \/ width\nlet threadsPerThreadgroup = MTLSizeMake(width, height, 1)\nlet threadgroupsPerGrid = MTLSize(width: (inputTexture.width + width - 1) \/ width,\n                                  height: (inputTexture.height + height - 1) \/ height,\n                                  depth: 1)\ncommandEncoder.dispatchThreadgroups(threadgroupsPerGrid, threadsPerThreadgroup: threadsPerThreadgroup)\n\ncommandEncoder.endEncoding()\ncommandBuffer.commit()",
      "language" : "swift"
    },
    {
      "code" : "kernel void rosyEffect(texture2d<half, access::read>  inputTexture  [[ texture(0) ]],\n\t\t\t\t\t   texture2d<half, access::write> outputTexture [[ texture(1) ]],\n\t\t\t\t\t   uint2 gid [[thread_position_in_grid]])\n{\n    \/\/ Don't read or write outside of the texture.\n    if ((gid.x >= inputTexture.get_width()) || (gid.y >= inputTexture.get_height())) {\n        return;\n    }\n\n    half4 inputColor = inputTexture.read(gid);\n\n    \/\/ Set the output color to the input color, excluding the green component.\n    half4 outputColor = half4(inputColor.r, 0.0, inputColor.b, 1.0);\n\n    outputTexture.write(outputColor, gid);\n}"
    },
    {
      "code" : "dataOutputQueue.async {\n    self.videoDepthMixer.mixFactor = mixFactor\n}\nprocessingQueue.async {\n    self.photoDepthMixer.mixFactor = mixFactor\n}",
      "language" : "swift"
    },
    {
      "code" : "var parameters = MixerParameters(mixFactor: mixFactor)\n\ncommandEncoder.label = \"Video Mixer\"\ncommandEncoder.setRenderPipelineState(renderPipelineState!)\ncommandEncoder.setVertexBuffer(fullRangeVertexBuffer, offset: 0, index: 0)\ncommandEncoder.setFragmentTexture(inputTexture0, index: 0)\ncommandEncoder.setFragmentTexture(inputTexture1, index: 1)\ncommandEncoder.setFragmentSamplerState(sampler, index: 0)\nwithUnsafeMutablePointer(to: &parameters) { parametersRawPointer in\n    commandEncoder.setFragmentBytes(parametersRawPointer, length: MemoryLayout<MixerParameters>.size, index: 0)\n}\ncommandEncoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)\ncommandEncoder.endEncoding()",
      "language" : "swift"
    },
    {
      "code" : "fragment half4 fragmentMixer( VertexIO        inputFragment    [[ stage_in ]],\n                              texture2d<half> mixerInput0      [[ texture(0) ]],\n                              texture2d<half> mixerInput1      [[ texture(1) ]],\n                              const device    mixerParameters& mixerParameters [[ buffer(0) ]],\n                              sampler         samplr           [[ sampler(0) ]])\n{\n    half4 input0 = mixerInput0.sample(samplr, inputFragment.textureCoord);\n    half4 input1 = mixerInput1.sample(samplr, inputFragment.textureCoord);\n\n    half4 output = mix(input0, input1, half(mixerParameters.mixFactor));\n\n    return output;\n}"
    },
    {
      "code" : "var depthFormatDescription: CMFormatDescription?\nCMVideoFormatDescriptionCreateForImageBuffer(allocator: kCFAllocatorDefault,\n                                             imageBuffer: depthData.depthDataMap,\n                                             formatDescriptionOut: &depthFormatDescription)\nif let unwrappedDepthFormatDescription = depthFormatDescription {\n    videoDepthConverter.prepare(with: unwrappedDepthFormatDescription, outputRetainedBufferCountHint: 2)\n}",
      "language" : "swift"
    },
    {
      "code" : "kernel void depthToGrayscale(texture2d<float, access::read> inputTexture   [[ texture(0) ]],\n\t\t\t\t\t\t                 texture2d<float, access::write> outputTexture [[ texture(1) ]],\n                             constant converterParameters& converterParameters [[ buffer(0) ]],\n                             uint2 gid [[ thread_position_in_grid ]])\n{\n    \/\/ Don't read or write outside of the texture.\n    if ((gid.x >= inputTexture.get_width()) || (gid.y >= inputTexture.get_height())) {\n        return;\n    }\n\n    float depth = inputTexture.read(gid).x;\n\n    \/\/ Normalize the value between 0 and 1.\n    depth = (depth - converterParameters.offset) \/ (converterParameters.range);\n\n    float4 outputColor = float4(float3(depth), 1.0);\n\n    outputTexture.write(outputColor, gid);\n}"
    },
    {
      "code" : "sessionQueue.async {\n    self.depthDataOutput.isFilteringEnabled = smoothingEnabled\n}",
      "language" : "swift"
    },
    {
      "code" : "try self.videoInput.device.lockForConfiguration()\nself.videoInput.device.activeDepthDataMinFrameDuration = duration\nself.videoInput.device.unlockForConfiguration()",
      "language" : "swift"
    }
  ],
  "contentHash" : "9be793877c3d287fc34e0c2ba7cd56a32e5efcbdd3cf70230bdfab22df7df92b",
  "crawledAt" : "2025-12-02T15:30:00Z",
  "id" : "C3066798-D4E9-42BE-B035-EA24E664A23E",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "AVFoundation",
  "overview" : "## Overview\n\nAVCamFilter is a sample camera app that takes photos with filtered effects. It shows the user a live preview of the scene with the effect rendered on top.\n\n\n\nThis sample shows you how to apply a filter with a rose-colored lens using Core Image and Metal. It also shows how to render depth and a smoothened depth effect on top of the capture stream using a grayscale filter. Finally, AVCamFilter allows the user to modulate the frame rate and the effect through sliders.\n\n### Getting started\n\nBuild and run AVCamFilter on a device running iOS 12 or later. This sample won’t work in Simulator. Also, because Metal won’t compile on Simulator, set the build target and schema to a device, or “Generic iOS Device,” before building. The depth effect also won’t show on devices that don’t support depth capture, such as the iPhone 6S and before.\n\n### Show the camera preview in a Metal view\n\nAVCamFilter uses `PreviewMetalView`, a custom subclass of [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView], instead of a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView] as its preview view, because the standard [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureVideoPreviewLayer] gets its frames directly from the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSession], with no opportunity for the app to apply effects to those frames. By subclassing `MTKView`, AVCamFilter can apply the rose-colored filter and depth grayscale filter before rendering each frame.\n\nThe `PreviewMetalView` defines its rendering behavior in `draw`. It creates a Metal texture from the image buffer, so it can transform and render that texture to the image:\n\n### Create a filter renderer\n\nThe custom `FilterRenderer` class serves as the parent for all rendering classes, such as the rose-colored filter and the grayscale converter. `RosyMetalRenderer` and `DepthToGrayscaleConverter` are both subclasses of `FilterRenderer` which provide specific filtering functionality.\n\n`FilterRenderer` encapsulates all the resources and functions necessary to render an effect to the image. For example, it allocates a pool of output buffers for rendering:\n\n`FilterRenderer` also maintains a retained buffer count to tell renderers how many buffers it can hold at one time. This hint prepares the renderer to size and preallocate its pool before beginning to render the scene:\n\n### Apply a rose-colored filter\n\nAVCamFilter applies a rose-colored filter on top of the camera stream in two ways:\n\nBoth approaches run on the GPU for optimal performance. Because the Core Image approach doesn’t require GPU command queues, `RosyCIRenderer` involves less direct manipulation of the GPU than its Metal counterpart and chains more seamlessly with other Core Image filters. Unlike the Metal function, `RosyCIRenderer` requires the creation and application of a [doc:\/\/com.apple.documentation\/documentation\/CoreImage\/CIFilter-swift.class]:\n\nIn the Metal approach, AVCamFilter sets up a command queue and thread groups to do the rendering:\n\nThe function, `RosyEffect.metal`, sets the output color of a pixel to its input color, so most of the image content remains the same, resulting in a transparent effect. However, the kernel excludes the green component, giving the image a rose-colored appearance:\n\nFor more information about setting up a Metal compute command encoder, see [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder].\n\n### Vary the mix factor\n\nWhen the user tweaks the “MixFactor” slider, AVCamFilter modulates the intensity of the filter’s mixture:\n\nThe sample accomplishes this in code by setting the mix parameter in `VideoMixer.swift`. This helper class marshals mixing commands in a command queue, buffer, and encoder. When the mix factor changes, the rendering pipeline pulls in those changes by varying the bytes in a rendered fragment:\n\nThe Metal function, `Mixer.metal`, specifies the mixing operation for each fragment:\n\n### Stream depth data\n\nAVCamFilter streams depth data in addition to RGB video by maintaining buffers dedicated to depth information. The `CameraViewController` refreshes these buffers by adhering to the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDepthDataOutputDelegate] protocol and implementing the delegate method [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDepthDataOutputDelegate\/depthDataOutput(_:didOutput:timestamp:connection:)]:\n\n`outputRetainedBufferCountHint` is the number of pixel buffers the renderer retains as it draws the scene. AVCamFilter’s depth converter preallocates its buffers with an `outputRetainedBufferCountHint` of 2 frames of latency to cover the `dispatch_async` call.\n\nThe `DepthToGrayscaleConverter` class converts depth values to grayscale pixels in the preview. Like the rose-colored filter, `DepthToGrayscaleConverter` relies on a Metal function, `DepthToGrayscale.metal`, to perform texture transformations:\n\n### Smooth depth data\n\nWithout smoothing, the depth data in each frame may have gaps or holes. Smoothing the depth data reduces the effect of frame-to-frame discrepancies by interpolating previous and subsequent frames to fill in the holes. To achieve this smoothing in code, set a parameter on [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDepthDataOutput]:\n\n### Modulate frame rate\n\nAVCamFilter also shows how to change the frame rate at which the camera delivers depth data. When the user moves the “FPS” (frames per second) slider, the app converts this user-facing representation of frame rate to its inverse, frame duration, for setting the video device’s  [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDevice\/activeDepthDataMinFrameDuration] accordingly:\n\nChanging the frame rate allows the user to control how fast the app refreshes the live stream. For example, a user who cares less about the granularity of depth information may lower the frame rate of depth data while maintaining a high RGB frame rate.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AVFoundation\/avcamfilter-applying-filters-to-a-capture-stream\ncrawled: 2025-12-02T15:30:00Z\n---\n\n# AVCamFilter: Applying filters to a capture stream\n\n**Sample Code**\n\nRender a capture stream with rose-colored filtering and depth effects.\n\n## Overview\n\nAVCamFilter is a sample camera app that takes photos with filtered effects. It shows the user a live preview of the scene with the effect rendered on top.\n\n\n\nThis sample shows you how to apply a filter with a rose-colored lens using Core Image and Metal. It also shows how to render depth and a smoothened depth effect on top of the capture stream using a grayscale filter. Finally, AVCamFilter allows the user to modulate the frame rate and the effect through sliders.\n\n### Getting started\n\nBuild and run AVCamFilter on a device running iOS 12 or later. This sample won’t work in Simulator. Also, because Metal won’t compile on Simulator, set the build target and schema to a device, or “Generic iOS Device,” before building. The depth effect also won’t show on devices that don’t support depth capture, such as the iPhone 6S and before.\n\n### Show the camera preview in a Metal view\n\nAVCamFilter uses `PreviewMetalView`, a custom subclass of [doc:\/\/com.apple.documentation\/documentation\/MetalKit\/MTKView], instead of a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIView] as its preview view, because the standard [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureVideoPreviewLayer] gets its frames directly from the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureSession], with no opportunity for the app to apply effects to those frames. By subclassing `MTKView`, AVCamFilter can apply the rose-colored filter and depth grayscale filter before rendering each frame.\n\nThe `PreviewMetalView` defines its rendering behavior in `draw`. It creates a Metal texture from the image buffer, so it can transform and render that texture to the image:\n\n```swift\nlet width = CVPixelBufferGetWidth(previewPixelBuffer)\nlet height = CVPixelBufferGetHeight(previewPixelBuffer)\n\nif textureCache == nil {\n    createTextureCache()\n}\nvar cvTextureOut: CVMetalTexture?\nCVMetalTextureCacheCreateTextureFromImage(kCFAllocatorDefault,\n                                          textureCache!,\n                                          previewPixelBuffer,\n                                          nil,\n                                          .bgra8Unorm,\n                                          width,\n                                          height,\n                                          0,\n                                          &cvTextureOut)\n```\n\n### Create a filter renderer\n\nThe custom `FilterRenderer` class serves as the parent for all rendering classes, such as the rose-colored filter and the grayscale converter. `RosyMetalRenderer` and `DepthToGrayscaleConverter` are both subclasses of `FilterRenderer` which provide specific filtering functionality.\n\n`FilterRenderer` encapsulates all the resources and functions necessary to render an effect to the image. For example, it allocates a pool of output buffers for rendering:\n\n```swift\nvar pixelBuffers = [CVPixelBuffer]()\nvar error: CVReturn = kCVReturnSuccess\nlet auxAttributes = [kCVPixelBufferPoolAllocationThresholdKey as String: allocationThreshold] as NSDictionary\nvar pixelBuffer: CVPixelBuffer?\nwhile error == kCVReturnSuccess {\n    error = CVPixelBufferPoolCreatePixelBufferWithAuxAttributes(kCFAllocatorDefault, pool, auxAttributes, &pixelBuffer)\n    if let pixelBuffer = pixelBuffer {\n        pixelBuffers.append(pixelBuffer)\n    }\n    pixelBuffer = nil\n}\npixelBuffers.removeAll()\n```\n\n`FilterRenderer` also maintains a retained buffer count to tell renderers how many buffers it can hold at one time. This hint prepares the renderer to size and preallocate its pool before beginning to render the scene:\n\n```swift\nfunc prepare(with inputFormatDescription: CMFormatDescription, outputRetainedBufferCountHint: Int)\n\n\/\/ Release resources.\nfunc reset()\n\n\/\/ The format description of the output pixel buffers.\nvar outputFormatDescription: CMFormatDescription? { get }\n\n\/\/ The format description of the input pixel buffers.\nvar inputFormatDescription: CMFormatDescription? { get }\n\n\/\/ Render the pixel buffer.\nfunc render(pixelBuffer: CVPixelBuffer) -> CVPixelBuffer?\n```\n\n### Apply a rose-colored filter\n\nAVCamFilter applies a rose-colored filter on top of the camera stream in two ways:\n\n- `RosyCIRenderer` applies a Core Image [doc:\/\/com.apple.documentation\/documentation\/CoreImage\/CIColorMatrix] filter to the input buffer.\n- `RosyMetalRenderer` creates a Metal texture from the image buffer and applies the shader in `RosyEffect.metal`.\n\nBoth approaches run on the GPU for optimal performance. Because the Core Image approach doesn’t require GPU command queues, `RosyCIRenderer` involves less direct manipulation of the GPU than its Metal counterpart and chains more seamlessly with other Core Image filters. Unlike the Metal function, `RosyCIRenderer` requires the creation and application of a [doc:\/\/com.apple.documentation\/documentation\/CoreImage\/CIFilter-swift.class]:\n\n```swift\nciContext = CIContext()\nrosyFilter = CIFilter(name: \"CIColorMatrix\")\nrosyFilter!.setValue(CIVector(x: 0, y: 0, z: 0, w: 0), forKey: \"inputGVector\")\n```\n\nIn the Metal approach, AVCamFilter sets up a command queue and thread groups to do the rendering:\n\n```swift\nguard let inputTexture = makeTextureFromCVPixelBuffer(pixelBuffer: pixelBuffer, textureFormat: .bgra8Unorm),\n    let outputTexture = makeTextureFromCVPixelBuffer(pixelBuffer: outputPixelBuffer, textureFormat: .bgra8Unorm) else {\n        return nil\n}\n\n\/\/ Set up command queue, buffer, and encoder.\nguard let commandQueue = commandQueue,\n    let commandBuffer = commandQueue.makeCommandBuffer(),\n    let commandEncoder = commandBuffer.makeComputeCommandEncoder() else {\n        print(\"Failed to create a Metal command queue.\")\n        CVMetalTextureCacheFlush(textureCache!, 0)\n        return nil\n}\n\ncommandEncoder.label = \"Rosy Metal\"\ncommandEncoder.setComputePipelineState(computePipelineState!)\ncommandEncoder.setTexture(inputTexture, index: 0)\ncommandEncoder.setTexture(outputTexture, index: 1)\n\n\/\/ Set up the thread groups.\nlet width = computePipelineState!.threadExecutionWidth\nlet height = computePipelineState!.maxTotalThreadsPerThreadgroup \/ width\nlet threadsPerThreadgroup = MTLSizeMake(width, height, 1)\nlet threadgroupsPerGrid = MTLSize(width: (inputTexture.width + width - 1) \/ width,\n                                  height: (inputTexture.height + height - 1) \/ height,\n                                  depth: 1)\ncommandEncoder.dispatchThreadgroups(threadgroupsPerGrid, threadsPerThreadgroup: threadsPerThreadgroup)\n\ncommandEncoder.endEncoding()\ncommandBuffer.commit()\n```\n\nThe function, `RosyEffect.metal`, sets the output color of a pixel to its input color, so most of the image content remains the same, resulting in a transparent effect. However, the kernel excludes the green component, giving the image a rose-colored appearance:\n\n```\nkernel void rosyEffect(texture2d<half, access::read>  inputTexture  [[ texture(0) ]],\n\t\t\t\t\t   texture2d<half, access::write> outputTexture [[ texture(1) ]],\n\t\t\t\t\t   uint2 gid [[thread_position_in_grid]])\n{\n    \/\/ Don't read or write outside of the texture.\n    if ((gid.x >= inputTexture.get_width()) || (gid.y >= inputTexture.get_height())) {\n        return;\n    }\n\n    half4 inputColor = inputTexture.read(gid);\n\n    \/\/ Set the output color to the input color, excluding the green component.\n    half4 outputColor = half4(inputColor.r, 0.0, inputColor.b, 1.0);\n\n    outputTexture.write(outputColor, gid);\n}\n```\n\nFor more information about setting up a Metal compute command encoder, see [doc:\/\/com.apple.documentation\/documentation\/Metal\/MTLComputeCommandEncoder].\n\n### Vary the mix factor\n\nWhen the user tweaks the “MixFactor” slider, AVCamFilter modulates the intensity of the filter’s mixture:\n\n```swift\ndataOutputQueue.async {\n    self.videoDepthMixer.mixFactor = mixFactor\n}\nprocessingQueue.async {\n    self.photoDepthMixer.mixFactor = mixFactor\n}\n```\n\nThe sample accomplishes this in code by setting the mix parameter in `VideoMixer.swift`. This helper class marshals mixing commands in a command queue, buffer, and encoder. When the mix factor changes, the rendering pipeline pulls in those changes by varying the bytes in a rendered fragment:\n\n```swift\nvar parameters = MixerParameters(mixFactor: mixFactor)\n\ncommandEncoder.label = \"Video Mixer\"\ncommandEncoder.setRenderPipelineState(renderPipelineState!)\ncommandEncoder.setVertexBuffer(fullRangeVertexBuffer, offset: 0, index: 0)\ncommandEncoder.setFragmentTexture(inputTexture0, index: 0)\ncommandEncoder.setFragmentTexture(inputTexture1, index: 1)\ncommandEncoder.setFragmentSamplerState(sampler, index: 0)\nwithUnsafeMutablePointer(to: &parameters) { parametersRawPointer in\n    commandEncoder.setFragmentBytes(parametersRawPointer, length: MemoryLayout<MixerParameters>.size, index: 0)\n}\ncommandEncoder.drawPrimitives(type: .triangleStrip, vertexStart: 0, vertexCount: 4)\ncommandEncoder.endEncoding()\n```\n\nThe Metal function, `Mixer.metal`, specifies the mixing operation for each fragment:\n\n```\nfragment half4 fragmentMixer( VertexIO        inputFragment    [[ stage_in ]],\n                              texture2d<half> mixerInput0      [[ texture(0) ]],\n                              texture2d<half> mixerInput1      [[ texture(1) ]],\n                              const device    mixerParameters& mixerParameters [[ buffer(0) ]],\n                              sampler         samplr           [[ sampler(0) ]])\n{\n    half4 input0 = mixerInput0.sample(samplr, inputFragment.textureCoord);\n    half4 input1 = mixerInput1.sample(samplr, inputFragment.textureCoord);\n\n    half4 output = mix(input0, input1, half(mixerParameters.mixFactor));\n\n    return output;\n}\n```\n\n### Stream depth data\n\nAVCamFilter streams depth data in addition to RGB video by maintaining buffers dedicated to depth information. The `CameraViewController` refreshes these buffers by adhering to the [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDepthDataOutputDelegate] protocol and implementing the delegate method [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDepthDataOutputDelegate\/depthDataOutput(_:didOutput:timestamp:connection:)]:\n\n```swift\nvar depthFormatDescription: CMFormatDescription?\nCMVideoFormatDescriptionCreateForImageBuffer(allocator: kCFAllocatorDefault,\n                                             imageBuffer: depthData.depthDataMap,\n                                             formatDescriptionOut: &depthFormatDescription)\nif let unwrappedDepthFormatDescription = depthFormatDescription {\n    videoDepthConverter.prepare(with: unwrappedDepthFormatDescription, outputRetainedBufferCountHint: 2)\n}\n```\n\n`outputRetainedBufferCountHint` is the number of pixel buffers the renderer retains as it draws the scene. AVCamFilter’s depth converter preallocates its buffers with an `outputRetainedBufferCountHint` of 2 frames of latency to cover the `dispatch_async` call.\n\nThe `DepthToGrayscaleConverter` class converts depth values to grayscale pixels in the preview. Like the rose-colored filter, `DepthToGrayscaleConverter` relies on a Metal function, `DepthToGrayscale.metal`, to perform texture transformations:\n\n```\nkernel void depthToGrayscale(texture2d<float, access::read> inputTexture   [[ texture(0) ]],\n\t\t\t\t\t\t                 texture2d<float, access::write> outputTexture [[ texture(1) ]],\n                             constant converterParameters& converterParameters [[ buffer(0) ]],\n                             uint2 gid [[ thread_position_in_grid ]])\n{\n    \/\/ Don't read or write outside of the texture.\n    if ((gid.x >= inputTexture.get_width()) || (gid.y >= inputTexture.get_height())) {\n        return;\n    }\n\n    float depth = inputTexture.read(gid).x;\n\n    \/\/ Normalize the value between 0 and 1.\n    depth = (depth - converterParameters.offset) \/ (converterParameters.range);\n\n    float4 outputColor = float4(float3(depth), 1.0);\n\n    outputTexture.write(outputColor, gid);\n}\n```\n\n### Smooth depth data\n\nWithout smoothing, the depth data in each frame may have gaps or holes. Smoothing the depth data reduces the effect of frame-to-frame discrepancies by interpolating previous and subsequent frames to fill in the holes. To achieve this smoothing in code, set a parameter on [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDepthDataOutput]:\n\n```swift\nsessionQueue.async {\n    self.depthDataOutput.isFilteringEnabled = smoothingEnabled\n}\n```\n\n### Modulate frame rate\n\nAVCamFilter also shows how to change the frame rate at which the camera delivers depth data. When the user moves the “FPS” (frames per second) slider, the app converts this user-facing representation of frame rate to its inverse, frame duration, for setting the video device’s  [doc:\/\/com.apple.avfoundation\/documentation\/AVFoundation\/AVCaptureDevice\/activeDepthDataMinFrameDuration] accordingly:\n\n```swift\ntry self.videoInput.device.lockForConfiguration()\nself.videoInput.device.activeDepthDataMinFrameDuration = duration\nself.videoInput.device.unlockForConfiguration()\n```\n\nChanging the frame rate allows the user to control how fast the app refreshes the live stream. For example, a user who cares less about the granularity of depth information may lower the frame rate of depth data while maintaining a high RGB frame rate.\n\n## Depth data capture\n\n- **Capturing photos with depth**: Get a depth map with a photo to create effects like the system camera’s Portrait mode (on compatible devices).\n- **Creating auxiliary depth data manually**: Generate a depth image and attach it to your own image.\n- **Capturing depth using the LiDAR camera**: Access the LiDAR camera on supporting devices to capture precise depth data.\n- **Streaming depth data from the TrueDepth camera**: Visualize depth data in 2D and 3D from the TrueDepth camera.\n- **Enhancing live video by leveraging TrueDepth camera data**: Apply your own background to a live capture feed streamed from the front-facing TrueDepth camera.\n- **AVCaptureDepthDataOutput**: A capture output that records scene depth information on compatible camera devices.\n- **AVDepthData**: A container for per-pixel distance or disparity information captured by compatible camera devices.\n- **AVCameraCalibrationData**: Information about the camera characteristics used to capture images and depth data.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Get a depth map with a photo to create effects like the system camera’s Portrait mode (on compatible devices).",
          "name" : "Capturing photos with depth",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/capturing-photos-with-depth"
        },
        {
          "description" : "Generate a depth image and attach it to your own image.",
          "name" : "Creating auxiliary depth data manually",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/creating-auxiliary-depth-data-manually"
        },
        {
          "description" : "Access the LiDAR camera on supporting devices to capture precise depth data.",
          "name" : "Capturing depth using the LiDAR camera",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/capturing-depth-using-the-lidar-camera"
        },
        {
          "description" : "Visualize depth data in 2D and 3D from the TrueDepth camera.",
          "name" : "Streaming depth data from the TrueDepth camera",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/streaming-depth-data-from-the-truedepth-camera"
        },
        {
          "description" : "Apply your own background to a live capture feed streamed from the front-facing TrueDepth camera.",
          "name" : "Enhancing live video by leveraging TrueDepth camera data",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/enhancing-live-video-by-leveraging-truedepth-camera-data"
        },
        {
          "description" : "A capture output that records scene depth information on compatible camera devices.",
          "name" : "AVCaptureDepthDataOutput",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCaptureDepthDataOutput"
        },
        {
          "description" : "A container for per-pixel distance or disparity information captured by compatible camera devices.",
          "name" : "AVDepthData",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVDepthData"
        },
        {
          "description" : "Information about the camera characteristics used to capture images and depth data.",
          "name" : "AVCameraCalibrationData",
          "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/AVCameraCalibrationData"
        }
      ],
      "title" : "Depth data capture"
    }
  ],
  "source" : "appleJSON",
  "title" : "AVCamFilter: Applying filters to a capture stream",
  "url" : "https:\/\/developer.apple.com\/documentation\/AVFoundation\/avcamfilter-applying-filters-to-a-capture-stream"
}