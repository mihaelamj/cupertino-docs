{
  "abstract" : "Build a walkie-talkie style app with system user interface controls.",
  "codeExamples" : [
    {
      "code" : "\/\/ Create a channel manager instance.    \nchannelManager = try await PTChannelManager.channelManager(delegate: self,\n                                                           restorationDelegate: self) ",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create a descriptor an app uses to join a channel.    \nlet channelImage = UIImage(named: “ChannelImage”)    \nchannelDescriptor = PTChannelDescriptor(name: “The channel name”,                                                                             \n                                        image: channelImage)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Join a channel with a unique identifier and descriptor.\nchannelManager.requestJoinChannel(channelUUID: channelUUID,\n                                  descriptor: channelDescriptor)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Restore an active channel after relaunch.    \nfunc channelDescriptor(restoredChannelUUID channelUUID: UUID) -> PTChannelDescriptor {\n    let descriptor = \/\/ Get a cached descriptor for the channel's unique identifier.\n    return descriptor\n}",
      "language" : "swift"
    },
    {
      "code" : "try await channelManager.setTransmissionMode(.fullDuplex, \n                                             channelUUID: channelUUID)",
      "language" : "swift"
    },
    {
      "code" : "await channelManager.setServiceStatus(.connecting, \n                                      channelUUID: channelUUID)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Begin transmitting to a channel.    \nchannelManager.requestBeginTransmitting(channelUUID: channelUUID)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ The transmission begins from the request source.    \nfunc channelManager(_ channelManager: PTChannelManager,\n                    channelUUID: UUID,\n                    didBeginTransmittingFrom source: PTChannelTransmitRequestSource) {        \n    \/\/ Begin reconnecting to the app’s PTT services backend infrastructure        \n    \/\/ and signal that the user is beginning to transmit.    \n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ The audio session is in an active state and ready to use.    \nfunc channelManager(_ channelManager: PTChannelManager,\n                    didActivate audioSession: AVAudioSession) {        \n    \/\/ Configure the audio session and begin recording.    \n}",
      "language" : "swift"
    },
    {
      "code" : "curl -v \\        \n    -d ‘{”activeSpeaker”:”The name of the active speaker”}’ \\\n    -H “apns-push-type: pushtotalk” \\\n    -H “apns-topic: <The app bundle id>.voip-ptt” \\\n    -H “apns-priority: 10” \\\n    -H “apns-expiration: 0” \\\n    --http2 \\\n    --cert <The certificate key name>.pem \\\n    https:\/\/api.sandbox.push.apple.com\/3\/device\/<token>",
      "language" : "shell"
    },
    {
      "code" : "func incomingPushResult(channelManager: PTChannelManager,\n                        channelUUID: UUID,\n                        pushPayload: [String: Any]) -> PTPushResult {\n    guard let activeSpeaker = pushPayload[“activeSpeaker”] as? String else {\n        \/\/ Report that there's no active speaker, so leave the channel.\n        return .leaveChannel\n    }\n\n    let activeSpeakerImage = \/\/ Get the cached image for the active speaker.\n    let participant = PTParticipant(name: activeSpeaker,\n                                    image: activeSpeakerImage)\n    \/\/ Report the active participant information to the system.\n    return .activeRemoteParticipant(participant)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "7c6db0edcfe0d7ac2a63e1b03fc7ef74e53937be8d73502542ae62ddbf4c3720",
  "crawledAt" : "2025-12-05T15:54:36Z",
  "id" : "5936D192-7159-429F-B6E2-A5CA4CDE9B09",
  "kind" : "article",
  "language" : "swift",
  "module" : "Push to Talk",
  "overview" : "## Overview\n\nThe Push to Talk (PTT) framework makes it easy to communicate with a group of individuals almost instantly with the press of a button. The framework provides your app with system user interface controls, as well as management for channel events. Handle push notifications and events like when audio transmission begins or ends, and when a person joins or leaves a channel.\n\nPTT provides the interface, and you provide the back-end communication service. Its flexibility makes it compatible with your existing end-to-end communication solutions and backend infrastructure. Use PTT to integrate with Bluetooth accessories that trigger audio recording and transmission.\n\n### Configure your Xcode project\n\nTo begin using the PTT framework, configure Xcode with the following steps:\n\n### Join a channel\n\nA channel represents and describes the PTT session to the system. Apps interact with channels through a [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager], which is the primary interface for joining channels and performing actions like transmitting and receiving audio. Multiple calls to [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/channelManager(delegate:restorationDelegate:completionHandler:)] result in the system returning the same shared instance, so store the channel manager in an instance variable.\n\nInitialize the channel manager as soon as possible during startup to ensure the framework can restore existing channels and deliver push notifications to the app.\n\nA [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelDescriptor] describes the channel to the system so it can present details — like channel name and image — in the system UI.\n\nThe framework uses shared system resources, so only one PTT channel can be active on the system at a time. To join a channel, call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/requestJoinChannel(channelUUID:descriptor:)]. The system uses the same unique identifier when interacting with the manager throughout the life of the channel, so when joining a channel, store the descriptor and UUID for later use.\n\nAfter initializing the channel manager, the framework provides an ephemeral APNs device token in [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:receivedEphemeralPushToken:)]. Get the variable-length push token and send it to the app’s server. The token isn’t active until a person joins the channel. If they leave the channel, wait until they rejoin to resume notifications.\n\nJoining a channel can fail when another channel is already active. On failure, the framework calls the delegate method [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:failedToJoinChannel:error:)] and contains a [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelError-swift.struct\/Code].\n\n### Restore an active channel\n\nWhen the system terminates an app or a person reboots the device, the app needs to restore active channels. Provide a channel descriptor to update the system in the [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelRestorationDelegate]. The system only calls the restoration delegate method when it’s unable to use data it caches to restore a channel.\n\nTo keep the system responsive, return from [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelRestorationDelegate\/channelDescriptor(restoredChannelUUID:)] as soon as possible. Don’t perform long-running or blocking tasks — like network requests — to retrieve a descriptor.\n\n### Set the channel transmission mode\n\nAfter joining a channel, set the channel’s transmission mode to indicate when the user can transmit audio. The default transmission mode is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/halfDuplex], indicating that only one participant can send or receive audio at a time. The system prevents a person from transmitting audio while they’re receiving audio from a remote participant.\n\nUse [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/fullDuplex] to allow a person to transmit and receive audio simultaneously. In full-duplex mode, the system allows a person to begin transmitting even if they’re receiving audio.\n\nSet the transmission mode to [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/listenOnly] to prevent a participant from transmitting any audio.\n\n### Report service status\n\nIf there are any platform service disruptions, report the service status through the channel manager. For example, if there’s a network outage, report that the connection is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTServiceStatus\/connecting].\n\nWhen the network is in a restored state, set the service status to [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTServiceStatus\/ready].\n\n### Transmit audio\n\nThe framework provides flexibility in how apps handle audio transmission, and enables compatibility with other platforms. Apps implement their own audio encoding and streaming process to transmit audio between users. Start PTT transmissions from the system UI or by calling [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/requestBeginTransmitting(channelUUID:)]. Begin transmission when the app is running in the foreground or following a characteristic change from a [doc:\/\/com.apple.documentation\/documentation\/CoreBluetooth] device.\n\nThe system automatically interprets play or pause toggle events from wired headsets and CarPlay devices when the system has an active PTT channel. Events result in begin- or end-transmission events in the PTT framework.\n\nTo begin a transmission, call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/requestBeginTransmitting(channelUUID:)] with a unique channel identifier.\n\nWhen the request to begin transmitting succeeds, the framework calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:channelUUID:didBeginTransmittingFrom:)]. The framework also calls this method if transmission begins from the system UI.\n\nBefore recording and transmitting audio, wait for the framework to call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:didActivate:)]. The framework calls the method when the audio session is active. This allows for recording audio even if the app is in the background. The framework doesn’t call the method if the channel transmission mode is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/fullDuplex] and already has an active audio session, because the app is receiving audio from a remote participant when a transmission begins.\n\nThe system provides built-in sound effects to indicate that the microphone is in an activated or deactivated state. Don’t provide sound effects for these events. The framework doesn’t support custom sound effects.\n\nIf the system can’t begin transmission — for example, if a person has an active cellular call — the framework calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:failedToBeginTransmittingInChannel:error:)].\n\nWhen transmission ends, the framework calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:channelUUID:didEndTransmittingFrom:)] and [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:didDeactivate:)]. The system then returns the app to a suspended state if it’s running in the background. Use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication\/beginBackgroundTask(expirationHandler:)] to request additional runtime to update the app’s server.\n\n### Receive audio\n\nThe framework introduces a new APNs type for PTT apps. When an app’s server has new audio for a person to receive, it sends a PTT notification using the device push token that an app receives when joining a channel. A token is only active for the life of a channel, so an app receives a new token each time it joins a new channel.\n\nSet the APNs push type to `pushtotalk` in the request header, and the topic header to the app’s bundle identifier with the `.voip-ptt` suffix. The payload can contain custom keys, such as the name of an active speaker or an indication that the session ended. Set the APNs priority to `10` to request immediate delivery, and set an expiration of `0` to prevent the system from delivering older pushes.\n\nWhen the app’s server sends a PTT notification, the system starts the app in the background and calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/incomingPushResult(channelManager:channelUUID:pushPayload:)]. When an app receives a push payload, it constructs a push result type to indicate what action to perform.\n\nReturn a [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTPushResult] as soon as possible and don’t block the thread. Perform network tasks — like downloading a speaker’s image or setting up a streaming network connection to a server — on a separate thread.\n\nAfter setting [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTPushResult\/activeRemoteParticipant(_:)], the system activates the app’s audio session and calls the [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:didActivate:)] method. When the app’s audio session is in an active state, begin playing back the audio it receives from the app’s server.\n\nIf the PTT channel transmission mode is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/halfDuplex], and the local participant is transmitting when the app receives a PTT notification, returning an active participant results in an error. End the local participant’s transmission by calling [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/stopTransmitting(channelUUID:)] before returning an active remote participant. The system batches these operations together — without deactivating the audio session — so an app can immediately begin playing audio it receives from a remote participant.\n\nWhen an app is in the foreground, it can receive and queue messages for playback while playing messages it previously received.\n\nWhen a remote participant finishes speaking, set [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/setActiveRemoteParticipant(_:channelUUID:completionHandler:)] to `nil` to indicate that the app is no longer receiving audio on the channel and the system can deactivate the audio session. This action updates the system UI and allows the user to transmit again.\n\n### Reduce network latency and handle audio interruptions\n\nTo reduce the steps necessary to establish a secure TLS connection, and improve the initial connection speed, use the [doc:\/\/com.apple.documentation\/documentation\/Network] framework and implement `QUIC`. For more information about `QUIC`, see [doc:\/\/com.apple.documentation\/documentation\/Network\/quic-options].\n\nThe system prioritizes communications from cellular, FaceTime, and VoIP calls, so PTT apps need to respond accordingly and handle failures gracefully. Monitor and respond to [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioSession] notifications, such as session interruptions, route changes, and failures. For more information about handling interruptions, see [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/handling-audio-interruptions].\n\n### Handle multiple Push to Talk conversations\n\nTo support simultaneous conversations, join a single channel and update the channel descriptor to reflect the active conversation. Call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/setChannelDescriptor(_:channelUUID:completionHandler:)] to update the system UI when the active conversation changes.\n\nWhen an app is in the process of receiving audio, use [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/setActiveRemoteParticipant(_:channelUUID:completionHandler:)] to update the system UI with new participant details when the conversation’s speaker changes. This eliminates having to send a new APNs notification.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/pushtotalk\/creating-a-push-to-talk-app\ncrawled: 2025-12-05T15:54:36Z\n---\n\n# Creating a Push to Talk app\n\n**Article**\n\nBuild a walkie-talkie style app with system user interface controls.\n\n## Overview\n\nThe Push to Talk (PTT) framework makes it easy to communicate with a group of individuals almost instantly with the press of a button. The framework provides your app with system user interface controls, as well as management for channel events. Handle push notifications and events like when audio transmission begins or ends, and when a person joins or leaves a channel.\n\nPTT provides the interface, and you provide the back-end communication service. Its flexibility makes it compatible with your existing end-to-end communication solutions and backend infrastructure. Use PTT to integrate with Bluetooth accessories that trigger audio recording and transmission.\n\n### Configure your Xcode project\n\nTo begin using the PTT framework, configure Xcode with the following steps:\n\n1. Choose your top-level project in the Xcode Project navigator.\n2. For your project’s target, choose Signing & Capabilities.\n3. Choose Editor > Add Capability, select Background Modes, and select Push to Talk from the list of modes.\n4. Choose Editor > Add Capability and select Push to Talk.\n5. Choose Editor > Add Capability and select Push Notifications.\n6. Click Info, expand the Custom iOS Target Properties section, hover your pointer over a row and click the Add button (+). Enter the key name [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSMicrophoneUsageDescription] and a string value that explains why the app is requesting access to the device’s microphone.\n\n### Join a channel\n\nA channel represents and describes the PTT session to the system. Apps interact with channels through a [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager], which is the primary interface for joining channels and performing actions like transmitting and receiving audio. Multiple calls to [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/channelManager(delegate:restorationDelegate:completionHandler:)] result in the system returning the same shared instance, so store the channel manager in an instance variable.\n\n```swift\n\/\/ Create a channel manager instance.    \nchannelManager = try await PTChannelManager.channelManager(delegate: self,\n                                                           restorationDelegate: self) \n```\n\nInitialize the channel manager as soon as possible during startup to ensure the framework can restore existing channels and deliver push notifications to the app.\n\nA [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelDescriptor] describes the channel to the system so it can present details — like channel name and image — in the system UI.\n\n```swift\n\/\/ Create a descriptor an app uses to join a channel.    \nlet channelImage = UIImage(named: “ChannelImage”)    \nchannelDescriptor = PTChannelDescriptor(name: “The channel name”,                                                                             \n                                        image: channelImage)\n```\n\nThe framework uses shared system resources, so only one PTT channel can be active on the system at a time. To join a channel, call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/requestJoinChannel(channelUUID:descriptor:)]. The system uses the same unique identifier when interacting with the manager throughout the life of the channel, so when joining a channel, store the descriptor and UUID for later use.\n\n```swift\n\/\/ Join a channel with a unique identifier and descriptor.\nchannelManager.requestJoinChannel(channelUUID: channelUUID,\n                                  descriptor: channelDescriptor)\n```\n\n\n\nAfter initializing the channel manager, the framework provides an ephemeral APNs device token in [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:receivedEphemeralPushToken:)]. Get the variable-length push token and send it to the app’s server. The token isn’t active until a person joins the channel. If they leave the channel, wait until they rejoin to resume notifications.\n\nJoining a channel can fail when another channel is already active. On failure, the framework calls the delegate method [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:failedToJoinChannel:error:)] and contains a [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelError-swift.struct\/Code].\n\n### Restore an active channel\n\nWhen the system terminates an app or a person reboots the device, the app needs to restore active channels. Provide a channel descriptor to update the system in the [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelRestorationDelegate]. The system only calls the restoration delegate method when it’s unable to use data it caches to restore a channel.\n\n```swift\n\/\/ Restore an active channel after relaunch.    \nfunc channelDescriptor(restoredChannelUUID channelUUID: UUID) -> PTChannelDescriptor {\n    let descriptor = \/\/ Get a cached descriptor for the channel's unique identifier.\n    return descriptor\n}\n```\n\nTo keep the system responsive, return from [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelRestorationDelegate\/channelDescriptor(restoredChannelUUID:)] as soon as possible. Don’t perform long-running or blocking tasks — like network requests — to retrieve a descriptor.\n\n### Set the channel transmission mode\n\nAfter joining a channel, set the channel’s transmission mode to indicate when the user can transmit audio. The default transmission mode is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/halfDuplex], indicating that only one participant can send or receive audio at a time. The system prevents a person from transmitting audio while they’re receiving audio from a remote participant.\n\nUse [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/fullDuplex] to allow a person to transmit and receive audio simultaneously. In full-duplex mode, the system allows a person to begin transmitting even if they’re receiving audio.\n\n```swift\ntry await channelManager.setTransmissionMode(.fullDuplex, \n                                             channelUUID: channelUUID)\n```\n\nSet the transmission mode to [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/listenOnly] to prevent a participant from transmitting any audio.\n\n### Report service status\n\nIf there are any platform service disruptions, report the service status through the channel manager. For example, if there’s a network outage, report that the connection is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTServiceStatus\/connecting].\n\n```swift\nawait channelManager.setServiceStatus(.connecting, \n                                      channelUUID: channelUUID)\n```\n\nWhen the network is in a restored state, set the service status to [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTServiceStatus\/ready].\n\n### Transmit audio\n\nThe framework provides flexibility in how apps handle audio transmission, and enables compatibility with other platforms. Apps implement their own audio encoding and streaming process to transmit audio between users. Start PTT transmissions from the system UI or by calling [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/requestBeginTransmitting(channelUUID:)]. Begin transmission when the app is running in the foreground or following a characteristic change from a [doc:\/\/com.apple.documentation\/documentation\/CoreBluetooth] device.\n\nThe system automatically interprets play or pause toggle events from wired headsets and CarPlay devices when the system has an active PTT channel. Events result in begin- or end-transmission events in the PTT framework.\n\nTo begin a transmission, call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/requestBeginTransmitting(channelUUID:)] with a unique channel identifier.\n\n```swift\n\/\/ Begin transmitting to a channel.    \nchannelManager.requestBeginTransmitting(channelUUID: channelUUID)\n```\n\nWhen the request to begin transmitting succeeds, the framework calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:channelUUID:didBeginTransmittingFrom:)]. The framework also calls this method if transmission begins from the system UI.\n\n```swift\n\/\/ The transmission begins from the request source.    \nfunc channelManager(_ channelManager: PTChannelManager,\n                    channelUUID: UUID,\n                    didBeginTransmittingFrom source: PTChannelTransmitRequestSource) {        \n    \/\/ Begin reconnecting to the app’s PTT services backend infrastructure        \n    \/\/ and signal that the user is beginning to transmit.    \n}\n```\n\nBefore recording and transmitting audio, wait for the framework to call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:didActivate:)]. The framework calls the method when the audio session is active. This allows for recording audio even if the app is in the background. The framework doesn’t call the method if the channel transmission mode is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/fullDuplex] and already has an active audio session, because the app is receiving audio from a remote participant when a transmission begins.\n\n```swift\n\/\/ The audio session is in an active state and ready to use.    \nfunc channelManager(_ channelManager: PTChannelManager,\n                    didActivate audioSession: AVAudioSession) {        \n    \/\/ Configure the audio session and begin recording.    \n}\n```\n\n\n\nThe system provides built-in sound effects to indicate that the microphone is in an activated or deactivated state. Don’t provide sound effects for these events. The framework doesn’t support custom sound effects.\n\nIf the system can’t begin transmission — for example, if a person has an active cellular call — the framework calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:failedToBeginTransmittingInChannel:error:)].\n\nWhen transmission ends, the framework calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:channelUUID:didEndTransmittingFrom:)] and [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:didDeactivate:)]. The system then returns the app to a suspended state if it’s running in the background. Use [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplication\/beginBackgroundTask(expirationHandler:)] to request additional runtime to update the app’s server.\n\n### Receive audio\n\nThe framework introduces a new APNs type for PTT apps. When an app’s server has new audio for a person to receive, it sends a PTT notification using the device push token that an app receives when joining a channel. A token is only active for the life of a channel, so an app receives a new token each time it joins a new channel.\n\nSet the APNs push type to `pushtotalk` in the request header, and the topic header to the app’s bundle identifier with the `.voip-ptt` suffix. The payload can contain custom keys, such as the name of an active speaker or an indication that the session ended. Set the APNs priority to `10` to request immediate delivery, and set an expiration of `0` to prevent the system from delivering older pushes.\n\n```shell\ncurl -v \\        \n    -d ‘{”activeSpeaker”:”The name of the active speaker”}’ \\\n    -H “apns-push-type: pushtotalk” \\\n    -H “apns-topic: <The app bundle id>.voip-ptt” \\\n    -H “apns-priority: 10” \\\n    -H “apns-expiration: 0” \\\n    --http2 \\\n    --cert <The certificate key name>.pem \\\n    https:\/\/api.sandbox.push.apple.com\/3\/device\/<token>\n```\n\nWhen the app’s server sends a PTT notification, the system starts the app in the background and calls [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/incomingPushResult(channelManager:channelUUID:pushPayload:)]. When an app receives a push payload, it constructs a push result type to indicate what action to perform.\n\n```swift\nfunc incomingPushResult(channelManager: PTChannelManager,\n                        channelUUID: UUID,\n                        pushPayload: [String: Any]) -> PTPushResult {\n    guard let activeSpeaker = pushPayload[“activeSpeaker”] as? String else {\n        \/\/ Report that there's no active speaker, so leave the channel.\n        return .leaveChannel\n    }\n\n    let activeSpeakerImage = \/\/ Get the cached image for the active speaker.\n    let participant = PTParticipant(name: activeSpeaker,\n                                    image: activeSpeakerImage)\n    \/\/ Report the active participant information to the system.\n    return .activeRemoteParticipant(participant)\n}\n```\n\nReturn a [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTPushResult] as soon as possible and don’t block the thread. Perform network tasks — like downloading a speaker’s image or setting up a streaming network connection to a server — on a separate thread.\n\nAfter setting [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTPushResult\/activeRemoteParticipant(_:)], the system activates the app’s audio session and calls the [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManagerDelegate\/channelManager(_:didActivate:)] method. When the app’s audio session is in an active state, begin playing back the audio it receives from the app’s server.\n\nIf the PTT channel transmission mode is [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTTransmissionMode\/halfDuplex], and the local participant is transmitting when the app receives a PTT notification, returning an active participant results in an error. End the local participant’s transmission by calling [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/stopTransmitting(channelUUID:)] before returning an active remote participant. The system batches these operations together — without deactivating the audio session — so an app can immediately begin playing audio it receives from a remote participant.\n\nWhen an app is in the foreground, it can receive and queue messages for playback while playing messages it previously received.\n\nWhen a remote participant finishes speaking, set [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/setActiveRemoteParticipant(_:channelUUID:completionHandler:)] to `nil` to indicate that the app is no longer receiving audio on the channel and the system can deactivate the audio session. This action updates the system UI and allows the user to transmit again.\n\n### Reduce network latency and handle audio interruptions\n\nTo reduce the steps necessary to establish a secure TLS connection, and improve the initial connection speed, use the [doc:\/\/com.apple.documentation\/documentation\/Network] framework and implement `QUIC`. For more information about `QUIC`, see [doc:\/\/com.apple.documentation\/documentation\/Network\/quic-options].\n\nThe system prioritizes communications from cellular, FaceTime, and VoIP calls, so PTT apps need to respond accordingly and handle failures gracefully. Monitor and respond to [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/AVAudioSession] notifications, such as session interruptions, route changes, and failures. For more information about handling interruptions, see [doc:\/\/com.apple.documentation\/documentation\/AVFAudio\/handling-audio-interruptions].\n\n### Handle multiple Push to Talk conversations\n\nTo support simultaneous conversations, join a single channel and update the channel descriptor to reflect the active conversation. Call [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/setChannelDescriptor(_:channelUUID:completionHandler:)] to update the system UI when the active conversation changes.\n\nWhen an app is in the process of receiving audio, use [doc:\/\/com.apple.pushtotalk\/documentation\/PushToTalk\/PTChannelManager\/setActiveRemoteParticipant(_:channelUUID:completionHandler:)] to update the system UI with new participant details when the conversation’s speaker changes. This eliminates having to send a new APNs notification.\n\n## Essentials\n\n- **PTChannelManager**: An object that represents a push-to-talk channel manager.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object that represents a push-to-talk channel manager.",
          "name" : "PTChannelManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/PushToTalk\/PTChannelManager"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a Push to Talk app",
  "url" : "https:\/\/developer.apple.com\/documentation\/pushtotalk\/creating-a-push-to-talk-app"
}