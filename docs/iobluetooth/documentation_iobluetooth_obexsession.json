{
  "abstract" : "Object representing an OBEX connection to a remote target.",
  "codeExamples" : [

  ],
  "conformsTo" : [
    "CVarArg",
    "CustomDebugStringConvertible",
    "CustomStringConvertible",
    "Equatable",
    "Hashable",
    "NSObjectProtocol"
  ],
  "contentHash" : "94370087df90911a47adbdfaaa7ec12489a9e195156ababc981ba170c58cb24d",
  "crawledAt" : "2025-12-09T18:18:25Z",
  "declaration" : {
    "code" : "class OBEXSession",
    "language" : "swift"
  },
  "id" : "FD9EDD19-DD20-4EC7-A21D-2C2592D5DB6D",
  "inheritedBy" : [
    "IOBluetoothOBEXSession"
  ],
  "kind" : "class",
  "language" : "swift",
  "module" : "IOBluetooth",
  "overview" : "## Overview\n\nYou will have no need for a obtaining\/using a raw OBEXSession, since it requires an underlying transport to do anything useful. However, once you have an object that is a subclass of this class, you can use the functions herein to manipulate that OBEXSession. First off, you will want to use OBEXConnect (if you are a client session) to actually cause the transport to open a connection to a remote target and establish an OBEX connection over it. From there you can issue more commands based on the responses from a server.\n\nIf you are a server session, the first thing you should receive is an OBEXConnect command packet, and you will want to issue an OBEXConnectResponse packet, with your reesponse to that command (success, denied, bad request, etc.).\n\nYou can use the session accessors to access certain information, such as the negotiated max packet length.\n\nIf you wish to implement your own OBEXSession over a transport such as ethernet, you will need to see the end of the file to determine which functions to override, and what to pass to those functions.\n\nNo timeout mechanism has been implemented so far for an OBEXSessions. If you need timeouts, you will need to implement them yourself. This is being explored for a future revision. However, be aware that the OBEX Specification does not explicitly require timeouts, so be sure you allow ample time for commands to complete, as some devices may be slow when sending large amounts of data.",
  "platforms" : [
    "macOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\ncrawled: 2025-12-09T18:18:25Z\n---\n\n# OBEXSession\n\n**Class**\n\nObject representing an OBEX connection to a remote target.\n\n## Declaration\n\n```swift\nclass OBEXSession\n```\n\n## Overview\n\nYou will have no need for a obtaining\/using a raw OBEXSession, since it requires an underlying transport to do anything useful. However, once you have an object that is a subclass of this class, you can use the functions herein to manipulate that OBEXSession. First off, you will want to use OBEXConnect (if you are a client session) to actually cause the transport to open a connection to a remote target and establish an OBEX connection over it. From there you can issue more commands based on the responses from a server.\n\nIf you are a server session, the first thing you should receive is an OBEXConnect command packet, and you will want to issue an OBEXConnectResponse packet, with your reesponse to that command (success, denied, bad request, etc.).\n\nYou can use the session accessors to access certain information, such as the negotiated max packet length.\n\nIf you wish to implement your own OBEXSession over a transport such as ethernet, you will need to see the end of the file to determine which functions to override, and what to pass to those functions.\n\nNo timeout mechanism has been implemented so far for an OBEXSessions. If you need timeouts, you will need to implement them yourself. This is being explored for a future revision. However, be aware that the OBEX Specification does not explicitly require timeouts, so be sure you allow ample time for commands to complete, as some devices may be slow when sending large amounts of data.\n\n## DataTypes\n\n- **OBEXTransportEvent**\n- **OBEXTransportEventType**\n\n## Instance Methods\n\n- **clientHandleIncomingData(_:)**: Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch the data. If you do not handle this case, your server session will not work, guaranteed.\n- **closeTransportConnection()**: You must override this - it will be called when the transport connection should be shutdown.\n- **getAvailableCommandPayloadLength(_:)**: Determine the maximum amount of data you can send in a particular command as an OBEX client session.\n- **getAvailableCommandResponsePayloadLength(_:)**: Determine the maximum amount of data you can send in a particular command response as an OBEX server session.\n- **getMaxPacketLength()**: Gets current max packet length.\n- **hasOpenOBEXConnection()**: Has a successful connect packet been sent and received? This API tells you so.\n- **hasOpenTransportConnection()**: You must override this - it will be called periodically to determine if a transport connection is open or not.\n- **obexAbort(_:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send an OBEX Abort command to the session’s target.\n- **obexAbortResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send an abort response to a session’s target.\n- **obexConnect(_:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Initiate an OBEX connection to a device. Causes underlying transport (Bluetooth, et al) to attempt to connect to a remote device. After success, an OBEX connect packet is sent to establish the OBEX Connection.\n- **obexConnectResponse(_:flags:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send a connect response to a session’s target.\n- **obexDisconnect(_:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send an OBEX Disconnect command to the session’s target. THIS DOES NOT necessarily close the underlying transport connection. Deleting the session will ensure that closure.\n- **obexDisconnectResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send a disconnect response to a session’s target.\n- **obexGet(_:headers:headersLength:eventSelector:selectorTarget:refCon:)**: Send an OBEX Get command to the session’s target.\n- **obexGetResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send a get response to a session’s target.\n- **obexPut(_:headersData:headersDataLength:bodyData:bodyDataLength:eventSelector:selectorTarget:refCon:)**: Send an OBEX Put command to the session’s target.\n- **obexPutResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send a put response to a session’s target.\n- **obexSetPath(_:constants:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send an OBEX SetPath command to the session’s target.\n- **obexSetPathResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)**: Send a set path response to a session’s target.\n- **openTransportConnection(_:selectorTarget:refCon:)**: Opens a transport connection to a device. A Bluetooth connection is one example of a transport.\n- **sendData(toTransport:dataLength:)**: You must override this to send data over your transport. This does nothing by default, it will return a kOBEXUnsupportedError.\n- **serverHandleIncomingData(_:)**: Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch the data. If you do not handle this case, your server session will not work, guaranteed.\n- **setEventCallback(_:)**: Sets the C-API callback used when the session recieves data.\n- **setEventRefCon(_:)**: Sets the C-API callback refCon used when the session recieves data.\n- **setEventSelector(_:target:refCon:)**: Allow you to set a selector to be called when events occur on the OBEX session.\n\n## Classes\n\n- **IOBluetoothDevice**: An instance of IOBluetoothDevice represents a single remote Bluetooth device.\n- **IOBluetoothDeviceInquiry**: Object representing a device inquiry that finds Bluetooth devices in-range of the computer, and (optionally) retrieves name information for them.\n- **IOBluetoothDevicePair**: An instance of IOBluetoothDevicePair represents a pairing attempt to a remote Bluetooth device.\n- **IOBluetoothDeviceRef**: An object that represents a Bluetooth I\/O device.\n- **IOBluetoothHandsFree**: Hands free profile class.\n- **IOBluetoothHandsFreeAudioGateway**: An object that sends data to a connected Bluetooth hands-free phone or headset and processes commands from it.\n- **IOBluetoothHandsFreeDevice**: An object you use to manage phone calls on a connected Bluetooth hands-free phone or headset.\n- **IOBluetoothHostController**: This class is a representation of a Bluetooth Host Controller Interface that is present on the local computer (either plugged in externally or available internally).\n- **IOBluetoothL2CAPChannel**: An instance of IOBluetoothL2CAPChannel represents a single open L2CAP channel.\n- **IOBluetoothL2CAPChannelRef**\n- **IOBluetoothOBEXSession**: An OBEX Session with a Bluetooth RFCOMM channel as the transport.\n- **IOBluetoothObject**\n- **IOBluetoothObjectRef**\n- **IOBluetoothRFCOMMChannel**: An instance of this class represents an RFCOMM channel as defined by the Bluetooth SDP spec..\n- **IOBluetoothRFCOMMChannelRef**\n\n## Inherits From\n\n- NSObject\n\n## Inherited By\n\n- IOBluetoothOBEXSession\n\n## Conforms To\n\n- CVarArg\n- CustomDebugStringConvertible\n- CustomStringConvertible\n- Equatable\n- Hashable\n- NSObjectProtocol\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "OBEXTransportEvent",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXTransportEvent"
        },
        {
          "description" : "",
          "name" : "OBEXTransportEventType",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXTransportEventType"
        }
      ],
      "title" : "DataTypes"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch the data. If you do not handle this case, your server session will not work, guaranteed.",
          "name" : "clientHandleIncomingData(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/clientHandleIncomingData(_:)"
        },
        {
          "description" : "You must override this - it will be called when the transport connection should be shutdown.",
          "name" : "closeTransportConnection()",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/closeTransportConnection()"
        },
        {
          "description" : "Determine the maximum amount of data you can send in a particular command as an OBEX client session.",
          "name" : "getAvailableCommandPayloadLength(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/getAvailableCommandPayloadLength(_:)"
        },
        {
          "description" : "Determine the maximum amount of data you can send in a particular command response as an OBEX server session.",
          "name" : "getAvailableCommandResponsePayloadLength(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/getAvailableCommandResponsePayloadLength(_:)"
        },
        {
          "description" : "Gets current max packet length.",
          "name" : "getMaxPacketLength()",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/getMaxPacketLength()"
        },
        {
          "description" : "Has a successful connect packet been sent and received? This API tells you so.",
          "name" : "hasOpenOBEXConnection()",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/hasOpenOBEXConnection()"
        },
        {
          "description" : "You must override this - it will be called periodically to determine if a transport connection is open or not.",
          "name" : "hasOpenTransportConnection()",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/hasOpenTransportConnection()"
        },
        {
          "description" : "Send an OBEX Abort command to the session’s target.",
          "name" : "obexAbort(_:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexAbort(_:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send an abort response to a session’s target.",
          "name" : "obexAbortResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexAbortResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Initiate an OBEX connection to a device. Causes underlying transport (Bluetooth, et al) to attempt to connect to a remote device. After success, an OBEX connect packet is sent to establish the OBEX Connection.",
          "name" : "obexConnect(_:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexConnect(_:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send a connect response to a session’s target.",
          "name" : "obexConnectResponse(_:flags:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexConnectResponse(_:flags:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send an OBEX Disconnect command to the session’s target. THIS DOES NOT necessarily close the underlying transport connection. Deleting the session will ensure that closure.",
          "name" : "obexDisconnect(_:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexDisconnect(_:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send a disconnect response to a session’s target.",
          "name" : "obexDisconnectResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexDisconnectResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send an OBEX Get command to the session’s target.",
          "name" : "obexGet(_:headers:headersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexGet(_:headers:headersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send a get response to a session’s target.",
          "name" : "obexGetResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexGetResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send an OBEX Put command to the session’s target.",
          "name" : "obexPut(_:headersData:headersDataLength:bodyData:bodyDataLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexPut(_:headersData:headersDataLength:bodyData:bodyDataLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send a put response to a session’s target.",
          "name" : "obexPutResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexPutResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send an OBEX SetPath command to the session’s target.",
          "name" : "obexSetPath(_:constants:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexSetPath(_:constants:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Send a set path response to a session’s target.",
          "name" : "obexSetPathResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/obexSetPathResponse(_:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:)"
        },
        {
          "description" : "Opens a transport connection to a device. A Bluetooth connection is one example of a transport.",
          "name" : "openTransportConnection(_:selectorTarget:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/openTransportConnection(_:selectorTarget:refCon:)"
        },
        {
          "description" : "You must override this to send data over your transport. This does nothing by default, it will return a kOBEXUnsupportedError.",
          "name" : "sendData(toTransport:dataLength:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/sendData(toTransport:dataLength:)"
        },
        {
          "description" : "Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch the data. If you do not handle this case, your server session will not work, guaranteed.",
          "name" : "serverHandleIncomingData(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/serverHandleIncomingData(_:)"
        },
        {
          "description" : "Sets the C-API callback used when the session recieves data.",
          "name" : "setEventCallback(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/setEventCallback(_:)"
        },
        {
          "description" : "Sets the C-API callback refCon used when the session recieves data.",
          "name" : "setEventRefCon(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/setEventRefCon(_:)"
        },
        {
          "description" : "Allow you to set a selector to be called when events occur on the OBEX session.",
          "name" : "setEventSelector(_:target:refCon:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession\/setEventSelector(_:target:refCon:)"
        }
      ],
      "title" : "Instance Methods"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "An instance of IOBluetoothDevice represents a single remote Bluetooth device.",
          "name" : "IOBluetoothDevice",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothDevice"
        },
        {
          "description" : "Object representing a device inquiry that finds Bluetooth devices in-range of the computer, and (optionally) retrieves name information for them.",
          "name" : "IOBluetoothDeviceInquiry",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothDeviceInquiry"
        },
        {
          "description" : "An instance of IOBluetoothDevicePair represents a pairing attempt to a remote Bluetooth device.",
          "name" : "IOBluetoothDevicePair",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothDevicePair"
        },
        {
          "description" : "An object that represents a Bluetooth I\/O device.",
          "name" : "IOBluetoothDeviceRef",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothDeviceRef"
        },
        {
          "description" : "Hands free profile class.",
          "name" : "IOBluetoothHandsFree",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothHandsFree"
        },
        {
          "description" : "An object that sends data to a connected Bluetooth hands-free phone or headset and processes commands from it.",
          "name" : "IOBluetoothHandsFreeAudioGateway",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothHandsFreeAudioGateway"
        },
        {
          "description" : "An object you use to manage phone calls on a connected Bluetooth hands-free phone or headset.",
          "name" : "IOBluetoothHandsFreeDevice",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothHandsFreeDevice"
        },
        {
          "description" : "This class is a representation of a Bluetooth Host Controller Interface that is present on the local computer (either plugged in externally or available internally).",
          "name" : "IOBluetoothHostController",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothHostController"
        },
        {
          "description" : "An instance of IOBluetoothL2CAPChannel represents a single open L2CAP channel.",
          "name" : "IOBluetoothL2CAPChannel",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothL2CAPChannel"
        },
        {
          "description" : "",
          "name" : "IOBluetoothL2CAPChannelRef",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothL2CAPChannelRef"
        },
        {
          "description" : "An OBEX Session with a Bluetooth RFCOMM channel as the transport.",
          "name" : "IOBluetoothOBEXSession",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothOBEXSession"
        },
        {
          "description" : "",
          "name" : "IOBluetoothObject",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothObject"
        },
        {
          "description" : "",
          "name" : "IOBluetoothObjectRef",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothObjectRef"
        },
        {
          "description" : "An instance of this class represents an RFCOMM channel as defined by the Bluetooth SDP spec..",
          "name" : "IOBluetoothRFCOMMChannel",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothRFCOMMChannel"
        },
        {
          "description" : "",
          "name" : "IOBluetoothRFCOMMChannelRef",
          "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/IOBluetoothRFCOMMChannelRef"
        }
      ],
      "title" : "Classes"
    },
    {
      "content" : "",
      "items" : [
        {
          "name" : "NSObject"
        }
      ],
      "title" : "Inherits From"
    }
  ],
  "source" : "appleJSON",
  "title" : "OBEXSession",
  "url" : "https:\/\/developer.apple.com\/documentation\/IOBluetooth\/OBEXSession"
}