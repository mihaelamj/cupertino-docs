{
  "abstract" : "Configure a listener, establish a client session, and exchange messages between processes.",
  "codeExamples" : [
    {
      "code" : "let serviceName = \"com.example.XPC-Calc-Engine\"\n\nlet listener = try XPCListener(service: serviceName) { request in\n    request.accept { message in\n        performCalculation(with: message)\n    }\n}\n\ndispatchMain()",
      "language" : "swift"
    },
    {
      "code" : "\/\/ If a request can't be processed, reject the incoming request.\nrequest.reject(reason: \"Service unavailable.\")\n",
      "language" : "swift"
    },
    {
      "code" : "\/\/ A codable type that contains two numbers to add together.\nstruct CalculationRequest: Codable {\n    let firstNumber: Int\n    let secondNumber: Int\n}\n\n\/\/ A codable type that contains the result of the calculation.\nstruct CalcuationResponse: Codable {\n    let result: Int\n}",
      "language" : "swift"
    },
    {
      "code" : "func performCalculation(with message: XPCReceivedMessage) -> Encodable? {\n    guard let request = try? message.decode(as: CalculationRequest.self) else { return nil }\n    return CalcuationResponse(result: request.firstNumber + request.secondNumber)\n}",
      "language" : "swift"
    },
    {
      "code" : "let serviceName = \"com.example.XPC-Calc-Engine\"\nlet session = try XPCSession(xpcService: serviceName)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create a request with two numbers for the service to operate on.\nlet request = CalculationRequest(firstNumber: 23, secondNumber: 19)\n\n\/\/ Send the message to the server, and wait for a synchronous reply.\nlet reply = try session.sendSync(request)\n",
      "language" : "swift"
    },
    {
      "code" : "if let response = try? reply.decode(as: CalcuationResponse.self) {\n    \/\/ Do something with the result, such as display it in the UI.\n    let result = response.result\n}\n            ",
      "language" : "swift"
    }
  ],
  "contentHash" : "6be65344f0c756c213a0b350e281b436922e11e5f50197555983b4f5e5665a72",
  "crawledAt" : "2025-12-04T03:09:30Z",
  "id" : "554EBFC7-367B-4472-9CE9-66E4DFE1C62D",
  "kind" : "article",
  "language" : "swift",
  "module" : "XPC",
  "overview" : "## Overview\n\nXPC services have two sides: a listener or server that receives incoming connections and performs tasks, and a client that initiates connections and makes requests. The service in this example performs a task of adding two numbers together. The sections below show:\n\n### Add an XPC Service target to your project\n\nThe XPC Service template provides a starting point for you to build the listener side of an XPC connection. To add a target, follow these steps:\n\n\n\n### Accept incoming connection requests\n\nWhen `launchd` launches an XPC service, it starts a process that runs the binary of the service. To perform tasks, the service creates an [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCListener] with a service name and a closure to handle incoming session requests. For services in an app bundle or framework, the service name is the XPC service’s bundle identifier. After creating an `XPCListener`, the service must call [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/dispatchMain()] to begin processing requests.\n\nEach time a client initiates a session with the service, the system invokes the listener’s closure, passing an [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCListener\/IncomingSessionRequest]. The listener either accepts or rejects the request. If it accepts the incoming request, it provides a request-handling closure to receive the message the client sent. In this example, the service passes that message to a custom method, `performCalculation(with:)`, to perform the task.\n\nIf the listener rejects the request, it provides a `reason` string to inform the client why it rejected the request.\n\n### Perform a task and respond to messages\n\nAfter creating the listener and accepting an incoming request, the service is ready to perform its defined task. In the example below, clients submit requests by passing an instance of a custom [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] type named `CalculationRequest`. The request contains two numbers that the service adds together. The service’s response to the request is an instance of `CalculationResponse` that contains the result of the addition.\n\nThe listener’s request-handling closure receives an [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCReceivedMessage] parameter that contains the encoded object the client sent. To perform the task, the service decodes the message using the appropriate `CalculationRequest` type. To reply to the client, the service creates an instance of `CalcuationResponse`, populates it with the result of the calculation, and returns it.\n\nWith the connection and request-handling code in place, `launchd` can now hand off client requests to your XPC service.\n\n### Connect from the client to the server and make requests\n\nWhen a client wants to use an XPC service, it creates a session with the service and then sends it a message. The following code shows how to set up an XPC session. In response to this request, `launchd` locates the service, launching it if necessary, and establishes a connection between the client process and the listener’s process.\n\nAfter creating the session, the client can send its request to the service. In the following code, the client creates the `CalculationRequest` with two numbers to add. While the client waits for a synchronous reply, the system sends the message to the service, arriving at the listener’s handler, as shown previously.\n\nThe system encodes the response from the listener in an instance of [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCReceivedMessage]. The client decodes the response using the `CalculationResponse` type, and then processes the result.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/xpc\/creating-xpc-services\ncrawled: 2025-12-04T03:09:30Z\n---\n\n# Creating XPC services\n\n**Article**\n\nConfigure a listener, establish a client session, and exchange messages between processes.\n\n## Overview\n\nXPC services have two sides: a listener or server that receives incoming connections and performs tasks, and a client that initiates connections and makes requests. The service in this example performs a task of adding two numbers together. The sections below show:\n\n- How to configure the listener, or server, and prepare to receive messages\n- How the client connects to the listener\n- How the client sends a message to the listener and receives a response\n\n### Add an XPC Service target to your project\n\nThe XPC Service template provides a starting point for you to build the listener side of an XPC connection. To add a target, follow these steps:\n\n1. Open your app or framework project in Xcode.\n2. Choose File > New > Target.\n3. Select the XPC Service from the Framework & Library section.\n4. Click Next.\n5. Specify the name for the service.\n6. Select Low Level - libXPC for the API Level popup.\n7. Click Finish.\n\n\n\n\n\n### Accept incoming connection requests\n\nWhen `launchd` launches an XPC service, it starts a process that runs the binary of the service. To perform tasks, the service creates an [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCListener] with a service name and a closure to handle incoming session requests. For services in an app bundle or framework, the service name is the XPC service’s bundle identifier. After creating an `XPCListener`, the service must call [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/dispatchMain()] to begin processing requests.\n\nEach time a client initiates a session with the service, the system invokes the listener’s closure, passing an [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCListener\/IncomingSessionRequest]. The listener either accepts or rejects the request. If it accepts the incoming request, it provides a request-handling closure to receive the message the client sent. In this example, the service passes that message to a custom method, `performCalculation(with:)`, to perform the task.\n\n```swift\nlet serviceName = \"com.example.XPC-Calc-Engine\"\n\nlet listener = try XPCListener(service: serviceName) { request in\n    request.accept { message in\n        performCalculation(with: message)\n    }\n}\n\ndispatchMain()\n```\n\nIf the listener rejects the request, it provides a `reason` string to inform the client why it rejected the request.\n\n```swift\n\/\/ If a request can't be processed, reject the incoming request.\nrequest.reject(reason: \"Service unavailable.\")\n\n```\n\n### Perform a task and respond to messages\n\nAfter creating the listener and accepting an incoming request, the service is ready to perform its defined task. In the example below, clients submit requests by passing an instance of a custom [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] type named `CalculationRequest`. The request contains two numbers that the service adds together. The service’s response to the request is an instance of `CalculationResponse` that contains the result of the addition.\n\n```swift\n\/\/ A codable type that contains two numbers to add together.\nstruct CalculationRequest: Codable {\n    let firstNumber: Int\n    let secondNumber: Int\n}\n\n\/\/ A codable type that contains the result of the calculation.\nstruct CalcuationResponse: Codable {\n    let result: Int\n}\n```\n\nThe listener’s request-handling closure receives an [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCReceivedMessage] parameter that contains the encoded object the client sent. To perform the task, the service decodes the message using the appropriate `CalculationRequest` type. To reply to the client, the service creates an instance of `CalcuationResponse`, populates it with the result of the calculation, and returns it.\n\n```swift\nfunc performCalculation(with message: XPCReceivedMessage) -> Encodable? {\n    guard let request = try? message.decode(as: CalculationRequest.self) else { return nil }\n    return CalcuationResponse(result: request.firstNumber + request.secondNumber)\n}\n```\n\nWith the connection and request-handling code in place, `launchd` can now hand off client requests to your XPC service.\n\n### Connect from the client to the server and make requests\n\nWhen a client wants to use an XPC service, it creates a session with the service and then sends it a message. The following code shows how to set up an XPC session. In response to this request, `launchd` locates the service, launching it if necessary, and establishes a connection between the client process and the listener’s process.\n\n```swift\nlet serviceName = \"com.example.XPC-Calc-Engine\"\nlet session = try XPCSession(xpcService: serviceName)\n```\n\nAfter creating the session, the client can send its request to the service. In the following code, the client creates the `CalculationRequest` with two numbers to add. While the client waits for a synchronous reply, the system sends the message to the service, arriving at the listener’s handler, as shown previously.\n\n```swift\n\/\/ Create a request with two numbers for the service to operate on.\nlet request = CalculationRequest(firstNumber: 23, secondNumber: 19)\n\n\/\/ Send the message to the server, and wait for a synchronous reply.\nlet reply = try session.sendSync(request)\n\n```\n\nThe system encodes the response from the listener in an instance of [doc:\/\/com.apple.xpc\/documentation\/XPC\/XPCReceivedMessage]. The client decodes the response using the `CalculationResponse` type, and then processes the result.\n\n```swift\nif let response = try? reply.decode(as: CalcuationResponse.self) {\n    \/\/ Do something with the result, such as display it in the UI.\n    let result = response.result\n}\n            \n```\n\n## Interprocess communication\n\n- **XPCListener**: A type that performs tasks for clients across process boundaries.\n- **XPCSession**: A type that sends messages to a server process.\n- **XPCReceivedMessage**: A type that represents a message sent between a session and a listener.\n- **xpc_listener_t**: A C type that performs tasks for clients across process boundaries.\n- **xpc_session_t**: A C type that sends messages to a server process.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that performs tasks for clients across process boundaries.",
          "name" : "XPCListener",
          "url" : "https:\/\/developer.apple.com\/documentation\/XPC\/XPCListener"
        },
        {
          "description" : "A type that sends messages to a server process.",
          "name" : "XPCSession",
          "url" : "https:\/\/developer.apple.com\/documentation\/XPC\/XPCSession"
        },
        {
          "description" : "A type that represents a message sent between a session and a listener.",
          "name" : "XPCReceivedMessage",
          "url" : "https:\/\/developer.apple.com\/documentation\/XPC\/XPCReceivedMessage"
        },
        {
          "description" : "A C type that performs tasks for clients across process boundaries.",
          "name" : "xpc_listener_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/XPC\/xpc_listener_t"
        },
        {
          "description" : "A C type that sends messages to a server process.",
          "name" : "xpc_session_t",
          "url" : "https:\/\/developer.apple.com\/documentation\/XPC\/xpc_session_t-10if0"
        }
      ],
      "title" : "Interprocess communication"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating XPC services",
  "url" : "https:\/\/developer.apple.com\/documentation\/xpc\/creating-xpc-services"
}