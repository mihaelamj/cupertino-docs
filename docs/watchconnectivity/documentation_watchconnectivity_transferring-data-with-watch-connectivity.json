{
  "abstract" : "Transfer data between a watchOS app and its companion iOS app.",
  "codeExamples" : [
    {
      "code" : "if WCSession.default.isComplicationEnabled {\n    let userInfoTranser = WCSession.default.transferCurrentComplicationUserInfo(userInfo)",
      "language" : "swift"
    },
    {
      "code" : "WidgetCenter.shared.getCurrentConfigurations { result in\n    switch result {\n    case .success(let widgetInfoList):\n        for widgetInfo in widgetInfoList where widgetInfo.kind == WidgetSupport.widgetKind {\n            WidgetCenter.shared.reloadTimelines(ofKind: widgetInfo.kind)\n        }\n    case .failure(let error):\n        print(error.localizedDescription)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> Void) {",
      "language" : "swift"
    },
    {
      "code" : "func handle(_ backgroundTasks: Set<WKRefreshBackgroundTask>) {\n    for task in backgroundTasks {\n        if let wcTask = task as? WKWatchConnectivityRefreshBackgroundTask {\n            wcBackgroundTasks.append(wcTask)\n            Logger.shared.append(line: \"\\(#function):\\(wcTask.description) was appended!\")\n        } else {\n            task.setTaskCompletedWithSnapshot(false)\n            Logger.shared.append(line: \"\\(#function):\\(task.description) was completed!\")\n        }\n    }\n    completeBackgroundTasks()\n}",
      "language" : "swift"
    },
    {
      "code" : "activationStateObservation = WCSession.default.observe(\\.activationState) { _, _ in\n    DispatchQueue.main.async {\n        self.completeBackgroundTasks()\n    }\n}\nhasContentPendingObservation = WCSession.default.observe(\\.hasContentPending) { _, _ in\n    DispatchQueue.main.async {\n        self.completeBackgroundTasks()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "73bb74f98c6e85831842a147bb1373fe6df0cff44d6bab4a2a38bed422e31269",
  "crawledAt" : "2025-12-02T15:54:55Z",
  "id" : "50B1778D-ACA1-4F01-9451-069681DDD629",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Watch Connectivity",
  "overview" : "## Overview\n\nSome watchOS apps rely on their companion iOS app to perform complicated tasks, and need to exchange data with the companion app even when there’s no internet connection. The [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity] framework provides APIs for this purpose. This sample demonstrates how to use the APIs, and how to handle Watch Connectivity background tasks.\n\n### Configure the sample code project\n\nBefore building the sample app, perform the following steps in Xcode:\n\n### Transfer data with Watch Connectivity\n\nThe Watch Connectivity framework provides APIs that accomplish the following tasks:\n\nAll APIs transfer a dictionary between the companion apps, with notable differences. [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/updateApplicationContext(_:)] sends a dictionary that represents the current app context to the companion app. It overwrites the context data currently existing in the pipeline, if any. [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/transferUserInfo(_:)] guarantees to deliver a dictionary. If an app performs another transfer before finishing the previous one, the system queues the transfers and delivers them in the order received. [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/sendMessage(_:replyHandler:errorHandler:)] sends a dictionary immediately. If the method encounters an error, it returns the error via the error handler.\n\nAn app can provide a reply handler to receive a response from its companion app. The reply handler runs asynchronously on a background thread, and returns quickly to avoid timeout. Sending a message from a watchOS app wakes up its companion iOS app, if the companion is reachable.\n\n### Update an active complication from the companion iOS  app\n\nThis sample provides a WidgetKit complication that shows a timestamp. To activate the complication:\n\nTo update the complication, the iOS app in this sample calls [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/transferCurrentComplicationUserInfo(_:)] if the complication is active. The system allows 50 transfers of this kind per day. Apps can use [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/remainingComplicationUserInfoTransfers] to retrieve the number of remaining times.\n\nThe watchOS app persists the data it receives to the shared `UserDefaults`, and calls [doc:\/\/com.apple.documentation\/documentation\/WidgetKit\/WidgetCenter\/reloadTimelines(ofKind:)] for the system to reload the timelines for the widget:\n\nWhen the system requests the timeline, the widget retrieves the data from the shared `UserDefaults` and uses it to create and return a timeline entry:\n\n### Handle Watch Connectivity background tasks\n\nWhen using Watch Connectivity, apps must complete every background task ([doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKWatchConnectivityRefreshBackgroundTask]). An uncompleted task consumes the background-task time budget that watchOS allocates to the app, which results in a crash when the budget runs out.\n\nThis sample retains the tasks in an array, and completes them when:\n\nThe following code completes the tasks at the end of [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/handle(_:)-4vdjo]:\n\nThe following code completes the tasks in the other cases:\n\nOn watchOS, the system suspends an  app when a person stops using the app and lowers their wrist. Later, when watchOS triggers a background task for the app, watchOS wakes the app from the suspended state. Using Xcode to run an app prevents the system from completing the suspension process, and may lead to different app behaviors. When encountering an issue related to background tasks, consider debugging it by launching the app directly from the Home Screen and analyzing the app logs. This sample uses [Shared\/Logger.swift] to write logs into a file, and transfers the file to the iOS app when a person taps the file transfer button in the watchOS app.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/WatchConnectivity\/transferring-data-with-watch-connectivity\ncrawled: 2025-12-02T15:54:55Z\n---\n\n# Transferring data with Watch Connectivity\n\n**Sample Code**\n\nTransfer data between a watchOS app and its companion iOS app.\n\n## Overview\n\nSome watchOS apps rely on their companion iOS app to perform complicated tasks, and need to exchange data with the companion app even when there’s no internet connection. The [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity] framework provides APIs for this purpose. This sample demonstrates how to use the APIs, and how to handle Watch Connectivity background tasks.\n\n\n\n### Configure the sample code project\n\nBefore building the sample app, perform the following steps in Xcode:\n\n1. Verify that the bundle identifiers for the watchOS app and widget targets are based on the iOS app target’s bundle identifier. For example, if the iOS app target uses `com.YourCompany.ProductName`, the watchOS app and widget targets must use `com.YourCompany.ProductName.watchkitapp` and `com.YourCompany.ProductName.watchkitapp.SimpleWatchWidget`, respectively. To check this, select each target and click its Signing & Capabilities tab.\n2. In the Signing & Capabilities tab for each target, set the developer team to let Xcode automatically manage the provisioning profile. See [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev23aab79b4] for details.\n3. In the Info tab of the `SimpleWatchConnectivity Watch App` target, change the value of the `WKCompanionAppBundleIdentifier` key to the iOS app target’s bundle identifier.\n4. Replace the App Group container identifier `group.com.example.apple-samplecode.SimpleWatchConnectivity` with one specific to your team. The identifier occurs in the entitlements for the watchOS app and the widget, and in `WidgetSupport.swift`. See [doc:\/\/com.apple.documentation\/documentation\/Xcode\/configuring-app-groups] for more details.\n\n### Transfer data with Watch Connectivity\n\nThe Watch Connectivity framework provides APIs that accomplish the following tasks:\n\n- Updating app context data\n- Sending a message\n- Transferring user info and managing outstanding transfers\n- Transferring a file, observing the transfer progress, and managing outstanding transfers\n- Updating an active complication from the companion iOS app\n\nAll APIs transfer a dictionary between the companion apps, with notable differences. [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/updateApplicationContext(_:)] sends a dictionary that represents the current app context to the companion app. It overwrites the context data currently existing in the pipeline, if any. [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/transferUserInfo(_:)] guarantees to deliver a dictionary. If an app performs another transfer before finishing the previous one, the system queues the transfers and delivers them in the order received. [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/sendMessage(_:replyHandler:errorHandler:)] sends a dictionary immediately. If the method encounters an error, it returns the error via the error handler.\n\nAn app can provide a reply handler to receive a response from its companion app. The reply handler runs asynchronously on a background thread, and returns quickly to avoid timeout. Sending a message from a watchOS app wakes up its companion iOS app, if the companion is reachable.\n\n### Update an active complication from the companion iOS  app\n\nThis sample provides a WidgetKit complication that shows a timestamp. To activate the complication:\n\n1. Choose a Modular watch face on the Apple Watch.\n2. Press the watch face to show the customization screen, tap the Edit button, and swipe right to show the configuration screen.\n3. Tap the large rectangular area, rotate the digital crown to find `SimpleWatchConnectivity Watch App`, tap it, and then select the complication.\n4. Press the digital crown and tap the screen to finish the configuration.\n\nTo update the complication, the iOS app in this sample calls [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/transferCurrentComplicationUserInfo(_:)] if the complication is active. The system allows 50 transfers of this kind per day. Apps can use [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/remainingComplicationUserInfoTransfers] to retrieve the number of remaining times.\n\n```swift\nif WCSession.default.isComplicationEnabled {\n    let userInfoTranser = WCSession.default.transferCurrentComplicationUserInfo(userInfo)\n```\n\nThe watchOS app persists the data it receives to the shared `UserDefaults`, and calls [doc:\/\/com.apple.documentation\/documentation\/WidgetKit\/WidgetCenter\/reloadTimelines(ofKind:)] for the system to reload the timelines for the widget:\n\n```swift\nWidgetCenter.shared.getCurrentConfigurations { result in\n    switch result {\n    case .success(let widgetInfoList):\n        for widgetInfo in widgetInfoList where widgetInfo.kind == WidgetSupport.widgetKind {\n            WidgetCenter.shared.reloadTimelines(ofKind: widgetInfo.kind)\n        }\n    case .failure(let error):\n        print(error.localizedDescription)\n    }\n}\n```\n\nWhen the system requests the timeline, the widget retrieves the data from the shared `UserDefaults` and uses it to create and return a timeline entry:\n\n```swift\nfunc getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> Void) {\n```\n\n### Handle Watch Connectivity background tasks\n\nWhen using Watch Connectivity, apps must complete every background task ([doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKWatchConnectivityRefreshBackgroundTask]). An uncompleted task consumes the background-task time budget that watchOS allocates to the app, which results in a crash when the budget runs out.\n\nThis sample retains the tasks in an array, and completes them when:\n\n- The app finishes handling the tasks.\n- The current `WCSession` turns to a state other than [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSessionActivationState\/activated].\n- [doc:\/\/com.apple.documentation\/documentation\/WatchConnectivity\/WCSession\/hasContentPending] becomes `false`, indicating that there’s no pending data received prior to `WCSession` activation waiting for processing.\n\nThe following code completes the tasks at the end of [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/handle(_:)-4vdjo]:\n\n```swift\nfunc handle(_ backgroundTasks: Set<WKRefreshBackgroundTask>) {\n    for task in backgroundTasks {\n        if let wcTask = task as? WKWatchConnectivityRefreshBackgroundTask {\n            wcBackgroundTasks.append(wcTask)\n            Logger.shared.append(line: \"\\(#function):\\(wcTask.description) was appended!\")\n        } else {\n            task.setTaskCompletedWithSnapshot(false)\n            Logger.shared.append(line: \"\\(#function):\\(task.description) was completed!\")\n        }\n    }\n    completeBackgroundTasks()\n}\n```\n\nThe following code completes the tasks in the other cases:\n\n```swift\nactivationStateObservation = WCSession.default.observe(\\.activationState) { _, _ in\n    DispatchQueue.main.async {\n        self.completeBackgroundTasks()\n    }\n}\nhasContentPendingObservation = WCSession.default.observe(\\.hasContentPending) { _, _ in\n    DispatchQueue.main.async {\n        self.completeBackgroundTasks()\n    }\n}\n```\n\nOn watchOS, the system suspends an  app when a person stops using the app and lowers their wrist. Later, when watchOS triggers a background task for the app, watchOS wakes the app from the suspended state. Using Xcode to run an app prevents the system from completing the suspension process, and may lead to different app behaviors. When encountering an issue related to background tasks, consider debugging it by launching the app directly from the Home Screen and analyzing the app logs. This sample uses [Shared\/Logger.swift] to write logs into a file, and transfers the file to the iOS app when a person taps the file transfer button in the watchOS app.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Transferring data with Watch Connectivity",
  "url" : "https:\/\/developer.apple.com\/documentation\/WatchConnectivity\/transferring-data-with-watch-connectivity"
}