{
  "abstract" : "Communicate with nearby devices over a secure, high-throughput, low-latency connection by using Wi-Fi Aware.",
  "codeExamples" : [
    {
      "code" : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>com.apple.developer.wifi-aware<\/key>\n    <array>\n        <string>Publish<\/string>\n        <string>Subscribe<\/string>\n    <\/array>\n<\/dict>\n<\/plist>",
      "language" : "xml"
    },
    {
      "code" : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>WiFiAwareServices<\/key>\n    <dict>\n        <key>_sat-simulation._udp<\/key>\n        <dict>\n            <key>Publishable<\/key>\n            <dict\/>\n            <key>Subscribable<\/key>\n            <dict\/>\n        <\/dict>\n    <\/dict>\n<\/dict>\n<\/plist>",
      "language" : "xml"
    },
    {
      "code" : "let simulationServiceName = \"_sat-simulation._udp\"\n\nextension WAPublishableService {\n    public static var simulationService: WAPublishableService {\n        allServices[simulationServiceName]!\n    }\n}\n\nextension WASubscribableService {\n    public static var simulationService: WASubscribableService {\n        allServices[simulationServiceName]!\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "DevicePicker(.wifiAware(.connecting(to: .userSpecifiedDevices, from: .simulationService))) { endpoint in\n    logger.info(\"Paired Endpoint: \\(endpoint)\")\n} label: {\n    Image(systemName: \"plus\")\n    Text(\"Add Device\")\n} fallback: {\n    Image(systemName: \"xmark.circle\")\n    Text(\"Unavailable\")\n}",
      "language" : "swift"
    },
    {
      "code" : "DevicePairingView(.wifiAware(.connecting(to: .simulationService, from: .userSpecifiedDevices))) {\n    Image(systemName: \"plus\")\n    Text(\"Add Device\")\n} fallback: {\n    Image(systemName: \"xmark.circle\")\n    Text(\"Unavailable\")\n}",
      "language" : "swift"
    },
    {
      "code" : "@State var pairedDevices: [WAPairedDevice] = []",
      "language" : "swift"
    },
    {
      "code" : "do {\n    for try await updatedDeviceList in WAPairedDevice.allDevices {\n        pairedDevices = Array(updatedDeviceList.values)\n    }\n} catch {\n    logger.error(\"Failed to get paired devices: \\(error)\")\n}",
      "language" : "swift"
    },
    {
      "code" : "let appPerformanceMode: WAPerformanceMode = .realtime\n\/\/ Change the performance mode.\nlet appPerformanceMode: WAPerformanceMode = .bulk",
      "language" : "swift"
    },
    {
      "code" : "let appAccessCategory: WAAccessCategory = .interactiveVideo\n\/\/ Change the traffic service class.\nlet appAccessCategory: WAAccessCategory = .bestEffort",
      "language" : "swift"
    },
    {
      "code" : "try await NetworkListener(for:\n    .wifiAware(.connecting(to: .simulationService, from: .allPairedDevices)),\nusing: .parameters {\n    Coder(receiving: NetworkEvent.self, sending: NetworkEvent.self, using: NetworkJSONCoder()) {\n        UDP()\n    }\n}\n.wifiAware { $0.performanceMode = appPerformanceMode }\n.serviceClass(appServiceClass))\n.onStateUpdate { listener, state in\n    logger.info(\"\\(String(describing: listener)) : \\(String(describing: state))\")\n\n    \/\/ Process the listener state update.\n}\n.run { connection in\n    logger.info(\"Incoming Connection: \\(String(describing: connection))\")\n    \n    \/\/ Handle the incoming connection.\n}",
      "language" : "swift"
    },
    {
      "code" : "let browser = NetworkBrowser(for:\n    .wifiAware(.connecting(to: .allPairedDevices, from: .simulationService))\n)\n.onStateUpdate { browser, state in\n    logger.info(\"\\(String(describing: browser)): \\(String(describing: state))\")\n\n    \/\/ Process the browser state update.\n}",
      "language" : "swift"
    },
    {
      "code" : "let endpoint = try await browser.run { waEndpoints in\n    logger.info(\"Discovered: \\(waEndpoints)\")\n    if let firstEndpoint = waEndpoints.first {\n        return .finish(firstEndpoint)\n    } else {\n        return .continue\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "typealias WiFiAwareConnection = NetworkConnection<Coder<NetworkEvent, NetworkEvent, NetworkJSONCoder>>\n\npublic enum NetworkEvent: Codable, Sendable {\n    case startStreaming\n    case satelliteMovedTo(position: CGPoint, dimensions: CGSize)\n}",
      "language" : "swift"
    },
    {
      "code" : "connection.onStateUpdate { connection, state in\n    logger.info(\"\\(String(describing: connection)) : \\(String(describing: state))\")\n    \n    \/\/ Process the connection state update.\n}",
      "language" : "swfit"
    },
    {
      "code" : "let connection = NetworkConnection(\n    to:\n        endpoint,\n    using: .parameters {\n        Coder(receiving: NetworkEvent.self, sending: NetworkEvent.self, using: NetworkJSONCoder()) {\n            UDP()\n        }\n    }\n    .wifiAware { $0.performanceMode = appPerformanceMode }\n    .serviceClass(appServiceClass)\n)\n\nconnection.onStateUpdate { connection, state in\n    logger.info(\"\\(connection.debugDescription): \\(String(describing: state))\")\n    \n    \/\/ Process the connection state update.\n}",
      "language" : "swift"
    },
    {
      "code" : "func send(_ event: NetworkEvent, to connection: WiFiAwareConnection) async {\n    do {\n        try await connection.send(event)\n    } catch {\n        logger.error(\"Failed to send to: \\(connection.debugDescription): \\(error)\")\n    }\n}\n\nfunc sendToAll(_ event: NetworkEvent) async {\n    for connection in connections {\n        await send(event, to: connection)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "for try await (event, _) in connection.messages {\n    \/\/ Process the incoming message and update the satellite position using the received coordinates.\n}",
      "language" : "swift"
    },
    {
      "code" : "if let wifiAwarePath = try await connection.currentPath?.wifiAware {\n    let connectedDevice = wifiAwarePath.endpoint.device\n    let performanceReport = wifiAwarePath.performance\n\n    \/\/ Use the performance report.\n}",
      "language" : "swift"
    },
    {
      "code" : "performanceReport.signalStrength",
      "language" : "swift"
    },
    {
      "code" : "performanceReport.transmitLatency[appAccessCategory]?.average",
      "language" : "swift"
    },
    {
      "code" : "case .failed(let error): \/\/ Get the Wi-Fi Aware from the NWError as error.wifiAware",
      "language" : "swfit"
    }
  ],
  "contentHash" : "fc52e14cb2cd6e3b8cedbb590510f8caeeb311987fb245ef59c172b88586c668",
  "crawledAt" : "2025-12-02T15:27:16Z",
  "id" : "5B1C82C6-0B10-47DD-8A14-DE7FD96FFF67",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Wi-Fi Aware",
  "overview" : "## Overview\n\nThis sample app uses the Wi-Fi Aware framework to build a peer-to-peer app. One device acts as a publisher by running a local simulation and advertising a service. Nearby devices connect to the publisher and subscribe to the simulation movements. The Wi-Fi Aware framework provides a secure, low-latency connection between the publisher and connected devices.\n\nThe sample app shows the interactions between the publisher and subscriber devices. The publisher simulates a satellite orbiting a planet. It sends the satellite’s coordinates to connected subscriber devices. The subscribers receive the coordinates for each frame on the publisher simulation and update their local satellite’s position, mirroring the publisher’s.\n\n### Configure the sample code project\n\nBecause this sample app relies on using Wi-Fi Aware to make a network connection between devices, you can’t run this sample in Simulator — you’ll need to run it on physical devices.\n\n### Launch and run the app\n\nThe devices then make a Wi-Fi Aware connection, and the satellite position on the subscriber device mirrors that of the one on the publisher. You can control the position of the satellite on the publisher device by tapping on it and moving it around, and you can observe the position of the satellite on the subscriber devices mirroring the one on the publisher device.\n\n### Authorize the app to publish and subscribe\n\nThe sample app uses the Wi-Fi Aware framework with the addition of the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.wifi-aware] entitlement as a capability array. To perform both publish and subscribe operations, the sample app adds the `Publish` and `Subscribe` strings to the capability array:\n\n### Declare and access services\n\nFor an app to perform any Wi-Fi Aware operations, it needs to declare the services that it intends to use for publishing and subscribing. The sample app declares the *_sat-simulation._udp* service in its `Info.plist` with `Publishable` and `Subscribable` keys:\n\nFor convenience, the app creates extensions to the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublishableService] and [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WASubscribableService] classes for the service it uses to publish and subscribe:\n\n### Pair devices to connect\n\nTo set up a connection between devices, you need to pair the devices. Both the  [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI] and [doc:\/\/com.apple.documentation\/documentation\/AccessorySetupKit] frameworks work for pairing. The sample app uses `DeviceDiscoveryUI` to pair devices.\n\nTo start a browser that can discover nearby devices, the app uses the [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI\/DevicePicker] view, providing it with `userSpecifiedDevices` as the list of allowed devices and `simulationService` as the service:\n\nTo start a listener that allows nearby devices to discover and pair, the app uses [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI\/DevicePairingView] with `simulationService` as the service and `userSpecifiedDevices` as the list of allowed devices:\n\nTo perform pairing, tap the **+** button in the app on the two devices, one running in publisher mode and the other in subscriber mode.\n\n### Access paired devices\n\nThe sample app declares a `@State` variable to display the currently available paired devices ([doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPairedDevice] instances) using a List view:\n\nThe app keeps track of currently paired devices that it has access to by iterating over the async sequence provided by [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPairedDevice\/allDevices].\n\n### Consider performance\n\nBefore using Wi-Fi Aware in an app, it’s important to decide on the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceMode] to use for the connections. The first option is [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceMode\/bulk], the recommended option for almost all use cases. The second option is [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceMode\/realtime], which is for instances that require low latency. The sample app uses `realtime` as it needs to send position updates for every frame of the simulation scene and thus requires very low latency.\n\nChanging the performance mode from `realtime` to `bulk` in the app demonstrates the difference between the two modes. To change the performance mode in the sample app, change the following line in `NetworkConfig.swift`:\n\nIn addition to setting the performance mode to `realtime`, the app also sets the traffic service class to `interactiveVideo` to achieve better prioritization of traffic resuling in lower latency. Experiment with changing the traffic service class in `NetworkConfig.swift`.\n\n### Connect using the Network framework\n\nThe sample app uses the [doc:\/\/com.apple.documentation\/documentation\/Network] framework to publish and subscribe. The Wi-Fi Aware framework implements the [doc:\/\/com.apple.documentation\/documentation\/Network\/ListenerProvider] and [doc:\/\/com.apple.documentation\/documentation\/Network\/BrowserProvider] protocols in the Network framework. The app creates a network listener and browser using [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkListener] and [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkBrowser], respectively. Running these instances results in Wi-Fi Aware publish and subscribe operations. After the app discovers the network endpoints, it creates a Wi-Fi Aware connection using [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection].\n\n### Publish a service\n\nTo start publishing, the app creates a `NetworkListener` instance by providing it `simulationService` as the service to advertise, and specifying the paired devices allowed to connect. In the sample app, [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublisherListener\/Devices\/allPairedDevices] allows a connection from any paired device. Using [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublisherListener\/Devices\/selected(_:)-56vig] limits connections to a smaller subset of devices, and using [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublisherListener\/Devices\/matching(_:)] provides a predicate filter on `WAPairedDevice`.\n\n### Subscribe to a service\n\nTo start subscribing, the app creates a `NetworkBrowser` instance by providing it `simulationService` as the service, and specifying the paired devices that it can discover.\n\nTo start the subscriber, the sample app uses the `run` method on the `NetworkBrowser` instance. The app then selects the first discovered endpoint advertising the service and stops the browse operation by returning `.finish(firstEndpoint)`. Typically, an app evaluates the list of discovered endpoints and decides to continue the browse operation until the desired endpoint is found.\n\n### Make a connection\n\nThe sample app uses the Network framework to make a connection. For convenience, the app declares a type alias `WiFiAwareConnection` for a parameterized [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection], and a [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Sendable] enumeration to encode and send satellite position coordinates over the connection.\n\nOn the publisher side, the sample app receives incoming connections in the `run` closure attached to the `NetworkListener`. As it receives new connections, the app sets up the state update handler and holds a reference to the connection instance.\n\nOn the subscriber side, the `WAEndpoint` instances the app receives from the `NetworkBrowser` are connectable when the app passes them to the `NetworkConnection`. To set up a connection to a discovered endpoint using `NetworkConnection`, the app provides the endpoint of interest and sets the Wi-Fi Aware performance mode and traffic service class. It also sets up a connection state update handler similar to the publisher.\n\nThe sample app connects to the first endpoint that’s discovered, provides the *_sat-simulation._udp* service, and stops the browser after making the first connection. Although this particular design of connecting to the first available endpoint works for the sample app’s use case, most apps typically review the discovered endpoint and make a connection only if required.\n\n### Send data to connected devices\n\nThe publisher instance of the sample app sends the coordinates of the *satellite* in the local simulation to all connected devices, for every frame:\n\n### Receive data from the connected device\n\nTo receive data over the connection, the app uses the `Network` framework APIs available in the [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection] instance:\n\nThe sample app instance running on the subscriber side receives the coordinates of the satellite as it moves in the publisher simulation. It then updates the position of the local satellite based on the coordinates it receives.\n\n### Monitor connection performance\n\nThe sample app uses the Wi-Fi Aware framework to monitor the performance of connections to peer devices. It gets the `WAPairedDevice` representing the remote endpoint and the current performance report of the connection by accessing the [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection\/currentPath] property of the connection. The app accesses the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceReport] through the `.wifiAware` extension to `currentPath`, which contains Wi-Fi Aware-specific connection performance information:\n\nThe app displays two performance attributes for each connected device: signal strength and transmit latency.\n\n### Get the signal strength\n\nSignal strength, represented as a number between `0.0` and `1.0`, is present in the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceReport] instance. A number closer to `1.0` indicates a stronger signal strength.\n\n### Get the transmit latency\n\nThe Wi-Fi Aware framework reports the measured transmit latency of packets sent to a paired device, per access category (`WAAccessCategory`). Each `NetworkConnection` is bound to a specific `WAAccessCategory` based on the `serviceClass` configuration that was provided during the creation of the connection instance. In case of the sample app, the publisher specifies [https:\/\/developer.apple.com\/documentation\/network\/nwparameters\/serviceclass-swift.enum\/interactivevideo] as the service class to transmit packets to the subscribers. To access the average transmit latency for the corresponding access category, use the following code:\n\n### Get Wi-Fi Aware errors\n\nThe Wi-Fi Aware framework extends [doc:\/\/com.apple.documentation\/documentation\/Network\/NWError] with a [doc:\/\/com.apple.documentation\/documentation\/Network\/NWError\/wifiAware] property that provides Wi-Fi Aware with specific errors that occur on the `NetworkListener`, `NetworkBrowser` or `NetworkConnection` instances. The app gets the underlying Wi-Fi Aware error from the NWError the Network framework provides as part of the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWListener\/State-swift.enum\/failed(_:)], [doc:\/\/com.apple.documentation\/documentation\/Network\/NWBrowser\/State-swift.enum\/failed(_:)], and [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/failed(_:)] states depending on whether the app is publishing, browsing, or connecting.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/WiFiAware\/Building-peer-to-peer-apps\ncrawled: 2025-12-02T15:27:16Z\n---\n\n# Building peer-to-peer apps\n\n**Sample Code**\n\nCommunicate with nearby devices over a secure, high-throughput, low-latency connection by using Wi-Fi Aware.\n\n## Overview\n\nThis sample app uses the Wi-Fi Aware framework to build a peer-to-peer app. One device acts as a publisher by running a local simulation and advertising a service. Nearby devices connect to the publisher and subscribe to the simulation movements. The Wi-Fi Aware framework provides a secure, low-latency connection between the publisher and connected devices.\n\nThe sample app shows the interactions between the publisher and subscriber devices. The publisher simulates a satellite orbiting a planet. It sends the satellite’s coordinates to connected subscriber devices. The subscribers receive the coordinates for each frame on the publisher simulation and update their local satellite’s position, mirroring the publisher’s.\n\n### Configure the sample code project\n\nBecause this sample app relies on using Wi-Fi Aware to make a network connection between devices, you can’t run this sample in Simulator — you’ll need to run it on physical devices.\n\n### Launch and run the app\n\n1. Launch the app on two nearby devices.\n2. Tap Host Simulation on one device to start it in publisher mode.\n3. Tap View Simulation on the other device to start it in subscriber mode.\n4. Pair the devices.\n\n- Tap **+** on both devices.\n- On the subscriber device, select the publisher device to pair with, and follow the on-screen steps to complete the pairing.\n- After the pairing is complete, each device shows the other device under the *Paired Devices* section. Dismiss the pairing views on both devices.\n5. Connect the devices.\n\n- On the publisher device, tap Advertise.\n- On the subscriber device, tap Discover & Connect.\n\nThe devices then make a Wi-Fi Aware connection, and the satellite position on the subscriber device mirrors that of the one on the publisher. You can control the position of the satellite on the publisher device by tapping on it and moving it around, and you can observe the position of the satellite on the subscriber devices mirroring the one on the publisher device.\n\n### Authorize the app to publish and subscribe\n\nThe sample app uses the Wi-Fi Aware framework with the addition of the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.wifi-aware] entitlement as a capability array. To perform both publish and subscribe operations, the sample app adds the `Publish` and `Subscribe` strings to the capability array:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>com.apple.developer.wifi-aware<\/key>\n    <array>\n        <string>Publish<\/string>\n        <string>Subscribe<\/string>\n    <\/array>\n<\/dict>\n<\/plist>\n```\n\n### Declare and access services\n\nFor an app to perform any Wi-Fi Aware operations, it needs to declare the services that it intends to use for publishing and subscribing. The sample app declares the *_sat-simulation._udp* service in its `Info.plist` with `Publishable` and `Subscribable` keys:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>WiFiAwareServices<\/key>\n    <dict>\n        <key>_sat-simulation._udp<\/key>\n        <dict>\n            <key>Publishable<\/key>\n            <dict\/>\n            <key>Subscribable<\/key>\n            <dict\/>\n        <\/dict>\n    <\/dict>\n<\/dict>\n<\/plist>\n```\n\nFor convenience, the app creates extensions to the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublishableService] and [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WASubscribableService] classes for the service it uses to publish and subscribe:\n\n```swift\nlet simulationServiceName = \"_sat-simulation._udp\"\n\nextension WAPublishableService {\n    public static var simulationService: WAPublishableService {\n        allServices[simulationServiceName]!\n    }\n}\n\nextension WASubscribableService {\n    public static var simulationService: WASubscribableService {\n        allServices[simulationServiceName]!\n    }\n}\n```\n\n### Pair devices to connect\n\nTo set up a connection between devices, you need to pair the devices. Both the  [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI] and [doc:\/\/com.apple.documentation\/documentation\/AccessorySetupKit] frameworks work for pairing. The sample app uses `DeviceDiscoveryUI` to pair devices.\n\nTo start a browser that can discover nearby devices, the app uses the [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI\/DevicePicker] view, providing it with `userSpecifiedDevices` as the list of allowed devices and `simulationService` as the service:\n\n```swift\nDevicePicker(.wifiAware(.connecting(to: .userSpecifiedDevices, from: .simulationService))) { endpoint in\n    logger.info(\"Paired Endpoint: \\(endpoint)\")\n} label: {\n    Image(systemName: \"plus\")\n    Text(\"Add Device\")\n} fallback: {\n    Image(systemName: \"xmark.circle\")\n    Text(\"Unavailable\")\n}\n```\n\nTo start a listener that allows nearby devices to discover and pair, the app uses [doc:\/\/com.apple.documentation\/documentation\/DeviceDiscoveryUI\/DevicePairingView] with `simulationService` as the service and `userSpecifiedDevices` as the list of allowed devices:\n\n```swift\nDevicePairingView(.wifiAware(.connecting(to: .simulationService, from: .userSpecifiedDevices))) {\n    Image(systemName: \"plus\")\n    Text(\"Add Device\")\n} fallback: {\n    Image(systemName: \"xmark.circle\")\n    Text(\"Unavailable\")\n}\n```\n\nTo perform pairing, tap the **+** button in the app on the two devices, one running in publisher mode and the other in subscriber mode.\n\n### Access paired devices\n\nThe sample app declares a `@State` variable to display the currently available paired devices ([doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPairedDevice] instances) using a List view:\n\n```swift\n@State var pairedDevices: [WAPairedDevice] = []\n```\n\nThe app keeps track of currently paired devices that it has access to by iterating over the async sequence provided by [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPairedDevice\/allDevices].\n\n```swift\ndo {\n    for try await updatedDeviceList in WAPairedDevice.allDevices {\n        pairedDevices = Array(updatedDeviceList.values)\n    }\n} catch {\n    logger.error(\"Failed to get paired devices: \\(error)\")\n}\n```\n\n### Consider performance\n\nBefore using Wi-Fi Aware in an app, it’s important to decide on the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceMode] to use for the connections. The first option is [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceMode\/bulk], the recommended option for almost all use cases. The second option is [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceMode\/realtime], which is for instances that require low latency. The sample app uses `realtime` as it needs to send position updates for every frame of the simulation scene and thus requires very low latency.\n\nChanging the performance mode from `realtime` to `bulk` in the app demonstrates the difference between the two modes. To change the performance mode in the sample app, change the following line in `NetworkConfig.swift`:\n\n```swift\nlet appPerformanceMode: WAPerformanceMode = .realtime\n\/\/ Change the performance mode.\nlet appPerformanceMode: WAPerformanceMode = .bulk\n```\n\n\n\nIn addition to setting the performance mode to `realtime`, the app also sets the traffic service class to `interactiveVideo` to achieve better prioritization of traffic resuling in lower latency. Experiment with changing the traffic service class in `NetworkConfig.swift`.\n\n```swift\nlet appAccessCategory: WAAccessCategory = .interactiveVideo\n\/\/ Change the traffic service class.\nlet appAccessCategory: WAAccessCategory = .bestEffort\n```\n\n### Connect using the Network framework\n\nThe sample app uses the [doc:\/\/com.apple.documentation\/documentation\/Network] framework to publish and subscribe. The Wi-Fi Aware framework implements the [doc:\/\/com.apple.documentation\/documentation\/Network\/ListenerProvider] and [doc:\/\/com.apple.documentation\/documentation\/Network\/BrowserProvider] protocols in the Network framework. The app creates a network listener and browser using [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkListener] and [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkBrowser], respectively. Running these instances results in Wi-Fi Aware publish and subscribe operations. After the app discovers the network endpoints, it creates a Wi-Fi Aware connection using [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection].\n\n### Publish a service\n\nTo start publishing, the app creates a `NetworkListener` instance by providing it `simulationService` as the service to advertise, and specifying the paired devices allowed to connect. In the sample app, [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublisherListener\/Devices\/allPairedDevices] allows a connection from any paired device. Using [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublisherListener\/Devices\/selected(_:)-56vig] limits connections to a smaller subset of devices, and using [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPublisherListener\/Devices\/matching(_:)] provides a predicate filter on `WAPairedDevice`.\n\n```swift\ntry await NetworkListener(for:\n    .wifiAware(.connecting(to: .simulationService, from: .allPairedDevices)),\nusing: .parameters {\n    Coder(receiving: NetworkEvent.self, sending: NetworkEvent.self, using: NetworkJSONCoder()) {\n        UDP()\n    }\n}\n.wifiAware { $0.performanceMode = appPerformanceMode }\n.serviceClass(appServiceClass))\n.onStateUpdate { listener, state in\n    logger.info(\"\\(String(describing: listener)) : \\(String(describing: state))\")\n\n    \/\/ Process the listener state update.\n}\n.run { connection in\n    logger.info(\"Incoming Connection: \\(String(describing: connection))\")\n    \n    \/\/ Handle the incoming connection.\n}\n```\n\n\n\n### Subscribe to a service\n\nTo start subscribing, the app creates a `NetworkBrowser` instance by providing it `simulationService` as the service, and specifying the paired devices that it can discover.\n\n```swift\nlet browser = NetworkBrowser(for:\n    .wifiAware(.connecting(to: .allPairedDevices, from: .simulationService))\n)\n.onStateUpdate { browser, state in\n    logger.info(\"\\(String(describing: browser)): \\(String(describing: state))\")\n\n    \/\/ Process the browser state update.\n}\n```\n\nTo start the subscriber, the sample app uses the `run` method on the `NetworkBrowser` instance. The app then selects the first discovered endpoint advertising the service and stops the browse operation by returning `.finish(firstEndpoint)`. Typically, an app evaluates the list of discovered endpoints and decides to continue the browse operation until the desired endpoint is found.\n\n```swift\nlet endpoint = try await browser.run { waEndpoints in\n    logger.info(\"Discovered: \\(waEndpoints)\")\n    if let firstEndpoint = waEndpoints.first {\n        return .finish(firstEndpoint)\n    } else {\n        return .continue\n    }\n}\n```\n\n### Make a connection\n\nThe sample app uses the Network framework to make a connection. For convenience, the app declares a type alias `WiFiAwareConnection` for a parameterized [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection], and a [doc:\/\/com.apple.documentation\/documentation\/Swift\/Codable] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/Sendable] enumeration to encode and send satellite position coordinates over the connection.\n\n```swift\ntypealias WiFiAwareConnection = NetworkConnection<Coder<NetworkEvent, NetworkEvent, NetworkJSONCoder>>\n\npublic enum NetworkEvent: Codable, Sendable {\n    case startStreaming\n    case satelliteMovedTo(position: CGPoint, dimensions: CGSize)\n}\n```\n\nOn the publisher side, the sample app receives incoming connections in the `run` closure attached to the `NetworkListener`. As it receives new connections, the app sets up the state update handler and holds a reference to the connection instance.\n\n```swfit\nconnection.onStateUpdate { connection, state in\n    logger.info(\"\\(String(describing: connection)) : \\(String(describing: state))\")\n    \n    \/\/ Process the connection state update.\n}\n```\n\nOn the subscriber side, the `WAEndpoint` instances the app receives from the `NetworkBrowser` are connectable when the app passes them to the `NetworkConnection`. To set up a connection to a discovered endpoint using `NetworkConnection`, the app provides the endpoint of interest and sets the Wi-Fi Aware performance mode and traffic service class. It also sets up a connection state update handler similar to the publisher.\n\nThe sample app connects to the first endpoint that’s discovered, provides the *_sat-simulation._udp* service, and stops the browser after making the first connection. Although this particular design of connecting to the first available endpoint works for the sample app’s use case, most apps typically review the discovered endpoint and make a connection only if required.\n\n```swift\nlet connection = NetworkConnection(\n    to:\n        endpoint,\n    using: .parameters {\n        Coder(receiving: NetworkEvent.self, sending: NetworkEvent.self, using: NetworkJSONCoder()) {\n            UDP()\n        }\n    }\n    .wifiAware { $0.performanceMode = appPerformanceMode }\n    .serviceClass(appServiceClass)\n)\n\nconnection.onStateUpdate { connection, state in\n    logger.info(\"\\(connection.debugDescription): \\(String(describing: state))\")\n    \n    \/\/ Process the connection state update.\n}\n```\n\n\n\n### Send data to connected devices\n\nThe publisher instance of the sample app sends the coordinates of the *satellite* in the local simulation to all connected devices, for every frame:\n\n```swift\nfunc send(_ event: NetworkEvent, to connection: WiFiAwareConnection) async {\n    do {\n        try await connection.send(event)\n    } catch {\n        logger.error(\"Failed to send to: \\(connection.debugDescription): \\(error)\")\n    }\n}\n\nfunc sendToAll(_ event: NetworkEvent) async {\n    for connection in connections {\n        await send(event, to: connection)\n    }\n}\n```\n\n### Receive data from the connected device\n\nTo receive data over the connection, the app uses the `Network` framework APIs available in the [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection] instance:\n\n```swift\nfor try await (event, _) in connection.messages {\n    \/\/ Process the incoming message and update the satellite position using the received coordinates.\n}\n```\n\nThe sample app instance running on the subscriber side receives the coordinates of the satellite as it moves in the publisher simulation. It then updates the position of the local satellite based on the coordinates it receives.\n\n### Monitor connection performance\n\nThe sample app uses the Wi-Fi Aware framework to monitor the performance of connections to peer devices. It gets the `WAPairedDevice` representing the remote endpoint and the current performance report of the connection by accessing the [doc:\/\/com.apple.documentation\/documentation\/Network\/NetworkConnection\/currentPath] property of the connection. The app accesses the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceReport] through the `.wifiAware` extension to `currentPath`, which contains Wi-Fi Aware-specific connection performance information:\n\n```swift\nif let wifiAwarePath = try await connection.currentPath?.wifiAware {\n    let connectedDevice = wifiAwarePath.endpoint.device\n    let performanceReport = wifiAwarePath.performance\n\n    \/\/ Use the performance report.\n}\n```\n\nThe app displays two performance attributes for each connected device: signal strength and transmit latency.\n\n### Get the signal strength\n\nSignal strength, represented as a number between `0.0` and `1.0`, is present in the [doc:\/\/com.apple.wifiaware\/documentation\/WiFiAware\/WAPerformanceReport] instance. A number closer to `1.0` indicates a stronger signal strength.\n\n```swift\nperformanceReport.signalStrength\n```\n\n### Get the transmit latency\n\nThe Wi-Fi Aware framework reports the measured transmit latency of packets sent to a paired device, per access category (`WAAccessCategory`). Each `NetworkConnection` is bound to a specific `WAAccessCategory` based on the `serviceClass` configuration that was provided during the creation of the connection instance. In case of the sample app, the publisher specifies [https:\/\/developer.apple.com\/documentation\/network\/nwparameters\/serviceclass-swift.enum\/interactivevideo] as the service class to transmit packets to the subscribers. To access the average transmit latency for the corresponding access category, use the following code:\n\n```swift\nperformanceReport.transmitLatency[appAccessCategory]?.average\n```\n\n### Get Wi-Fi Aware errors\n\nThe Wi-Fi Aware framework extends [doc:\/\/com.apple.documentation\/documentation\/Network\/NWError] with a [doc:\/\/com.apple.documentation\/documentation\/Network\/NWError\/wifiAware] property that provides Wi-Fi Aware with specific errors that occur on the `NetworkListener`, `NetworkBrowser` or `NetworkConnection` instances. The app gets the underlying Wi-Fi Aware error from the NWError the Network framework provides as part of the [doc:\/\/com.apple.documentation\/documentation\/Network\/NWListener\/State-swift.enum\/failed(_:)], [doc:\/\/com.apple.documentation\/documentation\/Network\/NWBrowser\/State-swift.enum\/failed(_:)], and [doc:\/\/com.apple.documentation\/documentation\/Network\/NWConnection\/State-swift.enum\/failed(_:)] states depending on whether the app is publishing, browsing, or connecting.\n\n```swfit\ncase .failed(let error): \/\/ Get the Wi-Fi Aware from the NWError as error.wifiAware\n```\n\n## Essentials\n\n- **Connecting devices for peer-to-peer Wi-Fi**: Make outgoing and accept incoming secure connections with paired devices.\n- **Adopting Wi-Fi Aware**: Add entitlements and declare your app’s services.\n- **com.apple.developer.wifi-aware**: The entitlement the system requires for an app to use the Wi-Fi Aware framework.\n- **WiFiAwareServices**: Dictionaries of Wi-Fi Aware services that the app can publish or subscribe to.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Make outgoing and accept incoming secure connections with paired devices.",
          "name" : "Connecting devices for peer-to-peer Wi-Fi",
          "url" : "https:\/\/developer.apple.com\/documentation\/WiFiAware\/Connecting-paired-devices"
        },
        {
          "description" : "Add entitlements and declare your app’s services.",
          "name" : "Adopting Wi-Fi Aware",
          "url" : "https:\/\/developer.apple.com\/documentation\/WiFiAware\/Adopting-Wi-Fi-Aware"
        },
        {
          "description" : "The entitlement the system requires for an app to use the Wi-Fi Aware framework.",
          "name" : "com.apple.developer.wifi-aware",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.wifi-aware"
        },
        {
          "description" : "Dictionaries of Wi-Fi Aware services that the app can publish or subscribe to.",
          "name" : "WiFiAwareServices",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Information-Property-List\/WiFiAwareServices"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Building peer-to-peer apps",
  "url" : "https:\/\/developer.apple.com\/documentation\/WiFiAware\/Building-peer-to-peer-apps"
}