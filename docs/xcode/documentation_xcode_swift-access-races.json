{
  "abstract" : "Detects unsynchronized access to mutable state across multiple threads in Swift.",
  "codeExamples" : [
    {
      "code" : "var messages: [String] = []\n\/\/ Executed on Thread #1\nfunc producer() {\n    messages.append(\"A message\");\n}\n\/\/ Executed on Thread #2\nfunc consumer() {\n    repeat {\n        let message = messages.remove(at: 0)\n        print(\"\\(message)\")\n    } while !messages.isEmpty\n}",
      "language" : "swift"
    },
    {
      "code" : "var log: String = \"\"\n\/\/ Executed on Thread #1\nfunc writeNumbers() {\n    print(1, 2, 3, separator: \",\", to: &log)\n}\n\/\/ Executed on Thread #2\nfunc writeLetters() {\n    print(\"a\", \"b\", \"c\", separator:\",\", to: &log)\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "89217b6dfc2fd95f7287bb2ac21f5abf01326ba2702bfb70b6838a9ccbaa1458",
  "crawledAt" : "2025-12-04T01:08:49Z",
  "id" : "8F375A7D-C329-4430-A297-DAB4FBA369FF",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nUse this check to detect when multiple threads call a mutating method on a structure, or when they pass a reference to a shared variable without synchronization, which can result in unpredictable behavior. Available in Xcode 9 and later.\n\n### Access race with mutating structure methods\n\nIn the following example, the `producer()` function adds messages to a global array, and the `consumer()` function removes messages from the array and prints them. Because `producer()` executes on one thread and `consumer()`  executes on another, and both call mutating methods on the array, there is an access race on `messages`.\n\n#### Solution\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Dispatch] APIs to coordinate access to `messages` across multiple threads.\n\n### Access race with in-out parameters\n\nIn the following example, the `writeNumbers()` function writes numbers to a global string. The `writeLetters()` function writes letters to the same string. Because the two functions execute on different threads and both access `log` by reference using `inout,` there is an access race on `log`.\n\n#### Solution\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Dispatch] APIs to coordinate access to `log` across multiple threads.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/swift-access-races\ncrawled: 2025-12-04T01:08:49Z\n---\n\n# Swift access races\n\n**Article**\n\nDetects unsynchronized access to mutable state across multiple threads in Swift.\n\n## Overview\n\nUse this check to detect when multiple threads call a mutating method on a structure, or when they pass a reference to a shared variable without synchronization, which can result in unpredictable behavior. Available in Xcode 9 and later.\n\n### Access race with mutating structure methods\n\nIn the following example, the `producer()` function adds messages to a global array, and the `consumer()` function removes messages from the array and prints them. Because `producer()` executes on one thread and `consumer()`  executes on another, and both call mutating methods on the array, there is an access race on `messages`.\n\n```swift\nvar messages: [String] = []\n\/\/ Executed on Thread #1\nfunc producer() {\n    messages.append(\"A message\");\n}\n\/\/ Executed on Thread #2\nfunc consumer() {\n    repeat {\n        let message = messages.remove(at: 0)\n        print(\"\\(message)\")\n    } while !messages.isEmpty\n}\n```\n\n#### Solution\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Dispatch] APIs to coordinate access to `messages` across multiple threads.\n\n### Access race with in-out parameters\n\nIn the following example, the `writeNumbers()` function writes numbers to a global string. The `writeLetters()` function writes letters to the same string. Because the two functions execute on different threads and both access `log` by reference using `inout,` there is an access race on `log`.\n\n```swift\nvar log: String = \"\"\n\/\/ Executed on Thread #1\nfunc writeNumbers() {\n    print(1, 2, 3, separator: \",\", to: &log)\n}\n\/\/ Executed on Thread #2\nfunc writeLetters() {\n    print(\"a\", \"b\", \"c\", separator:\",\", to: &log)\n}\n```\n\n#### Solution\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Dispatch] APIs to coordinate access to `log` across multiple threads.\n\n## Thread Sanitizer\n\n- **Data races**: Detects unsynchronized access to mutable state across multiple threads.\n- **Races on collections and other APIs**: Detects when one thread accesses a mutable object while another thread is writing to it.\n- **Uninitialized mutexes**: Detects when you use an uninitialized mutex.\n- **Thread leaks**: Detects when you don’t close threads after use.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Detects unsynchronized access to mutable state across multiple threads.",
          "name" : "Data races",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/data-races"
        },
        {
          "description" : "Detects when one thread accesses a mutable object while another thread is writing to it.",
          "name" : "Races on collections and other APIs",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/races-on-collections-and-other-apis"
        },
        {
          "description" : "Detects when you use an uninitialized mutex.",
          "name" : "Uninitialized mutexes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/uninitialized-mutexes"
        },
        {
          "description" : "Detects when you don’t close threads after use.",
          "name" : "Thread leaks",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/thread-leaks"
        }
      ],
      "title" : "Thread Sanitizer"
    }
  ],
  "source" : "appleJSON",
  "title" : "Swift access races",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/swift-access-races"
}