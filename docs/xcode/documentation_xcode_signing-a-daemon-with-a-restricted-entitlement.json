{
  "abstract" : "Wrap a daemon in an app-like structure to use an entitlement thatʼs authorized by a provisioning profile.",
  "codeExamples" : [
    {
      "code" : "import Foundation\n\n\/\/\/ A helper for calling the Security framework from Swift.\n\nfunc secCall<Result>(_ body: (_ resultPtr: UnsafeMutablePointer<Result?>) -> OSStatus  ) throws -> Result {\n    var result: Result? = nil\n    let err = body(&result)\n    guard err == errSecSuccess else {\n        throw NSError(domain: NSOSStatusErrorDomain, code: Int(err), userInfo: nil)\n    }\n    return result!\n}\n\nfunc main() throws {\n    let me = try secCall { SecCodeCopySelf([], $0) }\n    let meStatic = try secCall { SecCodeCopyStaticCode(me, [], $0) }\n    let infoCF = try secCall { SecCodeCopySigningInformation(meStatic, [], $0) }\n    let info = infoCF as NSDictionary\n    let entitlements = info[kSecCodeInfoEntitlementsDict] as? NSDictionary\n    NSLog(\"entitlements: %@\", entitlements ?? [:])\n}\n\ntry! main()",
      "language" : "swift"
    },
    {
      "code" : "2021-08-04 16:24:10.979941+0100 DaemonInAppsClothing[50219:4886989] entitlements: {\n    \"com.apple.application-identifier\" = \"SKMME9E2Y8.com.example.apple-samplecode.DaemonInAppsClothing\";\n    \"com.apple.developer.networking.custom-protocol\" = 1;\n    \"com.apple.developer.team-identifier\" = SKMME9E2Y8;\n    \"com.apple.security.get-task-allow\" = 1;\n}"
    },
    {
      "code" : "DaemonInAppsClothing.app\/\n  Contents\/\n    Info.plist\n    MacOS\/\n      DaemonInAppsClothing\n    PkgInfo\n    _CodeSignature\/\n      CodeResources\n    embedded.provisionprofile"
    },
    {
      "code" : "% sudo mkdir \"\/Library\/Application Support\/DaemonInAppsClothing\"\n% sudo cp -R \"DaemonInAppsClothing.app\" \"\/Library\/Application Support\/DaemonInAppsClothing\/\""
    },
    {
      "code" : "% \/usr\/libexec\/PlistBuddy -c \"Add :Label string com.example.apple-samplecode.DaemonInAppsClothing\" \"com.example.apple-samplecode.DaemonInAppsClothing.plist\"\nFile Doesn't Exist, Will Create: com.example.apple-samplecode.DaemonInAppsClothing.plist\n% \/usr\/libexec\/PlistBuddy -c 'Add :Program string \"\/Library\/Application Support\/DaemonInAppsClothing\/DaemonInAppsClothing.app\/Contents\/MacOS\/DaemonInAppsClothing\"' \"com.example.apple-samplecode.DaemonInAppsClothing.plist\"\n% cat com.example.apple-samplecode.DaemonInAppsClothing.plist \n…\n<dict>\n    <key>Label<\/key>\n    <string>com.example.apple-samplecode.DaemonInAppsClothing<\/string>\n    <key>Program<\/key>\n    <string>\/Library\/Application Support\/DaemonInAppsClothing\/DaemonInAppsClothing.app\/Contents\/MacOS\/DaemonInAppsClothing<\/string>\n<\/dict>\n<\/plist>"
    },
    {
      "code" : "% sudo cp com.example.apple-samplecode.DaemonInAppsClothing.plist \/Library\/LaunchDaemons \n% sudo launchctl load \/Library\/LaunchDaemons\/com.example.apple-samplecode.DaemonInAppsClothing.plist \n% sudo launchctl start com.example.apple-samplecode.DaemonInAppsClothing                      "
    },
    {
      "code" : "entitlements: {\n    \"com.apple.application-identifier\" = \"SKMME9E2Y8.com.example.apple-samplecode.DaemonInAppsClothing\";\n    \"com.apple.developer.networking.custom-protocol\" = 1;\n    \"com.apple.developer.team-identifier\" = SKMME9E2Y8;\n    \"com.apple.security.get-task-allow\" = 1;\n}"
    }
  ],
  "contentHash" : "8242067ef063d08b9e05bdd019e42ad6f0ccd12319c2ebed718ed51312c6ca0a",
  "crawledAt" : "2025-12-03T19:58:57Z",
  "id" : "D783D30E-D51D-4050-AB5E-F4632779F826",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nSome APIs are usable from a daemon but require that the daemon claim a restricted entitlement thatʼs authorized by a provisioning profile. For example, the [doc:\/\/com.apple.documentation\/documentation\/EndpointSecurity] API is usable from a daemon but requires that the daemon has the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.endpoint-security.client] entitlement, and that it’s authorized by a provisioning profile. This is problematic because a daemon is a standalone executable, so you canʼt embed a provisioning profile in it. To get around this limitation, wrap your daemon in an app-like structure.\n\n### Create a minimal daemon project\n\nThe basic idea is to create an app target, rather than a command-line tool target, and then remove all of the app-specific content and replace it with your daemon code. To start, create a new project with an app target by choosing File > New > Project and selecting the macOS > App template. Set the Interface popup to Storyboard, the Life Cycle popup (if present) to AppKit App Delegate, and the Language popup to Swift.\n\nIn the General tab of the target editor, ensure that the Bundle Identifier field has the right value.  This is important because your provisioning profile is tied to your App ID, and the bundle identifier is a key part of that App ID.\n\nAlso, clear the Deployment Info > Main Interface field and set the App Icons > Source popup to “Donʼt use asset catalogs”.\n\nSwitch to the Signing & Capabilities tab and configure it as follows:\n\nSwitch to the Build Settings tab and remove the Enable App Sandbox (`ENABLE_APP_SANDBOX`) build setting, if present.\n\nSwitch to the Info tab and delete all the app-specific items ([doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSPrincipalClass], [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSMainStoryboardFile], [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSSupportsSuddenTermination], `NSSupportsAutomaticTermination`, and [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/CFBundleIconFile]).  Some of these items may not be present, depending on the exact version of Xcode youʼre using.\n\nIn the Project navigator, remove the `AppDelegate.swift`, `ViewController.swift`, `Assets.xcassets`, and `Main.storyboard` files.\n\nAdd a `main.swift` file and populate it with your daemon code.  For a minimal daemon, use this:\n\nThis code logs the current processʼs entitlements, which is a good way to confirm that youʼre set up correctly.\n\nBuild and run the daemon from Xcode.  The program logs its entitlements:\n\nThe final structure of your daemon should look like this:\n\nNote the presence of the embedded provisioning profile; itʼs this profile that authorizes your daemon to use the `com.apple.developer.networking.custom-protocol` entitlement.\n\n### Test your daemon\n\nTo properly test your daemon, run it in a daemon context.  First, copy the built daemon to a secure location:\n\nNow create a `launchd` property list file that points to the daemonʼs main executable:\n\nCopy that to `\/Library\/LaunchDaemons` and then load and start your daemon:\n\nRun the Console app and look in the system log.  At the point when you started the daemon, youʼll see a log entry like this:\n\nIf you miss it, run the `launchctl start` command to start your daemon again.\n\n### Integrate your daemon code\n\nNow that you have a working minimal daemon, itʼs time to integrate your real daemon code into the project.  Add your code to the project as you would with any other Xcode project.  If necessary, replace `main.swift` with a C, C++, Objective-C, or Objective-C++ main entry point.\n\nOr, if youʼre using an alternative build system, like a makefile, update it to create a structure that matches the one created by Xcode.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/signing-a-daemon-with-a-restricted-entitlement\ncrawled: 2025-12-03T19:58:57Z\n---\n\n# Signing a daemon with a restricted entitlement\n\n**Article**\n\nWrap a daemon in an app-like structure to use an entitlement thatʼs authorized by a provisioning profile.\n\n## Overview\n\nSome APIs are usable from a daemon but require that the daemon claim a restricted entitlement thatʼs authorized by a provisioning profile. For example, the [doc:\/\/com.apple.documentation\/documentation\/EndpointSecurity] API is usable from a daemon but requires that the daemon has the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.endpoint-security.client] entitlement, and that it’s authorized by a provisioning profile. This is problematic because a daemon is a standalone executable, so you canʼt embed a provisioning profile in it. To get around this limitation, wrap your daemon in an app-like structure.\n\n\n\n### Create a minimal daemon project\n\nThe basic idea is to create an app target, rather than a command-line tool target, and then remove all of the app-specific content and replace it with your daemon code. To start, create a new project with an app target by choosing File > New > Project and selecting the macOS > App template. Set the Interface popup to Storyboard, the Life Cycle popup (if present) to AppKit App Delegate, and the Language popup to Swift.\n\n\n\nIn the General tab of the target editor, ensure that the Bundle Identifier field has the right value.  This is important because your provisioning profile is tied to your App ID, and the bundle identifier is a key part of that App ID.\n\nAlso, clear the Deployment Info > Main Interface field and set the App Icons > Source popup to “Donʼt use asset catalogs”.\n\nSwitch to the Signing & Capabilities tab and configure it as follows:\n\n- Ensure that “Automatically manage signing” is set.\n- Select your team in the Team popup.\n- Remove the App Sandbox capability (if present).  The App Sandbox is, as the name suggests, not appropriate for daemons.\n- Add the Hardened Runtime capability, which youʼll need to notarize your daemon.\n- Add the Custom Network Protocol capability, which enables the `com.apple.developer.networking.custom-protocol` entitlement that must be authorized by a provisioning profile. Adding it to your target triggers Xcodeʼs automatic code-signing machinery to register your App ID, create a provisioning profile for that App ID, and embed that provisioning profile in the built product.\n\n\n\nSwitch to the Build Settings tab and remove the Enable App Sandbox (`ENABLE_APP_SANDBOX`) build setting, if present.\n\nSwitch to the Info tab and delete all the app-specific items ([doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSPrincipalClass], [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSMainStoryboardFile], [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSSupportsSuddenTermination], `NSSupportsAutomaticTermination`, and [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/CFBundleIconFile]).  Some of these items may not be present, depending on the exact version of Xcode youʼre using.\n\nIn the Project navigator, remove the `AppDelegate.swift`, `ViewController.swift`, `Assets.xcassets`, and `Main.storyboard` files.\n\nAdd a `main.swift` file and populate it with your daemon code.  For a minimal daemon, use this:\n\n```swift\nimport Foundation\n\n\/\/\/ A helper for calling the Security framework from Swift.\n\nfunc secCall<Result>(_ body: (_ resultPtr: UnsafeMutablePointer<Result?>) -> OSStatus  ) throws -> Result {\n    var result: Result? = nil\n    let err = body(&result)\n    guard err == errSecSuccess else {\n        throw NSError(domain: NSOSStatusErrorDomain, code: Int(err), userInfo: nil)\n    }\n    return result!\n}\n\nfunc main() throws {\n    let me = try secCall { SecCodeCopySelf([], $0) }\n    let meStatic = try secCall { SecCodeCopyStaticCode(me, [], $0) }\n    let infoCF = try secCall { SecCodeCopySigningInformation(meStatic, [], $0) }\n    let info = infoCF as NSDictionary\n    let entitlements = info[kSecCodeInfoEntitlementsDict] as? NSDictionary\n    NSLog(\"entitlements: %@\", entitlements ?? [:])\n}\n\ntry! main()\n```\n\nThis code logs the current processʼs entitlements, which is a good way to confirm that youʼre set up correctly.\n\nBuild and run the daemon from Xcode.  The program logs its entitlements:\n\n```\n2021-08-04 16:24:10.979941+0100 DaemonInAppsClothing[50219:4886989] entitlements: {\n    \"com.apple.application-identifier\" = \"SKMME9E2Y8.com.example.apple-samplecode.DaemonInAppsClothing\";\n    \"com.apple.developer.networking.custom-protocol\" = 1;\n    \"com.apple.developer.team-identifier\" = SKMME9E2Y8;\n    \"com.apple.security.get-task-allow\" = 1;\n}\n```\n\nThe final structure of your daemon should look like this:\n\n```\nDaemonInAppsClothing.app\/\n  Contents\/\n    Info.plist\n    MacOS\/\n      DaemonInAppsClothing\n    PkgInfo\n    _CodeSignature\/\n      CodeResources\n    embedded.provisionprofile\n```\n\nNote the presence of the embedded provisioning profile; itʼs this profile that authorizes your daemon to use the `com.apple.developer.networking.custom-protocol` entitlement.\n\n### Test your daemon\n\nTo properly test your daemon, run it in a daemon context.  First, copy the built daemon to a secure location:\n\n```\n% sudo mkdir \"\/Library\/Application Support\/DaemonInAppsClothing\"\n% sudo cp -R \"DaemonInAppsClothing.app\" \"\/Library\/Application Support\/DaemonInAppsClothing\/\"\n```\n\nNow create a `launchd` property list file that points to the daemonʼs main executable:\n\n```\n% \/usr\/libexec\/PlistBuddy -c \"Add :Label string com.example.apple-samplecode.DaemonInAppsClothing\" \"com.example.apple-samplecode.DaemonInAppsClothing.plist\"\nFile Doesn't Exist, Will Create: com.example.apple-samplecode.DaemonInAppsClothing.plist\n% \/usr\/libexec\/PlistBuddy -c 'Add :Program string \"\/Library\/Application Support\/DaemonInAppsClothing\/DaemonInAppsClothing.app\/Contents\/MacOS\/DaemonInAppsClothing\"' \"com.example.apple-samplecode.DaemonInAppsClothing.plist\"\n% cat com.example.apple-samplecode.DaemonInAppsClothing.plist \n…\n<dict>\n    <key>Label<\/key>\n    <string>com.example.apple-samplecode.DaemonInAppsClothing<\/string>\n    <key>Program<\/key>\n    <string>\/Library\/Application Support\/DaemonInAppsClothing\/DaemonInAppsClothing.app\/Contents\/MacOS\/DaemonInAppsClothing<\/string>\n<\/dict>\n<\/plist>\n```\n\nCopy that to `\/Library\/LaunchDaemons` and then load and start your daemon:\n\n```\n% sudo cp com.example.apple-samplecode.DaemonInAppsClothing.plist \/Library\/LaunchDaemons \n% sudo launchctl load \/Library\/LaunchDaemons\/com.example.apple-samplecode.DaemonInAppsClothing.plist \n% sudo launchctl start com.example.apple-samplecode.DaemonInAppsClothing                      \n```\n\nRun the Console app and look in the system log.  At the point when you started the daemon, youʼll see a log entry like this:\n\n```\nentitlements: {\n    \"com.apple.application-identifier\" = \"SKMME9E2Y8.com.example.apple-samplecode.DaemonInAppsClothing\";\n    \"com.apple.developer.networking.custom-protocol\" = 1;\n    \"com.apple.developer.team-identifier\" = SKMME9E2Y8;\n    \"com.apple.security.get-task-allow\" = 1;\n}\n```\n\nIf you miss it, run the `launchctl start` command to start your daemon again.\n\n### Integrate your daemon code\n\nNow that you have a working minimal daemon, itʼs time to integrate your real daemon code into the project.  Add your code to the project as you would with any other Xcode project.  If necessary, replace `main.swift` with a C, C++, Objective-C, or Objective-C++ main entry point.\n\nOr, if youʼre using an alternative build system, like a makefile, update it to create a structure that matches the one created by Xcode.\n\n## Code signing\n\n- **Creating distribution-signed code for macOS**: Sign Mac code for distribution using either Xcode or command-line tools.\n- **Using the latest code signature format**: Update legacy app code signatures so your app runs on current OS releases.\n- **Notarizing macOS software before distribution**: Give users even more confidence in your macOS software by submitting it to Apple for notarization.\n- **Synchronizing code signing identities with your developer account**: Ensure you and other team members can sign your organization’s code and installer packages in Xcode.\n- **TN3125: Inside Code Signing: Provisioning Profiles**: Learn how provisioning profiles enable third-party code to run on Apple platforms.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Sign Mac code for distribution using either Xcode or command-line tools.",
          "name" : "Creating distribution-signed code for macOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/creating-distribution-signed-code-for-the-mac"
        },
        {
          "description" : "Update legacy app code signatures so your app runs on current OS releases.",
          "name" : "Using the latest code signature format",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/using-the-latest-code-signature-format"
        },
        {
          "description" : "Give users even more confidence in your macOS software by submitting it to Apple for notarization.",
          "name" : "Notarizing macOS software before distribution",
          "url" : "https:\/\/developer.apple.com\/documentation\/Security\/notarizing-macos-software-before-distribution"
        },
        {
          "description" : "Ensure you and other team members can sign your organization’s code and installer packages in Xcode.",
          "name" : "Synchronizing code signing identities with your developer account",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/sharing-your-teams-signing-certificates"
        },
        {
          "description" : "Learn how provisioning profiles enable third-party code to run on Apple platforms.",
          "name" : "TN3125: Inside Code Signing: Provisioning Profiles",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3125-inside-code-signing-provisioning-profiles"
        }
      ],
      "title" : "Code signing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Signing a daemon with a restricted entitlement",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/signing-a-daemon-with-a-restricted-entitlement"
}