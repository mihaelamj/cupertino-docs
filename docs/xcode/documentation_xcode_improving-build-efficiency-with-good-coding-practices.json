{
  "abstract" : "Shorten compile times by reducing the number of symbols your code exports and by giving the compiler the explicit information it needs.",
  "codeExamples" : [
    {
      "code" : "\/\/ Imports the framework’s module map\n#import <UIKit\/UIKit.h>\n#import <PetKit\/PetKit.h>     \/\/ Custom framework\n\n\/\/ Performs a textual inclusion of the header file.\n#import \"MyHeader.h\"\n",
      "language" : "occ"
    },
    {
      "code" : "struct ContrivedExample {\n   var bigNumber = [4, 3, 2].reduce(1) {\n      soFar, next in\n      pow(next, soFar)\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ContrivedExample {\n   var bigNumber : Double = [4, 3, 2].reduce(1) {\n      soFar, next in\n      pow(next, soFar)\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "weak var delegate: AnyObject?\nfunc reportSuccess() {\n   delegate?.myOperationDidSucceed(self)\n}",
      "language" : "swift"
    },
    {
      "code" : "weak var delegate: MyOperationDelegate?\nfunc reportSuccess() {\n   delegate?.myOperationDidSucceed(self)\n}\n\nprotocol MyOperationDelegate {\n   func myOperationDidSucceed(_ operation: MyOperation)\n}",
      "language" : "swift"
    },
    {
      "code" : "func sumNonOptional(i: Int?, j: Int?, k: Int?) -> Int? {\n   return [i, j, k].reduce(0) {\n      soFar, next in\n      soFar != nil && next != nil ? soFar! + next! : (soFar != nil ? soFar! : (next != nil ? next! : nil))\n   }\n}",
      "language" : "swift"
    },
    {
      "code" : "func sumNonOptional(i: Int?, j: Int?, k: Int?) -> Int? {\n   return [i, j, k].reduce(0) {\n      soFar, next in\n      if let soFar = soFar {\n         if let next = next { return soFar + next }\n         return soFar\n      } else {\n         return next\n      }\n   }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "78f0d257388843280c3b9b77078e602908cfb4af490bb4688300871016ff7916",
  "crawledAt" : "2025-12-01T09:03:50Z",
  "id" : "AC416AE4-EA65-4EA5-854F-AD1C201DBE78",
  "kind" : "article",
  "overview" : "## Overview\n\nReducing build times by even a few seconds can have a significant impact over the course of development. Xcode does everything possible to build your code as fast as possible. It parallelizes build tasks and takes advantage of all available resources to output a finished product. However, you can help Xcode by making sure you’re not creating unnecessary work for the compiler.\n\nOver the years, Xcode’s compiler has introduced optimizations to speed up compile times. Most of these optimizations are automatic, but some require you to make small changes to your code. In addition, projects that support both Objective-C code to Swift may require additional optimizations to ensure fast compile times.\n\n### Include framework names in import statements\n\nWhen you import headers into your source files, always include the name of the parent framework or library in your import statement. In C-based code, importing headers usually copies the contents of the header file into your source. When you include the framework name, the compiler has the option to use module maps to import the headers, which significantly reduces importation time. With module maps, the compiler loads and processes the framework’s header files once, and caches the resulting symbol information on disk. When you import the same framework from another source file, the compiler reuses the cached data, eliminating the need to again read and preprocess the header files.\n\nInclude framework names for both system frameworks and any custom frameworks you create in your projects. The following example shows import statements for both a system and custom framework, both of which have module maps. The last import statement continues to load and process the header file contents directly, rather than using an available module map.\n\nFor information about how to add a module map to your custom frameworks, see Create Module Maps for Custom Frameworks and Libraries.\n\n### Minimize the number of symbols you share between Swift and Objective-C\n\nWhen you mix Swift and Objective-C code in your project, your Swift code might need to know about portions of your Objective-C code, and vice versa. The compiler handles this exchange of symbol information using two special header files:\n\nReducing the size of both header files reduces the compiler’s workload and improves compilation times. A smaller file size means the compiler can process the headers more quickly. It also means faster symbol lookup times when compiling source files.\n\nWhen configuring the contents of your Objective-C bridging header, include only the headers and symbols you actually reference from your Swift source. If your Swift code uses only part of an Objective-C class, move the symbols your Swift code doesn’t use into categories in your implementation file or in an internal-only header file.\n\nThe following figure illustrates how you might separate the symbols you use externally from those your class uses internally. The `MyViewController.h` header contains only the subset of symbols you reference publicly from your Swift code. The `MyViewController-Internal.h` header includes the remaining symbols in category extensions on your class. Include both headers in your Objective-C implementation file, but include only the public header in your Objective-C bridging file.\n\n\n\nThe compiler makes all of your public Swift symbols available to your Objective-C code automatically using a generated header. To minimize the size of this generated header, update your Swift code in the following ways:\n\n### Provide the Swift compiler with explicit type information\n\nThe Swift compiler is capable of inferring the type of a variable from the value you assign to it. For simple values, the inference process is quick. For example, if you assign the value `0.0` to a property, the compiler can quickly determine that the type is a floating-point number. However, if you assign a complex value to a variable, the compiler must perform extra work to compute any type information.\n\nConsider the following structure, in which the `bigNumber` property has no explicit type information. To determine the type of that property, the Swift compiler must evaluate the results of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array\/reduce(_:_:)] function, which takes a nontrivial amount of time.\n\nInstead of letting the compiler determine the type, the best practice is to provide the type explicitly as shown in the example below. Providing explicit type information reduces the work the compiler must do, and also allows it to do more error checking.\n\n### Define delegate methods in explicit protocols\n\nDelegates are a standard design pattern on Apple platforms, and provide a useful way to communicate between objects. Although delegation enables communication between arbitrary objects, always provide explicit type information for your delegate objects.\n\nConsider the following example of a delegate declared as an optional object of any type. Although this declaration is perfectly legal, it actually creates more work for the compiler. The compiler must assume that any object in your project or referenced frameworks contains the function, and so it searches your entire project to make sure that function exists somewhere.\n\nInstead of using any object, a better approach is to supply specific type information. Typically, you specify the type information using a delegate protocol, as shown in the example below. An explicit protocol helps the compiler find the method more quickly. It also allows the compiler to perform additional type checking for objects you assign to the `delegate` property.\n\n### Simplify complex Swift expressions\n\nThe Swift language allows you to write code in very expressive ways, but make sure your code doesn’t affect compile times. Consider an example of a function that uses the `reduce` function to sum a set of values. If you pass `nil` for all the arguments, the function returns `nil`, but if you pass one or more arguments, it sums the sum of those arguments. The function takes advantage of a Swift feature, in which the compiler uses the one-line expression in the closure to determine the return type of that closure.\n\nAlthough this function represents legal Swift syntax, the one-line closure makes the code hard to read and harder for the compiler to evaluate. In fact, the compiler aborts with an error that states it cannot type-check the expression in a reasonable amount of time. The one-line closure is also unnecessary. The definition of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array\/reduce(_:_:)] function causes it to return the same type you pass in, which in this case is an optional integer.\n\nRather than use such a complex expression, it’s better to create something simpler and more readable. The following code offers the same behavior as the single-line closure version, but is easier to read and compiles quickly.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/improving-build-efficiency-with-good-coding-practices\ncrawled: 2025-12-01T09:03:50Z\n---\n\n# Improving build efficiency with good coding practices\n\n**Article**\n\nShorten compile times by reducing the number of symbols your code exports and by giving the compiler the explicit information it needs.\n\n## Overview\n\nReducing build times by even a few seconds can have a significant impact over the course of development. Xcode does everything possible to build your code as fast as possible. It parallelizes build tasks and takes advantage of all available resources to output a finished product. However, you can help Xcode by making sure you’re not creating unnecessary work for the compiler.\n\nOver the years, Xcode’s compiler has introduced optimizations to speed up compile times. Most of these optimizations are automatic, but some require you to make small changes to your code. In addition, projects that support both Objective-C code to Swift may require additional optimizations to ensure fast compile times.\n\n\n\n### Include framework names in import statements\n\nWhen you import headers into your source files, always include the name of the parent framework or library in your import statement. In C-based code, importing headers usually copies the contents of the header file into your source. When you include the framework name, the compiler has the option to use module maps to import the headers, which significantly reduces importation time. With module maps, the compiler loads and processes the framework’s header files once, and caches the resulting symbol information on disk. When you import the same framework from another source file, the compiler reuses the cached data, eliminating the need to again read and preprocess the header files.\n\nInclude framework names for both system frameworks and any custom frameworks you create in your projects. The following example shows import statements for both a system and custom framework, both of which have module maps. The last import statement continues to load and process the header file contents directly, rather than using an available module map.\n\n```occ\n\/\/ Imports the framework’s module map\n#import <UIKit\/UIKit.h>\n#import <PetKit\/PetKit.h>     \/\/ Custom framework\n\n\/\/ Performs a textual inclusion of the header file.\n#import \"MyHeader.h\"\n\n```\n\nFor information about how to add a module map to your custom frameworks, see Create Module Maps for Custom Frameworks and Libraries.\n\n### Minimize the number of symbols you share between Swift and Objective-C\n\nWhen you mix Swift and Objective-C code in your project, your Swift code might need to know about portions of your Objective-C code, and vice versa. The compiler handles this exchange of symbol information using two special header files:\n\n- The Objective-C bridging header determines which Objective-C symbols you make available to your Swift code.\n- The compiler-generated Swift header is a list of all public Swift symbols you can use in your Objective-C code.\n\nReducing the size of both header files reduces the compiler’s workload and improves compilation times. A smaller file size means the compiler can process the headers more quickly. It also means faster symbol lookup times when compiling source files.\n\nWhen configuring the contents of your Objective-C bridging header, include only the headers and symbols you actually reference from your Swift source. If your Swift code uses only part of an Objective-C class, move the symbols your Swift code doesn’t use into categories in your implementation file or in an internal-only header file.\n\nThe following figure illustrates how you might separate the symbols you use externally from those your class uses internally. The `MyViewController.h` header contains only the subset of symbols you reference publicly from your Swift code. The `MyViewController-Internal.h` header includes the remaining symbols in category extensions on your class. Include both headers in your Objective-C implementation file, but include only the public header in your Objective-C bridging file.\n\n\n\nThe compiler makes all of your public Swift symbols available to your Objective-C code automatically using a generated header. To minimize the size of this generated header, update your Swift code in the following ways:\n\n- Mark internal methods and properties of your Swift classes as `private`. The presence of that keyword prevents the inclusion of the symbol in the generated header file.\n- Choose block-based APIs over function-based APIs. Blocks are part of your implementation, and don’t generate public symbol information.\n- Support the most-recent version of the Swift language. Swift 3 and earlier automatically infer Objective-C type information for most symbols, which increases the size of the generated header. Later versions of Swift perform automatic type inference in fewer situations, reducing the overall size of the header.\n\n### Provide the Swift compiler with explicit type information\n\nThe Swift compiler is capable of inferring the type of a variable from the value you assign to it. For simple values, the inference process is quick. For example, if you assign the value `0.0` to a property, the compiler can quickly determine that the type is a floating-point number. However, if you assign a complex value to a variable, the compiler must perform extra work to compute any type information.\n\nConsider the following structure, in which the `bigNumber` property has no explicit type information. To determine the type of that property, the Swift compiler must evaluate the results of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array\/reduce(_:_:)] function, which takes a nontrivial amount of time.\n\n```swift\nstruct ContrivedExample {\n   var bigNumber = [4, 3, 2].reduce(1) {\n      soFar, next in\n      pow(next, soFar)\n   }\n}\n```\n\nInstead of letting the compiler determine the type, the best practice is to provide the type explicitly as shown in the example below. Providing explicit type information reduces the work the compiler must do, and also allows it to do more error checking.\n\n```swift\nstruct ContrivedExample {\n   var bigNumber : Double = [4, 3, 2].reduce(1) {\n      soFar, next in\n      pow(next, soFar)\n   }\n}\n```\n\n### Define delegate methods in explicit protocols\n\nDelegates are a standard design pattern on Apple platforms, and provide a useful way to communicate between objects. Although delegation enables communication between arbitrary objects, always provide explicit type information for your delegate objects.\n\nConsider the following example of a delegate declared as an optional object of any type. Although this declaration is perfectly legal, it actually creates more work for the compiler. The compiler must assume that any object in your project or referenced frameworks contains the function, and so it searches your entire project to make sure that function exists somewhere.\n\n```swift\nweak var delegate: AnyObject?\nfunc reportSuccess() {\n   delegate?.myOperationDidSucceed(self)\n}\n```\n\nInstead of using any object, a better approach is to supply specific type information. Typically, you specify the type information using a delegate protocol, as shown in the example below. An explicit protocol helps the compiler find the method more quickly. It also allows the compiler to perform additional type checking for objects you assign to the `delegate` property.\n\n```swift\nweak var delegate: MyOperationDelegate?\nfunc reportSuccess() {\n   delegate?.myOperationDidSucceed(self)\n}\n\nprotocol MyOperationDelegate {\n   func myOperationDidSucceed(_ operation: MyOperation)\n}\n```\n\n### Simplify complex Swift expressions\n\nThe Swift language allows you to write code in very expressive ways, but make sure your code doesn’t affect compile times. Consider an example of a function that uses the `reduce` function to sum a set of values. If you pass `nil` for all the arguments, the function returns `nil`, but if you pass one or more arguments, it sums the sum of those arguments. The function takes advantage of a Swift feature, in which the compiler uses the one-line expression in the closure to determine the return type of that closure.\n\n```swift\nfunc sumNonOptional(i: Int?, j: Int?, k: Int?) -> Int? {\n   return [i, j, k].reduce(0) {\n      soFar, next in\n      soFar != nil && next != nil ? soFar! + next! : (soFar != nil ? soFar! : (next != nil ? next! : nil))\n   }\n}\n```\n\nAlthough this function represents legal Swift syntax, the one-line closure makes the code hard to read and harder for the compiler to evaluate. In fact, the compiler aborts with an error that states it cannot type-check the expression in a reasonable amount of time. The one-line closure is also unnecessary. The definition of the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array\/reduce(_:_:)] function causes it to return the same type you pass in, which in this case is an optional integer.\n\nRather than use such a complex expression, it’s better to create something simpler and more readable. The following code offers the same behavior as the single-line closure version, but is easier to read and compiles quickly.\n\n```swift\nfunc sumNonOptional(i: Int?, j: Int?, k: Int?) -> Int? {\n   return [i, j, k].reduce(0) {\n      soFar, next in\n      if let soFar = soFar {\n         if let next = next { return soFar + next }\n         return soFar\n      } else {\n         return next\n      }\n   }\n}\n```\n\n## Performance\n\n- **Configuring your project to use mergeable libraries**: Use mergeable dynamic libraries to get app launch times similar to static linking in release builds, without losing dynamically linked build times in debug builds.\n- **Improving the speed of incremental builds**: Tell the Xcode build system about your project’s target-related dependencies, and reduce the compiler workload during each build cycle.\n- **Building your project with explicit module dependencies**: Reduce compile times by eliminating unnecessary module variants using the Xcode build system.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use mergeable dynamic libraries to get app launch times similar to static linking in release builds, without losing dynamically linked build times in debug builds.",
          "name" : "Configuring your project to use mergeable libraries",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/configuring-your-project-to-use-mergeable-libraries"
        },
        {
          "description" : "Tell the Xcode build system about your project’s target-related dependencies, and reduce the compiler workload during each build cycle.",
          "name" : "Improving the speed of incremental builds",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/improving-the-speed-of-incremental-builds"
        },
        {
          "description" : "Reduce compile times by eliminating unnecessary module variants using the Xcode build system.",
          "name" : "Building your project with explicit module dependencies",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/building-your-project-with-explicit-module-dependencies"
        }
      ],
      "title" : "Performance"
    }
  ],
  "source" : "appleJSON",
  "title" : "Improving build efficiency with good coding practices",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/improving-build-efficiency-with-good-coding-practices"
}