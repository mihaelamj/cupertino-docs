{
  "abstract" : "Include test targets that build code to test the logic in your functions, check for integration issues, automate UI workflows, and measure performance.",
  "codeExamples" : [
    {
      "code" : "class MyUITests: XCTestCase {\n    let app = XCUIApplication()\n\n    \/\/ MARK: - Setup and Teardown\n        \n    override func setUp() {\n        super.setUp()\n        \/\/ In UI tests, it's prudent to stop the test immediately if a failure occurs.\n        continueAfterFailure = false\n        \/\/ UI tests must launch the app that they test. Do this in setup to ensure that it the app launches for each test method.\n        XCUIApplication().launch()\n    }\n\n    override func tearDown() {\n        \/\/ Put teardown code here. The test runner calls this method after the invocation of each test method in the class.\n        super.tearDown()\n    }\n    \n    func testAddition() {\n        \/\/ Perform UI actions to accomplish a task.\n        \/\/ Check the expected state UI value.\n        if let value = app.<ui_type>[<ui_identifier>].value as? String {\n            XCTAssertTrue(value = \/* … *\/, \"The function didn't return the expected result\")\n        }        \n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class PerformanceTests : XCTestCase {\n    func testCodeIsFastEnough() {\n        self.measure() {\n          \/\/ Place performance-sensitive code here.\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "7868f84108393cec8796a95d82bf956f67720de188b7f5ac0da20efbc5f74eb7",
  "crawledAt" : "2025-12-02T16:43:30Z",
  "id" : "F6BD88CA-A228-4271-91A7-D7619C38BCA9",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nWhen creating a new project in Xcode 16 and later, choose a Testing System from the pop-up menu in the options dialog and let Xcode configure your project with test bundles.\n\nXcode includes two testing frameworks:\n\nThe options for testing system are Swift Test with XCTest UI Tests and XCTests for Unit and UI Tests. After making a selection, Xcode adds two types of test targets to your project, one for your unit tests with a name ending in “Tests” and one for your UI tests with a name ending in “UITests”. You’ll find the matching name for each of these targets in the Project navigator, along with a template file you can use to start writing your first tests. Your testing system choice impacts the primary framework Xcode includes in the file template for unit tests. Previous versions of Xcode included these targets when you enabled the Include Tests option when creating a new project and included file templates that use XCTest.\n\n### Add a new testing target\n\nIf you need to add testing to additional targets or have an existing target you want to add tests to:\n\n### Write a unit test\n\nTo write a test, select a test file from your test target, and choose a type or function to write a unit test for. If you need to add a new test file to your target,  choose File > New > New File From Template, then select Swift Testing Unit Test or XCTest Unit Test to add a test file with the appropriate structure. The test function that implements the unit test has the following three steps, in order:\n\nIn Swift Testing, Test functions are just ordinary Swift functions that you add the the `Test` attribute to. They can be global functions or methods in a type. You can optionally identify suites, types that contain test functions, by marking them with the `Suite` attribute. You can mark them async or throws, or isolate them to a global actor.\n\nFor tests you create with XCTest, create a subclass of [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase] to contain test methods. Add a method to your `XCTestCase` subclass that takes no arguments and returns `Void`, giving the method a name that begins with the word “`test`”.\n\nCover multiple paths and test for each scenario. For example, if a function receives an optional parameter, test the parameter as `nil` and test a non-`nil` value. Identify the boundary cases and logical branches in your code, and write a unit test to cover each combination of these cases. To test multiple paths through a function or method in your project using Swift Testing, implement parameterized test functions. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Testing\/ParameterizedTesting]. In XCTest, each unit test should assert the expected behavior of a single path through a method or function in your project. To cover multiple paths, write one test for each scenario.\n\nFor more information on defining tests using Swift Testing, see [doc:\/\/com.apple.documentation\/documentation\/Testing\/DefiningTests]. For more information on defining tests using XCTest, see [doc:\/\/com.apple.documentation\/documentation\/XCTest\/defining-test-cases-and-test-methods].\n\n### Write an integration test\n\nIntegration tests look very similar to unit tests, use the same APIs, and follow the same Arrange-Act-Assert pattern. The difference between a unit test and an integration test is one of scale. While a unit test covers a very small part of your app’s logic, an integration test examines the behavior of a larger subsystem, or combination of classes and functions. In the Arrange step of an integration test, widen the scope of real project code that’s under test, using fewer stub objects.\n\nRather than trying to cover every different condition or boundary case as with unit tests, use integration tests to assert that components work together to achieve app goals in important situations. Examples include testing that a value received from a controller is stored in the model correctly, and that an error produced by a network request gets passed to and presented by the user interface.\n\n### Write a UI test\n\nUI tests work in a different way from unit and integration tests. The XCTest UI Test template for new files contains the common starting points for UI tests. You implement the UI tests for your app using XCTest in a subclass of [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase]. Rather than executing your app’s code directly, they use the app’s user-interface controls to determine whether the user can complete a specific task using the app.\n\nCreate UI tests to verify that the app can accomplish a tasks in response to user interactions, and that bugs haven’t been introduced that break the behavior of UI controls. UI tests that replicate real user activities provide confidence that the app can be used for its intended task. A UI test for a document-based app might verify that the user can create a new document, edit its content, then delete the document.\n\nTo create a UI test in a method on an `XCTestCase` subclass, record your interaction with the app using the Record UI Test feature in Xcode. Design UI tests to replicate the most critical workflows that would affect users if they broke, and to replay reported bugs to avoid regressions.\n\n\n\nWhen recording a workflow that exercises the functionality you’re testing, use the test assertion functions to ensure that the final state of the UI is what you’d expect, given the actions performed during the recorded interaction.\n\nWhere UI tests imitate complex workflows with multiple distinct steps, use [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTActivity] to organize and name the shared steps. Create helper methods to share implementations of activities that you use in multiple tests.\n\n### Write a performance test\n\nWrite performance tests to gather information on time taken, memory used, or data written, during the execution of a region of code. XCTest runs your code multiple times, measuring the requested metrics. You can set a baseline expectation for the metric, and if the measured value is significantly worse than the baseline, XCTest reports a test failure.\n\nTo test time taken by your code, call [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase\/measure(_:)] inside your test method, and run your app’s code inside the block argument to `measure(_:)`. To measure performance using other metrics, including memory use and amount of data written to disk, call [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase\/measure(metrics:block:)].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/adding-tests-to-your-xcode-project\ncrawled: 2025-12-02T16:43:30Z\n---\n\n# Adding tests to your Xcode project\n\n**Article**\n\nInclude test targets that build code to test the logic in your functions, check for integration issues, automate UI workflows, and measure performance.\n\n## Overview\n\nWhen creating a new project in Xcode 16 and later, choose a Testing System from the pop-up menu in the options dialog and let Xcode configure your project with test bundles.\n\nXcode includes two testing frameworks:\n\n\n\nThe options for testing system are Swift Test with XCTest UI Tests and XCTests for Unit and UI Tests. After making a selection, Xcode adds two types of test targets to your project, one for your unit tests with a name ending in “Tests” and one for your UI tests with a name ending in “UITests”. You’ll find the matching name for each of these targets in the Project navigator, along with a template file you can use to start writing your first tests. Your testing system choice impacts the primary framework Xcode includes in the file template for unit tests. Previous versions of Xcode included these targets when you enabled the Include Tests option when creating a new project and included file templates that use XCTest.\n\n### Add a new testing target\n\nIf you need to add testing to additional targets or have an existing target you want to add tests to:\n\n1. Chose File > New > Target.\n2. Type “Test” in the template filter.\n3. Select Unit Testing Bundle or UI Testing Bundle.\n4. Click Next.\n5. Fill out the options.\n6. Click Finish.\n\n\n\n### Write a unit test\n\nTo write a test, select a test file from your test target, and choose a type or function to write a unit test for. If you need to add a new test file to your target,  choose File > New > New File From Template, then select Swift Testing Unit Test or XCTest Unit Test to add a test file with the appropriate structure. The test function that implements the unit test has the following three steps, in order:\n\n1. **Arrange** — Create any objects or data structures that the code path you’re exercising uses. Replace complex dependencies with “stubs” that are easy to configure to ensure that tests run quickly and are deterministic. Adopting dependency injection and protocol-oriented programming ensures that relationships between objects in your app are sufficiently flexible to enable substitution of real implementations for stubs.\n2. **Act** — Call the method or function that you’re testing, using parameters and properties that you configure in the Arrange phase.\n3. **Assert** — Use [doc:\/\/com.apple.documentation\/documentation\/Testing\/Expectations] in Swift Testing or Test Assertions in [doc:\/\/com.apple.documentation\/documentation\/XCTest] to compare the behavior of the code you exercise in the Act phase with your expectations of what should happen. Any expectation whose condition is false causes a test to fail.\n\nIn Swift Testing, Test functions are just ordinary Swift functions that you add the the `Test` attribute to. They can be global functions or methods in a type. You can optionally identify suites, types that contain test functions, by marking them with the `Suite` attribute. You can mark them async or throws, or isolate them to a global actor.\n\nFor tests you create with XCTest, create a subclass of [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase] to contain test methods. Add a method to your `XCTestCase` subclass that takes no arguments and returns `Void`, giving the method a name that begins with the word “`test`”.\n\n\n\nCover multiple paths and test for each scenario. For example, if a function receives an optional parameter, test the parameter as `nil` and test a non-`nil` value. Identify the boundary cases and logical branches in your code, and write a unit test to cover each combination of these cases. To test multiple paths through a function or method in your project using Swift Testing, implement parameterized test functions. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Testing\/ParameterizedTesting]. In XCTest, each unit test should assert the expected behavior of a single path through a method or function in your project. To cover multiple paths, write one test for each scenario.\n\nFor more information on defining tests using Swift Testing, see [doc:\/\/com.apple.documentation\/documentation\/Testing\/DefiningTests]. For more information on defining tests using XCTest, see [doc:\/\/com.apple.documentation\/documentation\/XCTest\/defining-test-cases-and-test-methods].\n\n\n\n### Write an integration test\n\nIntegration tests look very similar to unit tests, use the same APIs, and follow the same Arrange-Act-Assert pattern. The difference between a unit test and an integration test is one of scale. While a unit test covers a very small part of your app’s logic, an integration test examines the behavior of a larger subsystem, or combination of classes and functions. In the Arrange step of an integration test, widen the scope of real project code that’s under test, using fewer stub objects.\n\nRather than trying to cover every different condition or boundary case as with unit tests, use integration tests to assert that components work together to achieve app goals in important situations. Examples include testing that a value received from a controller is stored in the model correctly, and that an error produced by a network request gets passed to and presented by the user interface.\n\n### Write a UI test\n\nUI tests work in a different way from unit and integration tests. The XCTest UI Test template for new files contains the common starting points for UI tests. You implement the UI tests for your app using XCTest in a subclass of [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase]. Rather than executing your app’s code directly, they use the app’s user-interface controls to determine whether the user can complete a specific task using the app.\n\nCreate UI tests to verify that the app can accomplish a tasks in response to user interactions, and that bugs haven’t been introduced that break the behavior of UI controls. UI tests that replicate real user activities provide confidence that the app can be used for its intended task. A UI test for a document-based app might verify that the user can create a new document, edit its content, then delete the document.\n\nTo create a UI test in a method on an `XCTestCase` subclass, record your interaction with the app using the Record UI Test feature in Xcode. Design UI tests to replicate the most critical workflows that would affect users if they broke, and to replay reported bugs to avoid regressions.\n\n\n\nWhen recording a workflow that exercises the functionality you’re testing, use the test assertion functions to ensure that the final state of the UI is what you’d expect, given the actions performed during the recorded interaction.\n\n```swift\nclass MyUITests: XCTestCase {\n    let app = XCUIApplication()\n\n    \/\/ MARK: - Setup and Teardown\n        \n    override func setUp() {\n        super.setUp()\n        \/\/ In UI tests, it's prudent to stop the test immediately if a failure occurs.\n        continueAfterFailure = false\n        \/\/ UI tests must launch the app that they test. Do this in setup to ensure that it the app launches for each test method.\n        XCUIApplication().launch()\n    }\n\n    override func tearDown() {\n        \/\/ Put teardown code here. The test runner calls this method after the invocation of each test method in the class.\n        super.tearDown()\n    }\n    \n    func testAddition() {\n        \/\/ Perform UI actions to accomplish a task.\n        \/\/ Check the expected state UI value.\n        if let value = app.<ui_type>[<ui_identifier>].value as? String {\n            XCTAssertTrue(value = \/* … *\/, \"The function didn't return the expected result\")\n        }        \n    }\n}\n```\n\nWhere UI tests imitate complex workflows with multiple distinct steps, use [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTActivity] to organize and name the shared steps. Create helper methods to share implementations of activities that you use in multiple tests.\n\n### Write a performance test\n\nWrite performance tests to gather information on time taken, memory used, or data written, during the execution of a region of code. XCTest runs your code multiple times, measuring the requested metrics. You can set a baseline expectation for the metric, and if the measured value is significantly worse than the baseline, XCTest reports a test failure.\n\nTo test time taken by your code, call [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase\/measure(_:)] inside your test method, and run your app’s code inside the block argument to `measure(_:)`. To measure performance using other metrics, including memory use and amount of data written to disk, call [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTestCase\/measure(metrics:block:)].\n\n```swift\nclass PerformanceTests : XCTestCase {\n    func testCodeIsFastEnough() {\n        self.measure() {\n          \/\/ Place performance-sensitive code here.\n        }\n    }\n}\n```\n\n## Test development\n\n- **Updating your existing codebase to accommodate unit tests**: Remove coupling between components to increase test coverage and reliability.\n- **Determining how much code your tests cover**: Use code coverage to focus new test development on areas that lack adequate testing.\n- **Improving code assessment by organizing tests into test plans**: Control the information you receive from your tests at different stages in the software engineering process by creating and configuring test plans.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Remove coupling between components to increase test coverage and reliability.",
          "name" : "Updating your existing codebase to accommodate unit tests",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/updating-your-existing-codebase-to-accommodate-unit-tests"
        },
        {
          "description" : "Use code coverage to focus new test development on areas that lack adequate testing.",
          "name" : "Determining how much code your tests cover",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/determining-how-much-code-your-tests-cover"
        },
        {
          "description" : "Control the information you receive from your tests at different stages in the software engineering process by creating and configuring test plans.",
          "name" : "Improving code assessment by organizing tests into test plans",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/organizing-tests-to-improve-feedback"
        }
      ],
      "title" : "Test development"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding tests to your Xcode project",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/adding-tests-to-your-xcode-project"
}