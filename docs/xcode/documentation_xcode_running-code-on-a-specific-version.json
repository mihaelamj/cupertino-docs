{
  "abstract" : "Add conditional compilation markers around code that requires a particular family of devices or minimum operating system version to run.",
  "codeExamples" : [
    {
      "code" : "\/\/\/ Swift\n\/\/\/ `iOS` specifies the operating system for which this code compiles. \n\/\/\/ Change `iOS` to specify another operating system.\n#if os(iOS)\n   \/\/ iOS code\n#endif",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Objective-C\n\/\/\/ `IOS` specifies the operating system for which this code compiles. \n\/\/\/ Change `IOS` to specify another operating system. For the list of \n\/\/\/ compilation macros, see the \/usr\/include\/TargetConditionals.h \n\/\/\/ header file in the appropriate SDK.\n#if TARGET_OS_IOS\n   \/\/ iOS code\n#endif",
      "language" : "objc"
    },
    {
      "code" : "\/\/\/ Swift\n\/\/\/ `simulator` specifies an environment to compile the code for. \n\/\/\/ Change `simulator` to specify another environment, such as `macCatalyst`.\n#if targetEnvironment(simulator)\n    \/\/ code for Simulator\n#endif\n",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Objective-C\n\/\/\/ `SIMULATOR` specifies an environment this code depends on. \n\/\/\/ Change `SIMULATOR` to specify another environment, such as `MACCATALYST`.\n#if TARGET_OS_SIMULATOR\n    \/\/ code for Simulator\n#endif",
      "language" : "objc"
    },
    {
      "code" : "\/\/\/ Swift\n\/\/\/ `UIKit` specifies a module this code depends on. \n\/\/\/ Change `UIKit` to specify another module.\n#if canImport(UIKit)\n    \/\/ code that requires UIKit\n#endif",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Swift\nif #available(iOS 15.4.1, *) {\n    \/\/ On iOS, this branch runs in versions 15.4.1 and greater. \n    \/\/ On any other OS, this branch runs in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS versions.\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/\/ Objective-C\nif (@available(iOS 15.4.1, *)) {\n    \/\/ On iOS, this branch runs in versions 15.4.1 and greater. \n    \/\/ On any other OS, this branch runs in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS versions.\n}",
      "language" : "objc"
    },
    {
      "code" : "\/\/ Swift\nif #available(iOS 15, macOS 12, *) {\n    \/\/ On iOS, this branch runs in iOS 15 or later.\n    \/\/ On macOS, this branch runs in macOS 12 or later.\n    \/\/ On any other OS, this branch will run in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS and macOS versions.\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Objective-C\nif (@available(iOS 15, macOS 12, *)) {\n    \/\/ On iOS, this branch runs in iOS 15 or later.\n    \/\/ On macOS, this branch runs in macOS 12 or later.\n    \/\/ On any other OS, this branch will run in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS and macOS versions.\n}",
      "language" : "objc"
    },
    {
      "code" : "@available(iOS 15, macOS 12, *)\nfunc newMethod() {\n    \/\/ Use iOS 15 APIs.\n}",
      "language" : "swift"
    },
    {
      "code" : "@interface MyViewController : UIViewController\n- (void) newMethod API_AVAILABLE(ios(15));\n@end",
      "language" : "objc"
    }
  ],
  "contentHash" : "c9dd4ef06f24e16dff6d44047dc937b3e904c46ce2434bfd008bb1a33dcb908c",
  "crawledAt" : "2025-12-02T06:10:45Z",
  "id" : "978A1BA4-C257-4F5F-A483-F2369A6C0B08",
  "kind" : "article",
  "overview" : "## Overview\n\nWhen you invest time developing a new feature for an app, you want to get the maximum value out of the code you write. Creating a new project to support a new platform or operating system version adds unnecessary work, especially if most of your code stays the same. The best solution is to maintain one version of your app that runs on multiple platforms and operating system versions. To achieve this, compile code conditionally for the target platform, or use availability condition checks to run code based on operating system version.\n\n### Compile code for a specific platform\n\nApple platforms support many of the same technologies, but some features might not be available on every platform. For example, features on iOS devices might not make sense on a macOS devices. To prevent code from compiling on an operating system that doesn’t support the corresponding feature, add a conditional compilation block to specify the target operating system.\n\nYou can also compile or prevent compiling for specific environments, such as Simulator or Mac Catalyst.\n\nIf your Swift code relies on a specific Swift package or framework, you can check to see whether you can import the package or framework. This condition tests whether it’s possible to import a module, but doesn’t actually import it. This type of check has the advantage that your code uses the package or framework if a future version of the operating system makes it available.\n\nFor more information on the compiler control statements and the platforms conditions they support, see [https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/statements\/#Compiler-Control-Statements] in the Swift language documentation.\n\n### Require a minimum operating system version for a feature\n\nYour app’s minimum deployment target defines the range of operating system versions your app supports. Rather than require the latest system software for each app update, target one or two older operating system versions to give people time to transition gradually. When you implement features found only in the most recent operating system version, wrap your code with availability markers.\n\nPlatform names support both major and minor revision numbers for releases, as shown in the following example:\n\nThe `*` matches any other operating system. To specify versions for multiple operating systems, include multiple operating system names separated by commas.\n\nFor more information on the availability condition statement, see [https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/statements\/#Availability-Condition] in the Swift language documentation.\n\n### Annotate declarations in your code\n\nYou can reduce the number of conditional runtime checks your app performs by factoring code with common requirements together and annotating your declarations.\n\nWith the above annotation in place, calling `newMethod` might still require a compiler control statement, but you remove the need to check again inside the body.\n\nFor more information about marking availability in Swift, see [https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/attributes\/#available].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/running-code-on-a-specific-version\ncrawled: 2025-12-02T06:10:45Z\n---\n\n# Running code on a specific platform or OS version\n\n**Article**\n\nAdd conditional compilation markers around code that requires a particular family of devices or minimum operating system version to run.\n\n## Overview\n\nWhen you invest time developing a new feature for an app, you want to get the maximum value out of the code you write. Creating a new project to support a new platform or operating system version adds unnecessary work, especially if most of your code stays the same. The best solution is to maintain one version of your app that runs on multiple platforms and operating system versions. To achieve this, compile code conditionally for the target platform, or use availability condition checks to run code based on operating system version.\n\n### Compile code for a specific platform\n\nApple platforms support many of the same technologies, but some features might not be available on every platform. For example, features on iOS devices might not make sense on a macOS devices. To prevent code from compiling on an operating system that doesn’t support the corresponding feature, add a conditional compilation block to specify the target operating system.\n\n```swift\n\/\/\/ Swift\n\/\/\/ `iOS` specifies the operating system for which this code compiles. \n\/\/\/ Change `iOS` to specify another operating system.\n#if os(iOS)\n   \/\/ iOS code\n#endif\n```\n\n```objc\n\/\/\/ Objective-C\n\/\/\/ `IOS` specifies the operating system for which this code compiles. \n\/\/\/ Change `IOS` to specify another operating system. For the list of \n\/\/\/ compilation macros, see the \/usr\/include\/TargetConditionals.h \n\/\/\/ header file in the appropriate SDK.\n#if TARGET_OS_IOS\n   \/\/ iOS code\n#endif\n```\n\nYou can also compile or prevent compiling for specific environments, such as Simulator or Mac Catalyst.\n\n```swift\n\/\/\/ Swift\n\/\/\/ `simulator` specifies an environment to compile the code for. \n\/\/\/ Change `simulator` to specify another environment, such as `macCatalyst`.\n#if targetEnvironment(simulator)\n    \/\/ code for Simulator\n#endif\n\n```\n\n```objc\n\/\/\/ Objective-C\n\/\/\/ `SIMULATOR` specifies an environment this code depends on. \n\/\/\/ Change `SIMULATOR` to specify another environment, such as `MACCATALYST`.\n#if TARGET_OS_SIMULATOR\n    \/\/ code for Simulator\n#endif\n```\n\nIf your Swift code relies on a specific Swift package or framework, you can check to see whether you can import the package or framework. This condition tests whether it’s possible to import a module, but doesn’t actually import it. This type of check has the advantage that your code uses the package or framework if a future version of the operating system makes it available.\n\n```swift\n\/\/\/ Swift\n\/\/\/ `UIKit` specifies a module this code depends on. \n\/\/\/ Change `UIKit` to specify another module.\n#if canImport(UIKit)\n    \/\/ code that requires UIKit\n#endif\n```\n\nFor more information on the compiler control statements and the platforms conditions they support, see [https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/statements\/#Compiler-Control-Statements] in the Swift language documentation.\n\n### Require a minimum operating system version for a feature\n\nYour app’s minimum deployment target defines the range of operating system versions your app supports. Rather than require the latest system software for each app update, target one or two older operating system versions to give people time to transition gradually. When you implement features found only in the most recent operating system version, wrap your code with availability markers.\n\n- In Swift, use the `#available` compiler control statement to run code conditionally.\n- In Objective-C, use the `@available` compiler directive to run code conditionally.\n\nPlatform names support both major and minor revision numbers for releases, as shown in the following example:\n\n```swift\n\/\/\/ Swift\nif #available(iOS 15.4.1, *) {\n    \/\/ On iOS, this branch runs in versions 15.4.1 and greater. \n    \/\/ On any other OS, this branch runs in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS versions.\n}\n```\n\n```objc\n\/\/\/ Objective-C\nif (@available(iOS 15.4.1, *)) {\n    \/\/ On iOS, this branch runs in versions 15.4.1 and greater. \n    \/\/ On any other OS, this branch runs in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS versions.\n}\n```\n\nThe `*` matches any other operating system. To specify versions for multiple operating systems, include multiple operating system names separated by commas.\n\n```swift\n\/\/ Swift\nif #available(iOS 15, macOS 12, *) {\n    \/\/ On iOS, this branch runs in iOS 15 or later.\n    \/\/ On macOS, this branch runs in macOS 12 or later.\n    \/\/ On any other OS, this branch will run in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS and macOS versions.\n}\n```\n\n```objc\n\/\/ Objective-C\nif (@available(iOS 15, macOS 12, *)) {\n    \/\/ On iOS, this branch runs in iOS 15 or later.\n    \/\/ On macOS, this branch runs in macOS 12 or later.\n    \/\/ On any other OS, this branch will run in any version of that OS.\n} else {\n   \/\/ This branch runs in earlier iOS and macOS versions.\n}\n```\n\nFor more information on the availability condition statement, see [https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/statements\/#Availability-Condition] in the Swift language documentation.\n\n### Annotate declarations in your code\n\nYou can reduce the number of conditional runtime checks your app performs by factoring code with common requirements together and annotating your declarations.\n\n- In Swift, use the `@available` attribute to indicate a declaration is available.\n- In Objective-C, use the `API_AVAILABLE` macro to add availability information.\n\n```swift\n@available(iOS 15, macOS 12, *)\nfunc newMethod() {\n    \/\/ Use iOS 15 APIs.\n}\n```\n\n```objc\n@interface MyViewController : UIViewController\n- (void) newMethod API_AVAILABLE(ios(15));\n@end\n```\n\nWith the above annotation in place, calling `newMethod` might still require a compiler control statement, but you remove the need to check again inside the body.\n\nFor more information about marking availability in Swift, see [https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/attributes\/#available].\n\n## Build customization\n\n- **Customizing the build schemes for a project**: Specify which targets to build, and customize the settings Xcode uses to build, run, test, and profile those targets.\n- **Customizing the build phases of a target**: Specify the tasks to perform during a build, including the source files to compile, the scripts to run, and the resources to include in the final product.\n- **Creating build rules for custom file types**: Tell Xcode how to build your project’s custom file types, and provide dependency information to optimize the build process for each file.\n- **Running custom scripts during a build**: Execute custom shell scripts during the build process, and run tools or other commands that your project requires.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Specify which targets to build, and customize the settings Xcode uses to build, run, test, and profile those targets.",
          "name" : "Customizing the build schemes for a project",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/customizing-the-build-schemes-for-a-project"
        },
        {
          "description" : "Specify the tasks to perform during a build, including the source files to compile, the scripts to run, and the resources to include in the final product.",
          "name" : "Customizing the build phases of a target",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/customizing-the-build-phases-of-a-target"
        },
        {
          "description" : "Tell Xcode how to build your project’s custom file types, and provide dependency information to optimize the build process for each file.",
          "name" : "Creating build rules for custom file types",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/creating-build-rules-for-custom-file-types"
        },
        {
          "description" : "Execute custom shell scripts during the build process, and run tools or other commands that your project requires.",
          "name" : "Running custom scripts during a build",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/running-custom-scripts-during-a-build"
        }
      ],
      "title" : "Build customization"
    }
  ],
  "source" : "appleJSON",
  "title" : "Running code on a specific platform or OS version",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/running-code-on-a-specific-version"
}