{
  "abstract" : "Identify the signature of a zombie and investigate the cause of the crash.",
  "codeExamples" : [
    {
      "code" : "Thread 0 Crashed:\n0   libobjc.A.dylib                   0x00000001a186d190 objc_msgSend + 16\n1   Foundation                        0x00000001a1f31238 __NSThreadPerformPerform + 232\n2   CoreFoundation                    0x00000001a1ac67e0 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24",
      "language" : "other"
    },
    {
      "code" : "Thread 2 Crashed:\n0   libobjc.A.dylib                 0x00007fff7478bd5c objc_release + 28\n1   libobjc.A.dylib                 0x00007fff7478cc8c (anonymous namespace)::AutoreleasePoolPage::pop(void*) + 726\n2   com.apple.CoreFoundation        0x00007fff485feee6 _CFAutoreleasePoolPop + 22",
      "language" : "other"
    },
    {
      "code" : "Last Exception Backtrace:\n0   CoreFoundation                    0x1bf596a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x1bf2bdfa4 objc_exception_throw + 55\n2   CoreFoundation                    0x1bf49a5a8 -[NSObject+ 193960 (NSObject) doesNotRecognizeSelector:] + 139",
      "language" : "other"
    },
    {
      "code" : "Terminating app due to uncaught exception 'NSInvalidArgumentException',\n    reason: '-[NSNumberFormatter playSound]: \n    unrecognized selector sent to instance 0x28360dac0'",
      "language" : "other"
    }
  ],
  "contentHash" : "52123b1993024497c8dc20ca5b0cd93e4c71ccf3a3713ac05c8f6327bf3f4220",
  "crawledAt" : "2025-12-05T12:37:35Z",
  "id" : "DCD9D841-67A9-443C-A3D7-1C8D34F06A4F",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nOnce an Objective-C or Swift object no longer has any strong references to it, the object is deallocated. Attempting to further send messages to the object as if it were still a valid object is a “use after free” issue, with the deallocated object still receiving messages called a *zombie object*.\n\n### Determine whether a crash report has signs of a zombie\n\nThe Objective-C runtime can’t message objects deallocated from memory, so crashes often occur in the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend], `objc_retain`, or `objc_release` functions. For example, a crash where the Objective-C runtime can’t send a message to the deallocated object looks like this:\n\nHere’s another example, where the Objective-C runtime tries to release an object that’s already released:\n\nAnother pattern that indicates a zombie object is a stack frame for an *unrecognized selector*, which is a method that an object doesn’t implement. Often this kind of crash looks like code where an unexpected type of object is asked to do something it obviously can’t do, such as a number formatter class trying to play a sound. This is because the operating system reused memory that once held the deallocated object, and that memory now contains a different kind of object. A zombie identified by an unrecognized selector has a call stack with the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/doesNotRecognizeSelector(_:)] method:\n\nIf you reproduce a crash like this when debugging, the console logs additional information:\n\nIn this example, a message was sent to a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] to perform the `playSound` selector, but [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] doesn’t implement a method with that name, so the app crashed. An object was previously allocated at the same memory address as the current [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] that did implement the `playSound` method, but that object was deallocated, and the unrelated [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] object is now using the same memory address. The `playSound` selector is a clue for debugging. If you identify the class implementing the `playSound` selector, you can identify the code paths that call it and determine why the expected object deallocated too early.\n\n### Investigate the source of the zombie\n\nIn cases where a crash is caused by a zombie object, stack frames from the app may be in the backtrace, but not always. Even if no backtrace frames reference code in your app, your code contributed to the creation of the zombie, so investigate the source of the zombie with the Zombies instrument, as described in [https:\/\/help.apple.com\/instruments\/mac\/current\/#\/dev612e6956]. As you use the Zombies instrument, look for answers to the following questions, so you have the information needed to modify your code and remove the zombie:\n\nWhen modifying your code, pay attention to the expected lifetime of the objects involved. Consider which objects use strong references, and which objects use weak or unowned references, so that objects are deallocated only when no longer needed and not too soon. See [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/ObjectiveC\/RN-TransitioningToARC\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40011226-CH1-SW13] for information about Automatic Reference Counting in Objective-C, and the [https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/AutomaticReferenceCounting.html] for information in Swift.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/investigating-crashes-for-zombie-objects\ncrawled: 2025-12-05T12:37:35Z\n---\n\n# Investigating crashes for zombie objects\n\n**Article**\n\nIdentify the signature of a zombie and investigate the cause of the crash.\n\n## Overview\n\nOnce an Objective-C or Swift object no longer has any strong references to it, the object is deallocated. Attempting to further send messages to the object as if it were still a valid object is a “use after free” issue, with the deallocated object still receiving messages called a *zombie object*.\n\n### Determine whether a crash report has signs of a zombie\n\nThe Objective-C runtime can’t message objects deallocated from memory, so crashes often occur in the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend], `objc_retain`, or `objc_release` functions. For example, a crash where the Objective-C runtime can’t send a message to the deallocated object looks like this:\n\n```other\nThread 0 Crashed:\n0   libobjc.A.dylib                   0x00000001a186d190 objc_msgSend + 16\n1   Foundation                        0x00000001a1f31238 __NSThreadPerformPerform + 232\n2   CoreFoundation                    0x00000001a1ac67e0 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24\n```\n\nHere’s another example, where the Objective-C runtime tries to release an object that’s already released:\n\n```other\nThread 2 Crashed:\n0   libobjc.A.dylib                 0x00007fff7478bd5c objc_release + 28\n1   libobjc.A.dylib                 0x00007fff7478cc8c (anonymous namespace)::AutoreleasePoolPage::pop(void*) + 726\n2   com.apple.CoreFoundation        0x00007fff485feee6 _CFAutoreleasePoolPop + 22\n```\n\nAnother pattern that indicates a zombie object is a stack frame for an *unrecognized selector*, which is a method that an object doesn’t implement. Often this kind of crash looks like code where an unexpected type of object is asked to do something it obviously can’t do, such as a number formatter class trying to play a sound. This is because the operating system reused memory that once held the deallocated object, and that memory now contains a different kind of object. A zombie identified by an unrecognized selector has a call stack with the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/doesNotRecognizeSelector(_:)] method:\n\n```other\nLast Exception Backtrace:\n0   CoreFoundation                    0x1bf596a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x1bf2bdfa4 objc_exception_throw + 55\n2   CoreFoundation                    0x1bf49a5a8 -[NSObject+ 193960 (NSObject) doesNotRecognizeSelector:] + 139\n```\n\nIf you reproduce a crash like this when debugging, the console logs additional information:\n\n```other\nTerminating app due to uncaught exception 'NSInvalidArgumentException',\n    reason: '-[NSNumberFormatter playSound]: \n    unrecognized selector sent to instance 0x28360dac0'\n```\n\nIn this example, a message was sent to a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] to perform the `playSound` selector, but [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] doesn’t implement a method with that name, so the app crashed. An object was previously allocated at the same memory address as the current [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] that did implement the `playSound` method, but that object was deallocated, and the unrelated [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NumberFormatter] object is now using the same memory address. The `playSound` selector is a clue for debugging. If you identify the class implementing the `playSound` selector, you can identify the code paths that call it and determine why the expected object deallocated too early.\n\n### Investigate the source of the zombie\n\nIn cases where a crash is caused by a zombie object, stack frames from the app may be in the backtrace, but not always. Even if no backtrace frames reference code in your app, your code contributed to the creation of the zombie, so investigate the source of the zombie with the Zombies instrument, as described in [https:\/\/help.apple.com\/instruments\/mac\/current\/#\/dev612e6956]. As you use the Zombies instrument, look for answers to the following questions, so you have the information needed to modify your code and remove the zombie:\n\n- What was the type of the deallocated object, and what message was sent to it?\n- When was the object actually deallocated?\n- How was the object used after it was deallocated?\n\nWhen modifying your code, pay attention to the expected lifetime of the objects involved. Consider which objects use strong references, and which objects use weak or unowned references, so that objects are deallocated only when no longer needed and not too soon. See [https:\/\/developer.apple.com\/library\/archive\/releasenotes\/ObjectiveC\/RN-TransitioningToARC\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40011226-CH1-SW13] for information about Automatic Reference Counting in Objective-C, and the [https:\/\/docs.swift.org\/swift-book\/LanguageGuide\/AutomaticReferenceCounting.html] for information in Swift.\n\n## Related Documentation\n\n- **Analyzing a crash report**: Identify clues in a crash report that help you diagnose problems.\n\n## Memory access errors\n\n- **Investigating memory access crashes**: Identify crashes that arise from memory access issues, and investigate the cause of the crash.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Identify clues in a crash report that help you diagnose problems.",
          "name" : "Analyzing a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/analyzing-a-crash-report"
        }
      ],
      "title" : "Related Documentation"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Identify crashes that arise from memory access issues, and investigate the cause of the crash.",
          "name" : "Investigating memory access crashes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/investigating-memory-access-crashes"
        }
      ],
      "title" : "Memory access errors"
    }
  ],
  "source" : "appleJSON",
  "title" : "Investigating crashes for zombie objects",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/investigating-crashes-for-zombie-objects"
}