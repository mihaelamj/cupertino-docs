{
  "abstract" : "Detects the use of deallocated memory.",
  "codeExamples" : [
    {
      "code" : "__unsafe_unretained MyClass *unsafePointer;\n@autoreleasepool {    \n    MyClass *object = [MyClass new];\n    unsafePointer = object;\n}\nNSLog(@\"%d\", unsafePointer->instanceVariable); \n\/\/ Error: unsafePointer is deallocated in autorelease pool",
      "language" : "occ"
    },
    {
      "code" : "int *unsafePointer;\n@autoreleasepool {    \n    MyClass *object = [MyClass new];\n    unsafePointer = &object->instanceVariable;\n}\nNSLog(@\"%d\", *unsafePointer);\n\/\/ Error: unsafePointer is invalidated when object is deallocated in autorelease pool",
      "language" : "occ"
    }
  ],
  "contentHash" : "11e5fff5b3a157cc86009c93f8efb54995a1d72d7a197f82bfe69a6dc7515562",
  "crawledAt" : "2025-12-04T01:08:44Z",
  "id" : "4365ADC0-5052-4B3A-B2BF-697A6588E6EB",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nUse this check to detect when your code accesses deallocated memory, which can lead to unpredictable behavior. Available in Xcode 7 and later.\n\n### Use of deallocated memory in Objective-C\n\nIn the following example, the `unsafePointer` variable has `__unsafe_unretained` ownership. Because there are no other objects that have a strong reference to it, the autorelease pool deallocates the variable, causing it to point to invalid memory.\n\n#### Solution\n\nUse a `__strong` or `__weak` reference instead of `__unsafe_unretained`. Strong ownership ensures that you, or the system, can only deallocate an object when no strong references exist. Weak ownership has no effect on the life cycle of the object it refers to, but ensures that a variable is `nil` when you deallocate the object, or the system deallocates it.\n\n### Use of deallocated pointer in Objective-C\n\nThis issue exists when using pointers to nonobject types, as well. In the following example, the pointer to the instance variable invalidates when deallocating the object:\n\n#### Solution\n\nUse property accessors rather than direct access to instance variables and pointers whenever possible.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/use-of-deallocated-memory\ncrawled: 2025-12-04T01:08:44Z\n---\n\n# Use of deallocated memory\n\n**Article**\n\nDetects the use of deallocated memory.\n\n## Overview\n\nUse this check to detect when your code accesses deallocated memory, which can lead to unpredictable behavior. Available in Xcode 7 and later.\n\n### Use of deallocated memory in Objective-C\n\nIn the following example, the `unsafePointer` variable has `__unsafe_unretained` ownership. Because there are no other objects that have a strong reference to it, the autorelease pool deallocates the variable, causing it to point to invalid memory.\n\n```occ\n__unsafe_unretained MyClass *unsafePointer;\n@autoreleasepool {    \n    MyClass *object = [MyClass new];\n    unsafePointer = object;\n}\nNSLog(@\"%d\", unsafePointer->instanceVariable); \n\/\/ Error: unsafePointer is deallocated in autorelease pool\n```\n\n#### Solution\n\nUse a `__strong` or `__weak` reference instead of `__unsafe_unretained`. Strong ownership ensures that you, or the system, can only deallocate an object when no strong references exist. Weak ownership has no effect on the life cycle of the object it refers to, but ensures that a variable is `nil` when you deallocate the object, or the system deallocates it.\n\n### Use of deallocated pointer in Objective-C\n\nThis issue exists when using pointers to nonobject types, as well. In the following example, the pointer to the instance variable invalidates when deallocating the object:\n\n```occ\nint *unsafePointer;\n@autoreleasepool {    \n    MyClass *object = [MyClass new];\n    unsafePointer = &object->instanceVariable;\n}\nNSLog(@\"%d\", *unsafePointer);\n\/\/ Error: unsafePointer is invalidated when object is deallocated in autorelease pool\n```\n\n#### Solution\n\nUse property accessors rather than direct access to instance variables and pointers whenever possible.\n\n## Address Sanitizer\n\n- **Deallocation of deallocated memory**: Detects attempts to free deallocated memory.\n- **Deallocation of nonallocated memory**: Detects attempts to free nonallocated memory.\n- **Use of stack memory after function return**: Detects when you access stack variable memory after its declaring function returns.\n- **Use of out-of-scope stack memory**: Detects access to variables outside of their declared scope.\n- **Overflow and underflow of buffers**: Detects when you access memory outside of a buffer’s boundaries.\n- **Overflow of C++ containers**: Detects when you access a C++ container outside its bounds.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Detects attempts to free deallocated memory.",
          "name" : "Deallocation of deallocated memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/deallocation-of-deallocated-memory"
        },
        {
          "description" : "Detects attempts to free nonallocated memory.",
          "name" : "Deallocation of nonallocated memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/deallocation-of-nonallocated-memory"
        },
        {
          "description" : "Detects when you access stack variable memory after its declaring function returns.",
          "name" : "Use of stack memory after function return",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/use-of-stack-memory-after-function-return"
        },
        {
          "description" : "Detects access to variables outside of their declared scope.",
          "name" : "Use of out-of-scope stack memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/use-of-out-of-scope-stack-memory"
        },
        {
          "description" : "Detects when you access memory outside of a buffer’s boundaries.",
          "name" : "Overflow and underflow of buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/overflow-and-underflow-of-buffers"
        },
        {
          "description" : "Detects when you access a C++ container outside its bounds.",
          "name" : "Overflow of C++ containers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/overflow-of-c-containers"
        }
      ],
      "title" : "Address Sanitizer"
    }
  ],
  "source" : "appleJSON",
  "title" : "Use of deallocated memory",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/use-of-deallocated-memory"
}