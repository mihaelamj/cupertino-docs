{
  "abstract" : "Remove coupling between components to increase test coverage and reliability.",
  "codeExamples" : [
    {
      "code" : "private enum AttachmentOpeningError: Error {\n    case unableToOpenAttachment\n}\n\nstruct AttachmentOpener {\n  func openAttachment(file location: URL, with service: OpaqueService) throws {\n    if (!service.open(location)) {\n      throw AttachmentOpeningError.unableToOpenAttachment\n    }\n  }\n}",
      "language" : "swift"
    },
    {
      "code" : "protocol URLOpener {\n    func open(_ file: URL) -> Bool\n}\n\nextension OpaqueService : URLOpener {}\n\nstruct AttachmentOpener {\n    func openAttachment(file location: URL, with service: URLOpener) throws {\n        if (!service.open(location)) {\n            throw AttachmentOpeningError.unableToOpenAttachment\n        }\n    }\n}\n\nclass StubService: URLOpener {\n    var isSuccessful = true\n\n    func open(_ file: URL) -> Bool {\n        return isSuccessful\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "enum DocumentError : Error {\n    case cannotLoadContent\n    case cannotSaveContent\n}\n\nclass Document {\n    private var location: URL\n    private var titleContent: String?\n    var title : String {\n        get {\n            return titleContent ?? \"Untitled\"\n        }\n        set {\n            titleContent = newValue\n        }\n    }\n\n    required init(fileURL: URL) {\n        location = fileURL\n    }\n    \n    func load() throws {\n        do {\n            let myString = try String(contentsOf: location, encoding: .utf8)\n        }\n        catch {\n            throw DocumentError.cannotLoadContent\n        }\n    }\n    \n    func save() throws {\n        do {\n            try titleContent?.write(to: location, atomically: true, encoding: .utf8)\n        }\n        catch {\n            throw DocumentError.cannotSaveContent\n        }\n    }\n}\n\nclass DocumentLoader {\n    func loadDocument(at location: URL) -> Bool {\n        do {\n            var document = Document(fileURL: location)\n            try document.load()\n            \/\/ Do something with the document, for example, present it in the app's UI.\n            return true\n        } catch {\n            return false\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class DocumentLoader {\n    var DocumentClass = Document.self\n\n    func loadDocument(at location: URL) -> Bool {\n        do {\n            var document = DocumentClass.init(fileURL: location)\n            try document.load()\n            \/\/ Do something with the document, for example, present it in the app's UI.\n            return true\n        } catch {\n            return false\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class SampleDocument : Document {\n    static var loadsSuccessfully : Bool = true\n    static var savesSuccessfully : Bool = true\n    \n    override func load() throws {\n        guard SampleDocument.loadsSuccessfully else {\n            throw DocumentError.cannotLoadContent\n        }\n    }\n    \n    override func save() throws {\n        guard SampleDocument.savesSuccessfully else {\n            throw DocumentError.cannotSaveContent\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import Foundation\n\nenum AccountError : Error {\n    case cannotCalculateAge\n}\n\nclass Account {\n    let name: String\n    let email: String\n    let userId: String\n    let dateOfBirth: Date\n    \n    init(name: String, email: String, userId: String, dateOfBirth: Date) {\n        self.name = name\n        self.email = email\n        self.userId = userId\n        self.dateOfBirth = dateOfBirth\n    }\n    \n    var now : Date {\n        get {\n            return Date()\n        }\n    }\n    \n    func age() throws -> Int {\n        let calendar = Calendar.current\n        let birthday = calendar.startOfDay(for: dateOfBirth)\n        let today = calendar.startOfDay(for: now)\n        guard let years =  calendar.dateComponents([.year], from: birthday, to: today).year else {\n            throw AccountError.cannotCalculateAge\n        }\n        return years\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class StubAccount : Account {\n    private var overrideNow : Date\n    \n    init(name: String, email: String, userId: String, dateOfBirth: Date, overrideNow: Date) {\n        self.overrideNow = overrideNow\n        super.init(name: name, email: email, userId: userId, dateOfBirth: dateOfBirth)\n    }\n    \n    override var now : Date {\n        overrideNow\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "class LoginHandler {\n    \n    var previousUsername: String? {\n        get {\n            UserDefaults.standard.string(forKey: \"ExampleAccountUsername\")\n        }\n    }\n    \n}",
      "language" : "swift"
    },
    {
      "code" : "protocol LoginStorage {\n    func string(forKey: String) -> String?\n}\n\nextension UserDefaults : LoginStorage { }\n\nclass LoginHandler {\n    private var storage: LoginStorage\n    \n    init(storage: LoginStorage = UserDefaults.standard) {\n        self.storage = storage\n    }\n    \n    var previousUsername: String? {\n        get {\n            storage.string(forKey: \"ExampleAccountUsername\")\n        }\n    }\n    \n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "4e28fb33dcc5cb7cbd4aa95f574699598c5fe94291b85803440f34130f3ad42a",
  "crawledAt" : "2025-12-02T17:02:19Z",
  "id" : "665AB08E-45C3-4761-B78D-7DEA683359F7",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nAdding unit tests to existing projects can be difficult, because design choices made without considering testability can couple together distinct classes or subsystems, making it impossible to test them in isolation. When two components in your software are tightly coupled, you can only use one of them correctly when it’s integrated with the other in a specific way. Sometimes, this coupling means your tests attempt network connections or interact with the filesystem, which makes the tests slow and their results non-deterministic. Removing the coupling makes it possible to introduce unit tests, but requires code changes in places where you don’t already have test coverage, which is risky.\n\nTo improve the test coverage of your project by identifying a component you’d like to test, write a test case that covers the behavior you want to assert. Use a risk-focused approach to prioritization that covers logic in features which have received a high number of user bug reports, or where a regression would have the highest impact.\n\nWhen the code you’re testing is coupled to another part of your project or a framework class, make the smallest possible change to the code so you can isolate the component without changing its behavior. Improve the ability to use the class in a test context with reduced coupling, and keep the changes small to reduce the risk associated with each change.\n\nThe following sections propose changes that remove couplings in situations where coupling between the code under consideration and another component blocks testing. Each solution demonstrates how a test function works with the changed code to assert its behavior.\n\n### Replace a concrete type with a protocol\n\nWhen your code relies on a specific type whose behavior makes testing difficult, create a protocol that lists the methods and properties used by your code. You can use this approach when interacting with components in your own codebase or with APIs from other sources outside of your control, including platform SDKs and Swift packages. Examples of such problematic dependencies include those that access external state, including user documents or databases, or those that don’t have deterministic results, including network connections or random value generators.\n\nThe following shows a class in an app that uses an opaque service to open a file which represents an attachment handled by external dependencies. The outcome of the `openAttachment(file:with:)` method depends on whether the opaque service can handle files of the requested type, and whether the application successfully opens the file. All of these variables could introduce test failures, which would slow down development as you investigate “errors” that turn out to be transient problems unrelated to your code.\n\nTo test code with this coupling, introduce a protocol that describes how your code interacts with the problematic dependency. Use that protocol in your code, so the class depends on the existence of the methods in the protocol, but not their specific implementation. Write an alternative implementation of the protocol that doesn’t perform the stateful or nondeterministic tasks, and use that implementation to write tests with controlled behavior.\n\nIn this listing, a protocol that includes the `open` method is defined, along with an extension to opaque class that makes it conform to the protocol.\n\nIn tests, write a different implementation of the `URLOpener` protocol that doesn’t depend on the apps installed on the user’s computer.\n\n### Replace named type with metatype value\n\nWhen one class in your app creates and uses instances of another class, and the created objects introduce testing difficulties, it can be hard to test the class where they’re created. Parameterize the type of the created object and use a required initializer to create an instance. Examples of this difficult testing situation include a controller that creates a new document on the filesystem in response to a person’s action, or a method that interprets JSON received from a web service and creates new Core Data managed objects that represent the received data.\n\nIn each of these cases, because the objects are created by the code you want to test, you can’t pass in a different object as a parameter to the method. The object doesn’t exist until it’s created by your code, at which point it’s of the type that has the untestable behavior.\n\nThe listing below shows a `DocumentLoader` class that creates and loads a `Document`, for example, in response to a UI action. The document object it creates reads and writes data to the file system, so its behavior isn’t easy to control in a unit test.\n\nTo remove the coupling between the code you’re trying to test and the objects it creates, define a variable on the class under test that represents the *type* of object it should construct. Such a variable is called a *metatype value*. Set the default value to the type the class already uses. You’ll need to ensure that the initializer used to construct instances is marked `required`. This listing shows the document browser view controller delegate with that variable introduced. The delegate creates documents with the type defined by the metatype value.\n\nSet a different value for the metatype in tests, so your code constructs an object that doesn’t have the same untestable behavior. In tests, create a “sample” version of the document class: a class with the same interface, but which doesn’t implement the behavior that makes it hard to test. In this case, a sample document class should not interact with the file system.\n\nReplace the document type with the sample type in your test case’s `setUp()` method, so the document loader you test creates instances of the stub document type. Sample documents behave deterministically in the tests.\n\n### Subclass and override untestable methods\n\nWhen a class combines custom logic with interactions or behavior that make the class hard to test, introduce a subclass that overrides some of the class’s methods to make the others easier to test. It’s common to design classes that contain both app-specific logic, and interactions with the environment or frameworks that render behavior difficult to control in tests. A common example is a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController] subclass, which has app-specific code in its action methods and also loads views or presents other view controllers.\n\nIntroducing tests for the custom app logic is desirable, to ensure that this logic works as expected and to protect against regressions. The complexity of controlling or working around the interactions between the class and the environment make testing the logic difficult.\n\nAs an example, the following account object provides a method to calculate someone’s birthday. It does the calculation by finding the number of years between the account’s recorded date of birth and today’s date.\n\nTesting this object’s behavior is difficult because the `now` field gets its value from the system’s clock. If the clock isn’t set correctly then the test might fail, and as time passes the value returned from `now` changes so a test’s expectation of the computed age would become out of date.\n\nTo overcome this complexity, subclass the `Account` and “stub out” methods that produce complex, untestable interactions, by overriding them with simpler methods. Use the subclass in your tests to verify the behavior of the custom logic, which you don’t override. You may also need to introduce a metatype value, if the code under test creates an instance of the target type.\n\nThe following listing introduces a subclass, `StubAccount`, which doesn’t rely on the system’s clock. Instead, it uses a fixed date that’s configured by the caller. Tests using this subclass provide fixed values for both the account’s date of birth and the date that represents the current date, to ensure that the calculation the `Account` object performs is correct.\n\nIn testing types, create instances of `StubAccount` and test the date-calculation logic inherited from `Account`. Because `StubAccount` lets the test code control the date that represents the current date, the test behavior doesn’t depend on the system’s clock.\n\nSometimes this pattern can help you test existing classes that combine multiple responsibilities, but only if those classes and the methods aren’t marked as `final` and it isn’t a good practice to follow in designing testable code from scratch. Separate code that handles different concerns into different classes, for example:\n\nAdd UI tests to verify the behavior of the real class in an end-to-end workflow covering the logic you stubbed out in the unit tests.\n\nSubclassing and overriding untestable methods is the first step in redesigning existing code so app logic and integration with frameworks or external data are separated. Dividing the code this way makes it easier to understand which parts of your project implement the app’s features and which integrate with the rest of the system, and it also reduces the chance of introducing logic bugs when you change your code to take advantage of new APIs or adopt different technologies.\n\n### Inject a singleton\n\nIf your code uses a singleton object to gain access to globally-available state or behavior, turn the singleton into a parameter that you can replace to support isolation for testing. Singleton use can be spread throughout a codebase, which makes it hard to know the singleton’s state when it’s used by the component you’re trying to test. Running tests in different orders may produce different outcomes.\n\nIn this example, a `LoginHandler` object participates in authenticating someone to a network service. Part of its capability is retrieving a username that the app previously used for the service, which it gets from the standard user defaults object:\n\n[doc:\/\/com.apple.documentation\/documentation\/Foundation\/UserDefaults] relies on shared state that’s stored in the file system and might be modified by other code in the app or by someone editing files on their Mac. Replace direct access to the singleton object with a parameter or property that can be controlled from outside the component under test. In the app, continue to use the singleton as the collaborator for the component. In tests, supply an alternative object that’s easier to control.\n\nThe following listing shows the result of applying this change to the `LoginHandler` class listed above. The login handler gets the stored username from its `storage` object, which defaults to the user defaults singleton. An extension conforms `UserDefaults` to the `LoginStorage` protocol, so that tests can supply alternative implementations of the protocol.\n\nIn a test case you can substitute a different storage object, which isn’t used elsewhere in the test suite or the app, and therefore is isolated from the behavior of other tests and modules.\n\nYou may need to combine this change with those described in the article sections ([doc:\/\/com.apple.Xcode\/documentation\/Xcode\/updating-your-existing-codebase-to-accommodate-unit-tests#Replace-a-concrete-type-with-a-protocol] and [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/updating-your-existing-codebase-to-accommodate-unit-tests#Subclass-and-override-untestable-methods]) to create the alternative object you use in the test in place of the singleton. You’ll need to do this where the singleton supplies behavior that’s difficult to control in a test, like [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileManager] or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplication].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/updating-your-existing-codebase-to-accommodate-unit-tests\ncrawled: 2025-12-02T17:02:19Z\n---\n\n# Updating your existing codebase to accommodate unit tests\n\n**Article**\n\nRemove coupling between components to increase test coverage and reliability.\n\n## Overview\n\nAdding unit tests to existing projects can be difficult, because design choices made without considering testability can couple together distinct classes or subsystems, making it impossible to test them in isolation. When two components in your software are tightly coupled, you can only use one of them correctly when it’s integrated with the other in a specific way. Sometimes, this coupling means your tests attempt network connections or interact with the filesystem, which makes the tests slow and their results non-deterministic. Removing the coupling makes it possible to introduce unit tests, but requires code changes in places where you don’t already have test coverage, which is risky.\n\nTo improve the test coverage of your project by identifying a component you’d like to test, write a test case that covers the behavior you want to assert. Use a risk-focused approach to prioritization that covers logic in features which have received a high number of user bug reports, or where a regression would have the highest impact.\n\nWhen the code you’re testing is coupled to another part of your project or a framework class, make the smallest possible change to the code so you can isolate the component without changing its behavior. Improve the ability to use the class in a test context with reduced coupling, and keep the changes small to reduce the risk associated with each change.\n\nThe following sections propose changes that remove couplings in situations where coupling between the code under consideration and another component blocks testing. Each solution demonstrates how a test function works with the changed code to assert its behavior.\n\n### Replace a concrete type with a protocol\n\nWhen your code relies on a specific type whose behavior makes testing difficult, create a protocol that lists the methods and properties used by your code. You can use this approach when interacting with components in your own codebase or with APIs from other sources outside of your control, including platform SDKs and Swift packages. Examples of such problematic dependencies include those that access external state, including user documents or databases, or those that don’t have deterministic results, including network connections or random value generators.\n\nThe following shows a class in an app that uses an opaque service to open a file which represents an attachment handled by external dependencies. The outcome of the `openAttachment(file:with:)` method depends on whether the opaque service can handle files of the requested type, and whether the application successfully opens the file. All of these variables could introduce test failures, which would slow down development as you investigate “errors” that turn out to be transient problems unrelated to your code.\n\n```swift\nprivate enum AttachmentOpeningError: Error {\n    case unableToOpenAttachment\n}\n\nstruct AttachmentOpener {\n  func openAttachment(file location: URL, with service: OpaqueService) throws {\n    if (!service.open(location)) {\n      throw AttachmentOpeningError.unableToOpenAttachment\n    }\n  }\n}\n```\n\nTo test code with this coupling, introduce a protocol that describes how your code interacts with the problematic dependency. Use that protocol in your code, so the class depends on the existence of the methods in the protocol, but not their specific implementation. Write an alternative implementation of the protocol that doesn’t perform the stateful or nondeterministic tasks, and use that implementation to write tests with controlled behavior.\n\nIn this listing, a protocol that includes the `open` method is defined, along with an extension to opaque class that makes it conform to the protocol.\n\n```swift\nprotocol URLOpener {\n    func open(_ file: URL) -> Bool\n}\n\nextension OpaqueService : URLOpener {}\n\nstruct AttachmentOpener {\n    func openAttachment(file location: URL, with service: URLOpener) throws {\n        if (!service.open(location)) {\n            throw AttachmentOpeningError.unableToOpenAttachment\n        }\n    }\n}\n\nclass StubService: URLOpener {\n    var isSuccessful = true\n\n    func open(_ file: URL) -> Bool {\n        return isSuccessful\n    }\n}\n```\n\nIn tests, write a different implementation of the `URLOpener` protocol that doesn’t depend on the apps installed on the user’s computer.\n\n\n\n### Replace named type with metatype value\n\nWhen one class in your app creates and uses instances of another class, and the created objects introduce testing difficulties, it can be hard to test the class where they’re created. Parameterize the type of the created object and use a required initializer to create an instance. Examples of this difficult testing situation include a controller that creates a new document on the filesystem in response to a person’s action, or a method that interprets JSON received from a web service and creates new Core Data managed objects that represent the received data.\n\nIn each of these cases, because the objects are created by the code you want to test, you can’t pass in a different object as a parameter to the method. The object doesn’t exist until it’s created by your code, at which point it’s of the type that has the untestable behavior.\n\nThe listing below shows a `DocumentLoader` class that creates and loads a `Document`, for example, in response to a UI action. The document object it creates reads and writes data to the file system, so its behavior isn’t easy to control in a unit test.\n\n```swift\nenum DocumentError : Error {\n    case cannotLoadContent\n    case cannotSaveContent\n}\n\nclass Document {\n    private var location: URL\n    private var titleContent: String?\n    var title : String {\n        get {\n            return titleContent ?? \"Untitled\"\n        }\n        set {\n            titleContent = newValue\n        }\n    }\n\n    required init(fileURL: URL) {\n        location = fileURL\n    }\n    \n    func load() throws {\n        do {\n            let myString = try String(contentsOf: location, encoding: .utf8)\n        }\n        catch {\n            throw DocumentError.cannotLoadContent\n        }\n    }\n    \n    func save() throws {\n        do {\n            try titleContent?.write(to: location, atomically: true, encoding: .utf8)\n        }\n        catch {\n            throw DocumentError.cannotSaveContent\n        }\n    }\n}\n\nclass DocumentLoader {\n    func loadDocument(at location: URL) -> Bool {\n        do {\n            var document = Document(fileURL: location)\n            try document.load()\n            \/\/ Do something with the document, for example, present it in the app's UI.\n            return true\n        } catch {\n            return false\n        }\n    }\n}\n```\n\nTo remove the coupling between the code you’re trying to test and the objects it creates, define a variable on the class under test that represents the *type* of object it should construct. Such a variable is called a *metatype value*. Set the default value to the type the class already uses. You’ll need to ensure that the initializer used to construct instances is marked `required`. This listing shows the document browser view controller delegate with that variable introduced. The delegate creates documents with the type defined by the metatype value.\n\n```swift\nclass DocumentLoader {\n    var DocumentClass = Document.self\n\n    func loadDocument(at location: URL) -> Bool {\n        do {\n            var document = DocumentClass.init(fileURL: location)\n            try document.load()\n            \/\/ Do something with the document, for example, present it in the app's UI.\n            return true\n        } catch {\n            return false\n        }\n    }\n}\n```\n\nSet a different value for the metatype in tests, so your code constructs an object that doesn’t have the same untestable behavior. In tests, create a “sample” version of the document class: a class with the same interface, but which doesn’t implement the behavior that makes it hard to test. In this case, a sample document class should not interact with the file system.\n\n```swift\nclass SampleDocument : Document {\n    static var loadsSuccessfully : Bool = true\n    static var savesSuccessfully : Bool = true\n    \n    override func load() throws {\n        guard SampleDocument.loadsSuccessfully else {\n            throw DocumentError.cannotLoadContent\n        }\n    }\n    \n    override func save() throws {\n        guard SampleDocument.savesSuccessfully else {\n            throw DocumentError.cannotSaveContent\n        }\n    }\n}\n```\n\nReplace the document type with the sample type in your test case’s `setUp()` method, so the document loader you test creates instances of the stub document type. Sample documents behave deterministically in the tests.\n\n\n\n### Subclass and override untestable methods\n\nWhen a class combines custom logic with interactions or behavior that make the class hard to test, introduce a subclass that overrides some of the class’s methods to make the others easier to test. It’s common to design classes that contain both app-specific logic, and interactions with the environment or frameworks that render behavior difficult to control in tests. A common example is a [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIViewController] subclass, which has app-specific code in its action methods and also loads views or presents other view controllers.\n\nIntroducing tests for the custom app logic is desirable, to ensure that this logic works as expected and to protect against regressions. The complexity of controlling or working around the interactions between the class and the environment make testing the logic difficult.\n\nAs an example, the following account object provides a method to calculate someone’s birthday. It does the calculation by finding the number of years between the account’s recorded date of birth and today’s date.\n\n```swift\nimport Foundation\n\nenum AccountError : Error {\n    case cannotCalculateAge\n}\n\nclass Account {\n    let name: String\n    let email: String\n    let userId: String\n    let dateOfBirth: Date\n    \n    init(name: String, email: String, userId: String, dateOfBirth: Date) {\n        self.name = name\n        self.email = email\n        self.userId = userId\n        self.dateOfBirth = dateOfBirth\n    }\n    \n    var now : Date {\n        get {\n            return Date()\n        }\n    }\n    \n    func age() throws -> Int {\n        let calendar = Calendar.current\n        let birthday = calendar.startOfDay(for: dateOfBirth)\n        let today = calendar.startOfDay(for: now)\n        guard let years =  calendar.dateComponents([.year], from: birthday, to: today).year else {\n            throw AccountError.cannotCalculateAge\n        }\n        return years\n    }\n}\n```\n\nTesting this object’s behavior is difficult because the `now` field gets its value from the system’s clock. If the clock isn’t set correctly then the test might fail, and as time passes the value returned from `now` changes so a test’s expectation of the computed age would become out of date.\n\nTo overcome this complexity, subclass the `Account` and “stub out” methods that produce complex, untestable interactions, by overriding them with simpler methods. Use the subclass in your tests to verify the behavior of the custom logic, which you don’t override. You may also need to introduce a metatype value, if the code under test creates an instance of the target type.\n\nThe following listing introduces a subclass, `StubAccount`, which doesn’t rely on the system’s clock. Instead, it uses a fixed date that’s configured by the caller. Tests using this subclass provide fixed values for both the account’s date of birth and the date that represents the current date, to ensure that the calculation the `Account` object performs is correct.\n\n```swift\nclass StubAccount : Account {\n    private var overrideNow : Date\n    \n    init(name: String, email: String, userId: String, dateOfBirth: Date, overrideNow: Date) {\n        self.overrideNow = overrideNow\n        super.init(name: name, email: email, userId: userId, dateOfBirth: dateOfBirth)\n    }\n    \n    override var now : Date {\n        overrideNow\n    }\n}\n```\n\nIn testing types, create instances of `StubAccount` and test the date-calculation logic inherited from `Account`. Because `StubAccount` lets the test code control the date that represents the current date, the test behavior doesn’t depend on the system’s clock.\n\n\n\nSometimes this pattern can help you test existing classes that combine multiple responsibilities, but only if those classes and the methods aren’t marked as `final` and it isn’t a good practice to follow in designing testable code from scratch. Separate code that handles different concerns into different classes, for example:\n\n- Controller classes that implement your app’s custom behavior.\n- View controllers that manage your view hierarchy and respond to UI actions.\n- View models that prepare and update data you present in your app’s views.\n\nAdd UI tests to verify the behavior of the real class in an end-to-end workflow covering the logic you stubbed out in the unit tests.\n\nSubclassing and overriding untestable methods is the first step in redesigning existing code so app logic and integration with frameworks or external data are separated. Dividing the code this way makes it easier to understand which parts of your project implement the app’s features and which integrate with the rest of the system, and it also reduces the chance of introducing logic bugs when you change your code to take advantage of new APIs or adopt different technologies.\n\n### Inject a singleton\n\nIf your code uses a singleton object to gain access to globally-available state or behavior, turn the singleton into a parameter that you can replace to support isolation for testing. Singleton use can be spread throughout a codebase, which makes it hard to know the singleton’s state when it’s used by the component you’re trying to test. Running tests in different orders may produce different outcomes.\n\n\n\nIn this example, a `LoginHandler` object participates in authenticating someone to a network service. Part of its capability is retrieving a username that the app previously used for the service, which it gets from the standard user defaults object:\n\n```swift\nclass LoginHandler {\n    \n    var previousUsername: String? {\n        get {\n            UserDefaults.standard.string(forKey: \"ExampleAccountUsername\")\n        }\n    }\n    \n}\n```\n\n[doc:\/\/com.apple.documentation\/documentation\/Foundation\/UserDefaults] relies on shared state that’s stored in the file system and might be modified by other code in the app or by someone editing files on their Mac. Replace direct access to the singleton object with a parameter or property that can be controlled from outside the component under test. In the app, continue to use the singleton as the collaborator for the component. In tests, supply an alternative object that’s easier to control.\n\nThe following listing shows the result of applying this change to the `LoginHandler` class listed above. The login handler gets the stored username from its `storage` object, which defaults to the user defaults singleton. An extension conforms `UserDefaults` to the `LoginStorage` protocol, so that tests can supply alternative implementations of the protocol.\n\n```swift\nprotocol LoginStorage {\n    func string(forKey: String) -> String?\n}\n\nextension UserDefaults : LoginStorage { }\n\nclass LoginHandler {\n    private var storage: LoginStorage\n    \n    init(storage: LoginStorage = UserDefaults.standard) {\n        self.storage = storage\n    }\n    \n    var previousUsername: String? {\n        get {\n            storage.string(forKey: \"ExampleAccountUsername\")\n        }\n    }\n    \n}\n```\n\nIn a test case you can substitute a different storage object, which isn’t used elsewhere in the test suite or the app, and therefore is isolated from the behavior of other tests and modules.\n\n\n\nYou may need to combine this change with those described in the article sections ([doc:\/\/com.apple.Xcode\/documentation\/Xcode\/updating-your-existing-codebase-to-accommodate-unit-tests#Replace-a-concrete-type-with-a-protocol] and [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/updating-your-existing-codebase-to-accommodate-unit-tests#Subclass-and-override-untestable-methods]) to create the alternative object you use in the test in place of the singleton. You’ll need to do this where the singleton supplies behavior that’s difficult to control in a test, like [doc:\/\/com.apple.documentation\/documentation\/Foundation\/FileManager] or [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplication].\n\n## Test development\n\n- **Adding tests to your Xcode project**: Include test targets that build code to test the logic in your functions, check for integration issues, automate UI workflows, and measure performance.\n- **Determining how much code your tests cover**: Use code coverage to focus new test development on areas that lack adequate testing.\n- **Improving code assessment by organizing tests into test plans**: Control the information you receive from your tests at different stages in the software engineering process by creating and configuring test plans.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Include test targets that build code to test the logic in your functions, check for integration issues, automate UI workflows, and measure performance.",
          "name" : "Adding tests to your Xcode project",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/adding-tests-to-your-xcode-project"
        },
        {
          "description" : "Use code coverage to focus new test development on areas that lack adequate testing.",
          "name" : "Determining how much code your tests cover",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/determining-how-much-code-your-tests-cover"
        },
        {
          "description" : "Control the information you receive from your tests at different stages in the software engineering process by creating and configuring test plans.",
          "name" : "Improving code assessment by organizing tests into test plans",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/organizing-tests-to-improve-feedback"
        }
      ],
      "title" : "Test development"
    }
  ],
  "source" : "appleJSON",
  "title" : "Updating your existing codebase to accommodate unit tests",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/updating-your-existing-codebase-to-accommodate-unit-tests"
}