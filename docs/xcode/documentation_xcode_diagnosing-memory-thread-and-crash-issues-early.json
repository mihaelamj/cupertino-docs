{
  "abstract" : "Identify runtime crashes and undefined behaviors in your app during testing using Xcode’s sanitizer tools.",
  "codeExamples" : [
    {
      "code" : "let task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n   if let data = data {\n      \/\/ Redirect to the main thread.\n      DispatchQueue.main.async {\n         self.label.text = \"\\(data.count) bytes downloaded\"\n      }\n   }\n}\ntask.resume()\n",
      "language" : "swift"
    }
  ],
  "contentHash" : "09af758bfd9b20f3277c9a90ba052c2c944aa72878113072965206ddb0e4a0df",
  "crawledAt" : "2025-12-01T09:06:41Z",
  "id" : "21FE6E45-BB98-4DA9-924D-D26BB113C2DE",
  "kind" : "collection",
  "overview" : "## Overview\n\nIdentifying potential issues during development saves testing time later and improves the stability of your code. Xcode provides several runtime tools to identify potential issues in your code:\n\nThese are LLVM-based tools that add specific checks to your code. You enable them at build time using the Xcode scheme editor. Select the appropriate scheme for your project and choose Product > Scheme > Edit Scheme to display the scheme editor. Select the Run or Test schemes, navigate to the Diagnostics section, and select the sanitizers you want to run.\n\nTest your app with sanitizer tools enabled to catch otherwise difficult to catch bugs. Test your code using a comprehensive set of unit tests, and use additional integration and UI tests to exercise additional code at runtime. The `Address Sanitizer`, `Thread Sanitizer`, `Undefined Behavior Sanitizer`, and `Main Thread Checker` values of a test plan configuration enable these sanitizers during test runs, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/organizing-tests-to-improve-feedback].  For more information about testing your code, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/testing].\n\n### Locate memory corruption issues in your code\n\nAccessing memory improperly can introduce unexpected issues into your code, and even pose a security threat. The Address Sanitizer tool detects memory-access attempts that don’t belong to an allocated block. To enable this tool, select Address Sanitizer from the Diagnostics section of the appropriate scheme.\n\n\n\nTo enable ASan from the command line, use the following flags:\n\nThe Address Sanitizer tool replaces the `malloc(_:)` and `free(_:)` functions with custom implementations. The custom `malloc(_:)` function surrounds a requested memory block with special off-limits regions, and reports attempts to access those regions. The `free(_:)` function places a deallocated block into a special quarantine queue, and reports attempts to access that quarantined memory.\n\nFor most use cases, the overhead that Address Sanitizer adds to your code should be acceptable for daily development. Running your code with Address Sanitizer increases memory usage by two to three times, and also adds 2x to 5x slowdown of your code. To improve your code’s memory usage, compile your code with the `-O1` optimization.\n\n### Detect data races among your app’s threads\n\nRace conditions occur when multiple threads access the same memory without proper synchronization. Race conditions are difficult to detect during regular testing because they don’t occur consistently. However, fixing them is important because they cause your code to behave unpredictably, and may even lead to memory corruption.\n\nTo detect race conditions and other thread-related issues, enable the Thread Sanitizer tool from the Diagnostics section of the appropriate build scheme.\n\n\n\nTo enable TSan from the command line, use the following flags:\n\nThe Thread Sanitizer tool inserts diagnostics into your code to record each memory read or write operation. These diagnostics generate a timestamp for each operation, as well as its location in memory. The tool then reports any operations that occur at the same location at approximately the same time. The tool also detects other thread-related bugs, such as uninitialized mutexes and thread leaks.\n\nBecause Thread Sanitizer inserts diagnostics into your code, it increases memory usage by five to ten times. Running your code with these diagnostics also introduces a 2x to 20x slowdown of your app. To improve your code’s memory usage, compile your code with the `-O1` optimization.\n\n### Detect improper UI updates on background threads\n\nSome system frameworks contain APIs that you must only call from your app’s main thread. This requirement applies to most of the AppKit and UIKit user interface APIs, and also applies to some other system APIs. Calling these APIs from the main thread prevents race conditions by serializing the execution of the associated tasks. Failure to perform these operations on the main thread may result in visual defects, data corruption, or crashes.\n\nThe Main Thread Checker tool ensures that all calls that must occur on the main thread do so. To enable this tool, select Main Thread Checker from the Diagnostics section of the appropriate scheme.\n\n\n\nThe Main Thread Checker tool dynamically replaces system methods that must execute on the main thread with variants that check the current thread. The tool replaces only system APIs with well-known thread requirements, and doesn’t replace all system APIs. Because the replacements occur in system frameworks, Main Thread Checker doesn’t require you to recompile your app.\n\nTo fix problems identified by Main Thread Checker, dispatch calls to your app’s main thread. The most common place where main thread errors occur is completion handler blocks. The following code wraps the text label modification with an asynchronous dispatch call to the main thread.\n\nThe performance impact of Main Thread Checker is minimal. The tool adds 1–2% CPU overhead to your process, and increases process launch time by no more than 100 milliseconds. Because of this minimal impact, Xcode enables Main Thread Checker by default for your development-related schemes.\n\n### Detect operations with undefined semantics\n\nCode that results in undefined behavior can lead to crashes or incorrect output. In some cases, the code may not result in any problems at all initially, making it even harder to diagnose the problem later when conditions are different. The Undefined Behavior Sanitizer tool checks C-based code for a variety of common runtime errors, including:\n\nTo enable this tool, select Undefined Behavior Sanitizer from the Diagnostics section of the appropriate scheme.\n\n\n\nTo enable UBSan from the command line, add the `-fsanitize=undefined` option in clang or the `enableUndefinedBehaviorSanitizer YES` option in xcodebuild. To enable individual sanitizer checks, use the following options:\n\nThe Undefined Behavior Sanitizer tool inserts diagnostics into your code at compile time. The nature of these checks differs according to the type of operation. For example, before performing a mathematical operation on an integer value, the tool adds a check to determine if the operation triggers an integer overflow.\n\nThe performance impact of Undefined Behavior Sanitizer is minimal. The tool adds an average of 20% CPU overhead to the debug version of your app.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/diagnosing-memory-thread-and-crash-issues-early\ncrawled: 2025-12-01T09:06:41Z\n---\n\n# Diagnosing memory, thread, and crash issues early\n\nIdentify runtime crashes and undefined behaviors in your app during testing using Xcode’s sanitizer tools.\n\n## Overview\n\nIdentifying potential issues during development saves testing time later and improves the stability of your code. Xcode provides several runtime tools to identify potential issues in your code:\n\n- Address Sanitizer—The ASan tool identifies potential memory-related corruption issues.\n- Thread Sanitizer—The TSan tool detects race conditions between threads.\n- Main Thread Checker—This tool verifies that system APIs that must run on the main thread actually do run on that thread.\n- Undefined Behavior Sanitizer—The UBSan tool detects divide-by-zero errors, attempts to access memory using a misaligned pointer, and other undefined behaviors.\n\nThese are LLVM-based tools that add specific checks to your code. You enable them at build time using the Xcode scheme editor. Select the appropriate scheme for your project and choose Product > Scheme > Edit Scheme to display the scheme editor. Select the Run or Test schemes, navigate to the Diagnostics section, and select the sanitizers you want to run.\n\n\n\nTest your app with sanitizer tools enabled to catch otherwise difficult to catch bugs. Test your code using a comprehensive set of unit tests, and use additional integration and UI tests to exercise additional code at runtime. The `Address Sanitizer`, `Thread Sanitizer`, `Undefined Behavior Sanitizer`, and `Main Thread Checker` values of a test plan configuration enable these sanitizers during test runs, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/organizing-tests-to-improve-feedback].  For more information about testing your code, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/testing].\n\n### Locate memory corruption issues in your code\n\nAccessing memory improperly can introduce unexpected issues into your code, and even pose a security threat. The Address Sanitizer tool detects memory-access attempts that don’t belong to an allocated block. To enable this tool, select Address Sanitizer from the Diagnostics section of the appropriate scheme.\n\n\n\nTo enable ASan from the command line, use the following flags:\n\n- `-fsanitize=address` (clang)\n- `-sanitize=address` (swiftc)\n- `-enableAddressSanitizer YES` (xcodebuild)\n\nThe Address Sanitizer tool replaces the `malloc(_:)` and `free(_:)` functions with custom implementations. The custom `malloc(_:)` function surrounds a requested memory block with special off-limits regions, and reports attempts to access those regions. The `free(_:)` function places a deallocated block into a special quarantine queue, and reports attempts to access that quarantined memory.\n\n\n\nFor most use cases, the overhead that Address Sanitizer adds to your code should be acceptable for daily development. Running your code with Address Sanitizer increases memory usage by two to three times, and also adds 2x to 5x slowdown of your code. To improve your code’s memory usage, compile your code with the `-O1` optimization.\n\n### Detect data races among your app’s threads\n\nRace conditions occur when multiple threads access the same memory without proper synchronization. Race conditions are difficult to detect during regular testing because they don’t occur consistently. However, fixing them is important because they cause your code to behave unpredictably, and may even lead to memory corruption.\n\nTo detect race conditions and other thread-related issues, enable the Thread Sanitizer tool from the Diagnostics section of the appropriate build scheme.\n\n\n\nTo enable TSan from the command line, use the following flags:\n\n- `-fsanitize=thread` (clang)\n- `-sanitize=thread` (swiftc)\n- `-enableThreadSanitizer YES` (xcodebuild)\n\nThe Thread Sanitizer tool inserts diagnostics into your code to record each memory read or write operation. These diagnostics generate a timestamp for each operation, as well as its location in memory. The tool then reports any operations that occur at the same location at approximately the same time. The tool also detects other thread-related bugs, such as uninitialized mutexes and thread leaks.\n\n\n\nBecause Thread Sanitizer inserts diagnostics into your code, it increases memory usage by five to ten times. Running your code with these diagnostics also introduces a 2x to 20x slowdown of your app. To improve your code’s memory usage, compile your code with the `-O1` optimization.\n\n### Detect improper UI updates on background threads\n\nSome system frameworks contain APIs that you must only call from your app’s main thread. This requirement applies to most of the AppKit and UIKit user interface APIs, and also applies to some other system APIs. Calling these APIs from the main thread prevents race conditions by serializing the execution of the associated tasks. Failure to perform these operations on the main thread may result in visual defects, data corruption, or crashes.\n\nThe Main Thread Checker tool ensures that all calls that must occur on the main thread do so. To enable this tool, select Main Thread Checker from the Diagnostics section of the appropriate scheme.\n\n\n\nThe Main Thread Checker tool dynamically replaces system methods that must execute on the main thread with variants that check the current thread. The tool replaces only system APIs with well-known thread requirements, and doesn’t replace all system APIs. Because the replacements occur in system frameworks, Main Thread Checker doesn’t require you to recompile your app.\n\n\n\nTo fix problems identified by Main Thread Checker, dispatch calls to your app’s main thread. The most common place where main thread errors occur is completion handler blocks. The following code wraps the text label modification with an asynchronous dispatch call to the main thread.\n\n```swift\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n   if let data = data {\n      \/\/ Redirect to the main thread.\n      DispatchQueue.main.async {\n         self.label.text = \"\\(data.count) bytes downloaded\"\n      }\n   }\n}\ntask.resume()\n\n```\n\nThe performance impact of Main Thread Checker is minimal. The tool adds 1–2% CPU overhead to your process, and increases process launch time by no more than 100 milliseconds. Because of this minimal impact, Xcode enables Main Thread Checker by default for your development-related schemes.\n\n### Detect operations with undefined semantics\n\nCode that results in undefined behavior can lead to crashes or incorrect output. In some cases, the code may not result in any problems at all initially, making it even harder to diagnose the problem later when conditions are different. The Undefined Behavior Sanitizer tool checks C-based code for a variety of common runtime errors, including:\n\n- Attempts to divide by zero\n- Attempts to load memory from a misaligned pointer\n- Attempts to dereference a `NULL` pointer\n- Math operations that result in integer overflow\n\nTo enable this tool, select Undefined Behavior Sanitizer from the Diagnostics section of the appropriate scheme.\n\n\n\nTo enable UBSan from the command line, add the `-fsanitize=undefined` option in clang or the `enableUndefinedBehaviorSanitizer YES` option in xcodebuild. To enable individual sanitizer checks, use the following options:\n\n\n\nThe Undefined Behavior Sanitizer tool inserts diagnostics into your code at compile time. The nature of these checks differs according to the type of operation. For example, before performing a mathematical operation on an integer value, the tool adds a check to determine if the operation triggers an integer overflow.\n\nThe performance impact of Undefined Behavior Sanitizer is minimal. The tool adds an average of 20% CPU overhead to the debug version of your app.\n\n## Address Sanitizer\n\n- **Use of deallocated memory**: Detects the use of deallocated memory.\n- **Deallocation of deallocated memory**: Detects attempts to free deallocated memory.\n- **Deallocation of nonallocated memory**: Detects attempts to free nonallocated memory.\n- **Use of stack memory after function return**: Detects when you access stack variable memory after its declaring function returns.\n- **Use of out-of-scope stack memory**: Detects access to variables outside of their declared scope.\n- **Overflow and underflow of buffers**: Detects when you access memory outside of a buffer’s boundaries.\n- **Overflow of C++ containers**: Detects when you access a C++ container outside its bounds.\n\n## Thread Sanitizer\n\n- **Data races**: Detects unsynchronized access to mutable state across multiple threads.\n- **Swift access races**: Detects unsynchronized access to mutable state across multiple threads in Swift.\n- **Races on collections and other APIs**: Detects when one thread accesses a mutable object while another thread is writing to it.\n- **Uninitialized mutexes**: Detects when you use an uninitialized mutex.\n- **Thread leaks**: Detects when you don’t close threads after use.\n\n## Undefined Behavior Sanitizer\n\n- **Misaligned pointer**: Detects when code accesses a misaligned pointer or creates a misaligned reference.\n- **Invalid Boolean value**: Detects when a program accesses a Boolean variable and its value isn’t true or false.\n- **Out-of-bounds array access**: Detects out-of-bounds access of arrays.\n- **Invalid enumeration value**: Detects when an enumeration variable has an invalid value.\n- **Reaching of unreachable point**: Detects when a program reaches an unreachable point.\n- **Dynamic type violation**: Detects when an object has the wrong dynamic type.\n- **Invalid float cast**: Detects out-of-range casts to, from, or between floating-point types.\n- **Division by zero**: Detects division where the divisor is zero.\n- **Nonnull argument violation**: Detects when an argument incorrectly receives a null value.\n- **Nonnull return value violation**: Detects when a function incorrectly returns null.\n- **Nonnull variable assignment violation**: Detects when you incorrectly assign null to a variable.\n- **Null reference creation and null pointer dereference**: Detects the creation of null references and null pointer dereferences.\n- **Invalid object size**: Detects invalid pointer casts due to differences in the sizes of types.\n- **Invalid shift**: Detects invalid and overflowing shifts.\n- **Integer overflow**: Detects overflow in arithmetic.\n- **Invalid variable-length array**: Detects negative array bounds.\n\n## Debugging strategies\n\n- **Diagnosing issues in the appearance of a running app**: Inspect your running app to investigate issues in the appearance and placement of the content it displays.\n- **Analyzing HTTP traffic with Instruments**: Measure HTTP-based network performance and usage of your apps.\n- **Detecting when your app contacts domains that may be profiling users**: Use Instruments to assess whether your app or its third-party SDKs connect to domains that may profile users.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Detects the use of deallocated memory.",
          "name" : "Use of deallocated memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/use-of-deallocated-memory"
        },
        {
          "description" : "Detects attempts to free deallocated memory.",
          "name" : "Deallocation of deallocated memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/deallocation-of-deallocated-memory"
        },
        {
          "description" : "Detects attempts to free nonallocated memory.",
          "name" : "Deallocation of nonallocated memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/deallocation-of-nonallocated-memory"
        },
        {
          "description" : "Detects when you access stack variable memory after its declaring function returns.",
          "name" : "Use of stack memory after function return",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/use-of-stack-memory-after-function-return"
        },
        {
          "description" : "Detects access to variables outside of their declared scope.",
          "name" : "Use of out-of-scope stack memory",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/use-of-out-of-scope-stack-memory"
        },
        {
          "description" : "Detects when you access memory outside of a buffer’s boundaries.",
          "name" : "Overflow and underflow of buffers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/overflow-and-underflow-of-buffers"
        },
        {
          "description" : "Detects when you access a C++ container outside its bounds.",
          "name" : "Overflow of C++ containers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/overflow-of-c-containers"
        }
      ],
      "title" : "Address Sanitizer"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Detects unsynchronized access to mutable state across multiple threads.",
          "name" : "Data races",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/data-races"
        },
        {
          "description" : "Detects unsynchronized access to mutable state across multiple threads in Swift.",
          "name" : "Swift access races",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/swift-access-races"
        },
        {
          "description" : "Detects when one thread accesses a mutable object while another thread is writing to it.",
          "name" : "Races on collections and other APIs",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/races-on-collections-and-other-apis"
        },
        {
          "description" : "Detects when you use an uninitialized mutex.",
          "name" : "Uninitialized mutexes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/uninitialized-mutexes"
        },
        {
          "description" : "Detects when you don’t close threads after use.",
          "name" : "Thread leaks",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/thread-leaks"
        }
      ],
      "title" : "Thread Sanitizer"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Detects when code accesses a misaligned pointer or creates a misaligned reference.",
          "name" : "Misaligned pointer",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/misaligned-pointer"
        },
        {
          "description" : "Detects when a program accesses a Boolean variable and its value isn’t true or false.",
          "name" : "Invalid Boolean value",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/invalid-boolean"
        },
        {
          "description" : "Detects out-of-bounds access of arrays.",
          "name" : "Out-of-bounds array access",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/out-of-bounds-array-access"
        },
        {
          "description" : "Detects when an enumeration variable has an invalid value.",
          "name" : "Invalid enumeration value",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/invalid-enumeration-value"
        },
        {
          "description" : "Detects when a program reaches an unreachable point.",
          "name" : "Reaching of unreachable point",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/reaching-of-unreachable-point"
        },
        {
          "description" : "Detects when an object has the wrong dynamic type.",
          "name" : "Dynamic type violation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/dynamic-type-violation"
        },
        {
          "description" : "Detects out-of-range casts to, from, or between floating-point types.",
          "name" : "Invalid float cast",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/invalid-float-cast"
        },
        {
          "description" : "Detects division where the divisor is zero.",
          "name" : "Division by zero",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/division-by-zero"
        },
        {
          "description" : "Detects when an argument incorrectly receives a null value.",
          "name" : "Nonnull argument violation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/nonnull-argument-violation"
        },
        {
          "description" : "Detects when a function incorrectly returns null.",
          "name" : "Nonnull return value violation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/nonnull-return-value-violation"
        },
        {
          "description" : "Detects when you incorrectly assign null to a variable.",
          "name" : "Nonnull variable assignment violation",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/nonnull-variable-assignment-violation"
        },
        {
          "description" : "Detects the creation of null references and null pointer dereferences.",
          "name" : "Null reference creation and null pointer dereference",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/null-reference-creation-and-null-pointer-dereference"
        },
        {
          "description" : "Detects invalid pointer casts due to differences in the sizes of types.",
          "name" : "Invalid object size",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/invalid-object-size"
        },
        {
          "description" : "Detects invalid and overflowing shifts.",
          "name" : "Invalid shift",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/invalid-shift"
        },
        {
          "description" : "Detects overflow in arithmetic.",
          "name" : "Integer overflow",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/integer-overflow"
        },
        {
          "description" : "Detects negative array bounds.",
          "name" : "Invalid variable-length array",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/invalid-variable-length-array"
        }
      ],
      "title" : "Undefined Behavior Sanitizer"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Inspect your running app to investigate issues in the appearance and placement of the content it displays.",
          "name" : "Diagnosing issues in the appearance of a running app",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/diagnosing-issues-in-the-appearance-of-your-running-app"
        },
        {
          "description" : "Measure HTTP-based network performance and usage of your apps.",
          "name" : "Analyzing HTTP traffic with Instruments",
          "url" : "https:\/\/developer.apple.com\/documentation\/Foundation\/analyzing-http-traffic-with-instruments"
        },
        {
          "description" : "Use Instruments to assess whether your app or its third-party SDKs connect to domains that may profile users.",
          "name" : "Detecting when your app contacts domains that may be profiling users",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/detecting-when-your-app-contacts-domains-that-may-be-profiling-users"
        }
      ],
      "title" : "Debugging strategies"
    }
  ],
  "source" : "appleJSON",
  "title" : "Diagnosing memory, thread, and crash issues early",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/diagnosing-memory-thread-and-crash-issues-early"
}