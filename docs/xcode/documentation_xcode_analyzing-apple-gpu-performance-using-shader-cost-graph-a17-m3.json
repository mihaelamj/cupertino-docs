{
  "abstract" : "Discover potential shader performance issues by examining pipeline states.",
  "codeExamples" : [

  ],
  "contentHash" : "dbd365f4659ba6e66ac0e04066c7163bc3fa8c23904ebc6a4dd923df31c38733",
  "crawledAt" : "2025-12-02T19:54:17Z",
  "id" : "451F35B4-C652-429D-88AE-C0C00718533D",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nOne key method of triaging performance bottlenecks is to look at the most expensive shaders to understand which functions and lines are the most costly. The shader cost graph allows you to quickly find and triage expensive pipeline states and shaders.\n\n### View the shader cost graph\n\nTo open the shader cost graph, click the Performance button in the Metal debugger’s Debug navigator, and then click the Shaders tab above the Performance timeline.\n\nWhen you select a pipeline state in the Timeline navigator, the shader cost graph for that pipeline state’s shaders appears on the right.\n\n\n\n### Switch between shader types\n\nBy default, selecting a render pipeline state shows the fragment shader cost graph. Selecting a compute pipeline state shows the compute shader cost graph.\n\nYou can switch between different shader types using the Vertex and Fragment tabs above the shader cost graph.\n\n### Navigate the shader cost graph\n\nThe shader cost graph in the top section left-aligns the most expensive shader function calls, and shows the function call stack from top to bottom. The shader source code of the corresponding shader type appears below the graph.\n\nYou can select a function in the shader cost graph to view its shader source code below in the source editor.\n\n### Understand per-line costs\n\nThe percentage weights appear in the gutter of the shader source code to the left of the lines of code.\n\nThe pie chart to the right of each weight contains performance statistics to help you improve the shader code. Hover over a pie chart to display the detailed breakdown of the instructions of a line.\n\n\n\nThe instruction details include the following runtime statistics infomation:\n\nThe shader source line may consist of multiple instructions with different instruction types. For example, sampling a texture may involve math, sample, and synchronization instructions. The instruction details include the following possible instruction types and their cost:\n\nEach arithmetic instruction may operate on different data types, such as half-floats or integers. The instruction details include the following possible data types and their cost:\n\n### Switch between per-line metric modes\n\nIn the shader source code control bar, you can choose different modes for the per-line shader profiling statistics in the gutter. Options include the following:\n\nFor more information about the Metal profiling tools for M3 and A17 Pro, see [https:\/\/developer.apple.com\/videos\/play\/tech-talks\/111374\/].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-shader-cost-graph-a17-m3\ncrawled: 2025-12-02T19:54:17Z\n---\n\n# Analyzing Apple GPU performance using the shader cost graph\n\n**Article**\n\nDiscover potential shader performance issues by examining pipeline states.\n\n## Overview\n\nOne key method of triaging performance bottlenecks is to look at the most expensive shaders to understand which functions and lines are the most costly. The shader cost graph allows you to quickly find and triage expensive pipeline states and shaders.\n\n\n\n### View the shader cost graph\n\nTo open the shader cost graph, click the Performance button in the Metal debugger’s Debug navigator, and then click the Shaders tab above the Performance timeline.\n\n\n\nWhen you select a pipeline state in the Timeline navigator, the shader cost graph for that pipeline state’s shaders appears on the right.\n\n\n\n### Switch between shader types\n\nBy default, selecting a render pipeline state shows the fragment shader cost graph. Selecting a compute pipeline state shows the compute shader cost graph.\n\nYou can switch between different shader types using the Vertex and Fragment tabs above the shader cost graph.\n\n### Navigate the shader cost graph\n\nThe shader cost graph in the top section left-aligns the most expensive shader function calls, and shows the function call stack from top to bottom. The shader source code of the corresponding shader type appears below the graph.\n\nYou can select a function in the shader cost graph to view its shader source code below in the source editor.\n\n### Understand per-line costs\n\nThe percentage weights appear in the gutter of the shader source code to the left of the lines of code.\n\nThe pie chart to the right of each weight contains performance statistics to help you improve the shader code. Hover over a pie chart to display the detailed breakdown of the instructions of a line.\n\n\n\nThe instruction details include the following runtime statistics infomation:\n\n\n\nThe shader source line may consist of multiple instructions with different instruction types. For example, sampling a texture may involve math, sample, and synchronization instructions. The instruction details include the following possible instruction types and their cost:\n\n- Math\n- Comparison\n- Select\n- Bit Manipulation\n- Conversion\n- Permute\n- Reduce\n- Control Flow\n- Predication\n- Sample\n- Synchronization\n- Load Store\n- Load\n- Store\n- Atomic\n- Barrier\n- Fragment Feedback\n- Vertex Processing\n- Image Access\n- Data Movement\n- Ray Tracing\n- Image Block Load\n- Image Block Write\n- Image Write\n\nEach arithmetic instruction may operate on different data types, such as half-floats or integers. The instruction details include the following possible data types and their cost:\n\n- Float16\n- Float32\n- Integer\n- Bits\n\n### Switch between per-line metric modes\n\nIn the shader source code control bar, you can choose different modes for the per-line shader profiling statistics in the gutter. Options include the following:\n\n\n\nFor more information about the Metal profiling tools for M3 and A17 Pro, see [https:\/\/developer.apple.com\/videos\/play\/tech-talks\/111374\/].\n\n## Metal workload analysis\n\n- **Analyzing your Metal workload**: Investigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.\n- **Analyzing resource dependencies**: Avoid unnecessary work in your Metal app by understanding the relationships between resources.\n- **Analyzing memory usage**: Manage your Metal app’s memory usage by inspecting its resources.\n- **Analyzing Apple GPU performance using a visual timeline**: Locate performance issues using the Performance timeline.\n- **Analyzing Apple GPU performance using counter statistics**: Optimize performance by examining counters for individual passes and commands.\n- **Analyzing Apple GPU performance with performance heat maps**: Gain insights to SIMD group performance by inspecting source code execution.\n- **Analyzing non-Apple GPU performance using counter statistics**: Optimize performance by examining counters for individual passes and commands.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Investigate your app’s workload, dependencies, performance, and memory impact using the Metal debugger.",
          "name" : "Analyzing your Metal workload",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-your-Metal-workload"
        },
        {
          "description" : "Avoid unnecessary work in your Metal app by understanding the relationships between resources.",
          "name" : "Analyzing resource dependencies",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-resource-dependencies"
        },
        {
          "description" : "Manage your Metal app’s memory usage by inspecting its resources.",
          "name" : "Analyzing memory usage",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-memory-usage"
        },
        {
          "description" : "Locate performance issues using the Performance timeline.",
          "name" : "Analyzing Apple GPU performance using a visual timeline",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-a-visual-timeline"
        },
        {
          "description" : "Optimize performance by examining counters for individual passes and commands.",
          "name" : "Analyzing Apple GPU performance using counter statistics",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-counter-statistics"
        },
        {
          "description" : "Gain insights to SIMD group performance by inspecting source code execution.",
          "name" : "Analyzing Apple GPU performance with performance heat maps",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-performance-heatmaps-a17-m3"
        },
        {
          "description" : "Optimize performance by examining counters for individual passes and commands.",
          "name" : "Analyzing non-Apple GPU performance using counter statistics",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-non-Apple-GPU-performance-using-counter-statistics"
        }
      ],
      "title" : "Metal workload analysis"
    }
  ],
  "source" : "appleJSON",
  "title" : "Analyzing Apple GPU performance using the shader cost graph",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-shader-cost-graph-a17-m3"
}