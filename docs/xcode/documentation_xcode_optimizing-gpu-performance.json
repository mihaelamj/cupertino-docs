{
  "abstract" : "Find and address performance bottlenecks using the Metal debugger.",
  "codeExamples" : [

  ],
  "contentHash" : "9c1de26fc9712d819706a1139e78224da07cd6bcb39b6cad10873cdbd4ce9dd7",
  "crawledAt" : "2025-12-02T19:54:12Z",
  "id" : "88A412E9-C04B-4D3C-98C0-C7441F50A6DC",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nApple GPUs run vertex, fragment, and compute tasks in parallel whenever possible. The Metal debugger offers ways to inspect the passes running with overlap, which you can use to find bottlenecking tasks in GPU-bound workloads. In addition, the profiler measures performance statistics by sampling your shaders to reveal hot spots.\n\nIf you notice any performance issues while running your app, you can use the Metal debugger to find and investigate bottlenecks. First, configure your build to include shader source code (see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Building-your-project-with-embedded-shader-sources]). Then, take a frame capture of your app when you notice the visual artifact that you want to debug (see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Capturing-a-Metal-workload-in-Xcode]).\n\n### Gather performance data\n\nWhen you enable the Profile after Replay option, the Metal debugger automatically begins gathering performance data after replaying the workload. Alternatively, you can click the Profile button on the Summary viewer to gather performance data.\n\n\n\nThe performance state of the GPU is important when profiling because it affects how fast the system executes the workload. Factors that affect the performance state include thermals and system settings.\n\nBy default, the Metal debugger profiles the workload with the same GPU performance state at capture time, so the performance is typically similar to what you observe on the device. However, you can induce a specific GPU performance state as you make a profile in the Metal debugger by clicking the GPU Profiler button in the debug bar.\n\nFor more information on GPU performance state, see [https:\/\/developer.apple.com\/videos\/play\/wwdc2021\/10157\/?time=476].\n\n\n\nYou can switch between different GPU Execution Modes, including Concurrent and Serial, by clicking the GPU Profiler button in the debug bar. By default, the Metal debugger profiles the workload in Concurrent mode. This allows the GPU to overlap the vertex, fragment, and compute tasks so they can finish as quickly as possible. In Serial mode, the Metal debugger forces each pass to run only after the previous pass finishes, which adds precision to the data report for each pass without overlap, but it doesn’t represent runtime performance.\n\n### Find performance bottlenecks with the Performance timeline\n\nThe Performance timeline in the Metal debugger can help you find expensive tasks and performance bottlenecks in the captured workload. Open the Performance timeline by clicking the Performance button in the Debug navigator.\n\n\n\nThe Timeline navigator on the left side of the window lists all profiled passes, pipeline states, and GPU Commands with their shader profiler cost.\n\nThe top section has the Vertex, Fragment, and Compute GPU tracks, which display the beginning time and duration of individual passes running with overlap. Below the GPU tracks are the aggregated shader tracks that combine the individual shaders. You can view the timeline of individual shaders in a waterfall-like fashion by expanding the aggregated shader tracks.\n\nThe bottom section has a separate Counters timeline, which includes GPU counters such as Occupancy, Limiter, and Bandwidth. The counters can help you diagnose performance bottlenecks. You can focus on counter subsets by switching between different counter tabs. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-a-visual-timeline].\n\n### Get detailed performance metrics for passes and draws\n\nYou can view performance counter statistics from your app’s passes or commands in the GPU trace. Open the Performance counters by clicking the Counters tab above the Performance timeline.\n\n\n\nThe Metal debugger derives the shader profiler time by tracing the shader instructions when running the workload with overlap. In a shader-bound workload, sorting the table by shader profiler time can point you to the overall most expensive pass or draw. In addition, the Metal debugger measures the detailed counters from each pass or command in isolation. You can also choose different sets of counters in the top bar for a more focused view. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-counter-statistics].\n\n### Group commands by pipeline states in the Debug navigator\n\nFor a different perspective in viewing the Metal commands, click the Outline popup menu in the Debug navigator and select Group by Pipeline State to view a list of pipeline states.\n\n\n\nWith profiling data, the Debug navigator displays the percentage of samples from shaders of each pipeline state when running the workload with overlap. In a shader-bound workload, this sorted list of pipeline states is helpful in identifying the most expensive pipeline state. Expanding a pipeline state allows you to find a list of commands that use that state.\n\nYou can also quickly view the shader source code and per-line profiling statistics by selecting a shader from a pipeline state in the list.\n\nFor more information on the Debug navigator, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-your-Metal-workload].\n\n### Optimize shaders with per-line shader profiling statistics\n\nAfter opening a shader, you can find the time breakdown for the shader in the pipeline state.\n\n\n\nThe left sidebar allows you to inspect the shader source files and profiling call tree. With the call tree, you can find performance hot spots by the weights of each frame.\n\nIn the gutter of the shader source code, you can find weights next to the lines of code. The pie chart to the right of each weight contains performance statistics to help you improve the shader code.\n\nFor example, when you observe an expensive line of code with a high percentage for memory sample, it may be taking time to read texture data. To reduce the shader time, if it’s less expensive to compute the value than reading it from a texture, you can modify the code to calculate it in the shader.\n\nAfter making changes to the shader source code, click the Reload Shaders button in the debug bar to refresh the profiling statistics. You can verify whether the changes help with the overall performance by observing the new total GPU time and the tracks in the Performance timeline.\n\nFor more information on interpreting the per-line shader profiling statistics, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-shaders].\n\n### Inspect shader performance with the shader cost graph\n\nYou can quickly find and triage expensive pipeline states and shaders by using the shader cost graph. Select a pipeline state in the Timeline navigator, and then click the Shaders tab.\n\n\n\nYou can inspect the percentage cost of the shader function calls with the flame graph in the top section, and select function calls to jump directly to the source code.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-shader-cost-graph-a17-m3].\n\n### Understand SIMD group execution with the performance heat maps\n\nYou can quickly find and inspect the execution of your shader source code with the performance heat maps. Select an encoder, a pipeline state, or a GPU command in the Timeline navigator, and then click the Heat Maps tab.\n\n\n\nThe top section shows various heat maps graphing statistical information about GPU threads, such as the cost, the divergence, and the number of instructions.\n\nThe bottom section shows the shader execution history of GPU threads on a timeline, including function call stacks and thread states.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-performance-heatmaps-a17-m3].\n\n### Save the performance data to your development system\n\nYou can save your app’s Metal workload performance data as a GPU trace for later analysis by choosing File > Export, and selecting the Embed performance data checkbox in the dialog. This allows you to view just the performance data instead of replaying the GPU trace on a device.\n\n\n\nYou can open the GPU trace on any Mac — not just your development system — because it doesn’t require a compatible device to replay the trace. Optionally, you can replay the GPU trace by selecting a compatible device.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Replaying-a-GPU-trace-file].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/Optimizing-GPU-performance\ncrawled: 2025-12-02T19:54:12Z\n---\n\n# Optimizing GPU performance\n\n**Article**\n\nFind and address performance bottlenecks using the Metal debugger.\n\n## Overview\n\nApple GPUs run vertex, fragment, and compute tasks in parallel whenever possible. The Metal debugger offers ways to inspect the passes running with overlap, which you can use to find bottlenecking tasks in GPU-bound workloads. In addition, the profiler measures performance statistics by sampling your shaders to reveal hot spots.\n\nIf you notice any performance issues while running your app, you can use the Metal debugger to find and investigate bottlenecks. First, configure your build to include shader source code (see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Building-your-project-with-embedded-shader-sources]). Then, take a frame capture of your app when you notice the visual artifact that you want to debug (see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Capturing-a-Metal-workload-in-Xcode]).\n\n### Gather performance data\n\nWhen you enable the Profile after Replay option, the Metal debugger automatically begins gathering performance data after replaying the workload. Alternatively, you can click the Profile button on the Summary viewer to gather performance data.\n\n\n\nThe performance state of the GPU is important when profiling because it affects how fast the system executes the workload. Factors that affect the performance state include thermals and system settings.\n\nBy default, the Metal debugger profiles the workload with the same GPU performance state at capture time, so the performance is typically similar to what you observe on the device. However, you can induce a specific GPU performance state as you make a profile in the Metal debugger by clicking the GPU Profiler button in the debug bar.\n\nFor more information on GPU performance state, see [https:\/\/developer.apple.com\/videos\/play\/wwdc2021\/10157\/?time=476].\n\n\n\nYou can switch between different GPU Execution Modes, including Concurrent and Serial, by clicking the GPU Profiler button in the debug bar. By default, the Metal debugger profiles the workload in Concurrent mode. This allows the GPU to overlap the vertex, fragment, and compute tasks so they can finish as quickly as possible. In Serial mode, the Metal debugger forces each pass to run only after the previous pass finishes, which adds precision to the data report for each pass without overlap, but it doesn’t represent runtime performance.\n\n### Find performance bottlenecks with the Performance timeline\n\nThe Performance timeline in the Metal debugger can help you find expensive tasks and performance bottlenecks in the captured workload. Open the Performance timeline by clicking the Performance button in the Debug navigator.\n\n\n\nThe Timeline navigator on the left side of the window lists all profiled passes, pipeline states, and GPU Commands with their shader profiler cost.\n\nThe top section has the Vertex, Fragment, and Compute GPU tracks, which display the beginning time and duration of individual passes running with overlap. Below the GPU tracks are the aggregated shader tracks that combine the individual shaders. You can view the timeline of individual shaders in a waterfall-like fashion by expanding the aggregated shader tracks.\n\nThe bottom section has a separate Counters timeline, which includes GPU counters such as Occupancy, Limiter, and Bandwidth. The counters can help you diagnose performance bottlenecks. You can focus on counter subsets by switching between different counter tabs. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-a-visual-timeline].\n\n### Get detailed performance metrics for passes and draws\n\nYou can view performance counter statistics from your app’s passes or commands in the GPU trace. Open the Performance counters by clicking the Counters tab above the Performance timeline.\n\n\n\nThe Metal debugger derives the shader profiler time by tracing the shader instructions when running the workload with overlap. In a shader-bound workload, sorting the table by shader profiler time can point you to the overall most expensive pass or draw. In addition, the Metal debugger measures the detailed counters from each pass or command in isolation. You can also choose different sets of counters in the top bar for a more focused view. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-counter-statistics].\n\n### Group commands by pipeline states in the Debug navigator\n\nFor a different perspective in viewing the Metal commands, click the Outline popup menu in the Debug navigator and select Group by Pipeline State to view a list of pipeline states.\n\n\n\nWith profiling data, the Debug navigator displays the percentage of samples from shaders of each pipeline state when running the workload with overlap. In a shader-bound workload, this sorted list of pipeline states is helpful in identifying the most expensive pipeline state. Expanding a pipeline state allows you to find a list of commands that use that state.\n\nYou can also quickly view the shader source code and per-line profiling statistics by selecting a shader from a pipeline state in the list.\n\nFor more information on the Debug navigator, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-your-Metal-workload].\n\n### Optimize shaders with per-line shader profiling statistics\n\nAfter opening a shader, you can find the time breakdown for the shader in the pipeline state.\n\n\n\nThe left sidebar allows you to inspect the shader source files and profiling call tree. With the call tree, you can find performance hot spots by the weights of each frame.\n\nIn the gutter of the shader source code, you can find weights next to the lines of code. The pie chart to the right of each weight contains performance statistics to help you improve the shader code.\n\nFor example, when you observe an expensive line of code with a high percentage for memory sample, it may be taking time to read texture data. To reduce the shader time, if it’s less expensive to compute the value than reading it from a texture, you can modify the code to calculate it in the shader.\n\nAfter making changes to the shader source code, click the Reload Shaders button in the debug bar to refresh the profiling statistics. You can verify whether the changes help with the overall performance by observing the new total GPU time and the tracks in the Performance timeline.\n\n\n\nFor more information on interpreting the per-line shader profiling statistics, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-shaders].\n\n### Inspect shader performance with the shader cost graph\n\n\n\nYou can quickly find and triage expensive pipeline states and shaders by using the shader cost graph. Select a pipeline state in the Timeline navigator, and then click the Shaders tab.\n\n\n\nYou can inspect the percentage cost of the shader function calls with the flame graph in the top section, and select function calls to jump directly to the source code.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-shader-cost-graph-a17-m3].\n\n### Understand SIMD group execution with the performance heat maps\n\n\n\nYou can quickly find and inspect the execution of your shader source code with the performance heat maps. Select an encoder, a pipeline state, or a GPU command in the Timeline navigator, and then click the Heat Maps tab.\n\n\n\nThe top section shows various heat maps graphing statistical information about GPU threads, such as the cost, the divergence, and the number of instructions.\n\nThe bottom section shows the shader execution history of GPU threads on a timeline, including function call stacks and thread states.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Analyzing-Apple-GPU-performance-using-performance-heatmaps-a17-m3].\n\n### Save the performance data to your development system\n\nYou can save your app’s Metal workload performance data as a GPU trace for later analysis by choosing File > Export, and selecting the Embed performance data checkbox in the dialog. This allows you to view just the performance data instead of replaying the GPU trace on a device.\n\n\n\nYou can open the GPU trace on any Mac — not just your development system — because it doesn’t require a compatible device to replay the trace. Optionally, you can replay the GPU trace by selecting a compatible device.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Replaying-a-GPU-trace-file].\n\n## Essentials\n\n- **Capturing a Metal workload in Xcode**: Analyze your app’s performance by configuring your project to use the Metal debugger.\n- **Capturing a Metal workload programmatically**: Analyze your app’s performance by invoking Metal’s frame capture.\n- **Replaying a GPU trace file**: Debug and profile your app’s performance using a GPU trace file in the Metal debugger.\n- **Investigating visual artifacts**: Discover, diagnose, and fix visual artifacts in your app with the Metal debugger.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Analyze your app’s performance by configuring your project to use the Metal debugger.",
          "name" : "Capturing a Metal workload in Xcode",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Capturing-a-Metal-workload-in-Xcode"
        },
        {
          "description" : "Analyze your app’s performance by invoking Metal’s frame capture.",
          "name" : "Capturing a Metal workload programmatically",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Capturing-a-Metal-workload-programmatically"
        },
        {
          "description" : "Debug and profile your app’s performance using a GPU trace file in the Metal debugger.",
          "name" : "Replaying a GPU trace file",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Replaying-a-GPU-trace-file"
        },
        {
          "description" : "Discover, diagnose, and fix visual artifacts in your app with the Metal debugger.",
          "name" : "Investigating visual artifacts",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Investigating-visual-artifacts"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Optimizing GPU performance",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Optimizing-GPU-performance"
}