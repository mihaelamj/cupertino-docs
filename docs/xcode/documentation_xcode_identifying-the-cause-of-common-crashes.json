{
  "abstract" : "Find patterns in crash reports that identify common problems, and investigate the issue based on the pattern.",
  "codeExamples" : [
    {
      "code" : "Exception Type:  EXC_BREAKPOINT (SIGTRAP)\n...\nTermination Signal: Trace\/BPT trap: 5\nTermination Reason: Namespace SIGNAL, Code 0x5",
      "language" : "other"
    },
    {
      "code" : "Exception Type:        EXC_BAD_INSTRUCTION (SIGILL)\n...\nException Note:        EXC_CORPSE_NOTIFY\n\nTermination Signal:    Illegal instruction: 4\nTermination Reason:    Namespace SIGNAL, Code 0x4",
      "language" : "other"
    },
    {
      "code" : "Thread 0 Crashed:\n0   MyCoolApp                         0x0000000100a71a88 @objc ViewController.viewDidLoad() (in MyCoolApp) (ViewController.swift:18)",
      "language" : "other"
    },
    {
      "code" : "Exception Type:    EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x400000000000bad0 -> 0x000000000000bad0 (possible pointer authentication failure)",
      "language" : "console"
    },
    {
      "code" : "Exception Type:    EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000bad0",
      "language" : "console"
    },
    {
      "code" : "@interface MyController : NSObject { }\n\n@property (atomic, strong) MyAppService *service;\n\n- (void)connectToService;\n- (MyServiceResult *)updateServiceStatus;\n\n@end\n\n@implementation MyController\n\n- (void)connectToService {\n    dispatch_async(aQueue, ^{\n        self.service = [[MyAppService alloc] init];\n        [self.service connect];\n    });\n}\n\n- (MyServiceResult *)updateServiceStatus {\n    return self.service.status;\n}\n\n@end",
      "language" : "objc"
    },
    {
      "code" : "Exception Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY",
      "language" : "other"
    },
    {
      "code" : "Last Exception Backtrace:\n0   CoreFoundation                    0x19aae2a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x19a809fa4 objc_exception_throw + 55",
      "language" : "other"
    },
    {
      "code" : "Exception Type:  EXC_CRASH (SIGKILL)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\nTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00d",
      "language" : "other"
    },
    {
      "code" : "Termination Description: SPRINGBOARD, \n    scene-create watchdog transgression: application<com.example.MyCoolApp>:667\n    exhausted real (wall clock) time allowance of 19.97 seconds \n    | ProcessVisibility: Foreground \n    | ProcessState: Running \n    | WatchdogEvent: scene-create \n    | WatchdogVisibility: Foreground \n    | WatchdogCPUStatistics: ( \n    |  \"Elapsed total CPU time (seconds): 15.290 (user 15.290, system 0.000), 28% CPU\", \n    |  \"Elapsed application CPU time (seconds): 0.367, 1% CPU\" \n    | )",
      "language" : "other"
    },
    {
      "code" : "Thread 0 Crashed:\n0   libobjc.A.dylib                   0x00000001a186d190 objc_msgSend + 16\n1   Foundation                        0x00000001a1f31238 __NSThreadPerformPerform + 232\n2   CoreFoundation                    0x00000001a1ac67e0 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24",
      "language" : "other"
    },
    {
      "code" : "Last Exception Backtrace:\n0   CoreFoundation                    0x1bf596a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x1bf2bdfa4 objc_exception_throw + 55\n2   CoreFoundation                    0x1bf49a5a8 -[NSObject+ 193960 (NSObject) doesNotRecognizeSelector:] + 139",
      "language" : "other"
    },
    {
      "code" : "Exception Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000\nVM Region Info: 0 is not in any region.  Bytes before following region: 4307009536\n\n      REGION TYPE                      START - END             [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->\n      __TEXT                 0000000100b7c000-0000000100b84000 [   32K] r-x\/r-x SM=COW  ...pp\/MyGreatApp",
      "language" : "other"
    },
    {
      "code" : "Exception Type: EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note: EXC_CORPSE_NOTIFY\nTermination Description: DYLD, dependent dylib '@rpath\/MyFramework.framework\/MyFramework'\n    not found for '<path>\/MyCoolApp.app\/MyCoolApp', tried but didn't find: \n    '\/usr\/lib\/swift\/MyFramework.framework\/MyFramework' \n    '<path>\/MyCoolApp.app\/Frameworks\/MyFramework.framework\/MyFramework' \n    '@rpath\/MyFramework.framework\/MyFramework' \n    '\/System\/Library\/Frameworks\/MyFramework.framework\/MyFramework'",
      "language" : "other"
    }
  ],
  "contentHash" : "be4bd16b0e224cb232016d7b1d4c092a59a9c6cbbb994d68a6ca21d593d56184",
  "crawledAt" : "2025-12-07T15:08:16Z",
  "id" : "A64DE679-E741-4322-97B1-93CACE2B68C2",
  "kind" : "collection",
  "language" : "swift",
  "overview" : "## Overview\n\nYou can identify the causes for many app crashes by looking for specific patterns in the crash report and taking specific diagnostic actions based on what the pattern shows. To recognize patterns, you consult two sections available in every crash report:\n\n\n\nSome types of common crashes have a Diagnostic Messages section or a `Last Exception Backtrace` in the Backtraces section, which further describe the issue. These sections aren’t present in all crash reports. [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report] describes each section and field in detail.\n\nCompare the examples provided in this article to a crash report you’re investigating. Once you find a match, proceed to the more detailed article about that type of crash.\n\nDetermining whether your crash report contains a pattern for a common issue is the first step in diagnosing a problem. In some cases, the suggested diagnostic actions won’t identify the cause of the issue, requiring a more thorough analysis of the entire crash report. [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] describes how to perform a detailed analysis of a crash report.\n\n### Determine whether the crash is a Swift runtime error\n\nSwift uses memory safety techniques to catch programming errors early. If the Swift runtime encounters a programming error, the runtime catches the error and intentionally crashes the app. These crashes have an identifiable pattern in the crash report. On ARM processors, the exception info in the crash report looks like:\n\nOn Intel processors (including apps for macOS, Mac Catalyst, and the simulators for iOS, iPadOS, tvOS, and watchOS), the exception info in the crash report looks like:\n\nAdditionally, the crash report shows the thread that encountered the error, with frame 0 in the backtrace identifying the specific line of code in your app containing the error, such as:\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-crashes-from-swift-runtime-errors] describes how to resolve this type of crash.\n\n### Determine whether the crash is an Objective-C concurrent property access error\n\nThe Objective-C runtime can detect when multiple threads concurrently write values to the same strong property; or when a thread reads a value from a strong property while another thread writes a value to the property. When the Objective-C runtime detects this situation, it catches the error and intentionally crashes the app. In most cases, the exception info in the crash report looks like this:\n\nIf the crash occurs in a 32-bit process on watchOS, the exception info in the crash report looks like this:\n\nTo resolve this type of crash, restructure your code so that different threads don’t concurrently read and write the property’s value. Alternatively, add the `atomic` keyword to the property declaration and ensure that all threads access the value through the property accessors:\n\nFor information on using Thread Sanitizer to detect concurrent access to memory locations, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/diagnosing-memory-thread-and-crash-issues-early].\n\n### Look for signs of a language exception\n\nApple’s system frameworks throw language exceptions when they encounter certain types of programming errors at runtime, such as accessing an array with an index that’s out-of-bounds. To determine whether a crash is due to a language exception, first confirm that the crash report contains this pattern:\n\nA crash due to a language exception also has a `Last Exception Backtrace` in the crash report:\n\nIf your crash report contains these patterns, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-language-exception-crashes] for how to address the crash.\n\n### Check for watchdog information\n\nThe operating system employs a watchdog to monitor app responsiveness. If an app is unresponsive, the watchdog terminates it, which creates a crash report with the `0x8badf00d` code in the Termination Reason:\n\nIn the crash report for an unresponsive app, the `Termination Description` contains information from the watchdog about how the app spent its time. For example:\n\nSee [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-watchdog-terminations] to diagnose why your app is unresponsive.\n\n### Determine whether the crash report contains signs of a zombie\n\n*Zombie objects* are objects that are messaged by the Objective-C runtime after they’re deallocated from memory and no longer exist. Messaging a deallocated object can cause a crash in the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend], `objc_retain`, or `objc_release` functions of the Objective-C runtime, such as this example with [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend]:\n\nA different pattern that also indicates a zombie object is the presence of a `Last Exception Backtrace` with a stack frame containing the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/doesNotRecognizeSelector(_:)] method:\n\nIf your crash report shows your app has a zombie, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-crashes-for-zombie-objects].\n\n### Determine whether there’s a memory access issue\n\nWhen your app uses memory in an unexpected way, you’ll receive a crash report about a memory access issue. These types of crash reports have a `EXC_BAD_ACCESS` exception type, plus additional information in the `VM Region Info` field. For example:\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-memory-access-crashes] contains information on the different types of memory access issues and how to investigate them.\n\n### Determine whether a framework is missing\n\nIf an app crashes because it’s missing a required framework, the crash report contains the `EXC_CRASH (SIGABRT)` exception code. You’ll also find a `Termination Description` in the crash report, identifying the specific framework that the dynamic linker, `dyld`, couldn’t locate. Here’s an example, with extra line breaks included for readability:\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-missing-framework-crashes] discusses how to resolve this issue.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/xcode\/identifying-the-cause-of-common-crashes\ncrawled: 2025-12-07T15:08:16Z\n---\n\n# Identifying the cause of common crashes\n\nFind patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\n\n## Overview\n\nYou can identify the causes for many app crashes by looking for specific patterns in the crash report and taking specific diagnostic actions based on what the pattern shows. To recognize patterns, you consult two sections available in every crash report:\n\n- The exception code in the Exception Information section identifies the specific way the app crashed.\n- The backtraces show what code the thread was executing at the time of the crash.\n\n\n\nSome types of common crashes have a Diagnostic Messages section or a `Last Exception Backtrace` in the Backtraces section, which further describe the issue. These sections aren’t present in all crash reports. [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report] describes each section and field in detail.\n\nCompare the examples provided in this article to a crash report you’re investigating. Once you find a match, proceed to the more detailed article about that type of crash.\n\nDetermining whether your crash report contains a pattern for a common issue is the first step in diagnosing a problem. In some cases, the suggested diagnostic actions won’t identify the cause of the issue, requiring a more thorough analysis of the entire crash report. [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] describes how to perform a detailed analysis of a crash report.\n\n\n\n### Determine whether the crash is a Swift runtime error\n\nSwift uses memory safety techniques to catch programming errors early. If the Swift runtime encounters a programming error, the runtime catches the error and intentionally crashes the app. These crashes have an identifiable pattern in the crash report. On ARM processors, the exception info in the crash report looks like:\n\n```other\nException Type:  EXC_BREAKPOINT (SIGTRAP)\n...\nTermination Signal: Trace\/BPT trap: 5\nTermination Reason: Namespace SIGNAL, Code 0x5\n```\n\nOn Intel processors (including apps for macOS, Mac Catalyst, and the simulators for iOS, iPadOS, tvOS, and watchOS), the exception info in the crash report looks like:\n\n```other\nException Type:        EXC_BAD_INSTRUCTION (SIGILL)\n...\nException Note:        EXC_CORPSE_NOTIFY\n\nTermination Signal:    Illegal instruction: 4\nTermination Reason:    Namespace SIGNAL, Code 0x4\n```\n\nAdditionally, the crash report shows the thread that encountered the error, with frame 0 in the backtrace identifying the specific line of code in your app containing the error, such as:\n\n```other\nThread 0 Crashed:\n0   MyCoolApp                         0x0000000100a71a88 @objc ViewController.viewDidLoad() (in MyCoolApp) (ViewController.swift:18)\n```\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-crashes-from-swift-runtime-errors] describes how to resolve this type of crash.\n\n### Determine whether the crash is an Objective-C concurrent property access error\n\nThe Objective-C runtime can detect when multiple threads concurrently write values to the same strong property; or when a thread reads a value from a strong property while another thread writes a value to the property. When the Objective-C runtime detects this situation, it catches the error and intentionally crashes the app. In most cases, the exception info in the crash report looks like this:\n\n```console\nException Type:    EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x400000000000bad0 -> 0x000000000000bad0 (possible pointer authentication failure)\n```\n\nIf the crash occurs in a 32-bit process on watchOS, the exception info in the crash report looks like this:\n\n```console\nException Type:    EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000bad0\n```\n\nTo resolve this type of crash, restructure your code so that different threads don’t concurrently read and write the property’s value. Alternatively, add the `atomic` keyword to the property declaration and ensure that all threads access the value through the property accessors:\n\n```objc\n@interface MyController : NSObject { }\n\n@property (atomic, strong) MyAppService *service;\n\n- (void)connectToService;\n- (MyServiceResult *)updateServiceStatus;\n\n@end\n\n@implementation MyController\n\n- (void)connectToService {\n    dispatch_async(aQueue, ^{\n        self.service = [[MyAppService alloc] init];\n        [self.service connect];\n    });\n}\n\n- (MyServiceResult *)updateServiceStatus {\n    return self.service.status;\n}\n\n@end\n```\n\nFor information on using Thread Sanitizer to detect concurrent access to memory locations, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/diagnosing-memory-thread-and-crash-issues-early].\n\n### Look for signs of a language exception\n\nApple’s system frameworks throw language exceptions when they encounter certain types of programming errors at runtime, such as accessing an array with an index that’s out-of-bounds. To determine whether a crash is due to a language exception, first confirm that the crash report contains this pattern:\n\n```other\nException Type:  EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\n```\n\nA crash due to a language exception also has a `Last Exception Backtrace` in the crash report:\n\n```other\nLast Exception Backtrace:\n0   CoreFoundation                    0x19aae2a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x19a809fa4 objc_exception_throw + 55\n```\n\nIf your crash report contains these patterns, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-language-exception-crashes] for how to address the crash.\n\n### Check for watchdog information\n\nThe operating system employs a watchdog to monitor app responsiveness. If an app is unresponsive, the watchdog terminates it, which creates a crash report with the `0x8badf00d` code in the Termination Reason:\n\n```other\nException Type:  EXC_CRASH (SIGKILL)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note:  EXC_CORPSE_NOTIFY\nTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00d\n```\n\nIn the crash report for an unresponsive app, the `Termination Description` contains information from the watchdog about how the app spent its time. For example:\n\n```other\nTermination Description: SPRINGBOARD, \n    scene-create watchdog transgression: application<com.example.MyCoolApp>:667\n    exhausted real (wall clock) time allowance of 19.97 seconds \n    | ProcessVisibility: Foreground \n    | ProcessState: Running \n    | WatchdogEvent: scene-create \n    | WatchdogVisibility: Foreground \n    | WatchdogCPUStatistics: ( \n    |  \"Elapsed total CPU time (seconds): 15.290 (user 15.290, system 0.000), 28% CPU\", \n    |  \"Elapsed application CPU time (seconds): 0.367, 1% CPU\" \n    | )\n```\n\n\n\nSee [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-watchdog-terminations] to diagnose why your app is unresponsive.\n\n### Determine whether the crash report contains signs of a zombie\n\n*Zombie objects* are objects that are messaged by the Objective-C runtime after they’re deallocated from memory and no longer exist. Messaging a deallocated object can cause a crash in the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend], `objc_retain`, or `objc_release` functions of the Objective-C runtime, such as this example with [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend]:\n\n```other\nThread 0 Crashed:\n0   libobjc.A.dylib                   0x00000001a186d190 objc_msgSend + 16\n1   Foundation                        0x00000001a1f31238 __NSThreadPerformPerform + 232\n2   CoreFoundation                    0x00000001a1ac67e0 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24\n```\n\nA different pattern that also indicates a zombie object is the presence of a `Last Exception Backtrace` with a stack frame containing the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/NSObject-swift.class\/doesNotRecognizeSelector(_:)] method:\n\n```other\nLast Exception Backtrace:\n0   CoreFoundation                    0x1bf596a48 __exceptionPreprocess + 220\n1   libobjc.A.dylib                   0x1bf2bdfa4 objc_exception_throw + 55\n2   CoreFoundation                    0x1bf49a5a8 -[NSObject+ 193960 (NSObject) doesNotRecognizeSelector:] + 139\n```\n\nIf your crash report shows your app has a zombie, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-crashes-for-zombie-objects].\n\n### Determine whether there’s a memory access issue\n\nWhen your app uses memory in an unexpected way, you’ll receive a crash report about a memory access issue. These types of crash reports have a `EXC_BAD_ACCESS` exception type, plus additional information in the `VM Region Info` field. For example:\n\n```other\nException Type:  EXC_BAD_ACCESS (SIGSEGV)\nException Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000\nVM Region Info: 0 is not in any region.  Bytes before following region: 4307009536\n\n      REGION TYPE                      START - END             [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      UNUSED SPACE AT START\n--->\n      __TEXT                 0000000100b7c000-0000000100b84000 [   32K] r-x\/r-x SM=COW  ...pp\/MyGreatApp\n```\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-memory-access-crashes] contains information on the different types of memory access issues and how to investigate them.\n\n### Determine whether a framework is missing\n\nIf an app crashes because it’s missing a required framework, the crash report contains the `EXC_CRASH (SIGABRT)` exception code. You’ll also find a `Termination Description` in the crash report, identifying the specific framework that the dynamic linker, `dyld`, couldn’t locate. Here’s an example, with extra line breaks included for readability:\n\n```other\nException Type: EXC_CRASH (SIGABRT)\nException Codes: 0x0000000000000000, 0x0000000000000000\nException Note: EXC_CORPSE_NOTIFY\nTermination Description: DYLD, dependent dylib '@rpath\/MyFramework.framework\/MyFramework'\n    not found for '<path>\/MyCoolApp.app\/MyCoolApp', tried but didn't find: \n    '\/usr\/lib\/swift\/MyFramework.framework\/MyFramework' \n    '<path>\/MyCoolApp.app\/Frameworks\/MyFramework.framework\/MyFramework' \n    '@rpath\/MyFramework.framework\/MyFramework' \n    '\/System\/Library\/Frameworks\/MyFramework.framework\/MyFramework'\n```\n\n\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-missing-framework-crashes] discusses how to resolve this issue.\n\n## Runtime errors\n\n- **Addressing crashes from Swift runtime errors**: Identify the signs of a Swift runtime error, and address the crashes runtime errors cause.\n- **Addressing language exception crashes**: Identify the signs of a language exception, and address the crashes caused by uncaught language exceptions.\n- **Reading an exception message**: Understand and address the common reasons apps crash.\n\n## System terminations\n\n- **Addressing watchdog terminations**: Identify the signature of an unresponsive app terminated by the watchdog, and address the issue.\n\n## Memory access errors\n\n- **Investigating crashes for zombie objects**: Identify the signature of a zombie and investigate the cause of the crash.\n- **Investigating memory access crashes**: Identify crashes that arise from memory access issues, and investigate the cause of the crash.\n\n## App configuration errors\n\n- **Addressing missing framework crashes**: Identify missing frameworks from a crash report, and adjust your app’s build to correctly include the framework.\n\n## Crash reports\n\n- **Adding identifiable symbol names to a crash report**: Replace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\n- **Analyzing a crash report**: Identify clues in a crash report that help you diagnose problems.\n- **Examining the fields in a crash report**: Understand the structure of a crash report and the information each field contains.\n- **Interpreting the JSON format of a crash report**: Understand the structure and properties of the objects the system includes in the JSON of a crash report.\n- **Understanding the exception types in a crash report**: Learn what the exception type tells you about why your app crashed.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Identify the signs of a Swift runtime error, and address the crashes runtime errors cause.",
          "name" : "Addressing crashes from Swift runtime errors",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/addressing-crashes-from-swift-runtime-errors"
        },
        {
          "description" : "Identify the signs of a language exception, and address the crashes caused by uncaught language exceptions.",
          "name" : "Addressing language exception crashes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/addressing-language-exception-crashes"
        },
        {
          "description" : "Understand and address the common reasons apps crash.",
          "name" : "Reading an exception message",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/reading-an-exception-message"
        }
      ],
      "title" : "Runtime errors"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Identify the signature of an unresponsive app terminated by the watchdog, and address the issue.",
          "name" : "Addressing watchdog terminations",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/addressing-watchdog-terminations"
        }
      ],
      "title" : "System terminations"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Identify the signature of a zombie and investigate the cause of the crash.",
          "name" : "Investigating crashes for zombie objects",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/investigating-crashes-for-zombie-objects"
        },
        {
          "description" : "Identify crashes that arise from memory access issues, and investigate the cause of the crash.",
          "name" : "Investigating memory access crashes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/investigating-memory-access-crashes"
        }
      ],
      "title" : "Memory access errors"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Identify missing frameworks from a crash report, and adjust your app’s build to correctly include the framework.",
          "name" : "Addressing missing framework crashes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/addressing-missing-framework-crashes"
        }
      ],
      "title" : "App configuration errors"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Replace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.",
          "name" : "Adding identifiable symbol names to a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report"
        },
        {
          "description" : "Identify clues in a crash report that help you diagnose problems.",
          "name" : "Analyzing a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/analyzing-a-crash-report"
        },
        {
          "description" : "Understand the structure of a crash report and the information each field contains.",
          "name" : "Examining the fields in a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/examining-the-fields-in-a-crash-report"
        },
        {
          "description" : "Understand the structure and properties of the objects the system includes in the JSON of a crash report.",
          "name" : "Interpreting the JSON format of a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/interpreting-the-JSON-format-of-a-crash-report"
        },
        {
          "description" : "Learn what the exception type tells you about why your app crashed.",
          "name" : "Understanding the exception types in a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/understanding-the-exception-types-in-a-crash-report"
        }
      ],
      "title" : "Crash reports"
    }
  ],
  "source" : "appleJSON",
  "title" : "Identifying the cause of common crashes",
  "url" : "https:\/\/developer.apple.com\/documentation\/xcode\/identifying-the-cause-of-common-crashes"
}