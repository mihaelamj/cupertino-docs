{
  "abstract" : "Sign Mac code for distribution using either Xcode or command-line tools.",
  "codeExamples" : [
    {
      "code" : "DaemonWithApp.xcarchive\/\n  Info.plist\n  Products\/\n    usr\/\n      local\/\n        bin\/\n          Daemon\n    Applications\/\n      ConfigApp.app\/\n        Contents\/\n          embedded.provisionprofile\n          Frameworks\/\n            Core.framework\/\n              …\n          PlugIns\/\n            Share.appex\/\n              Contents\/\n                embedded.provisionprofile\n                …\n          …\n  …"
    },
    {
      "code" : "% mkdir \"to-be-signed\"\n% ditto \"DaemonWithApp.xcarchive\/Products\/usr\/local\/bin\/Daemon\" \"to-be-signed\/Daemon\"\n% ditto \"DaemonWithApp.xcarchive\/Products\/Applications\/ConfigApp.app\" \"to-be-signed\/ConfigApp.app\" "
    },
    {
      "code" : "% file \"to-be-signed\/ConfigApp.app\/Contents\/Frameworks\/Core.framework\/Versions\/A\/Core\"\n…\n… Mach-O 64-bit dynamically linked shared library x86_64\n…\n% file \"to-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex\/Contents\/MacOS\/Share\"\n…\n… Mach-O 64-bit executable x86_64\n…"
    },
    {
      "code" : "% codesign -d --entitlements - --xml \"to-be-signed\/ConfigApp.app\" | plutil -convert xml1 -o - -\n…\n<dict>\n  <key>com.apple.application-identifier<\/key>\n  <string>[Your Team ID].com.example.apple-samplecode.DaemonWithApp.App<\/string>\n  <key>com.apple.developer.team-identifier<\/key>\n  <string>[Your Team ID]<\/string>\n  <key>com.apple.security.app-sandbox<\/key>\n  <true\/>\n  <key>keychain-access-groups<\/key>\n  <array>\n    <string>[Your Team ID].com.example.apple-samplecode.DaemonWithApp.SharedKeychain<\/string>\n  <\/array>\n<\/dict>\n<\/plist>"
    },
    {
      "code" : "% cp \"ConfigApp-Dist.provisionprofile\" \"to-be-signed\/ConfigApp.app\/Contents\/embedded.provisionprofile\"\n% cp \"Share-Dist.provisionprofile\" \"to-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex\/Contents\/embedded.provisionprofile\""
    },
    {
      "code" : "% codesign -d -vv to-be-signed\/Daemon\n…\nAuthority=Apple Development: …\n…"
    },
    {
      "code" : "% security find-identity -p codesigning -v\n  1) A06E7F3F8237330EE15CB91BE1A511C00B853358 \"Apple Distribution: …\"\n  2) ADC03B244F4C1018384DCAFFC920F26136F6B59B \"Developer ID Application: …\"\n     2 valid identities found"
    },
    {
      "code" : "% codesign -s <CodeSigningIdentity> <PathToExecutable>"
    },
    {
      "code" : "% codesign -s \"Developer ID Application\" -f --timestamp \"to-be-signed\/ConfigApp.app\/Contents\/Frameworks\/Core.framework\"\nto-be-signed\/ConfigApp.app\/Contents\/Frameworks\/Core.framework: replacing existing signature\n% codesign -s \"Developer ID Application\" -f --timestamp -o runtime --entitlements \"Share.entitlements\" \"to-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex\"\nto-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex: replacing existing signature\n% codesign -s \"Developer ID Application\" -f --timestamp -o runtime --entitlements \"ConfigApp.entitlements\" \"to-be-signed\/ConfigApp.app\"\nto-be-signed\/ConfigApp.app: replacing existing signature\n% codesign -s \"Developer ID Application\" -f --timestamp -o runtime -i \"com.example.apple-samplecode.DaemonWithApp.Daemon\" \"to-be-signed\/Daemon\"\nto-be-signed\/Daemon: replacing existing signature"
    }
  ],
  "contentHash" : "f676940a4192ce8196bda92b9bd8a4091804cb15994b778c960b9f169a8cdb64",
  "crawledAt" : "2025-12-04T01:02:41Z",
  "id" : "4F2FB0DA-6C7B-4F8F-BC55-9567ACCC3145",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nBefore shipping a software product for the Mac, you need to first create distribution-signed code, which is code that you package up and submit to either the Mac App Store or the notary service.  The way you do this depends on the type of your product and how you build it:\n\nWhen you have distribution-signed code, package it for distribution. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/packaging-mac-software-for-distribution].\n\n## Export an app from Xcode\n\nIf your product is a standalone app that you build with Xcode, follow these steps to export a distribution-signed app:\n\nYou can complete each step from the Xcode app or automate the steps using `xcodebuild`.\n\nTo create a distribution-signed app using the Xcode app:\n\nFor more information about Xcode archives and the Archives organizer, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/distributing-your-app-for-beta-testing-and-releases].\n\nTo export a distribution-signed app from the command line:\n\nFor more information about `xcodebuild`, see its manual page.  For instructions on how to read a manual page, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].  For information about the keys supported by the export options property list, run `xcodebuild` with the `-help` argument.\n\n## Export a non-app product built with Xcode\n\nTo archive a non-app product in Xcode, follow the steps in “Export an app from Xcode” above.\n\nTo export a distribution-signed product from the Xcode archive:\n\nThe commands that you use depend on your project structure. For example, imagine your product is a daemon, but it also has an associated configuration app.  The configuration app has a share extension and an embedded framework to share code between the app and the extension. An archive of this product in Xcode has the following structure:\n\nThe `Products` directory contains two items: the daemon itself (`Daemon`) and the configuration app (`ConfigApp.app`). To sign this product, first copy these items out of the archive.\n\n## Identify the code to sign\n\nTo sign your product, first identify each code item that you need to sign. For example, in the `DaemonWithApp` product, there are four code items: `ConfigApp.app`, `Core.framework`, `Share.appex`, and `Daemon`.\n\nFor each code item, determine the following:\n\nBundled code is the main code within a bundle. If, for example, you have an app with a nested helper tool, there are two code items: the app and the helper tool. The app is considered bundled code, but the helper tool isn’t.\n\nThe following table shows the code items in the `DaemonWithApp` product and whether they’re bundled code or a main executable:\n\nIn some cases, it might not be obvious whether the code item is a main executable. To confirm, run the `file` command. A main executable says `Mach-O … executable` as the following example shows:\n\n`Core.framework` isn’t a main executable, but `Share.appex` is.\n\n## Determine the signing order\n\nSign code from the inside out.  That is, if component `A` depends on component `B`, sign `B` before you sign `A`.  For the `DaemonWithApp` example, sign the components in the following order:\n\nThe app and daemon are independent, so you can sign them in either order.\n\n## Configure your entitlements\n\nA code signature can include *entitlements* — key-value pairs that grant an executable permission to use a service or technology. When macOS runs a process, it grants that process the entitlements that its executable’s code signature claims. For more information, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements].\n\nYou apply entitlements to a main executable. If your main executable needs entitlements, create an `.entitlements` property list file, and add the key-value pairs for the entitlements that the executable claims.\n\nIf you build your product with Xcode, you might be able to use the `.entitlements` file that Xcode manages in your source code.  If not, create the `.entitlements` file yourself.\n\nIf you have a development-signed version of your program, you can print its entitlements using the `codesign` command-line tool, and use that information as the basis for your entitlements property list file as the following example shows:\n\nIf you use the entitlements from a development-signed version of your program to create the entitlements property list file for your distribution-signed code, consider the following changes to the entitlements:\n\nFor any other entitlement, see the documentation for that specific entitlement in [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements].\n\n## Configure your designated requirements\n\nA code signature includes a designated requirement (DR) that macOS uses to identify the code.  For example, macOS uses the DR to track access to privacy-protected resources like the microphone.  For more information, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3127-inside-code-signing-requirements].\n\nWhen you sign code with the `codesign` tool, it applies a default DR.  The default DR works well for most products, with one notable exception: The default DR for a Mac App Store app and a Developer ID-signed app are not mutually compatible.  If you distribute two variants of your app, one on the Mac App Store and one that you distribute directly using Developer ID signing, then, by default, those variants don’t share access to privacy-protected resources.\n\nTo share access to privacy-protected resources across variants, sign the variants with mutually compatible DRs.  For advice on how to craft these DRs, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3127-inside-code-signing-requirements].\n\nIf you decide to use a custom DR, save it to a requirements file.  Mutually compatible DRs include a code-signing identifier.  If your product has multiple code items, copy this requirements file for each code item and update the code-signing identifier to match that of the code.\n\n## Embed distribution provisioning profiles\n\nFor security reasons, a provisioning profile needs to authorize most entitlement claims. For example, the `keychain-access-groups` entitlement requires authorization by a provisioning profile. This stops other developers from distributing apps that impersonate your app to access its confidential keychain items.\n\nmacOS allows programs to claim certain entitlements without such authorization.  These unrestricted entitlements include:\n\nIf your program claims a restricted entitlement, include a distribution provisioning profile to authorize that claim as follows:\n\nIf your product includes a nonbundled executable that uses a restricted entitlement, package that executable in an app-like structure.  For more information, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/signing-a-daemon-with-a-restricted-entitlement].\n\nIn the `DaemonWithApp` example, the configuration app and its share extension use a keychain access group to share secrets. The system grants the programs access to that group based on their `keychain-access-groups` entitlement claim, and a provisioning profile needs to authorize such claims. The app and the share extension each have their own profile. To distribute the app, update the app and share extension bundles with the corresponding distribution provisioning profile.\n\nModifying the app in this way breaks the seal on its code signature.  You re-sign the app before you distribute it.\n\n## Confirm your code-signing identity\n\nThe code you copy from the Xcode archive is typically signed using a development code-signing identity.\n\nTo ship a product that you signed for development, you need to re-sign it for distribution using an appropriate code-signing identity.  Choose one of the following identities for your distribution channel:\n\nFor information on how to set up these code-signing identities, see [https:\/\/developer.apple.com\/help\/account\/].\n\nTo confirm that your code-signing identity is present and correct, run the following command:\n\nThe `-p codesigning` argument filters for code-signing identities. The `-v` argument filters for valid identities only.  If the code-signing identity that you need isn’t listed, see [https:\/\/developer.apple.com\/help\/account\/].\n\nEach output line includes a SHA-1 hash that uniquely identifies the identity. If you have multiple identities with the same name, sign your code using this hash rather than the identity name.\n\n## Sign each code item\n\nFor all code types, the basic `codesign` command looks like the following:\n\nReplace `<CodeSigningIdentity>` with the name of the code-signing identity to use, and replace `<PathToExecutable>` with the path to the code to sign.\n\nThe specific identity you use for `<CodeSigningIdentity>` depends on your distribution channel, as discussed in “Confirm your code-signing identity” above.\n\nIf you’re re-signing code — that is, the code you’re signing is already signed — add the `-f` option.\n\nIf you’re signing a main executable that needs entitlements, add the `--entitlements <entitlementsPath>` option, where `<entitlementsPath>` is the path to the entitlements file that you created for that executable.\n\nIf you’re signing for Developer ID distribution, add the `--timestamp` option to include a secure timestamp.\n\nIf you’re signing a main executable for Developer ID distribution, add the `-o runtime` option to enable the Hardened Runtime.  For more information about the Hardened Runtime, see [doc:\/\/com.apple.documentation\/documentation\/Security\/hardened-runtime].\n\nIf you’re signing nonbundled code, add the `-i <BundleID>` option to set the code-signing identifier, where `<BundleID>` is the bundle ID the code would have if it had a bundle ID.  For example, for an app with a  bundle ID of `com.example.flying-animals` that has a nested command-line tool called `pig-jato`, you can use `com.example.flying-animals.pig-jato` as the bundle ID for the command-line tool.\n\nIf you’re using a custom DR, add the `-r <ReqPath>` option, where `<ReqPath>` is the path to the requirements file containing the DR for this code item.\n\nRepeat this signing step for every code item in your product, in the order you established in “Determine the signing order” above. If you have a complex product with many code items to sign, create a script to automate this process.\n\nThe folloiwng code shows the complete sequence of commands to sign the `DaemonWithApp` example for Developer ID distribution:\n\n## Avoid deep code signing\n\nDon’t pass the `--deep` option to `codesign` when you sign code.  This option is helpful in some specific circumstances (for example, in verifying a code signature), but it causes the following problems when signing a complex product:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/creating-distribution-signed-code-for-the-mac\ncrawled: 2025-12-04T01:02:41Z\n---\n\n# Creating distribution-signed code for macOS\n\n**Article**\n\nSign Mac code for distribution using either Xcode or command-line tools.\n\n## Overview\n\nBefore shipping a software product for the Mac, you need to first create distribution-signed code, which is code that you package up and submit to either the Mac App Store or the notary service.  The way you do this depends on the type of your product and how you build it:\n\n- If your product is a Mac app bundle, possibly containing nested code such as an app extension, that you build using Xcode, use Xcode to export a distribution-signed app.\n- If your product isn’t an app, but you build it using Xcode, create an Xcode archive, and then manually export distribution-signed code from that archive.\n- If you build your product using an external build system, such as `make`, add a manual signing step to your build system.\n\nWhen you have distribution-signed code, package it for distribution. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/packaging-mac-software-for-distribution].\n\n\n\n## Export an app from Xcode\n\nIf your product is a standalone app that you build with Xcode, follow these steps to export a distribution-signed app:\n\n1. Build an Xcode archive from your project.\n2. Export a distribution-signed app from that Xcode archive.\n\nYou can complete each step from the Xcode app or automate the steps using `xcodebuild`.\n\nTo create a distribution-signed app using the Xcode app:\n\n1. Select your app’s scheme.\n2. Choose Product > Archive.\n3. In the Archives organizer, select the archive created in step 2.\n4. Click Distribute App.\n5. Choose the appropriate distribution method. For example, to create a notarized app that you send directly to your customers, choose Direct Distribution.\n6. Click Distribute.\n\n\n\nFor more information about Xcode archives and the Archives organizer, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/distributing-your-app-for-beta-testing-and-releases].\n\nTo export a distribution-signed app from the command line:\n\n1. Run `xcodebuild` with the `archive` action to build and archive your app.\n2. Run `xcodebuild` with the `exportArchive` action to export the distribution-signed app from the archive created in step 1.\n\nFor more information about `xcodebuild`, see its manual page.  For instructions on how to read a manual page, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].  For information about the keys supported by the export options property list, run `xcodebuild` with the `-help` argument.\n\n## Export a non-app product built with Xcode\n\nTo archive a non-app product in Xcode, follow the steps in “Export an app from Xcode” above.\n\nTo export a distribution-signed product from the Xcode archive:\n\n1. Copy the relevant components from the archive.\n2. Sign those components manually.\n\nThe commands that you use depend on your project structure. For example, imagine your product is a daemon, but it also has an associated configuration app.  The configuration app has a share extension and an embedded framework to share code between the app and the extension. An archive of this product in Xcode has the following structure:\n\n```\nDaemonWithApp.xcarchive\/\n  Info.plist\n  Products\/\n    usr\/\n      local\/\n        bin\/\n          Daemon\n    Applications\/\n      ConfigApp.app\/\n        Contents\/\n          embedded.provisionprofile\n          Frameworks\/\n            Core.framework\/\n              …\n          PlugIns\/\n            Share.appex\/\n              Contents\/\n                embedded.provisionprofile\n                …\n          …\n  …\n```\n\nThe `Products` directory contains two items: the daemon itself (`Daemon`) and the configuration app (`ConfigApp.app`). To sign this product, first copy these items out of the archive.\n\n```\n% mkdir \"to-be-signed\"\n% ditto \"DaemonWithApp.xcarchive\/Products\/usr\/local\/bin\/Daemon\" \"to-be-signed\/Daemon\"\n% ditto \"DaemonWithApp.xcarchive\/Products\/Applications\/ConfigApp.app\" \"to-be-signed\/ConfigApp.app\" \n```\n\n\n\n## Identify the code to sign\n\nTo sign your product, first identify each code item that you need to sign. For example, in the `DaemonWithApp` product, there are four code items: `ConfigApp.app`, `Core.framework`, `Share.appex`, and `Daemon`.\n\nFor each code item, determine the following:\n\n- Is it bundled code?\n- Is it a main executable?\n\nBundled code is the main code within a bundle. If, for example, you have an app with a nested helper tool, there are two code items: the app and the helper tool. The app is considered bundled code, but the helper tool isn’t.\n\nThe following table shows the code items in the `DaemonWithApp` product and whether they’re bundled code or a main executable:\n\n\n\nIn some cases, it might not be obvious whether the code item is a main executable. To confirm, run the `file` command. A main executable says `Mach-O … executable` as the following example shows:\n\n```\n% file \"to-be-signed\/ConfigApp.app\/Contents\/Frameworks\/Core.framework\/Versions\/A\/Core\"\n…\n… Mach-O 64-bit dynamically linked shared library x86_64\n…\n% file \"to-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex\/Contents\/MacOS\/Share\"\n…\n… Mach-O 64-bit executable x86_64\n…\n```\n\n`Core.framework` isn’t a main executable, but `Share.appex` is.\n\n## Determine the signing order\n\nSign code from the inside out.  That is, if component `A` depends on component `B`, sign `B` before you sign `A`.  For the `DaemonWithApp` example, sign the components in the following order:\n\n1. `Core.framework`\n2. `Share.appex `\n3. `ConfigApp.app`\n\nThe app and daemon are independent, so you can sign them in either order.\n\n## Configure your entitlements\n\nA code signature can include *entitlements* — key-value pairs that grant an executable permission to use a service or technology. When macOS runs a process, it grants that process the entitlements that its executable’s code signature claims. For more information, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements].\n\n\n\nYou apply entitlements to a main executable. If your main executable needs entitlements, create an `.entitlements` property list file, and add the key-value pairs for the entitlements that the executable claims.\n\nIf you build your product with Xcode, you might be able to use the `.entitlements` file that Xcode manages in your source code.  If not, create the `.entitlements` file yourself.\n\n\n\nIf you have a development-signed version of your program, you can print its entitlements using the `codesign` command-line tool, and use that information as the basis for your entitlements property list file as the following example shows:\n\n```\n% codesign -d --entitlements - --xml \"to-be-signed\/ConfigApp.app\" | plutil -convert xml1 -o - -\n…\n<dict>\n  <key>com.apple.application-identifier<\/key>\n  <string>[Your Team ID].com.example.apple-samplecode.DaemonWithApp.App<\/string>\n  <key>com.apple.developer.team-identifier<\/key>\n  <string>[Your Team ID]<\/string>\n  <key>com.apple.security.app-sandbox<\/key>\n  <true\/>\n  <key>keychain-access-groups<\/key>\n  <array>\n    <string>[Your Team ID].com.example.apple-samplecode.DaemonWithApp.SharedKeychain<\/string>\n  <\/array>\n<\/dict>\n<\/plist>\n```\n\nIf you use the entitlements from a development-signed version of your program to create the entitlements property list file for your distribution-signed code, consider the following changes to the entitlements:\n\n- Change the value of [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.aps-environment] from `development` to `production`.\n- The `com.apple.security.get-task-allow` entitlement allows the debugger to attach to your program, so you rarely apply it to a distribution-signed program. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Security\/resolving-common-notarization-issues#3087731].\n\nFor any other entitlement, see the documentation for that specific entitlement in [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements].\n\n## Configure your designated requirements\n\nA code signature includes a designated requirement (DR) that macOS uses to identify the code.  For example, macOS uses the DR to track access to privacy-protected resources like the microphone.  For more information, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3127-inside-code-signing-requirements].\n\nWhen you sign code with the `codesign` tool, it applies a default DR.  The default DR works well for most products, with one notable exception: The default DR for a Mac App Store app and a Developer ID-signed app are not mutually compatible.  If you distribute two variants of your app, one on the Mac App Store and one that you distribute directly using Developer ID signing, then, by default, those variants don’t share access to privacy-protected resources.\n\nTo share access to privacy-protected resources across variants, sign the variants with mutually compatible DRs.  For advice on how to craft these DRs, see [doc:\/\/com.apple.documentation\/documentation\/Technotes\/tn3127-inside-code-signing-requirements].\n\nIf you decide to use a custom DR, save it to a requirements file.  Mutually compatible DRs include a code-signing identifier.  If your product has multiple code items, copy this requirements file for each code item and update the code-signing identifier to match that of the code.\n\n## Embed distribution provisioning profiles\n\nFor security reasons, a provisioning profile needs to authorize most entitlement claims. For example, the `keychain-access-groups` entitlement requires authorization by a provisioning profile. This stops other developers from distributing apps that impersonate your app to access its confidential keychain items.\n\nmacOS allows programs to claim certain entitlements without such authorization.  These unrestricted entitlements include:\n\n- `com.apple.security.get-task-allow`\n- `com.apple.security.application-groups`\n- Entitlements that enable and configure the [doc:\/\/com.apple.documentation\/documentation\/Security\/app-sandbox]\n- Entitlements that configure the [doc:\/\/com.apple.documentation\/documentation\/Security\/hardened-runtime]\n\nIf your program claims a restricted entitlement, include a distribution provisioning profile to authorize that claim as follows:\n\n1. Create the profile on the developer website. For more information, see [https:\/\/developer.apple.com\/help\/account\/]. Make sure to choose a profile type that matches your distribution channel (Mac App Store or Developer ID).\n2. Copy that profile into your program’s bundle. For more information, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle].\n\nIf your product includes a nonbundled executable that uses a restricted entitlement, package that executable in an app-like structure.  For more information, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/signing-a-daemon-with-a-restricted-entitlement].\n\nIn the `DaemonWithApp` example, the configuration app and its share extension use a keychain access group to share secrets. The system grants the programs access to that group based on their `keychain-access-groups` entitlement claim, and a provisioning profile needs to authorize such claims. The app and the share extension each have their own profile. To distribute the app, update the app and share extension bundles with the corresponding distribution provisioning profile.\n\n```\n% cp \"ConfigApp-Dist.provisionprofile\" \"to-be-signed\/ConfigApp.app\/Contents\/embedded.provisionprofile\"\n% cp \"Share-Dist.provisionprofile\" \"to-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex\/Contents\/embedded.provisionprofile\"\n```\n\nModifying the app in this way breaks the seal on its code signature.  You re-sign the app before you distribute it.\n\n\n\n## Confirm your code-signing identity\n\nThe code you copy from the Xcode archive is typically signed using a development code-signing identity.\n\n```\n% codesign -d -vv to-be-signed\/Daemon\n…\nAuthority=Apple Development: …\n…\n```\n\nTo ship a product that you signed for development, you need to re-sign it for distribution using an appropriate code-signing identity.  Choose one of the following identities for your distribution channel:\n\n- To distribute an app on the Mac App Store, use an Apple Distribution code-signing identity.  This is named `Apple Distribution: <Team Name> (<Team ID>)`, where `<Team Name>` and `<Team ID>` identifies your team.\n- To distribute a product independently, use a Developer ID Application code-signing identity.  This is named `Developer ID Application: <Team ID>`, where `<Team ID>` identifies your team.\n\nFor information on how to set up these code-signing identities, see [https:\/\/developer.apple.com\/help\/account\/].\n\nTo confirm that your code-signing identity is present and correct, run the following command:\n\n```\n% security find-identity -p codesigning -v\n  1) A06E7F3F8237330EE15CB91BE1A511C00B853358 \"Apple Distribution: …\"\n  2) ADC03B244F4C1018384DCAFFC920F26136F6B59B \"Developer ID Application: …\"\n     2 valid identities found\n```\n\nThe `-p codesigning` argument filters for code-signing identities. The `-v` argument filters for valid identities only.  If the code-signing identity that you need isn’t listed, see [https:\/\/developer.apple.com\/help\/account\/].\n\nEach output line includes a SHA-1 hash that uniquely identifies the identity. If you have multiple identities with the same name, sign your code using this hash rather than the identity name.\n\n## Sign each code item\n\nFor all code types, the basic `codesign` command looks like the following:\n\n```\n% codesign -s <CodeSigningIdentity> <PathToExecutable>\n```\n\nReplace `<CodeSigningIdentity>` with the name of the code-signing identity to use, and replace `<PathToExecutable>` with the path to the code to sign.\n\nThe specific identity you use for `<CodeSigningIdentity>` depends on your distribution channel, as discussed in “Confirm your code-signing identity” above.\n\n\n\nIf you’re re-signing code — that is, the code you’re signing is already signed — add the `-f` option.\n\nIf you’re signing a main executable that needs entitlements, add the `--entitlements <entitlementsPath>` option, where `<entitlementsPath>` is the path to the entitlements file that you created for that executable.\n\nIf you’re signing for Developer ID distribution, add the `--timestamp` option to include a secure timestamp.\n\nIf you’re signing a main executable for Developer ID distribution, add the `-o runtime` option to enable the Hardened Runtime.  For more information about the Hardened Runtime, see [doc:\/\/com.apple.documentation\/documentation\/Security\/hardened-runtime].\n\nIf you’re signing nonbundled code, add the `-i <BundleID>` option to set the code-signing identifier, where `<BundleID>` is the bundle ID the code would have if it had a bundle ID.  For example, for an app with a  bundle ID of `com.example.flying-animals` that has a nested command-line tool called `pig-jato`, you can use `com.example.flying-animals.pig-jato` as the bundle ID for the command-line tool.\n\n\n\nIf you’re using a custom DR, add the `-r <ReqPath>` option, where `<ReqPath>` is the path to the requirements file containing the DR for this code item.\n\nRepeat this signing step for every code item in your product, in the order you established in “Determine the signing order” above. If you have a complex product with many code items to sign, create a script to automate this process.\n\nThe folloiwng code shows the complete sequence of commands to sign the `DaemonWithApp` example for Developer ID distribution:\n\n```\n% codesign -s \"Developer ID Application\" -f --timestamp \"to-be-signed\/ConfigApp.app\/Contents\/Frameworks\/Core.framework\"\nto-be-signed\/ConfigApp.app\/Contents\/Frameworks\/Core.framework: replacing existing signature\n% codesign -s \"Developer ID Application\" -f --timestamp -o runtime --entitlements \"Share.entitlements\" \"to-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex\"\nto-be-signed\/ConfigApp.app\/Contents\/PlugIns\/Share.appex: replacing existing signature\n% codesign -s \"Developer ID Application\" -f --timestamp -o runtime --entitlements \"ConfigApp.entitlements\" \"to-be-signed\/ConfigApp.app\"\nto-be-signed\/ConfigApp.app: replacing existing signature\n% codesign -s \"Developer ID Application\" -f --timestamp -o runtime -i \"com.example.apple-samplecode.DaemonWithApp.Daemon\" \"to-be-signed\/Daemon\"\nto-be-signed\/Daemon: replacing existing signature\n```\n\n\n\n## Avoid deep code signing\n\nDon’t pass the `--deep` option to `codesign` when you sign code.  This option is helpful in some specific circumstances (for example, in verifying a code signature), but it causes the following problems when signing a complex product:\n\n- The `--deep` option applies the same code-signing options to every code item that it signs. For example, if you have an app with an embedded command-line tool, where the app and the tool need different entitlements, `codesign --deep` applies the same entitlements to both.\n- `codesign` only signs nested code when you use the `--deep` option if that code is in particular locations in the top-level bundle. If you put code in a place where `codesign` expects to find data, `codesign --deep` doesn’t sign it. For information on the correct organization of nested code within a bundle, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle].\n\n## Code signing\n\n- **Using the latest code signature format**: Update legacy app code signatures so your app runs on current OS releases.\n- **Notarizing macOS software before distribution**: Give users even more confidence in your macOS software by submitting it to Apple for notarization.\n- **Signing a daemon with a restricted entitlement**: Wrap a daemon in an app-like structure to use an entitlement thatʼs authorized by a provisioning profile.\n- **Synchronizing code signing identities with your developer account**: Ensure you and other team members can sign your organization’s code and installer packages in Xcode.\n- **TN3125: Inside Code Signing: Provisioning Profiles**: Learn how provisioning profiles enable third-party code to run on Apple platforms.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Update legacy app code signatures so your app runs on current OS releases.",
          "name" : "Using the latest code signature format",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/using-the-latest-code-signature-format"
        },
        {
          "description" : "Give users even more confidence in your macOS software by submitting it to Apple for notarization.",
          "name" : "Notarizing macOS software before distribution",
          "url" : "https:\/\/developer.apple.com\/documentation\/Security\/notarizing-macos-software-before-distribution"
        },
        {
          "description" : "Wrap a daemon in an app-like structure to use an entitlement thatʼs authorized by a provisioning profile.",
          "name" : "Signing a daemon with a restricted entitlement",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/signing-a-daemon-with-a-restricted-entitlement"
        },
        {
          "description" : "Ensure you and other team members can sign your organization’s code and installer packages in Xcode.",
          "name" : "Synchronizing code signing identities with your developer account",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/sharing-your-teams-signing-certificates"
        },
        {
          "description" : "Learn how provisioning profiles enable third-party code to run on Apple platforms.",
          "name" : "TN3125: Inside Code Signing: Provisioning Profiles",
          "url" : "https:\/\/developer.apple.com\/documentation\/Technotes\/tn3125-inside-code-signing-provisioning-profiles"
        }
      ],
      "title" : "Code signing"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating distribution-signed code for macOS",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/creating-distribution-signed-code-for-the-mac"
}