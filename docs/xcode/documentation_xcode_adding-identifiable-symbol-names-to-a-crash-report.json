{
  "abstract" : "Replace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.",
  "codeExamples" : [
    {
      "code" : "Thread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n1   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n2   libswiftCore.dylib                0x00000001bd15958c _ArrayBuffer._checkInoutAndNativeTypeCheckedBounds+ 66956 (_:wasNativeTypeChecked:) + 200\n3   libswiftCore.dylib                0x00000001bd15c814 Array.subscript.getter + 88\n4   TouchCanvas                       0x00000001022cbfa8 Line.updateRectForExistingPoint(_:) (in TouchCanvas) + 656\n5   TouchCanvas                       0x00000001022c90b0 Line.updateWithTouch(_:) (in TouchCanvas) + 464\n6   TouchCanvas                       0x00000001022e7374 CanvasView.updateEstimatedPropertiesForTouches(_:) (in TouchCanvas) + 708\n7   TouchCanvas                       0x00000001022df754 ViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 304\n8   TouchCanvas                       0x00000001022df7e8 @objc ViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 120\n9   UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n10  UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n11  UIKitCore                         0x00000001b3e01e24 -[_UIEstimatedTouchRecord dispatchUpdateWithPressure:stillEstimated:] + 340",
      "language" : "other"
    },
    {
      "code" : "Thread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n1   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n2   libswiftCore.dylib                0x00000001bd15958c _ArrayBuffer._checkInoutAndNativeTypeCheckedBounds+ 66956 (_:wasNativeTypeChecked:) + 200\n3   libswiftCore.dylib                0x00000001bd15c814 Array.subscript.getter + 88\n4   TouchCanvas                       0x00000001022cbfa8 0x1022c0000 + 49064\n5   TouchCanvas                       0x00000001022c90b0 0x1022c0000 + 37040\n6   TouchCanvas                       0x00000001022e7374 0x1022c0000 + 160628\n7   TouchCanvas                       0x00000001022df754 0x1022c0000 + 128852\n8   TouchCanvas                       0x00000001022df7e8 0x1022c0000 + 129000\n9   UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n10  UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n11  UIKitCore                         0x00000001b3e01e24 -[_UIEstimatedTouchRecord dispatchUpdateWithPressure:stillEstimated:] + 340",
      "language" : "other"
    },
    {
      "code" : "Thread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 0x1bd149000 + 2378352\n1   libswiftCore.dylib                0x00000001bd38da70 0x1bd149000 + 2378352\n2   libswiftCore.dylib                0x00000001bd15958c 0x1bd149000 + 66956\n3   libswiftCore.dylib                0x00000001bd15c814 0x1bd149000 + 79892\n4   TouchCanvas                       0x00000001022cbfa8 0x1022c0000 + 49064\n5   TouchCanvas                       0x00000001022c90b0 0x1022c0000 + 37040\n6   TouchCanvas                       0x00000001022e7374 0x1022c0000 + 160628\n7   TouchCanvas                       0x00000001022df754 0x1022c0000 + 128852\n8   TouchCanvas                       0x00000001022df7e8 0x1022c0000 + 129000\n9   UIKitCore                         0x00000001b3da6230 0x1b3348000 + 10871344\n10  UIKitCore                         0x00000001b3da6230 0x1b3348000 + 10871344\n11  UIKitCore                         0x00000001b3e01e24 0x1b3348000 + 11247140",
      "language" : "other"
    },
    {
      "code" : "% grep --after-context=1000 \"Binary Images:\" <Path to Crash Report> | grep TouchCanvas\n0x1022c0000 - 0x1022effff TouchCanvas arm64  <9cc89c5e55163f4ab40c5821e99f05c6>\n\n% mdfind \"com_apple_xcode_dsym_uuids == 9CC89C5E-5516-3F4A-B40C-5821E99F05C6\"",
      "language" : "other"
    },
    {
      "code" : "% dwarfdump --uuid <PathToDSYMFile>\/Contents\/Resources\/DWARF\/<BinaryName>\n% dwarfdump --uuid <PathToBinary>",
      "language" : "other"
    },
    {
      "code" : "% atos -arch <BinaryArchitecture> -o <PathToDSYMFile>\/Contents\/Resources\/DWARF\/<BinaryName>  -l <LoadAddress> <AddressesToSymbolicate>",
      "language" : "other"
    },
    {
      "code" : "% atos -arch arm64 -o TouchCanvas.app.dSYM\/Contents\/Resources\/DWARF\/TouchCanvas -l 0x1022c0000 0x00000001022df754\nViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 304",
      "language" : "other"
    }
  ],
  "contentHash" : "d014946e42d3cdd02cddda65e098ff483701368dd05e6f59893e5d5db7848d04",
  "crawledAt" : "2025-12-02T06:11:15Z",
  "id" : "D379F223-7A43-49FF-9E26-A768C97DB228",
  "kind" : "article",
  "overview" : "## Overview\n\nWhen an app crashes, the operating system collects diagnostic information about what the app was doing at the time of crash. One of the most important parts of the crash report are the thread backtraces, reported as hexadecimal addresses. You translate these thread backtraces into readable function names and line numbers in source code, a process called *symbolication*, then use that information to understand why your app crashed. In many cases, the Crashes organizer in Xcode [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev709125d2e] for you.\n\n### Determine if a crash report is symbolicated\n\nTo diagnose an app issue using a crash report, you need a fully symbolicated or partially symbolicated crash report. An unsymbolicated crash report is rarely useful.\n\nA fully symbolicated crash report has function names on every frame of the backtrace, instead of hexadecimal memory addresses. Each frame represents a single function call that’s currently running on a specific thread, and provides a view of the functions from your app and the operating system frameworks that were executing at the time your app crashed. Fully symbolicated crash reports give you the most insight about the crash. Once you have a fully symbolicated crash report, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] for details about determing the source of the crash.\n\nAn example of a fully symbolicated crash report:\n\nA partially symbolicated crash report has function names for some of the backtrace frames, and hexadecimal addresses for other frames of the backtrace. A partially symbolicated crash report may contain enough information to understand the crash, depending upon the type of crash and which frames in the backtraces are symbolicated. However, you should still [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-in-Xcode] to make the report fully symbolicated, which will give you a complete understanding of the crash.\n\nAn example of a partially symbolicated crash report:\n\nUnsymbolicated crash reports contain hexadecimal addresses of executable code within the loaded binary images. These reports don’t contain any function names in the backtraces. Because an unsymbolicated crash report is rarely useful, [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-in-Xcode].\n\nAn example of an unsymbolicated symbolicated crash report:\n\n### Symbolicate the crash report in Xcode\n\nXcode is the preferred way to symbolicate crash reports because it uses all available `dSYM` files on your Mac at once. For specialized debugging situations, such as when you have an unsymbolicated stack trace in the Xcode debugger without a full crash report, you can [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-with-the-command-line] to symbolicate each frame.\n\nTo symbolicate in Xcode, click the Device Logs button in the [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev85c64ec79], then drag and drop the crash report file into the list of device logs.\n\nIf the crash report does not symbolicate, or only partly symbolicates, Xcode can’t locate matching symbol information, and you’ll need to acquire symbol information in these ways:\n\nOnce you have a fully symbolicated crash report, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] to determine the source of the crash.\n\n### Acquire device symbol information\n\nTo make symbols from the operating system frameworks identifiable in a crash report, you need to collect the symbols for the system frameworks from a device. For iOS, iPadOS, tvOS, visionOS, and watchOS apps, Xcode automatically copies operating system symbols from each device you connect to your Mac. For macOS and Mac Catalyst apps, symbolicate the crash log by using Xcode on a version of macOS that matches the macOS version named in the crash report.\n\nThe symbols for system frameworks are specific to the operating system release and the CPU architecture of the device. For example, the symbols for an iPhone running iOS 13.1.0 aren’t the same as the symbols for the same iPhone running iOS 13.1.2. If your app runs on operating system versions that support multiple CPU architectures, such as `arm64` and `arm64e`, a device with an `arm64` architecture will only contain the symbols for the `arm64` version of the operating system frameworks; it won’t have symbols for the operating system frameworks on `arm64e` devices.\n\n### Locate a dSYM using Spotlight\n\nTo determine whether the `dSYM` file you need to symbolicate a hexadecimal addresses for one of your binaries is present on your Mac:\n\nAfter getting the build UUID from the binary image section:\n\nIf Spotlight finds a `dSYM` file for the build UUID, `mdfind` prints the path to the `dSYM` file.\n\n\n\nUsing the information in this example, the commands to find the `dSYM` are:\n\nOnce you find the `dSYM` file, [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Match-build-UUIDs] to confirm that its build UUID matches the binary image’s build UUID. Once you verify that build UUIDs match, either [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-in-Xcode] or [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-with-the-command-line].\n\nIf Spotlight doesn’t find a matching `dSYM`, `mdfind` won’t print anything and you’ll need to:\n\n### Match build UUIDs\n\nIf you have a binary or a `dSYM` that you think can be used to symbolicate a crash report, verify that the build UUIDs match, using the `dwarfdump` command. If the build UUIDs don’t match each other or don’t match the build UUID listed in the Binary Images section of the crash report, you can’t use the files to symbolicate that crash report.\n\n### Symbolicate the crash report with the command line\n\nFor specialized debugging situations, such as symbolicating parts of a backtrace provided by the LLDB command line, you can symbolicate a crash report using the `atos` command. The `atos` command converts hexadecimal addresses to the identifiable function name and line number from your source code, if symbol information is available. To symbolicate using `atos`:\n\nAs an example, look at the highlighted sections of this crash report:\n\n\n\nUsing the information in this example, the complete `atos` command and its output are:\n\nOnce you have at least a partially symbolicated crash report by using `atos`, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] for information to determine the source of the crash.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report\ncrawled: 2025-12-02T06:11:15Z\n---\n\n# Adding identifiable symbol names to a crash report\n\n**Article**\n\nReplace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\n\n## Overview\n\nWhen an app crashes, the operating system collects diagnostic information about what the app was doing at the time of crash. One of the most important parts of the crash report are the thread backtraces, reported as hexadecimal addresses. You translate these thread backtraces into readable function names and line numbers in source code, a process called *symbolication*, then use that information to understand why your app crashed. In many cases, the Crashes organizer in Xcode [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev709125d2e] for you.\n\n### Determine if a crash report is symbolicated\n\nTo diagnose an app issue using a crash report, you need a fully symbolicated or partially symbolicated crash report. An unsymbolicated crash report is rarely useful.\n\nA fully symbolicated crash report has function names on every frame of the backtrace, instead of hexadecimal memory addresses. Each frame represents a single function call that’s currently running on a specific thread, and provides a view of the functions from your app and the operating system frameworks that were executing at the time your app crashed. Fully symbolicated crash reports give you the most insight about the crash. Once you have a fully symbolicated crash report, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] for details about determing the source of the crash.\n\nAn example of a fully symbolicated crash report:\n\n```other\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n1   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n2   libswiftCore.dylib                0x00000001bd15958c _ArrayBuffer._checkInoutAndNativeTypeCheckedBounds+ 66956 (_:wasNativeTypeChecked:) + 200\n3   libswiftCore.dylib                0x00000001bd15c814 Array.subscript.getter + 88\n4   TouchCanvas                       0x00000001022cbfa8 Line.updateRectForExistingPoint(_:) (in TouchCanvas) + 656\n5   TouchCanvas                       0x00000001022c90b0 Line.updateWithTouch(_:) (in TouchCanvas) + 464\n6   TouchCanvas                       0x00000001022e7374 CanvasView.updateEstimatedPropertiesForTouches(_:) (in TouchCanvas) + 708\n7   TouchCanvas                       0x00000001022df754 ViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 304\n8   TouchCanvas                       0x00000001022df7e8 @objc ViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 120\n9   UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n10  UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n11  UIKitCore                         0x00000001b3e01e24 -[_UIEstimatedTouchRecord dispatchUpdateWithPressure:stillEstimated:] + 340\n```\n\nA partially symbolicated crash report has function names for some of the backtrace frames, and hexadecimal addresses for other frames of the backtrace. A partially symbolicated crash report may contain enough information to understand the crash, depending upon the type of crash and which frames in the backtraces are symbolicated. However, you should still [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-in-Xcode] to make the report fully symbolicated, which will give you a complete understanding of the crash.\n\nAn example of a partially symbolicated crash report:\n\n```other\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n1   libswiftCore.dylib                0x00000001bd38da70 specialized _fatalErrorMessage+ 2378352 (_:_:file:line:flags:) + 384\n2   libswiftCore.dylib                0x00000001bd15958c _ArrayBuffer._checkInoutAndNativeTypeCheckedBounds+ 66956 (_:wasNativeTypeChecked:) + 200\n3   libswiftCore.dylib                0x00000001bd15c814 Array.subscript.getter + 88\n4   TouchCanvas                       0x00000001022cbfa8 0x1022c0000 + 49064\n5   TouchCanvas                       0x00000001022c90b0 0x1022c0000 + 37040\n6   TouchCanvas                       0x00000001022e7374 0x1022c0000 + 160628\n7   TouchCanvas                       0x00000001022df754 0x1022c0000 + 128852\n8   TouchCanvas                       0x00000001022df7e8 0x1022c0000 + 129000\n9   UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n10  UIKitCore                         0x00000001b3da6230 forwardMethod1 + 136\n11  UIKitCore                         0x00000001b3e01e24 -[_UIEstimatedTouchRecord dispatchUpdateWithPressure:stillEstimated:] + 340\n```\n\nUnsymbolicated crash reports contain hexadecimal addresses of executable code within the loaded binary images. These reports don’t contain any function names in the backtraces. Because an unsymbolicated crash report is rarely useful, [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-in-Xcode].\n\nAn example of an unsymbolicated symbolicated crash report:\n\n```other\nThread 0 name:  Dispatch queue: com.apple.main-thread\nThread 0 Crashed:\n0   libswiftCore.dylib                0x00000001bd38da70 0x1bd149000 + 2378352\n1   libswiftCore.dylib                0x00000001bd38da70 0x1bd149000 + 2378352\n2   libswiftCore.dylib                0x00000001bd15958c 0x1bd149000 + 66956\n3   libswiftCore.dylib                0x00000001bd15c814 0x1bd149000 + 79892\n4   TouchCanvas                       0x00000001022cbfa8 0x1022c0000 + 49064\n5   TouchCanvas                       0x00000001022c90b0 0x1022c0000 + 37040\n6   TouchCanvas                       0x00000001022e7374 0x1022c0000 + 160628\n7   TouchCanvas                       0x00000001022df754 0x1022c0000 + 128852\n8   TouchCanvas                       0x00000001022df7e8 0x1022c0000 + 129000\n9   UIKitCore                         0x00000001b3da6230 0x1b3348000 + 10871344\n10  UIKitCore                         0x00000001b3da6230 0x1b3348000 + 10871344\n11  UIKitCore                         0x00000001b3e01e24 0x1b3348000 + 11247140\n```\n\n### Symbolicate the crash report in Xcode\n\nXcode is the preferred way to symbolicate crash reports because it uses all available `dSYM` files on your Mac at once. For specialized debugging situations, such as when you have an unsymbolicated stack trace in the Xcode debugger without a full crash report, you can [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-with-the-command-line] to symbolicate each frame.\n\nTo symbolicate in Xcode, click the Device Logs button in the [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev85c64ec79], then drag and drop the crash report file into the list of device logs.\n\n\n\nIf the crash report does not symbolicate, or only partly symbolicates, Xcode can’t locate matching symbol information, and you’ll need to acquire symbol information in these ways:\n\n- If the operating system’s frameworks aren’t symbolicated, you need device symbol information matching the operating system version recorded in the crash report. To address this, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Acquire-device-symbol-information].\n- If the frames for your app, app extension, or frameworks aren’t symbolicated, you need to locate the existing `dSYM` files using Spotlight. To address this, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Locate-a-dSYM-using-Spotlight]. If your app uses frameworks built by a third-party, you may need to ask the framework vendor for the `dSYM` file.\n\nOnce you have a fully symbolicated crash report, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] to determine the source of the crash.\n\n### Acquire device symbol information\n\nTo make symbols from the operating system frameworks identifiable in a crash report, you need to collect the symbols for the system frameworks from a device. For iOS, iPadOS, tvOS, visionOS, and watchOS apps, Xcode automatically copies operating system symbols from each device you connect to your Mac. For macOS and Mac Catalyst apps, symbolicate the crash log by using Xcode on a version of macOS that matches the macOS version named in the crash report.\n\nThe symbols for system frameworks are specific to the operating system release and the CPU architecture of the device. For example, the symbols for an iPhone running iOS 13.1.0 aren’t the same as the symbols for the same iPhone running iOS 13.1.2. If your app runs on operating system versions that support multiple CPU architectures, such as `arm64` and `arm64e`, a device with an `arm64` architecture will only contain the symbols for the `arm64` version of the operating system frameworks; it won’t have symbols for the operating system frameworks on `arm64e` devices.\n\n### Locate a dSYM using Spotlight\n\nTo determine whether the `dSYM` file you need to symbolicate a hexadecimal addresses for one of your binaries is present on your Mac:\n\n1. Find a frame in the backtrace that isn’t symbolicated. Note the name of the binary image in the second column.\n2. Look for a binary image with that name in the list of binary images at the bottom of the crash report. This list contains the build UUID of each binary image that was loaded into the process at the time of the crash. Use the `grep` command line tool to find the entry in the list of binary images:\n\n```other\n% grep --after-context=1000 \"Binary Images:\" <Path to Crash Report> | grep <Binary Name>\n```\n\nAfter getting the build UUID from the binary image section:\n\n1. Convert the build UUID of the binary image to a 32-character string, that’s separated into groups of 8-4-4-4-12 (`XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`). All letters must be uppercase.\n2. Search for the build UUID using the `mdfind` command line tool query (including quotation marks):\n\n```other\n% mdfind \"com_apple_xcode_dsym_uuids == <UUID>\"\n```\n\nIf Spotlight finds a `dSYM` file for the build UUID, `mdfind` prints the path to the `dSYM` file.\n\n\n\nUsing the information in this example, the commands to find the `dSYM` are:\n\n```other\n% grep --after-context=1000 \"Binary Images:\" <Path to Crash Report> | grep TouchCanvas\n0x1022c0000 - 0x1022effff TouchCanvas arm64  <9cc89c5e55163f4ab40c5821e99f05c6>\n\n% mdfind \"com_apple_xcode_dsym_uuids == 9CC89C5E-5516-3F4A-B40C-5821E99F05C6\"\n```\n\nOnce you find the `dSYM` file, [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Match-build-UUIDs] to confirm that its build UUID matches the binary image’s build UUID. Once you verify that build UUIDs match, either [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-in-Xcode] or [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-with-the-command-line].\n\nIf Spotlight doesn’t find a matching `dSYM`, `mdfind` won’t print anything and you’ll need to:\n\n- Verify that you still have the Xcode archive for the version of your app that crashed. If you no longer have this archive, you can’t symbolicate your app’s stack frames for that version of your app. To avoid this in the future, release a new version of your app, and retain the Xcode archive for that version. You’ll then be able to symbolicate crash reports for the new version of your app.\n- Ensure the Xcode archive is located somewhere Spotlight can find it, such as your macOS home directory.\n- Verify that your build produces debugging information. See [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/building-your-app-to-include-debugging-information].\n\n### Match build UUIDs\n\nIf you have a binary or a `dSYM` that you think can be used to symbolicate a crash report, verify that the build UUIDs match, using the `dwarfdump` command. If the build UUIDs don’t match each other or don’t match the build UUID listed in the Binary Images section of the crash report, you can’t use the files to symbolicate that crash report.\n\n```other\n% dwarfdump --uuid <PathToDSYMFile>\/Contents\/Resources\/DWARF\/<BinaryName>\n% dwarfdump --uuid <PathToBinary>\n```\n\n### Symbolicate the crash report with the command line\n\nFor specialized debugging situations, such as symbolicating parts of a backtrace provided by the LLDB command line, you can symbolicate a crash report using the `atos` command. The `atos` command converts hexadecimal addresses to the identifiable function name and line number from your source code, if symbol information is available. To symbolicate using `atos`:\n\n1. Find a frame in the backtrace that you want to symbolicate. Note the name of the binary image in the second column, and the address in the third column.\n2. Look for a binary image with that name in the list of binary images at the bottom of the crash report. Note the architecture and load address of the binary image.\n3. Locate the `dSYM` file for the binary. If you don’t know where the `dSYM` file is located, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Locate-a-dSYM-using-Spotlight] to find the `dSYM` file that matches the build UUID of the binary image.\n4. Symbolicate the addresses in the backtrace using `atos` with the formula, substituting the information you gathered in previous steps:\n\n```other\n% atos -arch <BinaryArchitecture> -o <PathToDSYMFile>\/Contents\/Resources\/DWARF\/<BinaryName>  -l <LoadAddress> <AddressesToSymbolicate>\n```\n\n\n\nAs an example, look at the highlighted sections of this crash report:\n\n\n\nUsing the information in this example, the complete `atos` command and its output are:\n\n```other\n% atos -arch arm64 -o TouchCanvas.app.dSYM\/Contents\/Resources\/DWARF\/TouchCanvas -l 0x1022c0000 0x00000001022df754\nViewController.touchesEstimatedPropertiesUpdated(_:) (in TouchCanvas) + 304\n```\n\nOnce you have at least a partially symbolicated crash report by using `atos`, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/analyzing-a-crash-report] for information to determine the source of the crash.\n\n## Crash reports\n\n- **Identifying the cause of common crashes**: Find patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\n- **Analyzing a crash report**: Identify clues in a crash report that help you diagnose problems.\n- **Examining the fields in a crash report**: Understand the structure of a crash report and the information each field contains.\n- **Interpreting the JSON format of a crash report**: Understand the structure and properties of the objects the system includes in the JSON of a crash report.\n- **Understanding the exception types in a crash report**: Learn what the exception type tells you about why your app crashed.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Find patterns in crash reports that identify common problems, and investigate the issue based on the pattern.",
          "name" : "Identifying the cause of common crashes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/identifying-the-cause-of-common-crashes"
        },
        {
          "description" : "Identify clues in a crash report that help you diagnose problems.",
          "name" : "Analyzing a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/analyzing-a-crash-report"
        },
        {
          "description" : "Understand the structure of a crash report and the information each field contains.",
          "name" : "Examining the fields in a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/examining-the-fields-in-a-crash-report"
        },
        {
          "description" : "Understand the structure and properties of the objects the system includes in the JSON of a crash report.",
          "name" : "Interpreting the JSON format of a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/interpreting-the-JSON-format-of-a-crash-report"
        },
        {
          "description" : "Learn what the exception type tells you about why your app crashed.",
          "name" : "Understanding the exception types in a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/understanding-the-exception-types-in-a-crash-report"
        }
      ],
      "title" : "Crash reports"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding identifiable symbol names to a crash report",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report"
}