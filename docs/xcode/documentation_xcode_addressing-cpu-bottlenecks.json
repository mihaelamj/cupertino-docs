{
  "abstract" : "Locate and fix pipeline stalls, cache misses, and other performance issues.",
  "codeExamples" : [

  ],
  "contentHash" : "7c4ef18edb89e6a47969f10762b29369fa479f9999d109af513ff29edaf382ae",
  "crawledAt" : "2025-12-04T02:40:52Z",
  "id" : "D837C578-F6EB-47A8-B362-4BB24067A785",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nTo keep a device’s CPU running at its highest effectiveness while it’s processing your app, tune your app to best use the CPU instruction set and ensure that the CPU microarchitecture delivers and processes instructions efficiently. Modern processors have multiple facilities to improve the flow of instructions they process, including:\n\nIn situations where your app’s design, or the hints you provide to the compiler, don’t let the CPU take advantage of these features, the CPU can encounter a *bottleneck* where it can’t run at its maximum efficiency. Examples of CPU bottlenecks include situations that cause the CPU to wait because the next instruction it needs to process isn’t available yet, or where processing an instruction *stalls* because the CPU is waiting for a relatively slow access to memory. CPU bottlenecks reduce the rate at which the processor can finish your app’s work, increasing the time someone waits for your app to complete a task. Bottlenecks that occur on your app’s main thread contribute to freezes and hitches in your app’s UI.\n\nAdditionally, using the CPU inefficiently increases the power used by the CPU when it runs your app. For information on measuring your app’s power use, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/measuring-your-app-s-power-use-with-power-profiler].\n\nUse coding strategies that avoid CPU bottlenecks. Identify areas in your app that need performance improvement, set performance targets, and write performance tests to validate that your changes improve performance. Use Instruments to detect situations where the CPU encounters a bottleneck while it runs your app’s code. Take steps to remove the bottlenecks, and improve your app’s performance.\n\n### Design your app to avoid CPU bottlenecks\n\nThe following design principles help the system to optimize CPU performance when someone uses your app.\n\nUse system frameworks. Where the system provides a framework to perform a task, that framework’s implementation is optimized to use device resources efficiently.\n\nPrefer dynamic task allocation to static thread pools. The system assigns your app’s threads to run on different cores in the processor, which can complete work at different rates depending on the type of core and the other work running on the device. Work assigned to threads in a static pool can finish at different times, leaving some threads without work to do while other threads catch up.\n\nConsider using [doc:\/\/com.apple.documentation\/documentation\/BackgroundTasks] to create tasks that the system schedules dynamically, based on resource availability.\n\nIndicate quality-of-service for background tasks. The system uses quality-of-service information to dynamically schedule tasks and make efficient use of available processing resources.\n\nIf you use Background Tasks, pick the correct task type for the work you assign to the task. For more information, see [doc:\/\/com.apple.documentation\/documentation\/BackgroundTasks\/choosing-background-strategies-for-your-app]. If you use Grand Central Dispatch, dispatch your work to a queue with the appropriate [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/DispatchQoS].\n\nFor more guidance on optimizing your code for Apple silicon, see [doc:\/\/com.apple.documentation\/documentation\/Apple-Silicon\/tuning-your-code-s-performance-for-apple-silicon].\n\n### Establish performance goals\n\nUse information from the Metrics Organizer, and feedback from people who test and use your app, to identify performance issues and define targets for improvement. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/improving-your-app-s-performance].\n\n### Write performance tests\n\nWhen you identify features that need performance improvements, create performance tests to automatically exercise those features and measure their performance. Set a performance baseline and run the tests when you make code changes, to compare your app’s performance with the baseline and detect regressions.\n\nUse [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTCPUMetric] to measure CPU activity in your tests, and [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTClockMetric] to measure time elapsed during your tests. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/writing-and-running-performance-tests].\n\n### Detect CPU bottlenecks\n\nWhen your performance tests reveal that your app doesn’t meet your performance goals, use the CPU Counters instrument to identify situations where the system encounters CPU bottlenecks when it runs your app.\n\nRecord your app’s CPU access patterns by following these steps:\n\nIf you don’t have a performance test for the features you want to analyze, follow these steps instead:\n\n### Discover code that causes CPU bottlenecks\n\nThe CPU Counters instrument adds mode-specific lanes to the CPU Counters, process, and thread tracks you use to analyze the processor’s workload. In the initial CPU bottlenecks mode, the lane divides the maximum sustainable CPU bandwidth into four categories:\n\n\n\nWhile the presence of CPU bottlenecks indicates opportunities to improve your app’s performance, the absence of bottlenecks doesn’t necessarily mean your code is as efficient as possible. For example, there might be a more efficient algorithm available to implement your app’s features, or your app might encounter other overhead that doesn’t result in CPU bottlenecks.\n\nUse the Time Profiler track, and the tracks for your app’s threads, to correlate the presence of CPU bottlenecks with the code that runs in your app. Additionally, record another trace in Instruments using a sampling mode, which examines specific instructions that can frequently result in CPU bottlenecks.\n\nClick the CPU Counters track to see the Summary: Metrics view, which shows the fraction of time the CPU spends doing useful work or encountering bottlenecks. Select a range in the timeline to focus the Summary: Metrics view on that range.\n\n### Identify causes of CPU bottlenecks\n\nWhen you locate the code in your app that causes CPU bottlenecks and the category of bottleneck the processor encounters, gather more detailed information to determine the specific situations that lead to CPU bottlenecks, and plan to address those bottlenecks in code.\n\nFollow these steps in Instruments:\n\nThe CPU Counters track and Summary: Metrics view show the fraction of particular categories of CPU bottlenecks that the processor encounters. Switch to the Remarks view to see information about bottleneck events that Instruments detected. Click a metric or remark in the detail view to read more information about the cause of that type of CPU bottleneck, and suggested code strategies to mitigate the bottleneck.\n\n\n\nRefer to the [doc:\/\/com.apple.documentation\/documentation\/Apple-Silicon\/cpu-optimization-guide] for more information on Apple silicon and guidance on optimizing your code.\n\nAfter you make a code change, re-run your performance tests, and use the CPU Counters instrument again to validate that your change improves your app’s processor usage.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/addressing-cpu-bottlenecks\ncrawled: 2025-12-04T02:40:52Z\n---\n\n# Addressing CPU bottlenecks\n\n**Article**\n\nLocate and fix pipeline stalls, cache misses, and other performance issues.\n\n## Overview\n\nTo keep a device’s CPU running at its highest effectiveness while it’s processing your app, tune your app to best use the CPU instruction set and ensure that the CPU microarchitecture delivers and processes instructions efficiently. Modern processors have multiple facilities to improve the flow of instructions they process, including:\n\n\n\nIn situations where your app’s design, or the hints you provide to the compiler, don’t let the CPU take advantage of these features, the CPU can encounter a *bottleneck* where it can’t run at its maximum efficiency. Examples of CPU bottlenecks include situations that cause the CPU to wait because the next instruction it needs to process isn’t available yet, or where processing an instruction *stalls* because the CPU is waiting for a relatively slow access to memory. CPU bottlenecks reduce the rate at which the processor can finish your app’s work, increasing the time someone waits for your app to complete a task. Bottlenecks that occur on your app’s main thread contribute to freezes and hitches in your app’s UI.\n\nAdditionally, using the CPU inefficiently increases the power used by the CPU when it runs your app. For information on measuring your app’s power use, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/measuring-your-app-s-power-use-with-power-profiler].\n\nUse coding strategies that avoid CPU bottlenecks. Identify areas in your app that need performance improvement, set performance targets, and write performance tests to validate that your changes improve performance. Use Instruments to detect situations where the CPU encounters a bottleneck while it runs your app’s code. Take steps to remove the bottlenecks, and improve your app’s performance.\n\n\n\n### Design your app to avoid CPU bottlenecks\n\nThe following design principles help the system to optimize CPU performance when someone uses your app.\n\nUse system frameworks. Where the system provides a framework to perform a task, that framework’s implementation is optimized to use device resources efficiently.\n\nPrefer dynamic task allocation to static thread pools. The system assigns your app’s threads to run on different cores in the processor, which can complete work at different rates depending on the type of core and the other work running on the device. Work assigned to threads in a static pool can finish at different times, leaving some threads without work to do while other threads catch up.\n\nConsider using [doc:\/\/com.apple.documentation\/documentation\/BackgroundTasks] to create tasks that the system schedules dynamically, based on resource availability.\n\nIndicate quality-of-service for background tasks. The system uses quality-of-service information to dynamically schedule tasks and make efficient use of available processing resources.\n\nIf you use Background Tasks, pick the correct task type for the work you assign to the task. For more information, see [doc:\/\/com.apple.documentation\/documentation\/BackgroundTasks\/choosing-background-strategies-for-your-app]. If you use Grand Central Dispatch, dispatch your work to a queue with the appropriate [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/DispatchQoS].\n\nFor more guidance on optimizing your code for Apple silicon, see [doc:\/\/com.apple.documentation\/documentation\/Apple-Silicon\/tuning-your-code-s-performance-for-apple-silicon].\n\n### Establish performance goals\n\nUse information from the Metrics Organizer, and feedback from people who test and use your app, to identify performance issues and define targets for improvement. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/improving-your-app-s-performance].\n\n### Write performance tests\n\nWhen you identify features that need performance improvements, create performance tests to automatically exercise those features and measure their performance. Set a performance baseline and run the tests when you make code changes, to compare your app’s performance with the baseline and detect regressions.\n\nUse [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTCPUMetric] to measure CPU activity in your tests, and [doc:\/\/com.apple.documentation\/documentation\/XCTest\/XCTClockMetric] to measure time elapsed during your tests. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/writing-and-running-performance-tests].\n\n### Detect CPU bottlenecks\n\nWhen your performance tests reveal that your app doesn’t meet your performance goals, use the CPU Counters instrument to identify situations where the system encounters CPU bottlenecks when it runs your app.\n\nRecord your app’s CPU access patterns by following these steps:\n\n1. In Xcode, Control-click the test indicator next to the test that demonstrates the performance problem, and choose Profile *the test’s name*.\n2. In Instruments the Choose a Template… window opens, choose the CPU Counters template.\n3. Set the CPU Counters instrument mode to CPU Bottlenecks.\n4. Click record to start gathering data.\n\nIf you don’t have a performance test for the features you want to analyze, follow these steps instead:\n\n1. In Xcode, choose Product > Profile.\n2. In Instruments the Choose a Template… window opens, choose the CPU Counters template.\n3. Choose the target device and app to record.\n4. Set the CPU Counters instrument mode to CPU Bottlenecks.\n5. Click record to start gathering data.\n6. Interact with the features in your app that you want to analyze.\n7. In Instruments, click the Stop button to stop gathering data.\n\n### Discover code that causes CPU bottlenecks\n\nThe CPU Counters instrument adds mode-specific lanes to the CPU Counters, process, and thread tracks you use to analyze the processor’s workload. In the initial CPU bottlenecks mode, the lane divides the maximum sustainable CPU bandwidth into four categories:\n\n\n\n\n\nWhile the presence of CPU bottlenecks indicates opportunities to improve your app’s performance, the absence of bottlenecks doesn’t necessarily mean your code is as efficient as possible. For example, there might be a more efficient algorithm available to implement your app’s features, or your app might encounter other overhead that doesn’t result in CPU bottlenecks.\n\nUse the Time Profiler track, and the tracks for your app’s threads, to correlate the presence of CPU bottlenecks with the code that runs in your app. Additionally, record another trace in Instruments using a sampling mode, which examines specific instructions that can frequently result in CPU bottlenecks.\n\nClick the CPU Counters track to see the Summary: Metrics view, which shows the fraction of time the CPU spends doing useful work or encountering bottlenecks. Select a range in the timeline to focus the Summary: Metrics view on that range.\n\n### Identify causes of CPU bottlenecks\n\nWhen you locate the code in your app that causes CPU bottlenecks and the category of bottleneck the processor encounters, gather more detailed information to determine the specific situations that lead to CPU bottlenecks, and plan to address those bottlenecks in code.\n\n\n\nFollow these steps in Instruments:\n\n1. Expand the thread timeline for your app’s threads to reveal lanes that indicate when your app encountered bottlenecks.\n2. Click on a bottleneck in the thread timeline to scroll the detail view to that bottleneck.\n3. Control-click the bottleneck in the detail view and choose “Suggested Next” to start a new recording in Instruments that changes the CPU Counters instrument mode to gather more information about that bottleneck.\n4. If you aren’t profiling a performance test, interact with the feature in your app that caused the bottleneck in the first recording, then click the Stop button to stop gathering data.\n\nThe CPU Counters track and Summary: Metrics view show the fraction of particular categories of CPU bottlenecks that the processor encounters. Switch to the Remarks view to see information about bottleneck events that Instruments detected. Click a metric or remark in the detail view to read more information about the cause of that type of CPU bottleneck, and suggested code strategies to mitigate the bottleneck.\n\n\n\nRefer to the [doc:\/\/com.apple.documentation\/documentation\/Apple-Silicon\/cpu-optimization-guide] for more information on Apple silicon and guidance on optimizing your code.\n\nAfter you make a code change, re-run your performance tests, and use the CPU Counters instrument again to validate that your change improves your app’s processor usage.\n\n## Processor usage\n\n- **Analyzing CPU usage with the Processor Trace instrument**: Identify code where your app uses the CPU inefficiently.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Identify code where your app uses the CPU inefficiently.",
          "name" : "Analyzing CPU usage with the Processor Trace instrument",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/analyzing-cpu-usage-with-processor-trace"
        }
      ],
      "title" : "Processor usage"
    }
  ],
  "source" : "appleJSON",
  "title" : "Addressing CPU bottlenecks",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/addressing-cpu-bottlenecks"
}