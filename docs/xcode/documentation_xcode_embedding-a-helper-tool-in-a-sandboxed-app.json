{
  "abstract" : "Add a command-line tool to a sandboxed app’s Xcode project so the resulting app can run it as a helper tool.",
  "codeExamples" : [
    {
      "code" : "% codesign -d -vvv --entitlements :- AppWithTool.app \n…\nIdentifier=com.example.apple-samplecode.AppWithTool\nFormat=app bundle with Mach-O universal (x86_64 arm64)\nCodeDirectory v=20500 size=822 flags=0x10000(runtime) hashes=14+7 location=embedded\n…\nAuthority=Apple Distribution: …\n…\nTeamIdentifier=SKMME9E2Y8\n…\n<dict>\n    <key>com.apple.security.app-sandbox<\/key>\n    <true\/>\n    <key>com.apple.security.files.user-selected.read-only<\/key>\n    <true\/>\n<\/dict>\n<\/plist>\n% codesign -d -vvv --entitlements :- AppWithTool.app\/Contents\/MacOS\/ToolX \n…\nIdentifier=com.example.apple-samplecode.AppWithTool.ToolX\nFormat=Mach-O universal (x86_64 arm64)\nCodeDirectory v=20500 size=796 flags=0x10000(runtime) hashes=13+7 location=embedded\n…\nAuthority=Apple Distribution: …\n…\nTeamIdentifier=SKMME9E2Y8\n…\n<dict>\n    <key>com.apple.security.app-sandbox<\/key>\n    <true\/>\n    <key>com.apple.security.inherit<\/key>\n    <true\/>\n<\/dict>\n<\/plist>"
    },
    {
      "code" : "% mkdir ToolC\n% cd ToolC"
    },
    {
      "code" : "% cat main.c \n#include <stdio.h>\n\nint main(int argc, char ** argv) {\n    printf(\"Hello Cruel World!\\n\");\n    return 0;\n}"
    },
    {
      "code" : "% clang -o ToolC-x86_64 -mmacosx-version-min=10.15 -arch x86_64 main.c\n% clang -o ToolC-arm64 -mmacosx-version-min=11.0 -arch arm64 main.c\n% lipo ToolC-x86_64 ToolC-arm64 -create -output ToolC "
    },
    {
      "code" : "% \/usr\/libexec\/PlistBuddy -c \"Add :com.apple.security.app-sandbox bool true\" \"ToolC.entitlements\"\nFile Doesn't Exist, Will Create: ToolC.entitlements\n% \/usr\/libexec\/PlistBuddy -c \"Add :com.apple.security.inherit bool true\" ToolC.entitlements\n% cat ToolC.entitlements \n…\n<dict>\n    <key>com.apple.security.app-sandbox<\/key>\n    <true\/>\n    <key>com.apple.security.inherit<\/key>\n    <true\/>\n<\/dict>\n<\/plist>"
    },
    {
      "code" : "% codesign -s - -i com.example.apple-samplecode.AppWithTool.ToolC -o runtime --entitlements ToolC.entitlements -f ToolC"
    }
  ],
  "contentHash" : "7f8aadf65651527cb98567f908bbefe655e1e4f9534f6e0b0c5fd74478ecc183",
  "crawledAt" : "2025-12-04T02:39:55Z",
  "id" : "5A49B45A-7179-4D9F-8F94-AAE406A1333B",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nWhen building an app for the Mac, you can embed a command-line tool in the app to act as a helper tool. Instances where this may be helpful include, for example:\n\nEmbedding a command-line tool in a sandbox app does present some unique challenges. The best approach depends on whether you’re building the tool with Xcode or using a tool built by an external build system.\n\n### Create the app project\n\nTo get started, create a new project from the macOS > App template. Name it `AppWithTool`, resulting in a bundle ID like `com.example.apple-samplecode.AppWithTool`.\n\nIn the project editor, set the deployment target to 10.15. Later on, you’ll configure the tool target to inherit this deployment target, which helps to keep everything in sync.\n\nIn the General tab of the app target editor, set the App Category to Utilities. This avoids a warning when you build for distribution.\n\nIn the Signing & Capabilities tab of the app target editor, make sure “Automatically manage signing” is checked, and then select the appropriate team. The Signing Certificate popup should switch to Development, which is exactly what you want for day-to-day development.\n\nAdd the Hardened Runtime capability, which isn’t necessary for App Store apps but is best practice for new code.\n\nChoose Product > Archive, which builds the app into an Xcode archive and reveals that archive in the Xcode organizer. The goal here is to check that everything is working so far.\n\nIn the organizer, delete the new archive, just to reset to the original state.\n\n### Create the helper tool target\n\nWith the app target in the project building correctly, it’s time to create a helper tool target so you can embed its product into the app. To start, create a new target from the macOS > Command Line Tool template. Name this `ToolX`, where the *X* stands for *built with Xcode*.\n\nIn the General tab of the tool target editor, clear the Deployment Target field. This configures the tool target to inherit its deployment target (macOS 10.15) from the project.\n\nIn the Signing & Capabilities tab of the tool target editor, ensure that “Automatically manage signing” is checked, and then select the appropriate team. Again, the Signing Certificate popup switches to Development.\n\nFill in the Bundle Identifier field. The app’s bundle ID is `com.example.apple-samplecode.AppWithTool`, so set this to `com.example.apple-samplecode.AppWithTool.ToolX`. This value becomes the helper tool’s code signing identifier. See the discussion of the Other Code Signing Flags build setting, below.\n\nAdd the App Sandbox and Hardened Runtime capabilities. Again, the hardened runtime isn’t required for App Store apps, but it’s best practice for new code.\n\nIn the Build Settings tab, enable the Skip Install (`SKIP_INSTALL`) build setting. Without this setting, Xcode puts a standalone copy of the tool in your Xcode archive (in addition to the one embedded within your app). That copy of the tool causes problems when you try to distribute that archive.\n\nAlso, disable the Code Signing Inject Base Entitlements (`CODE_SIGN_INJECT_BASE_ENTITLEMENTS`) build setting. If you leave this setting enabled, then Xcode includes the `com.apple.security.get-task-allow` entitlement in development builds of your tool. This is problematic because that entitlement is incompatible with the `com.apple.security.inherit` entitlement.\n\nSet the Other Code Signing Flags (`OTHER_CODE_SIGN_FLAGS`) build setting to `$(inherited) -i $(PRODUCT_BUNDLE_IDENTIFIER)`, which ensures that the tool’s code signing identifier matches its bundle ID.\n\nSelect `ToolX.entitlements` in the Project navigator and add `com.apple.security.inherit` to it, with a Boolean value of `true`. For more information about this entitlement, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Miscellaneous\/Reference\/EntitlementKeyReference\/Chapters\/EnablingAppSandbox.html#\/\/apple_ref\/doc\/uid\/TP40011195-CH4-SW15].\n\nSelect the ToolX scheme and chose Product > Build, just to make sure that the tool builds correctly.\n\nNow switch back to the app (`AppWithTool`) scheme.\n\n### Embed the helper tool\n\nIn the Build Phases tab of the app target editor, add the ToolX target to the Dependencies build phase. This ensures that Xcode builds the tool target before building the app target.\n\nAdd a new Copy Files build phase. Double-click the build phase name and change it to `Embed Helper Tools` (the exact name doesn’t matter, but it’s best to pick a descriptive one). Set the Destination popup to Executables.  This places the helper tool in your app’s `Contents\/MacOS` directory, one of the locations recommended by [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle].\n\nAdd the `ToolX` executable to that build phase, making sure Code Sign On Copy is checked.\n\nFor more information about build phases, see [https:\/\/help.apple.com\/xcode\/mac\/11.4\/index.html#\/dev50bab713d]\n\n### Build and validate\n\nWith the project set up, it’s time to test that everything builds correctly. To start, choose Product > Archive, which builds the tool target and then the app target, embedding the result of the former within the latter.\n\nIn the Xcode organizer, select the newly created archive and click Distribute App.\n\nSelect App Store Connect and click Next, then select Export and click Next.\n\nGo through the rest of the export workflow. The end result is a directory with a name like `AppWithTool 2021-05-17 14-07-21`. Within that directory is an installer package (with the `.pkg` extension). Unpack that package.\n\nRun the following commands to confirm that Xcode constructed everything correctly:\n\nCheck the following:\n\n### Embed an externally built tool\n\nWith the app and Xcode-built helper tool working correctly, it’s time to repeat the process for a tool built using an external build system. The following example creates an example helper tool from the command line and then embeds the tool in the AppWithTool app. In a real project, you’d use the command-line tool’s external build system (for example, `make`) to build the tool that you want to embed.\n\n### Build the tool\n\nCreate a new directory and change into it:\n\nHere *C* stands for *built with Clang*.\n\nCreate a source file in the directory that looks like this:\n\nBuild that source file with `clang` twice, once for each architecture, and then `lipo` them together:\n\nThe `-mmacosx-version-min` option sets the deployment target to match the AppWithTool app. For the Intel architecture, this is macOS 10.15, as discussed above. For the Apple silicon architecture, this is macOS 11.0, the first macOS release to support Apple silicon.\n\nCreate an entitlements file for the tool:\n\nSign the tool as shown below:\n\nThis breaks down as follows:\n\nAdd the `ToolC` executable to your Xcode project. When you do this:\n\nIn the Build Phases tab of the app target editor, add `ToolC` to the Embed Helper Tools build phase, making sure that Code Sign On Copy is checked.\n\n### Build and validate again\n\nTo validate your work, follow the process described in [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/embedding-a-helper-tool-in-a-sandboxed-app#Build-and-validate], substituting `ToolC` for `ToolX` everywhere.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/embedding-a-helper-tool-in-a-sandboxed-app\ncrawled: 2025-12-04T02:39:55Z\n---\n\n# Embedding a command-line tool in a sandboxed app\n\n**Article**\n\nAdd a command-line tool to a sandboxed app’s Xcode project so the resulting app can run it as a helper tool.\n\n## Overview\n\nWhen building an app for the Mac, you can embed a command-line tool in the app to act as a helper tool. Instances where this may be helpful include, for example:\n\n- You want to run some code in a separate process. In many cases, an XPC service is a better choice for this, but sometimes it’s easier to embed a command-line tool.\n- You want to build a command-line tool with an external build system (for example, `make`) and then run it from your app.\n\nEmbedding a command-line tool in a sandbox app does present some unique challenges. The best approach depends on whether you’re building the tool with Xcode or using a tool built by an external build system.\n\n\n\n### Create the app project\n\nTo get started, create a new project from the macOS > App template. Name it `AppWithTool`, resulting in a bundle ID like `com.example.apple-samplecode.AppWithTool`.\n\nIn the project editor, set the deployment target to 10.15. Later on, you’ll configure the tool target to inherit this deployment target, which helps to keep everything in sync.\n\nIn the General tab of the app target editor, set the App Category to Utilities. This avoids a warning when you build for distribution.\n\nIn the Signing & Capabilities tab of the app target editor, make sure “Automatically manage signing” is checked, and then select the appropriate team. The Signing Certificate popup should switch to Development, which is exactly what you want for day-to-day development.\n\nAdd the Hardened Runtime capability, which isn’t necessary for App Store apps but is best practice for new code.\n\nChoose Product > Archive, which builds the app into an Xcode archive and reveals that archive in the Xcode organizer. The goal here is to check that everything is working so far.\n\nIn the organizer, delete the new archive, just to reset to the original state.\n\n### Create the helper tool target\n\nWith the app target in the project building correctly, it’s time to create a helper tool target so you can embed its product into the app. To start, create a new target from the macOS > Command Line Tool template. Name this `ToolX`, where the *X* stands for *built with Xcode*.\n\nIn the General tab of the tool target editor, clear the Deployment Target field. This configures the tool target to inherit its deployment target (macOS 10.15) from the project.\n\nIn the Signing & Capabilities tab of the tool target editor, ensure that “Automatically manage signing” is checked, and then select the appropriate team. Again, the Signing Certificate popup switches to Development.\n\nFill in the Bundle Identifier field. The app’s bundle ID is `com.example.apple-samplecode.AppWithTool`, so set this to `com.example.apple-samplecode.AppWithTool.ToolX`. This value becomes the helper tool’s code signing identifier. See the discussion of the Other Code Signing Flags build setting, below.\n\nAdd the App Sandbox and Hardened Runtime capabilities. Again, the hardened runtime isn’t required for App Store apps, but it’s best practice for new code.\n\nIn the Build Settings tab, enable the Skip Install (`SKIP_INSTALL`) build setting. Without this setting, Xcode puts a standalone copy of the tool in your Xcode archive (in addition to the one embedded within your app). That copy of the tool causes problems when you try to distribute that archive.\n\nAlso, disable the Code Signing Inject Base Entitlements (`CODE_SIGN_INJECT_BASE_ENTITLEMENTS`) build setting. If you leave this setting enabled, then Xcode includes the `com.apple.security.get-task-allow` entitlement in development builds of your tool. This is problematic because that entitlement is incompatible with the `com.apple.security.inherit` entitlement.\n\n\n\nSet the Other Code Signing Flags (`OTHER_CODE_SIGN_FLAGS`) build setting to `$(inherited) -i $(PRODUCT_BUNDLE_IDENTIFIER)`, which ensures that the tool’s code signing identifier matches its bundle ID.\n\nSelect `ToolX.entitlements` in the Project navigator and add `com.apple.security.inherit` to it, with a Boolean value of `true`. For more information about this entitlement, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Miscellaneous\/Reference\/EntitlementKeyReference\/Chapters\/EnablingAppSandbox.html#\/\/apple_ref\/doc\/uid\/TP40011195-CH4-SW15].\n\nSelect the ToolX scheme and chose Product > Build, just to make sure that the tool builds correctly.\n\nNow switch back to the app (`AppWithTool`) scheme.\n\n### Embed the helper tool\n\nIn the Build Phases tab of the app target editor, add the ToolX target to the Dependencies build phase. This ensures that Xcode builds the tool target before building the app target.\n\nAdd a new Copy Files build phase. Double-click the build phase name and change it to `Embed Helper Tools` (the exact name doesn’t matter, but it’s best to pick a descriptive one). Set the Destination popup to Executables.  This places the helper tool in your app’s `Contents\/MacOS` directory, one of the locations recommended by [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle].\n\nAdd the `ToolX` executable to that build phase, making sure Code Sign On Copy is checked.\n\nFor more information about build phases, see [https:\/\/help.apple.com\/xcode\/mac\/11.4\/index.html#\/dev50bab713d]\n\n### Build and validate\n\nWith the project set up, it’s time to test that everything builds correctly. To start, choose Product > Archive, which builds the tool target and then the app target, embedding the result of the former within the latter.\n\nIn the Xcode organizer, select the newly created archive and click Distribute App.\n\n\n\nSelect App Store Connect and click Next, then select Export and click Next.\n\nGo through the rest of the export workflow. The end result is a directory with a name like `AppWithTool 2021-05-17 14-07-21`. Within that directory is an installer package (with the `.pkg` extension). Unpack that package.\n\n\n\nRun the following commands to confirm that Xcode constructed everything correctly:\n\n```\n% codesign -d -vvv --entitlements :- AppWithTool.app \n…\nIdentifier=com.example.apple-samplecode.AppWithTool\nFormat=app bundle with Mach-O universal (x86_64 arm64)\nCodeDirectory v=20500 size=822 flags=0x10000(runtime) hashes=14+7 location=embedded\n…\nAuthority=Apple Distribution: …\n…\nTeamIdentifier=SKMME9E2Y8\n…\n<dict>\n    <key>com.apple.security.app-sandbox<\/key>\n    <true\/>\n    <key>com.apple.security.files.user-selected.read-only<\/key>\n    <true\/>\n<\/dict>\n<\/plist>\n% codesign -d -vvv --entitlements :- AppWithTool.app\/Contents\/MacOS\/ToolX \n…\nIdentifier=com.example.apple-samplecode.AppWithTool.ToolX\nFormat=Mach-O universal (x86_64 arm64)\nCodeDirectory v=20500 size=796 flags=0x10000(runtime) hashes=13+7 location=embedded\n…\nAuthority=Apple Distribution: …\n…\nTeamIdentifier=SKMME9E2Y8\n…\n<dict>\n    <key>com.apple.security.app-sandbox<\/key>\n    <true\/>\n    <key>com.apple.security.inherit<\/key>\n    <true\/>\n<\/dict>\n<\/plist>\n```\n\nCheck the following:\n\n- The `Identifier` field is the code signing identifier.\n- The `Format` field shows that the executable is universal.\n- The `runtime` flag, in the `CodeDirectory` field, shows that the hardened runtime is enabled.\n- The `Authority` field shows that the code was signed by an Apple Distribution signing identity, which is what you’d expect for an App Store submission.\n- The `TeamIdentifier` field is your Team ID.\n- The app’s entitlements include `com.apple.security.app-sandbox` and whatever other entitlements are appropriate for this app.\n- The tool’s entitlements include just `com.apple.security.app-sandbox` and `com.apple.security.inherit`.\n\n\n\n### Embed an externally built tool\n\nWith the app and Xcode-built helper tool working correctly, it’s time to repeat the process for a tool built using an external build system. The following example creates an example helper tool from the command line and then embeds the tool in the AppWithTool app. In a real project, you’d use the command-line tool’s external build system (for example, `make`) to build the tool that you want to embed.\n\n### Build the tool\n\nCreate a new directory and change into it:\n\n```\n% mkdir ToolC\n% cd ToolC\n```\n\nHere *C* stands for *built with Clang*.\n\nCreate a source file in the directory that looks like this:\n\n```\n% cat main.c \n#include <stdio.h>\n\nint main(int argc, char ** argv) {\n    printf(\"Hello Cruel World!\\n\");\n    return 0;\n}\n```\n\nBuild that source file with `clang` twice, once for each architecture, and then `lipo` them together:\n\n```\n% clang -o ToolC-x86_64 -mmacosx-version-min=10.15 -arch x86_64 main.c\n% clang -o ToolC-arm64 -mmacosx-version-min=11.0 -arch arm64 main.c\n% lipo ToolC-x86_64 ToolC-arm64 -create -output ToolC \n```\n\nThe `-mmacosx-version-min` option sets the deployment target to match the AppWithTool app. For the Intel architecture, this is macOS 10.15, as discussed above. For the Apple silicon architecture, this is macOS 11.0, the first macOS release to support Apple silicon.\n\nCreate an entitlements file for the tool:\n\n```\n% \/usr\/libexec\/PlistBuddy -c \"Add :com.apple.security.app-sandbox bool true\" \"ToolC.entitlements\"\nFile Doesn't Exist, Will Create: ToolC.entitlements\n% \/usr\/libexec\/PlistBuddy -c \"Add :com.apple.security.inherit bool true\" ToolC.entitlements\n% cat ToolC.entitlements \n…\n<dict>\n    <key>com.apple.security.app-sandbox<\/key>\n    <true\/>\n    <key>com.apple.security.inherit<\/key>\n    <true\/>\n<\/dict>\n<\/plist>\n```\n\nSign the tool as shown below:\n\n```\n% codesign -s - -i com.example.apple-samplecode.AppWithTool.ToolC -o runtime --entitlements ToolC.entitlements -f ToolC\n```\n\nThis breaks down as follows:\n\n- The `-s -` argument applies an ad hoc signature (in Xcode parlance, this is Sign to Run Locally). Setting up the code signature here is critical. It sets up a pattern that Xcode uses when it re-signs the tool when embedding it into the final app. The signing identity is the only thing that doesn’t matter. Xcode overrides that identity with the product’s signing identity during the embedding process, which is why you can get away with an ad hoc signature.\n- The `-i com.example.apple-samplecode.AppWithTool.ToolC` option sets the code signing identifier.\n- The `-o runtime` option enables the hardened runtime. Again, this isn’t necessary for App Store distribution, but it’s best practice for new code.\n- The `--entitlements ToolC.entitlements` option supplies the signature’s entitlements.\n- The `-f` option overrides any existing signature. This isn’t strictly necessary but it avoids any confusion about the existing ad hoc signature applied by `clang` to the `arm64` architecture. Apple silicon requires that all code be signed, and so `clang` automatically applies an ad hoc signature when building for Apple silicon.\n\nAdd the `ToolC` executable to your Xcode project. When you do this:\n\n- Enable “Copy items if needed”.\n- Select “Create groups” rather than “Create folder reference”.\n- Uncheck all the boxes in the “Add to targets” list.\n\nIn the Build Phases tab of the app target editor, add `ToolC` to the Embed Helper Tools build phase, making sure that Code Sign On Copy is checked.\n\n### Build and validate again\n\nTo validate your work, follow the process described in [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/embedding-a-helper-tool-in-a-sandboxed-app#Build-and-validate], substituting `ToolC` for `ToolX` everywhere.\n\n## Project configuration\n\n- **Managing your app’s information property list values**: Customize the information property list values for your app using Xcode.\n- **Adding package dependencies to your app**: Integrate package dependencies to share code between projects, or leverage code from other developers.\n- **Creating a Mac version of your iPad app**: Bring your iPad app to macOS with Mac Catalyst.\n- **Setting up a watchOS project**: Create a new watchOS project or add a watch target to an existing iOS project.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Customize the information property list values for your app using Xcode.",
          "name" : "Managing your app’s information property list values",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/managing-your-app-s-information-property-list"
        },
        {
          "description" : "Integrate package dependencies to share code between projects, or leverage code from other developers.",
          "name" : "Adding package dependencies to your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/adding-package-dependencies-to-your-app"
        },
        {
          "description" : "Bring your iPad app to macOS with Mac Catalyst.",
          "name" : "Creating a Mac version of your iPad app",
          "url" : "https:\/\/developer.apple.com\/documentation\/UIKit\/creating-a-mac-version-of-your-ipad-app"
        },
        {
          "description" : "Create a new watchOS project or add a watch target to an existing iOS project.",
          "name" : "Setting up a watchOS project",
          "url" : "https:\/\/developer.apple.com\/documentation\/WatchKit\/setting-up-a-watchos-project"
        }
      ],
      "title" : "Project configuration"
    }
  ],
  "source" : "appleJSON",
  "title" : "Embedding a command-line tool in a sandboxed app",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/embedding-a-helper-tool-in-a-sandboxed-app"
}