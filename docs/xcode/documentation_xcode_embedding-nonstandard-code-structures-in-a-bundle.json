{
  "abstract" : "Use code that’s structured in a nonstandard way while avoiding code signing and distribution problems.",
  "codeExamples" : [
    {
      "code" : "libWaffleVarnish\/\n  bin\/\n    wafflevarnish\n  etc\/\n    wafflevarnish.config\n  lib\/\n    libVarnish.dylib\n    libWaffle.dylib"
    },
    {
      "code" : "% otool -l libWaffleVarnish\/bin\/wafflevarnish | grep -B 1 -A 2 LC_RPATH \nLoad command 15\n          cmd LC_RPATH\n      cmdsize 40\n         path @executable_path\/..\/lib …"
    },
    {
      "code" : "% otool -L \"libWaffleVarnish\/bin\/wafflevarnish\"\n…\n    @rpath\/libVarnish.dylib …\n    @rpath\/libWaffle.dylib …\n    …\n% otool -L \"libWaffleVarnish\/lib\/libVarnish.dylib\"\n…\n    @rpath\/libVarnish.dylib …\n    @rpath\/libWaffle.dylib …\n    …\n% otool -L \"libWaffleVarnish\/lib\/libWaffle.dylib\"\n…\n    @rpath\/libWaffle.dylib …\n    …"
    },
    {
      "code" : "% otool -L \"libRubPat\/bin\/rubpat\"\n…\n    \/usr\/local\/libRubPat\/lib\/libPat.dylib …\n    \/usr\/local\/libRubPat\/lib\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libPat.dylib\"\n…\n    \/usr\/local\/libRubPat\/lib\/libPat.dylib …\n    \/usr\/local\/libRubPat\/lib\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libRub.dylib\"\n…\n    \/usr\/local\/libRubPat\/lib\/libRub.dylib …\n    …"
    },
    {
      "code" : "% codesign --remove-signature \"libRubPat\/lib\/libRub.dylib\"\n% codesign --remove-signature \"libRubPat\/lib\/libPat.dylib\"\n% codesign --remove-signature \"libRubPat\/bin\/rubpat\""
    },
    {
      "code" : "% install_name_tool -id \"@rpath\/libRub.dylib\" \"libRubPat\/lib\/libRub.dylib\"\n% install_name_tool -id \"@rpath\/libPat.dylib\" \"libRubPat\/lib\/libPat.dylib\""
    },
    {
      "code" : "% install_name_tool -change \"\/usr\/local\/libRubPat\/lib\/libRub.dylib\" \"@rpath\/libWaffle.dylib\" \"libRubPat\/lib\/libPat.dylib\"\n% install_name_tool -change \"\/usr\/local\/libRubPat\/lib\/libRub.dylib\" \"@rpath\/libWaffle.dylib\" \"libRubPat\/bin\/rubpat\"\n% install_name_tool -change \"\/usr\/local\/libRubPat\/lib\/libPat.dylib\" \"@rpath\/libVarnish.dylib\" \"libRubPat\/bin\/rubpat\""
    },
    {
      "code" : "% install_name_tool -add_rpath \"@executable_path\/..\/lib\" \"libRubPat\/bin\/rubpat\""
    },
    {
      "code" : "% otool -l libRubPat\/bin\/rubpat | grep -B 1 -A 2 LC_RPATH \nLoad command 17\n          cmd LC_RPATH\n      cmdsize 40\n         path @executable_path\/..\/lib (offset 12)\n\n% otool -L \"libRubPat\/bin\/rubpat\"\n…\n    @rpath\/libPat.dylib …\n    @rpath\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libPat.dylib\"\n…\n    @rpath\/libPat.dylib …\n    @rpath\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libRub.dylib\"\n…\n    @rpath\/libRub.dylib …\n    …"
    },
    {
      "code" : "MacWaffleVarnish.app\/\n  Contents\/\n    Info.plist\n    MacOS\/\n      MacWaffleVarnish\n      wafflevarnish\n    Frameworks\/\n      libVarnish.dylib\n      libWaffle.dylib\n    Resources\/\n      … other resources …\n      libWaffleVarnish\/\n        etc\/\n          wafflevarnish.config"
    },
    {
      "code" : "% install_name_tool -rpath \"@executable_path\/..\/lib\" \"@executable_path\/..\/Frameworks\" \"wafflevarnish\""
    },
    {
      "code" : "% MacWaffleVarnish.app\/Contents\/MacOS\/wafflevarnish\nMacWaffleVarnish.app\/Contents\/MacOS\/..\/etc\/wafflevarnish.config: No such file or directory\n…"
    },
    {
      "code" : "MacWaffleVarnish.app\/\n  Contents\/\n    …\n    MacOS\/\n      …\n      wafflevarnish\n    …\n    Resources\/\n      …\n      libWaffleVarnish\/\n        bin\/\n          wafflevarnish -> ..\/..\/MacOS\/wafflevarnish\n        etc\/\n          wafflevarnish.config"
    },
    {
      "code" : "% MacWaffleVarnish.app\/Contents\/Resources\/libWaffleVarnish\/bin\/wafflevarnish\nconfiguration:\n  finish: gloss\n…"
    }
  ],
  "contentHash" : "f15ea49f52738d02b610d681363bc63995ef42256e5f5f130bcb7c4910b6289f",
  "crawledAt" : "2025-12-04T01:08:39Z",
  "id" : "660271AE-5E66-4AC4-B1E1-EFB247516EAC",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nAll apps — and many non-app software products on the Mac, like plug-ins — are packaged in a bundle structure.  When creating a bundle, place content in the correct location.  Placing content in a nonstandard location can cause code signing and distribution problems.  For more on this, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle].\n\nIn some cases you need to work with nonstandard code structures, that is, code whose structure doesn’t match the standard bundle structure for your platform.  For example, you might be building a Mac app and want to embed an open source language runtime in it.  If the on-disk layout of this runtime doesn’t follow the rules in [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle], you run the risk of code signing and distribution problems.\n\nThe best way to resolve this conundrum is to rebuild the code to match your target platform’s bundle structure.  However, this isn’t always feasible:\n\nFortunately there’s another way.  This document walks you through an example of how to embed a nonstandard code structure into your bundle without having to rebuild all the code.  This example is for the Mac but the basic techniques work on all Apple platforms.\n\n### Separate read-only and read\/write content\n\nA bundle is a read-only structure.  All Apple platforms except the Mac enforce this requirement at runtime.  On iOS, for example, any attempt to modify your app’s bundle at runtime will fail with an error.  The Mac may or may not enforce this requirement at runtime, depending on the context, but modifying your app’s bundle isn’t supported because it breaks the seal on the app’s code signature.\n\nCode structures with their origins on other platforms are not always compatible with this requirement.  For example, the Python runtime writes bytecode files in the same directory in as the original Python source file.  If, say, you have a file called `WaffleVarnish.py`, the runtime may write a file called `WaffleVarnish.pyc` (or `WaffleVarnish.pyo`) into that directory.  This causes two problems:\n\nIf the code you’re using works this way, find a way to separate its read-only content, which you can safely place in your bundle, and its read\/write content, which you can’t.  The details are specific to the code in question, but this often involves setting a command-line argument or an environment variable that points to a writable location, for example, in the Library directory.\n\n### Investigate dynamic library linkage\n\nImagine you’re building a Mac app to varnish waffles and want to use the fabulous open source libWaffleVarnish code.  Its build system outputs a directory structure like this:\n\nThe `wafflevarnish` tool depends on both dynamic libraries.  The `libVarnish.dylib` library depends on `libWaffle.dylib`.  The `wafflevarnish` tool also reads the `wafflevarnish.config` configuration file.\n\nThe good news here is that libWaffleVarnish is structured in a way that makes it easy to relocate.  The `wafflevarnish` tool sets up the rpath context via an executable relative path that leads to the `lib` directory:\n\nAnd both `wafflevarnish` and `libVarnish.dylib` reference their dynamic library dependencies with rpath-relative references:\n\nFor more information on the rpath mechanism, see the `dyld` man page.  If you’re unfamiliar with reading man pages, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].\n\nWith this setup it’s easy to place this tool and its libraries in your bundle with a minimum amount of disruption.  If the code you’re using is built this way, skip forward to [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/embedding-nonstandard-code-structures-in-a-bundle#Place-content-in-the-correct-location-within-the-bundle].\n\n### Adopt rpath-relative references\n\nNot all code with a nonstandard structure is as accommodating as libWaffleVarnish.  For example, the build system for libRubPat expresses its dependencies using absolute paths:\n\nThis tool and its associated dynamic libraries will only work when they’re installed in `\/usr\/local\/libRubPat`, so you can’t embed this code as-is in your bundle.\n\nThe best way to fix this problem is to update the code’s build system to use rpath-relative references.  However, this isn’t possible for libRubPat because that library is not open source.  To embed libRubPat in your bundle, use `install_name_tool` to change the paths embedded in its code items.  First remove all the code signatures:\n\nChanging code using `install_name_tool` breaks the seal on its code signature, a fact that `install_name_tool` warns you about.  You will be re-signing this code as part of your distribution process, so you might as well work with unsigned code and avoid a bunch of warnings.\n\nNow change the dynamic library identifier for each library to be rpath-relative:\n\nThis controls how the library identifies itself to the rest of the system.\n\nNext, change each dynamic library dependency to match:\n\nFinally, add an executable-relative rpath to the tool:\n\nTo confirm that you’ve fixed all the dependencies, run `otool` just like you did for libWaffleVarnish:\n\nThe final result is a code structure where all the dynamic library dependencies are rpath-relative, and the rpath entry for the tool itself is executable-relative.  This structure works regardless of where it’s located on disk, making it feasible to embed it in your bundle.\n\n### Place content in the correct location within the bundle\n\nOnce you’ve confirmed that the code uses rpath-relative paths, it’s time to embed it in your bundle.  Imagine you’re building an app called MacWaffleVarnish.  The rules in [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle] require this structure:\n\nThe dynamic libraries are in `Contents\/Frameworks`, the tool in `Contents\/MacOS`, and the configuration file in `Contents\/Resources`.\n\nTo make this work, use `install_name_tool` to adjust the rpath entry in the `wafflevarnish` tool to point to the Frameworks directory rather than the lib directory:\n\nAnd that’s all you need to do.  The use of rpath-relative references in libWaffleVarnish makes it easy to change its code structure to match platform conventions.\n\n### Use symlinks for gnarly edge cases\n\nThere’s one final gotcha here.  If you run the `wafflevarnish` tool you’ll see this error:\n\nIt’s trying to access `wafflevarnish.config` via a path that’s relative to the executable, but you’ve moved things around such that the configuration file is no longer available at that relative path.  In many cases a tool will have a way to set the path to its configuration using a command-line argument or an environment variable.  If not, fix the problem using a symlink:\n\nNow, if you run the `wafflevarnish` tool via the symlink, it finds the configuration file and all is well:\n\nSymlinking is a powerful technique for handling gnarly edge cases.  For example, if the code dynamically loads a plug-in via a relative path that leads to a location that cannot hold code, create a symlink at that location that points to where the code is actually placed.\n\nYou can also use symlinks to reduce the number of dynamic library dependencies you have to rewrite using `install_name_tool`.  Imagine you’re working with a huge code structure with a lot of inter-library dependencies.  Rather than rewrite all of those dependencies, you could embed the code structure en masse, then move each code item to its appropriate location within your bundle while leaving behind a symlink.\n\nIn most cases, however, it’s easier and better to rewrite everything to use rpath-relative references.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/embedding-nonstandard-code-structures-in-a-bundle\ncrawled: 2025-12-04T01:08:39Z\n---\n\n# Embedding nonstandard code structures in a bundle\n\n**Article**\n\nUse code that’s structured in a nonstandard way while avoiding code signing and distribution problems.\n\n## Overview\n\nAll apps — and many non-app software products on the Mac, like plug-ins — are packaged in a bundle structure.  When creating a bundle, place content in the correct location.  Placing content in a nonstandard location can cause code signing and distribution problems.  For more on this, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle].\n\nIn some cases you need to work with nonstandard code structures, that is, code whose structure doesn’t match the standard bundle structure for your platform.  For example, you might be building a Mac app and want to embed an open source language runtime in it.  If the on-disk layout of this runtime doesn’t follow the rules in [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle], you run the risk of code signing and distribution problems.\n\nThe best way to resolve this conundrum is to rebuild the code to match your target platform’s bundle structure.  However, this isn’t always feasible:\n\n- It requires extensive knowledge of the code’s build system.  If you’re not already familiar with that, you may spend a lot of time gaining that knowledge.\n- It only works if the product is open source.\n\nFortunately there’s another way.  This document walks you through an example of how to embed a nonstandard code structure into your bundle without having to rebuild all the code.  This example is for the Mac but the basic techniques work on all Apple platforms.\n\n\n\n### Separate read-only and read\/write content\n\nA bundle is a read-only structure.  All Apple platforms except the Mac enforce this requirement at runtime.  On iOS, for example, any attempt to modify your app’s bundle at runtime will fail with an error.  The Mac may or may not enforce this requirement at runtime, depending on the context, but modifying your app’s bundle isn’t supported because it breaks the seal on the app’s code signature.\n\nCode structures with their origins on other platforms are not always compatible with this requirement.  For example, the Python runtime writes bytecode files in the same directory in as the original Python source file.  If, say, you have a file called `WaffleVarnish.py`, the runtime may write a file called `WaffleVarnish.pyc` (or `WaffleVarnish.pyo`) into that directory.  This causes two problems:\n\n- If the platform blocks this write, you miss out on the performance benefits of these bytecode files.\n- If the platform does not block this write, the write breaks the seal on your app’s code signature.\n\nIf the code you’re using works this way, find a way to separate its read-only content, which you can safely place in your bundle, and its read\/write content, which you can’t.  The details are specific to the code in question, but this often involves setting a command-line argument or an environment variable that points to a writable location, for example, in the Library directory.\n\n### Investigate dynamic library linkage\n\nImagine you’re building a Mac app to varnish waffles and want to use the fabulous open source libWaffleVarnish code.  Its build system outputs a directory structure like this:\n\n```\nlibWaffleVarnish\/\n  bin\/\n    wafflevarnish\n  etc\/\n    wafflevarnish.config\n  lib\/\n    libVarnish.dylib\n    libWaffle.dylib\n```\n\nThe `wafflevarnish` tool depends on both dynamic libraries.  The `libVarnish.dylib` library depends on `libWaffle.dylib`.  The `wafflevarnish` tool also reads the `wafflevarnish.config` configuration file.\n\nThe good news here is that libWaffleVarnish is structured in a way that makes it easy to relocate.  The `wafflevarnish` tool sets up the rpath context via an executable relative path that leads to the `lib` directory:\n\n```\n% otool -l libWaffleVarnish\/bin\/wafflevarnish | grep -B 1 -A 2 LC_RPATH \nLoad command 15\n          cmd LC_RPATH\n      cmdsize 40\n         path @executable_path\/..\/lib …\n```\n\nAnd both `wafflevarnish` and `libVarnish.dylib` reference their dynamic library dependencies with rpath-relative references:\n\n```\n% otool -L \"libWaffleVarnish\/bin\/wafflevarnish\"\n…\n    @rpath\/libVarnish.dylib …\n    @rpath\/libWaffle.dylib …\n    …\n% otool -L \"libWaffleVarnish\/lib\/libVarnish.dylib\"\n…\n    @rpath\/libVarnish.dylib …\n    @rpath\/libWaffle.dylib …\n    …\n% otool -L \"libWaffleVarnish\/lib\/libWaffle.dylib\"\n…\n    @rpath\/libWaffle.dylib …\n    …\n```\n\nFor more information on the rpath mechanism, see the `dyld` man page.  If you’re unfamiliar with reading man pages, see [doc:\/\/com.apple.documentation\/documentation\/os\/reading-unix-manual-pages].\n\nWith this setup it’s easy to place this tool and its libraries in your bundle with a minimum amount of disruption.  If the code you’re using is built this way, skip forward to [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/embedding-nonstandard-code-structures-in-a-bundle#Place-content-in-the-correct-location-within-the-bundle].\n\n### Adopt rpath-relative references\n\nNot all code with a nonstandard structure is as accommodating as libWaffleVarnish.  For example, the build system for libRubPat expresses its dependencies using absolute paths:\n\n```\n% otool -L \"libRubPat\/bin\/rubpat\"\n…\n    \/usr\/local\/libRubPat\/lib\/libPat.dylib …\n    \/usr\/local\/libRubPat\/lib\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libPat.dylib\"\n…\n    \/usr\/local\/libRubPat\/lib\/libPat.dylib …\n    \/usr\/local\/libRubPat\/lib\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libRub.dylib\"\n…\n    \/usr\/local\/libRubPat\/lib\/libRub.dylib …\n    …\n```\n\nThis tool and its associated dynamic libraries will only work when they’re installed in `\/usr\/local\/libRubPat`, so you can’t embed this code as-is in your bundle.\n\n\n\nThe best way to fix this problem is to update the code’s build system to use rpath-relative references.  However, this isn’t possible for libRubPat because that library is not open source.  To embed libRubPat in your bundle, use `install_name_tool` to change the paths embedded in its code items.  First remove all the code signatures:\n\n```\n% codesign --remove-signature \"libRubPat\/lib\/libRub.dylib\"\n% codesign --remove-signature \"libRubPat\/lib\/libPat.dylib\"\n% codesign --remove-signature \"libRubPat\/bin\/rubpat\"\n```\n\nChanging code using `install_name_tool` breaks the seal on its code signature, a fact that `install_name_tool` warns you about.  You will be re-signing this code as part of your distribution process, so you might as well work with unsigned code and avoid a bunch of warnings.\n\nNow change the dynamic library identifier for each library to be rpath-relative:\n\n```\n% install_name_tool -id \"@rpath\/libRub.dylib\" \"libRubPat\/lib\/libRub.dylib\"\n% install_name_tool -id \"@rpath\/libPat.dylib\" \"libRubPat\/lib\/libPat.dylib\"\n```\n\nThis controls how the library identifies itself to the rest of the system.\n\nNext, change each dynamic library dependency to match:\n\n```\n% install_name_tool -change \"\/usr\/local\/libRubPat\/lib\/libRub.dylib\" \"@rpath\/libWaffle.dylib\" \"libRubPat\/lib\/libPat.dylib\"\n% install_name_tool -change \"\/usr\/local\/libRubPat\/lib\/libRub.dylib\" \"@rpath\/libWaffle.dylib\" \"libRubPat\/bin\/rubpat\"\n% install_name_tool -change \"\/usr\/local\/libRubPat\/lib\/libPat.dylib\" \"@rpath\/libVarnish.dylib\" \"libRubPat\/bin\/rubpat\"\n```\n\nFinally, add an executable-relative rpath to the tool:\n\n```\n% install_name_tool -add_rpath \"@executable_path\/..\/lib\" \"libRubPat\/bin\/rubpat\"\n```\n\nTo confirm that you’ve fixed all the dependencies, run `otool` just like you did for libWaffleVarnish:\n\n```\n% otool -l libRubPat\/bin\/rubpat | grep -B 1 -A 2 LC_RPATH \nLoad command 17\n          cmd LC_RPATH\n      cmdsize 40\n         path @executable_path\/..\/lib (offset 12)\n\n% otool -L \"libRubPat\/bin\/rubpat\"\n…\n    @rpath\/libPat.dylib …\n    @rpath\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libPat.dylib\"\n…\n    @rpath\/libPat.dylib …\n    @rpath\/libRub.dylib …\n    …\n% otool -L \"libRubPat\/lib\/libRub.dylib\"\n…\n    @rpath\/libRub.dylib …\n    …\n```\n\nThe final result is a code structure where all the dynamic library dependencies are rpath-relative, and the rpath entry for the tool itself is executable-relative.  This structure works regardless of where it’s located on disk, making it feasible to embed it in your bundle.\n\n### Place content in the correct location within the bundle\n\nOnce you’ve confirmed that the code uses rpath-relative paths, it’s time to embed it in your bundle.  Imagine you’re building an app called MacWaffleVarnish.  The rules in [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/placing-content-in-a-bundle] require this structure:\n\n```\nMacWaffleVarnish.app\/\n  Contents\/\n    Info.plist\n    MacOS\/\n      MacWaffleVarnish\n      wafflevarnish\n    Frameworks\/\n      libVarnish.dylib\n      libWaffle.dylib\n    Resources\/\n      … other resources …\n      libWaffleVarnish\/\n        etc\/\n          wafflevarnish.config\n```\n\nThe dynamic libraries are in `Contents\/Frameworks`, the tool in `Contents\/MacOS`, and the configuration file in `Contents\/Resources`.\n\nTo make this work, use `install_name_tool` to adjust the rpath entry in the `wafflevarnish` tool to point to the Frameworks directory rather than the lib directory:\n\n```\n% install_name_tool -rpath \"@executable_path\/..\/lib\" \"@executable_path\/..\/Frameworks\" \"wafflevarnish\"\n```\n\nAnd that’s all you need to do.  The use of rpath-relative references in libWaffleVarnish makes it easy to change its code structure to match platform conventions.\n\n### Use symlinks for gnarly edge cases\n\nThere’s one final gotcha here.  If you run the `wafflevarnish` tool you’ll see this error:\n\n```\n% MacWaffleVarnish.app\/Contents\/MacOS\/wafflevarnish\nMacWaffleVarnish.app\/Contents\/MacOS\/..\/etc\/wafflevarnish.config: No such file or directory\n…\n```\n\nIt’s trying to access `wafflevarnish.config` via a path that’s relative to the executable, but you’ve moved things around such that the configuration file is no longer available at that relative path.  In many cases a tool will have a way to set the path to its configuration using a command-line argument or an environment variable.  If not, fix the problem using a symlink:\n\n```\nMacWaffleVarnish.app\/\n  Contents\/\n    …\n    MacOS\/\n      …\n      wafflevarnish\n    …\n    Resources\/\n      …\n      libWaffleVarnish\/\n        bin\/\n          wafflevarnish -> ..\/..\/MacOS\/wafflevarnish\n        etc\/\n          wafflevarnish.config\n```\n\nNow, if you run the `wafflevarnish` tool via the symlink, it finds the configuration file and all is well:\n\n```\n% MacWaffleVarnish.app\/Contents\/Resources\/libWaffleVarnish\/bin\/wafflevarnish\nconfiguration:\n  finish: gloss\n…\n```\n\nSymlinking is a powerful technique for handling gnarly edge cases.  For example, if the code dynamically loads a plug-in via a relative path that leads to a location that cannot hold code, create a symlink at that location that points to where the code is actually placed.\n\nYou can also use symlinks to reduce the number of dynamic library dependencies you have to rewrite using `install_name_tool`.  Imagine you’re working with a huge code structure with a lot of inter-library dependencies.  Rather than rewrite all of those dependencies, you could embed the code structure en masse, then move each code item to its appropriate location within your bundle while leaving behind a symlink.\n\nIn most cases, however, it’s easier and better to rewrite everything to use rpath-relative references.\n\n## Bundles\n\n- **Placing content in a bundle**: Place bundle content in the correct location based on its type.\n- **Managing your app’s information property list values**: Customize the information property list values for your app using Xcode.\n- **Editing property list files**: Add, remove, and change keys and values in a structured file.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Place bundle content in the correct location based on its type.",
          "name" : "Placing content in a bundle",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/placing-content-in-a-bundle"
        },
        {
          "description" : "Customize the information property list values for your app using Xcode.",
          "name" : "Managing your app’s information property list values",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/managing-your-app-s-information-property-list"
        },
        {
          "description" : "Add, remove, and change keys and values in a structured file.",
          "name" : "Editing property list files",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/editing-property-list-files"
        }
      ],
      "title" : "Bundles"
    }
  ],
  "source" : "appleJSON",
  "title" : "Embedding nonstandard code structures in a bundle",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/embedding-nonstandard-code-structures-in-a-bundle"
}