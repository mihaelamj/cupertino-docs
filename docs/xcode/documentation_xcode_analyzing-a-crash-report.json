{
  "abstract" : "Identify clues in a crash report that help you diagnose problems.",
  "codeExamples" : [
    {
      "code" : "Last Exception Backtrace:\n0   CoreFoundation                    0x1a1801190 __exceptionPreprocess + 228\n1   libobjc.A.dylib                   0x1a09d69f8 objc_exception_throw + 55\n2   UIKitCore                         0x1cd5d0af0 -[UIPopoverPresentationController presentationTransitionWillBegin] + 2739\n3   UIKitCore                         0x1cd5d9358 __71-[UIPresentationController _initViewHierarchyForPresentationSuperview:]_block_invoke + 2175\n4   UIKitCore                         0x1cd5d6ea4 __56-[UIPresentationController runTransitionForCurrentState]_block_invoke + 463\n5   UIKitCore                         0x1cdc5c0ac _runAfterCACommitDeferredBlocks + 295\n6   UIKitCore                         0x1cdc4abfc _cleanUpAfterCAFlushAndRunDeferredBlocks + 351\n7   UIKitCore                         0x1cdc77a6c _afterCACommitHandler + 115\n8   CoreFoundation                    0x1a179250c __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 31\n9   CoreFoundation                    0x1a178d234 __CFRunLoopDoObservers + 411\n10  CoreFoundation                    0x1a178d7b0 __CFRunLoopRun + 1227\n11  CoreFoundation                    0x1a178cfc4 CFRunLoopRunSpecific + 435\n12  GraphicsServices                  0x1a398e79c GSEventRunModal + 103\n13  UIKitCore                         0x1cdc50c38 UIApplicationMain + 211\n14  MyGreatApp                        0x10079600c main (in MyGreatApp) (AppDelegate.swift:12)\n15  libdyld.dylib                     0x1a124d8e0 start + 3",
      "language" : "other"
    }
  ],
  "contentHash" : "3c7b3b08f124ddd10e737cec5c7fe1f7a7800de9a079f867566e446358453bdf",
  "crawledAt" : "2025-12-07T15:08:19Z",
  "id" : "9744444C-2D66-4979-9EE3-5A764FFE9E1E",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nA crash report is a detailed log of an app’s state when it crashed, making it a crucial resource for identifying a problem before attempting to fix it. If you’re investigating a crash that isn’t resolved by the techniques discussed in [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/identifying-the-cause-of-common-crashes], you need to do a careful analysis of the complete crash report.\n\nWhen analyzing a crash report, read the information in all sections. As you formulate the hypothesis about the cause of a crash, ask questions about what the data in each section of the crash report says to refine or disprove the hypothesis. Some clues are explicitly captured by fields in the crash report, but other clues are subtle, and require you to uncover them by noticing small details. Performing a thorough analysis of a crash report and formulating a hypothesis takes time and practice to develop, but is a critical tool for making your app more robust.\n\n### Start from the user’s perspective\n\nFind a starting point from the crash report’s information to think about the crash from the user’s perspective to refine the hypothesis. For example, a frame in the backtrace may indicate a particular feature of the app is in use, and you can think about how other information in the crash report relates to that feature.\n\n### Group multiple crash reports according to similar and unique details\n\nIf you have many crash reports, try organizing them into groups to clarify the source of a crash. If many crash reports contain the exact same information, the problem likely is consistently reproducible, and the common details in the crash reports help you isolate the issue. If you have crash reports that all appear different, but you suspect the underlying cause is the same, pay attention to any detail that looks unusual. Place any crash reports with unusual details into their own group. By grouping crash reports based on similar and dissimilar details, you sometimes uncover insights into the cause of a crash that aren’t visible when looking at crash reports individually.\n\n### Check the header to identify the crash environment\n\nIf you have multiple crash reports that are similar, use the header information to help understand the scope of the problem, and to target the specific operating system versions and devices you need to reproduce the problem. Some questions that can help refine your hypothesis about the crash are:\n\nIf you’re unfamiliar with a specific field or its value in this section of crash report, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Header].\n\n### Identify the exception information\n\nEvery crash report records exception information that shows the exact mechanism by which the app’s process terminated. Termination is always the last step in error handling, but it starts when an unrecoverable condition occurs in the app or the frameworks it uses. For example, the app may request termination directly, such as by calling `abort()`. As a different example, the operating system may terminate the process to enforce a system policy, such as through a watchdog that ensures app responsiveness.\n\nException information narrows the sources for the crash you’re analyzing, and helps identify the clues you look for in other sections of the crash report. See [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/understanding-the-exception-types-in-a-crash-report] for details on the specific exception type in the crash report you’re analyzing, and then answer the following questions:\n\nIf you’re unfamiliar with a field in this section, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Exception-information].\n\n### Look for diagnostic messages\n\nFor certain types of problems, a crash report may contain additional diagnostic information between the Exception Information section and the Backtraces section. This information is directly related to the exception type.\n\nIf you’re unfamiliar with a field in this section, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Diagnostic-messages].\n\n### Read the backtraces\n\nThe backtraces in a crash report show the exact methods executing at the time of the crash—see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Backtraces] for a breakdown of what each column in this section means. As a starting point, look at the crashed thread, as well as the `Last Exception Backtrace` if one is present. Answer these questions about the backtrace:\n\nEven if the functions in the backtrace aren’t ones you directly call, they contain key clues. For example, this backtrace contains only system frameworks except for the app’s `main` function, but the crash is due to an invalid popover configuration in an iPadOS app:\n\nFrames 3 and 4 provide a clue that this crash relates to presenting a view controller, and frame 2 is a clue that the app is presenting a popover. This information narrows down what parts of your app’s code to focus on, even when no code from the app is in the backtrace.\n\nYou can frequently determine the purpose of a thread based on the bottom frames in the thread’s backtrace. An app’s main thread has [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationMain(_:_:)] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationMain(_:_:_:_:)-1yub7] in the bottom frames. Threads created through the [doc:\/\/com.apple.documentation\/documentation\/Dispatch] framework have `start_wqthread` in the bottom frames. As you look closer at the crashed thread’s backtrace, consider whether your app appears in a coherent state that matches your expectations about how your app functions:\n\nIn addition to the backtrace for the crashed thread or language exception, other thread backtraces provide additional clues about what state the app is in. These clues are subtle:\n\nIn some types of crashes, the crashed thread’s backtrace doesn’t consistently contain the source of the issue. [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-watchdog-terminations] describes situations where this happens for watchdog terminations, and [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-memory-access-crashes] describes this scenario for memory corruption crashes.\n\n### Understand the crashed thread’s registers\n\nAnalysis of most crash reports don’t need to consider the register state. However, if you’re investigating a difficult memory access issue, the registers provide information not found elsewhere in the crash report.\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-memory-access-crashes#Identify-the-type-of-memory-access-that-caused-the-issue] describes how to use these questions to diagnose a memory access crash.\n\n### Verify your frameworks are present in the binary images\n\nUse the Binary Images section of the crash report to take stock of the frameworks your app loads. You can identify the frameworks in your app by the file paths.\n\nFor the meaning of each column in this section, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Binary-images].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/xcode\/analyzing-a-crash-report\ncrawled: 2025-12-07T15:08:19Z\n---\n\n# Analyzing a crash report\n\n**Article**\n\nIdentify clues in a crash report that help you diagnose problems.\n\n## Overview\n\nA crash report is a detailed log of an app’s state when it crashed, making it a crucial resource for identifying a problem before attempting to fix it. If you’re investigating a crash that isn’t resolved by the techniques discussed in [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/identifying-the-cause-of-common-crashes], you need to do a careful analysis of the complete crash report.\n\n\n\nWhen analyzing a crash report, read the information in all sections. As you formulate the hypothesis about the cause of a crash, ask questions about what the data in each section of the crash report says to refine or disprove the hypothesis. Some clues are explicitly captured by fields in the crash report, but other clues are subtle, and require you to uncover them by noticing small details. Performing a thorough analysis of a crash report and formulating a hypothesis takes time and practice to develop, but is a critical tool for making your app more robust.\n\n\n\n### Start from the user’s perspective\n\nFind a starting point from the crash report’s information to think about the crash from the user’s perspective to refine the hypothesis. For example, a frame in the backtrace may indicate a particular feature of the app is in use, and you can think about how other information in the crash report relates to that feature.\n\n### Group multiple crash reports according to similar and unique details\n\nIf you have many crash reports, try organizing them into groups to clarify the source of a crash. If many crash reports contain the exact same information, the problem likely is consistently reproducible, and the common details in the crash reports help you isolate the issue. If you have crash reports that all appear different, but you suspect the underlying cause is the same, pay attention to any detail that looks unusual. Place any crash reports with unusual details into their own group. By grouping crash reports based on similar and dissimilar details, you sometimes uncover insights into the cause of a crash that aren’t visible when looking at crash reports individually.\n\n### Check the header to identify the crash environment\n\nIf you have multiple crash reports that are similar, use the header information to help understand the scope of the problem, and to target the specific operating system versions and devices you need to reproduce the problem. Some questions that can help refine your hypothesis about the crash are:\n\n- Does the crash occur in multiple versions of your app, or just one?\n- Does the crash occur on multiple versions of the operating system?\n- Is the crash from only one type of device, such as an iPad but not an iPhone?\n- Did the crash originate from your main app, or from one of your app extensions?\n- Is the crash from a TestFlight beta of your app?\n- Are all of the crashes from the same app thinning variant? Are you able to reproduce the crash if you export the specific app variant? To export a specific app variant, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/distributing-your-app-for-beta-testing-and-releases].\n- What device model did the app crash on? How much testing did you do on a device with similar capabilities?\n- Do multiple users experience the crash, or only a small number of unique users? Use the `CrashReporter Key` or the `Beta Identifier` fields to determine this.\n- How long was the app running before it crashed? Use the `Date\/Time` and `Launch Time` fields to determine this.\n\nIf you’re unfamiliar with a specific field or its value in this section of crash report, consult [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Header].\n\n### Identify the exception information\n\nEvery crash report records exception information that shows the exact mechanism by which the app’s process terminated. Termination is always the last step in error handling, but it starts when an unrecoverable condition occurs in the app or the frameworks it uses. For example, the app may request termination directly, such as by calling `abort()`. As a different example, the operating system may terminate the process to enforce a system policy, such as through a watchdog that ensures app responsiveness.\n\nException information narrows the sources for the crash you’re analyzing, and helps identify the clues you look for in other sections of the crash report. See [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/understanding-the-exception-types-in-a-crash-report] for details on the specific exception type in the crash report you’re analyzing, and then answer the following questions:\n\n- What is the exception type? What category of error does the exception define?\n- What thread triggered the crash? What relationship do you see between the frames in the crashed thread’s backtrace and the information communicated by the exception type?\n- What types of underlying issues does the exception type rule out? For example, the `EXC_BAD_ACCESS` exception rules out that a crash is due to an uncaught language exception.\n- Are there any additional codes in the `Termination Reason` field? What does the code mean?\n- Does the exception type indicate specific diagnostic tools are useful for discovering the issue?\n- Is the exception related to a specific type of system resource?\n\nIf you’re unfamiliar with a field in this section, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Exception-information].\n\n### Look for diagnostic messages\n\nFor certain types of problems, a crash report may contain additional diagnostic information between the Exception Information section and the Backtraces section. This information is directly related to the exception type.\n\n- Based on the exception type, is the crash due to an uncaught language exception? If so, what additional information about the API throwing the exception is in the message? See [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-language-exception-crashes] for additional information.\n- Based on the exception type, is the crash due to a memory access issue? See [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-memory-access-crashes] for how to decode the provided `VM Region Info`.\n- Is there a `Termination Description` field indicating the involvement of a specific part of the operating system? Is there an additional code in the `Termination Reason` field? What hints to the source of the problem does the message provide?\n- Is there an `Application Specific Information` field? Is there a specific API named in that message? Where do you use that API in your code?\n\nIf you’re unfamiliar with a field in this section, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Diagnostic-messages].\n\n### Read the backtraces\n\nThe backtraces in a crash report show the exact methods executing at the time of the crash—see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Backtraces] for a breakdown of what each column in this section means. As a starting point, look at the crashed thread, as well as the `Last Exception Backtrace` if one is present. Answer these questions about the backtrace:\n\n- What function is this thread serving in the app? Is it the main thread or another thread with a specific purpose?\n- Was a language exception thrown? What does the `Last Exception Backtrace` show?\n- What parts of the app use this thread and the functions that appear in this thread’s backtrace?\n- What mix of binaries in your app and Apple’s system frameworks are in the backtrace?\n\nEven if the functions in the backtrace aren’t ones you directly call, they contain key clues. For example, this backtrace contains only system frameworks except for the app’s `main` function, but the crash is due to an invalid popover configuration in an iPadOS app:\n\n```other\nLast Exception Backtrace:\n0   CoreFoundation                    0x1a1801190 __exceptionPreprocess + 228\n1   libobjc.A.dylib                   0x1a09d69f8 objc_exception_throw + 55\n2   UIKitCore                         0x1cd5d0af0 -[UIPopoverPresentationController presentationTransitionWillBegin] + 2739\n3   UIKitCore                         0x1cd5d9358 __71-[UIPresentationController _initViewHierarchyForPresentationSuperview:]_block_invoke + 2175\n4   UIKitCore                         0x1cd5d6ea4 __56-[UIPresentationController runTransitionForCurrentState]_block_invoke + 463\n5   UIKitCore                         0x1cdc5c0ac _runAfterCACommitDeferredBlocks + 295\n6   UIKitCore                         0x1cdc4abfc _cleanUpAfterCAFlushAndRunDeferredBlocks + 351\n7   UIKitCore                         0x1cdc77a6c _afterCACommitHandler + 115\n8   CoreFoundation                    0x1a179250c __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 31\n9   CoreFoundation                    0x1a178d234 __CFRunLoopDoObservers + 411\n10  CoreFoundation                    0x1a178d7b0 __CFRunLoopRun + 1227\n11  CoreFoundation                    0x1a178cfc4 CFRunLoopRunSpecific + 435\n12  GraphicsServices                  0x1a398e79c GSEventRunModal + 103\n13  UIKitCore                         0x1cdc50c38 UIApplicationMain + 211\n14  MyGreatApp                        0x10079600c main (in MyGreatApp) (AppDelegate.swift:12)\n15  libdyld.dylib                     0x1a124d8e0 start + 3\n```\n\nFrames 3 and 4 provide a clue that this crash relates to presenting a view controller, and frame 2 is a clue that the app is presenting a popover. This information narrows down what parts of your app’s code to focus on, even when no code from the app is in the backtrace.\n\nYou can frequently determine the purpose of a thread based on the bottom frames in the thread’s backtrace. An app’s main thread has [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSApplicationMain(_:_:)] or [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIApplicationMain(_:_:_:_:)-1yub7] in the bottom frames. Threads created through the [doc:\/\/com.apple.documentation\/documentation\/Dispatch] framework have `start_wqthread` in the bottom frames. As you look closer at the crashed thread’s backtrace, consider whether your app appears in a coherent state that matches your expectations about how your app functions:\n\n- Should the code from the app be running on this specific thread?\n- Is the crashed thread a background thread?\n- Do any of the backtraces show the app manipulating UI elements on any thread except the main thread? Have you tested your app with the `Main Thread Checker` enabled?\n- If your code uses an API that takes a completion handler, does that API guarantee the specific queue the completion handler uses? Is your code expecting that queue?\n- If your code uses an API where you provide a [doc:\/\/com.apple.documentation\/documentation\/Dispatch\/DispatchQueue] to the API, does the crash report show you’re using the queue you expect?\n\nIn addition to the backtrace for the crashed thread or language exception, other thread backtraces provide additional clues about what state the app is in. These clues are subtle:\n\n- Do any of the other threads help indicate what state the app is in? For example, if you see threads with frames from the [doc:\/\/com.apple.documentation\/documentation\/Contacts] framework and you only access contacts in one part of your app, you can focus your investigation on the crash to that part of the app.\n- Do any of the other thread backtraces contain frames related to the frames in the crashed thread’s backtrace? What does that say about the state of the app?\n- Are there many threads that have similar state, such as the same set of functions from your app before frames that are waiting on system resources?\n\nIn some types of crashes, the crashed thread’s backtrace doesn’t consistently contain the source of the issue. [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/addressing-watchdog-terminations] describes situations where this happens for watchdog terminations, and [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-memory-access-crashes] describes this scenario for memory corruption crashes.\n\n### Understand the crashed thread’s registers\n\nAnalysis of most crash reports don’t need to consider the register state. However, if you’re investigating a difficult memory access issue, the registers provide information not found elsewhere in the crash report.\n\n- Is the memory access a memory fetch, or an instruction fetch?\n- Do the program counter, link registers, and stack pointer register contain valid addresses in your program’s address space?\n- If you use `atos` to symbolicate the address in the link register, what function is it? Does that function jump to other code through function pointers? [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report#Symbolicate-the-crash-report-with-the-command-line] describes how to use `atos`.\n\n[doc:\/\/com.apple.Xcode\/documentation\/Xcode\/investigating-memory-access-crashes#Identify-the-type-of-memory-access-that-caused-the-issue] describes how to use these questions to diagnose a memory access crash.\n\n### Verify your frameworks are present in the binary images\n\nUse the Binary Images section of the crash report to take stock of the frameworks your app loads. You can identify the frameworks in your app by the file paths.\n\n- What frameworks had the app loaded at the time of the crash? Are any frameworks provided by your app missing?\n- If a framework is missing, were you expecting the system to automatically load the framework when the app launched, or do you manually load it by calling `dlopen(_:_:)`?\n- How many frameworks are from your app? If you’re investigating a watchdog termination, a high number of frameworks inside your app can consume a significant part of the app’s launch time budget.\n\nFor the meaning of each column in this section, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/examining-the-fields-in-a-crash-report#Binary-images].\n\n## Crash reports\n\n- **Adding identifiable symbol names to a crash report**: Replace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.\n- **Identifying the cause of common crashes**: Find patterns in crash reports that identify common problems, and investigate the issue based on the pattern.\n- **Examining the fields in a crash report**: Understand the structure of a crash report and the information each field contains.\n- **Interpreting the JSON format of a crash report**: Understand the structure and properties of the objects the system includes in the JSON of a crash report.\n- **Understanding the exception types in a crash report**: Learn what the exception type tells you about why your app crashed.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Replace hexadecimal addresses in a crash report with function names and line numbers that correspond to your app’s code.",
          "name" : "Adding identifiable symbol names to a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/adding-identifiable-symbol-names-to-a-crash-report"
        },
        {
          "description" : "Find patterns in crash reports that identify common problems, and investigate the issue based on the pattern.",
          "name" : "Identifying the cause of common crashes",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/identifying-the-cause-of-common-crashes"
        },
        {
          "description" : "Understand the structure of a crash report and the information each field contains.",
          "name" : "Examining the fields in a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/examining-the-fields-in-a-crash-report"
        },
        {
          "description" : "Understand the structure and properties of the objects the system includes in the JSON of a crash report.",
          "name" : "Interpreting the JSON format of a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/interpreting-the-JSON-format-of-a-crash-report"
        },
        {
          "description" : "Learn what the exception type tells you about why your app crashed.",
          "name" : "Understanding the exception types in a crash report",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/understanding-the-exception-types-in-a-crash-report"
        }
      ],
      "title" : "Crash reports"
    }
  ],
  "source" : "appleJSON",
  "title" : "Analyzing a crash report",
  "url" : "https:\/\/developer.apple.com\/documentation\/xcode\/analyzing-a-crash-report"
}