{
  "abstract" : "Identify and fix problematic shaders in your app using the shader debugger.",
  "codeExamples" : [

  ],
  "contentHash" : "25869369ff568622fee17893f89e7239f9b2b38e1c1502734c481c5c2bd46091",
  "crawledAt" : "2025-12-02T19:35:52Z",
  "id" : "C0F060FD-BE00-4E90-9F1C-4F645F5F68FE",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nIf you notice any visual artifacts while running your app, such as missing geometry or invalid pixels, you can use the shader debugger to investigate problematic shaders. Step through your shader source code and inspect variable values until you discover the problem. Then, just edit the shader source and reload the shader to verify your fix.\n\n### Debug your shader\n\nTo begin debugging a shader, select the draw command or compute dispatch of interest in the Debug navigator. Then, click the Shader Debugger button in the debug bar to begin debugging any of the associated shaders for the currently bound pipeline state.\n\n\n\nThe shader debugger opens a dialog that includes a tab for each shader type in use so you can easily select the shader region of interest. For example, if your draw command has a vertex and fragment shader, the dialog includes Vertex and Fragment tabs.\n\nThe Vertex tab shows the geometry of your draw command. You can immediately start debugging your vertex shader by clicking the Debug button on the bottom right because the shader debugger automatically selects the first vertex.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-the-geometry-of-a-draw-command].\n\n\n\nThe dialog includes tabs for Mesh and Object, if applicable, instead of the Vertex tab when a draw command uses a mesh-based pipeline state.\n\nThe Mesh and Object tabs show the geometry of your draw command. You can immediately start debugging your mesh or object shaders by clicking the Debug button on the bottom right because the shader debugger automatically selects the first mesh grid and its first mesh.\n\n\n\nYou can set the threadgroup position that produced a mesh in the thread selector by clicking the Mesh tab and selecting a mesh in the table or the geometry view. You can also set the thread position that produced a vertex in a mesh by choosing Thread Position for Vertex and selecting a vertex in the table or the geometry view. Alternatively, you can set the thread position that produced a primitive or an index in a mesh by choosing Thread Position for Primitive or Index.\n\n\n\nYou can set the threadgroup position that produced a mesh grid in the thread selector by clicking the Object tab and selecting a mesh grid in the table or the geometry view.\n\n\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-the-geometry-of-a-draw-command].\n\nThe Fragment tab shows the first attachment of your draw command, and hides other attachments by default. You can immediately start debugging your fragment shader by clicking the Debug button on the bottom right because the shader debugger automatically selects a pixel within a debuggable region. Alternatively, you can select a different pixel, change the visible attachments, and so on.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-the-attachments-of-a-draw-command].\n\n\n\nIf you select a compute dispatch rather than a draw command, you can immediately start debugging your compute shader by clicking the Debug button on the bottom right because the shader debugger automatically selects the first threadgroup.\n\n\n\nYou can also expand the Functions to Debug option to select a subset of functions within your shader source. Using a subset of functions can dramatically decrease the amount of the shader debugger’s initial processing.\n\n\n\nYou can also select a subset of functions in the Vertex, Mesh, Object, and Fragment tabs by clicking Debug while holding down the Option key.\n\n### Step through your shader code\n\nAfter you click the Debug button, the shader debugger displays the shader source in the Shader editor (see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-shaders]).\nThe call tree on the left shows each executed line in your shader. The values of the variables appear to the right of each shader line of source code in the Shader editor. For example, in the screenshot below, you can see that the `in` variable has a value containing `721.5`, `815.5`, and so on.\n\n\n\nIf your shader is producing incorrect results, you can examine the value of variables on each line until you see an unexpected value that indicates the cause of the problem. Use the call tree to quickly inspect your shader:\n\n\n\nWhen you select a line in the call tree, its corresponding line of source code in the Shader editor to the right appears with a green highlight. This line is also referred to as the *location of the playhead*. Use your keyboard arrow keys in the call tree to advance the playhead through your code one line at a time. As you step through the call tree, the playhead follows along in the source code in the Shader editor.\n\nAlternatively, you can change the playhead location by clicking any line in the Shader editor, and the shader debugger moves to the corresponding function in the call tree.\n\n\n\n### Iterate through loops\n\nUnlike a traditional CPU debugger, the shader debugger shows the value of all variables at the same time, with no need to step to the next line. If you decide not to use the call tree to iterate through loops, you can switch the visible loop iteration directly within the Shader editor. Click the Loop Iteration tab on the right above the loop, just before the variables sidebar. When you select a different iteration, the variables within the sidebar update to reflect their values during that iteration.\n\n\n\n### Inspect variable values\n\nTo inspect the value of a variable, move the pointer over it. For example, in the screenshot below, hovering over `linearSampler` shows the sampler properties in a popover.\n\n\n\nAlternatively, you can toggle the Preview button in the variables sidebar to show the value inline with the source. This is useful if you want to compare the values of multiple variables simultaneously.\n\n\n\nIf a variable has nested properties, you can disclose them in a cascading fashion.\n\n\n\nThis enables you to dive in to an object’s data by showing you more than the Shader editor can fit in the right sidebar.\n\nIn addition to the selected pixel or thread, the shader debugger also shows the variable values for nearby pixels, or other threads within the threadgroup, in what is known as the *region of interest*. When you expand a variable preview, the shader debugger shows the values of variables for all pixels or threads within the region of interest.\n\nUse this rendering to visually check that the variable is the value you expect. For graphical data, the visualization can be easier to verify than numerical data alone. Move the pointer over a pixel or thread to see the variable value for it. Then, you can click the pixel or thread to select it. The Shader editor automatically changes the variables in the variables sidebar to reflect their values during the execution of the shader when using the newly selected pixel or thread.\n\n\n\nIn the preview, the mask shows the pixels or threads within the region of interest that executed the line of code. Consider the example below, where the fragment shader branches depending on the vertex in-position. In the mask, the pixels within the region of interest that passed the condition appear with a white color, and pixels that didn’t pass the condition appear with a black color.\n\n\n\n### Update your shader\n\nAfter changing a shader, you can update the captured frame with the new source code by clicking the Reload Shaders button in the debug bar.\n\n\n\nAfter updating the captured frame, the shader debugger does the following:\n\nIf your shader is producing correct results, but taking a long time to run, consider profiling your Metal workload and inspecting the shader source in the Shader editor. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-shaders].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Xcode\/Debugging-the-shaders-within-a-draw-command-or-compute-dispatch\ncrawled: 2025-12-02T19:35:52Z\n---\n\n# Debugging the shaders within a draw command or compute dispatch\n\n**Article**\n\nIdentify and fix problematic shaders in your app using the shader debugger.\n\n## Overview\n\nIf you notice any visual artifacts while running your app, such as missing geometry or invalid pixels, you can use the shader debugger to investigate problematic shaders. Step through your shader source code and inspect variable values until you discover the problem. Then, just edit the shader source and reload the shader to verify your fix.\n\n\n\n### Debug your shader\n\nTo begin debugging a shader, select the draw command or compute dispatch of interest in the Debug navigator. Then, click the Shader Debugger button in the debug bar to begin debugging any of the associated shaders for the currently bound pipeline state.\n\n\n\nThe shader debugger opens a dialog that includes a tab for each shader type in use so you can easily select the shader region of interest. For example, if your draw command has a vertex and fragment shader, the dialog includes Vertex and Fragment tabs.\n\nThe Vertex tab shows the geometry of your draw command. You can immediately start debugging your vertex shader by clicking the Debug button on the bottom right because the shader debugger automatically selects the first vertex.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-the-geometry-of-a-draw-command].\n\n\n\nThe dialog includes tabs for Mesh and Object, if applicable, instead of the Vertex tab when a draw command uses a mesh-based pipeline state.\n\nThe Mesh and Object tabs show the geometry of your draw command. You can immediately start debugging your mesh or object shaders by clicking the Debug button on the bottom right because the shader debugger automatically selects the first mesh grid and its first mesh.\n\n\n\nYou can set the threadgroup position that produced a mesh in the thread selector by clicking the Mesh tab and selecting a mesh in the table or the geometry view. You can also set the thread position that produced a vertex in a mesh by choosing Thread Position for Vertex and selecting a vertex in the table or the geometry view. Alternatively, you can set the thread position that produced a primitive or an index in a mesh by choosing Thread Position for Primitive or Index.\n\n\n\nYou can set the threadgroup position that produced a mesh grid in the thread selector by clicking the Object tab and selecting a mesh grid in the table or the geometry view.\n\n\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-the-geometry-of-a-draw-command].\n\nThe Fragment tab shows the first attachment of your draw command, and hides other attachments by default. You can immediately start debugging your fragment shader by clicking the Debug button on the bottom right because the shader debugger automatically selects a pixel within a debuggable region. Alternatively, you can select a different pixel, change the visible attachments, and so on.\n\nFor more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-the-attachments-of-a-draw-command].\n\n\n\nIf you select a compute dispatch rather than a draw command, you can immediately start debugging your compute shader by clicking the Debug button on the bottom right because the shader debugger automatically selects the first threadgroup.\n\n\n\nYou can also expand the Functions to Debug option to select a subset of functions within your shader source. Using a subset of functions can dramatically decrease the amount of the shader debugger’s initial processing.\n\n\n\nYou can also select a subset of functions in the Vertex, Mesh, Object, and Fragment tabs by clicking Debug while holding down the Option key.\n\n### Step through your shader code\n\nAfter you click the Debug button, the shader debugger displays the shader source in the Shader editor (see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-shaders]).\nThe call tree on the left shows each executed line in your shader. The values of the variables appear to the right of each shader line of source code in the Shader editor. For example, in the screenshot below, you can see that the `in` variable has a value containing `721.5`, `815.5`, and so on.\n\n\n\nIf your shader is producing incorrect results, you can examine the value of variables on each line until you see an unexpected value that indicates the cause of the problem. Use the call tree to quickly inspect your shader:\n\n\n\nWhen you select a line in the call tree, its corresponding line of source code in the Shader editor to the right appears with a green highlight. This line is also referred to as the *location of the playhead*. Use your keyboard arrow keys in the call tree to advance the playhead through your code one line at a time. As you step through the call tree, the playhead follows along in the source code in the Shader editor.\n\n\n\nAlternatively, you can change the playhead location by clicking any line in the Shader editor, and the shader debugger moves to the corresponding function in the call tree.\n\n\n\n### Iterate through loops\n\nUnlike a traditional CPU debugger, the shader debugger shows the value of all variables at the same time, with no need to step to the next line. If you decide not to use the call tree to iterate through loops, you can switch the visible loop iteration directly within the Shader editor. Click the Loop Iteration tab on the right above the loop, just before the variables sidebar. When you select a different iteration, the variables within the sidebar update to reflect their values during that iteration.\n\n\n\n### Inspect variable values\n\nTo inspect the value of a variable, move the pointer over it. For example, in the screenshot below, hovering over `linearSampler` shows the sampler properties in a popover.\n\n\n\nAlternatively, you can toggle the Preview button in the variables sidebar to show the value inline with the source. This is useful if you want to compare the values of multiple variables simultaneously.\n\n\n\nIf a variable has nested properties, you can disclose them in a cascading fashion.\n\n\n\nThis enables you to dive in to an object’s data by showing you more than the Shader editor can fit in the right sidebar.\n\nIn addition to the selected pixel or thread, the shader debugger also shows the variable values for nearby pixels, or other threads within the threadgroup, in what is known as the *region of interest*. When you expand a variable preview, the shader debugger shows the values of variables for all pixels or threads within the region of interest.\n\n\n\nUse this rendering to visually check that the variable is the value you expect. For graphical data, the visualization can be easier to verify than numerical data alone. Move the pointer over a pixel or thread to see the variable value for it. Then, you can click the pixel or thread to select it. The Shader editor automatically changes the variables in the variables sidebar to reflect their values during the execution of the shader when using the newly selected pixel or thread.\n\n\n\nIn the preview, the mask shows the pixels or threads within the region of interest that executed the line of code. Consider the example below, where the fragment shader branches depending on the vertex in-position. In the mask, the pixels within the region of interest that passed the condition appear with a white color, and pixels that didn’t pass the condition appear with a black color.\n\n\n\n### Update your shader\n\nAfter changing a shader, you can update the captured frame with the new source code by clicking the Reload Shaders button in the debug bar.\n\n\n\nAfter updating the captured frame, the shader debugger does the following:\n\n- Updates variable views to show their new values.\n- Redraws attachments in the assistant editor.\n- Maintains your place in the captured frame, which provides an interactive environment to enhance your shader development and debugging.\n\n\n\nIf your shader is producing correct results, but taking a long time to run, consider profiling your Metal workload and inspecting the shader source in the Shader editor. For more information, see [doc:\/\/com.apple.Xcode\/documentation\/Xcode\/Inspecting-shaders].\n\n## Metal command analysis\n\n- **Inspecting the bound resources for a command**: Discover issues by examining the bound resources at any point in an encoder.\n- **Inspecting the geometry of a draw command**: Find problems in your app’s vertex, object, or mesh function by examining the current geometry.\n- **Inspecting the attachments of a draw command**: Discover attachment issues by inspecting individual pixels and samples.\n- **Analyzing draw command and compute dispatch performance with GPU counters**: Identify issues within your frame capture by examining performance counters.\n- **Analyzing draw command and compute dispatch performance with pipeline statistics**: Identify issues within your frame capture by examining pipeline statistics.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Discover issues by examining the bound resources at any point in an encoder.",
          "name" : "Inspecting the bound resources for a command",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Inspecting-the-bound-resources-for-a-command"
        },
        {
          "description" : "Find problems in your app’s vertex, object, or mesh function by examining the current geometry.",
          "name" : "Inspecting the geometry of a draw command",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Inspecting-the-geometry-of-a-draw-command"
        },
        {
          "description" : "Discover attachment issues by inspecting individual pixels and samples.",
          "name" : "Inspecting the attachments of a draw command",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Inspecting-the-attachments-of-a-draw-command"
        },
        {
          "description" : "Identify issues within your frame capture by examining performance counters.",
          "name" : "Analyzing draw command and compute dispatch performance with GPU counters",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-draw-command-and-compute-dispatch-performance-with-GPU-counters"
        },
        {
          "description" : "Identify issues within your frame capture by examining pipeline statistics.",
          "name" : "Analyzing draw command and compute dispatch performance with pipeline statistics",
          "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Analyzing-draw-command-and-compute-dispatch-performance-with-pipeline-statistics"
        }
      ],
      "title" : "Metal command analysis"
    }
  ],
  "source" : "appleJSON",
  "title" : "Debugging the shaders within a draw command or compute dispatch",
  "url" : "https:\/\/developer.apple.com\/documentation\/Xcode\/Debugging-the-shaders-within-a-draw-command-or-compute-dispatch"
}