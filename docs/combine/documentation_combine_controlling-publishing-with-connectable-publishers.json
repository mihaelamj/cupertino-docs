{
  "abstract" : "Coordinate when publishers start sending elements to subscribers.",
  "codeExamples" : [
    {
      "code" : "let url = URL(string: \"https:\/\/example.com\/\")!\nlet connectable = URLSession.shared\n    .dataTaskPublisher(for: url)\n    .map() { $0.data }\n    .catch() { _ in Just(Data() )}\n    .share()\n    .makeConnectable()\n\ncancellable1 = connectable\n    .sink(receiveCompletion: { print(\"Received completion 1: \\($0).\") },\n          receiveValue: { print(\"Received data 1: \\($0.count) bytes.\") })\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n    self.cancellable2 = connectable\n        .sink(receiveCompletion: { print(\"Received completion 2: \\($0).\") },\n              receiveValue: { print(\"Received data 2: \\($0.count) bytes.\") })\n}\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n    self.connection = connectable.connect()\n}",
      "language" : "swift"
    },
    {
      "code" : "let cancellable = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n    .sink() { date in\n        print (\"Date now: \\(date)\")\n     }",
      "language" : "swift"
    }
  ],
  "contentHash" : "f6fae109b125e36b0a4379db5abece7beca097a9e84ae5252ed9bc415ed7275e",
  "crawledAt" : "2025-12-06T13:58:44Z",
  "id" : "F7EB1926-5DB5-4304-BC01-C046A6AC1C92",
  "kind" : "article",
  "language" : "swift",
  "module" : "Combine",
  "overview" : "## Overview\n\nSometimes, you want to configure a publisher before it starts producing elements, such as when a publisher has properties that affect its behavior. But commonly used subscribers like [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] demand unlimited elements immediately, which might prevent you from setting up the publisher the way you like. A publisher that produces values before you’re ready for them can also be a problem when the publisher has two or more subscribers. This multi-subscriber scenario creates a race condition: the publisher can send elements to the first subscriber before the second even exists.\n\nConsider the scenario in the following figure. You create a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/DataTaskPublisher] and attach a sink subscriber to it (Subscriber 1) which causes the data task to start fetching the URL’s data. At some later point, you attach a second subscriber (Subscriber 2). If the data task completes its download before the second subscriber attaches, the second subscriber misses the data and only sees the completion.\n\n\n\n### Hold Publishing by Using a Connectable Publisher\n\nTo prevent a publisher from sending elements before you’re ready, Combine provides the [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] protocol. A connectable publisher produces no elements until you call its [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] method. Even if it’s ready to produce elements and has unsatisfied demand, a connectable publisher doesn’t deliver any elements to subscribers until you explicitly call [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()].\n\nThe following figure shows the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/DataTaskPublisher] scenario from above, but with a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] ahead of the subscribers. By waiting to call [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] until both subscribers attach, the data task doesn’t start downloading until then. This eliminates the race condition and guarantees both subscribers can receive the data.\n\n\n\nTo use a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] in your own Combine code, use the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/makeConnectable()] operator to wrap an existing publisher with a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publishers\/MakeConnectable] instance. The following code shows how [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/makeConnectable()] fixes the data task publisher race condition described above. Typically, attaching a sink — identified here by the [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyCancellable] it returns, `cancellable1` — would cause the data task to start immediately. In this scenario, the second sink, identified as `cancellable2`, doesn’t attach until one second later, and the data task publisher might complete before the second sink attaches. Instead, explicitly using a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] causes the data task to start only after the app calls [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()], which it does after a two-second delay.\n\n### Use the Autoconnect Operator If You Don’t Need to Explicitly Connect\n\nSome Combine publishers already implement [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher], such as [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publishers\/Multicast] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Timer\/TimerPublisher]. Using these publishers can cause the opposite problem: having to explicitly [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] could be burdensome if you don’t need to configure the publisher or attach multiple subscribers.\n\nFor cases like these, [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] provides the [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/autoconnect()] operator. This operator immediately calls [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] when a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] attaches to the publisher with the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/subscribe(_:)-3fk20] method.\n\nThe following example uses [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/autoconnect()], so a subscriber immediately receives elements from a once-a-second [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Timer\/TimerPublisher]. Without [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/autoconnect()], the example would need to explicitly start the timer publisher by calling [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] at some point.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Combine\/controlling-publishing-with-connectable-publishers\ncrawled: 2025-12-06T13:58:44Z\n---\n\n# Controlling Publishing with Connectable Publishers\n\n**Article**\n\nCoordinate when publishers start sending elements to subscribers.\n\n## Overview\n\nSometimes, you want to configure a publisher before it starts producing elements, such as when a publisher has properties that affect its behavior. But commonly used subscribers like [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] demand unlimited elements immediately, which might prevent you from setting up the publisher the way you like. A publisher that produces values before you’re ready for them can also be a problem when the publisher has two or more subscribers. This multi-subscriber scenario creates a race condition: the publisher can send elements to the first subscriber before the second even exists.\n\nConsider the scenario in the following figure. You create a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/DataTaskPublisher] and attach a sink subscriber to it (Subscriber 1) which causes the data task to start fetching the URL’s data. At some later point, you attach a second subscriber (Subscriber 2). If the data task completes its download before the second subscriber attaches, the second subscriber misses the data and only sees the completion.\n\n\n\n### Hold Publishing by Using a Connectable Publisher\n\nTo prevent a publisher from sending elements before you’re ready, Combine provides the [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] protocol. A connectable publisher produces no elements until you call its [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] method. Even if it’s ready to produce elements and has unsatisfied demand, a connectable publisher doesn’t deliver any elements to subscribers until you explicitly call [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()].\n\nThe following figure shows the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/DataTaskPublisher] scenario from above, but with a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] ahead of the subscribers. By waiting to call [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] until both subscribers attach, the data task doesn’t start downloading until then. This eliminates the race condition and guarantees both subscribers can receive the data.\n\n\n\nTo use a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] in your own Combine code, use the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/makeConnectable()] operator to wrap an existing publisher with a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publishers\/MakeConnectable] instance. The following code shows how [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/makeConnectable()] fixes the data task publisher race condition described above. Typically, attaching a sink — identified here by the [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyCancellable] it returns, `cancellable1` — would cause the data task to start immediately. In this scenario, the second sink, identified as `cancellable2`, doesn’t attach until one second later, and the data task publisher might complete before the second sink attaches. Instead, explicitly using a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] causes the data task to start only after the app calls [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()], which it does after a two-second delay.\n\n```swift\nlet url = URL(string: \"https:\/\/example.com\/\")!\nlet connectable = URLSession.shared\n    .dataTaskPublisher(for: url)\n    .map() { $0.data }\n    .catch() { _ in Just(Data() )}\n    .share()\n    .makeConnectable()\n\ncancellable1 = connectable\n    .sink(receiveCompletion: { print(\"Received completion 1: \\($0).\") },\n          receiveValue: { print(\"Received data 1: \\($0.count) bytes.\") })\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n    self.cancellable2 = connectable\n        .sink(receiveCompletion: { print(\"Received completion 2: \\($0).\") },\n              receiveValue: { print(\"Received data 2: \\($0.count) bytes.\") })\n}\n\nDispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n    self.connection = connectable.connect()\n}\n```\n\n\n\n### Use the Autoconnect Operator If You Don’t Need to Explicitly Connect\n\nSome Combine publishers already implement [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher], such as [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publishers\/Multicast] and [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Timer\/TimerPublisher]. Using these publishers can cause the opposite problem: having to explicitly [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] could be burdensome if you don’t need to configure the publisher or attach multiple subscribers.\n\nFor cases like these, [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] provides the [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/autoconnect()] operator. This operator immediately calls [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] when a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] attaches to the publisher with the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/subscribe(_:)-3fk20] method.\n\nThe following example uses [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/autoconnect()], so a subscriber immediately receives elements from a once-a-second [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Timer\/TimerPublisher]. Without [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/autoconnect()], the example would need to explicitly start the timer publisher by calling [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] at some point.\n\n```swift\nlet cancellable = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n    .sink() { date in\n        print (\"Date now: \\(date)\")\n     }\n```\n\n## Connectable Publishers\n\n- **ConnectablePublisher**: A publisher that provides an explicit means of connecting and canceling publication.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A publisher that provides an explicit means of connecting and canceling publication.",
          "name" : "ConnectablePublisher",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/ConnectablePublisher"
        }
      ],
      "title" : "Connectable Publishers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Controlling Publishing with Connectable Publishers",
  "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/controlling-publishing-with-connectable-publishers"
}