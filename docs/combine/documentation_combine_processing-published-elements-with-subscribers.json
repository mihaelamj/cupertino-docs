{
  "abstract" : "Apply back pressure to precisely control when publishers produce elements.",
  "codeExamples" : [
    {
      "code" : "\/\/ Publisher: Uses a timer to emit the date once per second.\nlet timerPub = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n\n\/\/ Subscriber: Waits 5 seconds after subscription, then requests a\n\/\/ maximum of 3 values.\nclass MySubscriber: Subscriber {\n    typealias Input = Date\n    typealias Failure = Never\n    var subscription: Subscription?\n    \n    func receive(subscription: Subscription) {\n        print(\"published                             received\")\n        self.subscription = subscription\n        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {\n            subscription.request(.max(3))\n        }\n    }\n    \n    func receive(_ input: Date) -> Subscribers.Demand {\n        print(\"\\(input)             \\(Date())\")\n        return Subscribers.Demand.none\n    }\n    \n    func receive(completion: Subscribers.Completion<Never>) {\n        print (\"--done--\")\n    }\n}\n\n\/\/ Subscribe to timerPub.\nlet mySub = MySubscriber()\nprint (\"Subscribing at \\(Date())\")\ntimerPub.subscribe(mySub)",
      "language" : "swift"
    },
    {
      "code" : "Subscribing at 2019-12-09 18:57:06 +0000\npublished                             received\n2019-12-09 18:57:11 +0000             2019-12-09 18:57:11 +0000\n2019-12-09 18:57:12 +0000             2019-12-09 18:57:12 +0000\n2019-12-09 18:57:13 +0000             2019-12-09 18:57:13 +0000",
      "language" : "text"
    }
  ],
  "contentHash" : "9e631efd0f360645acb2e539e2e9a4c5801e83ede9b7f27172d5184726ea14f7",
  "crawledAt" : "2025-12-09T22:26:14Z",
  "id" : "E8EFF427-8E7C-4854-9788-A4D7BD4F0478",
  "kind" : "article",
  "language" : "swift",
  "module" : "Combine",
  "overview" : "## Overview\n\nIn Combine, a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher] produces elements, and a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] acts on the elements it receives. However, a publisher can’t send elements until the subscriber attaches and asks for them. The subscriber also controls the rate at which the publisher delivers elements, by using the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Demand] type to indicate how many elements it can receive. A subscriber can indicate demand in either of two ways:\n\nDemand is additive: If a subscriber has demanded two elements, and then requests `Subscribers.Demand(.max(3))`, the publisher’s unsatisfied demand is now five elements. If the publisher then sends an element, the unsatisfied demand decreases to four. Publishing elements is the only way to reduce unsatisfied demand; subscribers can’t request negative demand.\n\nMany apps just use the operators [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] to create the convenience subscriber types [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Sink] and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Assign], respectively. These two subscribers issue a demand for [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Demand\/unlimited] when they first attach to the publisher. Once a publisher has unlimited demand, there can be no further negotiation of demand between subscriber and publisher.\n\n### Consume Elements as the Publisher Produces Them\n\nWhen a publisher has high or unlimited demand, it could send elements faster than a subscriber can process them. This scenario could lead to elements being dropped, or rapidly increasing memory pressure as elements fill a buffer while they await processing.\n\nThis scenario can occur if you use the convenience subscribers, because they demand an unlimited number of elements. Ensure that the closure you provide to [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] and the side-effects of [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] adhere to the following traits:\n\nFortunately, many commonly used publishers, such as publishers associated with user-interface elements, publish at a manageable rate. Other common publishers only produce a single element, like the URL Loading System’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/DataTaskPublisher]. It’s perfectly safe to use sink and assign subscribers with these publishers.\n\n### Apply Back Pressure with a Custom Subscriber\n\nTo control the rate at which the publisher sends elements to your subscriber, create a custom implementation of the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] protocol. Use your implementation to specify demands that you know your subscriber can keep up with. As the subscriber receives elements, it can request more by returning a new demand value to [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/receive(_:)], or by calling [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscription\/request(_:)] on the subscription. With either, your subscriber can then fine-tune the number of elements the publisher can send it at any given time.\n\nThis concept of controlling flow by signaling a subscriber’s readiness to receive elements is called *back pressure*.\n\nEach publisher keeps track of its current unsatisfied demand, meaning how many more elements a subscriber has requested. Even automated sources like Foundation’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Timer\/TimerPublisher] only produce elements when they have pending demand. The following example code illustrates this behavior.\n\nThe subscriber’s `receive(subscription:)` implementation uses a five-second delay before it requests any elements from the publisher. During this period, the publisher exists and has a valid subscriber, but has zero demand, so it doesn’t produce elements. It only starts publishing elements after the delay expires and the subscriber gives it a nonzero demand, as seen in the following output:\n\nThis example only requests three elements, issuing the demand after the five-second delay expires. As a result, the publisher sends no further elements after the third, but also doesn’t complete publishing by sending a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Completion\/finished] value either, because the publisher is just waiting for more demand. To continue to receive elements, the subscriber could store the subscription and periodically request more elements. It could also indicate new demand as the return value from its [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/receive(_:)] implementation.\n\n### Manage Unlimited Demand by Using Back-Pressure Operators\n\nEven without writing a custom [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber], you can still apply back pressure by using one of Combine’s buffering or timing operators:\n\nBecause these operators control the number of elements your subscriber receives, you can attach a subscriber that requests unlimited elements, such as [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Combine\/processing-published-elements-with-subscribers\ncrawled: 2025-12-09T22:26:14Z\n---\n\n# Processing Published Elements with Subscribers\n\n**Article**\n\nApply back pressure to precisely control when publishers produce elements.\n\n## Overview\n\nIn Combine, a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher] produces elements, and a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] acts on the elements it receives. However, a publisher can’t send elements until the subscriber attaches and asks for them. The subscriber also controls the rate at which the publisher delivers elements, by using the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Demand] type to indicate how many elements it can receive. A subscriber can indicate demand in either of two ways:\n\n- By calling [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscription\/request(_:)] on the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscription] instance that the publisher provided when the subscriber first subscribed.\n- By returning a new demand when the publisher calls the subscriber’s [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/receive(_:)] method to deliver an element.\n\nDemand is additive: If a subscriber has demanded two elements, and then requests `Subscribers.Demand(.max(3))`, the publisher’s unsatisfied demand is now five elements. If the publisher then sends an element, the unsatisfied demand decreases to four. Publishing elements is the only way to reduce unsatisfied demand; subscribers can’t request negative demand.\n\nMany apps just use the operators [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] to create the convenience subscriber types [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Sink] and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Assign], respectively. These two subscribers issue a demand for [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Demand\/unlimited] when they first attach to the publisher. Once a publisher has unlimited demand, there can be no further negotiation of demand between subscriber and publisher.\n\n### Consume Elements as the Publisher Produces Them\n\nWhen a publisher has high or unlimited demand, it could send elements faster than a subscriber can process them. This scenario could lead to elements being dropped, or rapidly increasing memory pressure as elements fill a buffer while they await processing.\n\nThis scenario can occur if you use the convenience subscribers, because they demand an unlimited number of elements. Ensure that the closure you provide to [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] and the side-effects of [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] adhere to the following traits:\n\n- Don’t block the publisher.\n- Don’t consume excessive memory by buffering elements.\n- Don’t get overwhelmed and fail to process elements.\n\nFortunately, many commonly used publishers, such as publishers associated with user-interface elements, publish at a manageable rate. Other common publishers only produce a single element, like the URL Loading System’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession\/DataTaskPublisher]. It’s perfectly safe to use sink and assign subscribers with these publishers.\n\n### Apply Back Pressure with a Custom Subscriber\n\nTo control the rate at which the publisher sends elements to your subscriber, create a custom implementation of the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] protocol. Use your implementation to specify demands that you know your subscriber can keep up with. As the subscriber receives elements, it can request more by returning a new demand value to [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/receive(_:)], or by calling [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscription\/request(_:)] on the subscription. With either, your subscriber can then fine-tune the number of elements the publisher can send it at any given time.\n\nThis concept of controlling flow by signaling a subscriber’s readiness to receive elements is called *back pressure*.\n\nEach publisher keeps track of its current unsatisfied demand, meaning how many more elements a subscriber has requested. Even automated sources like Foundation’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Timer\/TimerPublisher] only produce elements when they have pending demand. The following example code illustrates this behavior.\n\n```swift\n\/\/ Publisher: Uses a timer to emit the date once per second.\nlet timerPub = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n\n\/\/ Subscriber: Waits 5 seconds after subscription, then requests a\n\/\/ maximum of 3 values.\nclass MySubscriber: Subscriber {\n    typealias Input = Date\n    typealias Failure = Never\n    var subscription: Subscription?\n    \n    func receive(subscription: Subscription) {\n        print(\"published                             received\")\n        self.subscription = subscription\n        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {\n            subscription.request(.max(3))\n        }\n    }\n    \n    func receive(_ input: Date) -> Subscribers.Demand {\n        print(\"\\(input)             \\(Date())\")\n        return Subscribers.Demand.none\n    }\n    \n    func receive(completion: Subscribers.Completion<Never>) {\n        print (\"--done--\")\n    }\n}\n\n\/\/ Subscribe to timerPub.\nlet mySub = MySubscriber()\nprint (\"Subscribing at \\(Date())\")\ntimerPub.subscribe(mySub)\n```\n\nThe subscriber’s `receive(subscription:)` implementation uses a five-second delay before it requests any elements from the publisher. During this period, the publisher exists and has a valid subscriber, but has zero demand, so it doesn’t produce elements. It only starts publishing elements after the delay expires and the subscriber gives it a nonzero demand, as seen in the following output:\n\n```text\nSubscribing at 2019-12-09 18:57:06 +0000\npublished                             received\n2019-12-09 18:57:11 +0000             2019-12-09 18:57:11 +0000\n2019-12-09 18:57:12 +0000             2019-12-09 18:57:12 +0000\n2019-12-09 18:57:13 +0000             2019-12-09 18:57:13 +0000\n```\n\nThis example only requests three elements, issuing the demand after the five-second delay expires. As a result, the publisher sends no further elements after the third, but also doesn’t complete publishing by sending a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Completion\/finished] value either, because the publisher is just waiting for more demand. To continue to receive elements, the subscriber could store the subscription and periodically request more elements. It could also indicate new demand as the return value from its [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/receive(_:)] implementation.\n\n### Manage Unlimited Demand by Using Back-Pressure Operators\n\nEven without writing a custom [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber], you can still apply back pressure by using one of Combine’s buffering or timing operators:\n\n- [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/buffer(size:prefetch:whenFull:)] holds onto a fixed number of items from an upstream publisher. When full, the buffer either drops elements or throws an error.\n- [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/debounce(for:scheduler:options:)] publishes only when the upstream publisher stops publishing for a specified interval of time.\n- [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/throttle(for:scheduler:latest:)] produces elements at a given maximum rate. If it receives multiple elements during an interval, it sends only the newest or oldest.\n- [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/collect(_:)] and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/collect(_:options:)] bundle elements until they exceed a given count or time interval, sending you an array of elements. This option is good if your subscriber can process multiple elements at the same time.\n\nBecause these operators control the number of elements your subscriber receives, you can attach a subscriber that requests unlimited elements, such as [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveValue:)] and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)].\n\n## Subscribers\n\n- **Subscriber**: A protocol that declares a type that can receive input from a publisher.\n- **Subscribers**: A namespace for types that serve as subscribers.\n- **AnySubscriber**: A type-erasing subscriber.\n- **Subscription**: A protocol representing the connection of a subscriber to a publisher.\n- **Subscriptions**: A namespace for symbols related to subscriptions.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A protocol that declares a type that can receive input from a publisher.",
          "name" : "Subscriber",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/Subscriber"
        },
        {
          "description" : "A namespace for types that serve as subscribers.",
          "name" : "Subscribers",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/Subscribers"
        },
        {
          "description" : "A type-erasing subscriber.",
          "name" : "AnySubscriber",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/AnySubscriber"
        },
        {
          "description" : "A protocol representing the connection of a subscriber to a publisher.",
          "name" : "Subscription",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/Subscription"
        },
        {
          "description" : "A namespace for symbols related to subscriptions.",
          "name" : "Subscriptions",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/Subscriptions"
        }
      ],
      "title" : "Subscribers"
    }
  ],
  "source" : "appleJSON",
  "title" : "Processing Published Elements with Subscribers",
  "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/processing-published-elements-with-subscribers"
}