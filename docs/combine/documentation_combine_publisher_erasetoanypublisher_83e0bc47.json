{
  "abstract" : "Wraps this publisher with a type eraser.",
  "codeExamples" : [
    {
      "code" : "public class TypeWithSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n}\npublic class TypeWithErasedSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n        .eraseToAnyPublisher()\n}\n\n\/\/ In another module:\nlet nonErased = TypeWithSubject()\nif let subject = nonErased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast nonErased.publisher.\")\n}\nlet erased = TypeWithErasedSubject()\nif let subject = erased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast erased.publisher.\")\n}\n\n\/\/ Prints \"Successfully cast nonErased.publisher.\"",
      "language" : "swift"
    }
  ],
  "contentHash" : "aded6340098d7e834310b2fc08e67e9b486b6f0a47ad876a35552502d7fbb79c",
  "crawledAt" : "2025-12-05T02:45:26Z",
  "declaration" : {
    "code" : "func eraseToAnyPublisher() -> AnyPublisher<Self.Output, Self.Failure>",
    "language" : "swift"
  },
  "id" : "E3F01F7D-2329-4F2C-A254-C4EC19EB3F0E",
  "kind" : "method",
  "language" : "swift",
  "module" : "Combine",
  "overview" : "## Return Value\n\nAn [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher] wrapping this publisher.\n\n## Discussion\n\nUse [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/eraseToAnyPublisher()] to expose an instance of [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher] to the downstream subscriber, rather than this publisher’s actual type. This form of *type erasure* preserves abstraction across API boundaries, such as different modules. When you expose your publishers as the [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher] type, you can change the underlying implementation over time without affecting existing clients.\n\nThe following example shows two types that each have a `publisher` property. `TypeWithSubject` exposes this property as its actual type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/PassthroughSubject], while `TypeWithErasedSubject` uses [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/eraseToAnyPublisher()] to expose it as an [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher]. As seen in the output, a caller from another module can access `TypeWithSubject.publisher` as its native type. This means you can’t change your publisher to a different type without breaking the caller. By comparison, `TypeWithErasedSubject.publisher` appears to callers as an [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher], so you can change the underlying publisher type at will.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Combine\/Publisher\/eraseToAnyPublisher()\ncrawled: 2025-12-05T02:45:26Z\n---\n\n# eraseToAnyPublisher()\n\n**Instance Method**\n\nWraps this publisher with a type eraser.\n\n## Declaration\n\n```swift\nfunc eraseToAnyPublisher() -> AnyPublisher<Self.Output, Self.Failure>\n```\n\n## Return Value\n\nAn [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher] wrapping this publisher.\n\n## Discussion\n\nUse [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/eraseToAnyPublisher()] to expose an instance of [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher] to the downstream subscriber, rather than this publisher’s actual type. This form of *type erasure* preserves abstraction across API boundaries, such as different modules. When you expose your publishers as the [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher] type, you can change the underlying implementation over time without affecting existing clients.\n\nThe following example shows two types that each have a `publisher` property. `TypeWithSubject` exposes this property as its actual type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/PassthroughSubject], while `TypeWithErasedSubject` uses [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/eraseToAnyPublisher()] to expose it as an [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher]. As seen in the output, a caller from another module can access `TypeWithSubject.publisher` as its native type. This means you can’t change your publisher to a different type without breaking the caller. By comparison, `TypeWithErasedSubject.publisher` appears to callers as an [doc:\/\/com.apple.Combine\/documentation\/Combine\/AnyPublisher], so you can change the underlying publisher type at will.\n\n```swift\npublic class TypeWithSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n}\npublic class TypeWithErasedSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n        .eraseToAnyPublisher()\n}\n\n\/\/ In another module:\nlet nonErased = TypeWithSubject()\nif let subject = nonErased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast nonErased.publisher.\")\n}\nlet erased = TypeWithErasedSubject()\nif let subject = erased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast erased.publisher.\")\n}\n\n\/\/ Prints \"Successfully cast nonErased.publisher.\"\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "eraseToAnyPublisher()",
  "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/Publisher\/eraseToAnyPublisher()"
}