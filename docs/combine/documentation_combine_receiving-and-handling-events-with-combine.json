{
  "abstract" : "Customize and receive events from asynchronous sources.",
  "codeExamples" : [
    {
      "code" : "let pub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)",
      "language" : "swift"
    },
    {
      "code" : "let sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .sink(receiveCompletion: { print ($0) },\n          receiveValue: { print ($0) })",
      "language" : "swift"
    },
    {
      "code" : "let sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .map( { ($0.object as! NSTextField).stringValue } )\n    .sink(receiveCompletion: { print ($0) },\n          receiveValue: { print ($0) })",
      "language" : "swift"
    },
    {
      "code" : "let sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .map( { ($0.object as! NSTextField).stringValue } )\n    .assign(to: \\MyViewModel.filterString, on: myViewModel)",
      "language" : "swift"
    },
    {
      "code" : "let sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .map( { ($0.object as! NSTextField).stringValue } )\n    .filter( { $0.unicodeScalars.allSatisfy({CharacterSet.alphanumerics.contains($0)}) } )\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .receive(on: RunLoop.main)\n    .assign(to:\\MyViewModel.filterString, on: myViewModel)",
      "language" : "swift"
    },
    {
      "code" : "sub?.cancel()",
      "language" : "swift"
    }
  ],
  "contentHash" : "5f37db54eebd96de006497cc7e2054a5c8cf290b573261f56386811c29d8427d",
  "crawledAt" : "2025-12-09T22:20:25Z",
  "id" : "5B82D21C-64B3-4C83-A8A4-EEE5BCDF5BA5",
  "kind" : "article",
  "language" : "swift",
  "module" : "Combine",
  "overview" : "## Overview\n\nThe Combine framework provides a declarative approach for how your app processes events. Rather than potentially implementing multiple delegate callbacks or completion handler closures, you can create a single processing chain for a given event source. Each part of the chain is a Combine operator that performs a distinct action on the elements received from the previous step.\n\nConsider an app that needs to filter a table or collection view based on the contents of a text field. In AppKit, each keystroke in the text field produces a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Notification] that you can subscribe to with Combine. After receiving the notification, you can use operators to change the content and timing of event delivery, and use the final result to update your app’s user interface.\n\n### Connect a Publisher to a Subscriber\n\nTo receive the text field’s notifications with Combine, access the default instance of [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter] and call its [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter\/publisher(for:object:)] method. This call takes the notification name and source object that you want notifications from, and returns a publisher that produces notification elements.\n\nYou use a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] to receive elements from the publisher. The subscriber defines an associated type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/Input], to declare the type that it receives. The publisher also defines a type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Output], to declare what it produces. The publisher and subscriber both define a type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Failure], to indicate the kind of error they produce or receive. To connect a subscriber to a producer, the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Output] must match the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/Input], and the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Failure] types must also match.\n\nCombine provides two built-in subscribers, which automatically match the output and failure types of their attached publisher:\n\nFor example, you can use the sink subscriber to log when the publisher completes, and each time it receives an element:\n\nBoth the `sink(receiveCompletion:receiveValue:)` and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] subscribers request an unlimited number of elements from their publishers. To control the rate at which you receive elements, create your own subscriber by implementing the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] protocol.\n\n### Change the Output Type with Operators\n\nThe sink subscriber in the previous section performs all its work in the `receiveValue` closure. This could be burdensome if it needs to perform a lot of custom work with received elements or maintain state between invocations. The advantage of Combine comes from combining operators to customize event delivery.\n\nFor example, the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter\/Publisher] provided by Foundation’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter] uses [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Notification] as its [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Output] type. This isn’t a convenient type to receive in the callback if what you need is the text field’s string value.\n\nSince a publisher’s output is essentially a sequence of elements over time, Combine offers sequence-modifying operators like [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/map(_:)-99evh], [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/flatMap(maxPublishers:_:)-3k7z5], and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/reduce(_:_:)]. The behavior of these operators is similar to their equivalents in the Swift standard library. To change the output type of the publisher, you add a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/map(_:)-99evh] operator whose closure returns a different type. In this case, you can get the notification’s object as an [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSTextField], and then get the field’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSControl\/stringValue].\n\nAfter the publisher chain produces the type you want, replace `sink(receiveCompletion:receiveValue:)` with [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)]. The following example takes the strings it receives from the publisher chain and assigns them to the `filterString` of a custom view model object:\n\n### Customize Publishers with Operators\n\nYou can extend the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher] instance with an operator that performs actions that you’d otherwise need to code manually. Here are three ways you could use operators to improve this event-processing chain:\n\nThe resulting publisher declaration follows:\n\n### Cancel Publishing when Desired\n\nA publisher continues to emit elements until it completes normally or fails. If you no longer want to subscribe to the publisher, you can cancel the subscription. The subscriber types created by `sink(receiveCompletion:receiveValue:)` and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] both implement the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable] protocol, which provides a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable\/cancel()] method:\n\nIf you create a custom [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber], the publisher sends a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscription] object when you first subscribe to it. Store this subscription, and then call its [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable\/cancel()] method when you want to cancel publishing. When you create a custom subscriber, you should implement the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable] protocol, and have your [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable\/cancel()] implementation forward the call to the stored subscription.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/combine\/receiving-and-handling-events-with-combine\ncrawled: 2025-12-09T22:20:25Z\n---\n\n# Receiving and Handling Events with Combine\n\n**Article**\n\nCustomize and receive events from asynchronous sources.\n\n## Overview\n\nThe Combine framework provides a declarative approach for how your app processes events. Rather than potentially implementing multiple delegate callbacks or completion handler closures, you can create a single processing chain for a given event source. Each part of the chain is a Combine operator that performs a distinct action on the elements received from the previous step.\n\nConsider an app that needs to filter a table or collection view based on the contents of a text field. In AppKit, each keystroke in the text field produces a [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Notification] that you can subscribe to with Combine. After receiving the notification, you can use operators to change the content and timing of event delivery, and use the final result to update your app’s user interface.\n\n### Connect a Publisher to a Subscriber\n\nTo receive the text field’s notifications with Combine, access the default instance of [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter] and call its [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter\/publisher(for:object:)] method. This call takes the notification name and source object that you want notifications from, and returns a publisher that produces notification elements.\n\n```swift\nlet pub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n```\n\nYou use a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] to receive elements from the publisher. The subscriber defines an associated type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/Input], to declare the type that it receives. The publisher also defines a type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Output], to declare what it produces. The publisher and subscriber both define a type, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Failure], to indicate the kind of error they produce or receive. To connect a subscriber to a producer, the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Output] must match the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber\/Input], and the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Failure] types must also match.\n\nCombine provides two built-in subscribers, which automatically match the output and failure types of their attached publisher:\n\n- [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/sink(receiveCompletion:receiveValue:)] takes two closures. The first closure executes when it receives [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscribers\/Completion], which is an enumeration that indicates whether the publisher finished normally or failed with an error. The second closure executes when it receives an element from the publisher.\n- [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] immediately assigns every element it receives to a property of a given object, using a key path to indicate the property.\n\nFor example, you can use the sink subscriber to log when the publisher completes, and each time it receives an element:\n\n```swift\nlet sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .sink(receiveCompletion: { print ($0) },\n          receiveValue: { print ($0) })\n```\n\nBoth the `sink(receiveCompletion:receiveValue:)` and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] subscribers request an unlimited number of elements from their publishers. To control the rate at which you receive elements, create your own subscriber by implementing the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber] protocol.\n\n### Change the Output Type with Operators\n\nThe sink subscriber in the previous section performs all its work in the `receiveValue` closure. This could be burdensome if it needs to perform a lot of custom work with received elements or maintain state between invocations. The advantage of Combine comes from combining operators to customize event delivery.\n\nFor example, the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter\/Publisher] provided by Foundation’s [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter] uses [doc:\/\/com.apple.documentation\/documentation\/Foundation\/Notification] as its [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/Output] type. This isn’t a convenient type to receive in the callback if what you need is the text field’s string value.\n\nSince a publisher’s output is essentially a sequence of elements over time, Combine offers sequence-modifying operators like [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/map(_:)-99evh], [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/flatMap(maxPublishers:_:)-3k7z5], and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/reduce(_:_:)]. The behavior of these operators is similar to their equivalents in the Swift standard library. To change the output type of the publisher, you add a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/map(_:)-99evh] operator whose closure returns a different type. In this case, you can get the notification’s object as an [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSTextField], and then get the field’s [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSControl\/stringValue].\n\n```swift\nlet sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .map( { ($0.object as! NSTextField).stringValue } )\n    .sink(receiveCompletion: { print ($0) },\n          receiveValue: { print ($0) })\n```\n\nAfter the publisher chain produces the type you want, replace `sink(receiveCompletion:receiveValue:)` with [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)]. The following example takes the strings it receives from the publisher chain and assigns them to the `filterString` of a custom view model object:\n\n```swift\nlet sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .map( { ($0.object as! NSTextField).stringValue } )\n    .assign(to: \\MyViewModel.filterString, on: myViewModel)\n```\n\n### Customize Publishers with Operators\n\nYou can extend the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher] instance with an operator that performs actions that you’d otherwise need to code manually. Here are three ways you could use operators to improve this event-processing chain:\n\n- Rather than updating the view model with any string typed into the text field, you could use the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/filter(_:)] operator to ignore input under a certain length or to reject non-alphanumeric characters.\n- If the filtering operation is expensive — for example, if it’s querying a large database — you might want to wait for the user to stop typing. For this, the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/debounce(for:scheduler:options:)] operator lets you set a minimum period of time that must elapse before a publisher emits an event. The [doc:\/\/com.apple.documentation\/documentation\/Foundation\/RunLoop] class provides conveniences for specifying the time delay in seconds or milliseconds.\n- If the results update the UI, you can deliver callbacks to the main thread by calling the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/receive(on:options:)] method. By specifying the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Scheduler] instance provided by the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/RunLoop] class as the first parameter, you tell Combine to call your subscriber on the main run loop.\n\nThe resulting publisher declaration follows:\n\n```swift\nlet sub = NotificationCenter.default\n    .publisher(for: NSControl.textDidChangeNotification, object: filterField)\n    .map( { ($0.object as! NSTextField).stringValue } )\n    .filter( { $0.unicodeScalars.allSatisfy({CharacterSet.alphanumerics.contains($0)}) } )\n    .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n    .receive(on: RunLoop.main)\n    .assign(to:\\MyViewModel.filterString, on: myViewModel)\n```\n\n### Cancel Publishing when Desired\n\nA publisher continues to emit elements until it completes normally or fails. If you no longer want to subscribe to the publisher, you can cancel the subscription. The subscriber types created by `sink(receiveCompletion:receiveValue:)` and [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/assign(to:on:)] both implement the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable] protocol, which provides a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable\/cancel()] method:\n\n```swift\nsub?.cancel()\n```\n\nIf you create a custom [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscriber], the publisher sends a [doc:\/\/com.apple.Combine\/documentation\/Combine\/Subscription] object when you first subscribe to it. Store this subscription, and then call its [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable\/cancel()] method when you want to cancel publishing. When you create a custom subscriber, you should implement the [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable] protocol, and have your [doc:\/\/com.apple.Combine\/documentation\/Combine\/Cancellable\/cancel()] implementation forward the call to the stored subscription.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Receiving and Handling Events with Combine",
  "url" : "https:\/\/developer.apple.com\/documentation\/combine\/receiving-and-handling-events-with-combine"
}