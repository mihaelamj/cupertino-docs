{
  "abstract" : "Creates a connectable wrapper around the publisher.",
  "codeExamples" : [
    {
      "code" : " let subject = Just<String>(\"Sent\")\n let pub = subject\n     .share()\n     .makeConnectable()\n cancellable1 = pub.sink { print (\"Stream 1 received: \\($0)\")  }\n\n \/\/ For example purposes, use DispatchQueue to add a second subscriber\n \/\/ a second later, and then connect to the publisher a second after that.\n DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n     self.cancellable2 = pub.sink { print (\"Stream 2 received: \\($0)\") }\n }\n DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n     self.connectable = pub.connect()\n }\n \/\/ Prints:\n \/\/ Stream 2 received: Sent\n \/\/ Stream 1 received: Sent",
      "language" : "swift"
    }
  ],
  "contentHash" : "b956a1ff7b19fb81fe87882852d5192c41aa3f8f165cdd1cc6555e1c03eb957c",
  "crawledAt" : "2025-12-05T02:45:29Z",
  "declaration" : {
    "code" : "func makeConnectable() -> Publishers.MakeConnectable<Self>",
    "language" : "swift"
  },
  "id" : "BCC21159-A705-42BB-8CEB-2D058D632DF0",
  "kind" : "method",
  "language" : "swift",
  "module" : "Combine",
  "overview" : "## Return Value\n\nA [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] wrapping this publisher.\n\n## Discussion\n\nIn the following example, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/makeConnectable()] wraps its upstream publisher (an instance of [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publishers\/Share]) with a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher]. Without this, the first sink subscriber would receive all the elements from the sequence publisher and cause it to complete before the second subscriber attaches. By making the publisher connectable, the publisher doesn’t produce any elements until after the [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] call.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Combine\/Publisher\/makeConnectable()\ncrawled: 2025-12-05T02:45:29Z\n---\n\n# makeConnectable()\n\n**Instance Method**\n\nCreates a connectable wrapper around the publisher.\n\n## Declaration\n\n```swift\nfunc makeConnectable() -> Publishers.MakeConnectable<Self>\n```\n\n## Return Value\n\nA [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher] wrapping this publisher.\n\n## Discussion\n\nIn the following example, [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publisher\/makeConnectable()] wraps its upstream publisher (an instance of [doc:\/\/com.apple.Combine\/documentation\/Combine\/Publishers\/Share]) with a [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher]. Without this, the first sink subscriber would receive all the elements from the sequence publisher and cause it to complete before the second subscriber attaches. By making the publisher connectable, the publisher doesn’t produce any elements until after the [doc:\/\/com.apple.Combine\/documentation\/Combine\/ConnectablePublisher\/connect()] call.\n\n```swift\n let subject = Just<String>(\"Sent\")\n let pub = subject\n     .share()\n     .makeConnectable()\n cancellable1 = pub.sink { print (\"Stream 1 received: \\($0)\")  }\n\n \/\/ For example purposes, use DispatchQueue to add a second subscriber\n \/\/ a second later, and then connect to the publisher a second after that.\n DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n     self.cancellable2 = pub.sink { print (\"Stream 2 received: \\($0)\") }\n }\n DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n     self.connectable = pub.connect()\n }\n \/\/ Prints:\n \/\/ Stream 2 received: Sent\n \/\/ Stream 1 received: Sent\n```\n\n\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "makeConnectable()",
  "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/Publisher\/makeConnectable()"
}