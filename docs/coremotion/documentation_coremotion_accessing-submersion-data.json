{
  "abstract" : "Use a water-submersion manager to receive water pressure, temperature, and depth data on Apple Watch Ultra.",
  "codeExamples" : [
    {
      "code" : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>WKBackgroundModes<\/key>\n    <array>\n        <string>underwater-depth<\/string>\n    <\/array>\n<\/dict>\n<\/plist>\n",
      "language" : "xml"
    },
    {
      "code" : "guard CMWaterSubmersionManager.waterSubmersionAvailable else {\n    return false\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Instantiate the submersion manager.\nsubmersionManager = CMWaterSubmersionManager()\n\n\/\/ Assign the submersion manager delegate.\nsubmersionManager.delegate = self",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Respond to events.\nnonisolated func manager(_ manager: CMWaterSubmersionManager, didUpdate event: CMWaterSubmersionEvent) {\n\n    let submerged: Bool?\n    switch event.state {\n    case .unknown:\n        logger.info(\"*** Received an unknown event. ***\")\n        submerged = nil\n\n    case .notSubmerged:\n        logger.info(\"*** Not Submerged Event ***\")\n        submerged = false\n\n    case .submerged:\n        logger.info(\"*** Submerged Event ***\")\n        submerged = true\n\n    @unknown default:\n        fatalError(\"*** Unknown event received: \\(event.state) ***\")\n    }\n\n    Task {\n        await myAdd(event: event)\n        if let submerged {\n            await mySet(submerged: submerged)\n        }\n    }\n}\n\n\/\/ Respond to errors.\nnonisolated func manager(_ manager: CMWaterSubmersionManager, errorOccurred error: Error) {\n    logger.error(\"*** An error occurred: \\(error.localizedDescription) ***\")\n}\n",
      "language" : "swift"
    },
    {
      "code" : "nonisolated func manager(_ manager: CMWaterSubmersionManager, didUpdate measurement: CMWaterSubmersionMeasurement) {\n\n    logger.info(\"*** Received a depth measurement. ***\")\n\n    let currentDepth: String\n    if let depth = measurement.depth {\n        currentDepth = \"\\(depth.value) \\(depth.unit)\"\n    } else {\n        currentDepth = \"None\"\n    }\n\n    let currentSurfacePressure: String\n    let surfacePressure = measurement.surfacePressure\n    currentSurfacePressure = \"\\(surfacePressure.value) \\(surfacePressure.unit)\"\n\n    let currentPressure: String\n    if let pressure = measurement.pressure {\n        currentPressure = \"\\(pressure.value) \\(pressure.unit)\"\n    } else {\n        currentPressure = \"None\"\n    }\n\n    logger.info(\"*** Depth: \\(currentDepth) ***\")\n    logger.info(\"*** Surface Pressure: \\(currentSurfacePressure) ***\")\n    logger.info(\"*** Pressure: \\(currentPressure) ***\")\n\n    let submerged: Bool?\n    switch measurement.submersionState {\n    case .unknown:\n        logger.info(\"*** Unknown Depth ***\")\n        submerged = nil\n    case .notSubmerged:\n        logger.info(\"*** Not Submerged ***\")\n        submerged = false\n    case .submergedShallow:\n        logger.info(\"*** Shallow Depth ***\")\n        submerged = true\n    case .submergedDeep:\n        logger.info(\"*** Deep Depth ***\")\n        submerged = true\n    case .approachingMaxDepth:\n        logger.info(\"*** Approaching Max Depth ***\")\n        submerged = true\n    case .pastMaxDepth:\n        logger.info(\"*** Past Max Depth ***\")\n        submerged = true\n    case .sensorDepthError:\n        logger.info(\"*** A depth error has occurred. ***\")\n        submerged = nil\n    @unknown default:\n        fatalError(\"*** An unknown measurement depth state: \\(measurement.submersionState)\")\n    }\n\n    Task {\n        await myAdd(measurement: measurement)\n        if let submerged {\n            await mySet(submerged: submerged)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "nonisolated func manager(_ manager: CMWaterSubmersionManager, didUpdate measurement: CMWaterTemperature) {\n    let temp = measurement.temperature\n    let uncertainty = measurement.temperatureUncertainty\n    let currentTemperature = \"\\(temp.value) +\/- \\(uncertainty.value) \\(temp.unit)\"\n\n    logger.info((\"*** \\(currentTemperature) ***\"))\n\n    Task {\n        await myAdd(temperature:measurement)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func myStartDiveSession() {\n    logger.info(\"*** Starting a dive session. ***\")\n\n    \/\/ Create the extended runtime session.\n    let session = WKExtendedRuntimeSession()\n\n    \/\/ Assign a delegate to the session.\n    session.delegate = self\n\n    \/\/ Start the session.\n    session.start()\n\n    self.extendedRuntimeSession = session\n    diveSessionRunning = true\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyPickerView: View {\n\n    enum Action: String, CaseIterable, Identifiable {\n        case none, action1, action2, action3\n        var id: Self { self }\n    }\n\n    @State var selection: Action = .none\n\n    var body: some View {\n        Text(selection.rawValue)\n        Picker(\"Action\", selection: $selection) {\n            ForEach(Action.allCases) { action in\n                Text(action.rawValue.capitalized)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct DigitalCrown: View {\n    @State private var crownValue = 0.0\n\n    var body: some View {\n        Text(\"\\(crownValue)\")\n            .focusable()\n            .digitalCrownRotation($crownValue,\n                                  from: 1,\n                                  through: 10,\n                                  by: 1.0,\n                                  sensitivity: .low,\n                                  isHapticFeedbackEnabled: true)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Create an intent to launch your app and set up the dive manager.\nstruct MyStartDiveSessionIntent: StartDiveIntent {\n\n    static var title: LocalizedStringResource = \"Starting a dive session.\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Starting a dive session. ***\")\n\n        await MyDiveManager.shared.start()\n        return .result(actionButtonIntent: MyBeginDescent())\n    }\n}\n\n\/\/ Create an intent that defines the Action button's next action.\nstruct MyBeginDescent: AppIntent {\n\n    static var title: LocalizedStringResource = \"Start Your Descent\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Starting the descent. ***\")\n        await MyDiveManager.shared.beginDescent()\n        return .result()\n    }\n}\n",
      "language" : "swift"
    },
    {
      "code" : "func handle(_ extendedRuntimeSession: WKExtendedRuntimeSession) {\n    \/\/ The system starts a session because the wearer is more than\n    \/\/ 1 meter underwater without an active extended runtime session.\n\n    let submersionSession = MySubmersionSession.shared\n\n    \/\/ Assign a delegate to the session.\n    extendedRuntimeSession.delegate = submersionSession\n\n    submersionSession.extendedRuntimeSession = extendedRuntimeSession\n    submersionSession.diveSessionRunning = true\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "f78041cab666f9952a204f4b1c0e655cb68a1c180f7d9458ec84edba57e3382b",
  "crawledAt" : "2025-12-06T08:07:59Z",
  "id" : "F4ECE45E-453D-4BF9-8BB0-DA7D7A1FDA96",
  "kind" : "article",
  "language" : "swift",
  "module" : "Core Motion",
  "overview" : "## Overview\n\nApple Watch Ultra can collect water pressure, depth, and temperature data while submerged; however, before your app can access this data, you need to perform the following setup steps:\n\nTo start monitoring submersion data, instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] and assign a delegate to the submersion manager. The system begins sending updates to your delegate. You can then start an extended runtime session when the watch first submerges, and transition your app to a touchless user interface for the duration of the dive.\n\n### Add the required entitlement\n\nBefore you can instantiate the [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] class, your app needs to include a Submerged Depth and Pressure entitlement to access submersion data.\n\nTo access data for dives with a maximum depth of 6 meters, add the Shallow Depth and Pressure capability to your app. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/adding-capabilities-to-your-app].\n\nTo enable a maximum depth of 40 meters, you need to apply for the full Submersion Depth and Pressure entitlement. For more information, see [https:\/\/developer.apple.com\/contact\/request\/submerged-depth-pressure-api-development\/]\n\nIf you instantiate the manager without an entitlement, the system calls your delegate’s [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManagerDelegate\/manager(_:errorOccurred:)] method, passing a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMErrorNotEntitled] error, and your delegate doesn’t receive any additional data.\n\n### Authorize access to motion data\n\nThe system automatically asks the wearer for authorization to access motion data when you first instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager]; however, before you can instantiate the manager, you need to include the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSMotionUsageDescription] key in your app target’s information property list and provide a usage description string.\n\n\n\nThe system displays this usage description when it prompts the wearer for authorization to access motion data. If you don’t include a usage description string, your app crashes when you try to instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] object.\n\n### Add support for the underwater depth extended runtime session\n\nTo make sure your app continues to run, and remains visible, you need to add the `underwater-depth` Background Mode to your app’s `Info.plist` file. This background mode lets your app run as the frontmost app during a dive session.\n\nOpen the `Info.plist` file as XML by Control-clicking it in the Project navigator and selecting Open As > Source Code. Next, edit the string value for the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/WKBackgroundModes] key so that it contains the `underwater-depth` value.\n\nIf your app doesn’t already have an `Info.plist` file, you can add a placeholder, and then edit it using the following steps:\n\nAdding the `underwater-depth` Background Mode capability to your `Info.plist` file lets your app run an extended runtime session so that it can remain the frontmost app for the duration of the dive session. It also adds your app to the list of apps that the system can autolaunch when the wearer submerges the watch.\n\nUnlike most extended runtime sessions, your app doesn’t need to start an extended runtime session to gain additional time as the frontmost app. Just by adding this key, the system automatically keeps your app as the frontmost app for 30 minutes after the wearer launches it. This gives the wearer time to prepare for the dive before submerging. Then, after you start an extended runtime session, your app remains the frontmost app for the duration of the dive. The session doesn’t time out until the watch spends more than 10 minutes unsubmerged or the wearer turns off Water Lock.\n\nIf you don’t explicitly start an extended runtime session, the system automatically starts a runtime session when the wearer dives below 1 meter, and your app transitions to the [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionMeasurement\/DepthState\/submergedDeep] state.\n\n### Verify that the submersion data is available on the current device.\n\nBefore creating a submersion manager, verify that the data is available on the current device.\n\nOn Apple Watch Ultra, the system sets [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager\/waterSubmersionAvailable] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. On all other devices and in Simulator, the system sets it to [doc:\/\/com.apple.documentation\/documentation\/Swift\/false].\n\n### Start monitoring submersion data\n\nTo begin receiving submersion data, instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] object and assign a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManagerDelegate].\n\nYour delegate begins to receive data as soon as you assign it. For example, your delegate receives both event notifications and errors.\n\nYour delegate also begins receiving measurement updates. If the watch isn’t submerged, the updates only include surface pressure and submersion state data. After submersion, it also receives water pressure and depth data. The system sends measurement updates three times a second while the watch is submerged. When the watch is on the surface, the system provides updates at a slower rate, and may stop providing updates if the watch isn’t moving.\n\nThe watch also receives water temperature data when it’s submerged.\n\nThe water temperature readings can take some time to converge on the correct value. The system estimates how long it takes to converge to the correct results, and calculates an uncertainty value based on the expected convergence.\n\n### Start a dive session\n\nYou can start an extended runtime session as the wearer begins their dive.\n\nThis session continues to run until:\n\nFor more information, see [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/using-extended-runtime-sessions].\n\n### Transition to a touchless user interface\n\nStarting an extended runtime session automatically enables Water Lock on the watch. As a result, the system disables the watch’s touchscreen for the duration of the dive. If you want the wearer to interact with your app during the dive, you need to enable interaction using either the Digital Crown or the Action button.\n\nMany views, like [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/List], [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ScrollView], and [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Picker], automatically respond to the Digital Crown. The wearer can interact with these elements without needing any changes to the user interface.\n\nYou can also use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/digitalCrownRotation(_:)] view modifier to respond directly when the wearer rotates the Digital Crown.\n\nFor the Action button, implement a [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/StartDiveIntent] to launch your app and prepare for a new dive when the wearer first presses the Action button. You can then donate an [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppIntent] for the Action button’s next action. If the wearer presses the Action button any other time during the session, it triggers the next action. Your app can have only one next action at a time, and donating a new intent changes the next action — letting you customize the next action based on your app’s current state.\n\nFor more information, see [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/ActionButtonArticle].\n\n### Handle automatic dive sessions\n\nIf you don’t explicitly start an extended runtime session, the system automatically starts a session when the wearer descends below 1 meter. It then passes the session to your app delegate’s [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/handle(_:)-7kiwx] method. To use this session, add a delegate and save it to a variable that remains in scope for the entire dive’s duration.\n\n### Respond to autolaunch\n\nOn Apple Watch Ultra, the wearer can tell the system to launch an app when the watch becomes submerged. To enable this feature, they choose Settings > General > Auto-Launch and select the Auto-Launch App setting from the When Submerged group. They can also select which app the system launches.\n\nThe system adds your app to the list of autolaunchable apps as soon as you add the `underwater-depth` Background Mode capability to your app’s `Info.plist` file. This means your app needs to respond appropriately if the wearer sets it as the autolaunch app, and jumps into the water without otherwise interacting with your app.\n\nFor example, you can set up your app’s [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] when your app launches. This ensures that your app is always ready to receive submersion data. Then, when the wearer descends below 1 meter, you can use your [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/handle(_:)-7kiwx] method to grab the automatically generated extended runtime session. Alternatively, if you prefer to explicitly start your own extended runtime session, you can start the session when your app receives a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionEvent\/State-swift.enum\/submerged] event.\n\n### Test submersion data\n\nAlways test submersion data on Apple Watch Ultra. You can’t instantiate the submersion manager in Simulator. To trigger a submersion event, you need to submerge Apple Watch Ultra in a tank of water at least 1 foot deep. When testing in a pressurized container, make sure the watch is completely submerged in water.\n\nIf the water isn’t deep enough to trigger a submersion event, you can enable Easy Submersion mode using a paired iPhone. Connect the phone to your Mac and in Xcode 14.2 or later, select Debug > Induce Device Conditions > Easy Submersion > Enable Easy Submersion.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreMotion\/accessing-submersion-data\ncrawled: 2025-12-06T08:07:59Z\n---\n\n# Accessing submersion data\n\n**Article**\n\nUse a water-submersion manager to receive water pressure, temperature, and depth data on Apple Watch Ultra.\n\n## Overview\n\nApple Watch Ultra can collect water pressure, depth, and temperature data while submerged; however, before your app can access this data, you need to perform the following setup steps:\n\n- Include an Apple-supplied entitlement that grants access to the submersion data.\n- Provide an information property list key that describes why the app needs access to submersion data.\n- Add the `underwater-depth` Background Mode capability to the app.\n- Verify that the submersion manager is available on the current device.\n\nTo start monitoring submersion data, instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] and assign a delegate to the submersion manager. The system begins sending updates to your delegate. You can then start an extended runtime session when the watch first submerges, and transition your app to a touchless user interface for the duration of the dive.\n\n### Add the required entitlement\n\nBefore you can instantiate the [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] class, your app needs to include a Submerged Depth and Pressure entitlement to access submersion data.\n\nTo access data for dives with a maximum depth of 6 meters, add the Shallow Depth and Pressure capability to your app. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/adding-capabilities-to-your-app].\n\nTo enable a maximum depth of 40 meters, you need to apply for the full Submersion Depth and Pressure entitlement. For more information, see [https:\/\/developer.apple.com\/contact\/request\/submerged-depth-pressure-api-development\/]\n\nIf you instantiate the manager without an entitlement, the system calls your delegate’s [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManagerDelegate\/manager(_:errorOccurred:)] method, passing a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMErrorNotEntitled] error, and your delegate doesn’t receive any additional data.\n\n### Authorize access to motion data\n\nThe system automatically asks the wearer for authorization to access motion data when you first instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager]; however, before you can instantiate the manager, you need to include the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/NSMotionUsageDescription] key in your app target’s information property list and provide a usage description string.\n\n\n\nThe system displays this usage description when it prompts the wearer for authorization to access motion data. If you don’t include a usage description string, your app crashes when you try to instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] object.\n\n### Add support for the underwater depth extended runtime session\n\nTo make sure your app continues to run, and remains visible, you need to add the `underwater-depth` Background Mode to your app’s `Info.plist` file. This background mode lets your app run as the frontmost app during a dive session.\n\nOpen the `Info.plist` file as XML by Control-clicking it in the Project navigator and selecting Open As > Source Code. Next, edit the string value for the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/WKBackgroundModes] key so that it contains the `underwater-depth` value.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\" \"http:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>WKBackgroundModes<\/key>\n    <array>\n        <string>underwater-depth<\/string>\n    <\/array>\n<\/dict>\n<\/plist>\n\n```\n\nIf your app doesn’t already have an `Info.plist` file, you can add a placeholder, and then edit it using the following steps:\n\n1. Select your app’s WatchKit Extension target and click the Signing & Capabilities tab.\n2. Choose Editor > Add Capability and double-click the Background Modes capability to add it to the Signing & Capabilities pane.\n3. Choose an option to use as a placeholder from the Session Type pop-up menu. The `Info.plist` file appears in the Project navigator.\n4. Open the `Info.plist` file as XML source code and replace the placeholder string value for the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/WKBackgroundModes] key with the `underwater-depth` value.\n\nAdding the `underwater-depth` Background Mode capability to your `Info.plist` file lets your app run an extended runtime session so that it can remain the frontmost app for the duration of the dive session. It also adds your app to the list of apps that the system can autolaunch when the wearer submerges the watch.\n\nUnlike most extended runtime sessions, your app doesn’t need to start an extended runtime session to gain additional time as the frontmost app. Just by adding this key, the system automatically keeps your app as the frontmost app for 30 minutes after the wearer launches it. This gives the wearer time to prepare for the dive before submerging. Then, after you start an extended runtime session, your app remains the frontmost app for the duration of the dive. The session doesn’t time out until the watch spends more than 10 minutes unsubmerged or the wearer turns off Water Lock.\n\nIf you don’t explicitly start an extended runtime session, the system automatically starts a runtime session when the wearer dives below 1 meter, and your app transitions to the [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionMeasurement\/DepthState\/submergedDeep] state.\n\n### Verify that the submersion data is available on the current device.\n\nBefore creating a submersion manager, verify that the data is available on the current device.\n\n```swift\nguard CMWaterSubmersionManager.waterSubmersionAvailable else {\n    return false\n}\n```\n\nOn Apple Watch Ultra, the system sets [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager\/waterSubmersionAvailable] to [doc:\/\/com.apple.documentation\/documentation\/Swift\/true]. On all other devices and in Simulator, the system sets it to [doc:\/\/com.apple.documentation\/documentation\/Swift\/false].\n\n### Start monitoring submersion data\n\nTo begin receiving submersion data, instantiate a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] object and assign a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManagerDelegate].\n\n```swift\n\/\/ Instantiate the submersion manager.\nsubmersionManager = CMWaterSubmersionManager()\n\n\/\/ Assign the submersion manager delegate.\nsubmersionManager.delegate = self\n```\n\nYour delegate begins to receive data as soon as you assign it. For example, your delegate receives both event notifications and errors.\n\n```swift\n\/\/ Respond to events.\nnonisolated func manager(_ manager: CMWaterSubmersionManager, didUpdate event: CMWaterSubmersionEvent) {\n\n    let submerged: Bool?\n    switch event.state {\n    case .unknown:\n        logger.info(\"*** Received an unknown event. ***\")\n        submerged = nil\n\n    case .notSubmerged:\n        logger.info(\"*** Not Submerged Event ***\")\n        submerged = false\n\n    case .submerged:\n        logger.info(\"*** Submerged Event ***\")\n        submerged = true\n\n    @unknown default:\n        fatalError(\"*** Unknown event received: \\(event.state) ***\")\n    }\n\n    Task {\n        await myAdd(event: event)\n        if let submerged {\n            await mySet(submerged: submerged)\n        }\n    }\n}\n\n\/\/ Respond to errors.\nnonisolated func manager(_ manager: CMWaterSubmersionManager, errorOccurred error: Error) {\n    logger.error(\"*** An error occurred: \\(error.localizedDescription) ***\")\n}\n\n```\n\nYour delegate also begins receiving measurement updates. If the watch isn’t submerged, the updates only include surface pressure and submersion state data. After submersion, it also receives water pressure and depth data. The system sends measurement updates three times a second while the watch is submerged. When the watch is on the surface, the system provides updates at a slower rate, and may stop providing updates if the watch isn’t moving.\n\n```swift\nnonisolated func manager(_ manager: CMWaterSubmersionManager, didUpdate measurement: CMWaterSubmersionMeasurement) {\n\n    logger.info(\"*** Received a depth measurement. ***\")\n\n    let currentDepth: String\n    if let depth = measurement.depth {\n        currentDepth = \"\\(depth.value) \\(depth.unit)\"\n    } else {\n        currentDepth = \"None\"\n    }\n\n    let currentSurfacePressure: String\n    let surfacePressure = measurement.surfacePressure\n    currentSurfacePressure = \"\\(surfacePressure.value) \\(surfacePressure.unit)\"\n\n    let currentPressure: String\n    if let pressure = measurement.pressure {\n        currentPressure = \"\\(pressure.value) \\(pressure.unit)\"\n    } else {\n        currentPressure = \"None\"\n    }\n\n    logger.info(\"*** Depth: \\(currentDepth) ***\")\n    logger.info(\"*** Surface Pressure: \\(currentSurfacePressure) ***\")\n    logger.info(\"*** Pressure: \\(currentPressure) ***\")\n\n    let submerged: Bool?\n    switch measurement.submersionState {\n    case .unknown:\n        logger.info(\"*** Unknown Depth ***\")\n        submerged = nil\n    case .notSubmerged:\n        logger.info(\"*** Not Submerged ***\")\n        submerged = false\n    case .submergedShallow:\n        logger.info(\"*** Shallow Depth ***\")\n        submerged = true\n    case .submergedDeep:\n        logger.info(\"*** Deep Depth ***\")\n        submerged = true\n    case .approachingMaxDepth:\n        logger.info(\"*** Approaching Max Depth ***\")\n        submerged = true\n    case .pastMaxDepth:\n        logger.info(\"*** Past Max Depth ***\")\n        submerged = true\n    case .sensorDepthError:\n        logger.info(\"*** A depth error has occurred. ***\")\n        submerged = nil\n    @unknown default:\n        fatalError(\"*** An unknown measurement depth state: \\(measurement.submersionState)\")\n    }\n\n    Task {\n        await myAdd(measurement: measurement)\n        if let submerged {\n            await mySet(submerged: submerged)\n        }\n    }\n}\n```\n\nThe watch also receives water temperature data when it’s submerged.\n\n```swift\nnonisolated func manager(_ manager: CMWaterSubmersionManager, didUpdate measurement: CMWaterTemperature) {\n    let temp = measurement.temperature\n    let uncertainty = measurement.temperatureUncertainty\n    let currentTemperature = \"\\(temp.value) +\/- \\(uncertainty.value) \\(temp.unit)\"\n\n    logger.info((\"*** \\(currentTemperature) ***\"))\n\n    Task {\n        await myAdd(temperature:measurement)\n    }\n}\n```\n\nThe water temperature readings can take some time to converge on the correct value. The system estimates how long it takes to converge to the correct results, and calculates an uncertainty value based on the expected convergence.\n\n### Start a dive session\n\nYou can start an extended runtime session as the wearer begins their dive.\n\n```swift\nfunc myStartDiveSession() {\n    logger.info(\"*** Starting a dive session. ***\")\n\n    \/\/ Create the extended runtime session.\n    let session = WKExtendedRuntimeSession()\n\n    \/\/ Assign a delegate to the session.\n    session.delegate = self\n\n    \/\/ Start the session.\n    session.start()\n\n    self.extendedRuntimeSession = session\n    diveSessionRunning = true\n}\n```\n\nThis session continues to run until:\n\n- You explicitly cancel the session by calling [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKExtendedRuntimeSession\/invalidate()] on it.\n- The wearer turns off Water Lock.\n- Your app remains in the [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionEvent\/State-swift.enum\/notSubmerged] state for at least 10 minutes.\n\nFor more information, see [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/using-extended-runtime-sessions].\n\n### Transition to a touchless user interface\n\nStarting an extended runtime session automatically enables Water Lock on the watch. As a result, the system disables the watch’s touchscreen for the duration of the dive. If you want the wearer to interact with your app during the dive, you need to enable interaction using either the Digital Crown or the Action button.\n\nMany views, like [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/List], [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ScrollView], and [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Picker], automatically respond to the Digital Crown. The wearer can interact with these elements without needing any changes to the user interface.\n\n```swift\nstruct MyPickerView: View {\n\n    enum Action: String, CaseIterable, Identifiable {\n        case none, action1, action2, action3\n        var id: Self { self }\n    }\n\n    @State var selection: Action = .none\n\n    var body: some View {\n        Text(selection.rawValue)\n        Picker(\"Action\", selection: $selection) {\n            ForEach(Action.allCases) { action in\n                Text(action.rawValue.capitalized)\n            }\n        }\n    }\n}\n```\n\nYou can also use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/digitalCrownRotation(_:)] view modifier to respond directly when the wearer rotates the Digital Crown.\n\n```swift\nstruct DigitalCrown: View {\n    @State private var crownValue = 0.0\n\n    var body: some View {\n        Text(\"\\(crownValue)\")\n            .focusable()\n            .digitalCrownRotation($crownValue,\n                                  from: 1,\n                                  through: 10,\n                                  by: 1.0,\n                                  sensitivity: .low,\n                                  isHapticFeedbackEnabled: true)\n    }\n}\n```\n\nFor the Action button, implement a [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/StartDiveIntent] to launch your app and prepare for a new dive when the wearer first presses the Action button. You can then donate an [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/AppIntent] for the Action button’s next action. If the wearer presses the Action button any other time during the session, it triggers the next action. Your app can have only one next action at a time, and donating a new intent changes the next action — letting you customize the next action based on your app’s current state.\n\n```swift\n\/\/ Create an intent to launch your app and set up the dive manager.\nstruct MyStartDiveSessionIntent: StartDiveIntent {\n\n    static var title: LocalizedStringResource = \"Starting a dive session.\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Starting a dive session. ***\")\n\n        await MyDiveManager.shared.start()\n        return .result(actionButtonIntent: MyBeginDescent())\n    }\n}\n\n\/\/ Create an intent that defines the Action button's next action.\nstruct MyBeginDescent: AppIntent {\n\n    static var title: LocalizedStringResource = \"Start Your Descent\"\n\n    func perform() async throws -> some IntentResult {\n        logger.debug(\"*** Starting the descent. ***\")\n        await MyDiveManager.shared.beginDescent()\n        return .result()\n    }\n}\n\n```\n\nFor more information, see [doc:\/\/com.apple.documentation\/documentation\/AppIntents\/ActionButtonArticle].\n\n### Handle automatic dive sessions\n\nIf you don’t explicitly start an extended runtime session, the system automatically starts a session when the wearer descends below 1 meter. It then passes the session to your app delegate’s [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/handle(_:)-7kiwx] method. To use this session, add a delegate and save it to a variable that remains in scope for the entire dive’s duration.\n\n```swift\nfunc handle(_ extendedRuntimeSession: WKExtendedRuntimeSession) {\n    \/\/ The system starts a session because the wearer is more than\n    \/\/ 1 meter underwater without an active extended runtime session.\n\n    let submersionSession = MySubmersionSession.shared\n\n    \/\/ Assign a delegate to the session.\n    extendedRuntimeSession.delegate = submersionSession\n\n    submersionSession.extendedRuntimeSession = extendedRuntimeSession\n    submersionSession.diveSessionRunning = true\n}\n```\n\n### Respond to autolaunch\n\nOn Apple Watch Ultra, the wearer can tell the system to launch an app when the watch becomes submerged. To enable this feature, they choose Settings > General > Auto-Launch and select the Auto-Launch App setting from the When Submerged group. They can also select which app the system launches.\n\nThe system adds your app to the list of autolaunchable apps as soon as you add the `underwater-depth` Background Mode capability to your app’s `Info.plist` file. This means your app needs to respond appropriately if the wearer sets it as the autolaunch app, and jumps into the water without otherwise interacting with your app.\n\nFor example, you can set up your app’s [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionManager] when your app launches. This ensures that your app is always ready to receive submersion data. Then, when the wearer descends below 1 meter, you can use your [doc:\/\/com.apple.documentation\/documentation\/WatchKit\/WKApplicationDelegate\/handle(_:)-7kiwx] method to grab the automatically generated extended runtime session. Alternatively, if you prefer to explicitly start your own extended runtime session, you can start the session when your app receives a [doc:\/\/com.apple.coremotion\/documentation\/CoreMotion\/CMWaterSubmersionEvent\/State-swift.enum\/submerged] event.\n\n### Test submersion data\n\nAlways test submersion data on Apple Watch Ultra. You can’t instantiate the submersion manager in Simulator. To trigger a submersion event, you need to submerge Apple Watch Ultra in a tank of water at least 1 foot deep. When testing in a pressurized container, make sure the watch is completely submerged in water.\n\nIf the water isn’t deep enough to trigger a submersion event, you can enable Easy Submersion mode using a paired iPhone. Connect the phone to your Mac and in Xcode 14.2 or later, select Debug > Induce Device Conditions > Easy Submersion > Enable Easy Submersion.\n\n## Water submersion\n\n- **CMWaterSubmersionManager**: An object for managing the collection of pressure and temperature data during submersion.\n- **CMWaterSubmersionManagerDelegate**: A delegate that receives updates about ambient pressure, water pressure, water temperature, and submersion events.\n- **CMWaterSubmersionEvent**: An event indicating that the device’s submersion state has changed.\n- **CMWaterSubmersionMeasurement**: An update that contains data about the pressure and depth.\n- **CMWaterTemperature**: An update that contains data about the water temperature.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "An object for managing the collection of pressure and temperature data during submersion.",
          "name" : "CMWaterSubmersionManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMotion\/CMWaterSubmersionManager"
        },
        {
          "description" : "A delegate that receives updates about ambient pressure, water pressure, water temperature, and submersion events.",
          "name" : "CMWaterSubmersionManagerDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMotion\/CMWaterSubmersionManagerDelegate"
        },
        {
          "description" : "An event indicating that the device’s submersion state has changed.",
          "name" : "CMWaterSubmersionEvent",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMotion\/CMWaterSubmersionEvent"
        },
        {
          "description" : "An update that contains data about the pressure and depth.",
          "name" : "CMWaterSubmersionMeasurement",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMotion\/CMWaterSubmersionMeasurement"
        },
        {
          "description" : "An update that contains data about the water temperature.",
          "name" : "CMWaterTemperature",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreMotion\/CMWaterTemperature"
        }
      ],
      "title" : "Water submersion"
    }
  ],
  "source" : "appleJSON",
  "title" : "Accessing submersion data",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreMotion\/accessing-submersion-data"
}