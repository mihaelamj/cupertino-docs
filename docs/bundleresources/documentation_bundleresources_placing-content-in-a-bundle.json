{
  "abstract" : "Place bundle content in the correct location based on its type.",
  "codeExamples" : [
    {
      "code" : "CoreWaffleVarnishing.framework\/\n  CoreWaffleVarnishing -> Versions\/Current\/CoreWaffleVarnishing\n  Resources -> Versions\/Current\/Resources\n  Versions\/\n    Current -> A\n    A\/\n      CoreWaffleVarnishing\n      Resources\/\n        Info.plist\n        … other resources …",
      "language" : "console"
    },
    {
      "code" : "WaffleVarnisher.app\/\n  Contents\/\n    …\n    PlugIns\/\n      Waffles\/\n        Belgian.plugin\n        Buttermilk.plugin\n        BananaCaramel.plugin\n        …\n      Varnishes\/\n        Gloss.plugin\n        Satin.plugin\n        Matte.plugin\n    …\n",
      "language" : "console"
    }
  ],
  "contentHash" : "ff10b66d11881df32e8c8309360065892734a7fdceae3c2c0b3fc92233a824cd",
  "crawledAt" : "2025-12-04T01:02:39Z",
  "id" : "EB389B0A-9530-4D4B-8C8E-67E162D04A07",
  "kind" : "article",
  "language" : "swift",
  "module" : "Bundle Resources",
  "overview" : "## Overview\n\nA *bundle* is a directory with a standardized hierarchical structure that typically contains executable code and the resources used by that code. Bundles fulfill many different roles: apps, app extensions, frameworks, and plug-ins are all bundles. Bundles can also contain other bundles; for example, an app may contain an app extension.\n\nA bundle has a set of standard locations to hold content. The correct location to place content within a bundle depends on the content type. For example, you must place an app extension in the location reserved for plug-ins and a storyboard in the location reserved for resources. Not all locations are appropriate on all platforms and, similarly, not all platforms support all content types.\n\nXcode understands the bundle structure and, if you use Xcode to build your bundle, it places content correctly based on its type. If you don’t use Xcode to build your software product, use the information below to place your bundled content in the right location. Even if you use Xcode, you might find this information useful as you check the final structure of your product.\n\n### Place content based on type and platform\n\nBundled content includes the bundle’s `Info.plist`, code content and resources:\n\nWhen adding content to a bundle, place it according to the rules in the following table:\n\niOS, watchOS, and tvOS support third-party frameworks but don’t support third-party standalone dynamic libraries, which are those outside a framework bundle, typically with the `.dylib` filename extension. The only exception to this rule is the Swift system libraries provided by Xcode.\n\niOS and tvOS support frameworks and Swift system libraries at the topmost app level; a nested bundle, like an app extension, can’t include a framework.\n\nFor more information about embedding frameworks and Swift system libraries on watchOS, see [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/placing-content-in-a-bundle#Handle-frameworks-and-Swift-system-libraries-on-watchOS].\n\nFor information on localizing resources, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/CoreFoundation\/Conceptual\/CFBundles\/BundleTypes\/BundleTypes.html#\/\/apple_ref\/doc\/uid\/10000123i-CH101-SW7].\n\n### Handle frameworks and Swift system libraries on watchOS\n\nA watchOS app consists of an iOS app that contains a watchOS app, that then contains a WatchKit extension. This nesting is present even for watch-only apps. When embedding frameworks and Swift system libraries in a watchOS app, you need to:\n\n### Support a single framework version on macOS\n\nA macOS framework is a bundle that uses a unique format. The framework’s root contains a `Versions` directory that holds one or more versions of the framework, each of which has its own bundle-like structure. On ancestor platforms to macOS, multiple versions of a framework can coexist within this versioned bundle. On macOS, however, best practice is to use a single version named `A`.\n\nIf you build your macOS framework in Xcode, it generates the correct structure automatically. If you’re working outside of Xcode, follow these rules to structure your framework for maximum compatibility:\n\nThe final structure looks like this:\n\n### Place code content directly in its location\n\nEach code location must contain a flat list of code content. If you have a lot of code content, you might be tempted to group it in nested directories, for example:\n\nDon’t group your nested code in this way. Although it might work in some situations, it might fail later in hard-to-debug ways.\n\nIf you ignore this recommendation and use this structure, don’t use a dot (`.`) in your directory names, such as `Waffles` and `Varnishes` in the example above. The code-signing machinery assumes that any directory with a name that contains a dot is a bundle, and then fails when signing that directory because it’s not a well-formed bundle.\n\n### Codeless bundles\n\nA codeless bundle has no executable code. For example, some apps use a codeless bundle as part of their plug-in support. A codeless bundle can hold a code signature, so you can sign it either as code or a resource, depending on the circumstances:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/BundleResources\/placing-content-in-a-bundle\ncrawled: 2025-12-04T01:02:39Z\n---\n\n# Placing content in a bundle\n\n**Article**\n\nPlace bundle content in the correct location based on its type.\n\n## Overview\n\nA *bundle* is a directory with a standardized hierarchical structure that typically contains executable code and the resources used by that code. Bundles fulfill many different roles: apps, app extensions, frameworks, and plug-ins are all bundles. Bundles can also contain other bundles; for example, an app may contain an app extension.\n\nA bundle has a set of standard locations to hold content. The correct location to place content within a bundle depends on the content type. For example, you must place an app extension in the location reserved for plug-ins and a storyboard in the location reserved for resources. Not all locations are appropriate on all platforms and, similarly, not all platforms support all content types.\n\nXcode understands the bundle structure and, if you use Xcode to build your bundle, it places content correctly based on its type. If you don’t use Xcode to build your software product, use the information below to place your bundled content in the right location. Even if you use Xcode, you might find this information useful as you check the final structure of your product.\n\n\n\n### Place content based on type and platform\n\nBundled content includes the bundle’s `Info.plist`, code content and resources:\n\n- The `Info.plist` is a property list file stored at a location that identifies a directory hierarchy as a bundle. For a list of `Info.plist` keys, see [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/Information-Property-List].\n- Code content is either executable code, like a helper tool, or another bundle that contains executable code, like an app extension. In this context, executable code means a Mach-O image. It doesn’t include things like shell scripts, Python scripts, and AppleScripts (unless you save the AppleScript as an application). Although you execute a script, it has no place to hold a code signature, so you treat it as a resource.\n- Resources are everything that’s not code.\n\nWhen adding content to a bundle, place it according to the rules in the following table:\n\n- If the location ends with a slash (`\/`), place the item within that directory. Otherwise, place a single item of that type at that location.\n- A location of `\/` indicates the root of the bundle.\n- The macOS platform covers both Mac and Mac Catalyst apps.\n\n\n\niOS, watchOS, and tvOS support third-party frameworks but don’t support third-party standalone dynamic libraries, which are those outside a framework bundle, typically with the `.dylib` filename extension. The only exception to this rule is the Swift system libraries provided by Xcode.\n\niOS and tvOS support frameworks and Swift system libraries at the topmost app level; a nested bundle, like an app extension, can’t include a framework.\n\nFor more information about embedding frameworks and Swift system libraries on watchOS, see [doc:\/\/com.apple.bundleresources\/documentation\/BundleResources\/placing-content-in-a-bundle#Handle-frameworks-and-Swift-system-libraries-on-watchOS].\n\nFor information on localizing resources, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/CoreFoundation\/Conceptual\/CFBundles\/BundleTypes\/BundleTypes.html#\/\/apple_ref\/doc\/uid\/10000123i-CH101-SW7].\n\n### Handle frameworks and Swift system libraries on watchOS\n\nA watchOS app consists of an iOS app that contains a watchOS app, that then contains a WatchKit extension. This nesting is present even for watch-only apps. When embedding frameworks and Swift system libraries in a watchOS app, you need to:\n\n- Place iOS frameworks and Swift system libraries in the iOS app’s `Frameworks` directory. For example, for an iOS app called MyApp, place iOS frameworks and Swift system libraries in `MyApp.app\/Frameworks\/`.\n- Place the watchOS Swift system libraries in the WatchKit app’s `Frameworks` directory, for example, `MyApp.app\/Watch\/MyApp WatchKit App.app\/Frameworks\/`.\n- Place watchOS frameworks in the WatchKit extension’s `Frameworks` directory, for example, `MyApp.app\/Watch\/MyApp WatchKit App.app\/PlugIns\/MyApp WatchKit Extension.appex\/Frameworks\/`.\n\n### Support a single framework version on macOS\n\nA macOS framework is a bundle that uses a unique format. The framework’s root contains a `Versions` directory that holds one or more versions of the framework, each of which has its own bundle-like structure. On ancestor platforms to macOS, multiple versions of a framework can coexist within this versioned bundle. On macOS, however, best practice is to use a single version named `A`.\n\nIf you build your macOS framework in Xcode, it generates the correct structure automatically. If you’re working outside of Xcode, follow these rules to structure your framework for maximum compatibility:\n\n1. Create a single `Versions` directory at the framework’s root.\n2. Within that, create a directory name `A`.\n3. Populate `Versions\/A` with your framework content.\n4. Create a symlink within `Versions` called `Current` that targets `A`.\n5. Create a symlink in the framework’s root that target’s the framework’s executable through `Versions\/Current`. For example, if you’re creating the CoreWaffleVarnishing framework, create a symlink called `CoreWaffleVarnishing` that targets the framework’s executable at `Versions\/Current\/CoreWaffleVarnishing`.\n6. Create a symlink in the framework’s root that target’s the framework’s `Resources` directory through `Versions\/Current`.\n7. Optionally, create other symlinks in the root that target similarly named items through `Versions\/Current`.\n\nThe final structure looks like this:\n\n```console\nCoreWaffleVarnishing.framework\/\n  CoreWaffleVarnishing -> Versions\/Current\/CoreWaffleVarnishing\n  Resources -> Versions\/Current\/Resources\n  Versions\/\n    Current -> A\n    A\/\n      CoreWaffleVarnishing\n      Resources\/\n        Info.plist\n        … other resources …\n```\n\n\n\n### Place code content directly in its location\n\nEach code location must contain a flat list of code content. If you have a lot of code content, you might be tempted to group it in nested directories, for example:\n\n```console\nWaffleVarnisher.app\/\n  Contents\/\n    …\n    PlugIns\/\n      Waffles\/\n        Belgian.plugin\n        Buttermilk.plugin\n        BananaCaramel.plugin\n        …\n      Varnishes\/\n        Gloss.plugin\n        Satin.plugin\n        Matte.plugin\n    …\n\n```\n\nDon’t group your nested code in this way. Although it might work in some situations, it might fail later in hard-to-debug ways.\n\nIf you ignore this recommendation and use this structure, don’t use a dot (`.`) in your directory names, such as `Waffles` and `Varnishes` in the example above. The code-signing machinery assumes that any directory with a name that contains a dot is a bundle, and then fails when signing that directory because it’s not a well-formed bundle.\n\n### Codeless bundles\n\nA codeless bundle has no executable code. For example, some apps use a codeless bundle as part of their plug-in support. A codeless bundle can hold a code signature, so you can sign it either as code or a resource, depending on the circumstances:\n\n- If you distribute a codeless bundle independently, sign it as code.\n- If you embed a codeless bundle within another bundle, sign it as code if the embedding location typically holds code, for example, `Contents\/PlugIns`. Otherwise, sign the codeless bundle as a resource.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Placing content in a bundle",
  "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/placing-content-in-a-bundle"
}