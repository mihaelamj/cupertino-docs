{
  "abstract" : "Display a 3D model that generates procedural textures in a reality view.",
  "codeExamples" : [
    {
      "code" : "import SwiftUI\nimport RealityKit\nimport GameplayKit\n\nstruct ProceduralTextureGenerator {\n    static func generate(_ seed: Int) throws -> TextureResource {\n        let length = 1024\n        let bytesPerPixel = 1\n        let bitSize = 8\n\n        \/\/\/ The generator to randomly generate numbers.\n        let generator = GKARC4RandomSource()\n\n        \/\/ Assign the generator seed that determines the random source’s behavior.\n        guard let setSeed = \"\\(seed)\".data(using: .ascii) else {\n            throw ProceduralTextureGeneratorError.convertSeedFailed\n        }\n        generator.seed = setSeed\n        \n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport RealityKit\nimport GameplayKit\n\nstruct ProceduralTextureGenerator {\n    static func generate(_ seed: Int) -> TextureResource? {\n        \/\/ ...\n    \n        \/\/\/ The data provider with pixels that the generator randomly assigns.\n        guard let provider = CGDataProvider(\n            data: Data(bytes: &pixels, count: pixels.count * bytesPerPixel) as CFData\n        ) else {\n            throw ProceduralTextureGeneratorError.providerCreationFailed\n        }\n\n        \/\/ The source image for the texture.\n        guard let image = CGImage(\n            width: length,\n            height: length,\n            bitsPerComponent: bytesPerPixel * bitSize,\n            bitsPerPixel: bytesPerPixel * bitSize,\n            bytesPerRow: length * bytesPerPixel,\n            space: CGColorSpaceCreateDeviceGray(),\n            bitmapInfo: CGBitmapInfo(),\n            provider: provider,\n            decode: nil,\n            shouldInterpolate: true,\n            intent: .defaultIntent\n        ) else {\n            throw ProceduralTextureGeneratorError.imageCreationFailed\n        }\n\n        return try TextureResource(image: image, options: TextureResource.CreateOptions(semantic: .color))\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import RealityKit\n\nstruct DrawableQueueSystem: System {\n    static let query = EntityQuery(where: .has(DrawableQueueComponent.self))\n\n    init(scene: RealityKit.Scene) { }\n\n    \/\/\/ Update the results to attach delta time to the component.\n    func update(context: SceneUpdateContext) {\n        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {\n            if var comp = entity.components[DrawableQueueComponent.self] {\n                comp.update(deltaTime: context.deltaTime)\n                entity.components[DrawableQueueComponent.self] = comp\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport RealityKit\n\nstruct DrawableQueueComponent: Component {\n    \/\/ ...\n\n    init(texture: TextureResource) throws {\n        DrawableQueueSystem.registerSystem()\n\n        \/\/ ...\n\n        \/\/\/ The descriptor to configure new Metal texture objects.\n        let desc = MTLTextureDescriptor()\n        desc.width = texture.width\n        desc.height = texture.height\n        desc.usage = [.shaderWrite, .shaderRead]\n        desc.pixelFormat = .r16Float\n\n        guard let newTexture = mtlDevice.makeTexture(descriptor: desc) else {\n            throw DrawableComponentError.textureCreationFailed\n        }\n        self.mtlTexture = newTexture\n\n        try texture.copy(to: mtlTexture)\n\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport RealityKit\n\nstruct DrawableQueueComponent: Component {\n    \/\/ ...\n\n    init(texture: TextureResource) throws {\n        \/\/ ...\n\n        \/\/\/ The descriptor for the drawable queue.\n        let queueDesc = TextureResource.DrawableQueue.Descriptor(\n            pixelFormat: .rgba16Float,\n            width: texture.width,\n            height: texture.height,\n            usage: [.shaderRead, .shaderWrite],\n            mipmapsMode: .none\n        )\n\n        \/\/ Replace the texture with the result of the drawable queue.\n        guard let queue = try? TextureResource.DrawableQueue(queueDesc) else {\n            throw DrawableComponentError.queueCreationFailed\n        }\n        texture.replace(withDrawables: queue)\n\n        \/\/\/ The name of the shader function.\n        let shaderFunctionName: String = \"textureShader\"\n\n        \/\/ Assign the configuration with the shader function.\n        guard let library = mtlDevice.makeDefaultLibrary(), let function = library.makeFunction(name: shaderFunctionName) else {\n            throw DrawableComponentError.shaderFunctionCreationFailed\n        }\n        self.pipeState = try mtlDevice.makeComputePipelineState(function: function)\n\n        \/\/ Assign the Metal command queue.\n        guard let newQueue = mtlDevice.makeCommandQueue() else {\n            throw DrawableComponentError.commandQueueCreationFailed\n        }\n        self.mtlCommandQueue = newQueue\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\nimport RealityKit\n\nstruct DrawableQueueComponent: Component {\n    \/\/ ...\n\n    mutating func update(deltaTime: TimeInterval) {\n        \/\/ Increment the value of time with amount of time.\n        time += deltaTime\n\n        \/\/ ...\n\n        let threadGroupCount = MTLSizeMake(8, 8, 1)\n        let threadGroups = MTLSizeMake(\n            texture.width \/ threadGroupCount.width,\n            texture.height \/ threadGroupCount.height,\n            1\n        )\n\n        encoder.dispatchThreadgroups(threadGroups, threadsPerThreadgroup: threadGroupCount)\n        encoder.endEncoding()\n\n        commandBuffer.commit()\n        drawable.present()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct EntityView: View {\n    \/\/\/ The value that controls which iteration of the texture the generator uses\n    var seed: Int\n\n    \/\/ ...\n\n    var body: some View {\n        RealityView { content in\n            do {\n                let entity = try makeEntity()\n                content.add(entity)\n            } catch {\n                print(\"Error creating entity: \\(error)\")\n            }\n        } update: { content in\n            for entity in content.entities {\n                if let modelEntitty = entity as? ModelEntity {\n                    try? updateEntity(modelEntitty)\n                } else {\n                    print(\"Entity is not a ModelEntity.\")\n                }\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@MainActor\nfunc makeEntity() throws -> ModelEntity {\n    let fileName: String = \"Torus\"\n    \n    \/\/\/ The 3D torus model.\n    let entity = try Entity.loadModel(named: fileName)\n    \n    \/\/ Set the scale of the entity with the bounding radius of the model's visible bounds.\n    entity.scale \/= entity.visualBounds(relativeTo: nil).boundingRadius\n\n    let scale: Float = 0.2\n    \n    \/\/ Apply the scale factor with the value of the scale variable.\n    entity.scale *= scale\n    \n    \/\/ Rotate the entity along the y-axis so that the entity faces the user.\n    entity.transform.rotation *= simd_quatf(from: SIMD3<Float>(0, 1, 0), to: SIMD3<Float>(0, 0, 1))\n\n    try updateEntity(entity)\n\n    return entity\n}",
      "language" : "swift"
    },
    {
      "code" : "@MainActor\nfunc updateEntity(_ entity: ModelEntity) throws {\n    \/\/\/ The texture based on the seed values.\n    guard let texture = ProceduralTextureGenerator.generate(seed) else {\n        return\n    }\n\n    \/\/\/ The texture of the sampler, to the nearest pixel.\n    var sampler = PhysicallyBasedMaterial.Texture.Sampler()\n    sampler.modify { $0.magFilter = .nearest }\n\n    \/\/\/ The material that simulates the appearance of real-world objects.\n    var material = PhysicallyBasedMaterial()\n\n    \/\/\/ The texture for the material.\n    let textureAndSampler = PhysicallyBasedMaterial.Texture(\n        texture,\n        sampler: sampler\n    )\n    material.baseColor = PhysicallyBasedMaterial.BaseColor(texture: textureAndSampler)\n\n    \/\/ Apply the material to the model of the entity.\n    entity.model?.materials = [material]\n\n    entity.components[DrawableQueueComponent.self] = try DrawableQueueComponent(texture: texture)\n}",
      "language" : "swift"
    },
    {
      "code" : "import SwiftUI\n\nstruct DrawableView: View {\n    @State var seed: Int = 0\n\n    var body: some View {\n        HStack {\n            EntityView(seed: seed)\n\n            Divider()\n\n            Button(\"Regenerate\") { seed += 1 }\n        }.padding()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "a23cd4a2eddd2397fddd66faade6341b050c1f7e3ffd80bdf13291d40777f4aa",
  "crawledAt" : "2025-12-02T17:48:51Z",
  "id" : "BA800A25-33D0-42D3-AEA0-08F469AECA35",
  "kind" : "unknown",
  "language" : "swift",
  "overview" : "## Overview\n\nThis sample demonstrates how to create and display a 3D torus model that dynamically regenerates a [doc:\/\/com.apple.documentation\/documentation\/Metal] texture at each render frame within a visionOS app.\n\nAt launch, the app starts a window group that contains:\n\n### Generate the texture of the model\n\nThe sample constructs the `ProceduralTextureGenerator` structure, which contains the `generate()` method to generate and return a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource] to apply to the torus model. The app uses  [doc:\/\/com.apple.documentation\/documentation\/GameplayKit\/GKARC4RandomSource] to generate a number using the ARC4 algorithm, and assigns the `seed` to the generator to determine the random source’s behavior:\n\nAfter creating the generator, the app creates a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGDataProvider] with pixels that the generator randomly assigns. Then it creates the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] for the procedural texture:\n\nThe app attempts to create and return a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource] with the generated `image`.\n\n### Update the texture in real time\n\nThe sample defines the custom system `DrawableQueueSystem` to update the model’s texture in real time:\n\nThe `update()` method iterates through all matching entities during the rendering phase and updates each entity’s `DrawableQueueComponent` by passing the time difference between frames, allowing for smooth real-time updates in the scene.\n\nThe initializer registers the `DrawableQueueSystem` within the component, establishing a Metal texture descriptor and a Metal texture. The app attempts to copy the input [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource] texture data into the Metal texture:\n\nA [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource\/DrawableQueue-swift.class] makes it possible to update a texture resource dynamically. The app creates a descriptor and inserts it into the drawable queue to dynamically replace the texture:\n\nThe app attempts to load the shader function. Then it creates a compute pipeline state, which allows the GPU to execute the shader function. Additionally, the app creates a command queue to enable communication between the app and the GPU.\n\nThe `update(deltaTime:)` method starts by incrementing the value of time, to track and allow contents to change over time:\n\nThe method sets up the encoder, then commits to the command buffer to submit the command buffer to run on the GPU. Lastly, it presents the updated texture to the renderer with the `present()` method.\n\n### Set up the torus model\n\nThe `EntityView` attempts to create the torus model by calling the `makeEntity()` method:\n\nThe `update` closure loops through all the entities in the reality view, and attempts to update the entity in scene updates.\n\nThe `makeEntity()` method marks the [doc:\/\/com.apple.documentation\/documentation\/Swift\/MainActor] to execute in the main dispatch queue:\n\nThe [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/Entity\/loadModel(named:in:)] method synchronously loads a 3D torus model, scales it to the proper size, and applies the `updateEntity()` method.\n\nThe `updateEntity()` method generates a new texture by passing the seed value into the `generate()` method, and creates a material sampler for the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/PhysicallyBasedMaterial]:\n\nThe method applies the material to the model of the entity, and attempts to set the `DrawableQueueComponent` to initalize the texture.\n\n### Set up the parent window\n\nThe `DrawableView` creates a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/State] `seed` property to control the randomization of the texture generator:\n\nUsing the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/HStack] makes it possible to call the `EntityView` that accepts `seed` and a button that increases the value of `seed` on each press.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/visionos\/generating-procedural-textures-in-visionos\ncrawled: 2025-12-02T17:48:51Z\n---\n\n# Generating procedural textures\n\n**Sample Code**\n\nDisplay a 3D model that generates procedural textures in a reality view.\n\n## Overview\n\nThis sample demonstrates how to create and display a 3D torus model that dynamically regenerates a [doc:\/\/com.apple.documentation\/documentation\/Metal] texture at each render frame within a visionOS app.\n\nAt launch, the app starts a window group that contains:\n\n- A 3D torus model with a generated texture\n- A button displaying the text “generate”\n\n\n\n### Generate the texture of the model\n\nThe sample constructs the `ProceduralTextureGenerator` structure, which contains the `generate()` method to generate and return a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource] to apply to the torus model. The app uses  [doc:\/\/com.apple.documentation\/documentation\/GameplayKit\/GKARC4RandomSource] to generate a number using the ARC4 algorithm, and assigns the `seed` to the generator to determine the random source’s behavior:\n\n```swift\nimport SwiftUI\nimport RealityKit\nimport GameplayKit\n\nstruct ProceduralTextureGenerator {\n    static func generate(_ seed: Int) throws -> TextureResource {\n        let length = 1024\n        let bytesPerPixel = 1\n        let bitSize = 8\n\n        \/\/\/ The generator to randomly generate numbers.\n        let generator = GKARC4RandomSource()\n\n        \/\/ Assign the generator seed that determines the random source’s behavior.\n        guard let setSeed = \"\\(seed)\".data(using: .ascii) else {\n            throw ProceduralTextureGeneratorError.convertSeedFailed\n        }\n        generator.seed = setSeed\n        \n        \/\/ ...\n    }\n}\n```\n\nAfter creating the generator, the app creates a [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGDataProvider] with pixels that the generator randomly assigns. Then it creates the [doc:\/\/com.apple.documentation\/documentation\/CoreGraphics\/CGImage] for the procedural texture:\n\n```swift\nimport SwiftUI\nimport RealityKit\nimport GameplayKit\n\nstruct ProceduralTextureGenerator {\n    static func generate(_ seed: Int) -> TextureResource? {\n        \/\/ ...\n    \n        \/\/\/ The data provider with pixels that the generator randomly assigns.\n        guard let provider = CGDataProvider(\n            data: Data(bytes: &pixels, count: pixels.count * bytesPerPixel) as CFData\n        ) else {\n            throw ProceduralTextureGeneratorError.providerCreationFailed\n        }\n\n        \/\/ The source image for the texture.\n        guard let image = CGImage(\n            width: length,\n            height: length,\n            bitsPerComponent: bytesPerPixel * bitSize,\n            bitsPerPixel: bytesPerPixel * bitSize,\n            bytesPerRow: length * bytesPerPixel,\n            space: CGColorSpaceCreateDeviceGray(),\n            bitmapInfo: CGBitmapInfo(),\n            provider: provider,\n            decode: nil,\n            shouldInterpolate: true,\n            intent: .defaultIntent\n        ) else {\n            throw ProceduralTextureGeneratorError.imageCreationFailed\n        }\n\n        return try TextureResource(image: image, options: TextureResource.CreateOptions(semantic: .color))\n    }\n}\n```\n\nThe app attempts to create and return a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource] with the generated `image`.\n\n### Update the texture in real time\n\nThe sample defines the custom system `DrawableQueueSystem` to update the model’s texture in real time:\n\n```swift\nimport RealityKit\n\nstruct DrawableQueueSystem: System {\n    static let query = EntityQuery(where: .has(DrawableQueueComponent.self))\n\n    init(scene: RealityKit.Scene) { }\n\n    \/\/\/ Update the results to attach delta time to the component.\n    func update(context: SceneUpdateContext) {\n        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {\n            if var comp = entity.components[DrawableQueueComponent.self] {\n                comp.update(deltaTime: context.deltaTime)\n                entity.components[DrawableQueueComponent.self] = comp\n            }\n        }\n    }\n}\n```\n\nThe `update()` method iterates through all matching entities during the rendering phase and updates each entity’s `DrawableQueueComponent` by passing the time difference between frames, allowing for smooth real-time updates in the scene.\n\nThe initializer registers the `DrawableQueueSystem` within the component, establishing a Metal texture descriptor and a Metal texture. The app attempts to copy the input [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource] texture data into the Metal texture:\n\n```swift\nimport SwiftUI\nimport RealityKit\n\nstruct DrawableQueueComponent: Component {\n    \/\/ ...\n\n    init(texture: TextureResource) throws {\n        DrawableQueueSystem.registerSystem()\n\n        \/\/ ...\n\n        \/\/\/ The descriptor to configure new Metal texture objects.\n        let desc = MTLTextureDescriptor()\n        desc.width = texture.width\n        desc.height = texture.height\n        desc.usage = [.shaderWrite, .shaderRead]\n        desc.pixelFormat = .r16Float\n\n        guard let newTexture = mtlDevice.makeTexture(descriptor: desc) else {\n            throw DrawableComponentError.textureCreationFailed\n        }\n        self.mtlTexture = newTexture\n\n        try texture.copy(to: mtlTexture)\n\n        \/\/ ...\n    }\n}\n```\n\nA [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/TextureResource\/DrawableQueue-swift.class] makes it possible to update a texture resource dynamically. The app creates a descriptor and inserts it into the drawable queue to dynamically replace the texture:\n\n```swift\nimport SwiftUI\nimport RealityKit\n\nstruct DrawableQueueComponent: Component {\n    \/\/ ...\n\n    init(texture: TextureResource) throws {\n        \/\/ ...\n\n        \/\/\/ The descriptor for the drawable queue.\n        let queueDesc = TextureResource.DrawableQueue.Descriptor(\n            pixelFormat: .rgba16Float,\n            width: texture.width,\n            height: texture.height,\n            usage: [.shaderRead, .shaderWrite],\n            mipmapsMode: .none\n        )\n\n        \/\/ Replace the texture with the result of the drawable queue.\n        guard let queue = try? TextureResource.DrawableQueue(queueDesc) else {\n            throw DrawableComponentError.queueCreationFailed\n        }\n        texture.replace(withDrawables: queue)\n\n        \/\/\/ The name of the shader function.\n        let shaderFunctionName: String = \"textureShader\"\n\n        \/\/ Assign the configuration with the shader function.\n        guard let library = mtlDevice.makeDefaultLibrary(), let function = library.makeFunction(name: shaderFunctionName) else {\n            throw DrawableComponentError.shaderFunctionCreationFailed\n        }\n        self.pipeState = try mtlDevice.makeComputePipelineState(function: function)\n\n        \/\/ Assign the Metal command queue.\n        guard let newQueue = mtlDevice.makeCommandQueue() else {\n            throw DrawableComponentError.commandQueueCreationFailed\n        }\n        self.mtlCommandQueue = newQueue\n    }\n}\n```\n\nThe app attempts to load the shader function. Then it creates a compute pipeline state, which allows the GPU to execute the shader function. Additionally, the app creates a command queue to enable communication between the app and the GPU.\n\nThe `update(deltaTime:)` method starts by incrementing the value of time, to track and allow contents to change over time:\n\n```swift\nimport SwiftUI\nimport RealityKit\n\nstruct DrawableQueueComponent: Component {\n    \/\/ ...\n\n    mutating func update(deltaTime: TimeInterval) {\n        \/\/ Increment the value of time with amount of time.\n        time += deltaTime\n\n        \/\/ ...\n\n        let threadGroupCount = MTLSizeMake(8, 8, 1)\n        let threadGroups = MTLSizeMake(\n            texture.width \/ threadGroupCount.width,\n            texture.height \/ threadGroupCount.height,\n            1\n        )\n\n        encoder.dispatchThreadgroups(threadGroups, threadsPerThreadgroup: threadGroupCount)\n        encoder.endEncoding()\n\n        commandBuffer.commit()\n        drawable.present()\n    }\n}\n```\n\nThe method sets up the encoder, then commits to the command buffer to submit the command buffer to run on the GPU. Lastly, it presents the updated texture to the renderer with the `present()` method.\n\n### Set up the torus model\n\nThe `EntityView` attempts to create the torus model by calling the `makeEntity()` method:\n\n```swift\nstruct EntityView: View {\n    \/\/\/ The value that controls which iteration of the texture the generator uses\n    var seed: Int\n\n    \/\/ ...\n\n    var body: some View {\n        RealityView { content in\n            do {\n                let entity = try makeEntity()\n                content.add(entity)\n            } catch {\n                print(\"Error creating entity: \\(error)\")\n            }\n        } update: { content in\n            for entity in content.entities {\n                if let modelEntitty = entity as? ModelEntity {\n                    try? updateEntity(modelEntitty)\n                } else {\n                    print(\"Entity is not a ModelEntity.\")\n                }\n            }\n        }\n    }\n}\n```\n\nThe `update` closure loops through all the entities in the reality view, and attempts to update the entity in scene updates.\n\nThe `makeEntity()` method marks the [doc:\/\/com.apple.documentation\/documentation\/Swift\/MainActor] to execute in the main dispatch queue:\n\n```swift\n@MainActor\nfunc makeEntity() throws -> ModelEntity {\n    let fileName: String = \"Torus\"\n    \n    \/\/\/ The 3D torus model.\n    let entity = try Entity.loadModel(named: fileName)\n    \n    \/\/ Set the scale of the entity with the bounding radius of the model's visible bounds.\n    entity.scale \/= entity.visualBounds(relativeTo: nil).boundingRadius\n\n    let scale: Float = 0.2\n    \n    \/\/ Apply the scale factor with the value of the scale variable.\n    entity.scale *= scale\n    \n    \/\/ Rotate the entity along the y-axis so that the entity faces the user.\n    entity.transform.rotation *= simd_quatf(from: SIMD3<Float>(0, 1, 0), to: SIMD3<Float>(0, 0, 1))\n\n    try updateEntity(entity)\n\n    return entity\n}\n```\n\nThe [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/Entity\/loadModel(named:in:)] method synchronously loads a 3D torus model, scales it to the proper size, and applies the `updateEntity()` method.\n\nThe `updateEntity()` method generates a new texture by passing the seed value into the `generate()` method, and creates a material sampler for the [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/PhysicallyBasedMaterial]:\n\n```swift\n@MainActor\nfunc updateEntity(_ entity: ModelEntity) throws {\n    \/\/\/ The texture based on the seed values.\n    guard let texture = ProceduralTextureGenerator.generate(seed) else {\n        return\n    }\n\n    \/\/\/ The texture of the sampler, to the nearest pixel.\n    var sampler = PhysicallyBasedMaterial.Texture.Sampler()\n    sampler.modify { $0.magFilter = .nearest }\n\n    \/\/\/ The material that simulates the appearance of real-world objects.\n    var material = PhysicallyBasedMaterial()\n\n    \/\/\/ The texture for the material.\n    let textureAndSampler = PhysicallyBasedMaterial.Texture(\n        texture,\n        sampler: sampler\n    )\n    material.baseColor = PhysicallyBasedMaterial.BaseColor(texture: textureAndSampler)\n\n    \/\/ Apply the material to the model of the entity.\n    entity.model?.materials = [material]\n\n    entity.components[DrawableQueueComponent.self] = try DrawableQueueComponent(texture: texture)\n}\n```\n\nThe method applies the material to the model of the entity, and attempts to set the `DrawableQueueComponent` to initalize the texture.\n\n### Set up the parent window\n\nThe `DrawableView` creates a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/State] `seed` property to control the randomization of the texture generator:\n\n```swift\nimport SwiftUI\n\nstruct DrawableView: View {\n    @State var seed: Int = 0\n\n    var body: some View {\n        HStack {\n            EntityView(seed: seed)\n\n            Divider()\n\n            Button(\"Regenerate\") { seed += 1 }\n        }.padding()\n    }\n}\n```\n\nUsing the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/HStack] makes it possible to call the `EntityView` that accepts `seed` and a button that increases the value of `seed` on each press.\n\n## Building materials\n\n- **Implementing adjustable material**: Update the adjustable parameters of a 3D model in visionOS.\n- **Displaying a stereoscopic image**: Build a stereoscopic image by applying textures to the left and right eye in a shader graph material.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Update the adjustable parameters of a 3D model in visionOS.",
          "name" : "Implementing adjustable material",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/implementing-adjustable-material-in-visionos"
        },
        {
          "description" : "Build a stereoscopic image by applying textures to the left and right eye in a shader graph material.",
          "name" : "Displaying a stereoscopic image",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/displaying-a-stereoscopic-image-in-visionos"
        }
      ],
      "title" : "Building materials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Generating procedural textures",
  "url" : "https:\/\/developer.apple.com\/documentation\/visionos\/generating-procedural-textures-in-visionos"
}