{
  "abstract" : "Use hand-tracking anchors to display a visual representation of hand transforms in visionOS.",
  "codeExamples" : [
    {
      "code" : "enum Finger: Int, CaseIterable {\n    case forearm\n    case thumb\n    case index\n    case middle\n    case ring\n    case little\n}\n\nenum Bone: Int, CaseIterable {\n    case arm\n    case wrist\n    case metacarpal\n    case knuckle\n    case intermediateBase\n    case intermediateTip\n    case tip\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Hand {\n    \/\/\/ The collection of joints in a hand.\n    static let joints: [(HandSkeleton.JointName, Finger, Bone)] = [\n        \/\/ Define the thumb bones.\n        (.thumbKnuckle, .thumb, .knuckle),\n        (.thumbIntermediateBase, .thumb, .intermediateBase),\n        (.thumbIntermediateTip, .thumb, .intermediateTip),\n        (.thumbTip, .thumb, .tip),\n\n        \/\/ ...\n\n        \/\/ Define wrist and arm bones.\n        (.forearmWrist, .forearm, .wrist),\n        (.forearmArm, .forearm, .arm)\n    ]\n}",
      "language" : "swift"
    },
    {
      "code" : "struct HandTrackingComponent: Component {\n    \/\/\/ The chirality for the hand this component tracks.\n    let chirality: AnchoringComponent.Target.Chirality\n\n    \/\/\/ A lookup that maps each joint name to the entity that represents it.\n    var fingers: [HandSkeleton.JointName: Entity] = [:]\n\n    \/\/\/ Creates a new hand-tracking component.\n    init(chirality: AnchoringComponent.Target.Chirality) {\n        self.chirality = chirality\n        HandTrackingSystem.registerSystem()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct HandTrackingSystem: System {\n    \/\/\/ The ARKit session for hand tracking.\n    private let arSession = ARKitSession()\n\n    \/\/\/ The provider instance for hand tracking.\n    private let handTracking = HandTrackingProvider()\n\n    \/\/\/ The most recent anchor that the provider detects on the left hand.\n    @State var latestLeftHand: HandAnchor?\n\n    \/\/\/ The most recent anchor that the provider detects on the right hand.\n    @State var latestRightHand: HandAnchor?\n\n    init(scene: RealityKit.Scene) {\n        Task { await Self.runSession() }\n    }\n\n    \/\/ ...\n}",
      "language" : "swift"
    },
    {
      "code" : "func runSession() {\n    Task {\n        do {\n            \/\/ Attempt to run the ARKit session with the hand-tracking provider.\n            try await arSession.run([handTracking])\n        } catch let error as ARKitSession.Error {\n            print(\"The app has encountered an error while running providers: \\(error.localizedDescription)\")\n        } catch let error {\n            print(\"The app has encountered an unexpected error: \\(error.localizedDescription)\")\n        }\n\n        \/\/ Start collecting each hand-tracking anchor.\n        for await anchorUpdate in handTracking.anchorUpdates {\n            \/\/ Check if the anchor is on the left or right hand.\n            switch anchorUpdate.anchor.chirality {\n            case .left:\n                self.latestLeftHand = anchorUpdate.anchor\n            case .right:\n                self.latestRightHand = anchorUpdate.anchor\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func addJoints(to handEntity: Entity, handComponent: inout HandTrackingComponent) {\n    \/\/\/ The size of the sphere mesh.\n    let radius: Float = 0.01\n\n    \/\/\/ The material to apply to the sphere entity.\n    let material = SimpleMaterial(color: .white, isMetallic: false)\n\n    \/\/\/ The sphere entity that represents a hand-tracking anchor.\n    let sphereEntity = ModelEntity(\n        mesh: .generateSphere(radius: radius),\n        materials: [material]\n    )\n\n    \/\/ For each anchor, create a sphere and attach it to the fingers.\n    for bone in Hand.joints {\n        let newJoint = sphereEntity.clone(recursive: false)\n        handEntity.addChild(newJoint)\n        handComponent.fingers[bone.0] = newJoint\n    }\n\n    \/\/ Apply the updated hand component back to the hand entity.\n    handEntity.components.set(handComponent)\n}",
      "language" : "swift"
    },
    {
      "code" : "struct HandTrackingSystem: System {\n    \/\/\/ The query this system uses to find all entities with the hand-tracking component.\n    static let query = EntityQuery(where: .has(HandTrackingComponent.self))\n\n    func update(context: SceneUpdateContext) {\n        let handEntities = context.entities(matching: Self.query, updatingSystemWhen: .rendering)\n\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "for entity in handEntities {\n    guard var handComponent = entity.components[HandTrackingComponent.self] else { continue }\n\n    \/\/ Set up the finger joint entities if you haven't yet.\n    if handComponent.fingers.isEmpty {\n        self.addJoints(to: entity, handComponent: &handComponent)\n    }\n\n    \/\/ Get the hand anchor for the component, depending on its chirality.\n    guard let handAnchor: HandAnchor = switch handComponent.chirality {\n        case .left: Self.latestLeftHand\n        case .right: Self.latestRightHand\n        default: nil\n    } else { continue }\n\n    \/\/ Iterate through all of the anchors on the hand skeleton.\n    if let handSkeleton = handAnchor.handSkeleton {\n        for (jointName, jointEntity) in handComponent.fingers {\n            \/\/\/ The current transform of the person's hand joint.\n            let anchorFromJointTransform = handSkeleton.joint(jointName).anchorFromJointTransform\n\n            \/\/ Update the joint entity to match the transform of the person's hand joint.\n            jointEntity.setTransformMatrix(\n                handAnchor.originFromAnchorTransform * anchorFromJointTransform,\n                relativeTo: nil\n            )\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct HandTrackingView: View {\n    \/\/\/ The main body of the view.\n    var body: some View {\n        RealityView { content in\n            content.add(makeHandEntities())\n        }\n    }\n\n    @MainActor\n    func makeHandEntities(in content: any RealityViewContentProtocol) {\n        \/\/ Add the left hand.\n        let leftHand = Entity()\n        leftHand.components.set(HandTrackingComponent(chirality: .left))\n        content.add(leftHand)\n\n        \/\/ Add the right hand.\n        let rightHand = Entity()\n        rightHand.components.set(HandTrackingComponent(chirality: .right))\n        content.add(rightHand)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "1623349d037100a90076d2f2774c8b6b88efe42544d4924c3b736812da1bc304",
  "crawledAt" : "2025-12-02T16:04:06Z",
  "id" : "B94600FE-7FAE-4D7E-9FFA-77A4F518EDF3",
  "kind" : "unknown",
  "language" : "swift",
  "overview" : "## Overview\n\nThis sample demonstrates tracking hand transforms in visionOS with the [doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandTrackingProvider] class, a type within [doc:\/\/com.apple.documentation\/documentation\/ARKit]. As the following video shows, the app displays a series of white spheres that affix themselves to each anchor point on a person’s hands and remain attached as the hands move:\n\nThe app achieves this effect by:\n\n### Define the hand-tracking anchors\n\n[doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandSkeleton\/JointName] contains a total of 26 hand-tracking anchors for each hand. To identify these anchors, the sample creates a series of `Finger` and `Bone` enumerations:\n\nThe sample also defines a `Hand` structure that stores data for joints in a hand:\n\n### Set up the hand tracker\n\nThe sample creates the `HandTrackingComponent` to track the entities of the left and right hand. It differentiates the left- and right-hand entities by configuring the component with a `chirality` value and registering it with the app’s `HandTrackingSystem` singleton instance:\n\nThe sample implements a custom system that tracks a person’s hands with a [doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandTrackingProvider] and stores them in the `latestLeftHand` and `latestRightHand` instances:\n\nOn initialization, the `HandTrackingSystem` starts a task that calls the `runSession()` method.\n\nThe `runSession()` method starts an [doc:\/\/com.apple.documentation\/documentation\/ARKit\/ARKitSession] with the [doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandTrackingProvider]:\n\nWhen the `handTracking.anchorUpdates` stream yields new hand data from ARKit, this async method updates the `latestLeftHand` and `latestRightHand` anchors accordingly.\n\n## Visualize the joints of a hand entity\n\nThe system also has an `addJoints(to:handComponent:)` method that adds a sphere entity to each anchor of a hand entity. The method starts by creating the sphere entity with the `radius` and `material` properties, then it adds the sphere entity to the hand entity and updates the `fingers` collection for each anchor in the `Hand` structure:\n\nThe [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/System] protocol has an [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/System\/update(context:)] method that the app calls for each scene update, to update its hand entities.\n\nThe app finds the hand entities for each scene update with an [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/EntityQuery] instance that retrieves entities with a hand-tracking component.\n\nThe system’s `update(context:)` method:\n\n### Create the left- and right-hand entities\n\nThe app adds hand-tracking entities to the content of the RealityKit view by calling `makeHandEntities(in:)`:\n\nThe `makeHandEntities(in:)` method creates the left- and right-hand entities, and adds a `HandTrackingComponent` instance, each with the chirality case that correlates to its hand.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/visionos\/tracking-and-visualizing-hand-movement\ncrawled: 2025-12-02T16:04:06Z\n---\n\n# Tracking and visualizing hand movement\n\n**Sample Code**\n\nUse hand-tracking anchors to display a visual representation of hand transforms in visionOS.\n\n## Overview\n\nThis sample demonstrates tracking hand transforms in visionOS with the [doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandTrackingProvider] class, a type within [doc:\/\/com.apple.documentation\/documentation\/ARKit]. As the following video shows, the app displays a series of white spheres that affix themselves to each anchor point on a person’s hands and remain attached as the hands move:\n\n\n\nThe app achieves this effect by:\n\n1. Creating a hand entity\n2. Placing white spheres on each hand-tracking anchor\n3. Tracking the person’s hand to update the hand entity’s position and orientation\n\n### Define the hand-tracking anchors\n\n[doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandSkeleton\/JointName] contains a total of 26 hand-tracking anchors for each hand. To identify these anchors, the sample creates a series of `Finger` and `Bone` enumerations:\n\n```swift\nenum Finger: Int, CaseIterable {\n    case forearm\n    case thumb\n    case index\n    case middle\n    case ring\n    case little\n}\n\nenum Bone: Int, CaseIterable {\n    case arm\n    case wrist\n    case metacarpal\n    case knuckle\n    case intermediateBase\n    case intermediateTip\n    case tip\n}\n```\n\nThe sample also defines a `Hand` structure that stores data for joints in a hand:\n\n```swift\nstruct Hand {\n    \/\/\/ The collection of joints in a hand.\n    static let joints: [(HandSkeleton.JointName, Finger, Bone)] = [\n        \/\/ Define the thumb bones.\n        (.thumbKnuckle, .thumb, .knuckle),\n        (.thumbIntermediateBase, .thumb, .intermediateBase),\n        (.thumbIntermediateTip, .thumb, .intermediateTip),\n        (.thumbTip, .thumb, .tip),\n\n        \/\/ ...\n\n        \/\/ Define wrist and arm bones.\n        (.forearmWrist, .forearm, .wrist),\n        (.forearmArm, .forearm, .arm)\n    ]\n}\n```\n\n### Set up the hand tracker\n\nThe sample creates the `HandTrackingComponent` to track the entities of the left and right hand. It differentiates the left- and right-hand entities by configuring the component with a `chirality` value and registering it with the app’s `HandTrackingSystem` singleton instance:\n\n```swift\nstruct HandTrackingComponent: Component {\n    \/\/\/ The chirality for the hand this component tracks.\n    let chirality: AnchoringComponent.Target.Chirality\n\n    \/\/\/ A lookup that maps each joint name to the entity that represents it.\n    var fingers: [HandSkeleton.JointName: Entity] = [:]\n\n    \/\/\/ Creates a new hand-tracking component.\n    init(chirality: AnchoringComponent.Target.Chirality) {\n        self.chirality = chirality\n        HandTrackingSystem.registerSystem()\n    }\n}\n```\n\nThe sample implements a custom system that tracks a person’s hands with a [doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandTrackingProvider] and stores them in the `latestLeftHand` and `latestRightHand` instances:\n\n```swift\nstruct HandTrackingSystem: System {\n    \/\/\/ The ARKit session for hand tracking.\n    private let arSession = ARKitSession()\n\n    \/\/\/ The provider instance for hand tracking.\n    private let handTracking = HandTrackingProvider()\n\n    \/\/\/ The most recent anchor that the provider detects on the left hand.\n    @State var latestLeftHand: HandAnchor?\n\n    \/\/\/ The most recent anchor that the provider detects on the right hand.\n    @State var latestRightHand: HandAnchor?\n\n    init(scene: RealityKit.Scene) {\n        Task { await Self.runSession() }\n    }\n\n    \/\/ ...\n}\n```\n\nOn initialization, the `HandTrackingSystem` starts a task that calls the `runSession()` method.\n\n\n\nThe `runSession()` method starts an [doc:\/\/com.apple.documentation\/documentation\/ARKit\/ARKitSession] with the [doc:\/\/com.apple.documentation\/documentation\/ARKit\/HandTrackingProvider]:\n\n```swift\nfunc runSession() {\n    Task {\n        do {\n            \/\/ Attempt to run the ARKit session with the hand-tracking provider.\n            try await arSession.run([handTracking])\n        } catch let error as ARKitSession.Error {\n            print(\"The app has encountered an error while running providers: \\(error.localizedDescription)\")\n        } catch let error {\n            print(\"The app has encountered an unexpected error: \\(error.localizedDescription)\")\n        }\n\n        \/\/ Start collecting each hand-tracking anchor.\n        for await anchorUpdate in handTracking.anchorUpdates {\n            \/\/ Check if the anchor is on the left or right hand.\n            switch anchorUpdate.anchor.chirality {\n            case .left:\n                self.latestLeftHand = anchorUpdate.anchor\n            case .right:\n                self.latestRightHand = anchorUpdate.anchor\n            }\n        }\n    }\n}\n```\n\nWhen the `handTracking.anchorUpdates` stream yields new hand data from ARKit, this async method updates the `latestLeftHand` and `latestRightHand` anchors accordingly.\n\n## Visualize the joints of a hand entity\n\nThe system also has an `addJoints(to:handComponent:)` method that adds a sphere entity to each anchor of a hand entity. The method starts by creating the sphere entity with the `radius` and `material` properties, then it adds the sphere entity to the hand entity and updates the `fingers` collection for each anchor in the `Hand` structure:\n\n```swift\nfunc addJoints(to handEntity: Entity, handComponent: inout HandTrackingComponent) {\n    \/\/\/ The size of the sphere mesh.\n    let radius: Float = 0.01\n\n    \/\/\/ The material to apply to the sphere entity.\n    let material = SimpleMaterial(color: .white, isMetallic: false)\n\n    \/\/\/ The sphere entity that represents a hand-tracking anchor.\n    let sphereEntity = ModelEntity(\n        mesh: .generateSphere(radius: radius),\n        materials: [material]\n    )\n\n    \/\/ For each anchor, create a sphere and attach it to the fingers.\n    for bone in Hand.joints {\n        let newJoint = sphereEntity.clone(recursive: false)\n        handEntity.addChild(newJoint)\n        handComponent.fingers[bone.0] = newJoint\n    }\n\n    \/\/ Apply the updated hand component back to the hand entity.\n    handEntity.components.set(handComponent)\n}\n```\n\nThe [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/System] protocol has an [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/System\/update(context:)] method that the app calls for each scene update, to update its hand entities.\n\n\n\nThe app finds the hand entities for each scene update with an [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/EntityQuery] instance that retrieves entities with a hand-tracking component.\n\n```swift\nstruct HandTrackingSystem: System {\n    \/\/\/ The query this system uses to find all entities with the hand-tracking component.\n    static let query = EntityQuery(where: .has(HandTrackingComponent.self))\n\n    func update(context: SceneUpdateContext) {\n        let handEntities = context.entities(matching: Self.query, updatingSystemWhen: .rendering)\n\n        \/\/ ...\n    }\n}\n```\n\nThe system’s `update(context:)` method:\n\n1. Sets up hand-tracking anchors for each hand entity with the `addJoints(to:handComponent:)` method\n2. Determines the hand’s anchor based on the chirality of the entity’s hand component\n3. Updates the transform of the joints entity to match the transform of a person’s hand joint that ARKit detects\n\n```swift\nfor entity in handEntities {\n    guard var handComponent = entity.components[HandTrackingComponent.self] else { continue }\n\n    \/\/ Set up the finger joint entities if you haven't yet.\n    if handComponent.fingers.isEmpty {\n        self.addJoints(to: entity, handComponent: &handComponent)\n    }\n\n    \/\/ Get the hand anchor for the component, depending on its chirality.\n    guard let handAnchor: HandAnchor = switch handComponent.chirality {\n        case .left: Self.latestLeftHand\n        case .right: Self.latestRightHand\n        default: nil\n    } else { continue }\n\n    \/\/ Iterate through all of the anchors on the hand skeleton.\n    if let handSkeleton = handAnchor.handSkeleton {\n        for (jointName, jointEntity) in handComponent.fingers {\n            \/\/\/ The current transform of the person's hand joint.\n            let anchorFromJointTransform = handSkeleton.joint(jointName).anchorFromJointTransform\n\n            \/\/ Update the joint entity to match the transform of the person's hand joint.\n            jointEntity.setTransformMatrix(\n                handAnchor.originFromAnchorTransform * anchorFromJointTransform,\n                relativeTo: nil\n            )\n        }\n    }\n}\n```\n\n### Create the left- and right-hand entities\n\nThe app adds hand-tracking entities to the content of the RealityKit view by calling `makeHandEntities(in:)`:\n\n```swift\nstruct HandTrackingView: View {\n    \/\/\/ The main body of the view.\n    var body: some View {\n        RealityView { content in\n            content.add(makeHandEntities())\n        }\n    }\n\n    @MainActor\n    func makeHandEntities(in content: any RealityViewContentProtocol) {\n        \/\/ Add the left hand.\n        let leftHand = Entity()\n        leftHand.components.set(HandTrackingComponent(chirality: .left))\n        content.add(leftHand)\n\n        \/\/ Add the right hand.\n        let rightHand = Entity()\n        rightHand.components.set(HandTrackingComponent(chirality: .right))\n        content.add(rightHand)\n    }\n}\n```\n\nThe `makeHandEntities(in:)` method creates the left- and right-hand entities, and adds a `HandTrackingComponent` instance, each with the chirality case that correlates to its hand.\n\n## Integrating ARKit\n\n- **Creating a 3D painting space**: Implement a painting canvas entity, and update its mesh to represent a stroke.\n- **Displaying an entity that follows a person’s view**: Create an entity that tracks and follows head movement in an immersive scene.\n- **Applying mesh to real-world surroundings**: Add a layer of mesh to objects in the real world, using scene reconstruction in ARKit.\n- **Obscuring virtual items in a scene behind real-world items**: Increase the realism of an immersive experience by adding entities with invisible materials  real-world objects.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Implement a painting canvas entity, and update its mesh to represent a stroke.",
          "name" : "Creating a 3D painting space",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/creating-a-painting-space-in-visionos"
        },
        {
          "description" : "Create an entity that tracks and follows head movement in an immersive scene.",
          "name" : "Displaying an entity that follows a person’s view",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/displaying-a-3D-object-that-moves-to-stay-in-a-person's-view"
        },
        {
          "description" : "Add a layer of mesh to objects in the real world, using scene reconstruction in ARKit.",
          "name" : "Applying mesh to real-world surroundings",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/applying-mesh-to-real-world-surroundings"
        },
        {
          "description" : "Increase the realism of an immersive experience by adding entities with invisible materials  real-world objects.",
          "name" : "Obscuring virtual items in a scene behind real-world items",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/obscuring-virtual-items-in-a-scene-behind-real-world-items"
        }
      ],
      "title" : "Integrating ARKit"
    }
  ],
  "source" : "appleJSON",
  "title" : "Tracking and visualizing hand movement",
  "url" : "https:\/\/developer.apple.com\/documentation\/visionos\/tracking-and-visualizing-hand-movement"
}