{
  "abstract" : "Create a hike planning app using SwiftUI and RealityKit.",
  "codeExamples" : [

  ],
  "contentHash" : "1a682c4003e404372ddfeba87e2e1f38abdb91fc7af9e2e3af7cc0bb84f45b93",
  "crawledAt" : "2025-12-02T15:27:06Z",
  "declaration" : {
    "code" : "let trailheadNamePositioningEntity = addBillboardingPositioningEntity(\n    for: trailNameAttachment,\n    offset: SIMD3<Float>(x: 0, y: 1.1, z: 0),\n    relativeTo: trailheadEntity\n)\ntrailheadNamePositioningEntity.scale = 1.0 \/ trailheadEntity.scale(relativeTo: nil)",
    "language" : "swift"
  },
  "id" : "19CA73DD-34C7-4833-BE8B-1E7D599B9D71",
  "kind" : "unknown",
  "overview" : "visionOS  Canyon Crosser: Building a volumetric hike-planning app  Canyon Crosser: Building a volumetric hike-planning app Sample CodeCanyon Crosser: Building a volumetric hike-planning appCreate a hike planning app using SwiftUI and RealityKit. Download visionOS 26.0+Xcode 26.0+OverviewCanyon Crosser is a volumetric app that allows people to plan a hike through a historic trail in Grand Canyon National Park. As hiking in the desert revolves around temperature, the app allows people to see the predicted temperatures and plan rest stops and departure time accordingly.\n\nCanyon Crosser shows off a number of RealityKit and visionOS features, including spatial layout, RealityKit and SwiftUI interoperability, and dynamic bounds extensions for volumes.\n\nCanyon Crosser uses RealityKit to present 3D models and SwiftUI to present standard user interface elements like buttons and pickers. The app uses Reality Composer Pro to manage the models and lighting effects.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app\ncrawled: 2025-12-02T15:27:06Z\n---\n\n# Canyon Crosser: Building a volumetric hike-planning app | Apple Developer Documentation\n\n- [ visionOS ](\/documentation\/visionos)\n\n- [ Canyon Crosser: Building a volumetric hike-planning app ](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app)\n\n-  Canyon Crosser: Building a volumetric hike-planning app \n\nSample Code# Canyon Crosser: Building a volumetric hike-planning app\n\nCreate a hike planning app using SwiftUI and RealityKit.[ Download ](https:\/\/docs-assets.developer.apple.com\/published\/1f9ab812f406\/CanyonCrosser.zip)visionOS 26.0+Xcode 26.0+## [Overview](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#Overview)\n\nCanyon Crosser is a volumetric app that allows people to plan a hike through a historic trail in Grand Canyon National Park. As hiking in the desert revolves around temperature, the app allows people to see the predicted temperatures and plan rest stops and departure time accordingly.\n\nCanyon Crosser shows off a number of [RealityKit](\/documentation\/RealityKit) and visionOS features, including spatial layout, RealityKit and [SwiftUI](\/documentation\/SwiftUI) interoperability, and dynamic bounds extensions for volumes.\n\n Video with custom controls.  Content description: A video showing the Bright Angel Trail hike being started and a hiker starting to move down the trail. [ Play ](#)Canyon Crosser uses RealityKit to present 3D models and SwiftUI to present standard user interface elements like buttons and pickers. The app uses Reality Composer Pro to manage the models and lighting effects.\n\nCanyon Crosser demonstrates the use of several visionOS APIs:\n\n- **Spatial Layout** — Demonstrates techniques for positioning 2D and 3D content in a volume.\n\n- **Framework Interoperability** — Illustrates how to add SwiftUI views to entities in a [`RealityView`](\/documentation\/RealityKit\/RealityView).\n\n- **Observable Entities** — Shows how to dynamically update and observe changes on RealityKit entities.\n\n- **Dynamic Bounds Restriction** — Shows how to render content outside the bounds of the volumetric window.\n\n## [Use spatial layout to create a carousel](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#Use-spatial-layout-to-create-a-carousel)\n\nAfter launching Canyon Crosser, the app displays a volumetric window featuring a carousel of landmarks. This carousel allows people to select a virtual hiking destination. While all landmarks are tappable in this example, they currently all lead to the Grand Canyon experience.\n\n Video with custom controls.  Content description: A screenshot that shows all five landmarks in a carousel, with the foremost one being the Grand Canyon. [ Play ](#)Canyon Crosser takes advantage of spatial layout to implement the carousel by using a combination of depth layouts and 3D rotations. To position the landmark models and the carousel base at the bottom of the volume, it uses a [`VStackLayout`](\/documentation\/SwiftUI\/VStackLayout) with a depth alignment of `.center` and a [`Spacer`](\/documentation\/SwiftUI\/Spacer).\n\nThe app uses a custom [`Layout`](\/documentation\/SwiftUI\/Layout) implementation, named `RadialLayout`, to arrange the individual landmark items in a circle. To present the carousel horizontally, the entire `RadialLayout` is rotated 90 degrees around the x-axis using\n\n\n\n```\n.rotation3DLayout(Rotation3D(angle: .degrees(90), axis: .x)))\n\n```\n\nBecause the models initially load upright, they counter-rotate with [`rotation3DLayout(_:)`](\/documentation\/SwiftUI\/View\/rotation3DLayout(_:)) by -90 degrees to compensate.\n\nCanyon Crosser uses the following to create the carousel:\n\n\n\n```\nVStackLayout(spacing: 0).depthAlignment(.center) {\n    \/\/ Pushes the content to the baseplate of the volume.\n    Spacer()\n    \/\/ A radial custom layout.\n    RadialLayout(angleOffset: angleOffset) {\n        ForEach(Array(zip(0..., $carouselModel.items)), id: .1.id) { (index, $item) in\n            \/\/ The view that contains each landmark.\n            LandmarkItemView(item: item)\n                \/\/ Set the opacity based on the z position of the item.\n                \/\/ The closer to the front of the carousel, the more opaque it is.\n                .opacity(1 - carouselModel.normalizedZPosition[index])\n                    \n                \/\/ Rotate the item by -90 degrees over the x-axis to account for the rotation of the entire `RadialLayout`.\n                .rotation3DLayout(Rotation3D(angle: .degrees(-90), axis: .x))\n                    \n                .onGeometryChange3D(for: Rect3D.self) { proxy in\n                    proxy.frame(in: .global)\n                } action: { newValue in\n                    localZPosition = backOfVolume.z - newValue.origin.z\n                    item.zPosition = localZPosition\n                }\n        }\n    }\n    \/\/ Rotates the radial layout to be horizontal instead of vertical.\n    .rotation3DLayout(Rotation3D(angle: .degrees(90), axis: .x))\n    \n    CarouselPlatter()\n}\n\n```\n\nNote\n\nFor a deeper dive into spatial layouts, watch the WWDC25 session, [Meet SwiftUI spatial layout](https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/273). For more information on building custom layouts, watch the WWDC22 session, [Compose custom layouts with SwiftUI](https:\/\/developer.apple.com\/videos\/play\/wwdc2022\/10056).\n\nThe app uses a front depth alignment to place the label at the front of the carousel.\n\n\n\n```\nVStackLayout(spacing: 20).depthAlignment(.front) {\n    \/\/ The rotational layout and bottom platter.\n   CarouselBodyView(angleOffset: angleOffset, backOfVolume: backOfVolume)\n        .environment(carouselModel)\n   CarouselLabelView()\n        .environment(carouselModel)\n}\n\n```\n\n## [Present SwiftUI views from a volume](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#Present-SwiftUI-views-from-a-volume)\n\nAfter selecting a landmark, three named trailhead markers appear for the Grand Canyon. The trailhead names appear above the marker at the top of the trail. Each trailhead has a sub-entity that has a [`ViewAttachmentComponent`](\/documentation\/RealityKit\/ViewAttachmentComponent). The `ViewAttachmentComponent` attaches SwiftUI views to entities.\n\nIt often makes sense to present views directly from an entity. However, sometimes it may be better to offset the presentation of views from the presenting entity. Canyon Crosser uses a descendant entity to present the view from the desired location:\n\n\n\n```\nprivate func addBillboardingPositioningEntity(\n    for viewComponent: Component, \n    offset: SIMD3<Float>, \n    relativeTo entity: Entity\n) -> Entity {\n    let positioningEntity = Entity()\n    positioningEntity.position = offset\n    positioningEntity.name = entity.name + \".positioningEntity\"\n    positioningEntity.components.set([viewComponent, BillboardComponent()])\n    entity.addChild(positioningEntity)\n    return positioningEntity\n}\n\n```\n\n`ViewComponentAttachment` also respects the scale of its parent entity. If the parent entity doesn’t inherit a large scale factor this is the desired behavior. If the entity’s hierarchy has a scale factor other than `1.0`, invert the scale factor to make sure the attachment is legible:\n\n\n\n```\nlet trailheadNamePositioningEntity = addBillboardingPositioningEntity(\n    for: trailNameAttachment,\n    offset: SIMD3<Float>(x: 0, y: 1.1, z: 0),\n    relativeTo: trailheadEntity\n)\ntrailheadNamePositioningEntity.scale = 1.0 \/ trailheadEntity.scale(relativeTo: nil)\n\n```\n\n\n\nUse [`PresentationComponent`](\/documentation\/RealityKit\/PresentationComponent) to present a SwiftUI view as a popover. The component has an `isPresented` property that controls the popover’s visibility. The popover presents modally, similar to popovers on other platforms.\n\n\n\n```\nvar trailHeadPopover = PresentationComponent(\n    configuration: .popover(arrowEdge: .bottom),\n    content: HikeDetailView(hike: hike)\n)\ntrailHeadPopover.isPresented = false\n\n\nlet trailheadPopoverPositioningEntity = addBillboardingPositioningEntity(\n    for: trailHeadPopover,\n    offset: SIMD3<Float>(0.0, 1.4, 0.0),\n    relativeTo: trailheadEntity\n)\n\n```\n\n\n\nNote\n\nThere’s no need to apply an inverse scale to this entity because popovers use the dynamic scaling built into visionOS.\n\nChoosing “Hike This Trail” activates the UI to allow people to interact with the hike. Each hike consists of the route for that hike and one entity for each rest stop along the trail. After selecting a hike, the entities activate. Conversely, the entities deactivate when the person deselects a hike. After selecting a hike, Canyon Crosser displays a toolbar that includes elements for modifying the hike. For example, Canyon Crosser lets people set the hike’s start and stop time, and they can drag a slider to locations along the hike’s path.\n\n## [Use observable entities and components for dynamic updates](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#Use-observable-entities-and-components-for-dynamic-updates)\n\nSwiftUI views can react to changes in components attached to an [`Observable`](\/documentation\/Observation\/Observable) entity to drive dynamic updates throughout the app.\n\nNote\n\nFor a comprehensive introduction to observable entities, watch [Better together: SwiftUI and RealityKit](https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/274).\n\nCanyon Crosser observes the hiker entity to keep several SwiftUI views up to date. There are four key components on the entity that update different parts of the UI:\n\n- `HikeTimingComponent` — Manages hike speed, arrival, and departure times.\n\n- `HikerProgressComponent` — Tracks the hiker’s progress along the trail.\n\n- `HikeDragStateComponent` — Controls the hiker’s drag state during user interaction.\n\n- `HikePlaybackStateComponent` — Manages the hike’s playback state for playing and pausing a hike.\n\nThe `HikerProgressComponent` is central to updating many parts of the app as the hiker moves. Whenever a property within this component changes, all views observing it are automatically updated. For example, the `HikeProgress` system updates the hiker’s progress:\n\n\n\n```\nprogressComponent.hikeProgress = min(1.0, progressComponent.hikeProgress + Float(deltaProgress))\n\n```\n\nThis modification to `hikeProgress` triggers updates in any view observing this component. The `SliderThumb` view, for example, observes this property to update its position along the slider track and adjust its visual effects based on the hiker’s location.\n\nThe `GrandCanyonView` also observes the `hikeProgress` value. As the observed value changes, RealityKit notifies the `update:` block on the contained `RealityView` of the change and updates the entities related to the lighting of the canyon:\n\n\n\n```\nsetSunlight(\n    for: calculateTimeOfDay(from: appModel.hikerProgressComponent.hikeProgress),\n    shouldAnimateChange: appModel.shouldAnimateSunlightChange\n)\n\n```\n\nUsing an observable entity property in the `update:` block registers the `RealityView` to update when the property changes. The implementation of `appModel.hikerProgressComponent` enables observation on the entity:\n\n\n\n```\nvar hikerProgressComponent: HikerProgressComponent {\n    get {\n        guard \n            let component = hikerEntity.observable.components[HikerProgressComponent.self] \n        else { fatalError() }\n\n\n        return component\n    }\n    set { hikerEntity.observable.components[HikerProgressComponent.self] = newValue }\n}\n\n```\n\nThe getter uses the `observable` property on the entity so any reference to this property registers the observation. Canyon Crosser relies on observable entities to synchronize the hiker’s movement with various aspects of the app, including UI updates and environmental changes.\n\nImportant\n\nModifying any variable within an observable component causes the entire component to update. Carefully consider the scope of your components to optimize performance. Also avoid observing and modifying the same variable within a component in the same view to prevent infinite loops.\n\nThe best places to modify observable properties are in a custom system, a gesture closure, or the `make: ` closure of your [`RealityView`](\/documentation\/RealityKit\/RealityView). Avoid modifying observable properties in view bodies or the `update: ` closure. The `make: ` closure of a RealityView differs from the `update: ` closure in that it doesn’t create a dependency when you access an observable property and doesn’t re-run on changes to the property.\n\n## [Request additional margins for drawing beyond the volume’s bounds](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#Request-additional-margins-for-drawing-beyond-the-volumes-bounds)\n\nUse the [`preferredWindowClippingMargins(_:_:)`](\/documentation\/SwiftUI\/View\/preferredWindowClippingMargins(_:_:)) view modifier to request additional margins for drawing beyond the bounds of the window. This modifies the system behavior allowing you to display content that extends beyond the volume’s bounds.\n\nCanyon Crosser uses this API to request additional space at the leading and trailing edges to draw the clouds as they come into the volume. To read the value of the window clipping margins, use the [`windowClippingMargins`](\/documentation\/SwiftUI\/EnvironmentValues\/windowClippingMargins) environment variable. Monitor for changes of this environment value to update the app as needed:\n\n\n\n```\n.onChange(of: windowClippingMargins) { _, newValue in\n    appModel.clippingMarginEnvironment.clippingMargins = physicalMetrics.convert(edges: windowClippingMargins, to: .meters)\n}\n\n```\n\nIn Canyon Crosser, the clipping margins are saved to the `ClippingMarginPercentageComponent`. The `FeatherSystem` reads these values and applies them to all entities that have a `FadingCloudComponent`. The system provides these properties to a shader graph material that uses them to fade out the clouds as the reach the edge of the clipping margins.\n\nNote\n\nFor more details, watch the WWDC25 session, [Set the scene with SwiftUI in visionOS](https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/290).\n\n## [Related videos](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#Related-videos)\n\n[ Better together: SwiftUI and RealityKit ](https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/274)[ Compose custom layouts with SwiftUI ](https:\/\/developer.apple.com\/videos\/play\/wwdc2022\/10056)[ Meet SwiftUI spatial layout ](https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/273)[ Set the scene with SwiftUI in visionOS ](https:\/\/developer.apple.com\/videos\/play\/wwdc2025\/290)## [See Also](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#see-also)\n\n### [SwiftUI](\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app#SwiftUI)\n\n[Hello World](\/documentation\/visionos\/world)Use windows, volumes, and immersive spaces to teach people about the Earth.[Presenting windows and spaces](\/documentation\/visionos\/presenting-windows-and-spaces)Open and close the scenes that make up your app’s interface.[Positioning and sizing windows](\/documentation\/visionos\/positioning-and-sizing-windows)Influence the initial geometry of windows that your app presents.[Adopting best practices for persistent UI](\/documentation\/visionos\/adopting-best-practices-for-scene-restoration)Create persistent and contextually relevant spatial experiences by managing scene restoration, customizing window behaviors, and surface snapping data.",
  "sections" : [
    {
      "content" : "",
      "title" : "Overview"
    },
    {
      "content" : "",
      "title" : "Use spatial layout to create a carousel"
    },
    {
      "content" : "",
      "title" : "Present SwiftUI views from a volume"
    },
    {
      "content" : "",
      "title" : "Use observable entities and components for dynamic updates"
    },
    {
      "content" : "",
      "title" : "Request additional margins for drawing beyond the volume’s bounds"
    },
    {
      "content" : "",
      "title" : "Related videos"
    },
    {
      "content" : "",
      "title" : "See Also"
    }
  ],
  "source" : "appleWebKit",
  "title" : "Canyon Crosser: Building a volumetric hike-planning app | Apple Developer Documentation",
  "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/canyon-crosser-building-a-volumetric-hike-planning-app"
}