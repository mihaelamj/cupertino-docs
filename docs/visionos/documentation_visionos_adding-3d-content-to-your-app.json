{
  "abstract" : "Add depth and dimension to your visionOS app and discover how to incorporate your app’s content into a person’s surroundings.",
  "codeExamples" : [
    {
      "code" : " struct SphereView: View {\n    var body: some View {\n        RealityView { content in\n            let model = ModelEntity(\n                         mesh: .generateSphere(radius: 0.1),\n                         materials: [SimpleMaterial(color: .white, isMetallic: true)])\n            content.add(model)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct SphereView: View {\n    var scale = false\n\n    var body: some View {\n        RealityView { content in\n            let model = ModelEntity(\n                         mesh: .generateSphere(radius: 0.1),\n                         materials: [SimpleMaterial(color: .white, isMetallic: true)])\n            content.add(model)\n        } update: { content in\n            if let model = content.entities.first {\n                model.transform.scale = scale ? [1.2, 1.2, 1.2] : [1.0, 1.0, 1.0]\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct SphereView: View {\n    @State private var scale = false\n\n    var body: some View {\n        RealityView { content in\n            let model = ModelEntity(\n                mesh: .generateSphere(radius: 0.1),\n                materials: [SimpleMaterial(color: .white, isMetallic: true)])\n\n            \/\/ Enable interactions on the entity.\n            model.components.set(InputTargetComponent())\n            model.components.set(CollisionComponent(shapes: [.generateSphere(radius: 0.1)]))\n            content.add(model)\n        } update: { content in\n            if let model = content.entities.first {\n                model.transform.scale = scale ? [1.2, 1.2, 1.2] : [1.0, 1.0, 1.0]\n            }\n        }\n        .gesture(TapGesture().targetedToAnyEntity().onEnded { _ in\n            scale.toggle()\n        })\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            Model3D(\"balloons\")\n        }.windowStyle(style: .volumetric)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@main\nstruct MyImmersiveApp: App {\n    var body: some Scene {\n        WindowGroup() {\n            ContentView()\n        }\n\n        ImmersiveSpace(id: \"solarSystem\") {\n            SolarSystemView()\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "Button(\"Show Solar System\") {\n    Task {\n        let result = await openImmersiveSpace(id: \"solarSystem\")\n        if case .error = result {\n            print(\"An error occurred\")\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "524f8daa68d79d61429b9e9b984084888d62d32c021792606295498f31cba118",
  "crawledAt" : "2025-12-02T16:03:33Z",
  "id" : "DBFE0738-471C-47A4-A375-2588931F75F0",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nA device with a stereoscopic display lets people experience 3D content in a way that feels more real. Content appears to have real depth, and people can view it from different angles, making it seem like it’s there in front of them.\n\nWhen building an app for visionOS, think about ways you might add depth to your app’s interface. The system provides several ways to display 3D content, including in your existing windows, in a volume, and in an immersive space. Choose the options that work best for your app and the content you offer.\n\n### Add depth to traditional 2D windows\n\nWindows are an important part of your app’s interface. With visionOS, apps automatically get materials with the visionOS look and feel, fully resizable windows with spacing tuned for eyes and hands input, and access to highlighting adjustments for your custom controls.\n\nIncorporate depth effects into your custom views as needed, and use 3D layout options to arrange views in your windows.\n\nIn addition to giving 2D views more depth, you can also add static 3D models to your 2D windows. The `Model3D` view loads a USDZ file or other asset type and displays it at its intrinsic size in your window. Use this in places where you already have the model data in your app, or can download it from the network. For example, a shopping app might use this type of view to display a 3D version of a product.\n\n### Display dynamic 3D scenes using RealityKit\n\nRealityKit is Apple’s technology for building 3D models and scenes that you update dynamically onscreen. In visionOS, use RealityKit and SwiftUI together to seamlessly couple your app’s 2D and 3D content. Load existing USDZ assets or create scenes in Reality Composer Pro that incorporate animation, physics, lighting, sounds, and custom behaviors for your content. To use a Reality Composer Pro project in your app, add the Swift package to your Xcode project and import its module in your Swift file. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/managing-files-and-folders-in-your-xcode-project].\n\n\n\nWhen you’re ready to display 3D content in your interface, use a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView]. This SwiftUI view serves as a container for your RealityKit content, and lets you update that content using familiar SwiftUI techniques.\n\nThe following example shows a view that uses a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView] to display a 3D sphere. The code in the view’s closure creates a RealityKit entity for the sphere, applies a texture to the surface of the sphere, and adds the sphere to the view’s content.\n\nWhen SwiftUI displays your [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView], it executes your code once to create the entities and other content. Because creating entities is relatively expensive, the view runs your creation code only once. When you want to update the state of your entities, change the state of your view and use an update closure to apply those changes to your content. The following example uses an update closure to change the size of the sphere when the value in the `scale` property changes:\n\nFor information about how to create content using RealityKit, see [doc:\/\/com.apple.documentation\/documentation\/RealityKit].\n\n### Respond to interactions with RealityKit content\n\nTo handle interactions with the entities of your RealityKit scenes:\n\nThe [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Gesture\/targetedToAnyEntity()] modifier provides a bridge between the gesture recognizer and your RealityKit content. For example, to recognize when someone drags an entity, specify a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/DragGesture] and add the modifier to it. When the specified gesture occurs on an entity, SwiftUI executes the provided closure.\n\nThe following example adds a tap gesture recognizer to the sphere view from the previous example. The code also adds [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/InputTargetComponent] and [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/CollisionComponent] components to the shape to allow the interactions to occur. If you omit these components, the view doesn’t detect the interactions with your entity.\n\n### Display 3D content in a volume\n\nA volume is a type of window that grows in three dimensions to match the size of the content it contains. Windows and volumes both accommodate 2D and 3D content, and are alike in many ways. However, windows clip 3D content that extends too far from the window’s surface, so volumes are the better choice for content that is primarily 3D.\n\nTo create a volume, add a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowGroup] scene to your app and set its style to [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowStyle\/volumetric]. This style tells SwiftUI to create a window for 3D content. Include any 2D or 3D views you want in your volume. You can also add a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView] to build your content using RealityKit. The following example creates a volume with a static 3D model of some balloons stored in the app’s bundle:\n\nWindows and volumes are a convenient way to display bounded 2D and 3D content, but your app doesn’t control the placement of that content in the person’s surroundings. The system sets the initial position of each window and volume at display time. The system also adds a window bar to allow someone to reposition the window or resize it.\n\n\n\nFor more information about when to use volumes, see [doc:\/\/com.apple.documentation\/design\/Human-Interface-Guidelines\/windows#visionOS].\n\n### Display 3D content in a person’s surroundings\n\nWhen you need more control over the placement of your app’s content, add that content to an [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace]. An immersive space offers an unbounded area for your content, and you control the size and placement of content within the space. After receiving permission from the user, you can also use ARKit with an immersive space to integrate content into their surroundings. For example, you can use ARKit scene reconstruction to obtain a mesh of furniture and nearby objects and have your content interact with that mesh.\n\nAn [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace] is a scene type that you create alongside your app’s other scenes. The following example shows an app that contains an immersive space and a window:\n\nIf you don’t add a style modifier to your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace] declaration, the system creates that space using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersionStyle\/mixed] style. This style displays your content together with the passthrough content that shows the person’s surroundings. Other styles let you hide passthrough to varying degrees. Use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/immersionStyle(selection:in:)] modifier to specify which styles your space supports. If you specify more than one style, you can toggle between the styles using the `selection` parameter of the modifier.\n\nRemember to set the position of items you place in an [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace]. Position SwiftUI views using modifiers, and position a RealityKit entity using its transform component. SwiftUI places the origin of a space at a person’s feet initially, but can change this origin in response to other events. For example, the system might shift the origin to accommodate a SharePlay activity that displays your content with Spatial Personas. If you need to position SwiftUI views and RealityKit entities relative to one another, perform any needed coordinate conversions using the methods in the `content` parameter of [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView].\n\nTo display your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace] scene, open it using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/openImmersiveSpace] action, which you obtain from the SwiftUI environment. This action runs asynchronously and uses the provided information to find and initialize your scene. The following example shows a button that opens the space with the `solarSystem` identifier:\n\nWhen an app presents an [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace], the system hides the content of other apps to prevent visual conflicts. The other apps remain hidden while your space is visible but return when you dismiss it. If your app defines multiple spaces, you must dismiss the currently visible space before displaying a different space. If you don’t dismiss the visible space, the system issues a runtime warning when you try to open the other space.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/visionos\/adding-3d-content-to-your-app\ncrawled: 2025-12-02T16:03:33Z\n---\n\n# Adding 3D content to your app\n\n**Article**\n\nAdd depth and dimension to your visionOS app and discover how to incorporate your app’s content into a person’s surroundings.\n\n## Overview\n\nA device with a stereoscopic display lets people experience 3D content in a way that feels more real. Content appears to have real depth, and people can view it from different angles, making it seem like it’s there in front of them.\n\nWhen building an app for visionOS, think about ways you might add depth to your app’s interface. The system provides several ways to display 3D content, including in your existing windows, in a volume, and in an immersive space. Choose the options that work best for your app and the content you offer.\n\n\n\n### Add depth to traditional 2D windows\n\nWindows are an important part of your app’s interface. With visionOS, apps automatically get materials with the visionOS look and feel, fully resizable windows with spacing tuned for eyes and hands input, and access to highlighting adjustments for your custom controls.\n\n\n\nIncorporate depth effects into your custom views as needed, and use 3D layout options to arrange views in your windows.\n\n- Apply a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/shadow(color:radius:x:y:)] or [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/visualEffect(_:)] modifier to the view.\n- Lift or highlight the view when someone looks at it using a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/hoverEffect(_:in:isEnabled:)] modifier.\n- Lay out views using a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ZStack].\n- Animate view-related changes with [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/transform3DEffect(_:)].\n- Rotate the view using a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/View\/rotation3DEffect(_:axis:anchor:anchorZ:perspective:)] modifier.\n\nIn addition to giving 2D views more depth, you can also add static 3D models to your 2D windows. The `Model3D` view loads a USDZ file or other asset type and displays it at its intrinsic size in your window. Use this in places where you already have the model data in your app, or can download it from the network. For example, a shopping app might use this type of view to display a 3D version of a product.\n\n### Display dynamic 3D scenes using RealityKit\n\nRealityKit is Apple’s technology for building 3D models and scenes that you update dynamically onscreen. In visionOS, use RealityKit and SwiftUI together to seamlessly couple your app’s 2D and 3D content. Load existing USDZ assets or create scenes in Reality Composer Pro that incorporate animation, physics, lighting, sounds, and custom behaviors for your content. To use a Reality Composer Pro project in your app, add the Swift package to your Xcode project and import its module in your Swift file. For more information, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/managing-files-and-folders-in-your-xcode-project].\n\n\n\nWhen you’re ready to display 3D content in your interface, use a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView]. This SwiftUI view serves as a container for your RealityKit content, and lets you update that content using familiar SwiftUI techniques.\n\nThe following example shows a view that uses a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView] to display a 3D sphere. The code in the view’s closure creates a RealityKit entity for the sphere, applies a texture to the surface of the sphere, and adds the sphere to the view’s content.\n\n```swift\n struct SphereView: View {\n    var body: some View {\n        RealityView { content in\n            let model = ModelEntity(\n                         mesh: .generateSphere(radius: 0.1),\n                         materials: [SimpleMaterial(color: .white, isMetallic: true)])\n            content.add(model)\n        }\n    }\n}\n```\n\nWhen SwiftUI displays your [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView], it executes your code once to create the entities and other content. Because creating entities is relatively expensive, the view runs your creation code only once. When you want to update the state of your entities, change the state of your view and use an update closure to apply those changes to your content. The following example uses an update closure to change the size of the sphere when the value in the `scale` property changes:\n\n```swift\nstruct SphereView: View {\n    var scale = false\n\n    var body: some View {\n        RealityView { content in\n            let model = ModelEntity(\n                         mesh: .generateSphere(radius: 0.1),\n                         materials: [SimpleMaterial(color: .white, isMetallic: true)])\n            content.add(model)\n        } update: { content in\n            if let model = content.entities.first {\n                model.transform.scale = scale ? [1.2, 1.2, 1.2] : [1.0, 1.0, 1.0]\n            }\n        }\n    }\n}\n```\n\nFor information about how to create content using RealityKit, see [doc:\/\/com.apple.documentation\/documentation\/RealityKit].\n\n### Respond to interactions with RealityKit content\n\nTo handle interactions with the entities of your RealityKit scenes:\n\n- Attach a gesture recognizer to your [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView] and add the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Gesture\/targetedToAnyEntity()] modifier to it.\n- Attach an [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/InputTargetComponent] to the entity or one of its parent entities.\n- Add collision shapes to the RealityKit entities that support interactions.\n\nThe [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Gesture\/targetedToAnyEntity()] modifier provides a bridge between the gesture recognizer and your RealityKit content. For example, to recognize when someone drags an entity, specify a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/DragGesture] and add the modifier to it. When the specified gesture occurs on an entity, SwiftUI executes the provided closure.\n\nThe following example adds a tap gesture recognizer to the sphere view from the previous example. The code also adds [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/InputTargetComponent] and [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/CollisionComponent] components to the shape to allow the interactions to occur. If you omit these components, the view doesn’t detect the interactions with your entity.\n\n```swift\nstruct SphereView: View {\n    @State private var scale = false\n\n    var body: some View {\n        RealityView { content in\n            let model = ModelEntity(\n                mesh: .generateSphere(radius: 0.1),\n                materials: [SimpleMaterial(color: .white, isMetallic: true)])\n\n            \/\/ Enable interactions on the entity.\n            model.components.set(InputTargetComponent())\n            model.components.set(CollisionComponent(shapes: [.generateSphere(radius: 0.1)]))\n            content.add(model)\n        } update: { content in\n            if let model = content.entities.first {\n                model.transform.scale = scale ? [1.2, 1.2, 1.2] : [1.0, 1.0, 1.0]\n            }\n        }\n        .gesture(TapGesture().targetedToAnyEntity().onEnded { _ in\n            scale.toggle()\n        })\n    }\n}\n```\n\n### Display 3D content in a volume\n\nA volume is a type of window that grows in three dimensions to match the size of the content it contains. Windows and volumes both accommodate 2D and 3D content, and are alike in many ways. However, windows clip 3D content that extends too far from the window’s surface, so volumes are the better choice for content that is primarily 3D.\n\nTo create a volume, add a [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowGroup] scene to your app and set its style to [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/WindowStyle\/volumetric]. This style tells SwiftUI to create a window for 3D content. Include any 2D or 3D views you want in your volume. You can also add a [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView] to build your content using RealityKit. The following example creates a volume with a static 3D model of some balloons stored in the app’s bundle:\n\n```swift\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            Model3D(\"balloons\")\n        }.windowStyle(style: .volumetric)\n    }\n}\n```\n\nWindows and volumes are a convenient way to display bounded 2D and 3D content, but your app doesn’t control the placement of that content in the person’s surroundings. The system sets the initial position of each window and volume at display time. The system also adds a window bar to allow someone to reposition the window or resize it.\n\n\n\nFor more information about when to use volumes, see [doc:\/\/com.apple.documentation\/design\/Human-Interface-Guidelines\/windows#visionOS].\n\n### Display 3D content in a person’s surroundings\n\nWhen you need more control over the placement of your app’s content, add that content to an [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace]. An immersive space offers an unbounded area for your content, and you control the size and placement of content within the space. After receiving permission from the user, you can also use ARKit with an immersive space to integrate content into their surroundings. For example, you can use ARKit scene reconstruction to obtain a mesh of furniture and nearby objects and have your content interact with that mesh.\n\nAn [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace] is a scene type that you create alongside your app’s other scenes. The following example shows an app that contains an immersive space and a window:\n\n```swift\n@main\nstruct MyImmersiveApp: App {\n    var body: some Scene {\n        WindowGroup() {\n            ContentView()\n        }\n\n        ImmersiveSpace(id: \"solarSystem\") {\n            SolarSystemView()\n        }\n    }\n}\n```\n\nIf you don’t add a style modifier to your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace] declaration, the system creates that space using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersionStyle\/mixed] style. This style displays your content together with the passthrough content that shows the person’s surroundings. Other styles let you hide passthrough to varying degrees. Use the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/Scene\/immersionStyle(selection:in:)] modifier to specify which styles your space supports. If you specify more than one style, you can toggle between the styles using the `selection` parameter of the modifier.\n\n\n\nRemember to set the position of items you place in an [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace]. Position SwiftUI views using modifiers, and position a RealityKit entity using its transform component. SwiftUI places the origin of a space at a person’s feet initially, but can change this origin in response to other events. For example, the system might shift the origin to accommodate a SharePlay activity that displays your content with Spatial Personas. If you need to position SwiftUI views and RealityKit entities relative to one another, perform any needed coordinate conversions using the methods in the `content` parameter of [doc:\/\/com.apple.documentation\/documentation\/RealityKit\/RealityView].\n\nTo display your [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace] scene, open it using the [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/EnvironmentValues\/openImmersiveSpace] action, which you obtain from the SwiftUI environment. This action runs asynchronously and uses the provided information to find and initialize your scene. The following example shows a button that opens the space with the `solarSystem` identifier:\n\n```swift\nButton(\"Show Solar System\") {\n    Task {\n        let result = await openImmersiveSpace(id: \"solarSystem\")\n        if case .error = result {\n            print(\"An error occurred\")\n        }\n    }\n}\n```\n\nWhen an app presents an [doc:\/\/com.apple.documentation\/documentation\/SwiftUI\/ImmersiveSpace], the system hides the content of other apps to prevent visual conflicts. The other apps remain hidden while your space is visible but return when you dismiss it. If your app defines multiple spaces, you must dismiss the currently visible space before displaying a different space. If you don’t dismiss the visible space, the system issues a runtime warning when you try to open the other space.\n\n## App construction\n\n- **Creating your first visionOS app**: Build a new visionOS app using SwiftUI and add platform-specific features.\n- **Creating fully immersive experiences in your app**: Build fully immersive experiences by combining spaces with content you create using RealityKit or Metal.\n- **Drawing sharp layer-based content in visionOS**: Deliver text and vector images at multiple resolutions from custom Core Animation layers in visionOS.\n- **Introductory visionOS samples**: Learn the fundamentals of building apps for visionOS with beginner-friendly sample code projects.\n- **Combining spatial support from multiple frameworks**: Integrate the features of an array of frameworks seamlessly to enhance your spatial app.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Build a new visionOS app using SwiftUI and add platform-specific features.",
          "name" : "Creating your first visionOS app",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/creating-your-first-visionos-app"
        },
        {
          "description" : "Build fully immersive experiences by combining spaces with content you create using RealityKit or Metal.",
          "name" : "Creating fully immersive experiences in your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/creating-fully-immersive-experiences"
        },
        {
          "description" : "Deliver text and vector images at multiple resolutions from custom Core Animation layers in visionOS.",
          "name" : "Drawing sharp layer-based content in visionOS",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/drawing-sharp-layer-based-content"
        },
        {
          "description" : "Learn the fundamentals of building apps for visionOS with beginner-friendly sample code projects.",
          "name" : "Introductory visionOS samples",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/introductory-visionOS-samples"
        },
        {
          "description" : "Integrate the features of an array of frameworks seamlessly to enhance your spatial app.",
          "name" : "Combining spatial support from multiple frameworks",
          "url" : "https:\/\/developer.apple.com\/documentation\/visionOS\/combining-spatial-support-from-multiple-frameworks"
        }
      ],
      "title" : "App construction"
    }
  ],
  "source" : "appleJSON",
  "title" : "Adding 3D content to your app",
  "url" : "https:\/\/developer.apple.com\/documentation\/visionos\/adding-3d-content-to-your-app"
}