{
  "abstract" : "Implement a configurable audio input source as a driver extension that runs in user space in macOS and iPadOS.",
  "codeExamples" : [
    {
      "code" : "kern_return_t SimpleAudioDriver::Start_Impl(IOService* in_provider)\n{\n\tbool success = false;\n\tauto device_uid = OSSharedPtr(OSString::withCString(kSimpleAudioDriverDeviceUID), OSNoRetain);\n\tauto model_uid = OSSharedPtr(OSString::withCString(\"SimpleAudioDevice-Model\"), OSNoRetain);\n\tauto manufacturer_uid = OSSharedPtr(OSString::withCString(\"Apple Inc.\"), OSNoRetain);\n\tauto device_name = OSSharedPtr(OSString::withCString(\"SimpleAudioDevice\"), OSNoRetain);\n\t\n\tkern_return_t error = Start(in_provider, SUPERDISPATCH);\n\tFailIfError(error, , Failure, \"Failed to start Super\");\n\t\n\t\/\/ Get the service's default dispatch queue from the driver object.\n\tivars->m_work_queue = GetWorkQueue();\n\tFailIfError(ivars->m_work_queue.get() == nullptr, error = kIOReturnInvalid, Failure, \"failed to get default work queue\");\n\t\t\n\t\/\/ Allocate and configure audio devices as necessary.\n\tivars->m_simple_audio_device = OSSharedPtr(OSTypeAlloc(SimpleAudioDevice), OSNoRetain);\n\tFailIfNULL(ivars->m_simple_audio_device.get(), error = kIOReturnNoMemory, Failure, \"Failed to allocate SimpleAudioDevice\");\n\t\n\tsuccess = ivars->m_simple_audio_device->init(this, false, device_uid.get(), model_uid.get(), manufacturer_uid.get(), k_zero_time_stamp_period);\n\tFailIf(success == false, error = kIOReturnNoMemory, Failure, \"Failed to init SimpleAudioDevice\");\n\t\n\tivars->m_simple_audio_device->SetName(device_name.get());\n\t\n\t\/\/ Add the device object to the driver.\n\tAddObject(ivars->m_simple_audio_device.get());\n\t\t\t\n\t\/\/ Register the service.\n\terror = RegisterService();\n\tFailIfError(error, , Failure, \"failed to register service!\");\n\t\n\treturn kIOReturnSuccess;\n\t\nFailure:\n\treturn error;\n}",
      "language" : "c++"
    },
    {
      "code" : "kern_return_t SimpleAudioDriver::NewUserClient_Impl(uint32_t in_type, IOUserClient** out_user_client)\n{\n\tkern_return_t error = kIOReturnSuccess;\n\t\n\t\/\/ Have the superclass create the IOUserAudioDriverUserClient object\n\t\/\/ if the type is kIOUserAudioDriverUserClientType.\n\tif (in_type == kIOUserAudioDriverUserClientType)\n\t{\n\t\terror = super::NewUserClient(in_type, out_user_client, SUPERDISPATCH);\n\t\tFailIfError(error, , Failure, \"Failed to create user client\");\n\t\tFailIfNULL(*out_user_client, error = kIOReturnNoMemory, Failure, \"Failed to create user client\");\n\t}\n\telse\n\t{\n\t\tIOService* user_client_service = nullptr;\n\t\terror = Create(this, \"SimpleAudioDriverUserClientProperties\", &user_client_service);\n\t\tFailIfError(error, , Failure, \"failed to create the SimpleAudioDriver user client\");\n\t\t*out_user_client = OSDynamicCast(IOUserClient, user_client_service);\n\t}\n\t\nFailure:\n\treturn error;\n}",
      "language" : "c++"
    },
    {
      "code" : "double sample_rates[] = {kSampleRate_1, kSampleRate_2};\nSetAvailableSampleRates(sample_rates, 2);\nSetSampleRate(kSampleRate_1);\nconst auto channels_per_frame = 1;\nIOUserAudioChannelLabel input_channel_layout[channels_per_frame] = { IOUserAudioChannelLabel::Mono };\nIOUserAudioChannelLabel output_channel_layout[channels_per_frame] = { IOUserAudioChannelLabel::Mono };\n\nIOUserAudioStreamBasicDescription stream_formats[] =\n{\n\t{\n\t\tkSampleRate_1, IOUserAudioFormatID::LinearPCM,\n\t\tstatic_cast<IOUserAudioFormatFlags>(IOUserAudioFormatFlags::FormatFlagIsSignedInteger | IOUserAudioFormatFlags::FormatFlagsNativeEndian),\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\t1,\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\tstatic_cast<uint32_t>(channels_per_frame),\n\t\t16\n\t},\n\t{\n\t\tkSampleRate_2, IOUserAudioFormatID::LinearPCM,\n\t\tstatic_cast<IOUserAudioFormatFlags>(IOUserAudioFormatFlags::FormatFlagIsSignedInteger | IOUserAudioFormatFlags::FormatFlagsNativeEndian),\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\t1,\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\tstatic_cast<uint32_t>(channels_per_frame),\n\t\t16\n\t},\n};",
      "language" : "c++"
    },
    {
      "code" : "OSSharedPtr<IOBufferMemoryDescriptor> output_io_ring_buffer;\nOSSharedPtr<IOBufferMemoryDescriptor> input_io_ring_buffer;\nconst auto buffer_size_bytes = static_cast<uint32_t>(in_zero_timestamp_period * sizeof(uint16_t) * channels_per_frame);\nerror = IOBufferMemoryDescriptor::Create(kIOMemoryDirectionInOut, buffer_size_bytes, 0, output_io_ring_buffer.attach());\nFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create output IOBufferMemoryDescriptor\");\n\nerror = IOBufferMemoryDescriptor::Create(kIOMemoryDirectionInOut, buffer_size_bytes, 0, input_io_ring_buffer.attach());\nFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create input IOBufferMemoryDescriptor\");\n\n\/\/ Create an output\/input stream object and pass in the I\/O ring buffer memory descriptor.\nivars->m_output_stream = IOUserAudioStream::Create(in_driver, IOUserAudioStreamDirection::Output, output_io_ring_buffer.get());\nFailIfNULL(ivars->m_output_stream.get(), error = kIOReturnNoMemory, Failure, \"failed to create output stream\");\n\nivars->m_input_stream = IOUserAudioStream::Create(in_driver, IOUserAudioStreamDirection::Input, input_io_ring_buffer.get());\nFailIfNULL(ivars->m_input_stream.get(), error = kIOReturnNoMemory, Failure, \"failed to create input stream\");\n\n\/\/\tConfigure stream properties: name, available formats, and current format.\nivars->m_output_stream->SetName(output_stream_name.get());\nivars->m_output_stream->SetAvailableStreamFormats(stream_formats, 2);\nivars->m_stream_format = stream_formats[0];\nivars->m_output_stream->SetCurrentStreamFormat(&ivars->m_stream_format);\n\nivars->m_input_stream->SetName(input_stream_name.get());\nivars->m_input_stream->SetAvailableStreamFormats(stream_formats, 2);\nivars->m_input_stream->SetCurrentStreamFormat(&ivars->m_stream_format);\n\n\/\/ Add a stream object to the driver.\nerror = AddStream(ivars->m_output_stream.get());\nFailIfError(error, , Failure, \"failed to add output stream\");\n\nerror = AddStream(ivars->m_input_stream.get());\nFailIfError(error, , Failure, \"failed to add input stream\");",
      "language" : "c++"
    },
    {
      "code" : "\/\/ Create the volume control object for the input stream.\nivars->m_input_volume_control = IOUserAudioLevelControl::Create(in_driver,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-6.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{-96.0, 0.0},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioObjectPropertyElementMain,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioObjectPropertyScope::Input,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioClassID::VolumeControl);\nFailIfNULL(ivars->m_input_volume_control.get(), error = kIOReturnNoMemory, Failure, \"Failed to create input volume control\");\nivars->m_input_volume_control->SetName(input_volume_control_name.get());\n\n\/\/ Add the volume control to the device object.\nerror = AddControl(ivars->m_input_volume_control.get());\nFailIfError(error, , Failure, \"failed to add input volume level control\");",
      "language" : "c++"
    },
    {
      "code" : "IOUserAudioObjectPropertyAddress prop_addr = {\n\tkSimpleAudioDriverCustomPropertySelector,\n\tIOUserAudioObjectPropertyScope::Global,\n\tIOUserAudioObjectPropertyElementMain };\nOSSharedPtr<IOUserAudioCustomProperty> custom_property = nullptr;\nOSSharedPtr<OSString> qualifier = nullptr;\nOSSharedPtr<OSString> data = nullptr;",
      "language" : "c++"
    },
    {
      "code" : "custom_property = IOUserAudioCustomProperty::Create(in_driver,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprop_addr,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioCustomPropertyDataType::String,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioCustomPropertyDataType::String);\n\n\/\/ Set the qualifier and data-value pair on the custom property.\nqualifier = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyQualifier0), OSNoRetain);\ndata = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyDataValue0), OSNoRetain);\ncustom_property->SetQualifierAndDataValue(qualifier.get(), data.get());\n   \n\/\/ Set another qualifier and data-value pair on the custom property.\nqualifier = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyQualifier1), OSNoRetain);\ndata = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyDataValue1), OSNoRetain);\ncustom_property->SetQualifierAndDataValue(qualifier.get(), data.get());\nAddCustomProperty(custom_property.get());",
      "language" : "c++"
    },
    {
      "code" : "kern_return_t SimpleAudioDevice::StartIO(IOUserAudioStartStopFlags in_flags)\n{\n\tDebugMsg(\"Start I\/O: device %u\", GetObjectID());\n\t\n\t__block kern_return_t error = kIOReturnSuccess;\n\t__block OSSharedPtr<IOMemoryDescriptor> input_iomd;\n\t__block OSSharedPtr<IOMemoryDescriptor> output_iomd;\n\n\tivars->m_work_queue->DispatchSync(^(){\n\t\t\/\/\tTell IOUserAudioObject base class to start I\/O for the device.\n\t\terror = super::StartIO(in_flags);\n\t\tFailIfError(error, , Failure, \"Failed to start I\/O\");\n\t\t\n\t\toutput_iomd = ivars->m_output_stream->GetIOMemoryDescriptor();\n\t\tFailIfNULL(output_iomd.get(), error = kIOReturnNoMemory, Failure, \"Failed to get output stream IOMemoryDescriptor\");\n\t\terror = output_iomd->CreateMapping(0, 0, 0, 0, 0, ivars->m_output_memory_map.attach());\n\t\tFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create memory map from output stream IOMemoryDescriptor\");\n\t\t\n\t\tinput_iomd = ivars->m_input_stream->GetIOMemoryDescriptor();\n\t\tFailIfNULL(input_iomd.get(), error = kIOReturnNoMemory, Failure, \"Failed to get input stream IOMemoryDescriptor\");\n\t\terror = input_iomd->CreateMapping(0, 0, 0, 0, 0, ivars->m_input_memory_map.attach());\n\t\tFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create memory map from input stream IOMemoryDescriptor\");\n\n\t\t\/\/ Start the timers to send timestamps and generate sine tone on the stream I\/O buffer.\n\t\tStartTimers();\n\t\treturn;\n\t\t\n\tFailure:\n\t\tsuper::StopIO(in_flags);\n\t\tivars->m_output_memory_map.reset();\n\t\tivars->m_input_memory_map.reset();\n\t\treturn;\n\t});\n\n\treturn error;\n}",
      "language" : "c++"
    },
    {
      "code" : "\/\/ Initialize the timer that stands in for a real interrupt.\nerror = IOTimerDispatchSource::Create(ivars->m_work_queue.get(), &zts_timer_event_source);\nFailIfError(error, , Failure, \"failed to create the ZTS timer event source\");\nivars->m_zts_timer_event_source = OSSharedPtr(zts_timer_event_source, OSNoRetain);\n\n\/\/ Create a timer action to generate timestamps.\nerror = CreateActionZtsTimerOccurred(sizeof(void*), &zts_timer_occurred_action);\nFailIfError(error, , Failure, \"failed to create the timer event source action\");\nivars->m_zts_timer_occurred_action = OSSharedPtr(zts_timer_occurred_action, OSNoRetain);\nivars->m_zts_timer_event_source->SetHandler(ivars->m_zts_timer_occurred_action.get());",
      "language" : "c++"
    },
    {
      "code" : "\/\/ Clear the device's timestamps.\nUpdateCurrentZeroTimestamp(0, 0);\nauto current_time = mach_absolute_time();\n\n\/\/ Start the timer. The first timestamp occurs when the timer goes off.\nivars->m_zts_timer_event_source->WakeAtTime(kIOTimerClockMachAbsoluteTime, current_time + ivars->m_zts_host_ticks_per_buffer, 0);\nivars->m_zts_timer_event_source->SetEnable(true);",
      "language" : "c++"
    },
    {
      "code" : "void\tSimpleAudioDevice::ZtsTimerOccurred_Impl(OSAction* action, uint64_t time)\n{\n\t\/\/ Get the current time.\n\tauto current_time = time;\n\t\n\t\/\/ Increment the timestamps...\n\tuint64_t current_sample_time = 0;\n\tuint64_t current_host_time = 0;\n\tGetCurrentZeroTimestamp(&current_sample_time, &current_host_time);\n\t\n\tauto host_ticks_per_buffer = ivars->m_zts_host_ticks_per_buffer;\n\t\n\tif(current_host_time != 0)\n\t{\n\t\tcurrent_sample_time += GetZeroTimestampPeriod();\n\t\tcurrent_host_time += host_ticks_per_buffer;\n\t}\n\telse\n\t{\n\t\t\/\/ ...but not if it's the first one.\n\t\tcurrent_sample_time = 0;\n\t\tcurrent_host_time = current_time;\n\t}\n\t\n\t\/\/ Update the device with the current timestamp.\n\tUpdateCurrentZeroTimestamp(current_sample_time, current_host_time);\n\t\n\t\/\/ Set the timer to go off in one buffer.\n\tivars->m_zts_timer_event_source->WakeAtTime(kIOTimerClockMachAbsoluteTime,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrent_host_time + host_ticks_per_buffer, 0);\n}",
      "language" : "c++"
    },
    {
      "code" : "io_operation = ^kern_return_t(IOUserAudioObjectID in_device,\n\t\t\t\t\t\t\t  IOUserAudioIOOperation in_io_operation,\n\t\t\t\t\t\t\t  uint32_t in_io_buffer_frame_size,\n\t\t\t\t\t\t\t  uint64_t in_sample_time,\n\t\t\t\t\t\t\t  uint64_t in_host_time)\n{",
      "language" : "c++"
    },
    {
      "code" : "this->SetIOOperationHandler(io_operation);",
      "language" : "c++"
    },
    {
      "code" : "void SimpleAudioDevice::GenerateToneForInput(double in_tone_freq, size_t in_sample_time, size_t in_frame_size)\n{\n\t\/\/ Fill out the input buffer with a sine tone.\n\tif (ivars->m_input_memory_map)\n\t{\n\t\t\/\/ Get the pointer to the I\/O buffer and use stream format information\n\t\t\/\/ to get the buffer length.\n\t\tconst auto& format = ivars->m_stream_format;\n\t\tauto buffer_length = ivars->m_input_memory_map->GetLength() \/ (format.mBytesPerFrame \/ format.mChannelsPerFrame);\n\t\tauto num_samples = in_frame_size;\n\t\tauto buffer = reinterpret_cast<int16_t*>(ivars->m_input_memory_map->GetAddress() + ivars->m_input_memory_map->GetOffset());\n\n\t\t\/\/ Get the volume control dB value to apply gain to the tone.\n\t\tauto input_volume_level = ivars->m_input_volume_control->GetScalarValue();\n\t\t\n\t\tfor(size_t i = 0; i < num_samples; i++)\n\t\t{\n\t\t\tfloat float_value = input_volume_level * sin(2.0 * M_PI * in_tone_freq * static_cast<double>(ivars->m_tone_sample_index) \/ format.mSampleRate);\n\t\t\tint16_t integer_value = FloatToInt16(float_value);\n\t\t\tfor (auto channel_index = 0; channel_index < format.mChannelsPerFrame; channel_index++)\n\t\t\t{\n\t\t\t\tauto buffer_index = (format.mChannelsPerFrame * (in_sample_time + i) + channel_index) % buffer_length;\n\t\t\t\tbuffer[buffer_index] = integer_value;\n\t\t\t}\n\t\t\tivars->m_tone_sample_index += 1;\n\t\t}\n\t}\n}",
      "language" : "c++"
    },
    {
      "code" : "kern_return_t SimpleAudioDriver::HandleTestConfigChange()\n{\n\tauto change_info = OSSharedPtr(OSString::withCString(\"Toggle Sample Rate\"), OSNoRetain);\n\treturn ivars->m_simple_audio_device->RequestDeviceConfigurationChange(k_custom_config_change_action, change_info.get());\n}",
      "language" : "c++"
    },
    {
      "code" : "kern_return_t SimpleAudioDevice::PerformDeviceConfigurationChange(uint64_t change_action, OSObject* in_change_info)\n{\n\tDebugMsg(\"change action %llu\", change_action);\n\tkern_return_t ret = kIOReturnSuccess;\n\tswitch (change_action) {\n\t\t\t\/\/ Add custom config change handlers.\n\t\tcase k_custom_config_change_action:\n\t\t{\n\t\t\tif (in_change_info)\n\t\t\t{\n\t\t\t\tauto change_info_string = OSDynamicCast(OSString, in_change_info);\n\t\t\t\tDebugMsg(\"%s\", change_info_string->getCStringNoCopy());\n\t\t\t}\n\t\t\t\n\t\t\t\/\/ Toggle the sample rate of the device.\n\t\t\tdouble rate_to_set = static_cast<uint64_t>(GetSampleRate()) != static_cast<uint64_t>(kSampleRate_1) ? kSampleRate_1 : kSampleRate_2;\n\t\t\tret = SetSampleRate(rate_to_set);\n\t\t\tif (ret == kIOReturnSuccess)\n\t\t\t{\n\t\t\t\t\/\/ Update the stream formats with the new rate.\n\t\t\t\tret = ivars->m_input_stream->DeviceSampleRateChanged(rate_to_set);\n\t\t\t\tret = ivars->m_output_stream->DeviceSampleRateChanged(rate_to_set);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tret = super::PerformDeviceConfigurationChange(change_action, in_change_info);\n\t\t\tbreak;\n\t}\n\t\n\t\/\/ Update the cached format.\n\tivars->m_stream_format = ivars->m_input_stream->GetCurrentStreamFormat();\n\t\n\treturn ret;\n}",
      "language" : "c++"
    }
  ],
  "contentHash" : "ec27499f2226f0d20cf8975b031e5ba1a6a270fd09a707a4ad4df4c3d8165b79",
  "crawledAt" : "2025-12-02T15:47:41Z",
  "id" : "455EBFA8-8387-4109-ADEC-A29B40E90F68",
  "kind" : "unknown",
  "language" : "occ",
  "module" : "AudioDriverKit",
  "overview" : "## Overview\n\nThis sample shows how to create an audio driver extension using the AudioDriverKit framework. The sample provides a C++ DriverKit implementation to publish a single audio device, output stream, input stream, volume control, and data-source selector control.\n\nThe sample implements a dynamic environment that can support multiple audio devices and any other audio objects the AudioDriverKit framework provides. The audio device provides the following features:\n\nAudioDriverKit is available in macOS, and in iPadOS 16 and later when running on an iPad device with an M-series chip. This sample project supports both platforms.\n\nThe sample app connects to the audio driver extension through a custom user client connection.  The custom user client shows an example of how to change the data-source selector value or the sample rate directly on the audio driver extension. In macOS, the sample app also provides the installer for the driver. In iPadOS, you install the driver by enabling it in Settings.\n\n### Configure the sample code project\n\nBy default, the sample project uses manual code signing. If you just want to run the app to see how it works, select “Automatically manage signing” for each of the targets.\n\nIf you want to run the app with manual signing, do the following:\n\n### Run the sample in macOS\n\nTo run the sample app in macOS, use the scheme selector to select the SimpleAudio (macOS) scheme and the My Mac destination. Build the target, then copy the app to the Applications folder and launch the app.\n\nIn macOS, the SimpleAudio app has two sections: Driver Manager, which installs the app, and User Client Manager, which interacts with the running driver. Under Driver Manager, click Install Driver. If a System Extension Blocked dialog appears, open System Settings and navigate to the Security & Privacy pane. Unlock the pane if necessary and click Allow to complete the installation. When installation completes, the Driver Manager status in the app displays the message “SimpleAudioDriver has been activated and is ready to use.”\n\nAt this point, the sample’s audio device is available to Core Audio. To inspect the newly installed device, use the Audio MIDI Setup app (`Applications\/Utilities`), which shows the sine tone’s frequency and sample rate. You can change these settings there, or in the SimpleAudio app’s User Client Manager section. Click Open User Client to open a connection from the app to the driver. Then you can use the other buttons in this section to toggle the frequency and sample rate.\n\nTo hear the sine tone, open the QuickTime Player app and choose File > New Audio Recording to create a new recording window. Next to the Record button, change the device from the default microphone to SimpleAudioDriver: Sine Tone 440 or SimpleAudioDriver: Sine Tone 660. Adjust the volume slider to hear the tone through your current audio output device.\n\nTo uninstall the driver, delete the sample app, which also stops and removes the driver extension (dext). You can also use `systemextensionsctl` from the command line to list and selectively uninstall system extensions like `SimpleAudioDriver`.\n\n### Run the sample in iPadOS\n\nTo run the sample app in iPadOS, connect an iPad device with an M-series chip to your Mac. Use the scheme selector to select the SimpleAudio (iOS) scheme and the name of your iPad as the destination. Run the app directly from Xcode to launch it on your iPad.\n\nIn iPadOS, the SimpleAudio app doesn’t show the Driver Manager section because the app isn’t responsible for installing the driver like it is in macOS. Instead, open the Settings app, navigate to Privacy & Security > Drivers, and enable the driver there.\n\nAfter enabling the driver, return to the SimpleAudio app to open a user client connection and modify the device’s frequency and sample rate.\n\nWhen you finish using the driver, delete the app, which deletes the driver as well.\n\n### Create driver and device classes\n\nTo create an AudioDriverKit driver, the sample creates a driver that subclasses [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDriver], and a device that subclasses [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice]. The dext’s `Info.plist` file contains entries that identify the driver class to AudioDriverKit, which instantiates and initializes the driver. The sample’s `Info.plist` file shows how this works: the `IOUserClass` key maps to the class name string `SimpleAudioDriver`, and `IOUserServerName` contains the bundle ID.\n\nThe driver subclass is the entry point into the dext, while the device subclass handles start and stop I\/O-related messages, timestamps, and configuration messages. The device also owns various [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioObject] instances for things like timer dispatch sources and [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/OSAction] references. In an actual hardware driver, the device class is also responsible for communication with the hardware over USB or PCI, and requires appropriate DriverKit entitlements for those transports. The sample doesn’t actually connect to hardware, and instead provides a virtual device that generates a sine tone.\n\nAfter initialization, DriverKit calls the driver’s [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOService\/Start] method. The implementation in `SimpleAudioDriver` creates and configures the `SimpleAudioDevice` instance and, if successful, calls [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOService\/RegisterService] to let the system know the driver is running.\n\n### Implement a user client interface\n\nThere are two dictionaries in the `Info.plist` file that define how the driver acts as a user client to the Core Audio Hardware Abstraction Layer (HAL) and to other apps. The first dictionary, `IOUserAudioDriverUserClientProperties`, maps `IOClass` to `IOUserUserClient` and `IOUserClass` to `IOUserAudioDriverUserClient`. This allows the HAL to connect to the driver. To support user client connections from apps, the sample also defines a custom user client class. The dictionary for the custom user client has the key `SimpleAudioDriverUserClientProperties`, and its `IOUserClass` has the value `SimpleAudioDriverUserClient`, a custom subclass of `IOUserClient`. Drivers that don’t accept user client connections from apps don’t need this second dictionary.\n\nWhen the HAL requires a new user client connection to the dext, it calls the driver’s [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOService\/NewUserClient] method. In the sample, the implementation of this method serves two purposes. If the incoming client type is `kIOUserAudioDriverUserClientType`, then this is a request from the HAL. In this case, the driver just forwards the call to the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDriver] superclass. For other client types, such as apps connecting to the driver, it uses the `SimpleAudioDriverUserClientProperties` values from the `Info.plist` file to create an instance of the custom `SimpleAudioDriverUserClient` class.\n\n### Create audio objects in the device initializer\n\nThe device class manages the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioStream] interfaces that perform audio I\/O. It can also contain controls and custom properties that interact with the audio stream.\n\nIn the sample, the `SimpleAudioDevice` initializer method declares the stream format to use for `IOUserAudioStream` objects: single-channel, PCM, using 16-bit native-endian signed integer. It also sets two available sample rates — `44100.0` and `48000.0` — which a person using the sample app can toggle.\n\nAudioDriverKit maps the memory of these streams to the Core Audio HAL. In an actual hardware driver, this memory needs to be the same I\/O memory the system uses for DMA to hardware.\n\n### Create standard controls in the device\n\nAudioDriverKit provides [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioControl] objects for standard user interface to an audio device. Along with general controls for a toggle, slider, or selection interface to device properties, there are standard controls for volume and stereo pan. The sample driver adds an instance of the volume control, [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioLevelControl], in its initializer, which provides the volume slider in Audio MIDI Setup in macOS.\n\nThe following code example creates the audio level control with a default level of -6.0 decibels (dB), and a range of -96.0 to 0.0 dB. Like all audio controls, the level control has an element and scope to set; these properties have the same meaning as the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AudioUnitElement] and [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AudioUnitScope] of an [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit] in [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox]. In this case, the element [audiodriverkit\/iouseraudiodriver] affects the entire control, and the scope [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/AudioDriverKit\/IOUserAudioObjectPropertyScope\/Input] indicates that this control affects input from the device.\n\n### Create custom properties to control the device\n\nThe sample creates two custom control properties for its virtual device. In the code example below, the sample creates a property address reference for a property selector, using the main element and global scope. It then creates local pointer variables for the property selector, the data, and an optional qualifier that provides further detail about how to use the property data.\n\nLater in the device’s initializer, the following code example creates the custom property from the property address, setting two qualifier\/data pairs before adding the custom property.\n\n### Handle the callback to start device I\/O\n\nBecause the sample project doesn’t connect to a hardware device, it uses timers and actions in place of hardware interrupts and DMA. When the HAL attempts to start I\/O on the device, it calls `SimpleAudioDevice::StartIO`. AudioDriverKit provides this method to signal the driver to perform any necessary calls to start I\/O on the device. The sample project uses this signal to start its timers.\n\nIn the sample, the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/StartIO] implementation calls `GetIOMemoryDescriptor` to get the streams’ memory descriptors, and then creates an [doc:\/\/com.apple.documentation\/documentation\/kernel\/iomemorymap] with [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOMemoryDescriptor\/CreateMapping]. After setting up the mapping, the sample uses a private helper method, `StartTimers`, to configure and enable the time sources and actions to generate timestamps and fill out the input audio buffer.\n\nAn [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice] is a subclass of [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice], and as such, it’s responsible for timekeeping between the driver and the hardware device. AudioDriverKit enables this with the methods [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/UpdateCurrentZeroTimestamp] and [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/GetCurrentZeroTimestamp]. The framework handles the timestamps atomically, and the HAL uses the sample time-host time pair to run and synchronize I\/O. Therefore, it’s vital to track the hardware clock’s timestamps as closely as possible.\n\nIn the case of the sample device, timers and actions simulate calls from a hardware device. These actions manage the zero timestamp values. The device class’s initializer creates an [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOTimerDispatchSource] to serve as the timer. Then it creates an action to invoke a callback named `ZtsTimerOccurred`, which simulates the handling of a hardware callback.\n\nIn the `StartTimers` method, which `StartIO` calls earlier, the sample calls `UpdateCurrentZeroTimestamp` to update the pair of values that represents the sample time and host time. Then it starts the timer that the sample creates in the previous code example, using [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] and host ticks from the device to schedule the timed callback.\n\nWhen the `ZtsTimerOccurred` action fires, it gets the last zero timestamp value from the device by calling `GetCurrentZeroTimestamp`. If this is the first timestamp, it uses `mach_absolute_time` as the anchor time. Otherwise, it updates the timestamps by the zero timestamp period and host ticks per buffer. Either way, it updates the device’s timestamps with a call to `UpdateCurrentZeroTimestamp`. Finally, it sets the timer to wake up in the future for the next zero timestamp.\n\n### Use real-time callbacks to perform signal processing in the driver\n\nFor drivers that need to perform signal processing, AudioDriverKit provides real-time callbacks. The driver registers a block that the system calls in a real-time context whenever an I\/O operation occurs on the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioStream] buffers for the device.\n\nIn the sample code, this is how `SimpleAudioDriver` creates its sine tone. It declares its callback in the `SimpleAudioDevice` initalizer.\n\nThe block receives a reference to the device, the operation it’s performing, the buffer size, and the sample and host times. `SimpleAudioDriver` checks that the operation is `IOUserAudioIOOperationBeginRead`, and if it is, it fills its audio buffers with signal data. The data is either loopback from the audio output, or a programmatically generated sine tone that results from a call to a private method, `GenerateToneForInput`.\n\nBecause this callback block runs on a real-time thread, it must not perform any lengthy or indeterminate operations. This includes things like allocating memory, acquiring locks, calling Objective-C or Swift methods, and performing file system or network I\/O.\n\nTo set this block as the callback, the sample calls the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice] method [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/SetIOOperationHandler].\n\n### Access DMA audio buffers\n\nAs mentioned previously, a private method called `GenerateToneForInput` creates the sine tone. This is where the sample simulates writing audio data to DMA, and thereby delivers it to the hardware.\n\nThis method starts by checking that the `m_input_memory_map` that [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/StartIO] creates is valid. If so, it uses the memory map buffer length and stream format to calculate the length in samples for the I\/O buffer. Because the sample project supports only signed, 16-bit PCM audio, it recasts the buffer to an `int_16` pointer.\n\nWith the calculated buffer length and the pointer ready, it’s possible to fill the buffer with the sine tone. The sample starts by getting the current volume control gain as a scalar value. Next, it loops for the number of samples necessary to fill the buffer. In the loop, it calculates a sine value for each sample and applies the volume gain, then writes this value as a signed, 16-bit integer to all the channels in the buffer’s format.\n\n### Handle configuration changes\n\nAt this point, the driver and device can supply an audio stream as if it’s coming from an external device. One other task a driver needs to support is handling configuration changes from the device. Three methods from [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice] support this ability:\n\nIn the sample code project, changing the sample rate provides an example of how to perform a configuration change. When a person taps the Toggle Sample Rate button, the app makes a user client call to the driver’s `HandleTestConfigChange` method. The driver calls `RequestDeviceConfigurationChange`, which tells AudioDriverKit to shut down I\/O and then make a callback to `PerformDeviceConfigurationChange`.\n\nThe implementation of `PerformDeviceConfigurationChange` starts by logging a string it receives from the initial callback in the app. Then it toggles between one of two preset sample rate values, and sets the new sample rate on the clock device with [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/SetSampleRate]. Assuming this succeeds, it then sets the sample rate on both the input and output streams with [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioStream\/DeviceSampleRateChanged]. Finally, it calls the superclass’s implementation of `PerformDeviceConfigurationChange`.\n\nWhen this method returns, the configuration change is complete, and the system resumes I\/O with the device.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/AudioDriverKit\/creating-an-audio-device-driver\ncrawled: 2025-12-02T15:47:41Z\n---\n\n# Creating an audio device driver\n\n**Sample Code**\n\nImplement a configurable audio input source as a driver extension that runs in user space in macOS and iPadOS.\n\n## Overview\n\n\n\nThis sample shows how to create an audio driver extension using the AudioDriverKit framework. The sample provides a C++ DriverKit implementation to publish a single audio device, output stream, input stream, volume control, and data-source selector control.\n\nThe sample implements a dynamic environment that can support multiple audio devices and any other audio objects the AudioDriverKit framework provides. The audio device provides the following features:\n\n- A configurable input device volume\n- A sine tone generator for the input stream’s I\/O buffer\n- An output stream loopback to the input stream data-source selector control\n- A sine tone frequency data-source selector control\n- 44.1 and 48 kHz sample rates\n- A mono channel of audio I\/O in 16-bit, linear PCM format\n- An example of a string-based custom property\n\nAudioDriverKit is available in macOS, and in iPadOS 16 and later when running on an iPad device with an M-series chip. This sample project supports both platforms.\n\nThe sample app connects to the audio driver extension through a custom user client connection.  The custom user client shows an example of how to change the data-source selector value or the sample rate directly on the audio driver extension. In macOS, the sample app also provides the installer for the driver. In iPadOS, you install the driver by enabling it in Settings.\n\n### Configure the sample code project\n\nBy default, the sample project uses manual code signing. If you just want to run the app to see how it works, select “Automatically manage signing” for each of the targets.\n\nIf you want to run the app with manual signing, do the following:\n\n1. Create new bundle identifiers for the app and driver. The bundle identifiers included with the project already have App IDs associated with them, so you need unique identifiers to create your own App IDs. Use a reverse-DNS format for your identifiers, as described in [doc:\/\/com.apple.documentation\/documentation\/Xcode\/preparing-your-app-for-distribution]. iPadOS also requires that your driver’s bundle identifier begin with the host app’s bundle identifier. For example, the default bundle identifiers are `com.example.apple-samplecode.SimpleAudio` for the app and `com.example.apple-samplecode.SimpleAudio.Driver` for the driver.\n2. In the Xcode project, click the Signing & Capabilities tab for each of the three targets — driver, macOS app, and iOS app — and set the respective bundle identifier.\n3. In the driver’s `Info.plist` file, set the value of the `IOUserServerName` to the driver bundle identifier.\n4. In `SimpleAudioDriverViewModel.swift`, make sure the string concatentation that initializes `dextIdentifier` matches the bundle identifer for the driver.\n5. The sample app needs an explicit App ID and provisioning profile with the entitlements System Extension and Communicates with Drivers. For information about how to request entitlements, see [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/requesting-entitlements-for-driverkit-development].\n6. The sample driver needs an explicit App ID and provisioning profile with the following entitlements: `com.apple.developer.driverkit`, `com.apple.developer.driverkit.family.audio`, and `com.apple.developer.driverkit.allow-any-userclient-access`. This latter macOS-only entitlement allows any app to connect to the driver as a user client. Although this simplifies running the sample code, in your own apps you may prefer to use `com.apple.developer.driverkit.userclient-access`. This entitlement goes on the app rather than the driver, and lists bundle identifiers of drivers it can connect to. If you don’t intend for your driver to allow user client connections, just use the `com.apple.developer.driverkit.family.audio` entitlement.\n7. For each of the App IDs you create in the previous steps, select Profiles to create a new provisioning profile. You need one for the macOS app, one for the iPadOS app, and one for the driver, which supports both macOS and iPadOS. When creating the driver’s profile, be sure to select DriverKit App Development as the profile type.\n8. Download each profile and add it to Xcode.\n9. On the Signing & Capabilities tab, set each target to manual code signing and select its new profile.\n\n### Run the sample in macOS\n\nTo run the sample app in macOS, use the scheme selector to select the SimpleAudio (macOS) scheme and the My Mac destination. Build the target, then copy the app to the Applications folder and launch the app.\n\n\n\nIn macOS, the SimpleAudio app has two sections: Driver Manager, which installs the app, and User Client Manager, which interacts with the running driver. Under Driver Manager, click Install Driver. If a System Extension Blocked dialog appears, open System Settings and navigate to the Security & Privacy pane. Unlock the pane if necessary and click Allow to complete the installation. When installation completes, the Driver Manager status in the app displays the message “SimpleAudioDriver has been activated and is ready to use.”\n\nAt this point, the sample’s audio device is available to Core Audio. To inspect the newly installed device, use the Audio MIDI Setup app (`Applications\/Utilities`), which shows the sine tone’s frequency and sample rate. You can change these settings there, or in the SimpleAudio app’s User Client Manager section. Click Open User Client to open a connection from the app to the driver. Then you can use the other buttons in this section to toggle the frequency and sample rate.\n\nTo hear the sine tone, open the QuickTime Player app and choose File > New Audio Recording to create a new recording window. Next to the Record button, change the device from the default microphone to SimpleAudioDriver: Sine Tone 440 or SimpleAudioDriver: Sine Tone 660. Adjust the volume slider to hear the tone through your current audio output device.\n\nTo uninstall the driver, delete the sample app, which also stops and removes the driver extension (dext). You can also use `systemextensionsctl` from the command line to list and selectively uninstall system extensions like `SimpleAudioDriver`.\n\n### Run the sample in iPadOS\n\nTo run the sample app in iPadOS, connect an iPad device with an M-series chip to your Mac. Use the scheme selector to select the SimpleAudio (iOS) scheme and the name of your iPad as the destination. Run the app directly from Xcode to launch it on your iPad.\n\nIn iPadOS, the SimpleAudio app doesn’t show the Driver Manager section because the app isn’t responsible for installing the driver like it is in macOS. Instead, open the Settings app, navigate to Privacy & Security > Drivers, and enable the driver there.\n\nAfter enabling the driver, return to the SimpleAudio app to open a user client connection and modify the device’s frequency and sample rate.\n\nWhen you finish using the driver, delete the app, which deletes the driver as well.\n\n### Create driver and device classes\n\nTo create an AudioDriverKit driver, the sample creates a driver that subclasses [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDriver], and a device that subclasses [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice]. The dext’s `Info.plist` file contains entries that identify the driver class to AudioDriverKit, which instantiates and initializes the driver. The sample’s `Info.plist` file shows how this works: the `IOUserClass` key maps to the class name string `SimpleAudioDriver`, and `IOUserServerName` contains the bundle ID.\n\nThe driver subclass is the entry point into the dext, while the device subclass handles start and stop I\/O-related messages, timestamps, and configuration messages. The device also owns various [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioObject] instances for things like timer dispatch sources and [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/OSAction] references. In an actual hardware driver, the device class is also responsible for communication with the hardware over USB or PCI, and requires appropriate DriverKit entitlements for those transports. The sample doesn’t actually connect to hardware, and instead provides a virtual device that generates a sine tone.\n\n\n\nAfter initialization, DriverKit calls the driver’s [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOService\/Start] method. The implementation in `SimpleAudioDriver` creates and configures the `SimpleAudioDevice` instance and, if successful, calls [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOService\/RegisterService] to let the system know the driver is running.\n\n```c++\nkern_return_t SimpleAudioDriver::Start_Impl(IOService* in_provider)\n{\n\tbool success = false;\n\tauto device_uid = OSSharedPtr(OSString::withCString(kSimpleAudioDriverDeviceUID), OSNoRetain);\n\tauto model_uid = OSSharedPtr(OSString::withCString(\"SimpleAudioDevice-Model\"), OSNoRetain);\n\tauto manufacturer_uid = OSSharedPtr(OSString::withCString(\"Apple Inc.\"), OSNoRetain);\n\tauto device_name = OSSharedPtr(OSString::withCString(\"SimpleAudioDevice\"), OSNoRetain);\n\t\n\tkern_return_t error = Start(in_provider, SUPERDISPATCH);\n\tFailIfError(error, , Failure, \"Failed to start Super\");\n\t\n\t\/\/ Get the service's default dispatch queue from the driver object.\n\tivars->m_work_queue = GetWorkQueue();\n\tFailIfError(ivars->m_work_queue.get() == nullptr, error = kIOReturnInvalid, Failure, \"failed to get default work queue\");\n\t\t\n\t\/\/ Allocate and configure audio devices as necessary.\n\tivars->m_simple_audio_device = OSSharedPtr(OSTypeAlloc(SimpleAudioDevice), OSNoRetain);\n\tFailIfNULL(ivars->m_simple_audio_device.get(), error = kIOReturnNoMemory, Failure, \"Failed to allocate SimpleAudioDevice\");\n\t\n\tsuccess = ivars->m_simple_audio_device->init(this, false, device_uid.get(), model_uid.get(), manufacturer_uid.get(), k_zero_time_stamp_period);\n\tFailIf(success == false, error = kIOReturnNoMemory, Failure, \"Failed to init SimpleAudioDevice\");\n\t\n\tivars->m_simple_audio_device->SetName(device_name.get());\n\t\n\t\/\/ Add the device object to the driver.\n\tAddObject(ivars->m_simple_audio_device.get());\n\t\t\t\n\t\/\/ Register the service.\n\terror = RegisterService();\n\tFailIfError(error, , Failure, \"failed to register service!\");\n\t\n\treturn kIOReturnSuccess;\n\t\nFailure:\n\treturn error;\n}\n```\n\n### Implement a user client interface\n\nThere are two dictionaries in the `Info.plist` file that define how the driver acts as a user client to the Core Audio Hardware Abstraction Layer (HAL) and to other apps. The first dictionary, `IOUserAudioDriverUserClientProperties`, maps `IOClass` to `IOUserUserClient` and `IOUserClass` to `IOUserAudioDriverUserClient`. This allows the HAL to connect to the driver. To support user client connections from apps, the sample also defines a custom user client class. The dictionary for the custom user client has the key `SimpleAudioDriverUserClientProperties`, and its `IOUserClass` has the value `SimpleAudioDriverUserClient`, a custom subclass of `IOUserClient`. Drivers that don’t accept user client connections from apps don’t need this second dictionary.\n\nWhen the HAL requires a new user client connection to the dext, it calls the driver’s [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOService\/NewUserClient] method. In the sample, the implementation of this method serves two purposes. If the incoming client type is `kIOUserAudioDriverUserClientType`, then this is a request from the HAL. In this case, the driver just forwards the call to the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDriver] superclass. For other client types, such as apps connecting to the driver, it uses the `SimpleAudioDriverUserClientProperties` values from the `Info.plist` file to create an instance of the custom `SimpleAudioDriverUserClient` class.\n\n```c++\nkern_return_t SimpleAudioDriver::NewUserClient_Impl(uint32_t in_type, IOUserClient** out_user_client)\n{\n\tkern_return_t error = kIOReturnSuccess;\n\t\n\t\/\/ Have the superclass create the IOUserAudioDriverUserClient object\n\t\/\/ if the type is kIOUserAudioDriverUserClientType.\n\tif (in_type == kIOUserAudioDriverUserClientType)\n\t{\n\t\terror = super::NewUserClient(in_type, out_user_client, SUPERDISPATCH);\n\t\tFailIfError(error, , Failure, \"Failed to create user client\");\n\t\tFailIfNULL(*out_user_client, error = kIOReturnNoMemory, Failure, \"Failed to create user client\");\n\t}\n\telse\n\t{\n\t\tIOService* user_client_service = nullptr;\n\t\terror = Create(this, \"SimpleAudioDriverUserClientProperties\", &user_client_service);\n\t\tFailIfError(error, , Failure, \"failed to create the SimpleAudioDriver user client\");\n\t\t*out_user_client = OSDynamicCast(IOUserClient, user_client_service);\n\t}\n\t\nFailure:\n\treturn error;\n}\n```\n\n### Create audio objects in the device initializer\n\nThe device class manages the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioStream] interfaces that perform audio I\/O. It can also contain controls and custom properties that interact with the audio stream.\n\nIn the sample, the `SimpleAudioDevice` initializer method declares the stream format to use for `IOUserAudioStream` objects: single-channel, PCM, using 16-bit native-endian signed integer. It also sets two available sample rates — `44100.0` and `48000.0` — which a person using the sample app can toggle.\n\n```c++\ndouble sample_rates[] = {kSampleRate_1, kSampleRate_2};\nSetAvailableSampleRates(sample_rates, 2);\nSetSampleRate(kSampleRate_1);\nconst auto channels_per_frame = 1;\nIOUserAudioChannelLabel input_channel_layout[channels_per_frame] = { IOUserAudioChannelLabel::Mono };\nIOUserAudioChannelLabel output_channel_layout[channels_per_frame] = { IOUserAudioChannelLabel::Mono };\n\nIOUserAudioStreamBasicDescription stream_formats[] =\n{\n\t{\n\t\tkSampleRate_1, IOUserAudioFormatID::LinearPCM,\n\t\tstatic_cast<IOUserAudioFormatFlags>(IOUserAudioFormatFlags::FormatFlagIsSignedInteger | IOUserAudioFormatFlags::FormatFlagsNativeEndian),\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\t1,\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\tstatic_cast<uint32_t>(channels_per_frame),\n\t\t16\n\t},\n\t{\n\t\tkSampleRate_2, IOUserAudioFormatID::LinearPCM,\n\t\tstatic_cast<IOUserAudioFormatFlags>(IOUserAudioFormatFlags::FormatFlagIsSignedInteger | IOUserAudioFormatFlags::FormatFlagsNativeEndian),\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\t1,\n\t\tstatic_cast<uint32_t>(sizeof(int16_t)*channels_per_frame),\n\t\tstatic_cast<uint32_t>(channels_per_frame),\n\t\t16\n\t},\n};\n```\n\nAudioDriverKit maps the memory of these streams to the Core Audio HAL. In an actual hardware driver, this memory needs to be the same I\/O memory the system uses for DMA to hardware.\n\n```c++\nOSSharedPtr<IOBufferMemoryDescriptor> output_io_ring_buffer;\nOSSharedPtr<IOBufferMemoryDescriptor> input_io_ring_buffer;\nconst auto buffer_size_bytes = static_cast<uint32_t>(in_zero_timestamp_period * sizeof(uint16_t) * channels_per_frame);\nerror = IOBufferMemoryDescriptor::Create(kIOMemoryDirectionInOut, buffer_size_bytes, 0, output_io_ring_buffer.attach());\nFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create output IOBufferMemoryDescriptor\");\n\nerror = IOBufferMemoryDescriptor::Create(kIOMemoryDirectionInOut, buffer_size_bytes, 0, input_io_ring_buffer.attach());\nFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create input IOBufferMemoryDescriptor\");\n\n\/\/ Create an output\/input stream object and pass in the I\/O ring buffer memory descriptor.\nivars->m_output_stream = IOUserAudioStream::Create(in_driver, IOUserAudioStreamDirection::Output, output_io_ring_buffer.get());\nFailIfNULL(ivars->m_output_stream.get(), error = kIOReturnNoMemory, Failure, \"failed to create output stream\");\n\nivars->m_input_stream = IOUserAudioStream::Create(in_driver, IOUserAudioStreamDirection::Input, input_io_ring_buffer.get());\nFailIfNULL(ivars->m_input_stream.get(), error = kIOReturnNoMemory, Failure, \"failed to create input stream\");\n\n\/\/\tConfigure stream properties: name, available formats, and current format.\nivars->m_output_stream->SetName(output_stream_name.get());\nivars->m_output_stream->SetAvailableStreamFormats(stream_formats, 2);\nivars->m_stream_format = stream_formats[0];\nivars->m_output_stream->SetCurrentStreamFormat(&ivars->m_stream_format);\n\nivars->m_input_stream->SetName(input_stream_name.get());\nivars->m_input_stream->SetAvailableStreamFormats(stream_formats, 2);\nivars->m_input_stream->SetCurrentStreamFormat(&ivars->m_stream_format);\n\n\/\/ Add a stream object to the driver.\nerror = AddStream(ivars->m_output_stream.get());\nFailIfError(error, , Failure, \"failed to add output stream\");\n\nerror = AddStream(ivars->m_input_stream.get());\nFailIfError(error, , Failure, \"failed to add input stream\");\n```\n\n### Create standard controls in the device\n\nAudioDriverKit provides [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioControl] objects for standard user interface to an audio device. Along with general controls for a toggle, slider, or selection interface to device properties, there are standard controls for volume and stereo pan. The sample driver adds an instance of the volume control, [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioLevelControl], in its initializer, which provides the volume slider in Audio MIDI Setup in macOS.\n\nThe following code example creates the audio level control with a default level of -6.0 decibels (dB), and a range of -96.0 to 0.0 dB. Like all audio controls, the level control has an element and scope to set; these properties have the same meaning as the [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AudioUnitElement] and [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AudioUnitScope] of an [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox\/AUAudioUnit] in [doc:\/\/com.apple.documentation\/documentation\/AudioToolbox]. In this case, the element [audiodriverkit\/iouseraudiodriver] affects the entire control, and the scope [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/AudioDriverKit\/IOUserAudioObjectPropertyScope\/Input] indicates that this control affects input from the device.\n\n```c++\n\/\/ Create the volume control object for the input stream.\nivars->m_input_volume_control = IOUserAudioLevelControl::Create(in_driver,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-6.0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{-96.0, 0.0},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioObjectPropertyElementMain,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioObjectPropertyScope::Input,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioClassID::VolumeControl);\nFailIfNULL(ivars->m_input_volume_control.get(), error = kIOReturnNoMemory, Failure, \"Failed to create input volume control\");\nivars->m_input_volume_control->SetName(input_volume_control_name.get());\n\n\/\/ Add the volume control to the device object.\nerror = AddControl(ivars->m_input_volume_control.get());\nFailIfError(error, , Failure, \"failed to add input volume level control\");\n```\n\n### Create custom properties to control the device\n\nThe sample creates two custom control properties for its virtual device. In the code example below, the sample creates a property address reference for a property selector, using the main element and global scope. It then creates local pointer variables for the property selector, the data, and an optional qualifier that provides further detail about how to use the property data.\n\n```c++\nIOUserAudioObjectPropertyAddress prop_addr = {\n\tkSimpleAudioDriverCustomPropertySelector,\n\tIOUserAudioObjectPropertyScope::Global,\n\tIOUserAudioObjectPropertyElementMain };\nOSSharedPtr<IOUserAudioCustomProperty> custom_property = nullptr;\nOSSharedPtr<OSString> qualifier = nullptr;\nOSSharedPtr<OSString> data = nullptr;\n```\n\nLater in the device’s initializer, the following code example creates the custom property from the property address, setting two qualifier\/data pairs before adding the custom property.\n\n```c++\ncustom_property = IOUserAudioCustomProperty::Create(in_driver,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprop_addr,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioCustomPropertyDataType::String,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIOUserAudioCustomPropertyDataType::String);\n\n\/\/ Set the qualifier and data-value pair on the custom property.\nqualifier = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyQualifier0), OSNoRetain);\ndata = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyDataValue0), OSNoRetain);\ncustom_property->SetQualifierAndDataValue(qualifier.get(), data.get());\n   \n\/\/ Set another qualifier and data-value pair on the custom property.\nqualifier = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyQualifier1), OSNoRetain);\ndata = OSSharedPtr(OSString::withCString(kSimpleAudioDriverCustomPropertyDataValue1), OSNoRetain);\ncustom_property->SetQualifierAndDataValue(qualifier.get(), data.get());\nAddCustomProperty(custom_property.get());\n```\n\n\n\n### Handle the callback to start device I\/O\n\nBecause the sample project doesn’t connect to a hardware device, it uses timers and actions in place of hardware interrupts and DMA. When the HAL attempts to start I\/O on the device, it calls `SimpleAudioDevice::StartIO`. AudioDriverKit provides this method to signal the driver to perform any necessary calls to start I\/O on the device. The sample project uses this signal to start its timers.\n\nIn the sample, the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/StartIO] implementation calls `GetIOMemoryDescriptor` to get the streams’ memory descriptors, and then creates an [doc:\/\/com.apple.documentation\/documentation\/kernel\/iomemorymap] with [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOMemoryDescriptor\/CreateMapping]. After setting up the mapping, the sample uses a private helper method, `StartTimers`, to configure and enable the time sources and actions to generate timestamps and fill out the input audio buffer.\n\n```c++\nkern_return_t SimpleAudioDevice::StartIO(IOUserAudioStartStopFlags in_flags)\n{\n\tDebugMsg(\"Start I\/O: device %u\", GetObjectID());\n\t\n\t__block kern_return_t error = kIOReturnSuccess;\n\t__block OSSharedPtr<IOMemoryDescriptor> input_iomd;\n\t__block OSSharedPtr<IOMemoryDescriptor> output_iomd;\n\n\tivars->m_work_queue->DispatchSync(^(){\n\t\t\/\/\tTell IOUserAudioObject base class to start I\/O for the device.\n\t\terror = super::StartIO(in_flags);\n\t\tFailIfError(error, , Failure, \"Failed to start I\/O\");\n\t\t\n\t\toutput_iomd = ivars->m_output_stream->GetIOMemoryDescriptor();\n\t\tFailIfNULL(output_iomd.get(), error = kIOReturnNoMemory, Failure, \"Failed to get output stream IOMemoryDescriptor\");\n\t\terror = output_iomd->CreateMapping(0, 0, 0, 0, 0, ivars->m_output_memory_map.attach());\n\t\tFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create memory map from output stream IOMemoryDescriptor\");\n\t\t\n\t\tinput_iomd = ivars->m_input_stream->GetIOMemoryDescriptor();\n\t\tFailIfNULL(input_iomd.get(), error = kIOReturnNoMemory, Failure, \"Failed to get input stream IOMemoryDescriptor\");\n\t\terror = input_iomd->CreateMapping(0, 0, 0, 0, 0, ivars->m_input_memory_map.attach());\n\t\tFailIf(error != kIOReturnSuccess, , Failure, \"Failed to create memory map from input stream IOMemoryDescriptor\");\n\n\t\t\/\/ Start the timers to send timestamps and generate sine tone on the stream I\/O buffer.\n\t\tStartTimers();\n\t\treturn;\n\t\t\n\tFailure:\n\t\tsuper::StopIO(in_flags);\n\t\tivars->m_output_memory_map.reset();\n\t\tivars->m_input_memory_map.reset();\n\t\treturn;\n\t});\n\n\treturn error;\n}\n```\n\nAn [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice] is a subclass of [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice], and as such, it’s responsible for timekeeping between the driver and the hardware device. AudioDriverKit enables this with the methods [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/UpdateCurrentZeroTimestamp] and [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/GetCurrentZeroTimestamp]. The framework handles the timestamps atomically, and the HAL uses the sample time-host time pair to run and synchronize I\/O. Therefore, it’s vital to track the hardware clock’s timestamps as closely as possible.\n\nIn the case of the sample device, timers and actions simulate calls from a hardware device. These actions manage the zero timestamp values. The device class’s initializer creates an [doc:\/\/com.apple.documentation\/documentation\/DriverKit\/IOTimerDispatchSource] to serve as the timer. Then it creates an action to invoke a callback named `ZtsTimerOccurred`, which simulates the handling of a hardware callback.\n\n```c++\n\/\/ Initialize the timer that stands in for a real interrupt.\nerror = IOTimerDispatchSource::Create(ivars->m_work_queue.get(), &zts_timer_event_source);\nFailIfError(error, , Failure, \"failed to create the ZTS timer event source\");\nivars->m_zts_timer_event_source = OSSharedPtr(zts_timer_event_source, OSNoRetain);\n\n\/\/ Create a timer action to generate timestamps.\nerror = CreateActionZtsTimerOccurred(sizeof(void*), &zts_timer_occurred_action);\nFailIfError(error, , Failure, \"failed to create the timer event source action\");\nivars->m_zts_timer_occurred_action = OSSharedPtr(zts_timer_occurred_action, OSNoRetain);\nivars->m_zts_timer_event_source->SetHandler(ivars->m_zts_timer_occurred_action.get());\n```\n\nIn the `StartTimers` method, which `StartIO` calls earlier, the sample calls `UpdateCurrentZeroTimestamp` to update the pair of values that represents the sample time and host time. Then it starts the timer that the sample creates in the previous code example, using [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] and host ticks from the device to schedule the timed callback.\n\n```c++\n\/\/ Clear the device's timestamps.\nUpdateCurrentZeroTimestamp(0, 0);\nauto current_time = mach_absolute_time();\n\n\/\/ Start the timer. The first timestamp occurs when the timer goes off.\nivars->m_zts_timer_event_source->WakeAtTime(kIOTimerClockMachAbsoluteTime, current_time + ivars->m_zts_host_ticks_per_buffer, 0);\nivars->m_zts_timer_event_source->SetEnable(true);\n```\n\nWhen the `ZtsTimerOccurred` action fires, it gets the last zero timestamp value from the device by calling `GetCurrentZeroTimestamp`. If this is the first timestamp, it uses `mach_absolute_time` as the anchor time. Otherwise, it updates the timestamps by the zero timestamp period and host ticks per buffer. Either way, it updates the device’s timestamps with a call to `UpdateCurrentZeroTimestamp`. Finally, it sets the timer to wake up in the future for the next zero timestamp.\n\n```c++\nvoid\tSimpleAudioDevice::ZtsTimerOccurred_Impl(OSAction* action, uint64_t time)\n{\n\t\/\/ Get the current time.\n\tauto current_time = time;\n\t\n\t\/\/ Increment the timestamps...\n\tuint64_t current_sample_time = 0;\n\tuint64_t current_host_time = 0;\n\tGetCurrentZeroTimestamp(&current_sample_time, &current_host_time);\n\t\n\tauto host_ticks_per_buffer = ivars->m_zts_host_ticks_per_buffer;\n\t\n\tif(current_host_time != 0)\n\t{\n\t\tcurrent_sample_time += GetZeroTimestampPeriod();\n\t\tcurrent_host_time += host_ticks_per_buffer;\n\t}\n\telse\n\t{\n\t\t\/\/ ...but not if it's the first one.\n\t\tcurrent_sample_time = 0;\n\t\tcurrent_host_time = current_time;\n\t}\n\t\n\t\/\/ Update the device with the current timestamp.\n\tUpdateCurrentZeroTimestamp(current_sample_time, current_host_time);\n\t\n\t\/\/ Set the timer to go off in one buffer.\n\tivars->m_zts_timer_event_source->WakeAtTime(kIOTimerClockMachAbsoluteTime,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrent_host_time + host_ticks_per_buffer, 0);\n}\n```\n\n### Use real-time callbacks to perform signal processing in the driver\n\nFor drivers that need to perform signal processing, AudioDriverKit provides real-time callbacks. The driver registers a block that the system calls in a real-time context whenever an I\/O operation occurs on the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioStream] buffers for the device.\n\nIn the sample code, this is how `SimpleAudioDriver` creates its sine tone. It declares its callback in the `SimpleAudioDevice` initalizer.\n\n```c++\nio_operation = ^kern_return_t(IOUserAudioObjectID in_device,\n\t\t\t\t\t\t\t  IOUserAudioIOOperation in_io_operation,\n\t\t\t\t\t\t\t  uint32_t in_io_buffer_frame_size,\n\t\t\t\t\t\t\t  uint64_t in_sample_time,\n\t\t\t\t\t\t\t  uint64_t in_host_time)\n{\n```\n\nThe block receives a reference to the device, the operation it’s performing, the buffer size, and the sample and host times. `SimpleAudioDriver` checks that the operation is `IOUserAudioIOOperationBeginRead`, and if it is, it fills its audio buffers with signal data. The data is either loopback from the audio output, or a programmatically generated sine tone that results from a call to a private method, `GenerateToneForInput`.\n\nBecause this callback block runs on a real-time thread, it must not perform any lengthy or indeterminate operations. This includes things like allocating memory, acquiring locks, calling Objective-C or Swift methods, and performing file system or network I\/O.\n\nTo set this block as the callback, the sample calls the [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice] method [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/SetIOOperationHandler].\n\n```c++\nthis->SetIOOperationHandler(io_operation);\n```\n\n### Access DMA audio buffers\n\nAs mentioned previously, a private method called `GenerateToneForInput` creates the sine tone. This is where the sample simulates writing audio data to DMA, and thereby delivers it to the hardware.\n\nThis method starts by checking that the `m_input_memory_map` that [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/StartIO] creates is valid. If so, it uses the memory map buffer length and stream format to calculate the length in samples for the I\/O buffer. Because the sample project supports only signed, 16-bit PCM audio, it recasts the buffer to an `int_16` pointer.\n\nWith the calculated buffer length and the pointer ready, it’s possible to fill the buffer with the sine tone. The sample starts by getting the current volume control gain as a scalar value. Next, it loops for the number of samples necessary to fill the buffer. In the loop, it calculates a sine value for each sample and applies the volume gain, then writes this value as a signed, 16-bit integer to all the channels in the buffer’s format.\n\n```c++\nvoid SimpleAudioDevice::GenerateToneForInput(double in_tone_freq, size_t in_sample_time, size_t in_frame_size)\n{\n\t\/\/ Fill out the input buffer with a sine tone.\n\tif (ivars->m_input_memory_map)\n\t{\n\t\t\/\/ Get the pointer to the I\/O buffer and use stream format information\n\t\t\/\/ to get the buffer length.\n\t\tconst auto& format = ivars->m_stream_format;\n\t\tauto buffer_length = ivars->m_input_memory_map->GetLength() \/ (format.mBytesPerFrame \/ format.mChannelsPerFrame);\n\t\tauto num_samples = in_frame_size;\n\t\tauto buffer = reinterpret_cast<int16_t*>(ivars->m_input_memory_map->GetAddress() + ivars->m_input_memory_map->GetOffset());\n\n\t\t\/\/ Get the volume control dB value to apply gain to the tone.\n\t\tauto input_volume_level = ivars->m_input_volume_control->GetScalarValue();\n\t\t\n\t\tfor(size_t i = 0; i < num_samples; i++)\n\t\t{\n\t\t\tfloat float_value = input_volume_level * sin(2.0 * M_PI * in_tone_freq * static_cast<double>(ivars->m_tone_sample_index) \/ format.mSampleRate);\n\t\t\tint16_t integer_value = FloatToInt16(float_value);\n\t\t\tfor (auto channel_index = 0; channel_index < format.mChannelsPerFrame; channel_index++)\n\t\t\t{\n\t\t\t\tauto buffer_index = (format.mChannelsPerFrame * (in_sample_time + i) + channel_index) % buffer_length;\n\t\t\t\tbuffer[buffer_index] = integer_value;\n\t\t\t}\n\t\t\tivars->m_tone_sample_index += 1;\n\t\t}\n\t}\n}\n```\n\n### Handle configuration changes\n\nAt this point, the driver and device can supply an audio stream as if it’s coming from an external device. One other task a driver needs to support is handling configuration changes from the device. Three methods from [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice] support this ability:\n\n- [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/RequestDeviceConfigurationChange] — A driver calls this method on the device prior to any configuration action. AudioDriverKit temporarily shuts down the audio stream — calling the device’s [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/StopIO] callback — so that the device class can perform the configuration change.\n- [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/PerformDeviceConfigurationChange] — AudioDriverKit calls this method after stopping any running I\/O, signaling to the device class that it can perform its configuration change. This is where the device can change sample rate and format, or perform other changes that are only safe while I\/O isn’t occurring. After this method returns, AudioDriverKit restarts I\/O if necessary, calling the device’s [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioDevice\/StartIO] callback.\n- [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/AbortDeviceConfigurationChange] — A driver calls this method to stop a change from a request to `RequestDeviceConfigurationChange`. The sample doesn’t need to perform any additional work to implement this method, so it just calls its superclass’s implementation.\n\nIn the sample code project, changing the sample rate provides an example of how to perform a configuration change. When a person taps the Toggle Sample Rate button, the app makes a user client call to the driver’s `HandleTestConfigChange` method. The driver calls `RequestDeviceConfigurationChange`, which tells AudioDriverKit to shut down I\/O and then make a callback to `PerformDeviceConfigurationChange`.\n\n```c++\nkern_return_t SimpleAudioDriver::HandleTestConfigChange()\n{\n\tauto change_info = OSSharedPtr(OSString::withCString(\"Toggle Sample Rate\"), OSNoRetain);\n\treturn ivars->m_simple_audio_device->RequestDeviceConfigurationChange(k_custom_config_change_action, change_info.get());\n}\n```\n\nThe implementation of `PerformDeviceConfigurationChange` starts by logging a string it receives from the initial callback in the app. Then it toggles between one of two preset sample rate values, and sets the new sample rate on the clock device with [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioClockDevice\/SetSampleRate]. Assuming this succeeds, it then sets the sample rate on both the input and output streams with [doc:\/\/com.apple.documentation\/documentation\/AudioDriverKit\/IOUserAudioStream\/DeviceSampleRateChanged]. Finally, it calls the superclass’s implementation of `PerformDeviceConfigurationChange`.\n\n```c++\nkern_return_t SimpleAudioDevice::PerformDeviceConfigurationChange(uint64_t change_action, OSObject* in_change_info)\n{\n\tDebugMsg(\"change action %llu\", change_action);\n\tkern_return_t ret = kIOReturnSuccess;\n\tswitch (change_action) {\n\t\t\t\/\/ Add custom config change handlers.\n\t\tcase k_custom_config_change_action:\n\t\t{\n\t\t\tif (in_change_info)\n\t\t\t{\n\t\t\t\tauto change_info_string = OSDynamicCast(OSString, in_change_info);\n\t\t\t\tDebugMsg(\"%s\", change_info_string->getCStringNoCopy());\n\t\t\t}\n\t\t\t\n\t\t\t\/\/ Toggle the sample rate of the device.\n\t\t\tdouble rate_to_set = static_cast<uint64_t>(GetSampleRate()) != static_cast<uint64_t>(kSampleRate_1) ? kSampleRate_1 : kSampleRate_2;\n\t\t\tret = SetSampleRate(rate_to_set);\n\t\t\tif (ret == kIOReturnSuccess)\n\t\t\t{\n\t\t\t\t\/\/ Update the stream formats with the new rate.\n\t\t\t\tret = ivars->m_input_stream->DeviceSampleRateChanged(rate_to_set);\n\t\t\t\tret = ivars->m_output_stream->DeviceSampleRateChanged(rate_to_set);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tret = super::PerformDeviceConfigurationChange(change_action, in_change_info);\n\t\t\tbreak;\n\t}\n\t\n\t\/\/ Update the cached format.\n\tivars->m_stream_format = ivars->m_input_stream->GetCurrentStreamFormat();\n\t\n\treturn ret;\n}\n```\n\nWhen this method returns, the configuration change is complete, and the system resumes I\/O with the device.\n\n## Essentials\n\n- **IOUserAudioObject**: The base class for most classes in the framework.\n- **IOUserAudioDriver**: A DriverKit provider object that manages communications with an audio device.\n- **DriverKit Audio Family**: A Boolean value that indicates whether the device supports audio functionality.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "The base class for most classes in the framework.",
          "name" : "IOUserAudioObject",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioDriverKit\/IOUserAudioObject"
        },
        {
          "description" : "A DriverKit provider object that manages communications with an audio device.",
          "name" : "IOUserAudioDriver",
          "url" : "https:\/\/developer.apple.com\/documentation\/AudioDriverKit\/IOUserAudioDriver"
        },
        {
          "description" : "A Boolean value that indicates whether the device supports audio functionality.",
          "name" : "DriverKit Audio Family",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.driverkit.family.audio"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating an audio device driver",
  "url" : "https:\/\/developer.apple.com\/documentation\/AudioDriverKit\/creating-an-audio-device-driver"
}