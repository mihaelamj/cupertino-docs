{
  "abstract" : "Fix problems that stem from architectural differences between Apple silicon and Intel-based Mac computers.",
  "codeExamples" : [
    {
      "code" : "int foo(const char *mystr, BOOL mybool, char mychar, int myint, long mylong)\n{\n    NSLog(@\"foo(%s, %x, %x, %x, %lx)\", mystr, mybool, mychar, myint, mylong);\n    return 42;\n}",
      "language" : "occ"
    },
    {
      "code" : "extern int foo(const char *mystr, ...);\nvoid printTestValues() {\n   BOOL mybool = YES;\n   char mychar = 42;\n   int myint = 0xfeedface;\n   long mylong = 0x0123456789abcdef;\n   foo(\"hello\", mybool, mychar, myint, mylong);\n}",
      "language" : "swift"
    },
    {
      "code" : "- (void)document:(NSDocument*)doc \n         didSave:(BOOL)didSave \n     contextInfo:(void*)contextInfo;",
      "language" : "occ"
    },
    {
      "code" : "\/\/ Declare a type-safe function pointer.\nvoid (* didSaveDispatcher)(id,SEL,NSDocument *,BOOL,void *) = \n       (void(*)(id,SEL,NSDocument *,BOOL,void *))objc_msgSend;",
      "language" : "occ"
    },
    {
      "code" : "\/\/ Call the function, dispatching it through objc_msgSend.\ndidSaveDispatcher(myDelegate, mySelector, myDocument, NO, myPtr);",
      "language" : "occ"
    },
    {
      "code" : "int GOOD_count_leading_zeroes(int x){\n    int count;\n    if(x == 0){\n        return (sizeof(x) * CHAR_BIT);\n    }\n#if __has_builtin(__builtin_clz)\n    count = __builtin_clz(x); \/\/ undefined when operating on 0\n#else\n    int index = 1;\n    for(; x != 1; ++index){\n        x = (unsigned)x >> 1;\n    }\n    count = ((sizeof(x) * CHAR_BIT) - index);\n#endif",
      "language" : "occ"
    },
    {
      "code" : "int BAD_count_leading_zeroes(int x){\n    int count;\n    if(x == 0){\n        return (sizeof(x) * CHAR_BIT);\n    }\n#if defined(__x86_64__)\n    __asm__ (\n        \"bsrl %1, %0\\n\\t\" \/\/ undefined when operating on 0\n        \"xorl $0x1f, %1\"\n        : \"=r\" (count)\n        : \"r\" (x)\n    );\n#elif defined(__aarch64__)\n    __asm__ (\n        \"clz %w1, %w0\"\n        : \"=r\" (count)\n        : \"r\" (x)\n    );\n#else\n    int index = 1;\n    for(; x != 1; ++index){\n        x = (unsigned)x >> 1;\n    }\n    count = ((sizeof(x) * CHAR_BIT) - index);\n#endif\n    return count;\n}",
      "language" : "occ"
    },
    {
      "code" : "uint64_t MachTimeToNanoseconds(uint64_t machTime) {\n    uint64_t nanoseconds = 0;\n    static mach_timebase_info_data_t sTimebase;\n    if (sTimebase.denom == 0)\n        (void)mach_timebase_info(&sTimebase);\n\n    nanoseconds = ((machTime * sTimebase.numer) \/ sTimebase.denom);\n\n    return nanoseconds;\n}",
      "language" : "occ"
    },
    {
      "code" : "uint32_t a = (uint32_t)INFINITY;\nint32_t b = (int32_t)INFINITY;",
      "language" : "occ"
    },
    {
      "code" : "a = 0xffffffff = 4294967295  \/\/ The largest unsigned integer\nb = 0x7fffffff = 2147483647  \/\/ The largest signed integer",
      "language" : "swift"
    },
    {
      "code" : "a = 0x00000000 = 0  \/\/ Wrap around to zero.\nb = 0x80000000 = -21474836548  \/\/ The indefinite integer value.",
      "language" : "swift"
    },
    {
      "code" : "int nBytes = 1024;\nBOOL receivedBytes = nBytes;\n\nif (receivedBytes) {\n   printf(\"Success!\\n\");\n} else {\n   printf(\"Failure...\\n\");\n}",
      "language" : "occ"
    },
    {
      "code" : "int nBytes = 1024;\nBOOL receivedBytes = !!nBytes;",
      "language" : "occ"
    }
  ],
  "contentHash" : "7708900be63c7686edb11ea2f1eb859a6ffe4d49a8acc012a992272e620d0cda",
  "crawledAt" : "2025-12-03T05:51:16Z",
  "id" : "10FC6BF4-CA57-4339-A27E-AEDDF682FBCA",
  "kind" : "article",
  "language" : "swift",
  "overview" : "## Overview\n\nAssumptions you make for your code on Intel-based Mac computers may not always apply on Apple silicon. Architectural differences between the two systems exist, and may cause your code to run incorrectly or crash. Use the following tips to identify potential problem areas in your code before you begin testing.\n\n### Fetch System and Hardware Details Dynamically\n\nCode that depends on specific system details or hardware configurations may crash or yield unexpected behaviors on Apple silicon. Many hardware features are different on Apple silicon and Intel-based Mac computers; some system features may also be different. If you hardcode a particular value for a feature, your code may not work as expected on systems where the value is different.\n\nInstead of hardcoding values related to the underlying system, fetch those values dynamically from system global variables whenever possible. For example, fetch the size of virtual memory pages from the `vm_page_size` global variable. When a global variable isn’t available, use the `sysctl` or [doc:\/\/com.apple.documentation\/documentation\/kernel\/1387446-sysctlbyname] functions to fetch the information instead.\n\nSome features of Apple silicon are decidedly different than those of Intel-based Mac computers, and may impact your code if you don’t fetch them dynamically. These features include:\n\nTo see the list of available hardware features, run the command `sysctl hw` command in Terminal. For other system features, run `sysctl` with a different domain string, such as `kern`, `user`, or `machdep`.\n\n### Synchronize Access to Shared Data in Memory\n\nAlways protect shared data with locks, memory barriers, and other synchronization primitives present in macOS. A strong memory-ordering model, like the one in Intel-based Mac computers, adds implicit memory barriers to prevent the processor from reordering load and store instructions in a way that might introduce race conditions. A weak memory ordering model, like the one in Apple silicon, gives the processor more flexibility to reorder memory instructions and improve performance, but doesn’t add implicit memory barriers. To ensure the correctness of your code on both platforms, add explicit synchronization primitives to your code.\n\nmacOS includes numerous synchronization primitives:\n\nIf you use lockless algorithms or custom synchronization techniques, consider replacing them with system-provided primitives. If you’re not able to adopt the system primitives, validate the correctness of your custom code on Apple silicon before deploying it in your binary.\n\n### Don’t Redeclare a Function to Have Variable Parameters\n\nThe `x86_64` and `arm64` architectures have different calling conventions for variadic functions—functions with a variable number of parameters. On `x86_64`, the compiler treats fixed and variadic parameters the same, placing parameters in registers first and only using the stack when no more registers are available. On `arm64`, the compiler always places variadic parameters on the stack, regardless of whether registers are available. If you implement a function with fixed parameters, but redeclare it with variadic parameters, the mismatch causes unexpected behavior at runtime.\n\nTo understand the problem, consider the following function, which has only fixed parameters:\n\nIt’s possible to redeclare the function elsewhere in your library and execute it successfully with code similar to the following on the `x86_64` architecture:\n\nThe same code fails on `arm64` because the caller of the function and the function itself marshal the parameters differently. The function expects all of the parameters to be in registers. However, the caller passes only the first parameter in a register; it passes all remaining parameters on the stack. As a result, the function implementation looks for the parameters in the wrong place, leading to unexpected results.\n\nEven if you don’t redeclare your functions explicitly, functions like [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] redeclare your functions and methods implicitly. For more information, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code#Enable-Strict-Type-Enforcement-for-Dynamic-Method-Dispatching].\n\n### Enable Strict Type Enforcement for Dynamic Method Dispatching\n\nDue to calling convention differences between the `x86_64` and `arm64` architectures, update your dynamic-dispatching code to pass parameters correctly on both platforms. A function like [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] calls a method of an object, passing the parameters you supply to that method. Because [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] must support calls to any method, it accepts a variable list of parameters instead of fixed parameters. This usage of variable parameters changes how [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] calls your function, effectively redeclaring your method as a variadic function.\n\nTo illustrate the problem, consider an example where you want to call the following method using [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend]:\n\nBecause [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] declares your method as variadic, the compiler places the method’s parameters on the stack, in accordance with the calling conventions for the `arm64` architecture. However, the original method declaration contains fixed parameters, not variable parameters. As a result, the method’s implementation looks for its parameters in registers, which is where the compiler places fixed parameters for `arm64`. This mismatch causes the method call to generate undefined results.\n\nTo fix dynamic-dispatching issues in your code, define a type-safe function pointer instead of calling [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] directly. You can use type-safe function pointers in both your `arm64` and `x86_64` code. A type-safe function pointer specifies the exact number of parameters, and incorporates the type information for each parameter into the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] call, allowing the compiler to generate the calling conventions the method expects. For example, a type-safe function pointer for the `document:didSave:contextInfo:` method looks like the following:\n\nTo initiate the dynamic dispatch operation, pass the target object, selector, and method parameters to your function pointer, as shown in the following code:\n\nTo locate places where you’re not calling [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] in a type-safe way, enable the Enable strict Checking of objc_msgSend Calls build setting. When the value of that setting is `YES`, the compiler flags your code where you’re not using a type-safe function pointer with [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend].\n\n### Address Numerical Differences in Specific Frameworks\n\nSome frameworks include minor changes that might impact code when porting to Apple silicon. For example:\n\nFor additional information about framework differences, see the specific framework reference.\n\n### Replace Raw Assembly Code with Builtin Intrinsics\n\nIf your app uses assembly code for specific tasks, or uses processor-specific `__builtin` functions, switch to the compiler’s builtin intrinsic functions instead. The compiler’s builtin intrinsics give you the same benefits of assembly code, but in a cross-platform package. During compilation, the compiler substitutes the builtin intrinsic function call for the appropriate set of assembly instructions for the current platform.\n\nTo illustrate the benefits of builtin intrinsics, consider the implementation of a function that counts the number of leading zeros in a value. The following example shows you how to use the builtin intrinsic for the `CLZ` instruction to count the number of leading zeros in an integer.\n\nImplementing the same behavior without the builtin intrinsic requires significantly more code, as shown in the following example. The required code is also more complicated because it provides custom implementations for each processor architecture.\n\nFor a list of builtin intrinsic functions provided by the clang compiler, see the clang documentation at [https:\/\/llvm.org].\n\n### Update Processor-Specific Vector Instructions\n\nIf your code includes instructions for the SSE, AVX, AVX2, or AVX512 units of Intel processors, update that code to support Apple silicon. The best alternative to processor-specific vector code is to use the Accelerate framework, which provides a vast library of vector operations optimized for all Mac computers. Accelerate leverages all available hardware of the current system to perform:\n\nFor more information about the Accelerate framework, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate].\n\n### Apply Timebase Information to Mach Absolute Time Values\n\nAlways apply timebase information to values you receive from [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] and never assume that the function returns the number of nanoseconds since boot. The value returned by the [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] function is different for native and translated processes, and doesn’t necessarily correspond to the number of nanoseconds since boot. Applying timebase information ensures that you can distribute time values between processes and between different computers.\n\nThe following code shows how to apply the timebase information to the value returned by the [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] function:\n\nTo retrieve time values in nanoseconds without converting  [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] values, call the `clock_gettime_nsec_np` function instead.\n\n### Audit Code that Contains Float-to-Int Conversions\n\nApple silicon and Intel-based Mac computers handle some float-to-int conversions differently in C-based languages. To illustrate one of the differences, consider the conversion of the floating-point representation of infinity to a `uint32_t` or `int32_t` value:\n\nThe `arm64` architecture converts this value to the nearest possible integer.\n\nFor the unsigned conversion, the `x86_64` architecture wraps the value to `0`. For the signed conversion, it sets the value to an indefinite integer.\n\nIf your code converts floating-point numbers to integers, audit your code to make sure that you handle boundary conditions correctly. One way to detect invalid conversions is to run the UBSan tool with the `float-cast-overflow` option selected. To detect implicit conversions by the compiler, enable the `-Wconversion` compiler flag when building your code.\n\nFor information about how to use the UBSan tool, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/diagnosing-memory-thread-and-crash-issues-early].\n\n### Treat BOOL Variables as Binary Values\n\nAs a rule, the Objective-C [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/BOOL] type has only two appropriate values: `YES` or `NO`. On Apple silicon, the compiler defines the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/BOOL] type to be a native `bool`, but on Intel-based Mac computers, it is a signed` char`. To avoid issues in universal binaries:\n\nTo illustrate the problem, consider the following example:\n\nOn the `x86_64` architecture, `receivedBytes` evaluates to `0`, or `false`. On the `arm64` architecture, `receivedBytes` evaluates to `true`. One way to fix the preceding code is to include two negation operators (`!!`) in front of the `nBytes` variable before assigning it to the `receivedBytes` variable, as shown in the following example:\n\n### Update Just-In-Time Compilers\n\nUpdate the workflow of any just-in-time compilers to support Apple silicon, which prevent all memory pages from being simultaneously writable and executable. On Intel-based Mac computers, this same behavior applies only to apps that adopt the [doc:\/\/com.apple.documentation\/documentation\/Security\/hardened-runtime].\n\nFor more information, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/porting-just-in-time-compilers-to-apple-silicon].\n\n### Update C++ Code\n\nThe C++ ABI for Apple silicon matches the ABI for iOS devices, and not the ABI for Intel-based Mac computers. For information about the ABI, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Xcode\/Conceptual\/iPhoneOSABIReference\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40009020-SW1].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code\ncrawled: 2025-12-03T05:51:16Z\n---\n\n# Addressing architectural differences in your macOS code\n\n**Article**\n\nFix problems that stem from architectural differences between Apple silicon and Intel-based Mac computers.\n\n## Overview\n\nAssumptions you make for your code on Intel-based Mac computers may not always apply on Apple silicon. Architectural differences between the two systems exist, and may cause your code to run incorrectly or crash. Use the following tips to identify potential problem areas in your code before you begin testing.\n\n### Fetch System and Hardware Details Dynamically\n\nCode that depends on specific system details or hardware configurations may crash or yield unexpected behaviors on Apple silicon. Many hardware features are different on Apple silicon and Intel-based Mac computers; some system features may also be different. If you hardcode a particular value for a feature, your code may not work as expected on systems where the value is different.\n\nInstead of hardcoding values related to the underlying system, fetch those values dynamically from system global variables whenever possible. For example, fetch the size of virtual memory pages from the `vm_page_size` global variable. When a global variable isn’t available, use the `sysctl` or [doc:\/\/com.apple.documentation\/documentation\/kernel\/1387446-sysctlbyname] functions to fetch the information instead.\n\nSome features of Apple silicon are decidedly different than those of Intel-based Mac computers, and may impact your code if you don’t fetch them dynamically. These features include:\n\n- Virtual memory page sizes are different. Fetch the value from the `vm_page_size` global variable.\n- Cache line sizes are different. Fetch the `hw.cachelinesize` setting using `sysctl`.\n- CPU-specific features. Fetch the feature availability using sysctl and a string of the form `hw.optional.`*<feature>*, where *<feature>* is the feature you want. For example, to determine if AVX512 instructions are available, use the `hw.optional.avx512f` string.\n\nTo see the list of available hardware features, run the command `sysctl hw` command in Terminal. For other system features, run `sysctl` with a different domain string, such as `kern`, `user`, or `machdep`.\n\n### Synchronize Access to Shared Data in Memory\n\nAlways protect shared data with locks, memory barriers, and other synchronization primitives present in macOS. A strong memory-ordering model, like the one in Intel-based Mac computers, adds implicit memory barriers to prevent the processor from reordering load and store instructions in a way that might introduce race conditions. A weak memory ordering model, like the one in Apple silicon, gives the processor more flexibility to reorder memory instructions and improve performance, but doesn’t add implicit memory barriers. To ensure the correctness of your code on both platforms, add explicit synchronization primitives to your code.\n\nmacOS includes numerous synchronization primitives:\n\n- Grand Central Dispatch (GCD) provides serial queues and other ways to synchronize tasks; see [doc:\/\/com.apple.documentation\/documentation\/Dispatch].\n- The `@synchronized` directive creates a mutex lock for Objective-C code.\n- The [doc:\/\/com.apple.documentation\/documentation\/Foundation] framework defines standard mutexes, conditions, and other types of locks.\n- The [doc:\/\/com.apple.documentation\/documentation\/os] framework provides “unfair” locks for synchronization.\n- The pthreads library defines standard mutexes and condition variables.\n- The C11\/C++11 primitives in `stdatomic.h` support custom memory ordering in atomic operations.\n\nIf you use lockless algorithms or custom synchronization techniques, consider replacing them with system-provided primitives. If you’re not able to adopt the system primitives, validate the correctness of your custom code on Apple silicon before deploying it in your binary.\n\n\n\n### Don’t Redeclare a Function to Have Variable Parameters\n\nThe `x86_64` and `arm64` architectures have different calling conventions for variadic functions—functions with a variable number of parameters. On `x86_64`, the compiler treats fixed and variadic parameters the same, placing parameters in registers first and only using the stack when no more registers are available. On `arm64`, the compiler always places variadic parameters on the stack, regardless of whether registers are available. If you implement a function with fixed parameters, but redeclare it with variadic parameters, the mismatch causes unexpected behavior at runtime.\n\nTo understand the problem, consider the following function, which has only fixed parameters:\n\n```occ\nint foo(const char *mystr, BOOL mybool, char mychar, int myint, long mylong)\n{\n    NSLog(@\"foo(%s, %x, %x, %x, %lx)\", mystr, mybool, mychar, myint, mylong);\n    return 42;\n}\n```\n\nIt’s possible to redeclare the function elsewhere in your library and execute it successfully with code similar to the following on the `x86_64` architecture:\n\n```swift\nextern int foo(const char *mystr, ...);\nvoid printTestValues() {\n   BOOL mybool = YES;\n   char mychar = 42;\n   int myint = 0xfeedface;\n   long mylong = 0x0123456789abcdef;\n   foo(\"hello\", mybool, mychar, myint, mylong);\n}\n```\n\nThe same code fails on `arm64` because the caller of the function and the function itself marshal the parameters differently. The function expects all of the parameters to be in registers. However, the caller passes only the first parameter in a register; it passes all remaining parameters on the stack. As a result, the function implementation looks for the parameters in the wrong place, leading to unexpected results.\n\nEven if you don’t redeclare your functions explicitly, functions like [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] redeclare your functions and methods implicitly. For more information, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code#Enable-Strict-Type-Enforcement-for-Dynamic-Method-Dispatching].\n\n### Enable Strict Type Enforcement for Dynamic Method Dispatching\n\nDue to calling convention differences between the `x86_64` and `arm64` architectures, update your dynamic-dispatching code to pass parameters correctly on both platforms. A function like [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] calls a method of an object, passing the parameters you supply to that method. Because [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] must support calls to any method, it accepts a variable list of parameters instead of fixed parameters. This usage of variable parameters changes how [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] calls your function, effectively redeclaring your method as a variadic function.\n\nTo illustrate the problem, consider an example where you want to call the following method using [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend]:\n\n```occ\n- (void)document:(NSDocument*)doc \n         didSave:(BOOL)didSave \n     contextInfo:(void*)contextInfo;\n```\n\nBecause [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] declares your method as variadic, the compiler places the method’s parameters on the stack, in accordance with the calling conventions for the `arm64` architecture. However, the original method declaration contains fixed parameters, not variable parameters. As a result, the method’s implementation looks for its parameters in registers, which is where the compiler places fixed parameters for `arm64`. This mismatch causes the method call to generate undefined results.\n\nTo fix dynamic-dispatching issues in your code, define a type-safe function pointer instead of calling [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] directly. You can use type-safe function pointers in both your `arm64` and `x86_64` code. A type-safe function pointer specifies the exact number of parameters, and incorporates the type information for each parameter into the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] call, allowing the compiler to generate the calling conventions the method expects. For example, a type-safe function pointer for the `document:didSave:contextInfo:` method looks like the following:\n\n```occ\n\/\/ Declare a type-safe function pointer.\nvoid (* didSaveDispatcher)(id,SEL,NSDocument *,BOOL,void *) = \n       (void(*)(id,SEL,NSDocument *,BOOL,void *))objc_msgSend;\n```\n\nTo initiate the dynamic dispatch operation, pass the target object, selector, and method parameters to your function pointer, as shown in the following code:\n\n```occ\n\/\/ Call the function, dispatching it through objc_msgSend.\ndidSaveDispatcher(myDelegate, mySelector, myDocument, NO, myPtr);\n```\n\nTo locate places where you’re not calling [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend] in a type-safe way, enable the Enable strict Checking of objc_msgSend Calls build setting. When the value of that setting is `YES`, the compiler flags your code where you’re not using a type-safe function pointer with [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/objc_msgSend].\n\n### Address Numerical Differences in Specific Frameworks\n\nSome frameworks include minor changes that might impact code when porting to Apple silicon. For example:\n\n- The [doc:\/\/com.apple.documentation\/documentation\/UIKit\/NSTextAlignment] enumeration uses different numerical values for some constants on `arm64` and `x86_64` architectures. When referring to constants using numerical values, validate that you use the correct values on each architecture.\n- The [doc:\/\/com.apple.documentation\/documentation\/AppKit\/NSImage\/ResizingMode-swift.enum] and [doc:\/\/com.apple.documentation\/documentation\/UIKit\/UIImage\/ResizingMode-swift.enum] enumerations uses different numerical values for some constants on `arm64` and `x86_64` architectures. When referring to constants using numerical values, validate that you use the correct values on each architecture.\n- Encoder IDs in the Video Toolbox framework may differ on `arm64` and `x86_64` architectures and on different versions of macOS. For example, the value in [doc:\/\/com.apple.documentation\/documentation\/VideoToolbox\/kVTVideoEncoderSpecification_EncoderID] may differ between architectures.\n\nFor additional information about framework differences, see the specific framework reference.\n\n### Replace Raw Assembly Code with Builtin Intrinsics\n\nIf your app uses assembly code for specific tasks, or uses processor-specific `__builtin` functions, switch to the compiler’s builtin intrinsic functions instead. The compiler’s builtin intrinsics give you the same benefits of assembly code, but in a cross-platform package. During compilation, the compiler substitutes the builtin intrinsic function call for the appropriate set of assembly instructions for the current platform.\n\nTo illustrate the benefits of builtin intrinsics, consider the implementation of a function that counts the number of leading zeros in a value. The following example shows you how to use the builtin intrinsic for the `CLZ` instruction to count the number of leading zeros in an integer.\n\n```occ\nint GOOD_count_leading_zeroes(int x){\n    int count;\n    if(x == 0){\n        return (sizeof(x) * CHAR_BIT);\n    }\n#if __has_builtin(__builtin_clz)\n    count = __builtin_clz(x); \/\/ undefined when operating on 0\n#else\n    int index = 1;\n    for(; x != 1; ++index){\n        x = (unsigned)x >> 1;\n    }\n    count = ((sizeof(x) * CHAR_BIT) - index);\n#endif\n```\n\nImplementing the same behavior without the builtin intrinsic requires significantly more code, as shown in the following example. The required code is also more complicated because it provides custom implementations for each processor architecture.\n\n```occ\nint BAD_count_leading_zeroes(int x){\n    int count;\n    if(x == 0){\n        return (sizeof(x) * CHAR_BIT);\n    }\n#if defined(__x86_64__)\n    __asm__ (\n        \"bsrl %1, %0\\n\\t\" \/\/ undefined when operating on 0\n        \"xorl $0x1f, %1\"\n        : \"=r\" (count)\n        : \"r\" (x)\n    );\n#elif defined(__aarch64__)\n    __asm__ (\n        \"clz %w1, %w0\"\n        : \"=r\" (count)\n        : \"r\" (x)\n    );\n#else\n    int index = 1;\n    for(; x != 1; ++index){\n        x = (unsigned)x >> 1;\n    }\n    count = ((sizeof(x) * CHAR_BIT) - index);\n#endif\n    return count;\n}\n```\n\nFor a list of builtin intrinsic functions provided by the clang compiler, see the clang documentation at [https:\/\/llvm.org].\n\n### Update Processor-Specific Vector Instructions\n\nIf your code includes instructions for the SSE, AVX, AVX2, or AVX512 units of Intel processors, update that code to support Apple silicon. The best alternative to processor-specific vector code is to use the Accelerate framework, which provides a vast library of vector operations optimized for all Mac computers. Accelerate leverages all available hardware of the current system to perform:\n\n- Vector and matrix computations\n- Image manipulation\n- Digital signal processing\n- Linear algebra computations\n- Compression\n- Neural network operations\n\nFor more information about the Accelerate framework, see [doc:\/\/com.apple.documentation\/documentation\/Accelerate].\n\n### Apply Timebase Information to Mach Absolute Time Values\n\nAlways apply timebase information to values you receive from [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] and never assume that the function returns the number of nanoseconds since boot. The value returned by the [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] function is different for native and translated processes, and doesn’t necessarily correspond to the number of nanoseconds since boot. Applying timebase information ensures that you can distribute time values between processes and between different computers.\n\nThe following code shows how to apply the timebase information to the value returned by the [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] function:\n\n```occ\nuint64_t MachTimeToNanoseconds(uint64_t machTime) {\n    uint64_t nanoseconds = 0;\n    static mach_timebase_info_data_t sTimebase;\n    if (sTimebase.denom == 0)\n        (void)mach_timebase_info(&sTimebase);\n\n    nanoseconds = ((machTime * sTimebase.numer) \/ sTimebase.denom);\n\n    return nanoseconds;\n}\n```\n\nTo retrieve time values in nanoseconds without converting  [doc:\/\/com.apple.documentation\/documentation\/kernel\/1462446-mach_absolute_time] values, call the `clock_gettime_nsec_np` function instead.\n\n### Audit Code that Contains Float-to-Int Conversions\n\nApple silicon and Intel-based Mac computers handle some float-to-int conversions differently in C-based languages. To illustrate one of the differences, consider the conversion of the floating-point representation of infinity to a `uint32_t` or `int32_t` value:\n\n```occ\nuint32_t a = (uint32_t)INFINITY;\nint32_t b = (int32_t)INFINITY;\n```\n\nThe `arm64` architecture converts this value to the nearest possible integer.\n\n```swift\na = 0xffffffff = 4294967295  \/\/ The largest unsigned integer\nb = 0x7fffffff = 2147483647  \/\/ The largest signed integer\n```\n\nFor the unsigned conversion, the `x86_64` architecture wraps the value to `0`. For the signed conversion, it sets the value to an indefinite integer.\n\n```swift\na = 0x00000000 = 0  \/\/ Wrap around to zero.\nb = 0x80000000 = -21474836548  \/\/ The indefinite integer value.\n```\n\n\n\nIf your code converts floating-point numbers to integers, audit your code to make sure that you handle boundary conditions correctly. One way to detect invalid conversions is to run the UBSan tool with the `float-cast-overflow` option selected. To detect implicit conversions by the compiler, enable the `-Wconversion` compiler flag when building your code.\n\nFor information about how to use the UBSan tool, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/diagnosing-memory-thread-and-crash-issues-early].\n\n### Treat BOOL Variables as Binary Values\n\nAs a rule, the Objective-C [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/BOOL] type has only two appropriate values: `YES` or `NO`. On Apple silicon, the compiler defines the [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/BOOL] type to be a native `bool`, but on Intel-based Mac computers, it is a signed` char`. To avoid issues in universal binaries:\n\n- Never perform mathematical operations on [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/BOOL] variables.\n- Never increment or decrement [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/BOOL] variables.\n- Never assume the numerical value of a [doc:\/\/com.apple.documentation\/documentation\/ObjectiveC\/BOOL] is anything other than `0` or `1`.\n\nTo illustrate the problem, consider the following example:\n\n```occ\nint nBytes = 1024;\nBOOL receivedBytes = nBytes;\n\nif (receivedBytes) {\n   printf(\"Success!\\n\");\n} else {\n   printf(\"Failure...\\n\");\n}\n```\n\nOn the `x86_64` architecture, `receivedBytes` evaluates to `0`, or `false`. On the `arm64` architecture, `receivedBytes` evaluates to `true`. One way to fix the preceding code is to include two negation operators (`!!`) in front of the `nBytes` variable before assigning it to the `receivedBytes` variable, as shown in the following example:\n\n```occ\nint nBytes = 1024;\nBOOL receivedBytes = !!nBytes;\n```\n\n\n\n### Update Just-In-Time Compilers\n\nUpdate the workflow of any just-in-time compilers to support Apple silicon, which prevent all memory pages from being simultaneously writable and executable. On Intel-based Mac computers, this same behavior applies only to apps that adopt the [doc:\/\/com.apple.documentation\/documentation\/Security\/hardened-runtime].\n\nFor more information, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/porting-just-in-time-compilers-to-apple-silicon].\n\n### Update C++ Code\n\nThe C++ ABI for Apple silicon matches the ABI for iOS devices, and not the ABI for Intel-based Mac computers. For information about the ABI, see [https:\/\/developer.apple.com\/library\/archive\/documentation\/Xcode\/Conceptual\/iPhoneOSABIReference\/Introduction\/Introduction.html#\/\/apple_ref\/doc\/uid\/TP40009020-SW1].\n\n## General porting tips\n\n- **Porting your audio code to Apple silicon**: Eliminate issues in your audio-specific code when running on Apple silicon Mac computers.\n- **Porting just-in-time compilers to Apple silicon**: Update your just-in-time (JIT) compiler to work with the Hardened Runtime capability, and with Apple silicon.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Eliminate issues in your audio-specific code when running on Apple silicon Mac computers.",
          "name" : "Porting your audio code to Apple silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-your-audio-code-to-apple-silicon"
        },
        {
          "description" : "Update your just-in-time (JIT) compiler to work with the Hardened Runtime capability, and with Apple silicon.",
          "name" : "Porting just-in-time compilers to Apple silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-just-in-time-compilers-to-apple-silicon"
        }
      ],
      "title" : "General porting tips"
    }
  ],
  "source" : "appleJSON",
  "title" : "Addressing architectural differences in your macOS code",
  "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code"
}