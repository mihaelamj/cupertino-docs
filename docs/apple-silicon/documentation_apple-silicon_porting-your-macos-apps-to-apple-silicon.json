{
  "abstract" : "Create a version of your macOS app that runs on both Apple silicon and Intel-based Mac computers.",
  "codeExamples" : [

  ],
  "contentHash" : "18893535a3e9d6269e8db102e1545d760011c17ba0ce7e8e05335e8029fa50b8",
  "crawledAt" : "2025-12-02T17:28:30Z",
  "id" : "EEBCDA9F-F340-4051-9DC2-9A22BDA9EBAF",
  "kind" : "collection",
  "language" : "swift",
  "overview" : "## Overview\n\nPort your existing macOS app to Apple silicon by creating a universal binary and modifying your code to handle architectural differences. A universal binary looks no different than a regular app, but its executable file contains two versions of your compiled code. One version runs natively on Apple silicon, and the other runs natively on Intel-based Mac computers. At runtime, the system automatically chooses which version to run on the current platform.\n\n\n\nTo build a universal binary, you need Xcode 12 or a later version, which adds `arm64` to the standard list of build architectures for macOS binaries. When you open your project and do a clean build, Xcode creates a universal binary automatically if your project uses the standard architectures. If you use custom makefiles or build scripts, add the `arm64` architecture to your build system.\n\nAfter you create a universal binary, test it on both architectures and determine whether you need to make additional changes. macOS frameworks shield apps from most architectural differences between platforms, but some differences may still require you to change your code. In addition, architectural differences may affect your app’s performance and require further changes.\n\nTo learn how to build a universal binary, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/building-a-universal-macos-binary].\n\n### Create a Porting Plan\n\nEarly in the porting process, identify the workflow you’ll use to build and test your code. Xcode runs on all Mac computers, so build your code on either an Apple silicon or Intel-based Mac computer and do your initial testing there. However, always test, tune, and validate your code on both computer types to uncover issues specific to that architecture.\n\n\n\nIn addition to a workflow plan, identify potential areas to investigate during the porting process. The porting effort for `arm64` depends on how much you rely on hardware-specific features. If you rely mostly on Apple frameworks and technologies, your porting effort may be small. If you tuned your code specifically for the `x86_64` architecture and hardware capabilities, porting to `arm64` may require additional effort.\n\nTo start your investigation, make a note of any code that does the following:\n\nThe list above is not exhaustive, but it offers a starting point for your investigation. Hardware and architectural differences may introduce bugs or performance issues to your code on Apple silicon. Identifying potential problem areas early will save you time later.\n\nAlways have a well-defined test plan, ideally with a set of automated test suites you can run at build time. In addition to testing your code’s correctness, gather metrics on your app’s performance. Examine your app’s memory usage, and measure how long it takes to execute specific tasks on both Apple silicon and Intel-based Mac computers. Use that information to identify additional areas to investigate.\n\n### Obtain Universal Versions of Linked Libraries\n\nIf your project depends on any third-party libraries, contact the original vendors and ask them to provide you with universal versions of those libraries. All code running in the same process must support the same architecture. You cannot produce a universal version of your binary without universal versions of all linked libraries. If one or more libraries is not universal, the linker reports errors.\n\n\n\nTo learn how to create your own universal binaries, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/building-a-universal-macos-binary].\n\n### Update Plug-Ins to Universal Binaries\n\nA universal plug-in runs natively on any Mac computer. If your app supports a plug-in model, create universal versions of the plug-ins that you manage. If your company allows external developers to contribute plug-ins, encourage those developers to create universal versions of their plug-ins.\n\nUniversal plug-ins are essential if your app loads those plug-ins directly into its process space. Code running in the same process must support the same architecture. If your app attempts to load a plug-in with an incompatible architecture, the system reports an error at load time.\n\n\n\nPlug-ins that run out-of-process using an XPC service may run using a different architecture than the app itself. To give your developers time to update their plug-ins, provide two non-universal XPC services—one to run `arm64` plug-ins and one to run `x86_64` plug-ins. A single XPC service can manage either native or translated plug-ins, but not both at the same time. When creating the services, give each one a unique bundle identifier so they may run simultaneously.\n\nFor information about how to communicate with out-of-process plug-ins using XPC, see [doc:\/\/com.apple.documentation\/documentation\/Foundation\/xpc].\n\n### Address Architectural Differences\n\nApart from large-scale changes to the processor and graphics hardware, subtle architectural differences exist between Apple silicon and Intel-based Mac computers. During the porting process, audit your code to identify fixes for any potential architectural issues. For example, look for places where your code relies on specific hardware features or configurations.\n\nThe following list identifies several known architectural differences between Apple silicon and Intel-based Mac computers. Update code that relies on any of the following:\n\nFor additional information about architectural differences, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code].\n\n### Update GPU-Specific Code\n\nMetal on Apple silicon supports the features of both Intel-based Mac computers and iOS devices. If your app adopts Metal features that are found only on Intel-based Mac computers, consider also adopting the iOS-specific features in your `arm64` code. Adopting these features can lead to performance improvements for many apps.\n\nIf your app uses Metal, OpenGL, or OpenCL, be aware of the following differences:\n\nFor information about how to update your graphics code, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/porting-your-metal-code-to-apple-silicon].\n\n### Update Drivers, System Extensions, and Kernel Extensions\n\nWhen porting code to macOS 11, be aware of the following requirements for code that interacts with the kernel:\n\nFor more information about kernel extension and driver changes, see [doc:\/\/com.apple.documentation\/documentation\/SystemExtensions\/implementing-drivers-system-extensions-and-kexts].\n\n### Migrate Away from Specific Technologies\n\nmacOS includes a few technologies that are currently deprecated or discouraged for active development. If your app uses one of the following technologies, migrate to an appropriate replacement as soon as possible:\n\nApple silicon still provides support for the preceding technologies, and you may continue to use them in macOS 11. However, this support may be removed in a future version of macOS, so migration to newer technologies is recommended.\n\n### Debug and Test Your Code\n\nApple silicon supports all debugging and testing tools found on Intel-based Mac computers. Use the Xcode IDE to set and monitor breakpoints and monitor other aspects of your app’s behavior. Use `lldb` from the command line to perform similar tasks outside of the Xcode interface.\n\nFor more information about how to debug and test your code, see [doc:\/\/com.apple.documentation\/documentation\/Xcode].\n\n### Tune Your App’s Performance\n\nApple silicon runs all performance tools found on Intel-based Mac computers. Use Instruments and other performance tools to gather different types of metrics for your app, including information about its memory usage, speed, energy usage, and more. You can also use command-line tools such as `leaks`, `heap`, `top`, `fs_usage`, `sc_usage`, `vm_stat`, `otool`, `sample`, `malloc_history`, and `vmmap` to identify potential performance issues.\n\nArchitectural differences between `arm64` and `x86_64` mean that techniques that work well on one system might not work well on the other. For example:\n\nDuring the porting process, measure your app’s performance on both Apple silicon and Intel-based Mac computers and investigate any discrepancies. Tasks that take longer to run on one platform may require additional tuning.\n\nFor specific tips on tuning universal binaries, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/tuning-your-code-s-performance-for-apple-silicon].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-your-macos-apps-to-apple-silicon\ncrawled: 2025-12-02T17:28:30Z\n---\n\n# Porting your macOS apps to Apple silicon\n\nCreate a version of your macOS app that runs on both Apple silicon and Intel-based Mac computers.\n\n## Overview\n\nPort your existing macOS app to Apple silicon by creating a universal binary and modifying your code to handle architectural differences. A universal binary looks no different than a regular app, but its executable file contains two versions of your compiled code. One version runs natively on Apple silicon, and the other runs natively on Intel-based Mac computers. At runtime, the system automatically chooses which version to run on the current platform.\n\n\n\nTo build a universal binary, you need Xcode 12 or a later version, which adds `arm64` to the standard list of build architectures for macOS binaries. When you open your project and do a clean build, Xcode creates a universal binary automatically if your project uses the standard architectures. If you use custom makefiles or build scripts, add the `arm64` architecture to your build system.\n\nAfter you create a universal binary, test it on both architectures and determine whether you need to make additional changes. macOS frameworks shield apps from most architectural differences between platforms, but some differences may still require you to change your code. In addition, architectural differences may affect your app’s performance and require further changes.\n\n\n\nTo learn how to build a universal binary, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/building-a-universal-macos-binary].\n\n### Create a Porting Plan\n\nEarly in the porting process, identify the workflow you’ll use to build and test your code. Xcode runs on all Mac computers, so build your code on either an Apple silicon or Intel-based Mac computer and do your initial testing there. However, always test, tune, and validate your code on both computer types to uncover issues specific to that architecture.\n\n\n\nIn addition to a workflow plan, identify potential areas to investigate during the porting process. The porting effort for `arm64` depends on how much you rely on hardware-specific features. If you rely mostly on Apple frameworks and technologies, your porting effort may be small. If you tuned your code specifically for the `x86_64` architecture and hardware capabilities, porting to `arm64` may require additional effort.\n\nTo start your investigation, make a note of any code that does the following:\n\n- Interacts with third-party libraries you don’t own.\n- Interacts with the kernel or hardware.\n- Relies on specific GPU behaviors.\n- Contains assembly instructions.\n- Manages threads or optimizes your app’s multithreaded behavior.\n- Contains hardware-specific assumptions or performance optimizations.\n\nThe list above is not exhaustive, but it offers a starting point for your investigation. Hardware and architectural differences may introduce bugs or performance issues to your code on Apple silicon. Identifying potential problem areas early will save you time later.\n\nAlways have a well-defined test plan, ideally with a set of automated test suites you can run at build time. In addition to testing your code’s correctness, gather metrics on your app’s performance. Examine your app’s memory usage, and measure how long it takes to execute specific tasks on both Apple silicon and Intel-based Mac computers. Use that information to identify additional areas to investigate.\n\n### Obtain Universal Versions of Linked Libraries\n\nIf your project depends on any third-party libraries, contact the original vendors and ask them to provide you with universal versions of those libraries. All code running in the same process must support the same architecture. You cannot produce a universal version of your binary without universal versions of all linked libraries. If one or more libraries is not universal, the linker reports errors.\n\n\n\nTo learn how to create your own universal binaries, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/building-a-universal-macos-binary].\n\n### Update Plug-Ins to Universal Binaries\n\nA universal plug-in runs natively on any Mac computer. If your app supports a plug-in model, create universal versions of the plug-ins that you manage. If your company allows external developers to contribute plug-ins, encourage those developers to create universal versions of their plug-ins.\n\nUniversal plug-ins are essential if your app loads those plug-ins directly into its process space. Code running in the same process must support the same architecture. If your app attempts to load a plug-in with an incompatible architecture, the system reports an error at load time.\n\n\n\nPlug-ins that run out-of-process using an XPC service may run using a different architecture than the app itself. To give your developers time to update their plug-ins, provide two non-universal XPC services—one to run `arm64` plug-ins and one to run `x86_64` plug-ins. A single XPC service can manage either native or translated plug-ins, but not both at the same time. When creating the services, give each one a unique bundle identifier so they may run simultaneously.\n\nFor information about how to communicate with out-of-process plug-ins using XPC, see [doc:\/\/com.apple.documentation\/documentation\/Foundation\/xpc].\n\n### Address Architectural Differences\n\nApart from large-scale changes to the processor and graphics hardware, subtle architectural differences exist between Apple silicon and Intel-based Mac computers. During the porting process, audit your code to identify fixes for any potential architectural issues. For example, look for places where your code relies on specific hardware features or configurations.\n\nThe following list identifies several known architectural differences between Apple silicon and Intel-based Mac computers. Update code that relies on any of the following:\n\n- Virtual memory-page sizes\n- Cache line sizes\n- Variadic functions\n- Memory that is simultaneously writable and executable\n- Just-in-time compilers\n- Realtime threads\n- Explicit thread priorities\n- Hardware-specific details\n- Assembly-language instructions or builtin intrinsics\n- Vector unit instructions\n- C++ ABI details\n\n\n\nFor additional information about architectural differences, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code].\n\n### Update GPU-Specific Code\n\nMetal on Apple silicon supports the features of both Intel-based Mac computers and iOS devices. If your app adopts Metal features that are found only on Intel-based Mac computers, consider also adopting the iOS-specific features in your `arm64` code. Adopting these features can lead to performance improvements for many apps.\n\nIf your app uses Metal, OpenGL, or OpenCL, be aware of the following differences:\n\n- The GPU and CPU on Apple silicon share memory.\n- OpenGL is deprecated, but is available on Apple silicon.\n- OpenCL is deprecated, but is available on Apple silicon when targeting the GPU. The OpenCL CPU device is not available to arm64 apps.\n\nFor information about how to update your graphics code, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/porting-your-metal-code-to-apple-silicon].\n\n### Update Drivers, System Extensions, and Kernel Extensions\n\nWhen porting code to macOS 11, be aware of the following requirements for code that interacts with the kernel:\n\n- Implement hardware drivers using DriverKit. macOS 11 requires you to use a DriverKit extension when support for one is available. Most driver types now support DriverKit, and only a few still require the creation of a kernel extension.\n- Kernel extensions must support the native architecture. Kernel extensions run in the kernel, and the kernel always runs as a native process. You cannot run kernel extensions using Rosetta translation.\n- The installation and uninstallation of kernel extensions requires a reboot. When you install a kernel extension, the system doesn’t load your extension until after a reboot.\n\nFor more information about kernel extension and driver changes, see [doc:\/\/com.apple.documentation\/documentation\/SystemExtensions\/implementing-drivers-system-extensions-and-kexts].\n\n### Migrate Away from Specific Technologies\n\nmacOS includes a few technologies that are currently deprecated or discouraged for active development. If your app uses one of the following technologies, migrate to an appropriate replacement as soon as possible:\n\n- OpenGL—Use [doc:\/\/com.apple.documentation\/documentation\/Metal] instead.\n- OpenCL—Use [doc:\/\/com.apple.documentation\/documentation\/Metal] instead.\n- AddressBook—Use the [doc:\/\/com.apple.documentation\/documentation\/Contacts] framework instead.\n- Carbon APIs—Migrate to [doc:\/\/com.apple.documentation\/documentation\/AppKit], [doc:\/\/com.apple.documentation\/documentation\/Foundation], and other modern APIs.\n- IOKit kernel extensions—Migrate to DriverKit where appropriate; see [doc:\/\/com.apple.documentation\/documentation\/DriverKit] framework.\n\nApple silicon still provides support for the preceding technologies, and you may continue to use them in macOS 11. However, this support may be removed in a future version of macOS, so migration to newer technologies is recommended.\n\n### Debug and Test Your Code\n\nApple silicon supports all debugging and testing tools found on Intel-based Mac computers. Use the Xcode IDE to set and monitor breakpoints and monitor other aspects of your app’s behavior. Use `lldb` from the command line to perform similar tasks outside of the Xcode interface.\n\nFor more information about how to debug and test your code, see [doc:\/\/com.apple.documentation\/documentation\/Xcode].\n\n### Tune Your App’s Performance\n\nApple silicon runs all performance tools found on Intel-based Mac computers. Use Instruments and other performance tools to gather different types of metrics for your app, including information about its memory usage, speed, energy usage, and more. You can also use command-line tools such as `leaks`, `heap`, `top`, `fs_usage`, `sc_usage`, `vm_stat`, `otool`, `sample`, `malloc_history`, and `vmmap` to identify potential performance issues.\n\nArchitectural differences between `arm64` and `x86_64` mean that techniques that work well on one system might not work well on the other. For example:\n\n- Don’t assume a discrete GPU means better performance. The integrated GPU in Apple processors is optimized for high performance graphics tasks. See [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/porting-your-metal-code-to-apple-silicon].\n- Don’t assume that all processor cores are equal. The processors on Apple silicon contain a mixture of performance cores (P-cores) and efficiency cores (E-cores), which execute tasks with different performance characteristics. Use Quality-of-Service (QoS) classes to help the system schedule your tasks on the right type of core.\n\nDuring the porting process, measure your app’s performance on both Apple silicon and Intel-based Mac computers and investigate any discrepancies. Tasks that take longer to run on one platform may require additional tuning.\n\nFor specific tips on tuning universal binaries, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/tuning-your-code-s-performance-for-apple-silicon].\n\n## Additional Porting Tips\n\n- **Addressing architectural differences in your macOS code**: Fix problems that stem from architectural differences between Apple silicon and Intel-based Mac computers.\n- **Porting your audio code to Apple silicon**: Eliminate issues in your audio-specific code when running on Apple silicon Mac computers.\n- **Porting just-in-time compilers to Apple silicon**: Update your just-in-time (JIT) compiler to work with the Hardened Runtime capability, and with Apple silicon.\n\n## Essentials\n\n- **Building a universal macOS binary**: Create macOS apps and other executables that run natively on both Apple silicon and Intel-based Mac computers.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Fix problems that stem from architectural differences between Apple silicon and Intel-based Mac computers.",
          "name" : "Addressing architectural differences in your macOS code",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code"
        },
        {
          "description" : "Eliminate issues in your audio-specific code when running on Apple silicon Mac computers.",
          "name" : "Porting your audio code to Apple silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-your-audio-code-to-apple-silicon"
        },
        {
          "description" : "Update your just-in-time (JIT) compiler to work with the Hardened Runtime capability, and with Apple silicon.",
          "name" : "Porting just-in-time compilers to Apple silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-just-in-time-compilers-to-apple-silicon"
        }
      ],
      "title" : "Additional Porting Tips"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create macOS apps and other executables that run natively on both Apple silicon and Intel-based Mac computers.",
          "name" : "Building a universal macOS binary",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/building-a-universal-macos-binary"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Porting your macOS apps to Apple silicon",
  "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-your-macos-apps-to-apple-silicon"
}