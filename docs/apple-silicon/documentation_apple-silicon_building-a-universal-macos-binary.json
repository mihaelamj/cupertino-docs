{
  "abstract" : "Create macOS apps and other executables that run natively on both Apple silicon and Intel-based Mac computers.",
  "codeExamples" : [
    {
      "code" : "x86_app: main.c\n    $(CC) main.c -o x86_app -target x86_64-apple-macos10.12\narm_app: main.c\n    $(CC) main.c -o arm_app -target arm64-apple-macos11\nuniversal_app: x86_app arm_app\n    lipo -create -output universal_app x86_app arm_app",
      "language" : "other"
    },
    {
      "code" : "\/\/ Swift example\n#if arch(arm64)\n   \/\/ Code meant for the arm64 architecture here.\n#elseif arch(x86_64)\n   \/\/ Code meant for the x86_64 architecture here.\n#endif",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Objective-C example\n#include \"TargetConditionals.h\"\n#if TARGET_CPU_ARM64\n  \/\/ Code meant for the arm64 architecture here.\n#elif TARGET_CPU_X86_64\n  \/\/ Code meant for the x86_64 architecture here.\n#endif ",
      "language" : "occ"
    },
    {
      "code" : "\/\/Swift example\n#if os(macOS)\n   \/\/ Put CPU-independent macOS code here.\n   #if arch(arm64)\n      \/\/ Put 64-bit arm64 Mac code here.\n   #elseif arch(x86_64)\n      \/\/ Put 64-bit x86_64 Mac code here.\n   #endif\n#elseif targetEnvironment(macCatalyst)\n   \/\/ Put Mac Catalyst-specific code here.\n#elseif os(iOS)\n   \/\/ Put iOS-specific code here.\n#endif",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Objective-C example\n#include \"TargetConditionals.h\"\n#if TARGET_OS_OSX\n  \/\/ Put CPU-independent macOS code here.\n  #if TARGET_CPU_ARM64\n    \/\/ Put 64-bit Apple silicon macOS code here.\n  #elif TARGET_CPU_X86_64\n    \/\/ Put 64-bit Intel macOS code here.\n  #endif\n#elif TARGET_OS_MACCATALYST\n   \/\/ Put Mac Catalyst-specific code here.\n#elif TARGET_OS_IOS\n  \/\/ Put iOS-specific code here.\n#endif",
      "language" : "occ"
    },
    {
      "code" : "% lipo -archs \/System\/Applications\/Mail.app\/Contents\/MacOS\/Mail\nx86_64 arm64",
      "language" : "other"
    }
  ],
  "contentHash" : "af3acd822aadcbccd5ad0b4679acabf930f8fb731a2b3d00cd2b2c503961ba3f",
  "crawledAt" : "2025-12-01T10:40:30Z",
  "id" : "C7D5F34F-6065-4A1B-BC75-A22628EF2DB9",
  "kind" : "article",
  "overview" : "## Overview\n\nNative apps run more efficiently than translated apps because the compiler is able to optimize your code for the target architecture. An app that supports only the `x86_64` architecture must run under Rosetta translation on Apple silicon. A universal binary runs natively on both Apple silicon and Intel-based Mac computers, because it contains executable code for both architectures.\n\nTurn all of your compiled code into universal binaries, not just apps. The following list includes the most common types of executables to turn into universal binaries. This list is not exhaustive, but you can use it as a starting point to assess your projects.\n\n### Download and Install Xcode on Your Mac Computer\n\nXcode 12.2 and later is a requirement for building universal binaries. Earlier versions of Xcode don’t contain the support needed to build and test universal versions of your macOS code.\n\nDownload the latest public version of Xcode from the App Store. Download prerelease versions of Xcode from [https:\/\/developer.apple.com].\n\n### Update the Architecture List in Your Xcode Projects\n\nXcode 12.2 and later automatically adds the arm64 architecture to the list of standard architectures for all macOS binaries, including apps and libraries. During the debugging and testing process, Xcode builds only for the current system architecture by default. However, it automatically builds a universal binary for the release version of your code.\n\n\n\nIf you customized the Architectures build setting in your Xcode project, remove your customizations and use the Standard Architectures setting instead.\n\nFor additional information about Xcode build settings and how to configure them, see [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev04b3a04ba].\n\n### Update the Architecture List of Custom Makefiles\n\nIf you build your project using custom scripts or makefiles, add the `arm64` architecture to the appropriate environment variables. Xcode uses the `ARCHS` environment variable to define the current build architectures. Other build systems may use different environment variables, but with similar purposes. After adding the variable to the appropriate environment variable, build your code and verify that the compiler creates an `arm64` variant of your code. To create a universal binary for your project, merge the resulting executable files into a single executable binary using the `lipo` tool.\n\nFor makefiles you create outside of Xcode, pass the appropriate architecture values to the compiler using the `-target` option. The following example shows a makefile that compiles a single-source file twice—once for each architecture. It then creates a universal binary by merging the resulting executable files together with the `lipo` tool.\n\n### Wrap Platform-Specific Code with Conditional Compilation Macros\n\nWhen writing code for a specific platform or processor type, isolate that code using the appropriate conditional compilation statements. For C-based code, the system defines a set of macros for you to use in `\/usr\/include\/TargetConditionals.h`. The Swift language also supports conditional compilation using conditional compilation blocks.\n\nTo distinguish code meant for a specific type of processor, add conditional compilation statements that target the appropriate architecture. Universal macOS apps support the `arm64` and `x86_64` architectures, and the following example shows how to write conditional code for those architectures in Swift:\n\nFor Objective-C, use the following code:\n\nIf you share code between an iOS and macOS app, don’t assume that code intended for the `arm64` architecture runs only on an iOS device. That code also runs in your macOS app on an Apple silicon. To isolate code specifically for macOS or iOS, use the conditional compilation statements shown in the following example. You can also combine both platform- and architecture-specific conditional compilation to further refine your code.\n\nIn Objective-C, implement the same code as shown below.\n\nFor the complete list of conditional compilation macros, see the `\/usr\/include\/TargetConditionals.h` header file in the appropriate SDK. For a list of Swift compilation conditions and arguments, see [https:\/\/docs.swift.org\/swift-book\/ReferenceManual\/Statements.html] in [https:\/\/docs.swift.org\/swift-book\/].\n\n### Build Your Target\n\nWhen you build a debuggable version of your code, Xcode builds only for the current architecture by default. Building for one architecture saves time when you are trying to debug your code and fix problems quickly.\n\nYou can create a universal binary with debug symbols on any Mac computer by changing the Build Active Architecture Only build setting of your project. Although you can create this binary on an Intel-based Mac computer, you can’t run or debug the `arm64` slice of it. Only a Mac with Apple silicon is capable of running and debugging both slices of your binary; use Rosetta translation to run and debug the `x86_64` slice.\n\n### Determine Whether Your Binary Is Universal\n\nTo users, a universal binary looks no different than a binary built for a single architecture. When you build a universal binary, Xcode compiles your source files twice—once for each architecture. After linking the binaries for each architecture, Xcode then merges the architecture-specific binaries into a single executable file using the `lipo` tool. If you build the source files yourself, you must call `lipo` as part of your build scripts to merge your architecture-specific binaries into a single universal binary.\n\nTo see the architectures present in a built executable file, run the `lipo` or `file` command-line tools. When running either tool, specify the path to the actual executable file, not to any intermediate directories such as the app bundle. For example, the executable file of a macOS app is in the `Contents\/MacOS\/` directory of its bundle. When running the `lipo` tool, include the `-archs` parameter to see the architectures. The following example shows how to use `lipo` to view the list of architectures for the Mail app in macOS, and the results when Mail is a universal binary.\n\nTo obtain more information about each architecture, pass the `-detailed_info` argument to `lipo`.\n\nFor information about how to determine whether your app is running as a translated binary, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/about-the-rosetta-translation-environment#Determine-Whether-Your-App-Is-Running-as-a-Translated-Binary].\n\n### Specify the Launch Behavior of Your App\n\nFor universal binaries, the system prefers to execute the slice that is native to the current platform. On an Intel-based Mac computer, the system always executes the `x86_64` slice of the binary. On Apple silicon, the system prefers to execute the `arm64` slice when one is present. Users can force the system to run the app under Rosetta translation by enabling the appropriate option from the app’s Get Info window in the Finder.\n\nIf you never want users to run your app under Rosetta translation, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/LSRequiresNativeExecution] key to your app’s `Info.plist` file. When that key is present and set to `YES`, the system prevents your app from running under translation. In addition, the system removes the Rosetta translation option from your app’s Get Info window. Don’t include this key until you verify that your app runs correctly on both Apple silicon and Intel-based Mac computers.\n\nIf you want to prioritize one architecture, without preventing users from running your app under translation, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/LSArchitecturePriority] key to your app’s `Info.plist` file. The value of this key is an ordered array of strings, which define the priority order for selecting an architecture.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/building-a-universal-macos-binary\ncrawled: 2025-12-01T10:40:30Z\n---\n\n# Building a universal macOS binary\n\n**Article**\n\nCreate macOS apps and other executables that run natively on both Apple silicon and Intel-based Mac computers.\n\n## Overview\n\nNative apps run more efficiently than translated apps because the compiler is able to optimize your code for the target architecture. An app that supports only the `x86_64` architecture must run under Rosetta translation on Apple silicon. A universal binary runs natively on both Apple silicon and Intel-based Mac computers, because it contains executable code for both architectures.\n\nTurn all of your compiled code into universal binaries, not just apps. The following list includes the most common types of executables to turn into universal binaries. This list is not exhaustive, but you can use it as a starting point to assess your projects.\n\n- Apps\n- App extensions\n- Plug-ins\n- Custom frameworks\n- Static libraries\n- Dynamic libraries\n- Build tools\n- Command-line tools\n- Daemons and launch agents\n- DriverKit extensions\n- Kernel extensions\n\n\n\n### Download and Install Xcode on Your Mac Computer\n\nXcode 12.2 and later is a requirement for building universal binaries. Earlier versions of Xcode don’t contain the support needed to build and test universal versions of your macOS code.\n\nDownload the latest public version of Xcode from the App Store. Download prerelease versions of Xcode from [https:\/\/developer.apple.com].\n\n### Update the Architecture List in Your Xcode Projects\n\nXcode 12.2 and later automatically adds the arm64 architecture to the list of standard architectures for all macOS binaries, including apps and libraries. During the debugging and testing process, Xcode builds only for the current system architecture by default. However, it automatically builds a universal binary for the release version of your code.\n\n\n\nIf you customized the Architectures build setting in your Xcode project, remove your customizations and use the Standard Architectures setting instead.\n\nFor additional information about Xcode build settings and how to configure them, see [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev04b3a04ba].\n\n### Update the Architecture List of Custom Makefiles\n\nIf you build your project using custom scripts or makefiles, add the `arm64` architecture to the appropriate environment variables. Xcode uses the `ARCHS` environment variable to define the current build architectures. Other build systems may use different environment variables, but with similar purposes. After adding the variable to the appropriate environment variable, build your code and verify that the compiler creates an `arm64` variant of your code. To create a universal binary for your project, merge the resulting executable files into a single executable binary using the `lipo` tool.\n\nFor makefiles you create outside of Xcode, pass the appropriate architecture values to the compiler using the `-target` option. The following example shows a makefile that compiles a single-source file twice—once for each architecture. It then creates a universal binary by merging the resulting executable files together with the `lipo` tool.\n\n```other\nx86_app: main.c\n    $(CC) main.c -o x86_app -target x86_64-apple-macos10.12\narm_app: main.c\n    $(CC) main.c -o arm_app -target arm64-apple-macos11\nuniversal_app: x86_app arm_app\n    lipo -create -output universal_app x86_app arm_app\n```\n\n### Wrap Platform-Specific Code with Conditional Compilation Macros\n\nWhen writing code for a specific platform or processor type, isolate that code using the appropriate conditional compilation statements. For C-based code, the system defines a set of macros for you to use in `\/usr\/include\/TargetConditionals.h`. The Swift language also supports conditional compilation using conditional compilation blocks.\n\n\n\nTo distinguish code meant for a specific type of processor, add conditional compilation statements that target the appropriate architecture. Universal macOS apps support the `arm64` and `x86_64` architectures, and the following example shows how to write conditional code for those architectures in Swift:\n\n```swift\n\/\/ Swift example\n#if arch(arm64)\n   \/\/ Code meant for the arm64 architecture here.\n#elseif arch(x86_64)\n   \/\/ Code meant for the x86_64 architecture here.\n#endif\n```\n\nFor Objective-C, use the following code:\n\n```occ\n\/\/ Objective-C example\n#include \"TargetConditionals.h\"\n#if TARGET_CPU_ARM64\n  \/\/ Code meant for the arm64 architecture here.\n#elif TARGET_CPU_X86_64\n  \/\/ Code meant for the x86_64 architecture here.\n#endif \n```\n\nIf you share code between an iOS and macOS app, don’t assume that code intended for the `arm64` architecture runs only on an iOS device. That code also runs in your macOS app on an Apple silicon. To isolate code specifically for macOS or iOS, use the conditional compilation statements shown in the following example. You can also combine both platform- and architecture-specific conditional compilation to further refine your code.\n\n```swift\n\/\/Swift example\n#if os(macOS)\n   \/\/ Put CPU-independent macOS code here.\n   #if arch(arm64)\n      \/\/ Put 64-bit arm64 Mac code here.\n   #elseif arch(x86_64)\n      \/\/ Put 64-bit x86_64 Mac code here.\n   #endif\n#elseif targetEnvironment(macCatalyst)\n   \/\/ Put Mac Catalyst-specific code here.\n#elseif os(iOS)\n   \/\/ Put iOS-specific code here.\n#endif\n```\n\nIn Objective-C, implement the same code as shown below.\n\n```occ\n\/\/ Objective-C example\n#include \"TargetConditionals.h\"\n#if TARGET_OS_OSX\n  \/\/ Put CPU-independent macOS code here.\n  #if TARGET_CPU_ARM64\n    \/\/ Put 64-bit Apple silicon macOS code here.\n  #elif TARGET_CPU_X86_64\n    \/\/ Put 64-bit Intel macOS code here.\n  #endif\n#elif TARGET_OS_MACCATALYST\n   \/\/ Put Mac Catalyst-specific code here.\n#elif TARGET_OS_IOS\n  \/\/ Put iOS-specific code here.\n#endif\n```\n\nFor the complete list of conditional compilation macros, see the `\/usr\/include\/TargetConditionals.h` header file in the appropriate SDK. For a list of Swift compilation conditions and arguments, see [https:\/\/docs.swift.org\/swift-book\/ReferenceManual\/Statements.html] in [https:\/\/docs.swift.org\/swift-book\/].\n\n### Build Your Target\n\nWhen you build a debuggable version of your code, Xcode builds only for the current architecture by default. Building for one architecture saves time when you are trying to debug your code and fix problems quickly.\n\nYou can create a universal binary with debug symbols on any Mac computer by changing the Build Active Architecture Only build setting of your project. Although you can create this binary on an Intel-based Mac computer, you can’t run or debug the `arm64` slice of it. Only a Mac with Apple silicon is capable of running and debugging both slices of your binary; use Rosetta translation to run and debug the `x86_64` slice.\n\n### Determine Whether Your Binary Is Universal\n\nTo users, a universal binary looks no different than a binary built for a single architecture. When you build a universal binary, Xcode compiles your source files twice—once for each architecture. After linking the binaries for each architecture, Xcode then merges the architecture-specific binaries into a single executable file using the `lipo` tool. If you build the source files yourself, you must call `lipo` as part of your build scripts to merge your architecture-specific binaries into a single universal binary.\n\nTo see the architectures present in a built executable file, run the `lipo` or `file` command-line tools. When running either tool, specify the path to the actual executable file, not to any intermediate directories such as the app bundle. For example, the executable file of a macOS app is in the `Contents\/MacOS\/` directory of its bundle. When running the `lipo` tool, include the `-archs` parameter to see the architectures. The following example shows how to use `lipo` to view the list of architectures for the Mail app in macOS, and the results when Mail is a universal binary.\n\n```other\n% lipo -archs \/System\/Applications\/Mail.app\/Contents\/MacOS\/Mail\nx86_64 arm64\n```\n\nTo obtain more information about each architecture, pass the `-detailed_info` argument to `lipo`.\n\nFor information about how to determine whether your app is running as a translated binary, see [doc:\/\/com.apple.Apple-Silicon\/documentation\/Apple-Silicon\/about-the-rosetta-translation-environment#Determine-Whether-Your-App-Is-Running-as-a-Translated-Binary].\n\n### Specify the Launch Behavior of Your App\n\nFor universal binaries, the system prefers to execute the slice that is native to the current platform. On an Intel-based Mac computer, the system always executes the `x86_64` slice of the binary. On Apple silicon, the system prefers to execute the `arm64` slice when one is present. Users can force the system to run the app under Rosetta translation by enabling the appropriate option from the app’s Get Info window in the Finder.\n\nIf you never want users to run your app under Rosetta translation, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/LSRequiresNativeExecution] key to your app’s `Info.plist` file. When that key is present and set to `YES`, the system prevents your app from running under translation. In addition, the system removes the Rosetta translation option from your app’s Get Info window. Don’t include this key until you verify that your app runs correctly on both Apple silicon and Intel-based Mac computers.\n\nIf you want to prioritize one architecture, without preventing users from running your app under translation, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Information-Property-List\/LSArchitecturePriority] key to your app’s `Info.plist` file. The value of this key is an ordered array of strings, which define the priority order for selecting an architecture.\n\n\n\n## Essentials\n\n- **Porting your macOS apps to Apple silicon**: Create a version of your macOS app that runs on both Apple silicon and Intel-based Mac computers.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create a version of your macOS app that runs on both Apple silicon and Intel-based Mac computers.",
          "name" : "Porting your macOS apps to Apple silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-your-macos-apps-to-apple-silicon"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Building a universal macOS binary",
  "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/building-a-universal-macos-binary"
}