{
  "abstract" : "Update your just-in-time (JIT) compiler to work with the Hardened Runtime capability, and with Apple silicon.",
  "codeExamples" : [
    {
      "code" : "\/\/ Initialize this pointer using mmap() with the MAP_JIT flag.\nstatic void *jit_region;\n\nstruct jit_code {\n  void *instructions;\n  ptrdiff_t entry_point;\n  size_t instructions_length;\n}\n\nenum jit_code_safety {\n  JIT_CODE_VALID,\n  JIT_CODE_INVALID,\n};\n\n\/\/ Ensure that the JIT code is safe to execute.\nenum jit_code_safety validate_jit_code(struct jit_code *code);\n\nint jit_writing_callback(void *context) {\n  struct jit_code *code = (struct jit_code *)context;\n  if (validate_jit_code(code) == JIT_CODE_VALID) {\n    memcpy(jit_region, code->instructions, code->instructions_length);\n\treturn 0;\n  } else {\n    return -1;\n  }\n}",
      "language" : "c"
    },
    {
      "code" : "PTHREAD_JIT_WRITE_ALLOW_CALLBACKS_NP(jit_writing_callback)",
      "language" : "c"
    },
    {
      "code" : "struct jit_code code = {0};\nint status = jit_compile(\"console.log(\\\"Hello, world!\\\");\", &code);\nif (status == JIT_COMPILATION_SUCCESS) {\n  pthread_jit_write_with_callback_np(jit_writing_callback, &code);\n} else {\n  \/\/ Handle a compilation error.\n}",
      "language" : "c"
    },
    {
      "code" : "sys_icache_invalidate(jit_region, code.instructions_length);\nvoid (*run_jit)(void) = jit_region + code.entry_point;\nrun_jit();",
      "language" : "c"
    }
  ],
  "contentHash" : "31768c3021741719315997e4883894cf612d3cf09835258c2671e3bdda09668d",
  "crawledAt" : "2025-12-01T10:40:30Z",
  "id" : "4D26BF57-EC81-49A1-9ED4-FDB499DE6FE6",
  "kind" : "article",
  "overview" : "## Overview\n\nA just-in-time (JIT) compiler translates byte-code or intermediate script code into machine-language instructions, and makes those instructions available for execution. An app initiates JIT compilation as needed to support relevant tasks, and the compilation process takes place within the app’s process space. For example, a web browser uses JIT compilation to transform a web page’s script code into runnable code when the user interacts with the appropriate page elements.\n\n\n\nBecause JIT compilation uses some techniques that the Hardened Runtime capability specifically disallows, you need to update your app if it supports that capability. Even if your app doesn’t adopt the Hardened Runtime, you need to still make changes to support Apple silicon. For more information about configuring the Hardened Runtime capability, see [doc:\/\/com.apple.documentation\/documentation\/Security\/hardened-runtime].\n\n### Enable the JIT entitlements for the Hardened Runtime\n\nThe Hardened Runtime capability prohibits the execution of code in a memory page, unless that code is accompanied by a valid code signature. Because a JIT compiler doesn’t sign the code it generates, it technically violates the rules of the Hardened Runtime. To fix this issue, you need to adjust your Hardened Runtime settings to allow JIT-related activities.\n\nTo allow JIT compilation in your app, navigate to the Hardened Runtime capability in Xcode and enable the Allow Execution of JIT-compiled Code option for your app. When you enable this option, Xcode adds the `com.apple.security.cs.allow-jit` entitlement to your app. When this entitlement is present, the system allows your app to call `mmap` with the `MAP_JIT` flag. If you don’t have this entitlement, calls using that flag return an error.\n\nWhen your app has the Hardened Runtime capability and the `com.apple.security.cs.allow-jit` entitlement, it can only create one memory region with the `MAP_JIT` flag set. The `com.apple.security.cs.allow-jit` entitlement is required only when an app adopts the Hardened Runtime capability. If you don’t adopt this capability, you don’t need the entitlement to use the `MAP_JIT` flag. For more information about the entitlement, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.security.cs.allow-jit].\n\nAdditionally, add the `com.apple.security.cs.jit-write-allowlist` entitlement with the value `true`, to enable JIT callback allow lists. Adding this entitlement allows your to call `pthread_jit_write_with_callback_np()`, which you use to write to your app’s JIT region.\n\nWhen memory protection is enabled, a thread cannot write to a memory region and execute instructions in that region at the same time. Apple silicon enables memory protection for all apps, regardless of whether they adopt the Hardened Runtime. Intel-based Mac computers enable memory protection only for apps that adopt the Hardened Runtime.\n\n### Create a callback to write JIT instructions\n\nYour app writes to the `MAP_JIT` memory region in a callback function, that you pass to the `pthread_jit_write_with_callback_np()` function. The callback needs to take a context pointer as an argument, and return its result as an integer. The callback needs to assume that the memory pointed to by the context pointer can be controlled by an attacker, and validate that the instructions to be written are permitted. For example:\n\n### Add your JIT callback to the allowlist\n\nEach executable, for example, your app binary, can define at most one allowlist of functions that the executable uses as callbacks to `pthread_jit_write_with_callback_np()`.\n\nDefine your app’s allowlist using the `PTHREAD_JIT_WRITE_ALLOW_CALLBACKS_NP` macro:\n\nOn macOS, if you need to update the allowlist with callbacks you load at runtime, for example from dynamic libraries you load using `dlopen()`, follow these steps:\n\nIf you add the `com.apple.security.cs.jit-write-allowlist-freeze-late` entitlement, you need to call `pthread_jit_write_freeze_callbacks_np()` before your first call to `pthread_jit_write_with_callback_np()`. If you call `pthread_jit_write_with_callback_np()` before freezing the callbacks allowlist, the system terminates your process with an error.\n\n### Write instructions to your JIT memory region\n\nPass your callback and context pointer to `pthread_jit_write_with_callback_np()` to write code to the `MAP_JIT` memory region. This function:\n\n### Invalidate caches and execute the code\n\nAlways call `sys_icache_invalidate(_:_:)` before you execute the machine instructions on a recently updated memory page. On Apple silicon, the instruction caches aren’t coherent with data caches, and unexpected results might occur if you execute instructions without invalidating the caches. It’s also safe to call the `sys_icache_invalidate(_:_:)` function on Intel-based Mac computers, where the function does nothing.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-just-in-time-compilers-to-apple-silicon\ncrawled: 2025-12-01T10:40:30Z\n---\n\n# Porting just-in-time compilers to Apple silicon\n\n**Article**\n\nUpdate your just-in-time (JIT) compiler to work with the Hardened Runtime capability, and with Apple silicon.\n\n## Overview\n\nA just-in-time (JIT) compiler translates byte-code or intermediate script code into machine-language instructions, and makes those instructions available for execution. An app initiates JIT compilation as needed to support relevant tasks, and the compilation process takes place within the app’s process space. For example, a web browser uses JIT compilation to transform a web page’s script code into runnable code when the user interacts with the appropriate page elements.\n\n\n\nBecause JIT compilation uses some techniques that the Hardened Runtime capability specifically disallows, you need to update your app if it supports that capability. Even if your app doesn’t adopt the Hardened Runtime, you need to still make changes to support Apple silicon. For more information about configuring the Hardened Runtime capability, see [doc:\/\/com.apple.documentation\/documentation\/Security\/hardened-runtime].\n\n### Enable the JIT entitlements for the Hardened Runtime\n\nThe Hardened Runtime capability prohibits the execution of code in a memory page, unless that code is accompanied by a valid code signature. Because a JIT compiler doesn’t sign the code it generates, it technically violates the rules of the Hardened Runtime. To fix this issue, you need to adjust your Hardened Runtime settings to allow JIT-related activities.\n\nTo allow JIT compilation in your app, navigate to the Hardened Runtime capability in Xcode and enable the Allow Execution of JIT-compiled Code option for your app. When you enable this option, Xcode adds the `com.apple.security.cs.allow-jit` entitlement to your app. When this entitlement is present, the system allows your app to call `mmap` with the `MAP_JIT` flag. If you don’t have this entitlement, calls using that flag return an error.\n\nWhen your app has the Hardened Runtime capability and the `com.apple.security.cs.allow-jit` entitlement, it can only create one memory region with the `MAP_JIT` flag set. The `com.apple.security.cs.allow-jit` entitlement is required only when an app adopts the Hardened Runtime capability. If you don’t adopt this capability, you don’t need the entitlement to use the `MAP_JIT` flag. For more information about the entitlement, see [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.security.cs.allow-jit].\n\nAdditionally, add the `com.apple.security.cs.jit-write-allowlist` entitlement with the value `true`, to enable JIT callback allow lists. Adding this entitlement allows your to call `pthread_jit_write_with_callback_np()`, which you use to write to your app’s JIT region.\n\n\n\nWhen memory protection is enabled, a thread cannot write to a memory region and execute instructions in that region at the same time. Apple silicon enables memory protection for all apps, regardless of whether they adopt the Hardened Runtime. Intel-based Mac computers enable memory protection only for apps that adopt the Hardened Runtime.\n\n### Create a callback to write JIT instructions\n\nYour app writes to the `MAP_JIT` memory region in a callback function, that you pass to the `pthread_jit_write_with_callback_np()` function. The callback needs to take a context pointer as an argument, and return its result as an integer. The callback needs to assume that the memory pointed to by the context pointer can be controlled by an attacker, and validate that the instructions to be written are permitted. For example:\n\n```c\n\/\/ Initialize this pointer using mmap() with the MAP_JIT flag.\nstatic void *jit_region;\n\nstruct jit_code {\n  void *instructions;\n  ptrdiff_t entry_point;\n  size_t instructions_length;\n}\n\nenum jit_code_safety {\n  JIT_CODE_VALID,\n  JIT_CODE_INVALID,\n};\n\n\/\/ Ensure that the JIT code is safe to execute.\nenum jit_code_safety validate_jit_code(struct jit_code *code);\n\nint jit_writing_callback(void *context) {\n  struct jit_code *code = (struct jit_code *)context;\n  if (validate_jit_code(code) == JIT_CODE_VALID) {\n    memcpy(jit_region, code->instructions, code->instructions_length);\n\treturn 0;\n  } else {\n    return -1;\n  }\n}\n```\n\n### Add your JIT callback to the allowlist\n\nEach executable, for example, your app binary, can define at most one allowlist of functions that the executable uses as callbacks to `pthread_jit_write_with_callback_np()`.\n\n\n\nDefine your app’s allowlist using the `PTHREAD_JIT_WRITE_ALLOW_CALLBACKS_NP` macro:\n\n```c\nPTHREAD_JIT_WRITE_ALLOW_CALLBACKS_NP(jit_writing_callback)\n```\n\nOn macOS, if you need to update the allowlist with callbacks you load at runtime, for example from dynamic libraries you load using `dlopen()`, follow these steps:\n\n1. Add the `com.apple.security.cs.jit-write-allowlist-freeze-late` entitlement with the value `true`.\n2. Define at most one allowlist in each dynamic library using `PTHREAD_JIT_WRITE_ALLOW_CALLBACKS_NP`.\n3. Load the dynamic libraries in your main executable.\n4. Call `pthread_jit_write_freeze_callbacks_np()`.\n\nIf you add the `com.apple.security.cs.jit-write-allowlist-freeze-late` entitlement, you need to call `pthread_jit_write_freeze_callbacks_np()` before your first call to `pthread_jit_write_with_callback_np()`. If you call `pthread_jit_write_with_callback_np()` before freezing the callbacks allowlist, the system terminates your process with an error.\n\n\n\n### Write instructions to your JIT memory region\n\nPass your callback and context pointer to `pthread_jit_write_with_callback_np()` to write code to the `MAP_JIT` memory region. This function:\n\n1. Checks that your callback function is in the allowlist.\n2. Makes the memory region writable, and not executable, for the current thread only.\n3. Runs your callback function, passing the context pointer as the argument.\n4. Makes the memory region executable, and not writable, for the current thread.\n5. Returns the value that your callback function returned.\n\n```c\nstruct jit_code code = {0};\nint status = jit_compile(\"console.log(\\\"Hello, world!\\\");\", &code);\nif (status == JIT_COMPILATION_SUCCESS) {\n  pthread_jit_write_with_callback_np(jit_writing_callback, &code);\n} else {\n  \/\/ Handle a compilation error.\n}\n```\n\n### Invalidate caches and execute the code\n\nAlways call `sys_icache_invalidate(_:_:)` before you execute the machine instructions on a recently updated memory page. On Apple silicon, the instruction caches aren’t coherent with data caches, and unexpected results might occur if you execute instructions without invalidating the caches. It’s also safe to call the `sys_icache_invalidate(_:_:)` function on Intel-based Mac computers, where the function does nothing.\n\n```c\nsys_icache_invalidate(jit_region, code.instructions_length);\nvoid (*run_jit)(void) = jit_region + code.entry_point;\nrun_jit();\n```\n\n## General porting tips\n\n- **Addressing architectural differences in your macOS code**: Fix problems that stem from architectural differences between Apple silicon and Intel-based Mac computers.\n- **Porting your audio code to Apple silicon**: Eliminate issues in your audio-specific code when running on Apple silicon Mac computers.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Fix problems that stem from architectural differences between Apple silicon and Intel-based Mac computers.",
          "name" : "Addressing architectural differences in your macOS code",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/addressing-architectural-differences-in-your-macos-code"
        },
        {
          "description" : "Eliminate issues in your audio-specific code when running on Apple silicon Mac computers.",
          "name" : "Porting your audio code to Apple silicon",
          "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-your-audio-code-to-apple-silicon"
        }
      ],
      "title" : "General porting tips"
    }
  ],
  "source" : "appleJSON",
  "title" : "Porting just-in-time compilers to Apple silicon",
  "url" : "https:\/\/developer.apple.com\/documentation\/Apple-Silicon\/porting-just-in-time-compilers-to-apple-silicon"
}