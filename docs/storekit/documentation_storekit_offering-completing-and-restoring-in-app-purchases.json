{
  "abstract" : "Fetch, display, purchase, validate, and finish transactions in your app.",
  "codeExamples" : [
    {
      "code" : "var isAuthorizedForPayments: Bool {\n    return SKPaymentQueue.canMakePayments()\n}",
      "language" : "swift"
    },
    {
      "code" : "fileprivate func fetchProducts(matchingIdentifiers identifiers: [String]) {\n    \/\/ Create a set for the product identifiers.\n    let productIdentifiers = Set(identifiers)\n    \n    \/\/ Initialize the product request with the above identifiers.\n    productRequest = SKProductsRequest(productIdentifiers: productIdentifiers)\n    productRequest.delegate = self\n    \n    \/\/ Send the request to the App Store.\n    productRequest.start()\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Contains products with identifiers that the App Store recognizes. As such, they are available for purchase.\nif !response.products.isEmpty {\n    availableProducts = response.products\n}\n\n\/\/ invalidProductIdentifiers contains all product identifiers that the App Store doesn’t recognize.\nif !response.invalidProductIdentifiers.isEmpty {\n    invalidProductIdentifiers = response.invalidProductIdentifiers\n}",
      "language" : "swift"
    },
    {
      "code" : "extension SKProduct {\n    \/\/\/ - returns: The cost of the product formatted in the local currency.\n    var regularPrice: String? {\n        let formatter = NumberFormatter()\n        formatter.numberStyle = .currency\n        formatter.locale = self.priceLocale\n        return formatter.string(from: self.price)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {\n    for transaction in transactions {\n        switch transaction.transactionState {\n        case .purchasing: break\n        \/\/ Don’t block the UI. Allow the user to continue using the app.\n        case .deferred: print(Messages.deferred)\n        \/\/ The purchase was successful.\n        case .purchased: handlePurchased(transaction)\n        \/\/ The transaction failed.\n        case .failed: handleFailed(transaction)\n        \/\/ There are restored products.\n        case .restored: handleRestored(transaction)\n        @unknown default: fatalError(Messages.unknownPaymentTransaction)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Don’t send any notifications when the user cancels the purchase.\nif (transaction.error as? SKError)?.code != .paymentCancelled {\n    DispatchQueue.main.async {\n        self.delegate?.storeObserverDidReceiveMessage(message)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@IBAction func restore(_ sender: UIBarButtonItem) {\n    \/\/ Calls StoreObserver to restore all restorable purchases.\n    StoreObserver.shared.restore()\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Finish the successful transaction.\nSKPaymentQueue.default().finishTransaction(transaction)",
      "language" : "swift"
    }
  ],
  "contentHash" : "9d406fc50f276cab755b5d4112346e0cb92ab7703ae11bea37c68dbd5bac9a87",
  "crawledAt" : "2025-12-02T15:50:40Z",
  "id" : "EFD95C56-B59B-495D-A0EC-B311A65C6DE2",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "StoreKit",
  "overview" : "## Overview\n\nUse the In-App Purchase API to give people the ability to purchase virtual goods within your app or directly from the App Store using the StoreKit framework. This sample code project demonstrates how to retrieve, display, and restore in-app purchases. First, you set up your app to register and use a single-transaction queue observer at launch. The transaction queue observer manages all payment transactions and handles all transaction states. Confirm that it’s a shared instance of a custom class that conforms to the [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionObserver] protocol. Then, remove the transaction observer when the system is about to terminate the app. See [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/setting-up-the-transaction-observer-for-the-payment-queue] for more information.\n\nThis sample code project, which builds the InAppPurchases app, supports the iOS, iPadOS, macOS, and tvOS platforms. After launching, the app queries the App Store about product identifiers in the `Products.plist` file. The app updates its UI with the App Store’s response, which may include available products for sale, unrecognized product identifiers, or both. The app also displays all available purchased and restored payment transactions.\n\n### Configure the sample code project\n\nBefore you can run and test this sample code project, you need to:\n\n### Display available products for sale with localized pricing\n\nThe sample configures the app so it confirms that the user has authorization to make payments on the device before presenting products for sale.\n\nAfter the app confirms authorization, it sends a products request to the App Store to fetch localized product information. Querying the App Store ensures that the app only presents users with products available for purchase. The app initializes the products request with a list of product identifiers associated with products to sell in its UI. Be sure to keep a strong reference to the products request object; the system may release it before the request completes. See [https:\/\/help.apple.com\/app-store-connect\/#\/dev84b80958f] for more information.\n\nThe App Store responds to the products request with an [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKProductsResponse] object. Its [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKProductsResponse\/products] property contains information about all the products that are available for purchase in the App Store. The app uses this property to update its UI. The response’s `invalidProductIdentifiers` property includes all product identifiers that the App Store doesn’t recognize. See `invalidProductIdentifiers` for reasons the App Store may return invalid product identifiers.\n\nTo display the price of a product in the UI, the app uses the locale and currency that the App Store returns. For instance, consider a user who is logged in to the French App Store and their device uses the United States locale. When attempting to purchase a product, the App Store displays the product’s price in Euros. Converting and showing the product’s price in U.S. dollars to match the device’s locale would be incorrect.\n\n### Interact with the app to purchase products\n\nUsers can tap any product available for sale in the UI to purchase it. The app allows users to restore non-consumable products and auto-renewable subscriptions. The sample implements the Restore button and Settings > Restore all restorable purchases to implement this feature in the iOS and tvOS version of the app, respectively. It implements the Store > Restore menu item to restore purchases in the macOS version of the app.\n\nTapping any purchased item brings up purchase information, such as product identifier, transaction identifier, and transaction date. When the purchase is a restored one, the purchase information also contains its original transaction’s identifier and date.\n\n### Handle payment transaction states\n\nWhen a transaction is pending in the payment queue, StoreKit notifies the app’s transaction observer by calling its [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionObserver\/paymentQueue(_:updatedTransactions:)] method. Every transaction has five possible states, including [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/purchasing], [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/purchased], [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/failed], [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/restored], and [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/deferred]. For more information, see [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState]. The observer’s `paymentQueue(_:updatedTransactions:)` needs to be able to respond to any of these states at any time.\n\nWhen a transaction fails, the app inspects the [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransaction\/error] property to determine what happened. The app only displays errors with code that is different from [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKError\/paymentCancelled].\n\nWhen the user defers a transaction, apps need to allow them to continue using the UI while waiting for StoreKit to update the transaction.\n\n### Restore completed purchases\n\nWhen users purchase non-consumables, auto-renewable subscriptions, or non-renewing subscriptions, they expect them to be available on all their devices indefinitely. The app provides a UI that allows users to restore their past purchases. See [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/original-api-for-in-app-purchase#Understand-product-types] for more information.\n\nThe sample uses [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentQueue\/restoreCompletedTransactions()] to restore non-consumables and auto-renewable subscriptions. StoreKit notifies the app’s transaction observer by calling `paymentQueue(_:updatedTransactions:)` with a transaction state of `.restored` for each restored transaction. Restoring non-renewing subscriptions isn’t within the scope of this sample code project. For information about restore failures, see `restoreCompletedTransactions()`.\n\n### Provide content and finish the transaction\n\nApps need to deliver the content or unlock the purchased functionality after receiving a transaction with a state of `.purchased` or `.restored`. These states indicate that the App Store has received a payment for a product from the user.\n\nUnfinished transactions stay in the payment queue. StoreKit calls the app’s persistent observer’s `paymentQueue(_:updatedTransactions:)` each time upon launching or resuming from the background until the app finishes these transactions. As a result, the App Store may repeatedly prompt users to authenticate their purchases or prevent them from purchasing products from the app.\n\nThe sample calls [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentQueue\/finishTransaction(_:)] on transactions with a state of `.failed`, `.purchased`, or `.restored` to remove them from the queue. Finished transactions aren’t recoverable. Therefore, apps need to provide the purchased content or complete their purchase process before finishing transactions.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/StoreKit\/offering-completing-and-restoring-in-app-purchases\ncrawled: 2025-12-02T15:50:40Z\n---\n\n# Offering, completing, and restoring in-app purchases\n\n**Sample Code**\n\nFetch, display, purchase, validate, and finish transactions in your app.\n\n## Overview\n\nUse the In-App Purchase API to give people the ability to purchase virtual goods within your app or directly from the App Store using the StoreKit framework. This sample code project demonstrates how to retrieve, display, and restore in-app purchases. First, you set up your app to register and use a single-transaction queue observer at launch. The transaction queue observer manages all payment transactions and handles all transaction states. Confirm that it’s a shared instance of a custom class that conforms to the [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionObserver] protocol. Then, remove the transaction observer when the system is about to terminate the app. See [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/setting-up-the-transaction-observer-for-the-payment-queue] for more information.\n\nThis sample code project, which builds the InAppPurchases app, supports the iOS, iPadOS, macOS, and tvOS platforms. After launching, the app queries the App Store about product identifiers in the `Products.plist` file. The app updates its UI with the App Store’s response, which may include available products for sale, unrecognized product identifiers, or both. The app also displays all available purchased and restored payment transactions.\n\n### Configure the sample code project\n\nBefore you can run and test this sample code project, you need to:\n\n1. Start with a completed app that supports in-app purchases and has some configured in-app purchases in App Store Connect. For more information, see [https:\/\/developer.apple.com\/help\/app-store-connect\/configure-in-app-purchase-settings\/overview-for-configuring-in-app-purchases].\n2. Create [https:\/\/developer.apple.com\/help\/app-store-connect\/test-in-app-purchases\/create-a-sandbox-apple-account\/] in App Store Connect.\n3. Open the sample code project in Xcode, select the target that you want to build, click Signing & Capabilities, and change its bundle identifier to one that supports in-app purchases.\n4. Choose the appropriate team from the Team pop-up menu to let Xcode automatically manage your provisioning profile. See [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev23aab79b4] for details.\n5. Open the `ProductIds.plist` file in the sample and update its content with your existing in-app purchases product IDs.\n6. For iOS and tvOS devices, build and run the `InAppPurchases` and `InAppPurchasestvOS` targets, respectively, which the sample uses to build the app. If you have any code-signing issues, see [https:\/\/help.apple.com\/xcode\/mac\/current\/#\/dev01865b392].\n7. For macOS, before building the `InAppPurchasesmacOS` target, sign out of the Mac App Store. Build the target, then launch the resulting app from the Finder the first time to obtain a receipt. See [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/testing-in-app-purchases-with-sandbox] for details.\n8. Upon launching, the app queries the App Store about the product identifiers in `ProductIds.plist`. When successful, it displays a list of products available for sale in the App Store. Tap any product in that list to purchase it. When you receive a prompt to authenticate the purchase, use your test user account. If the product request fails, see [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKProductsResponse\/invalidProductIdentifiers] for reasons the App Store may return invalid product identifiers.\n\n### Display available products for sale with localized pricing\n\nThe sample configures the app so it confirms that the user has authorization to make payments on the device before presenting products for sale.\n\n```swift\nvar isAuthorizedForPayments: Bool {\n    return SKPaymentQueue.canMakePayments()\n}\n```\n\nAfter the app confirms authorization, it sends a products request to the App Store to fetch localized product information. Querying the App Store ensures that the app only presents users with products available for purchase. The app initializes the products request with a list of product identifiers associated with products to sell in its UI. Be sure to keep a strong reference to the products request object; the system may release it before the request completes. See [https:\/\/help.apple.com\/app-store-connect\/#\/dev84b80958f] for more information.\n\n```swift\nfileprivate func fetchProducts(matchingIdentifiers identifiers: [String]) {\n    \/\/ Create a set for the product identifiers.\n    let productIdentifiers = Set(identifiers)\n    \n    \/\/ Initialize the product request with the above identifiers.\n    productRequest = SKProductsRequest(productIdentifiers: productIdentifiers)\n    productRequest.delegate = self\n    \n    \/\/ Send the request to the App Store.\n    productRequest.start()\n}\n```\n\nThe App Store responds to the products request with an [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKProductsResponse] object. Its [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKProductsResponse\/products] property contains information about all the products that are available for purchase in the App Store. The app uses this property to update its UI. The response’s `invalidProductIdentifiers` property includes all product identifiers that the App Store doesn’t recognize. See `invalidProductIdentifiers` for reasons the App Store may return invalid product identifiers.\n\n```swift\n\/\/ Contains products with identifiers that the App Store recognizes. As such, they are available for purchase.\nif !response.products.isEmpty {\n    availableProducts = response.products\n}\n\n\/\/ invalidProductIdentifiers contains all product identifiers that the App Store doesn’t recognize.\nif !response.invalidProductIdentifiers.isEmpty {\n    invalidProductIdentifiers = response.invalidProductIdentifiers\n}\n```\n\nTo display the price of a product in the UI, the app uses the locale and currency that the App Store returns. For instance, consider a user who is logged in to the French App Store and their device uses the United States locale. When attempting to purchase a product, the App Store displays the product’s price in Euros. Converting and showing the product’s price in U.S. dollars to match the device’s locale would be incorrect.\n\n```swift\nextension SKProduct {\n    \/\/\/ - returns: The cost of the product formatted in the local currency.\n    var regularPrice: String? {\n        let formatter = NumberFormatter()\n        formatter.numberStyle = .currency\n        formatter.locale = self.priceLocale\n        return formatter.string(from: self.price)\n    }\n}\n```\n\n### Interact with the app to purchase products\n\nUsers can tap any product available for sale in the UI to purchase it. The app allows users to restore non-consumable products and auto-renewable subscriptions. The sample implements the Restore button and Settings > Restore all restorable purchases to implement this feature in the iOS and tvOS version of the app, respectively. It implements the Store > Restore menu item to restore purchases in the macOS version of the app.\n\nTapping any purchased item brings up purchase information, such as product identifier, transaction identifier, and transaction date. When the purchase is a restored one, the purchase information also contains its original transaction’s identifier and date.\n\n### Handle payment transaction states\n\nWhen a transaction is pending in the payment queue, StoreKit notifies the app’s transaction observer by calling its [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionObserver\/paymentQueue(_:updatedTransactions:)] method. Every transaction has five possible states, including [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/purchasing], [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/purchased], [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/failed], [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/restored], and [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState\/deferred]. For more information, see [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransactionState]. The observer’s `paymentQueue(_:updatedTransactions:)` needs to be able to respond to any of these states at any time.\n\n```swift\nfunc paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {\n    for transaction in transactions {\n        switch transaction.transactionState {\n        case .purchasing: break\n        \/\/ Don’t block the UI. Allow the user to continue using the app.\n        case .deferred: print(Messages.deferred)\n        \/\/ The purchase was successful.\n        case .purchased: handlePurchased(transaction)\n        \/\/ The transaction failed.\n        case .failed: handleFailed(transaction)\n        \/\/ There are restored products.\n        case .restored: handleRestored(transaction)\n        @unknown default: fatalError(Messages.unknownPaymentTransaction)\n        }\n    }\n}\n```\n\nWhen a transaction fails, the app inspects the [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentTransaction\/error] property to determine what happened. The app only displays errors with code that is different from [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKError\/paymentCancelled].\n\n```swift\n\/\/ Don’t send any notifications when the user cancels the purchase.\nif (transaction.error as? SKError)?.code != .paymentCancelled {\n    DispatchQueue.main.async {\n        self.delegate?.storeObserverDidReceiveMessage(message)\n    }\n}\n```\n\nWhen the user defers a transaction, apps need to allow them to continue using the UI while waiting for StoreKit to update the transaction.\n\n### Restore completed purchases\n\nWhen users purchase non-consumables, auto-renewable subscriptions, or non-renewing subscriptions, they expect them to be available on all their devices indefinitely. The app provides a UI that allows users to restore their past purchases. See [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/original-api-for-in-app-purchase#Understand-product-types] for more information.\n\n```swift\n@IBAction func restore(_ sender: UIBarButtonItem) {\n    \/\/ Calls StoreObserver to restore all restorable purchases.\n    StoreObserver.shared.restore()\n}\n```\n\nThe sample uses [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentQueue\/restoreCompletedTransactions()] to restore non-consumables and auto-renewable subscriptions. StoreKit notifies the app’s transaction observer by calling `paymentQueue(_:updatedTransactions:)` with a transaction state of `.restored` for each restored transaction. Restoring non-renewing subscriptions isn’t within the scope of this sample code project. For information about restore failures, see `restoreCompletedTransactions()`.\n\n### Provide content and finish the transaction\n\nApps need to deliver the content or unlock the purchased functionality after receiving a transaction with a state of `.purchased` or `.restored`. These states indicate that the App Store has received a payment for a product from the user.\n\nUnfinished transactions stay in the payment queue. StoreKit calls the app’s persistent observer’s `paymentQueue(_:updatedTransactions:)` each time upon launching or resuming from the background until the app finishes these transactions. As a result, the App Store may repeatedly prompt users to authenticate their purchases or prevent them from purchasing products from the app.\n\nThe sample calls [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/SKPaymentQueue\/finishTransaction(_:)] on transactions with a state of `.failed`, `.purchased`, or `.restored` to remove them from the queue. Finished transactions aren’t recoverable. Therefore, apps need to provide the purchased content or complete their purchase process before finishing transactions.\n\n```swift\n\/\/ Finish the successful transaction.\nSKPaymentQueue.default().finishTransaction(transaction)\n```\n\n## Essentials\n\n- **Setting up the transaction observer for the payment queue**: Enable your app to receive and handle transactions by adding an observer.\n- **SKPaymentQueue**: A queue of payment transactions for the App Store to process.\n- **SKPaymentTransactionObserver**: A set of methods that process transactions, unlock purchased functionality, and continue promoted In-App Purchases.\n- **SKPaymentQueueDelegate**: The protocol that provides information needed to complete transactions.\n- **SKRequest**: An abstract class that represents a request to the App Store.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Enable your app to receive and handle transactions by adding an observer.",
          "name" : "Setting up the transaction observer for the payment queue",
          "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/setting-up-the-transaction-observer-for-the-payment-queue"
        },
        {
          "description" : "A queue of payment transactions for the App Store to process.",
          "name" : "SKPaymentQueue",
          "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/SKPaymentQueue"
        },
        {
          "description" : "A set of methods that process transactions, unlock purchased functionality, and continue promoted In-App Purchases.",
          "name" : "SKPaymentTransactionObserver",
          "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/SKPaymentTransactionObserver"
        },
        {
          "description" : "The protocol that provides information needed to complete transactions.",
          "name" : "SKPaymentQueueDelegate",
          "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/SKPaymentQueueDelegate"
        },
        {
          "description" : "An abstract class that represents a request to the App Store.",
          "name" : "SKRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/SKRequest"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Offering, completing, and restoring in-app purchases",
  "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/offering-completing-and-restoring-in-app-purchases"
}