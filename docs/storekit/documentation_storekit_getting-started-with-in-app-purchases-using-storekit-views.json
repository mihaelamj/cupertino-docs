{
  "abstract" : "Set up an in-app store using SwiftUI and StoreKit views.",
  "codeExamples" : [
    {
      "code" : "enum ProductID: String {\n    case consumable = \"consumable\"\n    case consumablePack = \"consumable_pack\"\n\n    case nonconsumable = \"nonconsumable\"\n\n    case subscriptionMonthly = \"subscription_monthly\"\n    case subscriptionYearly = \"subscription_yearly\"\n    case subscriptionPremiumYearly = \"premium_subscription_yearly\"\n}",
      "language" : "swift"
    },
    {
      "code" : "import Foundation\nimport Observation\nimport StoreKit\n\n@MainActor\n@Observable\nfinal class Store {\n    private let defaultsKey = \"com.example.consumable count\"\n    private let nonConsumableDefaultsKey = \"com.example.nonconsumable\"\n\n    public var consumableCount: Int {\n        willSet {\n            UserDefaults.standard.set(newValue, forKey: defaultsKey)\n        }\n    }\n    public var boughtNonConsumable: Bool = false\n    public var activeSubscription: String? = nil\n\n    init() {\n        self.consumableCount = UserDefaults.standard.integer(forKey: defaultsKey)  \/\/ Returns 0 on first app launch.\n\n        \/\/ Because the tasks below capture 'self' in their closures, this object must be fully initialized before this point.\n        Task(priority: .background) {\n            \/\/ Finish any unfinished transactions -- for example, if the app was terminated before finishing a transaction.\n            for await verificationResult in Transaction.unfinished {\n                await handle(updatedTransaction: verificationResult)\n            }\n\n            \/\/ Fetch current entitlements for all product types except consumables.\n            for await verificationResult in Transaction.currentEntitlements {\n                await handle(updatedTransaction: verificationResult)\n            }\n        }\n        Task(priority: .background) {\n            for await verificationResult in Transaction.updates {\n                await handle(updatedTransaction: verificationResult)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private func handle(updatedTransaction verificationResult: VerificationResult<Transaction>) async {\n    \/\/ The code below handles only verified transactions; handle unverified transactions based on your business model.\n    guard case .verified(let transaction) = verificationResult else { return }\n\n    if let _ = transaction.revocationDate {\n        \/\/ Remove access to the product identified by `transaction.productID`.\n        \/\/ `Transaction.revocationReason` provides details about the revoked transaction.\n        guard let productID = ProductID(rawValue: transaction.productID) else {\n            print(\"Unexpected product: \\(transaction.productID).\")\n            return\n        }\n\n        switch productID {\n        case .consumable:\n            consumableCount -= 1\n        case .consumablePack:\n            consumableCount -= 10\n        case .nonconsumable:\n            boughtNonConsumable = false\n        case .subscriptionMonthly, .subscriptionYearly, .subscriptionPremiumYearly:\n            \/\/ In an app that supports Family Sharing, there might be another entitlement that still provides access to the subscription.\n            activeSubscription = nil\n        }\n        await transaction.finish()\n        return\n    } else if let expirationDate = transaction.expirationDate, expirationDate < Date() {\n        \/\/ In an app that supports Family Sharing, there might be another entitlement that still provides access to the subscription.\n        activeSubscription = nil\n        return\n    } else {\n        \/\/ Provide access to the product identified by transaction.productID.\n        guard let productID = ProductID(rawValue: transaction.productID) else {\n            print(\"Unexpected product: \\(transaction.productID).\")\n            return\n        }\n        print(\"transaction ID \\(transaction.id), product ID \\(transaction.productID)\")\n        switch productID {\n        case .consumable:\n            consumableCount += 1\n        case .consumablePack:\n            consumableCount += 10\n        case .nonconsumable:\n            boughtNonConsumable = true\n        case .subscriptionMonthly, .subscriptionYearly, .subscriptionPremiumYearly:\n            \/\/ In an app that supports Family Sharing, there might be another entitlement that already provides access to the subscription.\n            activeSubscription = transaction.productID\n        }\n        await transaction.finish()\n        return\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "import StoreKit\nimport SwiftUI\n\nstruct AllProductsView: View {\n    \/\/ Your app's data store.\n    @Environment(Store.self) private var store: Store\n\n    var body: some View {\n        @Bindable var store = store\n        VStack {\n            \/\/ ProductID.all is an array of your product ID strings.\n            StoreView(ids: ProductID.all)\n                .storeButton(.hidden, for: .cancellation)\n                .storeButton(.visible, for: .restorePurchases)\n        }\n        .padding()\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "b20628f08e3d0f6c96d2da4898567b35322c788a78b3b2c75b51b086e15c4a88",
  "crawledAt" : "2025-12-03T15:50:39Z",
  "id" : "7ED9A182-691C-46A4-9319-E26B18732D8A",
  "kind" : "article",
  "language" : "swift",
  "module" : "StoreKit",
  "overview" : "## Overview\n\nStoreKit provides a streamlined system for building basic In-App Purchase (IAP) capabilities that allow you to provide purchases in your app and process transactions using simple SwiftUI views. You can use this capability to build a basic store with default styling, or you can customize your store’s experience using the full, expressive capabilities of SwiftUI.\n\n## Choose your product types\n\nStoreKit supports the following product types, and StoreKit views can display all of them without any custom programming:\n\n## Prototype your in-app store offline\n\nWith StoreKit, you can create a file that allows you to prototype and test your In-App Purchase code in Xcode without needing to set up products in App Store Connect. Xcode calls this a StoreKit local configuration; to create a local configuration file, follow these steps:\n\nFor more information about setting up a local configuration file, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/setting-up-storekit-testing-in-xcode].\n\nThis local configuration file allows you to experiment with product IDs and various purchase types offline. To use the product IDs in a published app, create the same product IDs in App Store Connect after you finish prototyping.\n\n## Choose IDs for your products\n\nIn your app, define products that someone can buy, in order to prototype your store. Choose descriptive product IDs that are easy for you to read and understand. In this example, the product IDs describe the product type they represent.\n\nAlthough you could write product IDs in your code as an array of strings, defining an enumeration whose raw value is a string can help make your code easier to read. For example, when you add a new product, any `switch` that handles product IDs but omits the new product produces a compile-time error.\n\n## Monitor transactions in your app\n\nStoreKit provides several asynchronous sequences that provide your app with information and updates. For example, the class below checks [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/Transaction\/unfinished] and [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/Transaction\/currentEntitlements] at startup, and continues to check [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/Transaction\/updates] in the background while the app is running.\n\nThe `handle(updatedTransaction:)` method handles new verification results from all three sources of updates, to provide access to newly purchased content. For example, this work could include allocating consumable in-game coins, or delivering an in-game object.\n\n## Define products in the local StoreKit configuration file\n\nBefore moving on to the views that display these products, define these products in the local configuration file you created earlier.\n\nTo create the local products, follow these steps:\n\n\n\n## Create SwiftUI views that display your products\n\nAfter completing the local configuration, you can show all of your products on one page with a simple, compact SwiftUI view.\n\nHere, the `StoreView` view from StoreKit constructs a page and lays out a grid that contains each product, as shown in the following screenshot:\n\n\n\nTo show a specific subset of your available products, use the same view structure, but change the list of product IDs you provide to the `StoreView()`. So, change `store.allProductIDs` to another array of product IDs. For example, the `subscriptionProductIDs` array contains only subscription purchase types, so replace `store.allProductIDs` with the `subscriptionProductIDs` array to show subscriptions as shown here.\n\n\n\nFor more information on StoreKit Testing in Xcode, see [https:\/\/developer.apple.com\/documentation\/xcode\/setting-up-storekit-testing-in-xcode\/]. For more information on the presentation of In-App purchase products, see Human Interface Guidelines > [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/in-app-purchase]. For more information on creating products in App Store Connect, see [https:\/\/developer.apple.com\/help\/app-store-connect\/configure-in-app-purchase-settings\/overview-for-configuring-in-app-purchases].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/storekit\/getting-started-with-in-app-purchases-using-storekit-views\ncrawled: 2025-12-03T15:50:39Z\n---\n\n# Getting started with In-App Purchase using StoreKit views\n\n**Article**\n\nSet up an in-app store using SwiftUI and StoreKit views.\n\n## Overview\n\nStoreKit provides a streamlined system for building basic In-App Purchase (IAP) capabilities that allow you to provide purchases in your app and process transactions using simple SwiftUI views. You can use this capability to build a basic store with default styling, or you can customize your store’s experience using the full, expressive capabilities of SwiftUI.\n\n## Choose your product types\n\nStoreKit supports the following product types, and StoreKit views can display all of them without any custom programming:\n\n\n\n## Prototype your in-app store offline\n\nWith StoreKit, you can create a file that allows you to prototype and test your In-App Purchase code in Xcode without needing to set up products in App Store Connect. Xcode calls this a StoreKit local configuration; to create a local configuration file, follow these steps:\n\n1. Open your app’s Xcode project.\n2. Create the local StoreKit configuration by selecting File > New > File From Template.\n3. In the sheet that appears, enter *storekit* in the Filter search field.\n4. Click the StoreKit Configuration File, then click Next.\n5. In the dialog, enter a name for the file, for example `LocalConfiguration.storekit`. Leave the configuration sync checkbox unchecked and click Next.\n6. Select a location for your file in your app’s project, then click Create to save the file.\n\nFor more information about setting up a local configuration file, see [doc:\/\/com.apple.documentation\/documentation\/Xcode\/setting-up-storekit-testing-in-xcode].\n\nThis local configuration file allows you to experiment with product IDs and various purchase types offline. To use the product IDs in a published app, create the same product IDs in App Store Connect after you finish prototyping.\n\n## Choose IDs for your products\n\nIn your app, define products that someone can buy, in order to prototype your store. Choose descriptive product IDs that are easy for you to read and understand. In this example, the product IDs describe the product type they represent.\n\nAlthough you could write product IDs in your code as an array of strings, defining an enumeration whose raw value is a string can help make your code easier to read. For example, when you add a new product, any `switch` that handles product IDs but omits the new product produces a compile-time error.\n\n```swift\nenum ProductID: String {\n    case consumable = \"consumable\"\n    case consumablePack = \"consumable_pack\"\n\n    case nonconsumable = \"nonconsumable\"\n\n    case subscriptionMonthly = \"subscription_monthly\"\n    case subscriptionYearly = \"subscription_yearly\"\n    case subscriptionPremiumYearly = \"premium_subscription_yearly\"\n}\n```\n\n\n\n## Monitor transactions in your app\n\nStoreKit provides several asynchronous sequences that provide your app with information and updates. For example, the class below checks [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/Transaction\/unfinished] and [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/Transaction\/currentEntitlements] at startup, and continues to check [doc:\/\/com.apple.storekit\/documentation\/StoreKit\/Transaction\/updates] in the background while the app is running.\n\n```swift\nimport Foundation\nimport Observation\nimport StoreKit\n\n@MainActor\n@Observable\nfinal class Store {\n    private let defaultsKey = \"com.example.consumable count\"\n    private let nonConsumableDefaultsKey = \"com.example.nonconsumable\"\n\n    public var consumableCount: Int {\n        willSet {\n            UserDefaults.standard.set(newValue, forKey: defaultsKey)\n        }\n    }\n    public var boughtNonConsumable: Bool = false\n    public var activeSubscription: String? = nil\n\n    init() {\n        self.consumableCount = UserDefaults.standard.integer(forKey: defaultsKey)  \/\/ Returns 0 on first app launch.\n\n        \/\/ Because the tasks below capture 'self' in their closures, this object must be fully initialized before this point.\n        Task(priority: .background) {\n            \/\/ Finish any unfinished transactions -- for example, if the app was terminated before finishing a transaction.\n            for await verificationResult in Transaction.unfinished {\n                await handle(updatedTransaction: verificationResult)\n            }\n\n            \/\/ Fetch current entitlements for all product types except consumables.\n            for await verificationResult in Transaction.currentEntitlements {\n                await handle(updatedTransaction: verificationResult)\n            }\n        }\n        Task(priority: .background) {\n            for await verificationResult in Transaction.updates {\n                await handle(updatedTransaction: verificationResult)\n            }\n        }\n    }\n}\n```\n\nThe `handle(updatedTransaction:)` method handles new verification results from all three sources of updates, to provide access to newly purchased content. For example, this work could include allocating consumable in-game coins, or delivering an in-game object.\n\n```swift\nprivate func handle(updatedTransaction verificationResult: VerificationResult<Transaction>) async {\n    \/\/ The code below handles only verified transactions; handle unverified transactions based on your business model.\n    guard case .verified(let transaction) = verificationResult else { return }\n\n    if let _ = transaction.revocationDate {\n        \/\/ Remove access to the product identified by `transaction.productID`.\n        \/\/ `Transaction.revocationReason` provides details about the revoked transaction.\n        guard let productID = ProductID(rawValue: transaction.productID) else {\n            print(\"Unexpected product: \\(transaction.productID).\")\n            return\n        }\n\n        switch productID {\n        case .consumable:\n            consumableCount -= 1\n        case .consumablePack:\n            consumableCount -= 10\n        case .nonconsumable:\n            boughtNonConsumable = false\n        case .subscriptionMonthly, .subscriptionYearly, .subscriptionPremiumYearly:\n            \/\/ In an app that supports Family Sharing, there might be another entitlement that still provides access to the subscription.\n            activeSubscription = nil\n        }\n        await transaction.finish()\n        return\n    } else if let expirationDate = transaction.expirationDate, expirationDate < Date() {\n        \/\/ In an app that supports Family Sharing, there might be another entitlement that still provides access to the subscription.\n        activeSubscription = nil\n        return\n    } else {\n        \/\/ Provide access to the product identified by transaction.productID.\n        guard let productID = ProductID(rawValue: transaction.productID) else {\n            print(\"Unexpected product: \\(transaction.productID).\")\n            return\n        }\n        print(\"transaction ID \\(transaction.id), product ID \\(transaction.productID)\")\n        switch productID {\n        case .consumable:\n            consumableCount += 1\n        case .consumablePack:\n            consumableCount += 10\n        case .nonconsumable:\n            boughtNonConsumable = true\n        case .subscriptionMonthly, .subscriptionYearly, .subscriptionPremiumYearly:\n            \/\/ In an app that supports Family Sharing, there might be another entitlement that already provides access to the subscription.\n            activeSubscription = transaction.productID\n        }\n        await transaction.finish()\n        return\n    }\n}\n```\n\n## Define products in the local StoreKit configuration file\n\nBefore moving on to the views that display these products, define these products in the local configuration file you created earlier.\n\nTo create the local products, follow these steps:\n\n1. In Xcode, open the local StoreKit configuration file you created earlier.\n2. In the lower left corner click the plus (+) button; select the kind of product to add.\n3. Edit the new product name, product ID string, price, and other properties.\n4. Repeat steps 2 and 3 with additional product ID strings, and product types as needed.\n\n\n\n## Create SwiftUI views that display your products\n\nAfter completing the local configuration, you can show all of your products on one page with a simple, compact SwiftUI view.\n\n```swift\nimport StoreKit\nimport SwiftUI\n\nstruct AllProductsView: View {\n    \/\/ Your app's data store.\n    @Environment(Store.self) private var store: Store\n\n    var body: some View {\n        @Bindable var store = store\n        VStack {\n            \/\/ ProductID.all is an array of your product ID strings.\n            StoreView(ids: ProductID.all)\n                .storeButton(.hidden, for: .cancellation)\n                .storeButton(.visible, for: .restorePurchases)\n        }\n        .padding()\n    }\n}\n```\n\nHere, the `StoreView` view from StoreKit constructs a page and lays out a grid that contains each product, as shown in the following screenshot:\n\n\n\nTo show a specific subset of your available products, use the same view structure, but change the list of product IDs you provide to the `StoreView()`. So, change `store.allProductIDs` to another array of product IDs. For example, the `subscriptionProductIDs` array contains only subscription purchase types, so replace `store.allProductIDs` with the `subscriptionProductIDs` array to show subscriptions as shown here.\n\n\n\nFor more information on StoreKit Testing in Xcode, see [https:\/\/developer.apple.com\/documentation\/xcode\/setting-up-storekit-testing-in-xcode\/]. For more information on the presentation of In-App purchase products, see Human Interface Guidelines > [https:\/\/developer.apple.com\/design\/human-interface-guidelines\/in-app-purchase]. For more information on creating products in App Store Connect, see [https:\/\/developer.apple.com\/help\/app-store-connect\/configure-in-app-purchase-settings\/overview-for-configuring-in-app-purchases].\n\n## In-App Purchase\n\n- **In-App Purchase**: Offer content and services in your app across Apple platforms using a Swift-based interface.\n- **Understanding StoreKit workflows**: Implement an in-app store with several product types, using StoreKit views.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Offer content and services in your app across Apple platforms using a Swift-based interface.",
          "name" : "In-App Purchase",
          "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/in-app-purchase"
        },
        {
          "description" : "Implement an in-app store with several product types, using StoreKit views.",
          "name" : "Understanding StoreKit workflows",
          "url" : "https:\/\/developer.apple.com\/documentation\/StoreKit\/understanding-storekit-workflows"
        }
      ],
      "title" : "In-App Purchase"
    }
  ],
  "source" : "appleJSON",
  "title" : "Getting started with In-App Purchase using StoreKit views",
  "url" : "https:\/\/developer.apple.com\/documentation\/storekit\/getting-started-with-in-app-purchases-using-storekit-views"
}