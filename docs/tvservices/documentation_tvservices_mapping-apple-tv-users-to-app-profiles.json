{
  "abstract" : "Adapt the content of your app for the current viewer by using an entitlement and simplifying sign-in flows.",
  "codeExamples" : [
    {
      "code" : "<key>com.apple.developer.user-management<\/key>\n<array>\n    <string>runs-as-current-user-with-user-independent-keychain<\/string>\n<\/array>",
      "language" : "plist"
    },
    {
      "code" : "private var selectedProfileIdentifier: String? {\n    didSet {\n        guard oldValue != selectedProfileIdentifier else { return }\n\n        \/\/ If running on tvOS 16, check if the selected profile should be\n        \/\/ remembered before storing it.\n        if #available(tvOS 16.0, *), userManager.shouldStorePreferencesForCurrentUser {\n            UserDefaults.standard.set(selectedProfileIdentifier, forKey: \"PreferredProfileIdentifierKey\")\n        }",
      "language" : "swift"
    },
    {
      "code" : "private func presentProfilePickerIfNeeded() {\n    if #available(tvOS 16.0, *) {\n        \/\/ On tvOS 16, present the profile picker only if the Apple TV\n        \/\/ doesn't have multiple users, or the current user hasn't picked a\n        \/\/ profile yet.\n        if !userManager.shouldStorePreferencesForCurrentUser || profileData.selectedProfile == nil {\n            presentProfilePicker()\n        }\n    } else {\n        \/\/ Always present the profile picker on tvOS 15 and earlier.\n        presentProfilePicker()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var baseQuery: [CFString: Any] = [\n    kSecAttrService: \"com.example.apple-samplecode.ProfilesSample\",\n    kSecClass: kSecClassGenericPassword\n]\nif #available(tvOS 16.0, *) {\n    baseQuery[kSecUseUserIndependentKeychain] = kCFBooleanTrue as AnyObject\n}\nself.baseQuery = baseQuery",
      "language" : "swift"
    },
    {
      "code" : "private func loadCredentials() {\n    var attributesQuery = baseQuery\n    attributesQuery[kSecReturnAttributes] = kCFBooleanTrue\n\n    \/\/ Read all attributes. This is where the username comes from.\n    var outAttributes: AnyObject?\n    guard SecItemCopyMatching(attributesQuery as CFDictionary, &outAttributes) == errSecSuccess,\n          let attributes = outAttributes as? [CFString: Any] else {\n        return\n    }\n\n    \/\/ This is where the password comes from.\n    var passwordQuery = baseQuery\n    passwordQuery[kSecAttrAccount] = attributes[kSecAttrAccount]\n    passwordQuery[kSecReturnData] = kCFBooleanTrue\n\n    var outPassword: AnyObject?\n    guard SecItemCopyMatching(passwordQuery as CFDictionary, &outPassword) == errSecSuccess,\n          let passwordData = outPassword as? Data else {\n        return\n    }\n\n    if let username = attributes[kSecAttrAccount] as? String,\n        let password = String(data: passwordData, encoding: .utf8) {\n        credentials = (username: username, password: password)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func save(username: String, password: String) {\n    guard let passwordData = password.data(using: .utf8) else {\n        return\n    }\n\n    let attributes: [CFString: Any] = [\n        kSecAttrAccount: username,\n        kSecValueData: passwordData\n    ]\n\n    var status: OSStatus = errSecCoreFoundationUnknown\n    var itemExists = SecItemCopyMatching(baseQuery as CFDictionary, nil) == errSecSuccess\n\n    \/\/ Try to add the item to the keychain first.\n    if !itemExists {\n        let addAttributes = baseQuery.merging(attributes) { (current, _) in current }\n        status = SecItemAdd(addAttributes as CFDictionary, nil)\n        itemExists = status == errSecDuplicateItem\n    }\n\n    \/\/ Otherwise, update if it already exists.\n    if itemExists {\n        status = SecItemUpdate(baseQuery as CFDictionary, attributes as CFDictionary)\n    }\n\n    guard status == errSecSuccess else {\n        return\n    }\n\n    credentials = (username, password)\n}\n\nfunc removeCredentials() {\n    SecItemDelete(baseQuery as CFDictionary)\n    credentials = nil\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "35b018695a6533d0f422fa972e65b87ef1010ad89111160580b9c205c504a4d1",
  "crawledAt" : "2025-12-02T15:33:44Z",
  "id" : "76A4FA32-75DF-4014-A793-7AEAE73B3F91",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "TV Services",
  "overview" : "## Overview\n\nThis sample demonstrates how to reduce configuration dialogs for people who share an Apple TV and a service account, such as a family media subscription. To let people get to your content more directly, your app should save shared login information where it can access the credentials regardless of the current user, and your code should also remember which profile to load for each user.\n\n### Configure the sample code project\n\nBefore you run the sample code project in Xcode:\n\n### Run as the current user\n\nApple TV supports multiple users. To opt-in to keeping separate data for each user, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.user-management] to your app or app extension, with the value `runs-as-current-user-with-user-independent-keychain`.\n\n### Save each user’s profile\n\nWhen your app or extension is running on tvOS 16 with multiple Apple TV users, you can store each person’s preferred profile directly with an API such as [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UserDefaults] or CloudKit; the system separates the data for each Apple TV user. Your code doesn’t have to handle any data partitioning.\n\nHere’s an example using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UserDefaults] to save the profile.\n\nThe sample only attempts to save the selected profile when running on tvOS 16 or later; it doesn’t run as the current user on tvOS 15 or earlier. It also checks [doc:\/\/com.apple.documentation\/documentation\/TVServices\/TVUserManager\/shouldStorePreferencesForCurrentUser] before saving to avoid remembering the selected profile in case there aren’t multiple users on the Apple TV.\n\n### Skip the profile-picker dialog\n\nThis sample app can skip the interstitial profile-picker dialog whenever a person who already has a saved profile launches the app.\n\nThe sample still presents the profile picker if the Apple TV doesn’t have multiple users, the current user doesn’t have a saved profile, or the app is running on tvOS 15 or earlier.\n\n### Store shared login credentials in the user-independent Keychain\n\nAnother interstitial dialog that can get in the way of the content is the sign-in screen. Keychain data is automatically separated for each Apple TV user. To avoid having each user sign in individually, tvOS 16 adds a new Keychain API: [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseUserIndependentKeychain].\n\nWith [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseUserIndependentKeychain], signing in only needs to happen once, even when running as the current user, because items stored using this property are accessible by all Apple TV users.\n\nThe `loadCredentials` method in the `KeychainController` shows how to use the `baseQuery` above to read the username and password from the Keychain:\n\nYou can also use the same `baseQuery` to save a new item with username and password.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/TVServices\/mapping-apple-tv-users-to-app-profiles\ncrawled: 2025-12-02T15:33:44Z\n---\n\n# Mapping Apple TV users to app profiles\n\n**Sample Code**\n\nAdapt the content of your app for the current viewer by using an entitlement and simplifying sign-in flows.\n\n## Overview\n\nThis sample demonstrates how to reduce configuration dialogs for people who share an Apple TV and a service account, such as a family media subscription. To let people get to your content more directly, your app should save shared login information where it can access the credentials regardless of the current user, and your code should also remember which profile to load for each user.\n\n\n\n### Configure the sample code project\n\nBefore you run the sample code project in Xcode:\n\n- Update your Apple TV to tvOS 15 or later. This app runs in single-user mode on tvOS 15 and supports multiple users on tvOS 16 and later.\n- Add users by choosing Settings > Users and Accounts > Add New User.\n- To switch TV users, press and hold the TV button on your remote or choose Settings > Users and Accounts > Switch Current User.\n\n### Run as the current user\n\nApple TV supports multiple users. To opt-in to keeping separate data for each user, add the [doc:\/\/com.apple.documentation\/documentation\/BundleResources\/Entitlements\/com.apple.developer.user-management] to your app or app extension, with the value `runs-as-current-user-with-user-independent-keychain`.\n\n```plist\n<key>com.apple.developer.user-management<\/key>\n<array>\n    <string>runs-as-current-user-with-user-independent-keychain<\/string>\n<\/array>\n```\n\n\n\n### Save each user’s profile\n\nWhen your app or extension is running on tvOS 16 with multiple Apple TV users, you can store each person’s preferred profile directly with an API such as [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UserDefaults] or CloudKit; the system separates the data for each Apple TV user. Your code doesn’t have to handle any data partitioning.\n\nHere’s an example using [doc:\/\/com.apple.documentation\/documentation\/Foundation\/UserDefaults] to save the profile.\n\n```swift\nprivate var selectedProfileIdentifier: String? {\n    didSet {\n        guard oldValue != selectedProfileIdentifier else { return }\n\n        \/\/ If running on tvOS 16, check if the selected profile should be\n        \/\/ remembered before storing it.\n        if #available(tvOS 16.0, *), userManager.shouldStorePreferencesForCurrentUser {\n            UserDefaults.standard.set(selectedProfileIdentifier, forKey: \"PreferredProfileIdentifierKey\")\n        }\n```\n\nThe sample only attempts to save the selected profile when running on tvOS 16 or later; it doesn’t run as the current user on tvOS 15 or earlier. It also checks [doc:\/\/com.apple.documentation\/documentation\/TVServices\/TVUserManager\/shouldStorePreferencesForCurrentUser] before saving to avoid remembering the selected profile in case there aren’t multiple users on the Apple TV.\n\n### Skip the profile-picker dialog\n\nThis sample app can skip the interstitial profile-picker dialog whenever a person who already has a saved profile launches the app.\n\n```swift\nprivate func presentProfilePickerIfNeeded() {\n    if #available(tvOS 16.0, *) {\n        \/\/ On tvOS 16, present the profile picker only if the Apple TV\n        \/\/ doesn't have multiple users, or the current user hasn't picked a\n        \/\/ profile yet.\n        if !userManager.shouldStorePreferencesForCurrentUser || profileData.selectedProfile == nil {\n            presentProfilePicker()\n        }\n    } else {\n        \/\/ Always present the profile picker on tvOS 15 and earlier.\n        presentProfilePicker()\n    }\n}\n```\n\nThe sample still presents the profile picker if the Apple TV doesn’t have multiple users, the current user doesn’t have a saved profile, or the app is running on tvOS 15 or earlier.\n\n### Store shared login credentials in the user-independent Keychain\n\nAnother interstitial dialog that can get in the way of the content is the sign-in screen. Keychain data is automatically separated for each Apple TV user. To avoid having each user sign in individually, tvOS 16 adds a new Keychain API: [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseUserIndependentKeychain].\n\nWith [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseUserIndependentKeychain], signing in only needs to happen once, even when running as the current user, because items stored using this property are accessible by all Apple TV users.\n\n```swift\nvar baseQuery: [CFString: Any] = [\n    kSecAttrService: \"com.example.apple-samplecode.ProfilesSample\",\n    kSecClass: kSecClassGenericPassword\n]\nif #available(tvOS 16.0, *) {\n    baseQuery[kSecUseUserIndependentKeychain] = kCFBooleanTrue as AnyObject\n}\nself.baseQuery = baseQuery\n```\n\nThe `loadCredentials` method in the `KeychainController` shows how to use the `baseQuery` above to read the username and password from the Keychain:\n\n```swift\nprivate func loadCredentials() {\n    var attributesQuery = baseQuery\n    attributesQuery[kSecReturnAttributes] = kCFBooleanTrue\n\n    \/\/ Read all attributes. This is where the username comes from.\n    var outAttributes: AnyObject?\n    guard SecItemCopyMatching(attributesQuery as CFDictionary, &outAttributes) == errSecSuccess,\n          let attributes = outAttributes as? [CFString: Any] else {\n        return\n    }\n\n    \/\/ This is where the password comes from.\n    var passwordQuery = baseQuery\n    passwordQuery[kSecAttrAccount] = attributes[kSecAttrAccount]\n    passwordQuery[kSecReturnData] = kCFBooleanTrue\n\n    var outPassword: AnyObject?\n    guard SecItemCopyMatching(passwordQuery as CFDictionary, &outPassword) == errSecSuccess,\n          let passwordData = outPassword as? Data else {\n        return\n    }\n\n    if let username = attributes[kSecAttrAccount] as? String,\n        let password = String(data: passwordData, encoding: .utf8) {\n        credentials = (username: username, password: password)\n    }\n}\n```\n\nYou can also use the same `baseQuery` to save a new item with username and password.\n\n```swift\nfunc save(username: String, password: String) {\n    guard let passwordData = password.data(using: .utf8) else {\n        return\n    }\n\n    let attributes: [CFString: Any] = [\n        kSecAttrAccount: username,\n        kSecValueData: passwordData\n    ]\n\n    var status: OSStatus = errSecCoreFoundationUnknown\n    var itemExists = SecItemCopyMatching(baseQuery as CFDictionary, nil) == errSecSuccess\n\n    \/\/ Try to add the item to the keychain first.\n    if !itemExists {\n        let addAttributes = baseQuery.merging(attributes) { (current, _) in current }\n        status = SecItemAdd(addAttributes as CFDictionary, nil)\n        itemExists = status == errSecDuplicateItem\n    }\n\n    \/\/ Otherwise, update if it already exists.\n    if itemExists {\n        status = SecItemUpdate(baseQuery as CFDictionary, attributes as CFDictionary)\n    }\n\n    guard status == errSecSuccess else {\n        return\n    }\n\n    credentials = (username, password)\n}\n\nfunc removeCredentials() {\n    SecItemDelete(baseQuery as CFDictionary)\n    credentials = nil\n}\n```\n\n## Multiple users\n\n- **Personalizing Your App for Each User on Apple TV**: Use account-specific storage to segregate data on a multiuser system.\n- **Supporting Multiple Users in Your tvOS App**: Store separate data for each user with the new Runs as Current User capability.\n- **TVUserManager**: An object that indicates how to store preferences for multiple people on a shared device.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Use account-specific storage to segregate data on a multiuser system.",
          "name" : "Personalizing Your App for Each User on Apple TV",
          "url" : "https:\/\/developer.apple.com\/documentation\/TVServices\/personalizing-your-app-for-each-user-on-apple-tv"
        },
        {
          "description" : "Store separate data for each user with the new Runs as Current User capability.",
          "name" : "Supporting Multiple Users in Your tvOS App",
          "url" : "https:\/\/developer.apple.com\/documentation\/TVServices\/supporting-multiple-users-in-your-tvos-app"
        },
        {
          "description" : "An object that indicates how to store preferences for multiple people on a shared device.",
          "name" : "TVUserManager",
          "url" : "https:\/\/developer.apple.com\/documentation\/TVServices\/TVUserManager"
        }
      ],
      "title" : "Multiple users"
    }
  ],
  "source" : "appleJSON",
  "title" : "Mapping Apple TV users to app profiles",
  "url" : "https:\/\/developer.apple.com\/documentation\/TVServices\/mapping-apple-tv-users-to-app-profiles"
}