{
  "abstract" : "Decrypt and verify an in-app presentment request on your server.",
  "codeExamples" : [
    {
      "code" : "HPKEEnvelope = {\n    “algorithm”: tstr,    ; A value that's always “APPLE-HPKE-v1”.\n    “params”: HPKEParams,\n    “data”: bstr          ; The encrypted data.\n}\n\nHPKEParams = {\n    “mode”: uint,         ; A value that's always 0.\n    “pkEm”: bstr,         ; An ephemeral sender public key.\n    “pkRHash”: bstr,      ; The SHA256 hash of the recipient public key.\n    “infoHash”: bstr      ; The SHA256 hash of the HPKE info param.\n}",
      "language" : "other"
    },
    {
      "code" : "SessionTranscript = [\n    nil,           ; DeviceEngagementBytes isn't available.\n    nil,           ; EReaderKeyBytes isn't available.        \n    AppleHandover  ; A custom handover structure. \n]\n\nAppleHandover = [\n    “AppleIdentityPresentment_1.0”  ; The version number.\n    nonce,                          ; The app-provided nonce you use.  \n    merchantId,                     ; The merchant ID of the requesting client.  \n    teamID,                         ; The team ID of the requesting client.\n    pkRHash                         ; A SHA256 hash of the recipient public key, the same as in HPKEParams.\n]",
      "language" : "other"
    },
    {
      "code" : "Topics = {\n    “identity”: DeviceResponse      ; A DeviceResponse structure.\n}\n\nDeviceResponse = {\n    \"version\": tstr,                ; A value that's always 1.0.\n    \"documents\": [+Document],       ; A list of documents with a length of 1.\n    \"status\": uint,                 ; A value that's always 0.\n}",
      "language" : "other"
    },
    {
      "code" : "Document = {\n    “docType”: DocType,                 ; The document type.\n    “issuerSigned”: IssuerSigned,       ; The data elements the issuer signs.\n    “deviceSigned”: DeviceSigned,       ; The data elements the mdoc signs.\n    ? “errors”: Errors                 \n}",
      "language" : "other"
    }
  ],
  "contentHash" : "265f9e0142f3d48b76ed7dfaf0d18a59654a0e9a6d4e264a4929587b9554f0d2",
  "crawledAt" : "2025-12-03T07:04:40Z",
  "id" : "E57578C8-3CD1-452B-8882-716EE5EA41EB",
  "kind" : "article",
  "language" : "swift",
  "module" : "PassKit (Apple Pay and Wallet)",
  "overview" : "## Overview\n\nYour server needs to decrypt and validate a mobile driver’s license (mDL) document that an app requests. The response contains the user information that you request, plus several security elements your server needs to validate the information to ensure it’s authentic.\n\n### Understand the response structure\n\nThe `PassKit` framework uses the encryption certificate you create in the developer portal, so only your server can decrypt the response. The framework encrypts the data by using hybrid public key encryption (HPKE) that RFC 9180 defines.\n\nThe framework encodes the HPKE envelope and underlying plaintext with concise binary object representation (CBOR) — a binary JSON-like format that RFC 8949 defines. Because the framework encrypts the response data by using HPKE, it doesn’t use session encryption as ISO 18013-5 section 9.1.1 defines. The encryption envelope contains two parts, the encryption metadata and the encrypted data. When you decrypt the data, you get a CBOR-encoded data structure that contains an `mdoc` response object that ISO 18013-5 defines.\n\nIn HPKE, the `info` parameter — a session transcript — isn’t part of the package that you send. The sender and recipient need to build the `info` parameter independently, and need to generate the same value to successfully decrypt it. The following shows the HPKE envelope format:\n\nThe `infoHash` in the HPKE structure is the SHA256 hash of the session transcript during encryption to allow the recipient to verify they’re using the correct `info` parameter.\n\n### Build a session transcript\n\nThe session transcript is a CBOR structure you use during decryption and during validation of the device signature. The session transcript allows you to validate that the response payload belongs to a specific request that your app makes.\n\nNeither the session transcript nor the fields in it are part of the response payload. You need to create the structure on your server. Before you create the session transcript structure, verify that the hash of your public key matches the `pkRHash` property in the HPKE envelope.\n\nThe session transcript structure includes the same [doc:\/\/com.apple.passkit\/documentation\/PassKit\/PKIdentityRequest\/nonce] and merchant identifier you use in your [doc:\/\/com.apple.passkit\/documentation\/PassKit\/PKIdentityRequest], a team identifier, and the SHA256 hash of the public key of the server’s decryption certificate. The session transcript values need to match your app and developer account.\n\nThe API uses a modified version of the `SessionTranscript` structure that ISO 18013-5 section 9.1.5.1 defines. The API doesn’t use `DeviceEngagementBytes` and `AReaderKeyBytes`, so those elements are `nil`. The handover element contains the `AppleHandover` structure, as the following code example shows:\n\nCompute the SHA256 hash of the session transcript to produce a value that matches the `infoHash` parameter in the HPKE envelope.\n\n### Decrypt the HPKE envelope\n\nDecryption requires the encrypted data parameter from the HPKE envelope, the session transcript you create, and your server’s private key. The private key needs to correspond to the encryption certificate you create in the developer portal. The info parameter is the session transcript. The `enc` parameter is the `pkEm` parameter in the HPKE envelope.\n\nUse the inputs, along with the following HPKE options, to decrypt the encrypted data as the HPKE specification describes:\n\nThe output is a CBOR topics structure that wraps an ISO 18013-5 `mdoc` response structure.\n\nThe identity value contains the `DeviceResponse` structure that ISO 18013-5 section 8.2.2.1.2.2 defines.\n\nAn `mdoc` response contains three sections you use to verify that the response is valid. The issuer-signed items contain the elements your app requests. The issuer authentication structure contains the issuing authority’s signature and the metadata you use to verify the response authenticity. The device authentication structure contains a signature from the iPhone that’s requesting the information.\n\nBefore using the elements, you need to verify they come from the issuer and device you expect.\n\n### Verify the issuer signature\n\nYou use issuer data authentication to verify that the `mdoc` comes from an issuing authority you trust, and to verify it hasn’t been tampered with since issuance. Refer to ISO 18013-5 section 9.1.2 for more information.\n\nThe signed issuer structure includes the data elements you request, and an issuer authentication property that contains the mobile security object (MSO) you use for verification.\n\nFirst, you need to verify that the user information in the response matches the data from the issuing authority. The issuer’s signature includes an array of digests, or hashes, covering every element in the mDL. There can be more digests than you see in the issuer-signed items structure because you only receive signed items for each element your app requests. Compute the digest for each signed item to make sure its digest is present in the issuer authentication.\n\nNext, you use the issuer certificate to verify the issuer signature, and make sure the certificate matches an issuer root certificate your server trusts. The root certificates generally correspond to the issuing authorities of the state IDs you accept. For each state ID you accept, you need to download the root certificate from the corresponding state DMV website.\n\n### Verify the device signature\n\nThe device authentication structure contains the signature of the device that’s requesting the information. Refer to ISO 18013-5 section 9.1.3 for more information.\n\nTwo mechanisms exist for `mdoc` authentication, ECDSA and MAC. The `PassKit` framework only uses ECDSA authentication. The session transcript you use to construct the device authentication structure is the same session transcript you use for decryption. Get the device signing key — represented as a `COSE_Key` — from the MSO.\n\n### Test the implementation\n\nAfter you verify the issuer signature and device signature, you can use the signed items as necessary. To download a sample that contains the files necessary to test your implementation, see [https:\/\/developer.apple.com\/wallet\/resources\/].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/passkit\/verifying-wallet-identity-requests\ncrawled: 2025-12-03T07:04:40Z\n---\n\n# Verifying Wallet identity requests\n\n**Article**\n\nDecrypt and verify an in-app presentment request on your server.\n\n## Overview\n\nYour server needs to decrypt and validate a mobile driver’s license (mDL) document that an app requests. The response contains the user information that you request, plus several security elements your server needs to validate the information to ensure it’s authentic.\n\n### Understand the response structure\n\nThe `PassKit` framework uses the encryption certificate you create in the developer portal, so only your server can decrypt the response. The framework encrypts the data by using hybrid public key encryption (HPKE) that RFC 9180 defines.\n\nThe framework encodes the HPKE envelope and underlying plaintext with concise binary object representation (CBOR) — a binary JSON-like format that RFC 8949 defines. Because the framework encrypts the response data by using HPKE, it doesn’t use session encryption as ISO 18013-5 section 9.1.1 defines. The encryption envelope contains two parts, the encryption metadata and the encrypted data. When you decrypt the data, you get a CBOR-encoded data structure that contains an `mdoc` response object that ISO 18013-5 defines.\n\nIn HPKE, the `info` parameter — a session transcript — isn’t part of the package that you send. The sender and recipient need to build the `info` parameter independently, and need to generate the same value to successfully decrypt it. The following shows the HPKE envelope format:\n\n```other\nHPKEEnvelope = {\n    “algorithm”: tstr,    ; A value that's always “APPLE-HPKE-v1”.\n    “params”: HPKEParams,\n    “data”: bstr          ; The encrypted data.\n}\n\nHPKEParams = {\n    “mode”: uint,         ; A value that's always 0.\n    “pkEm”: bstr,         ; An ephemeral sender public key.\n    “pkRHash”: bstr,      ; The SHA256 hash of the recipient public key.\n    “infoHash”: bstr      ; The SHA256 hash of the HPKE info param.\n}\n```\n\nThe `infoHash` in the HPKE structure is the SHA256 hash of the session transcript during encryption to allow the recipient to verify they’re using the correct `info` parameter.\n\n### Build a session transcript\n\nThe session transcript is a CBOR structure you use during decryption and during validation of the device signature. The session transcript allows you to validate that the response payload belongs to a specific request that your app makes.\n\nNeither the session transcript nor the fields in it are part of the response payload. You need to create the structure on your server. Before you create the session transcript structure, verify that the hash of your public key matches the `pkRHash` property in the HPKE envelope.\n\nThe session transcript structure includes the same [doc:\/\/com.apple.passkit\/documentation\/PassKit\/PKIdentityRequest\/nonce] and merchant identifier you use in your [doc:\/\/com.apple.passkit\/documentation\/PassKit\/PKIdentityRequest], a team identifier, and the SHA256 hash of the public key of the server’s decryption certificate. The session transcript values need to match your app and developer account.\n\nThe API uses a modified version of the `SessionTranscript` structure that ISO 18013-5 section 9.1.5.1 defines. The API doesn’t use `DeviceEngagementBytes` and `AReaderKeyBytes`, so those elements are `nil`. The handover element contains the `AppleHandover` structure, as the following code example shows:\n\n```other\nSessionTranscript = [\n    nil,           ; DeviceEngagementBytes isn't available.\n    nil,           ; EReaderKeyBytes isn't available.        \n    AppleHandover  ; A custom handover structure. \n]\n\nAppleHandover = [\n    “AppleIdentityPresentment_1.0”  ; The version number.\n    nonce,                          ; The app-provided nonce you use.  \n    merchantId,                     ; The merchant ID of the requesting client.  \n    teamID,                         ; The team ID of the requesting client.\n    pkRHash                         ; A SHA256 hash of the recipient public key, the same as in HPKEParams.\n]\n```\n\nCompute the SHA256 hash of the session transcript to produce a value that matches the `infoHash` parameter in the HPKE envelope.\n\n### Decrypt the HPKE envelope\n\nDecryption requires the encrypted data parameter from the HPKE envelope, the session transcript you create, and your server’s private key. The private key needs to correspond to the encryption certificate you create in the developer portal. The info parameter is the session transcript. The `enc` parameter is the `pkEm` parameter in the HPKE envelope.\n\nUse the inputs, along with the following HPKE options, to decrypt the encrypted data as the HPKE specification describes:\n\n\n\nThe output is a CBOR topics structure that wraps an ISO 18013-5 `mdoc` response structure.\n\n```other\nTopics = {\n    “identity”: DeviceResponse      ; A DeviceResponse structure.\n}\n\nDeviceResponse = {\n    \"version\": tstr,                ; A value that's always 1.0.\n    \"documents\": [+Document],       ; A list of documents with a length of 1.\n    \"status\": uint,                 ; A value that's always 0.\n}\n```\n\nThe identity value contains the `DeviceResponse` structure that ISO 18013-5 section 8.2.2.1.2.2 defines.\n\nAn `mdoc` response contains three sections you use to verify that the response is valid. The issuer-signed items contain the elements your app requests. The issuer authentication structure contains the issuing authority’s signature and the metadata you use to verify the response authenticity. The device authentication structure contains a signature from the iPhone that’s requesting the information.\n\n```other\nDocument = {\n    “docType”: DocType,                 ; The document type.\n    “issuerSigned”: IssuerSigned,       ; The data elements the issuer signs.\n    “deviceSigned”: DeviceSigned,       ; The data elements the mdoc signs.\n    ? “errors”: Errors                 \n}\n```\n\nBefore using the elements, you need to verify they come from the issuer and device you expect.\n\n### Verify the issuer signature\n\nYou use issuer data authentication to verify that the `mdoc` comes from an issuing authority you trust, and to verify it hasn’t been tampered with since issuance. Refer to ISO 18013-5 section 9.1.2 for more information.\n\nThe signed issuer structure includes the data elements you request, and an issuer authentication property that contains the mobile security object (MSO) you use for verification.\n\nFirst, you need to verify that the user information in the response matches the data from the issuing authority. The issuer’s signature includes an array of digests, or hashes, covering every element in the mDL. There can be more digests than you see in the issuer-signed items structure because you only receive signed items for each element your app requests. Compute the digest for each signed item to make sure its digest is present in the issuer authentication.\n\nNext, you use the issuer certificate to verify the issuer signature, and make sure the certificate matches an issuer root certificate your server trusts. The root certificates generally correspond to the issuing authorities of the state IDs you accept. For each state ID you accept, you need to download the root certificate from the corresponding state DMV website.\n\n### Verify the device signature\n\nThe device authentication structure contains the signature of the device that’s requesting the information. Refer to ISO 18013-5 section 9.1.3 for more information.\n\nTwo mechanisms exist for `mdoc` authentication, ECDSA and MAC. The `PassKit` framework only uses ECDSA authentication. The session transcript you use to construct the device authentication structure is the same session transcript you use for decryption. Get the device signing key — represented as a `COSE_Key` — from the MSO.\n\n### Test the implementation\n\nAfter you verify the issuer signature and device signature, you can use the signed items as necessary. To download a sample that contains the files necessary to test your implementation, see [https:\/\/developer.apple.com\/wallet\/resources\/].\n\n## Essentials\n\n- **Pass Type IDs Entitlement**: A list of identifiers that specify pass types that your app can access in Wallet.\n- **Merchant IDs Entitlement**: A list of merchant IDs your app uses for Apple Pay support.\n- **com.apple.developer.in-app-identity-presentment**: An entitlement that verifies age or identity.\n- **Requesting identity data from a Wallet pass**: Initiate a request for identity information by prompting a user for permission and decrypting a response payload.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A list of identifiers that specify pass types that your app can access in Wallet.",
          "name" : "Pass Type IDs Entitlement",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.pass-type-identifiers"
        },
        {
          "description" : "A list of merchant IDs your app uses for Apple Pay support.",
          "name" : "Merchant IDs Entitlement",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.in-app-payments"
        },
        {
          "description" : "An entitlement that verifies age or identity.",
          "name" : "com.apple.developer.in-app-identity-presentment",
          "url" : "https:\/\/developer.apple.com\/documentation\/BundleResources\/Entitlements\/com.apple.developer.in-app-identity-presentment"
        },
        {
          "description" : "Initiate a request for identity information by prompting a user for permission and decrypting a response payload.",
          "name" : "Requesting identity data from a Wallet pass",
          "url" : "https:\/\/developer.apple.com\/documentation\/PassKit\/requesting-identity-data-from-a-wallet-pass"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Verifying Wallet identity requests",
  "url" : "https:\/\/developer.apple.com\/documentation\/passkit\/verifying-wallet-identity-requests"
}