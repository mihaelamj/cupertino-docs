{
  "abstract" : "Protect a keychain item with biometric authentication.",
  "codeExamples" : [
    {
      "code" : "let access = SecAccessControlCreateWithFlags(nil, \/\/ Use the default allocator.\n                                             kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,\n                                             .userPresence,\n                                             nil) \/\/ Ignore any error.",
      "language" : "swift"
    },
    {
      "code" : "let context = LAContext()\ncontext.touchIDAuthenticationAllowableReuseDuration = 10",
      "language" : "swift"
    },
    {
      "code" : "let query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrAccount as String: account,\n                            kSecAttrServer as String: server,\n                            kSecAttrAccessControl as String: access as Any,\n                            kSecUseAuthenticationContext as String: context,\n                            kSecValueData as String: password]",
      "language" : "swift"
    },
    {
      "code" : "let status = SecItemAdd(query as CFDictionary, nil)\nguard status == errSecSuccess else { throw KeychainError(status: status) }",
      "language" : "swift"
    },
    {
      "code" : "let context = LAContext()\ncontext.localizedReason = \"Access your password on the keychain\"\nlet query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrServer as String: server,\n                            kSecMatchLimit as String: kSecMatchLimitOne,\n                            kSecReturnAttributes as String: true,\n                            kSecUseAuthenticationContext as String: context,\n                            kSecReturnData as String: true]",
      "language" : "swift"
    }
  ],
  "contentHash" : "7357eaf61984aee968b19f4ce55a035be5431278b4b0dc8d6beda6c1c552541c",
  "crawledAt" : "2025-12-02T15:48:01Z",
  "id" : "E73466E0-3E64-46F9-96E5-25FD7AC3734F",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Local Authentication",
  "overview" : "## Overview\n\nWhen you store a secure item like a password or a private key in the keychain, you dictate the conditions under which that item can be accessed later. Among other things, you can tell keychain services that every time it tries to read the item, it should first seek the user’s permission—for example, by authenticating the user biometrically with Face ID or Touch ID. You rely on both the Security and LocalAuthentication frameworks to enable this behavior.\n\n\n\nTo access keychain items in general, you use keychain services within the Security framework. When authentication is needed, keychain services then relies on the LocalAuthentication framework to present the appropriate interface to the user. The Secure Enclave then carries out the authentication by, for example, testing the user’s finger against the stored fingerprints. The Secure Enclave passes back a pass\/fail result that gates keychain item access. No user space or operating system software ever has access to the underlying authentication data, such as stored fingerprints.\n\nThis sample code project demonstrates how to configure a keychain item when you store it, so that when your app tries to retrieve it later, keychain services only provides the data after a successful user authentication event.\n\n### Set the Face ID Usage Description\n\nIn any project that uses biometrics, include the [https:\/\/developer.apple.com\/library\/content\/documentation\/General\/Reference\/InfoPlistKeyReference\/Articles\/CocoaKeys.html#\/\/apple_ref\/doc\/uid\/TP40009251-SW75] key in your app’s `Info.plist` file. Without this key, the system won’t allow your app to use Face ID. The value for this key is a string that the system presents to the user the first time your app attempts to use Face ID. The string should clearly explain why your app needs access to this authentication mechanism. The system doesn’t require a comparable usage description for Touch ID.\n\n### Create an Access Control\n\nTo create a protected keychain item, begin by creating a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecAccessControl] instance:\n\nThe access control instance contains restrictions along two dimensions: accessibility and authentication. For the first, the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly] setting prevents items from being stored if the device has no passcode. Further, any item already stored in the keychain with this level of accessibility becomes unavailable if the user removes the passcode. Also, because this accessibility ends with `ThisDeviceOnly`, the item isn’t eligible for the iCloud keychain and won’t be included if the user restores a device backup to a new device. This is the most restrictive option, but others are available.\n\nAlong the authentication dimension, the above code uses the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecAccessControlCreateFlags\/userPresence] flag. This tells keychain services to request biometric authentication, or to fall back on the device passcode, whenever the item is later read from the keychain. For more information about creating an access control instance, including the various levels of restrictiveness in each dimension, see [doc:\/\/com.apple.documentation\/documentation\/Security\/restricting-keychain-item-accessibility].\n\n### Optionally, Provide a Customized Context\n\nKeychain services automatically makes use of the LocalAuthentication framework, and in particular uses an [doc:\/\/com.apple.documentation\/documentation\/LocalAuthentication\/LAContext] instance to authenticate the user. You can let keychain services create a new context every time it needs to authenticate. However, if you want to alter the default configuration, you can optionally create a context for it to use instead:\n\nIn this example, you set the context’s [doc:\/\/com.apple.documentation\/documentation\/LocalAuthentication\/LAContext\/touchIDAuthenticationAllowableReuseDuration] parameter to a non-zero value. As a result, any Touch ID authentication that keychain services requires is satisfied by the most recent device unlock event, if it happened within the given number of seconds (up to five minutes). This configuration prevents the user from having to authenticate twice in quick succession: once to get into the device, and immediately again to obtain a keychain item. Note that this grace period applies specifically to device unlock with Touch ID, not keychain retrieval authentications.\n\n### Add the Keychain Item\n\nNext, put all of the attributes together into a query dictionary:\n\nThis query is very much like the one described in [doc:\/\/com.apple.documentation\/documentation\/Security\/adding-a-password-to-the-keychain], with the addition of the access control instance and the context. Then use this query to actually create the item:\n\nTest the return status and handle error conditions in a way that makes sense for your app. For example, you might handle the [doc:\/\/com.apple.documentation\/documentation\/Security\/errSecDuplicateItem] error by attempting to modify the item that already exists. See [doc:\/\/com.apple.documentation\/documentation\/Security\/using-the-keychain-to-manage-user-secrets] for a general discussion of working with keychain items.\n\n### Provide a Prompt When Reading the Item\n\nWhen reading the protected item, you search for it as described in [doc:\/\/com.apple.documentation\/documentation\/Security\/searching-for-keychain-items]. Keychain services works with LocalAuthentication to authenticate the user automatically as needed, using the context you provided, if any. However, there are a few additional query settings you might want to include.\n\nFirst, you can provide a string that the authentication context presents to the user when asking for a TouchID event. Set this string in the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseOperationPrompt] attribute of the keychain item search query:\n\nProviding this prompt lets the user know why you want them to authenticate. The corresponding dialog already names your app, so you don’t have to include that in the prompt.\n\nAdditionally, if you don’t want keychain services to prompt for authentication when you search for items, for example, because you’re conducting a broad search and are willing to simply skip any protected items, you can specify the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseAuthenticationUI] value with the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseAuthenticationUISkip] key.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/LocalAuthentication\/accessing-keychain-items-with-face-id-or-touch-id\ncrawled: 2025-12-02T15:48:01Z\n---\n\n# Accessing Keychain Items with Face ID or Touch ID\n\n**Sample Code**\n\nProtect a keychain item with biometric authentication.\n\n## Overview\n\nWhen you store a secure item like a password or a private key in the keychain, you dictate the conditions under which that item can be accessed later. Among other things, you can tell keychain services that every time it tries to read the item, it should first seek the user’s permission—for example, by authenticating the user biometrically with Face ID or Touch ID. You rely on both the Security and LocalAuthentication frameworks to enable this behavior.\n\n\n\nTo access keychain items in general, you use keychain services within the Security framework. When authentication is needed, keychain services then relies on the LocalAuthentication framework to present the appropriate interface to the user. The Secure Enclave then carries out the authentication by, for example, testing the user’s finger against the stored fingerprints. The Secure Enclave passes back a pass\/fail result that gates keychain item access. No user space or operating system software ever has access to the underlying authentication data, such as stored fingerprints.\n\nThis sample code project demonstrates how to configure a keychain item when you store it, so that when your app tries to retrieve it later, keychain services only provides the data after a successful user authentication event.\n\n### Set the Face ID Usage Description\n\nIn any project that uses biometrics, include the [https:\/\/developer.apple.com\/library\/content\/documentation\/General\/Reference\/InfoPlistKeyReference\/Articles\/CocoaKeys.html#\/\/apple_ref\/doc\/uid\/TP40009251-SW75] key in your app’s `Info.plist` file. Without this key, the system won’t allow your app to use Face ID. The value for this key is a string that the system presents to the user the first time your app attempts to use Face ID. The string should clearly explain why your app needs access to this authentication mechanism. The system doesn’t require a comparable usage description for Touch ID.\n\n### Create an Access Control\n\nTo create a protected keychain item, begin by creating a [doc:\/\/com.apple.documentation\/documentation\/Security\/SecAccessControl] instance:\n\n```swift\nlet access = SecAccessControlCreateWithFlags(nil, \/\/ Use the default allocator.\n                                             kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,\n                                             .userPresence,\n                                             nil) \/\/ Ignore any error.\n```\n\nThe access control instance contains restrictions along two dimensions: accessibility and authentication. For the first, the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly] setting prevents items from being stored if the device has no passcode. Further, any item already stored in the keychain with this level of accessibility becomes unavailable if the user removes the passcode. Also, because this accessibility ends with `ThisDeviceOnly`, the item isn’t eligible for the iCloud keychain and won’t be included if the user restores a device backup to a new device. This is the most restrictive option, but others are available.\n\nAlong the authentication dimension, the above code uses the [doc:\/\/com.apple.documentation\/documentation\/Security\/SecAccessControlCreateFlags\/userPresence] flag. This tells keychain services to request biometric authentication, or to fall back on the device passcode, whenever the item is later read from the keychain. For more information about creating an access control instance, including the various levels of restrictiveness in each dimension, see [doc:\/\/com.apple.documentation\/documentation\/Security\/restricting-keychain-item-accessibility].\n\n### Optionally, Provide a Customized Context\n\nKeychain services automatically makes use of the LocalAuthentication framework, and in particular uses an [doc:\/\/com.apple.documentation\/documentation\/LocalAuthentication\/LAContext] instance to authenticate the user. You can let keychain services create a new context every time it needs to authenticate. However, if you want to alter the default configuration, you can optionally create a context for it to use instead:\n\n```swift\nlet context = LAContext()\ncontext.touchIDAuthenticationAllowableReuseDuration = 10\n```\n\nIn this example, you set the context’s [doc:\/\/com.apple.documentation\/documentation\/LocalAuthentication\/LAContext\/touchIDAuthenticationAllowableReuseDuration] parameter to a non-zero value. As a result, any Touch ID authentication that keychain services requires is satisfied by the most recent device unlock event, if it happened within the given number of seconds (up to five minutes). This configuration prevents the user from having to authenticate twice in quick succession: once to get into the device, and immediately again to obtain a keychain item. Note that this grace period applies specifically to device unlock with Touch ID, not keychain retrieval authentications.\n\n### Add the Keychain Item\n\nNext, put all of the attributes together into a query dictionary:\n\n```swift\nlet query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrAccount as String: account,\n                            kSecAttrServer as String: server,\n                            kSecAttrAccessControl as String: access as Any,\n                            kSecUseAuthenticationContext as String: context,\n                            kSecValueData as String: password]\n```\n\nThis query is very much like the one described in [doc:\/\/com.apple.documentation\/documentation\/Security\/adding-a-password-to-the-keychain], with the addition of the access control instance and the context. Then use this query to actually create the item:\n\n```swift\nlet status = SecItemAdd(query as CFDictionary, nil)\nguard status == errSecSuccess else { throw KeychainError(status: status) }\n```\n\nTest the return status and handle error conditions in a way that makes sense for your app. For example, you might handle the [doc:\/\/com.apple.documentation\/documentation\/Security\/errSecDuplicateItem] error by attempting to modify the item that already exists. See [doc:\/\/com.apple.documentation\/documentation\/Security\/using-the-keychain-to-manage-user-secrets] for a general discussion of working with keychain items.\n\n### Provide a Prompt When Reading the Item\n\nWhen reading the protected item, you search for it as described in [doc:\/\/com.apple.documentation\/documentation\/Security\/searching-for-keychain-items]. Keychain services works with LocalAuthentication to authenticate the user automatically as needed, using the context you provided, if any. However, there are a few additional query settings you might want to include.\n\nFirst, you can provide a string that the authentication context presents to the user when asking for a TouchID event. Set this string in the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseOperationPrompt] attribute of the keychain item search query:\n\n```swift\nlet context = LAContext()\ncontext.localizedReason = \"Access your password on the keychain\"\nlet query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrServer as String: server,\n                            kSecMatchLimit as String: kSecMatchLimitOne,\n                            kSecReturnAttributes as String: true,\n                            kSecUseAuthenticationContext as String: context,\n                            kSecReturnData as String: true]\n```\n\nProviding this prompt lets the user know why you want them to authenticate. The corresponding dialog already names your app, so you don’t have to include that in the prompt.\n\nAdditionally, if you don’t want keychain services to prompt for authentication when you search for items, for example, because you’re conducting a broad search and are willing to simply skip any protected items, you can specify the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseAuthenticationUI] value with the [doc:\/\/com.apple.documentation\/documentation\/Security\/kSecUseAuthenticationUISkip] key.\n\n## Essentials\n\n- **Logging a User into Your App with Face ID or Touch ID**: Supplement your own authentication scheme with biometric authentication, making it easy for users to access sensitive parts of your app.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Supplement your own authentication scheme with biometric authentication, making it easy for users to access sensitive parts of your app.",
          "name" : "Logging a User into Your App with Face ID or Touch ID",
          "url" : "https:\/\/developer.apple.com\/documentation\/LocalAuthentication\/logging-a-user-into-your-app-with-face-id-or-touch-id"
        }
      ],
      "title" : "Essentials"
    }
  ],
  "source" : "appleJSON",
  "title" : "Accessing Keychain Items with Face ID or Touch ID",
  "url" : "https:\/\/developer.apple.com\/documentation\/LocalAuthentication\/accessing-keychain-items-with-face-id-or-touch-id"
}