{
  "abstract" : "Forecast future data points by training a machine learning model using historical data.",
  "codeExamples" : [
    {
      "code" : "var options = CSVReadingOptions()\noptions.floatingPointType = .float\noptions.addDateParseStrategy(\n    Date.ParseStrategy(\n        format: \"\\(year: .defaultDigits)-\\(month: .twoDigits)-\\(day: .twoDigits) \\(hour: .twoDigits(clock: .twentyFourHour, hourCycle: .zeroBased)):\\(minute: .twoDigits):\\(second: .twoDigits))\",\n        locale: Locale(identifier: \"en_US\"),\n        timeZone: TimeZone(abbreviation: \"GMT\")!\n    )\n)\nlet dataFrame = try DataFrame(contentsOfCSVFile: url, columns: [\"Date\", \"Temp\"], types: [\"Date\": .date], options: options)",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Compute the scale of the training portion.\nlet scalerEstimator = ColumnSelector<_, Float>(\n    .include(columnNames: [\"Temp\"]),\n    estimator: OptionalUnwrapper().appending(StandardScaler<Float>())\n)\nlet trainingDataFrame = DataFrame(dataFrame[trainingPortion])\nlet scaler = try await scalerEstimator.fitted(to: trainingDataFrame)\n\n\/\/ Scale the features.\nlet scaledDataFrame = try await scaler.applied(to: dataFrame)\nlet mean = scaler.transformers[\"Temp\"]!.outer.mean\nlet stddev = scaler.transformers[\"Temp\"]!.outer.standardDeviation",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Extract the date features.\nlet dateFeatureExtractor = ColumnSelector<_, Date>(\n    .include(columnNames: [\"Date\"]),\n    transformer: OptionalUnwrapper().appending(\n        DateFeatureExtractor<Float>(features: [.hour, .weekday, .day, .dayOfYear])\n    )\n)\n\/\/ Concatenate the features.\nlet concatenator = ColumnConcatenator<Float>(\n    columnSelection: .all,\n    concatenatedColumnName: \"Features\"\n)\nlet preprocessor = try await dateFeatureExtractor.appending(concatenator).fitted(to: scaledDataFrame)\nlet featuresDataFrame = try await preprocessor.applied(to: dataFrame)",
      "language" : "swift"
    },
    {
      "code" : "let features = featuresDataFrame[\"Features\", MLShapedArray<Float>.self]\n    .filled(with: MLShapedArray<Float>())\nlet annotations = scaledDataFrame[\"Temp\", Float.self]\n    .filled(with: 0.0)\n    .map({ MLShapedArray<Float>(scalars: [Float($0)], shape: [1]) })\n\n\/\/ Create the training, validation, and testing splits.\nlet dayInHours = 24\nlet monthInHours = 30 * dayInHours\nlet yearInHours = 12 * monthInHours\n\nlet trainingPortion = 0 ..< yearInHours\nlet testingPotion = yearInHours + 4 * monthInHours - configuration.inputWindowSize ..< yearInHours + 8 * monthInHours\nlet validationPortion = yearInHours - configuration.inputWindowSize ..< yearInHours + 4 * monthInHours\n\nlet training = zip(features[trainingPortion], annotations[trainingPortion]).map(AnnotatedFeature.init)\nlet validation = zip(features[validationPortion], annotations[validationPortion]).map(AnnotatedFeature.init)\nlet testing = zip(features[testingPotion], annotations[testingPotion]).map(AnnotatedFeature.init)",
      "language" : "swift"
    },
    {
      "code" : "var configuration = LinearTimeSeriesForecasterConfiguration(\n    inputWindowSize: 14 * dayInHours,\n    forecastWindowSize: 4 * dayInHours\n)\nconfiguration.maximumIterationCount = 20\n\nlet estimator = LinearTimeSeriesForecaster<Float>(configuration: configuration)\nlet model = try await estimator.fitted(to: training, validateOn: validation) { event in\n    if let validationLoss = event.metrics[MetricsKey.validationLoss] as? Double {\n        print(\"Validation loss: \\(validationLoss)\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var mseValues = [Double]()\nvar maeValues = [Double]()\nlet predictions = try await model.applied(to: testing.map(\\.feature))\nlet groundTruths = testing.dropFirst(configuration.forecastWindowSize).map(\\.annotation)\nfor (prediction, groundTruth) in zip(predictions, groundTruths) {\n    let mse = meanSquaredError(prediction.scalars, groundTruth.scalars)\n    let mae = meanAbsoluteError(prediction.scalars, groundTruth.scalars)\n    mseValues.append(Double(mse))\n    maeValues.append(Double(mae))\n}\n\nlet mseSum = mseValues.reduce(0, +)\nlet mse = mseSum \/ Double(mseValues.count)\nprint(\"MSE: \\(mse)\")\n\nlet maeSum = maeValues.reduce(0, +)\nlet mae = maeSum \/ Double(maeValues.count)\nprint(\"MAE: \\(mae)\")",
      "language" : "swift"
    },
    {
      "code" : "try model.export(to: URL(filePath: \"forecaster.mlpackage\"))",
      "language" : "swift"
    },
    {
      "code" : "let mlmodel = try MLModel(contentsOf: modelURL)\nlet testFeatures = MLShapedArray<Float>(\n    concatenating: testing[0 ..< 14 * dayInHours].map(\\.feature).map({ $0.expandingShape(at: 0) }),\n    alongAxis: 0\n)\nlet featureValue = MLFeatureValue(shapedArray: testFeatures)\nlet featureProvider = try MLDictionaryFeatureProvider(dictionary: [\"input\": featureValue])\nlet modelOutput = try await mlmodel.prediction(from: featureProvider)\nlet result = modelOutput.featureValue(for: \"output\")!.shapedArrayValue(of: Float.self)!",
      "language" : "swift"
    },
    {
      "code" : "let temperatures = result.scalars.map({ $0 * stddev + mean })\nprint(temperatures)",
      "language" : "swift"
    }
  ],
  "contentHash" : "2d5c0fb32f6c22d91adf743b2fdf826c06528c19adcd367952f25381eba17dbc",
  "crawledAt" : "2025-12-01T09:34:17Z",
  "id" : "0FEDA9B5-EBD0-4234-91FC-532E3C0C4EA3",
  "kind" : "article",
  "module" : "Create ML Components",
  "overview" : "## Overview\n\nSome signals have patterns that repeat over time or have clear trends. For example, the energy consumption of a city has a pattern with peaks in the evening when most people get home. It’s common practice to refer to these signals as time-series data. Other examples of time-series data are:\n\nEven though there are patterns to the data, these patterns aren’t trivial to forecast. You can perform forecasts on these data by training an ML model. For example, you can forecast future energy consumption based on historical consumption.\n\nTraining a time-series forecaster with the Create ML Components framework shares common training behavior with other model types.\n\n### Prepare your training data\n\nThe first step to begin forecasting the energy consumption is to prepare the data. Gather the data as a CSV file, using the following structure:\n\nThe table shows a energy consumption reading for every hour (in GWh). Use the date and time because the consumption depends on the season and the time of day. Parse the date string into a `Date` type by using `CSVReadingOptions` and `Date.ParseStrategy`:\n\nNow that you have a data frame with a `Date` column and a `Float` column, create a preprocessing pipeline. First, scale the training consumptions to have a normal distribution. This makes it easier for the model to learn. Take note of the mean and standard deviation to reverse this operation later.\n\nExtract features from the dates by using `DateFeatureExtractor`. The extractor creates values in the range `-0.5 ... 0.5` and represents the components you select. Concatenate all features into a single column of `MLShapedArray<Float>` values and create a features data frame.\n\nFinally, extract features and annotations, and divide the data into training, validation, and testing sets:\n\n### Build and train a time-series forecaster\n\nAfter preparing your training data, you can create a forecaster. The forecaster configuration takes the input window size and forecast window size. Depending on your task you may want to adjust these values. A larger input window provides more context to the model, but results in a larger model. For this example, set the input window size to 14 days (336 samples) and the forecast window size to 4 days (96 samples).\n\n### Evaluate the model\n\nUse your testing set to evaluate your model. Two useful metrics you use to check a forecaster model are the mean-squared error (MSE) and the mean-absolute error (MAE).\n\n### Export the model\n\nWhen you’re satisfied with the model’s accuracy, export it as a Core ML package:\n\nDeploy the model you export and use Core ML to perform predictions. When you use the model, you need to concatenate the input window samples into a single shaped array. If you provide more than one window of input, the model returns multiple results in a shaped array.\n\nThe model output provides scaled temperatures, so use the mean and standard deviation values to compute the temperatures:",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/creating-a-time-series-forecaster\ncrawled: 2025-12-01T09:34:17Z\n---\n\n# Creating a time-series forecaster\n\n**Article**\n\nForecast future data points by training a machine learning model using historical data.\n\n## Overview\n\nSome signals have patterns that repeat over time or have clear trends. For example, the energy consumption of a city has a pattern with peaks in the evening when most people get home. It’s common practice to refer to these signals as time-series data. Other examples of time-series data are:\n\n- The accelerometer on your phone when performing an action.\n- The temperature of a machine in a factory.\n- Your heart rate during a gym session.\n\nEven though there are patterns to the data, these patterns aren’t trivial to forecast. You can perform forecasts on these data by training an ML model. For example, you can forecast future energy consumption based on historical consumption.\n\nTraining a time-series forecaster with the Create ML Components framework shares common training behavior with other model types.\n\n### Prepare your training data\n\nThe first step to begin forecasting the energy consumption is to prepare the data. Gather the data as a CSV file, using the following structure:\n\n\n\nThe table shows a energy consumption reading for every hour (in GWh). Use the date and time because the consumption depends on the season and the time of day. Parse the date string into a `Date` type by using `CSVReadingOptions` and `Date.ParseStrategy`:\n\n```swift\nvar options = CSVReadingOptions()\noptions.floatingPointType = .float\noptions.addDateParseStrategy(\n    Date.ParseStrategy(\n        format: \"\\(year: .defaultDigits)-\\(month: .twoDigits)-\\(day: .twoDigits) \\(hour: .twoDigits(clock: .twentyFourHour, hourCycle: .zeroBased)):\\(minute: .twoDigits):\\(second: .twoDigits))\",\n        locale: Locale(identifier: \"en_US\"),\n        timeZone: TimeZone(abbreviation: \"GMT\")!\n    )\n)\nlet dataFrame = try DataFrame(contentsOfCSVFile: url, columns: [\"Date\", \"Temp\"], types: [\"Date\": .date], options: options)\n```\n\nNow that you have a data frame with a `Date` column and a `Float` column, create a preprocessing pipeline. First, scale the training consumptions to have a normal distribution. This makes it easier for the model to learn. Take note of the mean and standard deviation to reverse this operation later.\n\n```swift\n\/\/ Compute the scale of the training portion.\nlet scalerEstimator = ColumnSelector<_, Float>(\n    .include(columnNames: [\"Temp\"]),\n    estimator: OptionalUnwrapper().appending(StandardScaler<Float>())\n)\nlet trainingDataFrame = DataFrame(dataFrame[trainingPortion])\nlet scaler = try await scalerEstimator.fitted(to: trainingDataFrame)\n\n\/\/ Scale the features.\nlet scaledDataFrame = try await scaler.applied(to: dataFrame)\nlet mean = scaler.transformers[\"Temp\"]!.outer.mean\nlet stddev = scaler.transformers[\"Temp\"]!.outer.standardDeviation\n```\n\nExtract features from the dates by using `DateFeatureExtractor`. The extractor creates values in the range `-0.5 ... 0.5` and represents the components you select. Concatenate all features into a single column of `MLShapedArray<Float>` values and create a features data frame.\n\n```swift\n\/\/ Extract the date features.\nlet dateFeatureExtractor = ColumnSelector<_, Date>(\n    .include(columnNames: [\"Date\"]),\n    transformer: OptionalUnwrapper().appending(\n        DateFeatureExtractor<Float>(features: [.hour, .weekday, .day, .dayOfYear])\n    )\n)\n\/\/ Concatenate the features.\nlet concatenator = ColumnConcatenator<Float>(\n    columnSelection: .all,\n    concatenatedColumnName: \"Features\"\n)\nlet preprocessor = try await dateFeatureExtractor.appending(concatenator).fitted(to: scaledDataFrame)\nlet featuresDataFrame = try await preprocessor.applied(to: dataFrame)\n```\n\nFinally, extract features and annotations, and divide the data into training, validation, and testing sets:\n\n```swift\nlet features = featuresDataFrame[\"Features\", MLShapedArray<Float>.self]\n    .filled(with: MLShapedArray<Float>())\nlet annotations = scaledDataFrame[\"Temp\", Float.self]\n    .filled(with: 0.0)\n    .map({ MLShapedArray<Float>(scalars: [Float($0)], shape: [1]) })\n\n\/\/ Create the training, validation, and testing splits.\nlet dayInHours = 24\nlet monthInHours = 30 * dayInHours\nlet yearInHours = 12 * monthInHours\n\nlet trainingPortion = 0 ..< yearInHours\nlet testingPotion = yearInHours + 4 * monthInHours - configuration.inputWindowSize ..< yearInHours + 8 * monthInHours\nlet validationPortion = yearInHours - configuration.inputWindowSize ..< yearInHours + 4 * monthInHours\n\nlet training = zip(features[trainingPortion], annotations[trainingPortion]).map(AnnotatedFeature.init)\nlet validation = zip(features[validationPortion], annotations[validationPortion]).map(AnnotatedFeature.init)\nlet testing = zip(features[testingPotion], annotations[testingPotion]).map(AnnotatedFeature.init)\n```\n\n### Build and train a time-series forecaster\n\nAfter preparing your training data, you can create a forecaster. The forecaster configuration takes the input window size and forecast window size. Depending on your task you may want to adjust these values. A larger input window provides more context to the model, but results in a larger model. For this example, set the input window size to 14 days (336 samples) and the forecast window size to 4 days (96 samples).\n\n```swift\nvar configuration = LinearTimeSeriesForecasterConfiguration(\n    inputWindowSize: 14 * dayInHours,\n    forecastWindowSize: 4 * dayInHours\n)\nconfiguration.maximumIterationCount = 20\n\nlet estimator = LinearTimeSeriesForecaster<Float>(configuration: configuration)\nlet model = try await estimator.fitted(to: training, validateOn: validation) { event in\n    if let validationLoss = event.metrics[MetricsKey.validationLoss] as? Double {\n        print(\"Validation loss: \\(validationLoss)\")\n    }\n}\n```\n\n### Evaluate the model\n\nUse your testing set to evaluate your model. Two useful metrics you use to check a forecaster model are the mean-squared error (MSE) and the mean-absolute error (MAE).\n\n```swift\nvar mseValues = [Double]()\nvar maeValues = [Double]()\nlet predictions = try await model.applied(to: testing.map(\\.feature))\nlet groundTruths = testing.dropFirst(configuration.forecastWindowSize).map(\\.annotation)\nfor (prediction, groundTruth) in zip(predictions, groundTruths) {\n    let mse = meanSquaredError(prediction.scalars, groundTruth.scalars)\n    let mae = meanAbsoluteError(prediction.scalars, groundTruth.scalars)\n    mseValues.append(Double(mse))\n    maeValues.append(Double(mae))\n}\n\nlet mseSum = mseValues.reduce(0, +)\nlet mse = mseSum \/ Double(mseValues.count)\nprint(\"MSE: \\(mse)\")\n\nlet maeSum = maeValues.reduce(0, +)\nlet mae = maeSum \/ Double(maeValues.count)\nprint(\"MAE: \\(mae)\")\n```\n\n### Export the model\n\nWhen you’re satisfied with the model’s accuracy, export it as a Core ML package:\n\n```swift\ntry model.export(to: URL(filePath: \"forecaster.mlpackage\"))\n```\n\nDeploy the model you export and use Core ML to perform predictions. When you use the model, you need to concatenate the input window samples into a single shaped array. If you provide more than one window of input, the model returns multiple results in a shaped array.\n\n```swift\nlet mlmodel = try MLModel(contentsOf: modelURL)\nlet testFeatures = MLShapedArray<Float>(\n    concatenating: testing[0 ..< 14 * dayInHours].map(\\.feature).map({ $0.expandingShape(at: 0) }),\n    alongAxis: 0\n)\nlet featureValue = MLFeatureValue(shapedArray: testFeatures)\nlet featureProvider = try MLDictionaryFeatureProvider(dictionary: [\"input\": featureValue])\nlet modelOutput = try await mlmodel.prediction(from: featureProvider)\nlet result = modelOutput.featureValue(for: \"output\")!.shapedArrayValue(of: Float.self)!\n```\n\nThe model output provides scaled temperatures, so use the mean and standard deviation values to compute the temperatures:\n\n```swift\nlet temperatures = result.scalars.map({ $0 * stddev + mean })\nprint(temperatures)\n```\n\n## Time-based components\n\n- **Creating a time-series classifier**: Train a machine learning model to predict the class label of time-series signals.\n- **DateFeatures**: A set of date and time features.\n- **DateFeatureExtractor**: A time and date feature extractor.\n- **LinearTimeSeriesForecaster**: A time-series forecasting estimator.\n- **LinearTimeSeriesForecasterConfiguration**: The configuration for a linear time-series forecaster.\n- **TimeSeriesForecasterBatches**: A sequence of forecaster batches on a time series shaped array.\n- **TimeSeriesForecasterAnnotatedWindows**: A sequence of forecasting windows on a time series shaped array.\n- **TemporalFeature**: A temporal feature contains a segment identifier and a feature value.\n- **TemporalSequence**: Async sequence for temporal features.\n- **TemporalSegmentIdentifier**: Uniquely identifiers a segment of a temporal sequence.\n- **SlidingWindows**: A sequence of windows on a time series shaped array.\n- **SlidingWindowTransformer**: A temporal transformer that groups input elements.\n- **Downsampler**: A temporal transformer that down samples the input stream.\n- **VideoReader**: A video file reader.\n- **TemporalFileSegment**: A URL and a time range identifying a specific segment of a time-based (temporal) file.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Train a machine learning model to predict the class label of time-series signals.",
          "name" : "Creating a time-series classifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/creating-a-time-series-classifier"
        },
        {
          "description" : "A set of date and time features.",
          "name" : "DateFeatures",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/DateFeatures"
        },
        {
          "description" : "A time and date feature extractor.",
          "name" : "DateFeatureExtractor",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/DateFeatureExtractor"
        },
        {
          "description" : "A time-series forecasting estimator.",
          "name" : "LinearTimeSeriesForecaster",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/LinearTimeSeriesForecaster"
        },
        {
          "description" : "The configuration for a linear time-series forecaster.",
          "name" : "LinearTimeSeriesForecasterConfiguration",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/LinearTimeSeriesForecasterConfiguration"
        },
        {
          "description" : "A sequence of forecaster batches on a time series shaped array.",
          "name" : "TimeSeriesForecasterBatches",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TimeSeriesForecasterBatches"
        },
        {
          "description" : "A sequence of forecasting windows on a time series shaped array.",
          "name" : "TimeSeriesForecasterAnnotatedWindows",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TimeSeriesForecasterAnnotatedWindows"
        },
        {
          "description" : "A temporal feature contains a segment identifier and a feature value.",
          "name" : "TemporalFeature",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalFeature"
        },
        {
          "description" : "Async sequence for temporal features.",
          "name" : "TemporalSequence",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalSequence"
        },
        {
          "description" : "Uniquely identifiers a segment of a temporal sequence.",
          "name" : "TemporalSegmentIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalSegmentIdentifier"
        },
        {
          "description" : "A sequence of windows on a time series shaped array.",
          "name" : "SlidingWindows",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/SlidingWindows"
        },
        {
          "description" : "A temporal transformer that groups input elements.",
          "name" : "SlidingWindowTransformer",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/SlidingWindowTransformer"
        },
        {
          "description" : "A temporal transformer that down samples the input stream.",
          "name" : "Downsampler",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/Downsampler"
        },
        {
          "description" : "A video file reader.",
          "name" : "VideoReader",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/VideoReader"
        },
        {
          "description" : "A URL and a time range identifying a specific segment of a time-based (temporal) file.",
          "name" : "TemporalFileSegment",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalFileSegment"
        }
      ],
      "title" : "Time-based components"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a time-series forecaster",
  "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/creating-a-time-series-forecaster"
}