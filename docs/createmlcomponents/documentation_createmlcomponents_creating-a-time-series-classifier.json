{
  "abstract" : "Train a machine learning model to predict the class label of time-series signals.",
  "codeExamples" : [
    {
      "code" : "\/\n    fastball\/\n        recording1.csv\n        recording2.csv\n        ...\n    breaking\/\n        recording3.csv\n        recording4.csv\n        ...\n    changeup\/\n        recording5.csv\n        recording6.csv\n        ..."
    },
    {
      "code" : "let annotatedFiles = try AnnotatedFiles(\n    labeledBySubdirectoryNamesAt: url,\n    type: .commaSeparatedText,\n    continueOnFailure: true\n)",
      "language" : "swift"
    },
    {
      "code" : "var configuration = TimeSeriesClassifierConfiguration()\nconfiguration.maximumSequenceLength = 120",
      "language" : "swift"
    },
    {
      "code" : "let featureColumns = [\n    \"accelerometerAccelerationX(G)\",\n    \"accelerometerAccelerationY(G)\",\n    \"accelerometerAccelerationZ(G)\",\n    \"motionRotationRateX(rad\/s)\",\n    \"motionRotationRateY(rad\/s)\",\n    \"motionRotationRateZ(rad\/s)\"\n]\n\nlet options = CSVReadingOptions(floatingPointType: .float)\nvar result = [AnnotatedFeature<MLShapedArray<Float>, String>]()\nfor file in annotatedFiles {\n    let df = try DataFrame(contentsOfCSVFile: file.feature, columns: featureColumns, options: options)\n    var arrays = [MLShapedArray<Float>]()\n    for featureColumn in featureColumns {\n        let featureValues = df[featureColumn, Float.self].filled(with: .nan)\n        let processedFeatureValues: MLShapedArray<Float>\n        if featureValues.count > configuration.maximumSequenceLength {\n            processedFeatureValues = MLShapedArray(\n                scalars: featureValues[..<configuration.maximumSequenceLength],\n                shape: [configuration.maximumSequenceLength, 1]\n            )\n        } else {\n            processedFeatureValues = MLShapedArray(scalars: featureValues, shape: [featureValues.count, 1])\n        }\n        arrays.append(processedFeatureValues)\n    }\n\n    let feature = MLShapedArray(concatenating: arrays, alongAxis: 1)\n    result.append(AnnotatedFeature(feature: feature, annotation: file.annotation))\n}\n\n\/\/ Shuffle the samples to introduce randomness.\nresult.shuffle()",
      "language" : "swift"
    },
    {
      "code" : "let sampleCount = Double(result.count)\nlet training = result[0 ..< Int(sampleCount * 0.8)]\nlet validation = result[Int(sampleCount * 0.8) ..< Int(sampleCount * 0.9)]\nlet testing = result[Int(sampleCount * 0.9)...]",
      "language" : "swift"
    },
    {
      "code" : "configuration.maximumIterationCount = 5\n\nlet estimator = TimeSeriesClassifier<Float, String>(\n    labels: [\"fastball\", \"breaking\", \"changeup\", \"other\"],\n    configuration: configuration\n)",
      "language" : "swift"
    },
    {
      "code" : "swift\nlet model = try await estimator.fitted(to: training, validateOn: validation) { event in\n    if let trainingAccuracy = event.metrics[MetricsKey.trainingAccuracy] as? Double {\n        print(\"Training accuracy: \\(trainingAccuracy)\")\n    }\n    if let validationAccuracy = event.metrics[MetricsKey.validationAccuracy] as? Double {\n        print(\"Validation accuracy: \\(validationAccuracy)\")\n    }\n}"
    },
    {
      "code" : "let classificationDistributions = try await model.applied(to: testing.map(\\.feature))\nlet predictedLabels = classificationDistributions.map(\\.mostLikelyLabel!)\nlet metrics = ClassificationMetrics(predictedLabels, testing.map(\\.annotation))\n\nprint(\"Accuracy: (metrics.accuracy)\")",
      "language" : "swift"
    },
    {
      "code" : "try model.export(to: URL(filePath: \"classifier.mlpackage\"))",
      "language" : "swift"
    },
    {
      "code" : "let mlmodel = try MLModel(contentsOf: modelURL)\nlet featureValue = MLFeatureValue(shapedArray: features)\nlet featureProvider = try MLDictionaryFeatureProvider(\n    dictionary: [\n        \"input\": featureValue,\n        \"sequenceLength\": MLFeatureValue(shapedArray: MLShapedArray(scalars: [Int32(sequenceLength)], shape: [1])),\n    ]\n)\nlet modelOutput = try await model.prediction(from: featureProvider)\nlet probabilities = modelOutput.featureValue(for: \"labelProbabilities\")!.dictionaryValue as! [String: NSNumber]\nlet label = probabilities.max(by: { $0.value.doubleValue < $1.value.doubleValue })?.key",
      "language" : "swift"
    }
  ],
  "contentHash" : "0f29666ddd429524d547558a86e1cae8ba4cb027de37df0ce12f5d776e566b37",
  "crawledAt" : "2025-12-03T04:44:51Z",
  "id" : "442A9719-274D-4055-9359-B71812D8AE28",
  "kind" : "article",
  "language" : "swift",
  "module" : "Create ML Components",
  "overview" : "## Overview\n\nSome signals have patterns that repeat over time or have clear trends. For example, the accelerometer data from an Apple Watch while the wearer is exercising. It’s common practice to refer to these signals as *time-series data*. Other examples of time-series data are:\n\nEven though there are patterns to the data, these patterns aren’t trivial to classify. You can perform classification on these data by training an ML model. For example, you can classify hand gestures from the accelerometer data from an Apple Watch.\n\nTraining a time-series classifier with the Create ML Components framework shares common training behavior with other model types.\n\n### Prepare your training data\n\nThe first step to begin classifying the throwing movement of a baseball is to prepare the data. The model predicts the baseball throw as fastball, breaking ball, or changeup. Organize the data by using the following directory structure:\n\nEach move contains a subdirectory with CSV files that contains information about a throw.\nEach data file represents one throw and uses the following structure:\n\nThe table shows the acceleration and rotation rate for a thrown baseball. You use these data points to identify the trajectory of the object that helps the model learn the throwing pattern. Each column denotes a feature for the model. Read the training data files from the directory by using `AnnotatedFiles`:\n\nThe recordings you produce may have differing time durations, resulting in a different number of rows for each CSV file you associate with it. Configure the maximum number of samples that the framework classifies by using `maximumSequenceLength`:\n\nThe next step is to process each CSV file into an `AnnotatedFeature` and process the features as an `MLShapedArray` with a label as a String.\n\nFinally, divide the data into training, validation, and testing sets where 80 percent of the data goes into the training set, and 10 percent each for validation and testing.\n\n### Build and train a time-series classifier\n\nAfter preparing your training data, configure your classifier model with the number of training iterations and class labels:\n\nTrain your classifier model and print the training and validation accuracy at every iteration to monitor the progress:\n\n### Evaluate the model\n\nUse your testing set to evaluate your model. Classification provides an accuracy metric with a value between 0 and 1, where 0 represents the least accurate. Look at how accurate it classified your labeled test data to determine whether to export the model.\n\n### Export the model\n\nWhen you’re satisfied with the model’s accuracy, export it as a Core ML package:\n\nDeploy the model you export and use Core ML to perform predictions. When you use the model, create a single shaped array of features with the shape `[sequenceLength, 1]`:.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/creating-a-time-series-classifier\ncrawled: 2025-12-03T04:44:51Z\n---\n\n# Creating a time-series classifier\n\n**Article**\n\nTrain a machine learning model to predict the class label of time-series signals.\n\n## Overview\n\nSome signals have patterns that repeat over time or have clear trends. For example, the accelerometer data from an Apple Watch while the wearer is exercising. It’s common practice to refer to these signals as *time-series data*. Other examples of time-series data are:\n\n- The temperature of a machine in a factory.\n- Your heart rate during a gym session.\n- The audio signal in a song.\n\nEven though there are patterns to the data, these patterns aren’t trivial to classify. You can perform classification on these data by training an ML model. For example, you can classify hand gestures from the accelerometer data from an Apple Watch.\n\nTraining a time-series classifier with the Create ML Components framework shares common training behavior with other model types.\n\n### Prepare your training data\n\nThe first step to begin classifying the throwing movement of a baseball is to prepare the data. The model predicts the baseball throw as fastball, breaking ball, or changeup. Organize the data by using the following directory structure:\n\n```\n\/\n    fastball\/\n        recording1.csv\n        recording2.csv\n        ...\n    breaking\/\n        recording3.csv\n        recording4.csv\n        ...\n    changeup\/\n        recording5.csv\n        recording6.csv\n        ...\n```\n\nEach move contains a subdirectory with CSV files that contains information about a throw.\nEach data file represents one throw and uses the following structure:\n\n\n\nThe table shows the acceleration and rotation rate for a thrown baseball. You use these data points to identify the trajectory of the object that helps the model learn the throwing pattern. Each column denotes a feature for the model. Read the training data files from the directory by using `AnnotatedFiles`:\n\n```swift\nlet annotatedFiles = try AnnotatedFiles(\n    labeledBySubdirectoryNamesAt: url,\n    type: .commaSeparatedText,\n    continueOnFailure: true\n)\n```\n\nThe recordings you produce may have differing time durations, resulting in a different number of rows for each CSV file you associate with it. Configure the maximum number of samples that the framework classifies by using `maximumSequenceLength`:\n\n```swift\nvar configuration = TimeSeriesClassifierConfiguration()\nconfiguration.maximumSequenceLength = 120\n```\n\nThe next step is to process each CSV file into an `AnnotatedFeature` and process the features as an `MLShapedArray` with a label as a String.\n\n```swift\nlet featureColumns = [\n    \"accelerometerAccelerationX(G)\",\n    \"accelerometerAccelerationY(G)\",\n    \"accelerometerAccelerationZ(G)\",\n    \"motionRotationRateX(rad\/s)\",\n    \"motionRotationRateY(rad\/s)\",\n    \"motionRotationRateZ(rad\/s)\"\n]\n\nlet options = CSVReadingOptions(floatingPointType: .float)\nvar result = [AnnotatedFeature<MLShapedArray<Float>, String>]()\nfor file in annotatedFiles {\n    let df = try DataFrame(contentsOfCSVFile: file.feature, columns: featureColumns, options: options)\n    var arrays = [MLShapedArray<Float>]()\n    for featureColumn in featureColumns {\n        let featureValues = df[featureColumn, Float.self].filled(with: .nan)\n        let processedFeatureValues: MLShapedArray<Float>\n        if featureValues.count > configuration.maximumSequenceLength {\n            processedFeatureValues = MLShapedArray(\n                scalars: featureValues[..<configuration.maximumSequenceLength],\n                shape: [configuration.maximumSequenceLength, 1]\n            )\n        } else {\n            processedFeatureValues = MLShapedArray(scalars: featureValues, shape: [featureValues.count, 1])\n        }\n        arrays.append(processedFeatureValues)\n    }\n\n    let feature = MLShapedArray(concatenating: arrays, alongAxis: 1)\n    result.append(AnnotatedFeature(feature: feature, annotation: file.annotation))\n}\n\n\/\/ Shuffle the samples to introduce randomness.\nresult.shuffle()\n```\n\nFinally, divide the data into training, validation, and testing sets where 80 percent of the data goes into the training set, and 10 percent each for validation and testing.\n\n```swift\nlet sampleCount = Double(result.count)\nlet training = result[0 ..< Int(sampleCount * 0.8)]\nlet validation = result[Int(sampleCount * 0.8) ..< Int(sampleCount * 0.9)]\nlet testing = result[Int(sampleCount * 0.9)...]\n```\n\n### Build and train a time-series classifier\n\nAfter preparing your training data, configure your classifier model with the number of training iterations and class labels:\n\n```swift\nconfiguration.maximumIterationCount = 5\n\nlet estimator = TimeSeriesClassifier<Float, String>(\n    labels: [\"fastball\", \"breaking\", \"changeup\", \"other\"],\n    configuration: configuration\n)\n```\n\nTrain your classifier model and print the training and validation accuracy at every iteration to monitor the progress:\n\n```\nswift\nlet model = try await estimator.fitted(to: training, validateOn: validation) { event in\n    if let trainingAccuracy = event.metrics[MetricsKey.trainingAccuracy] as? Double {\n        print(\"Training accuracy: \\(trainingAccuracy)\")\n    }\n    if let validationAccuracy = event.metrics[MetricsKey.validationAccuracy] as? Double {\n        print(\"Validation accuracy: \\(validationAccuracy)\")\n    }\n}\n```\n\n### Evaluate the model\n\nUse your testing set to evaluate your model. Classification provides an accuracy metric with a value between 0 and 1, where 0 represents the least accurate. Look at how accurate it classified your labeled test data to determine whether to export the model.\n\n```swift\nlet classificationDistributions = try await model.applied(to: testing.map(\\.feature))\nlet predictedLabels = classificationDistributions.map(\\.mostLikelyLabel!)\nlet metrics = ClassificationMetrics(predictedLabels, testing.map(\\.annotation))\n\nprint(\"Accuracy: (metrics.accuracy)\")\n```\n\n### Export the model\n\nWhen you’re satisfied with the model’s accuracy, export it as a Core ML package:\n\n```swift\ntry model.export(to: URL(filePath: \"classifier.mlpackage\"))\n```\n\nDeploy the model you export and use Core ML to perform predictions. When you use the model, create a single shaped array of features with the shape `[sequenceLength, 1]`:.\n\n```swift\nlet mlmodel = try MLModel(contentsOf: modelURL)\nlet featureValue = MLFeatureValue(shapedArray: features)\nlet featureProvider = try MLDictionaryFeatureProvider(\n    dictionary: [\n        \"input\": featureValue,\n        \"sequenceLength\": MLFeatureValue(shapedArray: MLShapedArray(scalars: [Int32(sequenceLength)], shape: [1])),\n    ]\n)\nlet modelOutput = try await model.prediction(from: featureProvider)\nlet probabilities = modelOutput.featureValue(for: \"labelProbabilities\")!.dictionaryValue as! [String: NSNumber]\nlet label = probabilities.max(by: { $0.value.doubleValue < $1.value.doubleValue })?.key\n```\n\n## Time-based components\n\n- **Creating a time-series forecaster**: Forecast future data points by training a machine learning model using historical data.\n- **DateFeatures**: A set of date and time features.\n- **DateFeatureExtractor**: A time and date feature extractor.\n- **LinearTimeSeriesForecaster**: A time-series forecasting estimator.\n- **LinearTimeSeriesForecasterConfiguration**: The configuration for a linear time-series forecaster.\n- **TimeSeriesForecasterBatches**: A sequence of forecaster batches on a time series shaped array.\n- **TimeSeriesForecasterAnnotatedWindows**: A sequence of forecasting windows on a time series shaped array.\n- **TemporalFeature**: A temporal feature contains a segment identifier and a feature value.\n- **TemporalSequence**: Async sequence for temporal features.\n- **TemporalSegmentIdentifier**: Uniquely identifiers a segment of a temporal sequence.\n- **SlidingWindows**: A sequence of windows on a time series shaped array.\n- **SlidingWindowTransformer**: A temporal transformer that groups input elements.\n- **Downsampler**: A temporal transformer that down samples the input stream.\n- **VideoReader**: A video file reader.\n- **TemporalFileSegment**: A URL and a time range identifying a specific segment of a time-based (temporal) file.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Forecast future data points by training a machine learning model using historical data.",
          "name" : "Creating a time-series forecaster",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/creating-a-time-series-forecaster"
        },
        {
          "description" : "A set of date and time features.",
          "name" : "DateFeatures",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/DateFeatures"
        },
        {
          "description" : "A time and date feature extractor.",
          "name" : "DateFeatureExtractor",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/DateFeatureExtractor"
        },
        {
          "description" : "A time-series forecasting estimator.",
          "name" : "LinearTimeSeriesForecaster",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/LinearTimeSeriesForecaster"
        },
        {
          "description" : "The configuration for a linear time-series forecaster.",
          "name" : "LinearTimeSeriesForecasterConfiguration",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/LinearTimeSeriesForecasterConfiguration"
        },
        {
          "description" : "A sequence of forecaster batches on a time series shaped array.",
          "name" : "TimeSeriesForecasterBatches",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TimeSeriesForecasterBatches"
        },
        {
          "description" : "A sequence of forecasting windows on a time series shaped array.",
          "name" : "TimeSeriesForecasterAnnotatedWindows",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TimeSeriesForecasterAnnotatedWindows"
        },
        {
          "description" : "A temporal feature contains a segment identifier and a feature value.",
          "name" : "TemporalFeature",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalFeature"
        },
        {
          "description" : "Async sequence for temporal features.",
          "name" : "TemporalSequence",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalSequence"
        },
        {
          "description" : "Uniquely identifiers a segment of a temporal sequence.",
          "name" : "TemporalSegmentIdentifier",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalSegmentIdentifier"
        },
        {
          "description" : "A sequence of windows on a time series shaped array.",
          "name" : "SlidingWindows",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/SlidingWindows"
        },
        {
          "description" : "A temporal transformer that groups input elements.",
          "name" : "SlidingWindowTransformer",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/SlidingWindowTransformer"
        },
        {
          "description" : "A temporal transformer that down samples the input stream.",
          "name" : "Downsampler",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/Downsampler"
        },
        {
          "description" : "A video file reader.",
          "name" : "VideoReader",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/VideoReader"
        },
        {
          "description" : "A URL and a time range identifying a specific segment of a time-based (temporal) file.",
          "name" : "TemporalFileSegment",
          "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/TemporalFileSegment"
        }
      ],
      "title" : "Time-based components"
    }
  ],
  "source" : "appleJSON",
  "title" : "Creating a time-series classifier",
  "url" : "https:\/\/developer.apple.com\/documentation\/CreateMLComponents\/creating-a-time-series-classifier"
}