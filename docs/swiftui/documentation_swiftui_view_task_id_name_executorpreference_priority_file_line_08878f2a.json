{
  "abstract" : "Adds a task to perform before this view appears or when a specified value changes.",
  "codeExamples" : [
    {
      "code" : "Text(status ?? \"Signed Out\")\n    .task(id: server) {\n        let sequence = NotificationCenter.default.notifications(\n            named: .didUpdateStatus,\n            object: server\n        ).compactMap {\n            $0.userInfo?[\"status\"] as? String\n        }\n        for await value in sequence {\n            status = value\n        }\n    }",
      "language" : "swift"
    },
    {
      "code" : "extension NSNotification.Name {\n    static var didUpdateStatus: NSNotification.Name {\n        NSNotification.Name(\"didUpdateStatus\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "let notification = Notification(\n    name: .didUpdateStatus,\n    object: self,\n    userInfo: [\"status\": \"Signed In\"])\nNotificationCenter.default.post(notification)",
      "language" : "swift"
    }
  ],
  "contentHash" : "f8b8e0108418b78f0e2f66e264ac93ff97a1855aed1750c620acfe68bce0a968",
  "crawledAt" : "2025-12-02T17:07:18Z",
  "declaration" : {
    "code" : "nonisolated func task<T>(id: T, name: String? = nil, executorPreference taskExecutor: any TaskExecutor, priority: TaskPriority = .userInitiated, file: String = #fileID, line: Int = #line, _ action: sending @escaping @isolated(any) () async -> Void) -> some View where T : Equatable\n",
    "language" : "swift"
  },
  "id" : "0738CC85-EE48-488B-B733-6DAEAD0AB2B8",
  "kind" : "method",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Return Value\n\nA view that runs the specified action asynchronously before the view appears, or restarts the task when the `id` value changes.\n\n## Discussion\n\nThis method behaves like [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/task(priority:_:)], except that it also cancels and recreates the task when a specified value changes. To detect a change, the modifier tests whether a new value for the `id` parameter equals the previous value. For this to work, the value’s type must conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable] protocol.\n\nFor example, if you define an equatable `Server` type that posts custom notifications whenever its state changes — for example, from *signed out* to *signed in* — you can use the task modifier to update the contents of a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view to reflect the state of the currently selected server:\n\nThis example uses the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter\/notifications(named:object:)] method to create an asynchronous sequence of notifications, given by an [doc:\/\/com.apple.documentation\/documentation\/Swift\/AsyncSequence] instance. The example then maps the notification sequence to a sequence of strings that correspond to values stored with each notification.\n\nElsewhere, the server defines a custom `didUpdateStatus` notification:\n\nWhenever the server status changes, like after the user signs in, the server posts a notification of this custom type:\n\nThe task attached to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view gets and displays the status value from the notification’s user information dictionary. When the user chooses a different server, SwiftUI cancels the task and creates a new one, which then waits for notifications from the new server.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/View\/task(id:name:executorPreference:priority:file:line:_:)\ncrawled: 2025-12-02T17:07:18Z\n---\n\n# task(id:name:executorPreference:priority:file:line:_:)\n\n**Instance Method**\n\nAdds a task to perform before this view appears or when a specified value changes.\n\n## Declaration\n\n```swift\nnonisolated func task<T>(id: T, name: String? = nil, executorPreference taskExecutor: any TaskExecutor, priority: TaskPriority = .userInitiated, file: String = #fileID, line: Int = #line, _ action: sending @escaping @isolated(any) () async -> Void) -> some View where T : Equatable\n\n```\n\n## Parameters\n\n- **id**: The value to observe for changes. The value must conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable] protocol.\n- **name**: Human readable name for the task. A name will be generated if this argument is `nil`.\n- **priority**: The task priority to use when creating the asynchronous task. The default priority is [doc:\/\/com.apple.documentation\/documentation\/Swift\/TaskPriority\/userInitiated].\n- **file**: File name used in default task name. SwiftUI uses the callsite of .task by default.\n- **line**: Line number used in default task name. SwiftUI uses the callsite of .task by default.\n- **action**: A closure that SwiftUI calls as an asynchronous task before the view appears. SwiftUI can automatically cancel the task after the view disappears before the action completes. If the `id` value changes, SwiftUI cancels and restarts the task.\n\n## Return Value\n\nA view that runs the specified action asynchronously before the view appears, or restarts the task when the `id` value changes.\n\n## Discussion\n\nThis method behaves like [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/task(priority:_:)], except that it also cancels and recreates the task when a specified value changes. To detect a change, the modifier tests whether a new value for the `id` parameter equals the previous value. For this to work, the value’s type must conform to the [doc:\/\/com.apple.documentation\/documentation\/Swift\/Equatable] protocol.\n\nFor example, if you define an equatable `Server` type that posts custom notifications whenever its state changes — for example, from *signed out* to *signed in* — you can use the task modifier to update the contents of a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view to reflect the state of the currently selected server:\n\n```swift\nText(status ?? \"Signed Out\")\n    .task(id: server) {\n        let sequence = NotificationCenter.default.notifications(\n            named: .didUpdateStatus,\n            object: server\n        ).compactMap {\n            $0.userInfo?[\"status\"] as? String\n        }\n        for await value in sequence {\n            status = value\n        }\n    }\n```\n\nThis example uses the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NotificationCenter\/notifications(named:object:)] method to create an asynchronous sequence of notifications, given by an [doc:\/\/com.apple.documentation\/documentation\/Swift\/AsyncSequence] instance. The example then maps the notification sequence to a sequence of strings that correspond to values stored with each notification.\n\nElsewhere, the server defines a custom `didUpdateStatus` notification:\n\n```swift\nextension NSNotification.Name {\n    static var didUpdateStatus: NSNotification.Name {\n        NSNotification.Name(\"didUpdateStatus\")\n    }\n}\n```\n\nWhenever the server status changes, like after the user signs in, the server posts a notification of this custom type:\n\n```swift\nlet notification = Notification(\n    name: .didUpdateStatus,\n    object: self,\n    userInfo: [\"status\": \"Signed In\"])\nNotificationCenter.default.post(notification)\n```\n\nThe task attached to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view gets and displays the status value from the notification’s user information dictionary. When the user chooses a different server, SwiftUI cancels the task and creates a new one, which then waits for notifications from the new server.\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "task(id:name:executorPreference:priority:file:line:_:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/View\/task(id:name:executorPreference:priority:file:line:_:)"
}