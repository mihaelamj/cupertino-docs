{
  "abstract" : "Create connections between your app’s data model and views.",
  "codeExamples" : [
    {
      "code" : "@Observable class Book: Identifiable {\n    var title = \"Sample Book Title\"\n    var author = Author()\n    var isAvailable = true\n}",
      "language" : "swift"
    },
    {
      "code" : "struct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var globalBook: Book = Book()\n\nstruct BookView: View {\n    var body: some View {\n        Text(globalBook.title)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Observable class Library {\n    var books: [Book] = [Book(), Book(), Book()]\n    \n    var availableBooksCount: Int {\n        books.filter(\\.isAvailable).count\n    }\n}\n\nstruct LibraryView: View {\n    @Environment(Library.self) private var library\n    \n    var body: some View {\n        NavigationStack {\n            List(library.books) { book in\n                \/\/ ...\n            }\n            .navigationTitle(\"Books available: \\(library.availableBooksCount)\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n    var body: some View {\n        List(books) { book in \n            Text(book.title)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n    var body: some View {\n        List(books) { book in \n            BookView(book: book)\n        }\n    }\n}\n\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Will not update when any property of `book` changes.\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n    \n    var body: some View {\n        LibraryItemView(book: book)\n    }\n}\n\n\/\/ Will not update when any property of `book` changes.\nstruct LibraryItemView: View {\n    var book: Book\n    \n    var body: some View {\n        BookView(book: book)\n    }\n}\n\n\/\/ Will update when `book.title` changes.\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct LibraryItemView: View {\n    var book: Book\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(book.title)\n            Text(\"Written by: \\(book.author.name)\")\n                .font(.caption)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct BookView: View {\n    @State private var book = Book()\n    \n    var body: some View {\n        Text(book.title)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "extension EnvironmentValues {\n    var library: Library {\n        get { self[LibraryKey.self] }\n        set { self[LibraryKey.self] = newValue }\n    }\n}\n\nprivate struct LibraryKey: EnvironmentKey {\n    static let defaultValue: Library = Library()\n}",
      "language" : "swift"
    },
    {
      "code" : "@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(\\.library, library)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct LibraryView: View {\n    @Environment(\\.library) private var library\n\n    var body: some View {\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct LibraryView: View {\n    @Environment(Library.self) private var library\n    \n    var body: some View {\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Environment(Library.self) private var library: Library?",
      "language" : "swift"
    },
    {
      "code" : "struct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        List {\n            Text(book.title)\n            HStack {\n                Text(book.isAvailable ? \"Available for checkout\" : \"Waiting for return\")\n                Spacer()\n                Button(book.isAvailable ? \"Check out\" : \"Return\") {\n                    book.isAvailable.toggle()\n                }\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct BookEditView: View {\n    @Bindable var book: Book\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        VStack() {\n            HStack {\n                Text(\"Title\")\n                TextField(\"Title\", text: $book.title)\n                    .textFieldStyle(.roundedBorder)\n                    .onSubmit {\n                        dismiss()\n                    }\n            }\n            \n            Toggle(isOn: $book.isAvailable) {\n                Text(\"Book is available\")\n            }\n            \n            Button(\"Close\") {\n                dismiss()\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n    var body: some View {\n        List(books) { book in \n            @Bindable var book = book\n            TextField(\"Title\", text: $book.title)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "84f80cf0bf57046a856147faba6c913c1615325676652e51ad143b83ff54feaf",
  "crawledAt" : "2025-12-04T17:23:04Z",
  "id" : "1656D3F2-3866-4BA3-A708-2E92D0DE5317",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nA SwiftUI app can display data that people can change using the app’s user interface (UI). To manage that data, an app creates a data model, which is a custom type that represents the data. A data model provides separation between the data and the views that interact with the data. This separation promotes modularity, improves testability, and helps make it easier to reason about how the app works.\n\nKeeping the model data (that is, an instance of a data model) in sync with what appears on the screen can be challenging, especially when the data appears in multiple views of the UI at the same time.\n\nSwiftUI helps keep your app’s UI up to date with changes made to the data thanks to Observation. With [doc:\/\/com.apple.documentation\/documentation\/Observation], a view in SwiftUI can form dependencies on observable data models and update the UI when data changes.\n\n### Make model data observable\n\nTo make data changes visible to SwiftUI, apply the [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable()] macro to your data model. This macro generates code that adds observation support to your data model at compile time, keeping your data model code focused on the properties that store data. For example, the following code defines a data model for books:\n\n### Observe model data in a view\n\nIn SwiftUI, a view forms a dependency on an observable data model object, such as an instance of `Book`, when the view’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o] property reads a property of the object. If `body` doesn’t read any properties of an observable data model object, the view doesn’t track any dependencies.\n\nWhen a tracked property changes, SwiftUI updates the view. If other properties change that [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o] doesn’t read, the view is unaffected and avoids unnecessary updates. For example, the view in the following code updates only when a book’s `title` changes but not when `author` or `isAvailable` changes:\n\nSwiftUI establishes this dependency tracking even if the view doesn’t store the observable type, such as when using a global property or singleton:\n\nObservation also supports tracking of computed properties when the computed property makes use of an observable property. For instance, the view in the following code updates when the number of available books changes:\n\nWhen a view forms a dependency on a collection of objects, of any collection type, the view tracks changes made to the collection itself. For instance, the view in the following code forms a dependency on `books` because `body` reads it. As changes occur to `books`, such as inserting, deleting, moving, or replacing items in the collection, SwiftUI updates the view.\n\nHowever, `LibraryView` doesn’t form a dependency on the property `title` because the view’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o] doesn’t read it directly. The view stores the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/List] content closure as an `@escaping` closure that SwiftUI calls when lazily creating list items before they appear on the screen. This means that instead of `LibraryView` depending on a book’s `title`, each [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] item of the list depends on `title`. Any changes to a `title` updates only the individual [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] representing the book and not the others.\n\nYou can also share an observable model data object with another view. The receiving view forms a dependency if it reads any properties of the object in its [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o]. For example, in the following code `LibraryView` shares an instance of `Book` with `BookView`, and `BookView` displays the book’s `title`. If the book’s `title` changes, SwiftUI updates only `BookView`, and not `LibraryView`, because only `BookView` reads the `title` property.\n\nIf a view doesn’t have any dependencies, SwiftUI doesn’t update the view when data changes. This approach allows an observable model data object to pass through multiple layers of a view hierarchy without each intermediate view forming a dependency.\n\nHowever, a view that stores a reference to the observable object updates if the reference changes. This happens because the stored reference is part of the view’s value and not because the object is observable. For example, if the reference to book in the following code changes, SwiftUI updates the view:\n\nA view can also form a dependency on an observable data model object accessed through another object. For example, the view in the following code updates when the author’s `name` changes:\n\n### Create the source of truth for model data\n\nTo create and store the source of truth for model data, declare a private variable and initialize it with a instance of an observable data model type. Then wrap it with a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State] property wrapper. For example, the following code stores an instance of the data model type `Book` in the state variable `book`:\n\nBy wrapping the book with [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State], you’re telling SwiftUI to manage the storage of the instance. Each time SwiftUI re-creates `BookView`, it connects the `book` variable to the managed instance, providing the view a single source of truth for the model data.\n\nYou can also create a state object in your top-level [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/App] instance or in one of your app’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Scene] instances. For example, the following code creates an instance of `Library` in the app’s top-level structure:\n\n### Share model data throughout a view hierarchy\n\nIf you have a data model object, like `Library`, that you want to share throughout your app, you can either:\n\nPassing model data to each view is convenient when you have a shallow view hierarchy; for example, when a view doesn’t share the object with its subviews. However, you usually don’t know if a view needs to pass the object to subviews, and you may not know if a subview deep inside the layers of the hierarchy needs the model data.\n\nTo share model data throughout a view hierarchy without needing to pass it to each view, add the model data to the view’s environment. You can add the data to the environment using either [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:_:)] or the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:)] modifier, passing in the model data.\n\nBefore you can use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:_:)] modifier, you need to create a custom [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/EnvironmentKey]. Then extend [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/EnvironmentValues] to include a custom environment property that gets and sets the value for the custom key. For instance, the following code creates an environment key and property for `library`:\n\nWith the custom environment key and property in place, a view can add model data to its environment. For example, `LibraryView` adds the source of truth for a `Library` instance to its environment using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:_:)] modifier:\n\nTo retrieve the `Library` instance from the environment, a view defines a local variable that stores a reference to the instance, and then wraps the variable with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Environment] property wrapper, passing in the key path to the custom environment value.\n\nYou can also store model data directly in the environment without defining a custom environment value by using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:)] modifier. For instance, the following code adds a `Library` instance to the environment using this modifier:\n\nTo retrieve the instance from the environment, another view defines a local variable to store the instance and wraps it with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Environment] property wrapper. But instead of providing a key path to the environment value, you can provide the model data type, as shown in the following code:\n\nBy default, reading an object from the environment returns a non-optional object when using the object type as the key. This default behavior assumes that a view in the current hierarchy previously stored a non-optional instance of the type using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:)] modifier. If a view attempts to retrieve an object using its type and that object isn’t in the environment, SwiftUI throws exception.\n\nIn cases where there is no guarantee that an object is in the environment, retrieve an optional version of the object as shown in the following code. If the object isn’t available the environment, SwiftUI returns `nil` instead of throwing an exception.\n\n### Change model data in a view\n\nIn most apps, people can change data that the app presents. When data changes, any views that display the data should update to reflect the changed data. With Observation in SwiftUI, a view can support data changes without using property wrappers or bindings. For example, the following toggles the `isAvailable` property of a book in the action closure of a button:\n\nHowever, there may be times when a view expects a binding before it can change the value of a mutable property. To provide a binding, wrap the model data with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Bindable] property wrapper. For example, the following code wraps the `book` variable with `@Bindable`. Then it uses a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/TextField] to change the `title` property of a book, and a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Toggle] to change the `isAvailable` property, using the `$` syntax to pass a binding to each property.\n\nYou can use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Bindable] property wrapper on properties and variables to an [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable] object. This includes global variables, properties that exist outside of SwiftUI types, or even local variables. For example, you can create a `@Bindable` variable within a view’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o]:\n\nThe `@Bindable` variable `book` provides a binding that connects [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/TextField] to the `title` property of a book so that a person can make changes directly to the model data.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swiftui\/managing-model-data-in-your-app\ncrawled: 2025-12-04T17:23:04Z\n---\n\n# Managing model data in your app\n\n**Sample Code**\n\nCreate connections between your app’s data model and views.\n\n## Overview\n\nA SwiftUI app can display data that people can change using the app’s user interface (UI). To manage that data, an app creates a data model, which is a custom type that represents the data. A data model provides separation between the data and the views that interact with the data. This separation promotes modularity, improves testability, and helps make it easier to reason about how the app works.\n\nKeeping the model data (that is, an instance of a data model) in sync with what appears on the screen can be challenging, especially when the data appears in multiple views of the UI at the same time.\n\nSwiftUI helps keep your app’s UI up to date with changes made to the data thanks to Observation. With [doc:\/\/com.apple.documentation\/documentation\/Observation], a view in SwiftUI can form dependencies on observable data models and update the UI when data changes.\n\n\n\n### Make model data observable\n\nTo make data changes visible to SwiftUI, apply the [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable()] macro to your data model. This macro generates code that adds observation support to your data model at compile time, keeping your data model code focused on the properties that store data. For example, the following code defines a data model for books:\n\n```swift\n@Observable class Book: Identifiable {\n    var title = \"Sample Book Title\"\n    var author = Author()\n    var isAvailable = true\n}\n```\n\n\n\n### Observe model data in a view\n\nIn SwiftUI, a view forms a dependency on an observable data model object, such as an instance of `Book`, when the view’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o] property reads a property of the object. If `body` doesn’t read any properties of an observable data model object, the view doesn’t track any dependencies.\n\nWhen a tracked property changes, SwiftUI updates the view. If other properties change that [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o] doesn’t read, the view is unaffected and avoids unnecessary updates. For example, the view in the following code updates only when a book’s `title` changes but not when `author` or `isAvailable` changes:\n\n```swift\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n```\n\nSwiftUI establishes this dependency tracking even if the view doesn’t store the observable type, such as when using a global property or singleton:\n\n```swift\nvar globalBook: Book = Book()\n\nstruct BookView: View {\n    var body: some View {\n        Text(globalBook.title)\n    }\n}\n```\n\nObservation also supports tracking of computed properties when the computed property makes use of an observable property. For instance, the view in the following code updates when the number of available books changes:\n\n```swift\n@Observable class Library {\n    var books: [Book] = [Book(), Book(), Book()]\n    \n    var availableBooksCount: Int {\n        books.filter(\\.isAvailable).count\n    }\n}\n\nstruct LibraryView: View {\n    @Environment(Library.self) private var library\n    \n    var body: some View {\n        NavigationStack {\n            List(library.books) { book in\n                \/\/ ...\n            }\n            .navigationTitle(\"Books available: \\(library.availableBooksCount)\")\n        }\n    }\n}\n```\n\nWhen a view forms a dependency on a collection of objects, of any collection type, the view tracks changes made to the collection itself. For instance, the view in the following code forms a dependency on `books` because `body` reads it. As changes occur to `books`, such as inserting, deleting, moving, or replacing items in the collection, SwiftUI updates the view.\n\n```swift\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n    var body: some View {\n        List(books) { book in \n            Text(book.title)\n        }\n    }\n}\n```\n\nHowever, `LibraryView` doesn’t form a dependency on the property `title` because the view’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o] doesn’t read it directly. The view stores the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/List] content closure as an `@escaping` closure that SwiftUI calls when lazily creating list items before they appear on the screen. This means that instead of `LibraryView` depending on a book’s `title`, each [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] item of the list depends on `title`. Any changes to a `title` updates only the individual [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] representing the book and not the others.\n\n\n\nYou can also share an observable model data object with another view. The receiving view forms a dependency if it reads any properties of the object in its [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o]. For example, in the following code `LibraryView` shares an instance of `Book` with `BookView`, and `BookView` displays the book’s `title`. If the book’s `title` changes, SwiftUI updates only `BookView`, and not `LibraryView`, because only `BookView` reads the `title` property.\n\n```swift\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n    var body: some View {\n        List(books) { book in \n            BookView(book: book)\n        }\n    }\n}\n\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n```\n\nIf a view doesn’t have any dependencies, SwiftUI doesn’t update the view when data changes. This approach allows an observable model data object to pass through multiple layers of a view hierarchy without each intermediate view forming a dependency.\n\n```swift\n\/\/ Will not update when any property of `book` changes.\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n    \n    var body: some View {\n        LibraryItemView(book: book)\n    }\n}\n\n\/\/ Will not update when any property of `book` changes.\nstruct LibraryItemView: View {\n    var book: Book\n    \n    var body: some View {\n        BookView(book: book)\n    }\n}\n\n\/\/ Will update when `book.title` changes.\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n```\n\nHowever, a view that stores a reference to the observable object updates if the reference changes. This happens because the stored reference is part of the view’s value and not because the object is observable. For example, if the reference to book in the following code changes, SwiftUI updates the view:\n\n```swift\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        \/\/ ...\n    }\n}\n```\n\nA view can also form a dependency on an observable data model object accessed through another object. For example, the view in the following code updates when the author’s `name` changes:\n\n```swift\nstruct LibraryItemView: View {\n    var book: Book\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(book.title)\n            Text(\"Written by: \\(book.author.name)\")\n                .font(.caption)\n        }\n    }\n}\n```\n\n### Create the source of truth for model data\n\nTo create and store the source of truth for model data, declare a private variable and initialize it with a instance of an observable data model type. Then wrap it with a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State] property wrapper. For example, the following code stores an instance of the data model type `Book` in the state variable `book`:\n\n```swift\nstruct BookView: View {\n    @State private var book = Book()\n    \n    var body: some View {\n        Text(book.title)\n    }\n}\n```\n\nBy wrapping the book with [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State], you’re telling SwiftUI to manage the storage of the instance. Each time SwiftUI re-creates `BookView`, it connects the `book` variable to the managed instance, providing the view a single source of truth for the model data.\n\nYou can also create a state object in your top-level [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/App] instance or in one of your app’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Scene] instances. For example, the following code creates an instance of `Library` in the app’s top-level structure:\n\n```swift\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}\n```\n\n### Share model data throughout a view hierarchy\n\nIf you have a data model object, like `Library`, that you want to share throughout your app, you can either:\n\n- pass the data model object to each view in the view hierarchy; or\n- add the data model object to the view’s environment\n\nPassing model data to each view is convenient when you have a shallow view hierarchy; for example, when a view doesn’t share the object with its subviews. However, you usually don’t know if a view needs to pass the object to subviews, and you may not know if a subview deep inside the layers of the hierarchy needs the model data.\n\nTo share model data throughout a view hierarchy without needing to pass it to each view, add the model data to the view’s environment. You can add the data to the environment using either [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:_:)] or the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:)] modifier, passing in the model data.\n\nBefore you can use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:_:)] modifier, you need to create a custom [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/EnvironmentKey]. Then extend [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/EnvironmentValues] to include a custom environment property that gets and sets the value for the custom key. For instance, the following code creates an environment key and property for `library`:\n\n```swift\nextension EnvironmentValues {\n    var library: Library {\n        get { self[LibraryKey.self] }\n        set { self[LibraryKey.self] = newValue }\n    }\n}\n\nprivate struct LibraryKey: EnvironmentKey {\n    static let defaultValue: Library = Library()\n}\n```\n\nWith the custom environment key and property in place, a view can add model data to its environment. For example, `LibraryView` adds the source of truth for a `Library` instance to its environment using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:_:)] modifier:\n\n```swift\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(\\.library, library)\n        }\n    }\n}\n```\n\nTo retrieve the `Library` instance from the environment, a view defines a local variable that stores a reference to the instance, and then wraps the variable with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Environment] property wrapper, passing in the key path to the custom environment value.\n\n```swift\nstruct LibraryView: View {\n    @Environment(\\.library) private var library\n\n    var body: some View {\n        \/\/ ...\n    }\n}\n```\n\nYou can also store model data directly in the environment without defining a custom environment value by using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:)] modifier. For instance, the following code adds a `Library` instance to the environment using this modifier:\n\n```swift\n@main\nstruct BookReaderApp: App {\n    @State private var library = Library()\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(library)\n        }\n    }\n}\n```\n\nTo retrieve the instance from the environment, another view defines a local variable to store the instance and wraps it with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Environment] property wrapper. But instead of providing a key path to the environment value, you can provide the model data type, as shown in the following code:\n\n```swift\nstruct LibraryView: View {\n    @Environment(Library.self) private var library\n    \n    var body: some View {\n        \/\/ ...\n    }\n}\n```\n\nBy default, reading an object from the environment returns a non-optional object when using the object type as the key. This default behavior assumes that a view in the current hierarchy previously stored a non-optional instance of the type using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environment(_:)] modifier. If a view attempts to retrieve an object using its type and that object isn’t in the environment, SwiftUI throws exception.\n\nIn cases where there is no guarantee that an object is in the environment, retrieve an optional version of the object as shown in the following code. If the object isn’t available the environment, SwiftUI returns `nil` instead of throwing an exception.\n\n```swift\n@Environment(Library.self) private var library: Library?\n```\n\n### Change model data in a view\n\nIn most apps, people can change data that the app presents. When data changes, any views that display the data should update to reflect the changed data. With Observation in SwiftUI, a view can support data changes without using property wrappers or bindings. For example, the following toggles the `isAvailable` property of a book in the action closure of a button:\n\n```swift\nstruct BookView: View {\n    var book: Book\n    \n    var body: some View {\n        List {\n            Text(book.title)\n            HStack {\n                Text(book.isAvailable ? \"Available for checkout\" : \"Waiting for return\")\n                Spacer()\n                Button(book.isAvailable ? \"Check out\" : \"Return\") {\n                    book.isAvailable.toggle()\n                }\n            }\n        }\n    }\n}\n```\n\nHowever, there may be times when a view expects a binding before it can change the value of a mutable property. To provide a binding, wrap the model data with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Bindable] property wrapper. For example, the following code wraps the `book` variable with `@Bindable`. Then it uses a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/TextField] to change the `title` property of a book, and a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Toggle] to change the `isAvailable` property, using the `$` syntax to pass a binding to each property.\n\n```swift\nstruct BookEditView: View {\n    @Bindable var book: Book\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        VStack() {\n            HStack {\n                Text(\"Title\")\n                TextField(\"Title\", text: $book.title)\n                    .textFieldStyle(.roundedBorder)\n                    .onSubmit {\n                        dismiss()\n                    }\n            }\n            \n            Toggle(isOn: $book.isAvailable) {\n                Text(\"Book is available\")\n            }\n            \n            Button(\"Close\") {\n                dismiss()\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}\n```\n\nYou can use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Bindable] property wrapper on properties and variables to an [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable] object. This includes global variables, properties that exist outside of SwiftUI types, or even local variables. For example, you can create a `@Bindable` variable within a view’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/body-8kl5o]:\n\n```swift\nstruct LibraryView: View {\n    @State private var books = [Book(), Book(), Book()]\n\n    var body: some View {\n        List(books) { book in \n            @Bindable var book = book\n            TextField(\"Title\", text: $book.title)\n        }\n    }\n}\n```\n\nThe `@Bindable` variable `book` provides a binding that connects [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/TextField] to the `title` property of a book so that a person can make changes directly to the model data.\n\n## Creating model data\n\n- **Migrating from the Observable Object protocol to the Observable macro**: Update your existing app to leverage the benefits of Observation in Swift.\n- **Observable()**: Defines and implements conformance of the Observable protocol.\n- **Monitoring data changes in your app**: Show changes to data in your app’s user interface by using observable objects.\n- **StateObject**: A property wrapper type that instantiates an observable object.\n- **ObservedObject**: A property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes.\n- **ObservableObject**: A type of object with a publisher that emits before the object has changed.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Update your existing app to leverage the benefits of Observation in Swift.",
          "name" : "Migrating from the Observable Object protocol to the Observable macro",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Migrating-from-the-observable-object-protocol-to-the-observable-macro"
        },
        {
          "description" : "Defines and implements conformance of the Observable protocol.",
          "name" : "Observable()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Observation\/Observable()"
        },
        {
          "description" : "Show changes to data in your app’s user interface by using observable objects.",
          "name" : "Monitoring data changes in your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Monitoring-model-data-changes-in-your-app"
        },
        {
          "description" : "A property wrapper type that instantiates an observable object.",
          "name" : "StateObject",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/StateObject"
        },
        {
          "description" : "A property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes.",
          "name" : "ObservedObject",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/ObservedObject"
        },
        {
          "description" : "A type of object with a publisher that emits before the object has changed.",
          "name" : "ObservableObject",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/ObservableObject"
        }
      ],
      "title" : "Creating model data"
    }
  ],
  "source" : "appleJSON",
  "title" : "Managing model data in your app",
  "url" : "https:\/\/developer.apple.com\/documentation\/swiftui\/managing-model-data-in-your-app"
}