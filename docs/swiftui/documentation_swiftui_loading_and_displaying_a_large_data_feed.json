{
  "abstract" : "Consume data in the background, and lower memory use by batching imports and preventing duplicate records.",
  "codeExamples" : [
    {
      "code" : "let container = NSPersistentContainer(name: \"Earthquakes\")",
      "language" : "swift"
    },
    {
      "code" : "let taskContext = container.newBackgroundContext()",
      "language" : "swift"
    },
    {
      "code" : "try await taskContext.perform {",
      "language" : "swift"
    },
    {
      "code" : "let batchInsertRequest = self.newBatchInsertRequest(with: propertiesList)\nif let fetchResult = try? taskContext.execute(batchInsertRequest),\n   let batchInsertResult = fetchResult as? NSBatchInsertResult,\n   let success = batchInsertResult.result as? Bool, success {\n    return\n}",
      "language" : "swift"
    },
    {
      "code" : "description.setOption(true as NSNumber,\n                      forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)",
      "language" : "swift"
    },
    {
      "code" : "description.setOption(true as NSNumber,\n                      forKey: NSPersistentHistoryTrackingKey)",
      "language" : "swift"
    },
    {
      "code" : "let changeRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: lastToken)\nlet historyResult = try taskContext.execute(changeRequest) as? NSPersistentHistoryResult\nif let history = historyResult?.result as? [NSPersistentHistoryTransaction] {\n    return history\n}",
      "language" : "swift"
    },
    {
      "code" : "let viewContext = container.viewContext\nlet tokens = await viewContext.perform {\n    history.map { (transaction: NSPersistentHistoryTransaction) -> NSPersistentHistoryToken in\n        viewContext.mergeChanges(fromContextDidSave: transaction.objectIDNotification())\n        return transaction.token\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "container.viewContext.automaticallyMergesChangesFromParent = false",
      "language" : "swift"
    },
    {
      "code" : "comma, separated, properties",
      "language" : "swift"
    },
    {
      "code" : "code",
      "language" : "swift"
    },
    {
      "code" : "container.viewContext.automaticallyMergesChangesFromParent = false",
      "language" : "swift"
    }
  ],
  "contentHash" : "bcb1cd85f8a3b747f7ea4fc39ebbeae548eec84f08f032d8e378fbcc733c97ce",
  "crawledAt" : "2025-12-02T15:29:00Z",
  "id" : "DF31ABF4-2440-49DA-8633-B3AE60652537",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nThis sample creates an app that shows a list of earthquakes recorded in the United States in the past 30 days by consuming a U. S. Geological Survey (USGS) real-time data feed.\n\nTo load the USGS JSON feed, perform either of the following:\n\nThe app will load the requested data on the default delegate queue of [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession], which is an operation queue that runs in the background. After the feed is downloaded and the session data task completes, the app continues working on this queue to import the large number of feed elements to the store without blocking the main queue.\n\n### Import data in the background\n\nTo import data in the background, apps may use one or two managed object contexts. The sample uses two ([doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext]) instances:\n\nBoth contexts are connected to the same [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer\/persistentStoreCoordinator]. This configuration is more efficient than using a nested context.\n\nThe sample creates a main queue context by setting up a Core Data stack using [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer], which initializes a main queue context in its [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer\/viewContext] property.\n\nCreate a private queue context by calling the persistent container’s [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer\/newBackgroundContext()] method.\n\nWhen the feed download finishes, the sample uses the task context to consume the feed in the background. In Core Data, every queue-based context has its own serial queue, and apps must serialize the tasks that manipulate the context with the queue by wrapping the code with a [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/perform(_:)] — with or without the `await` keyword — or [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/performAndWait(_:)-ypye] closure.\n\nFor more information about working with concurrency, see [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext#Concurrency].\n\nTo efficiently handle large data sets, the sample uses [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] which accesses the store directly — without interacting with the context, triggering any key value observation, or allocating managed objects. The closure-style initializer of [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] allows apps to provide one record at a time when Core Data calls the `dictionaryHandler` closure, which helps apps keep their memory footprint low because they do not need to prepare a buffer for all records.\n\n### Merge changes and update the user interface\n\nBecause [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] bypasses the context and doesn’t trigger a [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContextDidSaveNotification] notification, apps that need to update the UI with the changes have two options:\n\nThis sample uses persistent store remote change notifications and persistent history tracking to update the UI, because:\n\nEnable remote change notifications for a persistent store by setting the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentStoreRemoteChangeNotificationPostOptionKey] option on the store description to `true`.\n\nEnable persistent history tracking for a persistent store by setting the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentHistoryTrackingKey] option to `true` as well.\n\nWhenever changes occur within a persistent store, including writes by other processes, the store posts a remote change notification. When the sample receives the notification, it fetches the persistent history transactions and changes occurring after a given token. After the persistent history change request retrieves the history, the sample merges each transaction’s [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentHistoryTransaction\/objectIDNotification()] into the view context via [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/mergeChanges(fromContextDidSave:)].\n\nAfter executing each [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] or [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchDeleteRequest], the sample dispatches any UI updates back to the main queue, to render them in SwiftUI.\n\nAfter merging changes from the last transaction, the sample needs to store the token in memory or on disk, to use it in subsequent persistent history change requests.\n\n### Work in batches to lower memory footprint\n\nWhen apps fetch or create objects in a context, Core Data caches the object to avoid a round trip to the store file when the app uses those objects again. However, that approach grows the memory footprint of an app as it processes more and more objects, and can eventually lead to low-memory warnings or app termination on iOS. [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] doesn’t obviously increase an app’s memory footprint because it doesn’t load data into memory.\n\nThe sample sets the `viewContext`’s [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/automaticallyMergesChangesFromParent] property to `false` to prevent Core Data from automatically merging changes every time the background context is saved.\n\n### Prevent duplicate data in the store\n\nEvery time the sample app reloads the JSON feed, the parsed data contains all earthquake records for the past month, so it can have many duplicates of already imported data. To avoid creating duplicate records, the app constrains an attribute, or combination of attributes, to be unique across all instances.\n\nThe `code` attribute uniquely identifies an earthquake record, so constraining the `Quake` entity on `code` ensures that no two stored records have the same `code` value.\n\nSelect the `Quake` entity in the data model editor. In the data model inspector, add a new constraint by clicking the + button under the Constraints list. A constraint placeholder appears.\n\nDouble-click the placeholder to edit it. Enter the name of the attribute, or comma-separated list of attributes, to serve as unique constraints on the entity.\n\nWhen saving a new record, the store now checks whether any record already exists with the same value for the constrained attribute. In the case of a conflict, an [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSMergeByPropertyObjectTrumpMergePolicy] policy comes into play, and the new record overwrites all fields in the existing record.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/swiftui\/loading_and_displaying_a_large_data_feed\ncrawled: 2025-12-02T15:29:00Z\n---\n\n# Loading and displaying a large data feed\n\n**Sample Code**\n\nConsume data in the background, and lower memory use by batching imports and preventing duplicate records.\n\n## Overview\n\nThis sample creates an app that shows a list of earthquakes recorded in the United States in the past 30 days by consuming a U. S. Geological Survey (USGS) real-time data feed.\n\nTo load the USGS JSON feed, perform either of the following:\n\n- On iOS, pull to refresh the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/List].\n- On both iOS and macOS, press the refresh button (⌘R).\n\nThe app will load the requested data on the default delegate queue of [doc:\/\/com.apple.documentation\/documentation\/Foundation\/URLSession], which is an operation queue that runs in the background. After the feed is downloaded and the session data task completes, the app continues working on this queue to import the large number of feed elements to the store without blocking the main queue.\n\n\n\n### Import data in the background\n\nTo import data in the background, apps may use one or two managed object contexts. The sample uses two ([doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext]) instances:\n\n- A main queue context to provide data to the user interface.\n- A private queue context to perform the import on a background queue.\n\nBoth contexts are connected to the same [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer\/persistentStoreCoordinator]. This configuration is more efficient than using a nested context.\n\nThe sample creates a main queue context by setting up a Core Data stack using [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer], which initializes a main queue context in its [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer\/viewContext] property.\n\n```swift\nlet container = NSPersistentContainer(name: \"Earthquakes\")\n```\n\nCreate a private queue context by calling the persistent container’s [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentContainer\/newBackgroundContext()] method.\n\n```swift\nlet taskContext = container.newBackgroundContext()\n```\n\nWhen the feed download finishes, the sample uses the task context to consume the feed in the background. In Core Data, every queue-based context has its own serial queue, and apps must serialize the tasks that manipulate the context with the queue by wrapping the code with a [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/perform(_:)] — with or without the `await` keyword — or [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/performAndWait(_:)-ypye] closure.\n\n```swift\ntry await taskContext.perform {\n```\n\nFor more information about working with concurrency, see [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext#Concurrency].\n\nTo efficiently handle large data sets, the sample uses [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] which accesses the store directly — without interacting with the context, triggering any key value observation, or allocating managed objects. The closure-style initializer of [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] allows apps to provide one record at a time when Core Data calls the `dictionaryHandler` closure, which helps apps keep their memory footprint low because they do not need to prepare a buffer for all records.\n\n```swift\nlet batchInsertRequest = self.newBatchInsertRequest(with: propertiesList)\nif let fetchResult = try? taskContext.execute(batchInsertRequest),\n   let batchInsertResult = fetchResult as? NSBatchInsertResult,\n   let success = batchInsertResult.result as? Bool, success {\n    return\n}\n```\n\n### Merge changes and update the user interface\n\nBecause [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] bypasses the context and doesn’t trigger a [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContextDidSaveNotification] notification, apps that need to update the UI with the changes have two options:\n\n- Extract the relevant changes by parsing the store’s [doc:\/\/com.apple.documentation\/documentation\/CoreData\/persistent-history], then merge them into the view context. For more information on persistent history tracking, see [doc:\/\/com.apple.documentation\/documentation\/CoreData\/consuming-relevant-store-changes].\n- Re-fetch the data from the store. However, if the view context is pinned to a query generation, the context will need to be reset before fetching data. For more information on query generations, see [doc:\/\/com.apple.documentation\/documentation\/CoreData\/accessing-data-when-the-store-changes].\n\nThis sample uses persistent store remote change notifications and persistent history tracking to update the UI, because:\n\n- The data model contains a single entity, so all changes are relevant to the `List` and do not require parsing specific changes within the history.\n- [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/FetchRequest] fetches and retrieves results directly from the store, and the `List` refreshes its contents automatically.\n- SwiftUI is only concerned about the view context, so `QuakesProvider` observes the [doc:\/\/com.apple.documentation\/documentation\/Foundation\/NSNotification\/Name-swift.struct\/NSPersistentStoreRemoteChange] notification to merge changes from the background context, performing the batch operations, into the view context.\n\nEnable remote change notifications for a persistent store by setting the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentStoreRemoteChangeNotificationPostOptionKey] option on the store description to `true`.\n\n```swift\ndescription.setOption(true as NSNumber,\n                      forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)\n```\n\nEnable persistent history tracking for a persistent store by setting the [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentHistoryTrackingKey] option to `true` as well.\n\n```swift\ndescription.setOption(true as NSNumber,\n                      forKey: NSPersistentHistoryTrackingKey)\n```\n\nWhenever changes occur within a persistent store, including writes by other processes, the store posts a remote change notification. When the sample receives the notification, it fetches the persistent history transactions and changes occurring after a given token. After the persistent history change request retrieves the history, the sample merges each transaction’s [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSPersistentHistoryTransaction\/objectIDNotification()] into the view context via [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/mergeChanges(fromContextDidSave:)].\n\n```swift\nlet changeRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: lastToken)\nlet historyResult = try taskContext.execute(changeRequest) as? NSPersistentHistoryResult\nif let history = historyResult?.result as? [NSPersistentHistoryTransaction] {\n    return history\n}\n```\n\nAfter executing each [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] or [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchDeleteRequest], the sample dispatches any UI updates back to the main queue, to render them in SwiftUI.\n\n```swift\nlet viewContext = container.viewContext\nlet tokens = await viewContext.perform {\n    history.map { (transaction: NSPersistentHistoryTransaction) -> NSPersistentHistoryToken in\n        viewContext.mergeChanges(fromContextDidSave: transaction.objectIDNotification())\n        return transaction.token\n    }\n}\n```\n\nAfter merging changes from the last transaction, the sample needs to store the token in memory or on disk, to use it in subsequent persistent history change requests.\n\n### Work in batches to lower memory footprint\n\nWhen apps fetch or create objects in a context, Core Data caches the object to avoid a round trip to the store file when the app uses those objects again. However, that approach grows the memory footprint of an app as it processes more and more objects, and can eventually lead to low-memory warnings or app termination on iOS. [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSBatchInsertRequest] doesn’t obviously increase an app’s memory footprint because it doesn’t load data into memory.\n\n\n\nThe sample sets the `viewContext`’s [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSManagedObjectContext\/automaticallyMergesChangesFromParent] property to `false` to prevent Core Data from automatically merging changes every time the background context is saved.\n\n```swift\ncontainer.viewContext.automaticallyMergesChangesFromParent = false\n```\n\n### Prevent duplicate data in the store\n\nEvery time the sample app reloads the JSON feed, the parsed data contains all earthquake records for the past month, so it can have many duplicates of already imported data. To avoid creating duplicate records, the app constrains an attribute, or combination of attributes, to be unique across all instances.\n\nThe `code` attribute uniquely identifies an earthquake record, so constraining the `Quake` entity on `code` ensures that no two stored records have the same `code` value.\n\nSelect the `Quake` entity in the data model editor. In the data model inspector, add a new constraint by clicking the + button under the Constraints list. A constraint placeholder appears.\n\n```swift\ncomma, separated, properties\n```\n\nDouble-click the placeholder to edit it. Enter the name of the attribute, or comma-separated list of attributes, to serve as unique constraints on the entity.\n\n```swift\ncode\n```\n\nWhen saving a new record, the store now checks whether any record already exists with the same value for the constrained attribute. In the case of a conflict, an [doc:\/\/com.apple.documentation\/documentation\/CoreData\/NSMergeByPropertyObjectTrumpMergePolicy] policy comes into play, and the new record overwrites all fields in the existing record.\n\n```swift\ncontainer.viewContext.automaticallyMergesChangesFromParent = false\n```\n\n## Accessing Core Data\n\n- **managedObjectContext**\n- **FetchRequest**: A property wrapper type that retrieves entities from a Core Data persistent store.\n- **FetchedResults**: A collection of results retrieved from a Core Data store.\n- **SectionedFetchRequest**: A property wrapper type that retrieves entities, grouped into sections, from a Core Data persistent store.\n- **SectionedFetchResults**: A collection of results retrieved from a Core Data persistent store, grouped into sections.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "",
          "name" : "managedObjectContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/EnvironmentValues\/managedObjectContext"
        },
        {
          "description" : "A property wrapper type that retrieves entities from a Core Data persistent store.",
          "name" : "FetchRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/FetchRequest"
        },
        {
          "description" : "A collection of results retrieved from a Core Data store.",
          "name" : "FetchedResults",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/FetchedResults"
        },
        {
          "description" : "A property wrapper type that retrieves entities, grouped into sections, from a Core Data persistent store.",
          "name" : "SectionedFetchRequest",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/SectionedFetchRequest"
        },
        {
          "description" : "A collection of results retrieved from a Core Data persistent store, grouped into sections.",
          "name" : "SectionedFetchResults",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/SectionedFetchResults"
        }
      ],
      "title" : "Accessing Core Data"
    }
  ],
  "source" : "appleJSON",
  "title" : "Loading and displaying a large data feed",
  "url" : "https:\/\/developer.apple.com\/documentation\/swiftui\/loading_and_displaying_a_large_data_feed"
}