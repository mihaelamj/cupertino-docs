{
  "abstract" : "Attempts to asynchronously compile a shader function, to minimize the chance of stalling when it is first used for rendering.",
  "codeExamples" : [
    {
      "code" : "Task {\n    let shader = ShaderLibrary.example(.color(.clear), .float(0))\n    try! await shader.compile(as: .shapeStyle)\n}",
      "language" : "swift"
    },
    {
      "code" : "Circle().fill(\n    ShaderLibrary.example(.color(.orange), .float(32)))",
      "language" : "swift"
    }
  ],
  "contentHash" : "29ef3ac6ee0e76a9947d31980456b9eea7a830b512e6f6ffc4d341238137aa8f",
  "crawledAt" : "2025-12-01T11:23:11Z",
  "declaration" : {
    "code" : "func compile(as type: Shader.UsageType) async throws",
    "language" : "swift"
  },
  "id" : "C1617ED5-DC03-4E8A-A6F1-1ABE09C7E42A",
  "kind" : "method",
  "module" : "SwiftUI",
  "overview" : "## Discussion\n\nBefore being available for rendering each shader must be compiled for the current GPU. By default this happens on first use, but that may cause that frame to be delayed waiting for the compiler, i.e. cause a visible “glitch” in animations.\n\nCalling this method for each shader before it’s first used allows the necessary compilation to happen ahead of time, eliminating the delay on the first actual use (provided `compile()` completes before the first use of the shader).\n\nFor compilation to be successful the specified usage type must match how the shader is eventually used to render, and its current argument values must match the types of the arguments used when rendering (however array and data sizes may be empty).\n\nFor example, to compile a fill shader asynchronously when your app launches:\n\nHere the MSL shader function `example` takes two uniform arguments: a color and a numeric value. The placeholder values are replaced with actual values when using the shader, in this case to fill a circle:",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/Shader\/compile(as:)\ncrawled: 2025-12-01T11:23:11Z\n---\n\n# compile(as:)\n\n**Instance Method**\n\nAttempts to asynchronously compile a shader function, to minimize the chance of stalling when it is first used for rendering.\n\n## Declaration\n\n```swift\nfunc compile(as type: Shader.UsageType) async throws\n```\n\n## Parameters\n\n- **type**: How the shader will eventually be used.\n\n## Discussion\n\nBefore being available for rendering each shader must be compiled for the current GPU. By default this happens on first use, but that may cause that frame to be delayed waiting for the compiler, i.e. cause a visible “glitch” in animations.\n\nCalling this method for each shader before it’s first used allows the necessary compilation to happen ahead of time, eliminating the delay on the first actual use (provided `compile()` completes before the first use of the shader).\n\nFor compilation to be successful the specified usage type must match how the shader is eventually used to render, and its current argument values must match the types of the arguments used when rendering (however array and data sizes may be empty).\n\nFor example, to compile a fill shader asynchronously when your app launches:\n\n```swift\nTask {\n    let shader = ShaderLibrary.example(.color(.clear), .float(0))\n    try! await shader.compile(as: .shapeStyle)\n}\n```\n\nHere the MSL shader function `example` takes two uniform arguments: a color and a numeric value. The placeholder values are replaced with actual values when using the shader, in this case to fill a circle:\n\n```swift\nCircle().fill(\n    ShaderLibrary.example(.color(.orange), .float(32)))\n```\n\n\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "compile(as:)",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Shader\/compile(as:)"
}