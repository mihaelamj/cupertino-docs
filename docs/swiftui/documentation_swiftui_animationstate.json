{
  "abstract" : "A container that stores the state for a custom animation.",
  "codeExamples" : [
    {
      "code" : "private struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    static var defaultValue: Self { .init() }\n}\n\nextension AnimationContext {\n    fileprivate var pausableState: PausableState<Value> {\n        get { state[PausableState<Value>.self] }\n        set { state[PausableState<Value>.self] = newValue }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    var paused = false\n    var pauseTime: TimeInterval = 0.0\n\n    static var defaultValue: Self { .init() }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct PausableAnimation: CustomAnimation {\n    let base: Animation\n\n    func animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V? where V : VectorArithmetic {\n        let paused = context.environment.animationPaused\n\n        let pausableState = context.pausableState\n        var pauseTime = pausableState.pauseTime\n        if pausableState.paused != paused {\n            pauseTime = time - pauseTime\n            context.pausableState = PausableState(paused: paused, pauseTime: pauseTime)\n        }\n\n        let effectiveTime = paused ? pauseTime : time - pauseTime\n        let result = base.animate(value: value, time: effectiveTime, context: &context)\n        return result\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private struct TargetState<Value: VectorArithmetic>: AnimationStateKey {\n    var timeDelta = 0.0\n    var valueDelta = Value.zero\n    var secondaryState: AnimationState<Value>? = .init()\n\n    static var defaultValue: Self { .init() }\n}\n\nextension AnimationContext {\n    fileprivate var targetState: TargetState<Value> {\n        get { state[TargetState<Value>.self] }\n        set { state[TargetState<Value>.self] = newValue }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct TargetAnimation: CustomAnimation {\n    var base: Animation\n    var secondary: Animation\n\n    func animate<V: VectorArithmetic>(value: V, time: Double, context: inout AnimationContext<V>) -> V? {\n        var targetValue = value\n        if let secondaryState = context.targetState.secondaryState {\n            var secondaryContext = context\n            secondaryContext.state = secondaryState\n            let secondaryValue = value - context.targetState.valueDelta\n            let result = secondary.animate(\n                value: secondaryValue, time: time - context.targetState.timeDelta,\n                context: &secondaryContext)\n            if let result = result {\n                context.targetState.secondaryState = secondaryContext.state\n                targetValue = result + context.targetState.valueDelta\n            } else {\n                context.targetState.secondaryState = nil\n            }\n        }\n        let result = base.animate(value: targetValue, time: time, context: &context)\n        if let result = result {\n            targetValue = result\n        } else if context.targetState.secondaryState == nil {\n            return nil\n        }\n        return targetValue\n}\n\n    func shouldMerge<V: VectorArithmetic>(previous: Animation, value: V, time: Double, context: inout AnimationContext<V>) -> Bool {\n        guard let previous = previous.base as? Self else { return false }\n        var secondaryContext = context\n        if let secondaryState = context.targetState.secondaryState {\n            secondaryContext.state = secondaryState\n            context.targetState.valueDelta = secondary.animate(\n                value: value, time: time - context.targetState.timeDelta,\n                context: &secondaryContext) ?? value\n        } else {\n            context.targetState.valueDelta = value\n        }\n        \/\/ Reset the target each time a merge occurs.\n        context.targetState.secondaryState = .init()\n        context.targetState.timeDelta = time\n        return base.shouldMerge(\n            previous: previous.base, value: value, time: time,\n            context: &context)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "91e06645560efdc3972a5437d0916e33a1c7be1340938f8443d3b1dc31a84304",
  "crawledAt" : "2025-12-02T17:15:23Z",
  "declaration" : {
    "code" : "struct AnimationState<Value> where Value : VectorArithmetic",
    "language" : "swift"
  },
  "id" : "45E574D9-1EEE-4B65-BD48-0F1B99A3F200",
  "kind" : "struct",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nAn [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext] uses this type to store state for a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/CustomAnimation]. To retrieve the stored state of a context, you can use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext\/state] property. However, a more convenient way to access the animation state is to define an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationStateKey] and extend [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext] with a computed property that gets and sets the animation state, as shown in the following code:\n\nWhen creating an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationStateKey], it’s convenient to define the state values that your custom animation needs. For example, the following code adds the properties `paused` and `pauseTime` to the `PausableState` animation state key:\n\nTo access the pausable state in a `PausableAnimation`, the follow code calls `pausableState` instead of using the context’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext\/state] property. And because the animation state key `PausableState` defines properties for state values, the custom animation can read and write those values.\n\n### Storing state for secondary animations\n\nA custom animation can also use `AnimationState` to store the state of a secondary animation. For example, the following code creates an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationStateKey] that includes the property `secondaryState`, which a custom animation can use to store other state:\n\nThe custom animation `TargetAnimation` uses `TargetState` to store state data in `secondaryState` for another animation that runs as part of the target animation.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/AnimationState\ncrawled: 2025-12-02T17:15:23Z\n---\n\n# AnimationState\n\n**Structure**\n\nA container that stores the state for a custom animation.\n\n## Declaration\n\n```swift\nstruct AnimationState<Value> where Value : VectorArithmetic\n```\n\n## Overview\n\nAn [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext] uses this type to store state for a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/CustomAnimation]. To retrieve the stored state of a context, you can use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext\/state] property. However, a more convenient way to access the animation state is to define an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationStateKey] and extend [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext] with a computed property that gets and sets the animation state, as shown in the following code:\n\n```swift\nprivate struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    static var defaultValue: Self { .init() }\n}\n\nextension AnimationContext {\n    fileprivate var pausableState: PausableState<Value> {\n        get { state[PausableState<Value>.self] }\n        set { state[PausableState<Value>.self] = newValue }\n    }\n}\n```\n\nWhen creating an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationStateKey], it’s convenient to define the state values that your custom animation needs. For example, the following code adds the properties `paused` and `pauseTime` to the `PausableState` animation state key:\n\n```swift\nprivate struct PausableState<Value: VectorArithmetic>: AnimationStateKey {\n    var paused = false\n    var pauseTime: TimeInterval = 0.0\n\n    static var defaultValue: Self { .init() }\n}\n```\n\nTo access the pausable state in a `PausableAnimation`, the follow code calls `pausableState` instead of using the context’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationContext\/state] property. And because the animation state key `PausableState` defines properties for state values, the custom animation can read and write those values.\n\n```swift\nstruct PausableAnimation: CustomAnimation {\n    let base: Animation\n\n    func animate<V>(value: V, time: TimeInterval, context: inout AnimationContext<V>) -> V? where V : VectorArithmetic {\n        let paused = context.environment.animationPaused\n\n        let pausableState = context.pausableState\n        var pauseTime = pausableState.pauseTime\n        if pausableState.paused != paused {\n            pauseTime = time - pauseTime\n            context.pausableState = PausableState(paused: paused, pauseTime: pauseTime)\n        }\n\n        let effectiveTime = paused ? pauseTime : time - pauseTime\n        let result = base.animate(value: value, time: effectiveTime, context: &context)\n        return result\n    }\n}\n```\n\n### Storing state for secondary animations\n\nA custom animation can also use `AnimationState` to store the state of a secondary animation. For example, the following code creates an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnimationStateKey] that includes the property `secondaryState`, which a custom animation can use to store other state:\n\n```swift\nprivate struct TargetState<Value: VectorArithmetic>: AnimationStateKey {\n    var timeDelta = 0.0\n    var valueDelta = Value.zero\n    var secondaryState: AnimationState<Value>? = .init()\n\n    static var defaultValue: Self { .init() }\n}\n\nextension AnimationContext {\n    fileprivate var targetState: TargetState<Value> {\n        get { state[TargetState<Value>.self] }\n        set { state[TargetState<Value>.self] = newValue }\n    }\n}\n```\n\nThe custom animation `TargetAnimation` uses `TargetState` to store state data in `secondaryState` for another animation that runs as part of the target animation.\n\n```swift\nstruct TargetAnimation: CustomAnimation {\n    var base: Animation\n    var secondary: Animation\n\n    func animate<V: VectorArithmetic>(value: V, time: Double, context: inout AnimationContext<V>) -> V? {\n        var targetValue = value\n        if let secondaryState = context.targetState.secondaryState {\n            var secondaryContext = context\n            secondaryContext.state = secondaryState\n            let secondaryValue = value - context.targetState.valueDelta\n            let result = secondary.animate(\n                value: secondaryValue, time: time - context.targetState.timeDelta,\n                context: &secondaryContext)\n            if let result = result {\n                context.targetState.secondaryState = secondaryContext.state\n                targetValue = result + context.targetState.valueDelta\n            } else {\n                context.targetState.secondaryState = nil\n            }\n        }\n        let result = base.animate(value: targetValue, time: time, context: &context)\n        if let result = result {\n            targetValue = result\n        } else if context.targetState.secondaryState == nil {\n            return nil\n        }\n        return targetValue\n}\n\n    func shouldMerge<V: VectorArithmetic>(previous: Animation, value: V, time: Double, context: inout AnimationContext<V>) -> Bool {\n        guard let previous = previous.base as? Self else { return false }\n        var secondaryContext = context\n        if let secondaryState = context.targetState.secondaryState {\n            secondaryContext.state = secondaryState\n            context.targetState.valueDelta = secondary.animate(\n                value: value, time: time - context.targetState.timeDelta,\n                context: &secondaryContext) ?? value\n        } else {\n            context.targetState.valueDelta = value\n        }\n        \/\/ Reset the target each time a merge occurs.\n        context.targetState.secondaryState = .init()\n        context.targetState.timeDelta = time\n        return base.shouldMerge(\n            previous: previous.base, value: value, time: time,\n            context: &context)\n    }\n}\n```\n\n## Creating animation state\n\n- **init()**: Create an empty state container.\n\n## Accessing custom keys\n\n- **subscript(_:)**: Accesses the state for a custom key.\n\n## Creating custom animations\n\n- **CustomAnimation**: A type that defines how an animatable value changes over time.\n- **AnimationContext**: Contextual values that a custom animation can use to manage state and access a view’s environment.\n- **AnimationStateKey**: A key for accessing animation state values.\n- **UnitCurve**: A  function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed.\n- **Spring**: A representation of a spring’s motion.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create an empty state container.",
          "name" : "init()",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/AnimationState\/init()"
        }
      ],
      "title" : "Creating animation state"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Accesses the state for a custom key.",
          "name" : "subscript(_:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/AnimationState\/subscript(_:)"
        }
      ],
      "title" : "Accessing custom keys"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that defines how an animatable value changes over time.",
          "name" : "CustomAnimation",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/CustomAnimation"
        },
        {
          "description" : "Contextual values that a custom animation can use to manage state and access a view’s environment.",
          "name" : "AnimationContext",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/AnimationContext"
        },
        {
          "description" : "A key for accessing animation state values.",
          "name" : "AnimationStateKey",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/AnimationStateKey"
        },
        {
          "description" : "A  function defined by a two-dimensional curve that maps an input progress in the range [0,1] to an output progress that is also in the range [0,1]. By changing the shape of the curve, the effective speed of an animation or other interpolation can be changed.",
          "name" : "UnitCurve",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/UnitCurve"
        },
        {
          "description" : "A representation of a spring’s motion.",
          "name" : "Spring",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Spring"
        }
      ],
      "title" : "Creating custom animations"
    }
  ],
  "source" : "appleJSON",
  "title" : "AnimationState",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/AnimationState"
}