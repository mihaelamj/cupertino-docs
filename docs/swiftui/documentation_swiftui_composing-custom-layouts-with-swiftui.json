{
  "abstract" : "Arrange views in your app’s interface using layout tools that SwiftUI provides.",
  "codeExamples" : [
    {
      "code" : "Grid(alignment: .leading) {\n    ForEach(model.pets) { pet in\n        GridRow {\n            Text(pet.type)\n            ProgressView(\n                value: Double(pet.votes),\n                total: Double(max(1, model.totalVotes))) \/\/ Avoid dividing by zero.\n            Text(\"\\(pet.votes)\")\n                .gridColumnAlignment(.trailing)\n        }\n\n        Divider()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func sizeThatFits(\n    proposal: ProposedViewSize,\n    subviews: Subviews,\n    cache: inout Void\n) -> CGSize {\n    guard !subviews.isEmpty else { return .zero }\n\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n    let totalSpacing = spacing.reduce(0) { $0 + $1 }\n\n    return CGSize(\n        width: maxSize.width * CGFloat(subviews.count) + totalSpacing,\n        height: maxSize.height)\n}",
      "language" : "swift"
    },
    {
      "code" : "func placeSubviews(\n    in bounds: CGRect,\n    proposal: ProposedViewSize,\n    subviews: Subviews,\n    cache: inout Void\n) {\n    guard !subviews.isEmpty else { return }\n\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n\n    let placementProposal = ProposedViewSize(width: maxSize.width, height: maxSize.height)\n    var nextX = bounds.minX + maxSize.width \/ 2\n\n    for index in subviews.indices {\n        subviews[index].place(\n            at: CGPoint(x: nextX, y: bounds.midY),\n            anchor: .center,\n            proposal: placementProposal)\n        nextX += maxSize.width + spacing[index]\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "ViewThatFits { \/\/ Choose the first view that fits.\n    MyEqualWidthHStack { \/\/ Arrange horizontally if it fits...\n        Buttons()\n    }\n    MyEqualWidthVStack { \/\/ ...or vertically, otherwise.\n        Buttons()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CacheData {\n    let maxSize: CGSize\n    let spacing: [CGFloat]\n    let totalSpacing: CGFloat\n}",
      "language" : "swift"
    },
    {
      "code" : "func makeCache(subviews: Subviews) -> CacheData {\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n    let totalSpacing = spacing.reduce(0) { $0 + $1 }\n\n    return CacheData(\n        maxSize: maxSize,\n        spacing: spacing,\n        totalSpacing: totalSpacing)\n}",
      "language" : "swift"
    },
    {
      "code" : "let maxSize = cache.maxSize\nlet spacing = cache.spacing",
      "language" : "swift"
    },
    {
      "code" : "proposal.replacingUnspecifiedDimensions()",
      "language" : "swift"
    },
    {
      "code" : "for (index, subview) in subviews.enumerated() {\n    \/\/ Find a vector with an appropriate size and rotation.\n    var point = CGPoint(x: 0, y: -radius)\n        .applying(CGAffineTransform(\n            rotationAngle: angle * Double(index) + offset))\n\n    \/\/ Shift the vector to the middle of the region.\n    point.x += bounds.midX\n    point.y += bounds.midY\n\n    \/\/ Place the subview.\n    subview.place(at: point, anchor: .center, proposal: .unspecified)\n}",
      "language" : "swift"
    },
    {
      "code" : "let layout = model.isAllWayTie ? AnyLayout(HStackLayout()) : AnyLayout(MyRadialLayout())\n\nPodium()\n    .overlay(alignment: .top) {\n        layout {\n            ForEach(model.pets) { pet in\n                Avatar(pet: pet)\n                    .rank(model.rank(pet))\n            }\n        }\n        .animation(.default, value: model.pets)\n    }",
      "language" : "swift"
    }
  ],
  "contentHash" : "3cea148149f444f9db114ca93058ea33a6eccc27db31b6ee127edc84a27b983e",
  "crawledAt" : "2025-12-02T15:32:47Z",
  "id" : "D58C0FDA-28A4-403D-B963-CB995DA83434",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nThis sample app demonstrates many of the layout tools that SwiftUI provides by building an interface that enables people to vote for their favorite kind of pet. The app offers buttons to vote for a specific pet type, and displays the vote counts and relative rankings of the various contenders on a leaderboard. It also shows avatars for the pets, arranged in a way that reflects the current rankings.\n\n\n\n### Arrange views in two dimensions with a grid\n\nTo draw a leaderboard in the middle of the display that shows vote counts and percentages, the sample uses a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Grid] view.\n\n\n\nThe grid contains a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/GridRow] inside a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ForEach], where each view in the row creates a column cell. So the first view appears in the first column, the second in the second column, and so on. Because the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Divider] appears outside of a grid row instance, it creates a row that spans the width of the grid.\n\nThe sample initializes the grid with leading-edge alignment, which applies to every cell in the grid. Meanwhile, the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/gridColumnAlignment(_:)] view modifier that appears on the vote count cell overrides the alignment of cells in that column to use trailing-edge alignment.\n\n### Create a custom equal-width layout\n\nThe app offers buttons for voting at the bottom of the interface.\n\n\n\nTo ensure the buttons all have the same width, but are no wider than the widest button text, the app creates a custom layout container type that conforms to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout] protocol. The equal-width horizontal stack (`MyEqualWidthHStack`) measures the ideal sizes of all its subviews, and offers the widest ideal size to each subview.\n\nThe custom stack implements the protocol’s two required methods. First, [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/sizeThatFits(proposal:subviews:cache:)] reports the container’s size, given a set of subviews.\n\nThis method combines the largest size in each dimension with the horizontal spacing between subviews to find the container’s total size. Then, [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/placeSubviews(in:proposal:subviews:cache:)] tells each of the subviews where to appear within the layout’s bounds.\n\nThe method creates a single size proposal for the subviews, and then uses that, along with a point that changes for each subview, to arrange the buttons in a horizontal line with default spacing.\n\n### Choose the view that fits\n\nThe size of the voting buttons depends on the width of the text they contain. For people that speak another language or that use a larger text size, the horizontally arranged buttons might not fit in the display. So the app uses [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ViewThatFits] to let SwiftUI choose between a horizontal and a vertical arrangement of the buttons for the one that fits in the available space.\n\nTo ensure that the buttons maintain their equal-width property when arranged vertically, the app uses a custom equal-width vertical stack (`MyEqualWidthVStack`) that’s very similar to the horizontal version.\n\n### Improve layout efficiency with a cache\n\nThe methods of the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout] protocol take a bidirectional `cache` parameter. The cache provides access to optional storage that’s shared among all the methods of a particular layout instance. To demonstrate the use of a cache, the sample app’s equal-width vertical layout creates storage to share size and spacing calculations between its [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/sizeThatFits(proposal:subviews:cache:)] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/placeSubviews(in:proposal:subviews:cache:)] implementations.\n\nFirst, the layout defines a `CacheData` type for the storage.\n\nIt then implements the protocol’s optional [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/makeCache(subviews:)] method to do the calculations for a set of subviews, returning a value of the type defined above.\n\nIf the subviews change, SwiftUI calls the layout’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/updateCache(_:subviews:)] method. The default implementation of that method calls [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/makeCache(subviews:)] again, which recalculates the data. Then the `sizeThatFits(proposal:subviews:cache:)` and `placeSubviews(in:proposal:subviews:cache:)` methods make use of their `cache` parameter to retrieve the data. For example, `placeSubviews(in:proposal:subviews:cache:)` reads the size and the spacing array from the cache.\n\nContrast this with the equal-width horizontal stack, which doesn’t use a cache, and instead calculates the size and spacing information every time it needs that information.\n\n### Create a custom radial layout with an offset\n\nTo display the pet avatars in a circle, the app defines a radial layout (`MyRadialLayout`).\n\n\n\nLike other custom layouts, this layout needs the two required methods. For [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/sizeThatFits(proposal:subviews:cache:)], the layout fills the available space by returning whatever size its container proposes.\n\nThe app uses the proposal’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ProposedViewSize\/replacingUnspecifiedDimensions(by:)] method to convert the proposal into a concrete size. Then, to place subviews, the layout rotates a vector, translates the vector to the middle of the placement region, and uses that as the anchor for the subview.\n\nThe offset that the app applies to the rotation accounts for the current rankings, placing higher-ranked pets closer to the top of the interface. The app stores ranks on the subviews using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LayoutValueKey] protocol, and then reads the values to calculate the offset before placing views.\n\n### Animate transitions between layouts\n\nThe radial layout can calculate an offset that creates an appropriate arrangement for all but one set of rankings: there’s no way to show a three-way tie with the avatars in a circle. To resolve this, the app detects this condition, and uses it to put the avatars in a line instead, using a the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/HStackLayout] type, which is a version of the built-in [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/HStack] that conforms to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout] protocol. To transition between these layout types, the app uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnyLayout] type.\n\nBecause the structural identity of the views remains the same throughout, the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/animation(_:value:)] view modifier creates animated transitions between layout types. The modifier also animates radial layout changes that result from changes in the rankings because the calculated offsets depend on the same pet data.\n\n### Build documentation for the app\n\nTo see more information about the symbols defined by this app, you can build the app’s documentation. Open the project in Xcode and select Product > Build Documentation.\n\nFor information about how to include documentation in your own apps, see [https:\/\/www.swift.org\/documentation\/docc].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/composing-custom-layouts-with-swiftui\ncrawled: 2025-12-02T15:32:47Z\n---\n\n# Composing custom layouts with SwiftUI\n\n**Sample Code**\n\nArrange views in your app’s interface using layout tools that SwiftUI provides.\n\n## Overview\n\nThis sample app demonstrates many of the layout tools that SwiftUI provides by building an interface that enables people to vote for their favorite kind of pet. The app offers buttons to vote for a specific pet type, and displays the vote counts and relative rankings of the various contenders on a leaderboard. It also shows avatars for the pets, arranged in a way that reflects the current rankings.\n\n\n\n\n\n### Arrange views in two dimensions with a grid\n\nTo draw a leaderboard in the middle of the display that shows vote counts and percentages, the sample uses a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Grid] view.\n\n\n\nThe grid contains a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/GridRow] inside a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ForEach], where each view in the row creates a column cell. So the first view appears in the first column, the second in the second column, and so on. Because the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Divider] appears outside of a grid row instance, it creates a row that spans the width of the grid.\n\n```swift\nGrid(alignment: .leading) {\n    ForEach(model.pets) { pet in\n        GridRow {\n            Text(pet.type)\n            ProgressView(\n                value: Double(pet.votes),\n                total: Double(max(1, model.totalVotes))) \/\/ Avoid dividing by zero.\n            Text(\"\\(pet.votes)\")\n                .gridColumnAlignment(.trailing)\n        }\n\n        Divider()\n    }\n}\n```\n\nThe sample initializes the grid with leading-edge alignment, which applies to every cell in the grid. Meanwhile, the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/gridColumnAlignment(_:)] view modifier that appears on the vote count cell overrides the alignment of cells in that column to use trailing-edge alignment.\n\n### Create a custom equal-width layout\n\nThe app offers buttons for voting at the bottom of the interface.\n\n\n\nTo ensure the buttons all have the same width, but are no wider than the widest button text, the app creates a custom layout container type that conforms to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout] protocol. The equal-width horizontal stack (`MyEqualWidthHStack`) measures the ideal sizes of all its subviews, and offers the widest ideal size to each subview.\n\nThe custom stack implements the protocol’s two required methods. First, [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/sizeThatFits(proposal:subviews:cache:)] reports the container’s size, given a set of subviews.\n\n```swift\nfunc sizeThatFits(\n    proposal: ProposedViewSize,\n    subviews: Subviews,\n    cache: inout Void\n) -> CGSize {\n    guard !subviews.isEmpty else { return .zero }\n\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n    let totalSpacing = spacing.reduce(0) { $0 + $1 }\n\n    return CGSize(\n        width: maxSize.width * CGFloat(subviews.count) + totalSpacing,\n        height: maxSize.height)\n}\n```\n\nThis method combines the largest size in each dimension with the horizontal spacing between subviews to find the container’s total size. Then, [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/placeSubviews(in:proposal:subviews:cache:)] tells each of the subviews where to appear within the layout’s bounds.\n\n```swift\nfunc placeSubviews(\n    in bounds: CGRect,\n    proposal: ProposedViewSize,\n    subviews: Subviews,\n    cache: inout Void\n) {\n    guard !subviews.isEmpty else { return }\n\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n\n    let placementProposal = ProposedViewSize(width: maxSize.width, height: maxSize.height)\n    var nextX = bounds.minX + maxSize.width \/ 2\n\n    for index in subviews.indices {\n        subviews[index].place(\n            at: CGPoint(x: nextX, y: bounds.midY),\n            anchor: .center,\n            proposal: placementProposal)\n        nextX += maxSize.width + spacing[index]\n    }\n}\n```\n\nThe method creates a single size proposal for the subviews, and then uses that, along with a point that changes for each subview, to arrange the buttons in a horizontal line with default spacing.\n\n### Choose the view that fits\n\nThe size of the voting buttons depends on the width of the text they contain. For people that speak another language or that use a larger text size, the horizontally arranged buttons might not fit in the display. So the app uses [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ViewThatFits] to let SwiftUI choose between a horizontal and a vertical arrangement of the buttons for the one that fits in the available space.\n\n```swift\nViewThatFits { \/\/ Choose the first view that fits.\n    MyEqualWidthHStack { \/\/ Arrange horizontally if it fits...\n        Buttons()\n    }\n    MyEqualWidthVStack { \/\/ ...or vertically, otherwise.\n        Buttons()\n    }\n}\n```\n\nTo ensure that the buttons maintain their equal-width property when arranged vertically, the app uses a custom equal-width vertical stack (`MyEqualWidthVStack`) that’s very similar to the horizontal version.\n\n### Improve layout efficiency with a cache\n\nThe methods of the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout] protocol take a bidirectional `cache` parameter. The cache provides access to optional storage that’s shared among all the methods of a particular layout instance. To demonstrate the use of a cache, the sample app’s equal-width vertical layout creates storage to share size and spacing calculations between its [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/sizeThatFits(proposal:subviews:cache:)] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/placeSubviews(in:proposal:subviews:cache:)] implementations.\n\nFirst, the layout defines a `CacheData` type for the storage.\n\n```swift\nstruct CacheData {\n    let maxSize: CGSize\n    let spacing: [CGFloat]\n    let totalSpacing: CGFloat\n}\n```\n\nIt then implements the protocol’s optional [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/makeCache(subviews:)] method to do the calculations for a set of subviews, returning a value of the type defined above.\n\n```swift\nfunc makeCache(subviews: Subviews) -> CacheData {\n    let maxSize = maxSize(subviews: subviews)\n    let spacing = spacing(subviews: subviews)\n    let totalSpacing = spacing.reduce(0) { $0 + $1 }\n\n    return CacheData(\n        maxSize: maxSize,\n        spacing: spacing,\n        totalSpacing: totalSpacing)\n}\n```\n\nIf the subviews change, SwiftUI calls the layout’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/updateCache(_:subviews:)] method. The default implementation of that method calls [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/makeCache(subviews:)] again, which recalculates the data. Then the `sizeThatFits(proposal:subviews:cache:)` and `placeSubviews(in:proposal:subviews:cache:)` methods make use of their `cache` parameter to retrieve the data. For example, `placeSubviews(in:proposal:subviews:cache:)` reads the size and the spacing array from the cache.\n\n```swift\nlet maxSize = cache.maxSize\nlet spacing = cache.spacing\n```\n\nContrast this with the equal-width horizontal stack, which doesn’t use a cache, and instead calculates the size and spacing information every time it needs that information.\n\n\n\n### Create a custom radial layout with an offset\n\nTo display the pet avatars in a circle, the app defines a radial layout (`MyRadialLayout`).\n\n\n\nLike other custom layouts, this layout needs the two required methods. For [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout\/sizeThatFits(proposal:subviews:cache:)], the layout fills the available space by returning whatever size its container proposes.\n\n```swift\nproposal.replacingUnspecifiedDimensions()\n```\n\nThe app uses the proposal’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ProposedViewSize\/replacingUnspecifiedDimensions(by:)] method to convert the proposal into a concrete size. Then, to place subviews, the layout rotates a vector, translates the vector to the middle of the placement region, and uses that as the anchor for the subview.\n\n```swift\nfor (index, subview) in subviews.enumerated() {\n    \/\/ Find a vector with an appropriate size and rotation.\n    var point = CGPoint(x: 0, y: -radius)\n        .applying(CGAffineTransform(\n            rotationAngle: angle * Double(index) + offset))\n\n    \/\/ Shift the vector to the middle of the region.\n    point.x += bounds.midX\n    point.y += bounds.midY\n\n    \/\/ Place the subview.\n    subview.place(at: point, anchor: .center, proposal: .unspecified)\n}\n```\n\nThe offset that the app applies to the rotation accounts for the current rankings, placing higher-ranked pets closer to the top of the interface. The app stores ranks on the subviews using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LayoutValueKey] protocol, and then reads the values to calculate the offset before placing views.\n\n### Animate transitions between layouts\n\nThe radial layout can calculate an offset that creates an appropriate arrangement for all but one set of rankings: there’s no way to show a three-way tie with the avatars in a circle. To resolve this, the app detects this condition, and uses it to put the avatars in a line instead, using a the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/HStackLayout] type, which is a version of the built-in [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/HStack] that conforms to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Layout] protocol. To transition between these layout types, the app uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/AnyLayout] type.\n\n```swift\nlet layout = model.isAllWayTie ? AnyLayout(HStackLayout()) : AnyLayout(MyRadialLayout())\n\nPodium()\n    .overlay(alignment: .top) {\n        layout {\n            ForEach(model.pets) { pet in\n                Avatar(pet: pet)\n                    .rank(model.rank(pet))\n            }\n        }\n        .animation(.default, value: model.pets)\n    }\n```\n\nBecause the structural identity of the views remains the same throughout, the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/animation(_:value:)] view modifier creates animated transitions between layout types. The modifier also animates radial layout changes that result from changes in the rankings because the calculated offsets depend on the same pet data.\n\n### Build documentation for the app\n\nTo see more information about the symbols defined by this app, you can build the app’s documentation. Open the project in Xcode and select Product > Build Documentation.\n\nFor information about how to include documentation in your own apps, see [https:\/\/www.swift.org\/documentation\/docc].\n\n## Creating a custom layout container\n\n- **Layout**: A type that defines the geometry of a collection of views.\n- **LayoutSubview**: A proxy that represents one subview of a layout.\n- **LayoutSubviews**: A collection of proxy values that represent the subviews of a layout view.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A type that defines the geometry of a collection of views.",
          "name" : "Layout",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Layout"
        },
        {
          "description" : "A proxy that represents one subview of a layout.",
          "name" : "LayoutSubview",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/LayoutSubview"
        },
        {
          "description" : "A collection of proxy values that represent the subviews of a layout view.",
          "name" : "LayoutSubviews",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/LayoutSubviews"
        }
      ],
      "title" : "Creating a custom layout container"
    }
  ],
  "source" : "appleJSON",
  "title" : "Composing custom layouts with SwiftUI",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/composing-custom-layouts-with-swiftui"
}