{
  "abstract" : "A property wrapper type that instantiates an observable object.",
  "codeExamples" : [
    {
      "code" : "class DataModel: ObservableObject {\n    @Published var name = \"Some Name\"\n    @Published var isEnabled = false\n}\n\nstruct MyView: View {\n    @StateObject private var model = DataModel() \/\/ Create the state object.\n\n    var body: some View {\n        Text(model.name) \/\/ Updates when the data model changes.\n        MySubView()\n            .environmentObject(model)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MySubView: View {\n    @EnvironmentObject var model: DataModel\n\n    var body: some View {\n        Toggle(\"Enabled\", isOn: $model.isEnabled)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct MyInitializableView: View {\n    @StateObject private var model: DataModel\n\n    init(name: String) {\n        \/\/ SwiftUI ensures that the following initialization uses the\n        \/\/ closure only once during the lifetime of the view, so\n        \/\/ later changes to the view's name input have no effect.\n        _model = StateObject(wrappedValue: DataModel(name: name))\n    }\n\n    var body: some View {\n        VStack {\n            Text(\"Name: \\(model.name)\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "var body: some View {\n    VStack {\n        MyInitializableView(name: \"Ravi\")\n        MyInitializableView(name: \"Maria\")\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "MyInitializableView(name: name)\n    .id(name) \/\/ Binds the identity of the view to the name property.",
      "language" : "swift"
    },
    {
      "code" : "var hash: Int {\n    var hasher = Hasher()\n    hasher.combine(name)\n    hasher.combine(isEnabled)\n    return hasher.finalize()\n}",
      "language" : "swift"
    },
    {
      "code" : "MyInitializableView(name: name, isEnabled: isEnabled)\n    .id(hash)",
      "language" : "swift"
    }
  ],
  "conformsTo" : [
    "DynamicProperty",
    "Sendable",
    "SendableMetatype"
  ],
  "contentHash" : "c444c8262be0fa9247dda19028a2b9905c3ca33a51a77b28e9ed94e4bcfef1d6",
  "crawledAt" : "2025-12-02T15:57:39Z",
  "declaration" : {
    "code" : "@MainActor @frozen @propertyWrapper @preconcurrency struct StateObject<ObjectType> where ObjectType : ObservableObject",
    "language" : "swift"
  },
  "id" : "95CC2D55-86B0-40D2-8521-DB66CA33EBC3",
  "kind" : "struct",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nUse a state object as the single source of truth for a reference type that you store in a view hierarchy. Create a state object in an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/App], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Scene], or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View] by applying the `@StateObject` attribute to a property declaration and providing an initial value that conforms to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/ObservableObject] protocol. Declare state objects as private to prevent setting them from a memberwise initializer, which can conflict with the storage management that SwiftUI provides:\n\nSwiftUI creates a new instance of the model object only once during the lifetime of the container that declares the state object. For example, SwiftUI doesn’t create a new instance if a view’s inputs change, but does create a new instance if the identity of a view changes. When published properties of the observable object change, SwiftUI updates any view that depends on those properties, like the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view in the above example.\n\n### Share state objects with subviews\n\nYou can pass a state object into a subview through a property that has the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ObservedObject] attribute. Alternatively, add the object to the environment of a view hierarchy by applying the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environmentObject(_:)] modifier to a view, like `MySubView` in the above code. You can then read the object inside `MySubView` or any of its descendants using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/EnvironmentObject] attribute:\n\nGet a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] to the state object’s properties using the dollar sign (`$`) operator. Use a binding when you want to create a two-way connection. In the above code, the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Toggle] controls the model’s `isEnabled` value through a binding.\n\n### Initialize state objects using external data\n\nWhen a state object’s initial state depends on data that comes from outside its container, you can call the object’s initializer explicitly from within its container’s initializer. For example, suppose the data model from the previous example takes a `name` input during initialization and you want to use a value for that name that comes from outside the view. You can do this with a call to the state object’s initializer inside an explicit initializer that you create for the view:\n\nUse caution when doing this. SwiftUI only initializes a state object the first time you call its initializer in a given view. This ensures that the object provides stable storage even as the view’s inputs change. However, it might result in unexpected behavior or unwanted side effects if you explicitly initialize the state object.\n\nIn the above example, if the `name` input to `MyInitializableView` changes, SwiftUI reruns the view’s initializer with the new value. However, SwiftUI runs the autoclosure that you provide to the state object’s initializer only the first time you call the state object’s initializer, so the model’s stored `name` value doesn’t change.\n\nExplicit state object initialization works well when the external data that the object depends on doesn’t change for a given instance of the object’s container. For example, you can create two views with different constant names:\n\n### Force reinitialization by changing view identity\n\nIf you want SwiftUI to reinitialize a state object when a view input changes, make sure that the view’s identity changes at the same time. One way to do this is to bind the view’s identity to the value that changes using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/id(_:)] modifier. For example, you can ensure that the identity of an instance of `MyInitializableView` changes when its `name` input changes:\n\nIf you need the view to reinitialize state based on changes in more than one value, you can combine the values into a single identifier using a [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hasher]. For example, if you want to update the data model in `MyInitializableView` when the values of either `name` or `isEnabled` change, you can combine both variables into a single hash:\n\nThen apply the combined hash to the view as an identifier:\n\nBe mindful of the performance cost of reinitializing the state object every time the input changes. Also, changing view identity can have side effects. For example, SwiftUI doesn’t automatically animate changes inside the view if the view’s identity changes at the same time. Also, changing the identity resets *all* state held by the view, including values that you manage as [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/FocusState], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/GestureState], and so on.",
  "platforms" : [
    "iOS",
    "iPadOS",
    "Mac Catalyst",
    "macOS",
    "tvOS",
    "visionOS",
    "watchOS"
  ],
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/StateObject\ncrawled: 2025-12-02T15:57:39Z\n---\n\n# StateObject\n\n**Structure**\n\nA property wrapper type that instantiates an observable object.\n\n## Declaration\n\n```swift\n@MainActor @frozen @propertyWrapper @preconcurrency struct StateObject<ObjectType> where ObjectType : ObservableObject\n```\n\n## Overview\n\nUse a state object as the single source of truth for a reference type that you store in a view hierarchy. Create a state object in an [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/App], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Scene], or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View] by applying the `@StateObject` attribute to a property declaration and providing an initial value that conforms to the [doc:\/\/com.apple.documentation\/documentation\/Combine\/ObservableObject] protocol. Declare state objects as private to prevent setting them from a memberwise initializer, which can conflict with the storage management that SwiftUI provides:\n\n```swift\nclass DataModel: ObservableObject {\n    @Published var name = \"Some Name\"\n    @Published var isEnabled = false\n}\n\nstruct MyView: View {\n    @StateObject private var model = DataModel() \/\/ Create the state object.\n\n    var body: some View {\n        Text(model.name) \/\/ Updates when the data model changes.\n        MySubView()\n            .environmentObject(model)\n    }\n}\n```\n\nSwiftUI creates a new instance of the model object only once during the lifetime of the container that declares the state object. For example, SwiftUI doesn’t create a new instance if a view’s inputs change, but does create a new instance if the identity of a view changes. When published properties of the observable object change, SwiftUI updates any view that depends on those properties, like the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view in the above example.\n\n\n\n### Share state objects with subviews\n\nYou can pass a state object into a subview through a property that has the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ObservedObject] attribute. Alternatively, add the object to the environment of a view hierarchy by applying the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/environmentObject(_:)] modifier to a view, like `MySubView` in the above code. You can then read the object inside `MySubView` or any of its descendants using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/EnvironmentObject] attribute:\n\n```swift\nstruct MySubView: View {\n    @EnvironmentObject var model: DataModel\n\n    var body: some View {\n        Toggle(\"Enabled\", isOn: $model.isEnabled)\n    }\n}\n```\n\nGet a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] to the state object’s properties using the dollar sign (`$`) operator. Use a binding when you want to create a two-way connection. In the above code, the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Toggle] controls the model’s `isEnabled` value through a binding.\n\n### Initialize state objects using external data\n\nWhen a state object’s initial state depends on data that comes from outside its container, you can call the object’s initializer explicitly from within its container’s initializer. For example, suppose the data model from the previous example takes a `name` input during initialization and you want to use a value for that name that comes from outside the view. You can do this with a call to the state object’s initializer inside an explicit initializer that you create for the view:\n\n```swift\nstruct MyInitializableView: View {\n    @StateObject private var model: DataModel\n\n    init(name: String) {\n        \/\/ SwiftUI ensures that the following initialization uses the\n        \/\/ closure only once during the lifetime of the view, so\n        \/\/ later changes to the view's name input have no effect.\n        _model = StateObject(wrappedValue: DataModel(name: name))\n    }\n\n    var body: some View {\n        VStack {\n            Text(\"Name: \\(model.name)\")\n        }\n    }\n}\n```\n\nUse caution when doing this. SwiftUI only initializes a state object the first time you call its initializer in a given view. This ensures that the object provides stable storage even as the view’s inputs change. However, it might result in unexpected behavior or unwanted side effects if you explicitly initialize the state object.\n\nIn the above example, if the `name` input to `MyInitializableView` changes, SwiftUI reruns the view’s initializer with the new value. However, SwiftUI runs the autoclosure that you provide to the state object’s initializer only the first time you call the state object’s initializer, so the model’s stored `name` value doesn’t change.\n\nExplicit state object initialization works well when the external data that the object depends on doesn’t change for a given instance of the object’s container. For example, you can create two views with different constant names:\n\n```swift\nvar body: some View {\n    VStack {\n        MyInitializableView(name: \"Ravi\")\n        MyInitializableView(name: \"Maria\")\n    }\n}\n```\n\n\n\n### Force reinitialization by changing view identity\n\nIf you want SwiftUI to reinitialize a state object when a view input changes, make sure that the view’s identity changes at the same time. One way to do this is to bind the view’s identity to the value that changes using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/id(_:)] modifier. For example, you can ensure that the identity of an instance of `MyInitializableView` changes when its `name` input changes:\n\n```swift\nMyInitializableView(name: name)\n    .id(name) \/\/ Binds the identity of the view to the name property.\n```\n\n\n\nIf you need the view to reinitialize state based on changes in more than one value, you can combine the values into a single identifier using a [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hasher]. For example, if you want to update the data model in `MyInitializableView` when the values of either `name` or `isEnabled` change, you can combine both variables into a single hash:\n\n```swift\nvar hash: Int {\n    var hasher = Hasher()\n    hasher.combine(name)\n    hasher.combine(isEnabled)\n    return hasher.finalize()\n}\n```\n\nThen apply the combined hash to the view as an identifier:\n\n```swift\nMyInitializableView(name: name, isEnabled: isEnabled)\n    .id(hash)\n```\n\nBe mindful of the performance cost of reinitializing the state object every time the input changes. Also, changing view identity can have side effects. For example, SwiftUI doesn’t automatically animate changes inside the view if the view’s identity changes at the same time. Also, changing the identity resets *all* state held by the view, including values that you manage as [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/FocusState], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/GestureState], and so on.\n\n## Creating a state object\n\n- **init(wrappedValue:)**: Creates a new state object with an initial wrapped value.\n\n## Getting the value\n\n- **wrappedValue**: The underlying value referenced by the state object.\n- **projectedValue**: A projection of the state object that creates bindings to its properties.\n\n## Creating model data\n\n- **Managing model data in your app**: Create connections between your app’s data model and views.\n- **Migrating from the Observable Object protocol to the Observable macro**: Update your existing app to leverage the benefits of Observation in Swift.\n- **Observable()**: Defines and implements conformance of the Observable protocol.\n- **Monitoring data changes in your app**: Show changes to data in your app’s user interface by using observable objects.\n- **ObservedObject**: A property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes.\n- **ObservableObject**: A type of object with a publisher that emits before the object has changed.\n\n## Conforms To\n\n- DynamicProperty\n- Sendable\n- SendableMetatype\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Creates a new state object with an initial wrapped value.",
          "name" : "init(wrappedValue:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/StateObject\/init(wrappedValue:)"
        }
      ],
      "title" : "Creating a state object"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "The underlying value referenced by the state object.",
          "name" : "wrappedValue",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/StateObject\/wrappedValue"
        },
        {
          "description" : "A projection of the state object that creates bindings to its properties.",
          "name" : "projectedValue",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/StateObject\/projectedValue"
        }
      ],
      "title" : "Getting the value"
    },
    {
      "content" : "",
      "items" : [
        {
          "description" : "Create connections between your app’s data model and views.",
          "name" : "Managing model data in your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Managing-model-data-in-your-app"
        },
        {
          "description" : "Update your existing app to leverage the benefits of Observation in Swift.",
          "name" : "Migrating from the Observable Object protocol to the Observable macro",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Migrating-from-the-observable-object-protocol-to-the-observable-macro"
        },
        {
          "description" : "Defines and implements conformance of the Observable protocol.",
          "name" : "Observable()",
          "url" : "https:\/\/developer.apple.com\/documentation\/Observation\/Observable()"
        },
        {
          "description" : "Show changes to data in your app’s user interface by using observable objects.",
          "name" : "Monitoring data changes in your app",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Monitoring-model-data-changes-in-your-app"
        },
        {
          "description" : "A property wrapper type that subscribes to an observable object and invalidates a view whenever the observable object changes.",
          "name" : "ObservedObject",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/ObservedObject"
        },
        {
          "description" : "A type of object with a publisher that emits before the object has changed.",
          "name" : "ObservableObject",
          "url" : "https:\/\/developer.apple.com\/documentation\/Combine\/ObservableObject"
        }
      ],
      "title" : "Creating model data"
    }
  ],
  "source" : "appleJSON",
  "title" : "StateObject",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/StateObject"
}