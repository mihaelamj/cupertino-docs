{
  "abstract" : "Encapsulate view-specific data within your app’s view hierarchy to make your views reusable.",
  "codeExamples" : [
    {
      "code" : "struct PlayerView: View {\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        \/\/ ...\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "Button(action: {\n    self.isPlaying.toggle()\n}) {\n    Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n}",
      "language" : "swift"
    },
    {
      "code" : "struct PlayerView: View {\n    let episode: Episode \/\/ The queued episode.\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        VStack {\n            \/\/ Display information about the episode.\n            Text(episode.title)\n            Text(episode.showTitle)\n\n            Button(action: {\n                self.isPlaying.toggle()\n            }) {\n                Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct PlayButton: View {\n    @Binding var isPlaying: Bool\n    \n    var body: some View {\n        Button(action: {\n            self.isPlaying.toggle()\n        }) {\n            Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct PlayerView: View {\n    var episode: Episode\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        VStack {\n            Text(episode.title)\n            Text(episode.showTitle)\n            PlayButton(isPlaying: $isPlaying) \/\/ Pass a binding.\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct Podcaster: View {\n    @State private var episode = Episode(title: \"Some Episode\",\n                                         showTitle: \"Great Show\",\n                                         isFavorite: false)\n    var body: some View {\n        VStack {\n            Toggle(\"Favorite\", isOn: $episode.isFavorite) \/\/ Bind to the Boolean.\n            PlayerView(episode: episode)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "withAnimation(.easeInOut(duration: 1)) {\n    self.isPlaying.toggle()\n}",
      "language" : "swift"
    },
    {
      "code" : "Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n    .scaleEffect(isPlaying ? 1 : 1.5)",
      "language" : "swift"
    },
    {
      "code" : "VStack {\n    Text(episode.title)\n    Text(episode.showTitle)\n    PlayButton(isPlaying: $isPlaying)\n}\n.background(isPlaying ? Color.green : Color.red) \/\/ Transitions with animation.",
      "language" : "swift"
    }
  ],
  "contentHash" : "b23875428391364b6fb3c0273c3361633e560d157ef4807a9e59672803618dbd",
  "crawledAt" : "2025-12-02T17:13:31Z",
  "id" : "2802D020-B6D5-4B56-84CB-1BBC6F18F6B4",
  "kind" : "article",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nStore data as state in the least common ancestor of the views that need the data to establish a single *source of truth* that’s shared across views. Provide the data as read-only through a Swift property, or create a two-way connection to the state with a binding. SwiftUI watches for changes in the data, and updates any affected views as needed.\n\n\n\nDon’t use state properties for persistent storage because the life cycle of state variables mirrors the view life cycle. Instead, use them to manage transient state that only affects the user interface, like the highlight state of a button, filter settings, or the currently selected list item. You might also find this kind of storage convenient while you prototype, before you’re ready to make changes to your app’s data model.\n\n### Manage mutable values as state\n\nIf a view needs to store data that it can modify, declare a variable with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State] property wrapper. For example, you can create an `isPlaying` Boolean inside a podcast player view to keep track of when a podcast is running:\n\nMarking the property as state tells the framework to manage the underlying storage. Your view reads and writes the data, found in the state’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State\/wrappedValue] property, by using the property name. When you change the value, SwiftUI updates the affected parts of the view. For example, you can add a button to the `PlayerView` that toggles the stored value when tapped, and that displays a different image depending on the stored value:\n\nLimit the scope of state variables by declaring them as private. This ensures that the variables remain encapsulated in the view hierarchy that declares them.\n\n### Declare Swift properties to store immutable values\n\nTo provide a view with data that the view doesn’t modify, declare a standard Swift property. For example, you can extend the podcast player to have an input structure that contains strings for the episode title and the show name:\n\nWhile the value of the episode property is a constant for `PlayerView`, it doesn’t need to be constant in this view’s parent view. When the user selects a different episode in the parent, SwiftUI detects the state change and recreates the `PlayerView` with a new input.\n\n### Share access to state with bindings\n\nIf a view needs to share control of state with a child view, declare a property in the child with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] property wrapper. A binding represents a reference to existing storage, preserving a single source of truth for the underlying data. For example, if you refactor the podcast player view’s button into a child view called `PlayButton`, you can give it a binding to the `isPlaying` property:\n\nAs shown above, you read and write the binding’s wrapped value by referring directly to the property, just like state. But unlike a state property, the binding doesn’t have its own storage. Instead, it references a state property stored somewhere else, and provides a two-way connection to that storage.\n\nWhen you instantiate `PlayButton`, provide a binding to the corresponding state variable declared in the parent view by prefixing it with the dollar sign (`$`):\n\nThe `$` prefix asks a wrapped property for its [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State\/projectedValue], which for state is a binding to the underlying storage. Similarly, you can get a binding from a binding using the `$` prefix, allowing you to pass a binding through an arbitrary number of levels of view hierarchy.\n\nYou can also get a binding to a scoped value within a state variable. For example, if you declare `episode` as a state variable in the player’s parent view, and the episode structure also contains an `isFavorite` Boolean that you want to control with a toggle, then you can refer to `$episode.isFavorite` to get a binding to the episode’s favorite status:\n\n### Animate state transitions\n\nWhen the view state changes, SwiftUI updates affected views right away. If you want to smooth visual transitions, you can tell SwiftUI to animate them by wrapping the state change that triggers them in a call to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/withAnimation(_:_:)] function. For example, you can animate changes controlled by the `isPlaying` Boolean:\n\nBy changing `isPlaying` inside the animation function’s trailing closure, you tell SwiftUI to animate anything that depends on the wrapped value, like a scale effect on the button’s image:\n\nSwiftUI transitions the scale effect input over time between the given values of `1` and `1.5`, using the curve and duration that you specify, or reasonable default values if you provide none. On the other hand, the image content isn’t affected by the animation, even though the same Boolean dictates which system image to display. That’s because SwiftUI can’t incrementally transition in a meaningful way between the two strings `pause.circle` and `play.circle`.\n\nYou can add animation to a state property, or as in the above example, to a binding. Either way, SwiftUI animates any view changes that happen when the underlying stored value changes. For example, if you add a background color to the `PlayerView` — at a level of view hierarchy above the location of the animation block — SwiftUI animates that as well:\n\nWhen you want to apply animations to specific views, rather than across all views triggered by a change in state, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/animation(_:value:)] view modifier instead.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/Managing-User-Interface-State\ncrawled: 2025-12-02T17:13:31Z\n---\n\n# Managing user interface state\n\n**Article**\n\nEncapsulate view-specific data within your app’s view hierarchy to make your views reusable.\n\n## Overview\n\nStore data as state in the least common ancestor of the views that need the data to establish a single *source of truth* that’s shared across views. Provide the data as read-only through a Swift property, or create a two-way connection to the state with a binding. SwiftUI watches for changes in the data, and updates any affected views as needed.\n\n\n\nDon’t use state properties for persistent storage because the life cycle of state variables mirrors the view life cycle. Instead, use them to manage transient state that only affects the user interface, like the highlight state of a button, filter settings, or the currently selected list item. You might also find this kind of storage convenient while you prototype, before you’re ready to make changes to your app’s data model.\n\n### Manage mutable values as state\n\nIf a view needs to store data that it can modify, declare a variable with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State] property wrapper. For example, you can create an `isPlaying` Boolean inside a podcast player view to keep track of when a podcast is running:\n\n```swift\nstruct PlayerView: View {\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        \/\/ ...\n    }\n}\n```\n\nMarking the property as state tells the framework to manage the underlying storage. Your view reads and writes the data, found in the state’s [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State\/wrappedValue] property, by using the property name. When you change the value, SwiftUI updates the affected parts of the view. For example, you can add a button to the `PlayerView` that toggles the stored value when tapped, and that displays a different image depending on the stored value:\n\n```swift\nButton(action: {\n    self.isPlaying.toggle()\n}) {\n    Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n}\n```\n\nLimit the scope of state variables by declaring them as private. This ensures that the variables remain encapsulated in the view hierarchy that declares them.\n\n### Declare Swift properties to store immutable values\n\nTo provide a view with data that the view doesn’t modify, declare a standard Swift property. For example, you can extend the podcast player to have an input structure that contains strings for the episode title and the show name:\n\n```swift\nstruct PlayerView: View {\n    let episode: Episode \/\/ The queued episode.\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        VStack {\n            \/\/ Display information about the episode.\n            Text(episode.title)\n            Text(episode.showTitle)\n\n            Button(action: {\n                self.isPlaying.toggle()\n            }) {\n                Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n            }\n        }\n    }\n}\n```\n\nWhile the value of the episode property is a constant for `PlayerView`, it doesn’t need to be constant in this view’s parent view. When the user selects a different episode in the parent, SwiftUI detects the state change and recreates the `PlayerView` with a new input.\n\n### Share access to state with bindings\n\nIf a view needs to share control of state with a child view, declare a property in the child with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] property wrapper. A binding represents a reference to existing storage, preserving a single source of truth for the underlying data. For example, if you refactor the podcast player view’s button into a child view called `PlayButton`, you can give it a binding to the `isPlaying` property:\n\n```swift\nstruct PlayButton: View {\n    @Binding var isPlaying: Bool\n    \n    var body: some View {\n        Button(action: {\n            self.isPlaying.toggle()\n        }) {\n            Image(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n        }\n    }\n}\n```\n\nAs shown above, you read and write the binding’s wrapped value by referring directly to the property, just like state. But unlike a state property, the binding doesn’t have its own storage. Instead, it references a state property stored somewhere else, and provides a two-way connection to that storage.\n\nWhen you instantiate `PlayButton`, provide a binding to the corresponding state variable declared in the parent view by prefixing it with the dollar sign (`$`):\n\n```swift\nstruct PlayerView: View {\n    var episode: Episode\n    @State private var isPlaying: Bool = false\n    \n    var body: some View {\n        VStack {\n            Text(episode.title)\n            Text(episode.showTitle)\n            PlayButton(isPlaying: $isPlaying) \/\/ Pass a binding.\n        }\n    }\n}\n```\n\nThe `$` prefix asks a wrapped property for its [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State\/projectedValue], which for state is a binding to the underlying storage. Similarly, you can get a binding from a binding using the `$` prefix, allowing you to pass a binding through an arbitrary number of levels of view hierarchy.\n\nYou can also get a binding to a scoped value within a state variable. For example, if you declare `episode` as a state variable in the player’s parent view, and the episode structure also contains an `isFavorite` Boolean that you want to control with a toggle, then you can refer to `$episode.isFavorite` to get a binding to the episode’s favorite status:\n\n```swift\nstruct Podcaster: View {\n    @State private var episode = Episode(title: \"Some Episode\",\n                                         showTitle: \"Great Show\",\n                                         isFavorite: false)\n    var body: some View {\n        VStack {\n            Toggle(\"Favorite\", isOn: $episode.isFavorite) \/\/ Bind to the Boolean.\n            PlayerView(episode: episode)\n        }\n    }\n}\n```\n\n### Animate state transitions\n\nWhen the view state changes, SwiftUI updates affected views right away. If you want to smooth visual transitions, you can tell SwiftUI to animate them by wrapping the state change that triggers them in a call to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/withAnimation(_:_:)] function. For example, you can animate changes controlled by the `isPlaying` Boolean:\n\n```swift\nwithAnimation(.easeInOut(duration: 1)) {\n    self.isPlaying.toggle()\n}\n```\n\nBy changing `isPlaying` inside the animation function’s trailing closure, you tell SwiftUI to animate anything that depends on the wrapped value, like a scale effect on the button’s image:\n\n```swift\nImage(systemName: isPlaying ? \"pause.circle\" : \"play.circle\")\n    .scaleEffect(isPlaying ? 1 : 1.5)\n```\n\nSwiftUI transitions the scale effect input over time between the given values of `1` and `1.5`, using the curve and duration that you specify, or reasonable default values if you provide none. On the other hand, the image content isn’t affected by the animation, even though the same Boolean dictates which system image to display. That’s because SwiftUI can’t incrementally transition in a meaningful way between the two strings `pause.circle` and `play.circle`.\n\nYou can add animation to a state property, or as in the above example, to a binding. Either way, SwiftUI animates any view changes that happen when the underlying stored value changes. For example, if you add a background color to the `PlayerView` — at a level of view hierarchy above the location of the animation block — SwiftUI animates that as well:\n\n```swift\nVStack {\n    Text(episode.title)\n    Text(episode.showTitle)\n    PlayButton(isPlaying: $isPlaying)\n}\n.background(isPlaying ? Color.green : Color.red) \/\/ Transitions with animation.\n```\n\nWhen you want to apply animations to specific views, rather than across all views triggered by a change in state, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/animation(_:value:)] view modifier instead.\n\n## Creating and sharing view state\n\n- **State**: A property wrapper type that can read and write a value managed by SwiftUI.\n- **Bindable**: A property wrapper type that supports creating bindings to the mutable properties of observable objects.\n- **Binding**: A property wrapper type that can read and write a value owned by a source of truth.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "A property wrapper type that can read and write a value managed by SwiftUI.",
          "name" : "State",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/State"
        },
        {
          "description" : "A property wrapper type that supports creating bindings to the mutable properties of observable objects.",
          "name" : "Bindable",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Bindable"
        },
        {
          "description" : "A property wrapper type that can read and write a value owned by a source of truth.",
          "name" : "Binding",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Binding"
        }
      ],
      "title" : "Creating and sharing view state"
    }
  ],
  "source" : "appleJSON",
  "title" : "Managing user interface state",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Managing-User-Interface-State"
}