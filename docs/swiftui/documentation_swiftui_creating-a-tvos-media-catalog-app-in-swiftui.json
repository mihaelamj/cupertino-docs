{
  "abstract" : "Build standard content lockups and rows of content shelves for your tvOS app.",
  "codeExamples" : [
    {
      "code" : "Button { \/* action *\/ } label: {\n    Image(\"discovery_portrait\")\n        .resizable()\n        .frame(width: 250, height: 375)\n    Text(\"Borderless Portrait\")\n}",
      "language" : "swift"
    },
    {
      "code" : "Button { \/* action *\/ } label: {\n    Image(systemName: \"person.circle\")\n        .font(.title)\n        .background(Color.blue.grayscale(0.7))\n        .hoverEffect(.highlight)\n    Text(\"Shaped\")\n}\n.buttonBorderShape(.circle)",
      "language" : "swift"
    },
    {
      "code" : "Button { \/* action *\/ } label: {\n    CodeSampleArtwork(size: .appIconSize)\n        .frame(width: 400, height: 240)\n        .hoverEffect(.highlight)\n    Text(\"Custom Icon View\")\n}",
      "language" : "swift"
    },
    {
      "code" : "Button { \/* action *\/ } label: {\n    HStack(alignment: .top, spacing: 10) {\n        Image( . . . )\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .clipShape(RoundedRectangle(cornerRadius: 12))\n\n        VStack(alignment: .leading) {\n            Text(asset.title)\n                .font(.body)\n            Text(\"Subtitle text goes here, limited to two lines.\")\n                .font(.caption2)\n                .foregroundStyle(.secondary)\n                .lineLimit(2)\n            Spacer(minLength: 0)\n            HStack(spacing: 4) {\n                ForEach(1..<4) { _ in\n                    Image(systemName: \"ellipsis.rectangle.fill\")\n                }\n            }\n            .foregroundStyle(.secondary)\n        }\n    }\n    .padding(12)\n}",
      "language" : "swift"
    },
    {
      "code" : "struct CardOverlayLabelStyle: LabelStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        ZStack(alignment: .bottomLeading) {\n            configuration.icon\n                .resizable()\n                .aspectRatio(400\/240, contentMode: .fit)\n                .overlay {\n                    LinearGradient(\n                        stops: [\n                            .init(color: .black.opacity(0.6), location: 0.1),\n                            .init(color: .black.opacity(0.2), location: 0.25),\n                            .init(color: .black.opacity(0), location: 0.4)\n                        ],\n                        startPoint: .bottom, endPoint: .top\n                    )\n                }\n                .overlay {\n                    RoundedRectangle(cornerRadius: 12)\n                        .stroke(lineWidth: 2)\n                        .foregroundStyle(.quaternary)\n                }\n\n            configuration.title\n                .font(.caption.bold())\n                .foregroundStyle(.secondary)\n                .padding(6)\n        }\n        .frame(maxWidth: 400)\n    }\n}\n\nButton { \/* action *\/ } label: {\n    Label(\"Title at the bottom\", image: \"discovery_landscape\")\n}",
      "language" : "swift"
    },
    {
      "code" : "ScrollView(.horizontal) {\n    LazyHStack(spacing: 40) {\n        ForEach(Asset.allCases) { asset in\n            \/\/ . . .\n        }\n    }\n}\n.scrollClipDisabled()\n.buttonStyle(.borderless)",
      "language" : "swift"
    },
    {
      "code" : "asset.portraitImage\n    .resizable()\n    .aspectRatio(250 \/ 375, contentMode: .fit)\n    .containerRelativeFrame(.horizontal, count: 6, spacing: 40)\nText(asset.title)",
      "language" : "swift"
    },
    {
      "code" : "VStack(alignment: .leading) {\n    \/\/ Header content.\n}\n.frame(maxWidth: .infinity, alignment: .leading)\n.focusSection()\n.containerRelativeFrame(.vertical, alignment: .topLeading) {\n    length, _ in length * 0.8\n}",
      "language" : "swift"
    },
    {
      "code" : ".onScrollVisibilityChange { visible in\n    \/\/ When the header scrolls more than 50% offscreen, toggle\n    \/\/ to the below-the-fold state.\n    withAnimation {\n        belowFold = !visible\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "Image(\"beach_landscape\")\n    .resizable()\n    .aspectRatio(contentMode: .fill)\n    .overlay {\n        \/\/ Build the gradient material by filling an area with a material, and\n        \/\/ then masking that area using a linear gradient.\n        Rectangle()\n            .fill(.regularMaterial)\n            .mask {\n                LinearGradient(\n                    stops: [\n                        .init(color: .black, location: 0.25),\n                        .init(color: .black.opacity(belowFold ? 1 : 0.3), location: 0.375),\n                        .init(color: .black.opacity(belowFold ? 1 : 0), location: 0.5)\n                    ],\n                    startPoint: .bottom, endPoint: .top\n                )\n            }\n    }\n    .ignoresSafeArea()",
      "language" : "swift"
    },
    {
      "code" : "ScrollView {\n    \/\/ . . .\n}\n.scrollTargetBehavior(\n    FoldSnappingScrollTargetBehavior(\n        aboveFold: !belowFold, showcaseHeight: showcaseHeight))\n\nstruct FoldSnappingScrollTargetBehavior: ScrollTargetBehavior {\n    var aboveFold: Bool\n    var showcaseHeight: CGFloat\n\n    func updateTarget(_ target: inout ScrollTarget, context: TargetContext) {\n        \/\/ The view is above the fold and not moving far enough down, so make no\n        \/\/ change.\n        if aboveFold && target.rect.minY < showcaseHeight * 0.3 {\n            return\n        }\n\n        \/\/ The view is below the fold, and the header isn't coming onscreen, so\n        \/\/ make no change.\n        if !aboveFold && target.rect.minY > showcaseHeight {\n            return\n        }\n\n        \/\/ Upward movement: Require revealing over 30% of the header, or don't let\n        \/\/ the scroll go upward.\n        let showcaseRevealThreshold = showcaseHeight * 0.7\n        let snapToHideRange = showcaseRevealThreshold...showcaseHeight\n\n        if aboveFold || snapToHideRange.contains(target.rect.origin.y) {\n            \/\/ Snap to align the first content shelf at the top of the screen.\n            target.rect.origin.y = showcaseHeight\n        }\n        else {\n            \/\/ Snap upward to reveal the header.\n            target.rect.origin.y = 0\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "VStack(spacing: 12) {\n    Button { \/* action *\/ } label: {\n        Text(\"Sign Up\")\n            .font(.body.bold())\n            .frame(maxWidth: .infinity)\n    }\n\n    Button { \/* action *\/ } label: {\n        Text(\"Buy or Rent\")\n            .font(.body.bold())\n            .frame(maxWidth: .infinity)\n    }\n\n    Button { \/* action *\/ } label: {\n        Label(\"Add to Up Next\", systemImage: \"plus\")\n            .font(.body.bold())\n            .frame(maxWidth: .infinity)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : ".fullScreenCover(isPresented: $showDescription) {\n    VStack(alignment: .center) {\n        Text(loremIpsum)\n            .frame(maxWidth: 600)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "ScrollView(.vertical) {\n    LazyVGrid(\n        columns: Array(repeating: .init(.flexible(), spacing: 40), count: 4), \n        spacing: 40\n    ) {\n        ForEach(\/* matching assets, sorted *\/) { asset in\n            Button { \/* action *\/ } label: {\n                asset.landscapeImage\n                    .resizable()\n                    .aspectRatio(16 \/ 9, contentMode: .fit)\n                Text(asset.title)\n            }\n        }\n    }\n    .buttonStyle(.borderless)\n}\n.scrollClipDisabled()\n.searchable(text: $searchTerm)\n.searchSuggestions {\n    ForEach(\/* keywords matching search term *\/, id: \\.self) { suggestion in\n        Text(suggestion)\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "e43a0878eab6346dd1b24b6f157a6f97cc5bbaa50ac0546d711d78f8be32b48e",
  "crawledAt" : "2025-12-02T15:32:49Z",
  "id" : "932A0051-7826-4FB1-ACA6-7E90E3721611",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nThis sample code project shows how to create the standard content lockups for tvOS, and provides best practices for building out rows of content shelves. It also includes examples for product pages, search views, and tab views, including the new sidebar adaptive tab view style that provides a sidebar in tvOS.\n\nThe sample project contains the following examples:\n\n### Create content lockups\n\nThe [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PrimitiveButtonStyle\/borderless] button style provides the primary lockup style you use in tvOS, including all the focus interactions and hover effects. The button’s title and any nearby section titles automatically move out of the way of the button’s image as it scales up on focus.\n\n\n\nProvide a separate [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Image] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view in the button’s label closure to ensure the correct vertical appearance. Using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Label] usually results in a horizontal layout, and, depending on the current label style, may not give you the appearance you expect.\n\nBy default, the button style locates the first `Image` within the button’s label and attaches a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/HoverEffect\/highlight] hover effect to it, providing lift, a specular highlight, and gimbal motion effects.\n\nTo ensure the hover effect applies to exactly the right view, you can manually attach it to a particular subview of the button’s label using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/hoverEffect(_:)] modifier. For instance, to ensure an SF Symbols image hovers along with its background, do the following:\n\nYou can also attach the hover effect to a custom view.\n\n### Show information-dense lockups\n\nFor lockups with more dense information, consider using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PrimitiveButtonStyle\/card] button style, which provides a platter and a more subtle motion effect on focus. Providing containers with padding as the button’s label gives you something similar to the search result lockups on the Apple TV app.\n\n\n\nYou can also use a custom [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LabelStyle] to create a standard card-based lockup appearance while keeping your button’s declarations clean at the point of use.\n\n### Display content shelves\n\nContent shelves are usually horizontal stacks in scroll views.\n\n\n\nDisabling scroll clipping is necessary to allow the focus effects to scale up and lift each lockup. Shelves typically contain only a single style of lockup, so assign your button style on the outside of the shelf container.\n\nTo arrange your lockups nicely, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/containerRelativeFrame(_:count:span:spacing:alignment:)] modifier to let SwiftUI determine the best size for each. You can specify how many lockups you want on the screen, and the amount of spacing your stack view provides. Then SwiftUI arranges the content so that the edges of the leading and trailing items align with the leading and trailing safe area insets of its container.\n\nFor borderless buttons, you can attach the modifier to the `Image` instance within the button’s label closure to make the image the source of the frame calculations and alignments.\n\n### Show content above and below the fold\n\nFor a landing page you can implement above- and below-the-fold appearances through a combination of [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ScrollTargetBehavior] and a background view with a gradient mask.\n\n\n\nDefine your showcase or header section as a stack with a container relative frame to make it take up a particular percentage of the available space. Attach a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/focusSection()] modifier to the stack as well, so that its full width can act as a target for focus movement, which it then diverts to its content. Otherwise, moving focus up from the right side of the shelves below might fail, or might jump all the way to the tab bar because the focus engine searches for the nearest focusable view along a straight line from the currently focused item.\n\nThe code above is the above-the-fold section. To detect when focus moves below the fold, use [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/onScrollVisibilityChange(threshold:_:)] to detect when the header view moves more than halfway off the screen.\n\nYou can define the background of your landing page using a full-screen image with a material in an overlay. Then you can turn the material into a gradient by masking it with a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LinearGradient], and you can adjust the opacity of that gradient’s stops according to the view’s above- or below-the-fold status.\n\nBy adjusting the opacity of the gradient stops, rather than swapping out the mask view, you achieve a smooth animation between the above-the-fold appearance, where the material fades out above a certain height to reveal the image behind, and the below-the-fold appearance where the entire image blurs.\n\n### Snap at the fold point\n\nYou can implement a custom [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ScrollTargetBehavior] to create a fold-snapping effect. Then add a check to determine whether the target of a scroll event is crossing a fold threshold, and update that target to either the top of the page (if moving upward) or to the top of your first content shelf (if moving downward). With your view already tracking the above\/below fold state, it can pass that information into the behavior to indicate which operation to check for.\n\n### Provide product highlight pages\n\nIt’s common for product pages to use a material gradient appearance with above- and below-the-fold snapping. You most likely need to tune the gradient a little differently to account for a taller bar of content at the bottom of the screen, but you typically want to keep the content’s showcase image, with a suitable blur, as a background for the view when scrolling below.\n\n\n\nThis makes each product’s page unique, with its defining artwork tinting the content. This is the same effect that root screen on the Apple TV uses — the system blurs the most recently displayed top-shelf image and uses it as the background of the tvOS home screen.\n\nIn your description view, you may want to display a stack of bordered buttons, and stretch each to the same width. SwiftUI implements bordered buttons by attaching a background to their labels, so increasing the size of the button view isn’t necessarily going to cause the background platter to grow. Instead, you need to specify that the *label content* is able to expand, and its background then expands as well. Attaching a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:)] modifier to the button’s label content achieves this for you.\n\nWhen displaying your content’s description, allow it to truncate on the page, and place it within a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Button] using the `.plain` style. People can then select it, and you can present the full description using an overlay view that you attach with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/fullScreenCover(isPresented:onDismiss:content:)] modifier.\n\n### Search for content\n\nFor your search page, prefer using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LazyVGrid] to contain your results, and a landscape orientation for the lockups themselves. This allows more content to appear onscreen at one time, with several rows of three to five items per row. A tall content container area makes it much easier to see the effects of changes to your search term.\n\n\n\nThe search implementation consists of simple view modifiers that function identically on each Apple platform. The [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/searchable(text:placement:prompt:)-18a8f] modifier provides the entire search UI for you, binding the search field to the provided text. By attaching a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/searchSuggestions(_:)] modifier, you can present a list of potential search keyword completions. These are commonly `Text` instances, but `Button` and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Label] also work.\n\nBe sure to sort your search results so that the content of your grid is stable and predictable.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/Creating-a-tvOS-media-catalog-app-in-SwiftUI\ncrawled: 2025-12-02T15:32:49Z\n---\n\n# Creating a tvOS media catalog app in SwiftUI\n\n**Sample Code**\n\nBuild standard content lockups and rows of content shelves for your tvOS app.\n\n## Overview\n\nThis sample code project shows how to create the standard content lockups for tvOS, and provides best practices for building out rows of content shelves. It also includes examples for product pages, search views, and tab views, including the new sidebar adaptive tab view style that provides a sidebar in tvOS.\n\n\n\nThe sample project contains the following examples:\n\n- `StackView` implements an example landing page for a content catalog app, defining several shelves with a showcase or hero header area above them. It also gives an example of an above- and below-the-fold switching animation.\n- `ButtonsView` provides a showcase of the various button styles available in tvOS.\n- `DescriptionView` provides an example of how to build a product page similar to those you see on the Apple TV app, with a custom material blur.\n- `SearchView` shows an example of a simple search page using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/searchable(text:placement:prompt:)-18a8f] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/searchSuggestions(_:)] modifiers.\n- `SidebarContentView` shows how to make a sectioned sidebar using the new tab bar APIs in tvOS 18.\n- `HeroHeaderView` gives an example of creating a material gradient to blur content in a certain area, fading it into unblurred content.\n\n### Create content lockups\n\nThe [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PrimitiveButtonStyle\/borderless] button style provides the primary lockup style you use in tvOS, including all the focus interactions and hover effects. The button’s title and any nearby section titles automatically move out of the way of the button’s image as it scales up on focus.\n\n\n\nProvide a separate [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Image] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Text] view in the button’s label closure to ensure the correct vertical appearance. Using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Label] usually results in a horizontal layout, and, depending on the current label style, may not give you the appearance you expect.\n\n```swift\nButton { \/* action *\/ } label: {\n    Image(\"discovery_portrait\")\n        .resizable()\n        .frame(width: 250, height: 375)\n    Text(\"Borderless Portrait\")\n}\n```\n\nBy default, the button style locates the first `Image` within the button’s label and attaches a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/HoverEffect\/highlight] hover effect to it, providing lift, a specular highlight, and gimbal motion effects.\n\nTo ensure the hover effect applies to exactly the right view, you can manually attach it to a particular subview of the button’s label using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/hoverEffect(_:)] modifier. For instance, to ensure an SF Symbols image hovers along with its background, do the following:\n\n```swift\nButton { \/* action *\/ } label: {\n    Image(systemName: \"person.circle\")\n        .font(.title)\n        .background(Color.blue.grayscale(0.7))\n        .hoverEffect(.highlight)\n    Text(\"Shaped\")\n}\n.buttonBorderShape(.circle)\n```\n\nYou can also attach the hover effect to a custom view.\n\n```swift\nButton { \/* action *\/ } label: {\n    CodeSampleArtwork(size: .appIconSize)\n        .frame(width: 400, height: 240)\n        .hoverEffect(.highlight)\n    Text(\"Custom Icon View\")\n}\n```\n\n### Show information-dense lockups\n\nFor lockups with more dense information, consider using the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PrimitiveButtonStyle\/card] button style, which provides a platter and a more subtle motion effect on focus. Providing containers with padding as the button’s label gives you something similar to the search result lockups on the Apple TV app.\n\n\n\n```swift\nButton { \/* action *\/ } label: {\n    HStack(alignment: .top, spacing: 10) {\n        Image( . . . )\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .clipShape(RoundedRectangle(cornerRadius: 12))\n\n        VStack(alignment: .leading) {\n            Text(asset.title)\n                .font(.body)\n            Text(\"Subtitle text goes here, limited to two lines.\")\n                .font(.caption2)\n                .foregroundStyle(.secondary)\n                .lineLimit(2)\n            Spacer(minLength: 0)\n            HStack(spacing: 4) {\n                ForEach(1..<4) { _ in\n                    Image(systemName: \"ellipsis.rectangle.fill\")\n                }\n            }\n            .foregroundStyle(.secondary)\n        }\n    }\n    .padding(12)\n}\n```\n\nYou can also use a custom [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LabelStyle] to create a standard card-based lockup appearance while keeping your button’s declarations clean at the point of use.\n\n```swift\nstruct CardOverlayLabelStyle: LabelStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        ZStack(alignment: .bottomLeading) {\n            configuration.icon\n                .resizable()\n                .aspectRatio(400\/240, contentMode: .fit)\n                .overlay {\n                    LinearGradient(\n                        stops: [\n                            .init(color: .black.opacity(0.6), location: 0.1),\n                            .init(color: .black.opacity(0.2), location: 0.25),\n                            .init(color: .black.opacity(0), location: 0.4)\n                        ],\n                        startPoint: .bottom, endPoint: .top\n                    )\n                }\n                .overlay {\n                    RoundedRectangle(cornerRadius: 12)\n                        .stroke(lineWidth: 2)\n                        .foregroundStyle(.quaternary)\n                }\n\n            configuration.title\n                .font(.caption.bold())\n                .foregroundStyle(.secondary)\n                .padding(6)\n        }\n        .frame(maxWidth: 400)\n    }\n}\n\nButton { \/* action *\/ } label: {\n    Label(\"Title at the bottom\", image: \"discovery_landscape\")\n}\n```\n\n### Display content shelves\n\nContent shelves are usually horizontal stacks in scroll views.\n\n\n\nDisabling scroll clipping is necessary to allow the focus effects to scale up and lift each lockup. Shelves typically contain only a single style of lockup, so assign your button style on the outside of the shelf container.\n\n```swift\nScrollView(.horizontal) {\n    LazyHStack(spacing: 40) {\n        ForEach(Asset.allCases) { asset in\n            \/\/ . . .\n        }\n    }\n}\n.scrollClipDisabled()\n.buttonStyle(.borderless)\n```\n\nTo arrange your lockups nicely, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/containerRelativeFrame(_:count:span:spacing:alignment:)] modifier to let SwiftUI determine the best size for each. You can specify how many lockups you want on the screen, and the amount of spacing your stack view provides. Then SwiftUI arranges the content so that the edges of the leading and trailing items align with the leading and trailing safe area insets of its container.\n\nFor borderless buttons, you can attach the modifier to the `Image` instance within the button’s label closure to make the image the source of the frame calculations and alignments.\n\n```swift\nasset.portraitImage\n    .resizable()\n    .aspectRatio(250 \/ 375, contentMode: .fit)\n    .containerRelativeFrame(.horizontal, count: 6, spacing: 40)\nText(asset.title)\n```\n\n### Show content above and below the fold\n\nFor a landing page you can implement above- and below-the-fold appearances through a combination of [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ScrollTargetBehavior] and a background view with a gradient mask.\n\n\n\nDefine your showcase or header section as a stack with a container relative frame to make it take up a particular percentage of the available space. Attach a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/focusSection()] modifier to the stack as well, so that its full width can act as a target for focus movement, which it then diverts to its content. Otherwise, moving focus up from the right side of the shelves below might fail, or might jump all the way to the tab bar because the focus engine searches for the nearest focusable view along a straight line from the currently focused item.\n\n```swift\nVStack(alignment: .leading) {\n    \/\/ Header content.\n}\n.frame(maxWidth: .infinity, alignment: .leading)\n.focusSection()\n.containerRelativeFrame(.vertical, alignment: .topLeading) {\n    length, _ in length * 0.8\n}\n```\n\nThe code above is the above-the-fold section. To detect when focus moves below the fold, use [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/onScrollVisibilityChange(threshold:_:)] to detect when the header view moves more than halfway off the screen.\n\n```swift\n.onScrollVisibilityChange { visible in\n    \/\/ When the header scrolls more than 50% offscreen, toggle\n    \/\/ to the below-the-fold state.\n    withAnimation {\n        belowFold = !visible\n    }\n}\n```\n\nYou can define the background of your landing page using a full-screen image with a material in an overlay. Then you can turn the material into a gradient by masking it with a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LinearGradient], and you can adjust the opacity of that gradient’s stops according to the view’s above- or below-the-fold status.\n\n```swift\nImage(\"beach_landscape\")\n    .resizable()\n    .aspectRatio(contentMode: .fill)\n    .overlay {\n        \/\/ Build the gradient material by filling an area with a material, and\n        \/\/ then masking that area using a linear gradient.\n        Rectangle()\n            .fill(.regularMaterial)\n            .mask {\n                LinearGradient(\n                    stops: [\n                        .init(color: .black, location: 0.25),\n                        .init(color: .black.opacity(belowFold ? 1 : 0.3), location: 0.375),\n                        .init(color: .black.opacity(belowFold ? 1 : 0), location: 0.5)\n                    ],\n                    startPoint: .bottom, endPoint: .top\n                )\n            }\n    }\n    .ignoresSafeArea()\n```\n\nBy adjusting the opacity of the gradient stops, rather than swapping out the mask view, you achieve a smooth animation between the above-the-fold appearance, where the material fades out above a certain height to reveal the image behind, and the below-the-fold appearance where the entire image blurs.\n\n### Snap at the fold point\n\nYou can implement a custom [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/ScrollTargetBehavior] to create a fold-snapping effect. Then add a check to determine whether the target of a scroll event is crossing a fold threshold, and update that target to either the top of the page (if moving upward) or to the top of your first content shelf (if moving downward). With your view already tracking the above\/below fold state, it can pass that information into the behavior to indicate which operation to check for.\n\n```swift\nScrollView {\n    \/\/ . . .\n}\n.scrollTargetBehavior(\n    FoldSnappingScrollTargetBehavior(\n        aboveFold: !belowFold, showcaseHeight: showcaseHeight))\n\nstruct FoldSnappingScrollTargetBehavior: ScrollTargetBehavior {\n    var aboveFold: Bool\n    var showcaseHeight: CGFloat\n\n    func updateTarget(_ target: inout ScrollTarget, context: TargetContext) {\n        \/\/ The view is above the fold and not moving far enough down, so make no\n        \/\/ change.\n        if aboveFold && target.rect.minY < showcaseHeight * 0.3 {\n            return\n        }\n\n        \/\/ The view is below the fold, and the header isn't coming onscreen, so\n        \/\/ make no change.\n        if !aboveFold && target.rect.minY > showcaseHeight {\n            return\n        }\n\n        \/\/ Upward movement: Require revealing over 30% of the header, or don't let\n        \/\/ the scroll go upward.\n        let showcaseRevealThreshold = showcaseHeight * 0.7\n        let snapToHideRange = showcaseRevealThreshold...showcaseHeight\n\n        if aboveFold || snapToHideRange.contains(target.rect.origin.y) {\n            \/\/ Snap to align the first content shelf at the top of the screen.\n            target.rect.origin.y = showcaseHeight\n        }\n        else {\n            \/\/ Snap upward to reveal the header.\n            target.rect.origin.y = 0\n        }\n    }\n}\n```\n\n### Provide product highlight pages\n\nIt’s common for product pages to use a material gradient appearance with above- and below-the-fold snapping. You most likely need to tune the gradient a little differently to account for a taller bar of content at the bottom of the screen, but you typically want to keep the content’s showcase image, with a suitable blur, as a background for the view when scrolling below.\n\n\n\nThis makes each product’s page unique, with its defining artwork tinting the content. This is the same effect that root screen on the Apple TV uses — the system blurs the most recently displayed top-shelf image and uses it as the background of the tvOS home screen.\n\nIn your description view, you may want to display a stack of bordered buttons, and stretch each to the same width. SwiftUI implements bordered buttons by attaching a background to their labels, so increasing the size of the button view isn’t necessarily going to cause the background platter to grow. Instead, you need to specify that the *label content* is able to expand, and its background then expands as well. Attaching a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/frame(minWidth:idealWidth:maxWidth:minHeight:idealHeight:maxHeight:alignment:)] modifier to the button’s label content achieves this for you.\n\n```swift\nVStack(spacing: 12) {\n    Button { \/* action *\/ } label: {\n        Text(\"Sign Up\")\n            .font(.body.bold())\n            .frame(maxWidth: .infinity)\n    }\n\n    Button { \/* action *\/ } label: {\n        Text(\"Buy or Rent\")\n            .font(.body.bold())\n            .frame(maxWidth: .infinity)\n    }\n\n    Button { \/* action *\/ } label: {\n        Label(\"Add to Up Next\", systemImage: \"plus\")\n            .font(.body.bold())\n            .frame(maxWidth: .infinity)\n    }\n}\n```\n\nWhen displaying your content’s description, allow it to truncate on the page, and place it within a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Button] using the `.plain` style. People can then select it, and you can present the full description using an overlay view that you attach with the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/fullScreenCover(isPresented:onDismiss:content:)] modifier.\n\n```swift\n.fullScreenCover(isPresented: $showDescription) {\n    VStack(alignment: .center) {\n        Text(loremIpsum)\n            .frame(maxWidth: 600)\n    }\n}\n```\n\n### Search for content\n\nFor your search page, prefer using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LazyVGrid] to contain your results, and a landscape orientation for the lockups themselves. This allows more content to appear onscreen at one time, with several rows of three to five items per row. A tall content container area makes it much easier to see the effects of changes to your search term.\n\n\n\nThe search implementation consists of simple view modifiers that function identically on each Apple platform. The [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/searchable(text:placement:prompt:)-18a8f] modifier provides the entire search UI for you, binding the search field to the provided text. By attaching a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/searchSuggestions(_:)] modifier, you can present a list of potential search keyword completions. These are commonly `Text` instances, but `Button` and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Label] also work.\n\nBe sure to sort your search results so that the content of your grid is stable and predictable.\n\n```swift\nScrollView(.vertical) {\n    LazyVGrid(\n        columns: Array(repeating: .init(.flexible(), spacing: 40), count: 4), \n        spacing: 40\n    ) {\n        ForEach(\/* matching assets, sorted *\/) { asset in\n            Button { \/* action *\/ } label: {\n                asset.landscapeImage\n                    .resizable()\n                    .aspectRatio(16 \/ 9, contentMode: .fit)\n                Text(asset.title)\n            }\n        }\n    }\n    .buttonStyle(.borderless)\n}\n.scrollClipDisabled()\n.searchable(text: $searchTerm)\n.searchSuggestions {\n    ForEach(\/* keywords matching search term *\/, id: \\.self) { suggestion in\n        Text(suggestion)\n    }\n}\n```\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Creating a tvOS media catalog app in SwiftUI",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Creating-a-tvOS-media-catalog-app-in-SwiftUI"
}