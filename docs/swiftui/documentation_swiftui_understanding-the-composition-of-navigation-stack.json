{
  "abstract" : "Learn about the navigation stack, links, and how to manage navigation types in your app’s structure.",
  "codeExamples" : [
    {
      "code" : "struct DestinationView: View {\n    var body: some View {\n        NavigationStack {\n            NavigationLink {\n                ColorDetail(color: .mint, text: \"Mint\")\n            } label: {\n                Text(\"Mint\")\n            }\n            \n            NavigationLink {\n                ColorDetail(color: .red, text: \"Red\")\n            } label: {\n                Text(\"Red\")\n            }\n        }\n    }\n}\n\nstruct ColorDetail: View {\n    var color: Color\n    var text: String\n\n    var body: some View {\n        VStack {\n            Text(text)\n            color\n         }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct DestinationView: View { \n    @State private var showDetails = false\n    var favoriteColor: Color\n    \n    NavigationStack {\n        VStack {\n            Circle()\n                .fill(favoriteColor)\n            Button(\"Show details\") {\n                showDetails = true\n            }\n        }\n        .navigationDestination(isPresented: $showDetails) {\n            ColorDetail(color: favoriteColor, text: color.description)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "NavigationStack {\n    List {\n        NavigationLink(\"Mint\", value: Color.mint)\n        NavigationLink(\"Red\", value: Color.red)\n    }\n    .navigationDestination(for: Color.self) { color in\n        ColorDetail(color: color, text: color.description)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ValueView: View {\n    private var recipes: [Recipe] = [.applePie, .chocolateCake]\n    \n    var body: some View {\n        NavigationStack {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n                ForEach(recipes) { recipe in\n                    NavigationLink(recipe.description, value: recipe)\n                }\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color, text: color.description)\n            }\n            .navigationDestination(for: Recipe.self) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}\n\nstruct RecipeDetailView: View {\n    var recipe: Recipe\n    \n    var body: some View {\n        Text(recipe.description)\n    }\n}\n\nenum Recipe: Identifiable, Hashable, Codable {\n    case applePie\n    case chocolateCake\n    \n    var id: Self { self }\n    \n    var description: String {\n        switch self {\n        case .applePie:\n            return \"Apple Pie\"\n        case .chocolateCake:\n            return \"Chocolate Cake\"\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ContentView: View {\n    private var recipes: [Recipe] = [.applePie, .chocolateCake]\n    @State private var selectedRecipe: Recipe?\n    \n    var body: some View {\n        NavigationStack {\n            List(recipes, selection: $selectedRecipe) { recipe in\n                NavigationLink(recipe.description, value: recipe)\n            }\n            .navigationDestination(item: $selectedRecipe) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ContentView: View {\n    @State private var path = NavigationPath()\n\n    var body: some View {\n        NavigationStack(path: $path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Observable\nclass NavigationManager {\n    var path: [Color] = [] {\n        willSet {\n            print(\"will set to \\(newValue)\")\n        }\n        \n        didSet {\n            print(\"didSet to \\(path)\")\n        }\n    }\n}\n\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color, text: color.description)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Observable\nclass NavigationManager {\n    var path: [Color] = [] {\n        willSet {\n            print(\"will set to \\(newValue)\")\n        }\n        \n        didSet {\n            print(\"didSet to \\(path)\")\n        }\n    }\n    \n    @discardableResult\n    func navigateBack() -> Color? {\n        path.popLast()\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ValueView: View {\n    @State private var path = NavigationPath()\n    \n    var body: some View {\n        NavigationStack(path: $path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n                NavigationLink(\"Apple Pie\", value: Recipe.applePie)\n                NavigationLink(\"Chocolate Cake\", value: Recipe.chocolateCake)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color)\n            }\n            .navigationDestination(for: Recipe.self) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            NavigationLink(\"View Mint Color\", value: Color.mint)\n                .navigationDestination(for: Color.self) { color in\n                    NavigationLink(\"Push Recipe View\") {\n                        RecipeDetailView(recipe: .applePie)\n                    }\n                }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "Root → [Color.mint] → [RecipeDetailView]",
      "language" : "swift"
    },
    {
      "code" : "struct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            NavigationLink(\"View Mint Color\", value: Color.mint)\n                .navigationDestination(for: Color.self) { color in\n                    NavigationLink(\"Push Recipe View\") {\n                        NavigationLink(\"Push another view\", value: Color.pink)\n                    }\n                }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Observable\nclass NavigationManager {\n    var path: [Color] = [] {\n        didSet {\n            print(\"didSet to \\(path)\")\n        }\n    }\n}\n\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            NavigationLink(\"View Mint Color\", value: Color.mint)\n                .navigationDestination(for: Color.self) { color in\n                    NavigationLink(\"Push Recipe View\") {\n                        RecipeDetailView(recipe: .applePie)\n                    }\n                }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "New path: []\nNew Path: [Color.mint]",
      "language" : "swift"
    },
    {
      "code" : "@Observable\nclass NavigationManager {\n    var path: [Recipe] = [] {\n        didSet {\n            save()\n        }\n    }\n    \n    \/\/\/ The URL for the JSON file that stores the navigation path.\n    private static var dataURL: URL {\n        .documentsDirectory.appending(path: \"NavigationPath.json\")\n    }\n    \n    init() {\n        do {\n            \/\/ Load the data model from the 'NavigationPath' data file found in the Documents directory.\n            let path = try load(url: NavigationManager.dataURL)\n            self.path = path\n        } catch {\n            \/\/ Handle error.\n        }\n    }\n    \n    func save() {\n        let encoder = JSONEncoder()\n        do {\n            let data = try encoder.encode(path)\n            try data.write(to: NavigationManager.dataURL)\n        } catch {\n            \/\/ Handle error.\n        }\n    }\n    \n    \/\/\/ Load the navigation path from a previously saved state.\n    func load(url: URL) throws -> [Recipe] {\n        let data = try Data(contentsOf: url, options: .mappedIfSafe)\n        let decoder = JSONDecoder()\n        return try decoder.decode([Recipe].self, from: data)\n    }\n}\n\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n                NavigationLink(\"Apple Pie\", value: Recipe.applePie)\n                NavigationLink(\"Chocolate Cake\", value: Recipe.chocolateCake)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color, text: color.description)\n            }\n            .navigationDestination(for: Recipe.self) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "@Observable\nclass NavigationManager {\n    var path = NavigationPath() {\n        didSet {\n            save()\n        }\n    }\n    \n    \/\/\/ The URL for the JSON file that stores the navigation path.\n    private static var dataURL: URL {\n        .documentsDirectory.appending(path: \"NavigationPath.json\")\n    }\n    \n    init() {\n        do {\n            \/\/ Load the data model from the 'NavigationPath' data file found in the Documents directory.\n            let path = try load(url: NavigationManager.dataURL)\n            self.path = path\n        } catch {\n            \/\/ Handle error\n        }\n    }\n    \n    func save() {\n        guard let codableRepresentation = path.codable else { return }\n        let encoder = JSONEncoder()\n        do {\n            let data = try encoder.encode(codableRepresentation)\n            try data.write(to: NavigationManager.dataURL)\n        } catch {\n            \/\/Handle error.\n        }\n    }\n    \n    \/\/\/ Load the navigation path from a previously saved data.\n    func load(url: URL) throws -> NavigationPath {\n        let data = try Data(contentsOf: url, options: .mappedIfSafe)\n        let decoder = JSONDecoder()\n        let path = try decoder.decode(NavigationPath.CodableRepresentation.self, from: data)\n        return NavigationPath(path)\n    }\n}\n",
      "language" : "swift"
    }
  ],
  "contentHash" : "7a2b1e807ebfbd70a196c3fcd85704076e1ca4eca6ab01b2b0c2d4a2cae80c67",
  "crawledAt" : "2025-12-02T17:29:29Z",
  "id" : "E50397D6-1914-426A-8C2C-45254708CAB9",
  "kind" : "article",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nA [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationStack] is a container for your app’s navigation structure. Use a navigation stack to present a stack of views over a root view.\n\nA `NavigationStack` exposes its state to your app with the path parameter of its initializer. To create a navigation stack with a path that you can control or track views on the navigation stack, use a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationPath] or a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] to a [doc:\/\/com.apple.documentation\/documentation\/Swift\/RandomAccessCollection] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/RangeReplaceableCollection] that contains [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable] elements.\n\nA `NavigationPath` is a type-erased collection on which you can store a heterogenous list of data. For homogenous data, use an [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array] instead. Because `NavigationPath` is type-erased, it can represent different types of data that correspond to a view in the navigation stack.\n\nAnother element of the navigation stack is the *navigation destination*, which encapsulates the views people can navigate to within your app.\n\nYou can present destinations on a `NavigationStack` using:\n\n### Present view–destination links\n\nYou can push a view onto a `NavigationStack` using `NavigationLink(destination:label:)`. With this initializer, you specify both a label—displayed on the link itself—and a destination—displayed when someone taps the link.\n\nEnclose a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink] in a navigation structure higher up in the view-hierarchy—an ancestor view, for example. If this condition isn’t met, the link typically appears as disabled.\n\nBelow is an example with two links inside a `NavigationStack`:\n\nIn this example, tapping the label titled “Mint” pushes a `ColorDetail(color: .mint, text: \"Mint\")` view onto the navigation stack. The navigation stack contents are the root view (the `NavigationLink` itself) at depth `0`, and `ColorDetail(color: .mint, text: \"Mint\")`  at depth `1`.\n\nWhen you use [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink\/init(destination:label:)], note that:\n\nUse the stateful navigation techniques described in [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Understanding-the-composition-of-navigation-stack#Manage-navigation-state-and-compose-links] to track when a navigation link triggers, instead of [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/onAppear(perform:)] or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/task(priority:_:)].\n\nUse a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/navigationDestination(isPresented:destination:)] modifier to navigate programmatically by providing a binding to a `Boolean` value. For example, you can programmatically push `ColorDetail` view onto the stack:\n\nUse this approach when you want to navigate based on toggling state rather than by people’s interaction, or when your app presents a one-off destination with a different data type than the homogenous path of the navigation stack.\n\n### Present value-destination links\n\nWhen you add data to the navigation path, SwiftUI maps the data type to a view, then pushes it onto the navigation stack when someone taps the link. To describe the view the stack displays, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/navigationDestination(for:destination:)] view modifier inside a `NavigationStack`.\n\nThe following example implements `DestinationView` as a series of navigation links:\n\nIn the example above, SwiftUI uses the value type—in this case, `Color`—to determine the appropriate navigation destination. With value-based navigation, you can define a variety of possible destinations for a single stack When someone taps “Mint”, SwiftUI pushes `ColorDetail` view with a value `.mint` onto the stack.\n\nValue-based navigation shines in scenarios with mixed destination types. You can extend your app to handle recipe-related content in addition to colors:\n\nIn this example, the `NavigationStack` supports two destination types: `Color` for colors, and `Recipe` for recipes. SwiftUI determines the correct destination view based on the data type of the value from the navigation link.\n\nUse [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/navigationDestination(item:destination:)] when you need to navigate to a view based on the presence of an item. When the item binding is non-nil, SwiftUI passes the value into the destination closure and pushes the view onto the stack. For example:\n\nWhen a person taps a recipe, `selectedRecipe` value updates and SwiftUI pushes `RecipeDetailView(recipe: recipe)` onto the navigation stack. You can pop the view off the stack by setting `selectedRecipe` back to nil.\n\n### Manage navigation state and compose links\n\nBy default, a navigation stack manages state to keep track of the views on the stack. However, your app can share control of the state by initializing the stack with a binding to a collection of data values that you create.\n\nUse [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationStack\/init(path:root:)], which takes a binding to a `NavigationPath` argument, when you want to observe the navigation state for this stack.\n\nThe `NavigationPath` data type is a heterogeneous collection type that accepts any `Hashable` values. You can add to the path by calling [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationPath\/append(_:)] or when people tap value-destination links such as [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink\/init(value:label:)].\n\nWhen you push a value onto the stack using [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink\/init(_:value:)], you append the value to the path, as shown below:\n\nIn this example, when someone activates a link, SwiftUI adds the corresponding value, such as `Color.mint`, to `path`. SwiftUI uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State] property called `path` to mange the state of the navigation stack.\n\n[doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationStack\/init(path:root:)] also provides an initializer in which the path parameter takes a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] to a `RandomAccessCollection` and a `RangeReplaceableCollection` argument. You can store the path as a property in an object that leverages the [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable()] macro data type, and use property observers such as `willSet` and `didSet` or the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/onChange(of:initial:_:)] modifier to respond to changes when the value-destination link triggers.\n\nIn this case, the navigation path is a homogenous collection type that accepts a standard type, such as `Array`, or a custom data type as shown below:\n\nIn the example above, the `willSet` and `didSet` property observers track when a navigation link triggers.\n\nYou can also use the reference to `path` variable to perform programmatic navigation. For example, you can pop a view off the stack:\n\nUse a standard type when your stack displays views that rely on a single type of data, and `NavigationPath` when you need to present multiple data types in a single stack, as in the following example:\n\nWhen composed together, the navigation APIs allow you to use both styles of links, depending on what works best.\n\nHere, when someone taps on the link “View Mint Color”, SwiftUI pushes the value-based destination link onto the stack, followed by a view-destination link:\n\nAfter the code in this example runs, and someone clicks each `NavigationLink`, the navigation stack builds up with three views:\n\nSwiftUI keeps track of the entire navigation path. The underlying data structure looks like the following example:\n\nConceptually, SwiftUI stacks view-based destinations on top of the value-based destinations in the stack’s navigation path. For example, the code below replaces `RecipeDetailView` from the above example with a `NavigationLink`:\n\nWhen you run the revised example, the view-destination link is still on the top of the stack.\n\nIf you use a heterogenous or homogeneous path on the stack, you may observe changes to the navigation path over time, as shown below:\n\nWhen someone navigates through the app, it prints the following logs:\n\nThe logs print because view-destination navigation links don’t cause any state changes that your app can observe. If you attempt to push a value while a view-destination link is on the stack, SwiftUI pops all view destinations and pushes the value’s destination onto the stack.\n\n### Restore state for navigation paths\n\nState restoration for a navigation path enables you restore your interface to the previous interaction point during a subsequent launch, providing continuity for people using your app.\n\nIn iOS, state restoration is especially important at the window or scene level, because windows come and go frequently. For this reason, it’s important to think about state restoration for navigation path in the same way you handle restoring your app’s state at the window or scene level. See [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/restoring-your-app-s-state-with-swiftui] to learn about storing scene data.\n\nUsing `Codable`, you can manually persist and load the navigation stack path in one of two ways, depending on whether the path data type is homogeneous or heterogeneous. Store a homogenous path as in the following example:\n\nIn the above example, when the `path` changes, `didSet` property observer triggers and the `save` function is called. The function saves the new path to disk enabling the app to restore it when initializing `NavigationManager`.\n\nStore a heterogeneous path using `NavigationPath`, as shown in the following example:\n\nIn the example above, the `save` method checks `path.codable` for nullability. This value describes the contents of the path in a serializable format. It returns `nil` if any of the type-erased elements of the path don’t conform to the `codable`.\n\nIt’s important to perform this check because `NavigationPath` doesn’t require the data types to conform to `Codable`. `NavigationPath` only needs the types to conform to `Hashable`, and as a result, you can’t verify that the navigation path is a valid representation of `Codable` at compile time.\n\nTo learn more about navigation stacks, links and paths, see [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Bringing-robust-navigation-structure-to-your-swiftui-app].",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/Understanding-the-composition-of-navigation-stack\ncrawled: 2025-12-02T17:29:29Z\n---\n\n# Understanding the navigation stack\n\n**Article**\n\nLearn about the navigation stack, links, and how to manage navigation types in your app’s structure.\n\n## Overview\n\nA [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationStack] is a container for your app’s navigation structure. Use a navigation stack to present a stack of views over a root view.\n\nA `NavigationStack` exposes its state to your app with the path parameter of its initializer. To create a navigation stack with a path that you can control or track views on the navigation stack, use a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationPath] or a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] to a [doc:\/\/com.apple.documentation\/documentation\/Swift\/RandomAccessCollection] and [doc:\/\/com.apple.documentation\/documentation\/Swift\/RangeReplaceableCollection] that contains [doc:\/\/com.apple.documentation\/documentation\/Swift\/Hashable] elements.\n\nA `NavigationPath` is a type-erased collection on which you can store a heterogenous list of data. For homogenous data, use an [doc:\/\/com.apple.documentation\/documentation\/Swift\/Array] instead. Because `NavigationPath` is type-erased, it can represent different types of data that correspond to a view in the navigation stack.\n\n\n\nAnother element of the navigation stack is the *navigation destination*, which encapsulates the views people can navigate to within your app.\n\nYou can present destinations on a `NavigationStack` using:\n\n\n\n\n\n### Present view–destination links\n\nYou can push a view onto a `NavigationStack` using `NavigationLink(destination:label:)`. With this initializer, you specify both a label—displayed on the link itself—and a destination—displayed when someone taps the link.\n\nEnclose a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink] in a navigation structure higher up in the view-hierarchy—an ancestor view, for example. If this condition isn’t met, the link typically appears as disabled.\n\nBelow is an example with two links inside a `NavigationStack`:\n\n```swift\nstruct DestinationView: View {\n    var body: some View {\n        NavigationStack {\n            NavigationLink {\n                ColorDetail(color: .mint, text: \"Mint\")\n            } label: {\n                Text(\"Mint\")\n            }\n            \n            NavigationLink {\n                ColorDetail(color: .red, text: \"Red\")\n            } label: {\n                Text(\"Red\")\n            }\n        }\n    }\n}\n\nstruct ColorDetail: View {\n    var color: Color\n    var text: String\n\n    var body: some View {\n        VStack {\n            Text(text)\n            color\n         }\n    }\n}\n```\n\nIn this example, tapping the label titled “Mint” pushes a `ColorDetail(color: .mint, text: \"Mint\")` view onto the navigation stack. The navigation stack contents are the root view (the `NavigationLink` itself) at depth `0`, and `ColorDetail(color: .mint, text: \"Mint\")`  at depth `1`.\n\nWhen you use [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink\/init(destination:label:)], note that:\n\n- SwiftUI tracks the navigation state and the content of the navigation path; however, there are no stateful hooks for your app that indicate when the system pushes a view.\n- Its state can’t be restored programmatically.\n\nUse the stateful navigation techniques described in [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Understanding-the-composition-of-navigation-stack#Manage-navigation-state-and-compose-links] to track when a navigation link triggers, instead of [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/onAppear(perform:)] or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/task(priority:_:)].\n\nUse a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/navigationDestination(isPresented:destination:)] modifier to navigate programmatically by providing a binding to a `Boolean` value. For example, you can programmatically push `ColorDetail` view onto the stack:\n\n```swift\nstruct DestinationView: View { \n    @State private var showDetails = false\n    var favoriteColor: Color\n    \n    NavigationStack {\n        VStack {\n            Circle()\n                .fill(favoriteColor)\n            Button(\"Show details\") {\n                showDetails = true\n            }\n        }\n        .navigationDestination(isPresented: $showDetails) {\n            ColorDetail(color: favoriteColor, text: color.description)\n        }\n    }\n}\n```\n\nUse this approach when you want to navigate based on toggling state rather than by people’s interaction, or when your app presents a one-off destination with a different data type than the homogenous path of the navigation stack.\n\n### Present value-destination links\n\nWhen you add data to the navigation path, SwiftUI maps the data type to a view, then pushes it onto the navigation stack when someone taps the link. To describe the view the stack displays, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/navigationDestination(for:destination:)] view modifier inside a `NavigationStack`.\n\nThe following example implements `DestinationView` as a series of navigation links:\n\n```swift\nNavigationStack {\n    List {\n        NavigationLink(\"Mint\", value: Color.mint)\n        NavigationLink(\"Red\", value: Color.red)\n    }\n    .navigationDestination(for: Color.self) { color in\n        ColorDetail(color: color, text: color.description)\n    }\n}\n```\n\nIn the example above, SwiftUI uses the value type—in this case, `Color`—to determine the appropriate navigation destination. With value-based navigation, you can define a variety of possible destinations for a single stack When someone taps “Mint”, SwiftUI pushes `ColorDetail` view with a value `.mint` onto the stack.\n\nValue-based navigation shines in scenarios with mixed destination types. You can extend your app to handle recipe-related content in addition to colors:\n\n```swift\nstruct ValueView: View {\n    private var recipes: [Recipe] = [.applePie, .chocolateCake]\n    \n    var body: some View {\n        NavigationStack {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n                ForEach(recipes) { recipe in\n                    NavigationLink(recipe.description, value: recipe)\n                }\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color, text: color.description)\n            }\n            .navigationDestination(for: Recipe.self) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}\n\nstruct RecipeDetailView: View {\n    var recipe: Recipe\n    \n    var body: some View {\n        Text(recipe.description)\n    }\n}\n\nenum Recipe: Identifiable, Hashable, Codable {\n    case applePie\n    case chocolateCake\n    \n    var id: Self { self }\n    \n    var description: String {\n        switch self {\n        case .applePie:\n            return \"Apple Pie\"\n        case .chocolateCake:\n            return \"Chocolate Cake\"\n        }\n    }\n}\n```\n\nIn this example, the `NavigationStack` supports two destination types: `Color` for colors, and `Recipe` for recipes. SwiftUI determines the correct destination view based on the data type of the value from the navigation link.\n\nUse [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/navigationDestination(item:destination:)] when you need to navigate to a view based on the presence of an item. When the item binding is non-nil, SwiftUI passes the value into the destination closure and pushes the view onto the stack. For example:\n\n```swift\nstruct ContentView: View {\n    private var recipes: [Recipe] = [.applePie, .chocolateCake]\n    @State private var selectedRecipe: Recipe?\n    \n    var body: some View {\n        NavigationStack {\n            List(recipes, selection: $selectedRecipe) { recipe in\n                NavigationLink(recipe.description, value: recipe)\n            }\n            .navigationDestination(item: $selectedRecipe) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}\n```\n\nWhen a person taps a recipe, `selectedRecipe` value updates and SwiftUI pushes `RecipeDetailView(recipe: recipe)` onto the navigation stack. You can pop the view off the stack by setting `selectedRecipe` back to nil.\n\n### Manage navigation state and compose links\n\nBy default, a navigation stack manages state to keep track of the views on the stack. However, your app can share control of the state by initializing the stack with a binding to a collection of data values that you create.\n\nUse [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationStack\/init(path:root:)], which takes a binding to a `NavigationPath` argument, when you want to observe the navigation state for this stack.\n\nThe `NavigationPath` data type is a heterogeneous collection type that accepts any `Hashable` values. You can add to the path by calling [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationPath\/append(_:)] or when people tap value-destination links such as [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink\/init(value:label:)].\n\nWhen you push a value onto the stack using [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationLink\/init(_:value:)], you append the value to the path, as shown below:\n\n```swift\nstruct ContentView: View {\n    @State private var path = NavigationPath()\n\n    var body: some View {\n        NavigationStack(path: $path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color)\n            }\n        }\n    }\n}\n```\n\nIn this example, when someone activates a link, SwiftUI adds the corresponding value, such as `Color.mint`, to `path`. SwiftUI uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/State] property called `path` to mange the state of the navigation stack.\n\n[doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/NavigationStack\/init(path:root:)] also provides an initializer in which the path parameter takes a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Binding] to a `RandomAccessCollection` and a `RangeReplaceableCollection` argument. You can store the path as a property in an object that leverages the [doc:\/\/com.apple.documentation\/documentation\/Observation\/Observable()] macro data type, and use property observers such as `willSet` and `didSet` or the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/onChange(of:initial:_:)] modifier to respond to changes when the value-destination link triggers.\n\nIn this case, the navigation path is a homogenous collection type that accepts a standard type, such as `Array`, or a custom data type as shown below:\n\n```swift\n@Observable\nclass NavigationManager {\n    var path: [Color] = [] {\n        willSet {\n            print(\"will set to \\(newValue)\")\n        }\n        \n        didSet {\n            print(\"didSet to \\(path)\")\n        }\n    }\n}\n\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color, text: color.description)\n            }\n        }\n    }\n}\n```\n\nIn the example above, the `willSet` and `didSet` property observers track when a navigation link triggers.\n\nYou can also use the reference to `path` variable to perform programmatic navigation. For example, you can pop a view off the stack:\n\n```swift\n@Observable\nclass NavigationManager {\n    var path: [Color] = [] {\n        willSet {\n            print(\"will set to \\(newValue)\")\n        }\n        \n        didSet {\n            print(\"didSet to \\(path)\")\n        }\n    }\n    \n    @discardableResult\n    func navigateBack() -> Color? {\n        path.popLast()\n    }\n}\n```\n\nUse a standard type when your stack displays views that rely on a single type of data, and `NavigationPath` when you need to present multiple data types in a single stack, as in the following example:\n\n```swift\nstruct ValueView: View {\n    @State private var path = NavigationPath()\n    \n    var body: some View {\n        NavigationStack(path: $path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n                NavigationLink(\"Apple Pie\", value: Recipe.applePie)\n                NavigationLink(\"Chocolate Cake\", value: Recipe.chocolateCake)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color)\n            }\n            .navigationDestination(for: Recipe.self) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}\n```\n\n\n\nWhen composed together, the navigation APIs allow you to use both styles of links, depending on what works best.\n\nHere, when someone taps on the link “View Mint Color”, SwiftUI pushes the value-based destination link onto the stack, followed by a view-destination link:\n\n```swift\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            NavigationLink(\"View Mint Color\", value: Color.mint)\n                .navigationDestination(for: Color.self) { color in\n                    NavigationLink(\"Push Recipe View\") {\n                        RecipeDetailView(recipe: .applePie)\n                    }\n                }\n        }\n    }\n}\n```\n\nAfter the code in this example runs, and someone clicks each `NavigationLink`, the navigation stack builds up with three views:\n\n\n\nSwiftUI keeps track of the entire navigation path. The underlying data structure looks like the following example:\n\n```swift\nRoot → [Color.mint] → [RecipeDetailView]\n```\n\nConceptually, SwiftUI stacks view-based destinations on top of the value-based destinations in the stack’s navigation path. For example, the code below replaces `RecipeDetailView` from the above example with a `NavigationLink`:\n\n```swift\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            NavigationLink(\"View Mint Color\", value: Color.mint)\n                .navigationDestination(for: Color.self) { color in\n                    NavigationLink(\"Push Recipe View\") {\n                        NavigationLink(\"Push another view\", value: Color.pink)\n                    }\n                }\n        }\n    }\n}\n```\n\nWhen you run the revised example, the view-destination link is still on the top of the stack.\n\nIf you use a heterogenous or homogeneous path on the stack, you may observe changes to the navigation path over time, as shown below:\n\n```swift\n@Observable\nclass NavigationManager {\n    var path: [Color] = [] {\n        didSet {\n            print(\"didSet to \\(path)\")\n        }\n    }\n}\n\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            NavigationLink(\"View Mint Color\", value: Color.mint)\n                .navigationDestination(for: Color.self) { color in\n                    NavigationLink(\"Push Recipe View\") {\n                        RecipeDetailView(recipe: .applePie)\n                    }\n                }\n        }\n    }\n}\n```\n\nWhen someone navigates through the app, it prints the following logs:\n\n```swift\nNew path: []\nNew Path: [Color.mint]\n```\n\nThe logs print because view-destination navigation links don’t cause any state changes that your app can observe. If you attempt to push a value while a view-destination link is on the stack, SwiftUI pops all view destinations and pushes the value’s destination onto the stack.\n\n### Restore state for navigation paths\n\nState restoration for a navigation path enables you restore your interface to the previous interaction point during a subsequent launch, providing continuity for people using your app.\n\nIn iOS, state restoration is especially important at the window or scene level, because windows come and go frequently. For this reason, it’s important to think about state restoration for navigation path in the same way you handle restoring your app’s state at the window or scene level. See [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/restoring-your-app-s-state-with-swiftui] to learn about storing scene data.\n\nUsing `Codable`, you can manually persist and load the navigation stack path in one of two ways, depending on whether the path data type is homogeneous or heterogeneous. Store a homogenous path as in the following example:\n\n```swift\n@Observable\nclass NavigationManager {\n    var path: [Recipe] = [] {\n        didSet {\n            save()\n        }\n    }\n    \n    \/\/\/ The URL for the JSON file that stores the navigation path.\n    private static var dataURL: URL {\n        .documentsDirectory.appending(path: \"NavigationPath.json\")\n    }\n    \n    init() {\n        do {\n            \/\/ Load the data model from the 'NavigationPath' data file found in the Documents directory.\n            let path = try load(url: NavigationManager.dataURL)\n            self.path = path\n        } catch {\n            \/\/ Handle error.\n        }\n    }\n    \n    func save() {\n        let encoder = JSONEncoder()\n        do {\n            let data = try encoder.encode(path)\n            try data.write(to: NavigationManager.dataURL)\n        } catch {\n            \/\/ Handle error.\n        }\n    }\n    \n    \/\/\/ Load the navigation path from a previously saved state.\n    func load(url: URL) throws -> [Recipe] {\n        let data = try Data(contentsOf: url, options: .mappedIfSafe)\n        let decoder = JSONDecoder()\n        return try decoder.decode([Recipe].self, from: data)\n    }\n}\n\nstruct ContentView: View {\n    @State private var navigationManager = NavigationManager()\n\n    var body: some View {\n        NavigationStack(path: $navigationManager.path) {\n            List {\n                NavigationLink(\"Mint\", value: Color.mint)\n                NavigationLink(\"Red\", value: Color.red)\n                NavigationLink(\"Apple Pie\", value: Recipe.applePie)\n                NavigationLink(\"Chocolate Cake\", value: Recipe.chocolateCake)\n            }\n            .navigationDestination(for: Color.self) { color in\n                ColorDetail(color: color, text: color.description)\n            }\n            .navigationDestination(for: Recipe.self) { recipe in\n                RecipeDetailView(recipe: recipe)\n            }\n        }\n    }\n}\n```\n\nIn the above example, when the `path` changes, `didSet` property observer triggers and the `save` function is called. The function saves the new path to disk enabling the app to restore it when initializing `NavigationManager`.\n\nStore a heterogeneous path using `NavigationPath`, as shown in the following example:\n\n```swift\n@Observable\nclass NavigationManager {\n    var path = NavigationPath() {\n        didSet {\n            save()\n        }\n    }\n    \n    \/\/\/ The URL for the JSON file that stores the navigation path.\n    private static var dataURL: URL {\n        .documentsDirectory.appending(path: \"NavigationPath.json\")\n    }\n    \n    init() {\n        do {\n            \/\/ Load the data model from the 'NavigationPath' data file found in the Documents directory.\n            let path = try load(url: NavigationManager.dataURL)\n            self.path = path\n        } catch {\n            \/\/ Handle error\n        }\n    }\n    \n    func save() {\n        guard let codableRepresentation = path.codable else { return }\n        let encoder = JSONEncoder()\n        do {\n            let data = try encoder.encode(codableRepresentation)\n            try data.write(to: NavigationManager.dataURL)\n        } catch {\n            \/\/Handle error.\n        }\n    }\n    \n    \/\/\/ Load the navigation path from a previously saved data.\n    func load(url: URL) throws -> NavigationPath {\n        let data = try Data(contentsOf: url, options: .mappedIfSafe)\n        let decoder = JSONDecoder()\n        let path = try decoder.decode(NavigationPath.CodableRepresentation.self, from: data)\n        return NavigationPath(path)\n    }\n}\n\n```\n\nIn the example above, the `save` method checks `path.codable` for nullability. This value describes the contents of the path in a serializable format. It returns `nil` if any of the type-erased elements of the path don’t conform to the `codable`.\n\nIt’s important to perform this check because `NavigationPath` doesn’t require the data types to conform to `Codable`. `NavigationPath` only needs the types to conform to `Hashable`, and as a result, you can’t verify that the navigation path is a valid representation of `Codable` at compile time.\n\nTo learn more about navigation stacks, links and paths, see [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Bringing-robust-navigation-structure-to-your-swiftui-app].\n\n",
  "sections" : [

  ],
  "source" : "appleJSON",
  "title" : "Understanding the navigation stack",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Understanding-the-composition-of-navigation-stack"
}