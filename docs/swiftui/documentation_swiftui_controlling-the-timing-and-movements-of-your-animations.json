{
  "abstract" : "Build sophisticated animations that you control using phase and keyframe animators.",
  "codeExamples" : [
    {
      "code" : "struct SimpleAnimationView: View {\n    var emoji: String\n    @State private var offset = 0.0\n\n    var body: some View {\n        EmojiView(emoji: emoji)\n            .offset(y: offset)\n            .onTapGesture {\n                withAnimation(.bouncy) {\n                    offset = -40.0\n                }\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct SimpleAnimationView: View {\n    var emoji: String\n    @State private var offset = 0.0\n\n    var body: some View {\n        EmojiView(emoji: emoji)\n            .offset(y: offset)\n            .onTapGesture {\n                withAnimation(.bouncy) {\n                    offset = -40.0\n                } completion: {\n                    withAnimation {\n                        offset = 0.0\n                    }\n                }\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct TwoPhaseAnimationView: View {\n    var emoji: String\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true]) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct TwoPhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true], trigger: likeCount) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct TwoPhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true], trigger: likeCount) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            } animation: { phase in\n                phase ? .bouncy : .default\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n}",
      "language" : "swift"
    },
    {
      "code" : "private enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n    \n    var verticalOffset: Double {\n        switch self {\n        case .initial: 0\n        case .move, .scale: -64\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n    \n    var verticalOffset: Double {\n        switch self {\n        case .initial: 0\n        case .move, .scale: -64\n        }\n    }\n    \n    var scaleEffect: Double {\n        switch self {\n        case .initial: 1\n        case .move, .scale: 1.5\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct ThreePhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator(AnimationPhase.allCases, trigger: likeCount) { content, phase in\n                content\n                    .scaleEffect(phase.scaleEffect)\n                    .offset(y: phase.verticalOffset)\n            } animation: { phase in\n                switch phase {\n                case .initial: .smooth\n                case .move: .easeInOut(duration: 0.3)\n                case .scale: .spring(duration: 0.3, bounce: 0.7)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "private struct AnimationValues {\n    var scale = 1.0\n    var verticalStretch = 1.0\n    var verticalOffset = 0.0\n    var angle = Angle.zero\n}",
      "language" : "swift"
    },
    {
      "code" : "struct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                \/\/ ...\n            } keyframes: { _ in\n                \/\/ ...\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                \/\/ ...\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    \/\/ ...\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    LinearKeyframe(1.0, duration: 0.36)\n                    SpringKeyframe(1.5, duration: 0.8,\n                        spring: .bouncy)\n                    SpringKeyframe(1.0, spring: .bouncy)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "struct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    LinearKeyframe(1.0, duration: 0.36)\n                    SpringKeyframe(1.5, duration: 0.8, spring: .bouncy)\n                    SpringKeyframe(1.0, spring: .bouncy)\n                }\n                \n                KeyframeTrack(\\.verticalOffset) {\n                    LinearKeyframe(0.0, duration: 0.1)\n                    SpringKeyframe(20.0, duration: 0.15, spring: .bouncy)\n                    SpringKeyframe(-60.0, duration: 1.0, spring: .bouncy)\n                    SpringKeyframe(0.0, spring: .bouncy)\n                }\n\n                KeyframeTrack(\\.verticalStretch) {\n                    CubicKeyframe(1.0, duration: 0.1)\n                    CubicKeyframe(0.6, duration: 0.15)\n                    CubicKeyframe(1.5, duration: 0.1)\n                    CubicKeyframe(1.05, duration: 0.15)\n                    CubicKeyframe(1.0, duration: 0.88)\n                    CubicKeyframe(0.8, duration: 0.1)\n                    CubicKeyframe(1.04, duration: 0.4)\n                    CubicKeyframe(1.0, duration: 0.22)\n                }\n\n                KeyframeTrack(\\.angle) {\n                    CubicKeyframe(.zero, duration: 0.58)\n                    CubicKeyframe(.degrees(16), duration: 0.125)\n                    CubicKeyframe(.degrees(-16), duration: 0.125)\n                    CubicKeyframe(.degrees(16), duration: 0.125)\n                    CubicKeyframe(.zero, duration: 0.125)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "c7cf4d61609b0920a5568b8cea212070c3819349ca00f1aad9fbc4f5a975c018",
  "crawledAt" : "2025-12-02T15:32:48Z",
  "id" : "6542F449-F50E-4EDA-8201-29BDBB80E12D",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "SwiftUI",
  "overview" : "## Overview\n\nSwiftUI provides a collection of useful animations that you can use in your app. These animations help enhance the user experience of your app by providing visual transitions of views and user interface elements. While these standard animations provide a great way to enhancement the user interaction of your app, there are times when you need to have more control over the timing and movement of a visual element. [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator] help give you that control.\n\nA phase animator allows you to define an animation as a collection of discrete steps called phases. The animator cycles through these phases to create a visual transition. With keyframe animator, you create keyframes that define animation values at specific times during the visual transition.\n\n## Create a simple bounce animation\n\nTo better understand how to create animations using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator], start with a simple example that uses standard SwiftUI animations. The following code moves an emoji upwards by setting its offset to `-40.0`. To provide a smooth transition of the movement, the code uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/withAnimation(_:_:)] function to apply a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/bouncy] animation after someone taps the emoji.\n\nThis animation has a single, discrete step: move the emoji upward. However, an animation can have multiple steps, such as moving an emoji upwards then back to its original position. For example, the following code sets the offset to `-40.0` to move the emoji upward, and then sets the offset (`0.0`) to return the emoji back to its original position:\n\nThis code uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/withAnimation(_:completionCriteria:_:completion:)] function to animate the two steps of the visual transition. The first step occurs in the `body` closure of the function, setting the offset to `-40.0`. The second step occurs in the `completion` closure, setting the offset to `0.0`.\n\nHowever, `EmojiView` actually goes through three steps. The first step happens when the view appears for the first time. The offset of the `EmojiView` view is `0.0`. When someone taps the view, the offset changes to `-40.0`; this is the second step. When that animation completes, the third step changes the offset back to `0.0`. However, there are only two discrete steps, based on the offset values (`0.0` and `-40.0`).\n\nWhile this implementation certainly works as expected, using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] is a more convenient way to define discrete steps as phases of an animation.\n\n## Bounce with a phase animator\n\nA [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] automatically advances through a set of given phases to create an animated transition. Use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:content:animation:)] modifier to provide the animator the phases for changing the animation value. For example, the emoji bounce animation shown earlier has two phases: move up and move back. You can represent these phases using the Boolean values, `true` and `false`. When the phase is `true`, the emoji moves up to `-40.0`. When the phase is `false`, the emoji moves back to the original position by setting the offset to `0.0`.\n\nThe phase animator cycles through the list of phases in the order that you provide to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:content:animation:)] modifier. When the view first appears, the phase animator invokes the `content` closure passing in the first phase. Then the animator calls the closure with the value of the second phase. The animator continues to call the `content` closure for each additional phase. After reaching the last phase, the animator calls `content` one more time with the value of the first phase.\n\nThis means that in the previous code, the phase animator calls `content` with the phase value of `false` when the view first appears. This sets the emoji’s offset to `0.0`. The phase animator then calls `content` with the `true` phase. This phase sets the offset to `-40.0`, causing the emoji to move upwards. After reaching that offset position, the animator calls `content` with the phase of `false`. This causes the emoji to move back to its original position by setting its offset to `0.0`.\n\nThis animation starts when the view appears. To start the animation based on an event, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:trigger:content:animation:)] modifier and provide a `trigger` value that animator observes for changes. The animator starts the animation when the value changes. For example, the following code increments the state variable `likeCount` each time a person taps the emoji. The code uses `likeCount` as the value that the phase animator observes for changes. Now whenever someone taps the emoji, it moves up and returns to its original position.\n\nSo far, the phase animator uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/default] animation to move the emoji. You can change that behavior by providing the `phaseAnimator` modifier an animation closure. In this closure, specify the type of animation to apply for each phase. For instance, the following code applies a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/bouncy] animation when the phase is `true`; otherwise, it applies the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/default] animation:\n\n## Add more phases to the animation\n\nWhile this bounce effect is nice, you can add more pizzazz to it. For instance, you could make the emoji increase in size as it moves upward, and then shrink back to normal size. To do this, you’ll add a third phase to the animation: scale.\n\nTo define the phases, create a custom type that lists the possible phases; for example:\n\nNext, to help simplify logic and reduce complexity, define computed properties that return the values to animate. For instance, to set the vertical offset to move the emoji, create a computed property that returns the offset based on the current phase:\n\nWhen at the initial phase, the offset is `0`, which is the original screen location for the emoji. But when the phase is `move` or `scale`, the offset is `-64`.\n\nYou can use the same approach (creating a computed property) for the scale effect to change the size of the emoji. Initially, the emoji appears at its original size, but increases in size during the move and scale phase, as shown here:\n\nTo animate an emoji, apply the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:trigger:content:animation:)] modifier to the `EmojiView`. Provide the animator all cases from the custom `AnimationPhase` type. Then change the content based on the phase by applying the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/scaleEffect(_:anchor:)] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/offset(x:y:)] modifiers. The values passed into these modifiers come from the computed properties, which helps keep the view code more readable.\n\nThe code also applies different animation types based on the phase in the `animation` closure to give the full animation that pizzazz you were looking for.\n\nA [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] gives you control of an animation based on discrete phases, which helps you add extra polish to an animation. But if you find that you need even more control over the timing and movement of an animation, use a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator].\n\n## Gain more control with a keyframe animator\n\nYou can define complex, coordinated animations with complete control over timing and movement using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator]. This animator allows you to create keyframes that define values at specific times during an animation. The animator use these values to generate interpolated values in between each frame of the animation.\n\nUnlike a phase animator, in which you model separate, discrete states, a keyframe animator generates interpolated values of the type that you specify. While an animation is in progress, the animator provides you with a value of this type on every frame so you can update the animating view by applying modifiers to it.\n\nYou define the type as a structure that contains the properties that you want to independently animate. For example, the following code defines four properties that determine the scale, stretch, position, and angle of an emoji:\n\nTo create a animation using a keyframe animator, apply either the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/keyframeAnimator(initialValue:repeating:content:keyframes:)] or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/keyframeAnimator(initialValue:trigger:content:keyframes:)] modifier to the view that you want to animate. For instance, the following code applies the second modifier to `EmojiView`. The initial value for the animation is a new instance of `AnimationValues`, and the state variable `likeCount` is the value that the animator observes for changes as it did in the previous phase animation example.\n\nTo apply modifiers to a view during the animation, provide a `content` closure to the keyframe animator. This closure includes two parameters:\n\nUse these parameters to apply modifiers to the view that SwiftUI is animating. For example, the following code uses these parameters to rotate, scale, stretch, and move an emoji:\n\nNext, define the keyframes. Keyframes let you build sophisticated animations with different keyframe for different properties. To make this possible, you organize the keyframes into tracks. Each track controls a different property of the type that you are animating. You associate a property to a track by providing the key path to the property when creating the track. For example, the following code adds a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeTrack] for the `scale` property:\n\nWhen creating a track, you use the declarative syntax in SwiftUI to add keyframes to the track. There are different kinds of keyframes, such as [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/CubicKeyframe], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LinearKeyframe], and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/SpringKeyframe]. You can mix and match the different kinds of keyframes within a track. For example, the following code adds a track for the `scale` property that performs a combination of linear and spring animations:\n\nEach keyframe type receives a value. The animator uses this value to generate interpolated values between frames and sets the property specified in the track’s key path before calling the animator’s content closure. For instance, in the previous code listing, the scale value is `1.0` during the linear keyframes, which keeps the emoji at its original size. Then the scale changes to `1.5` during the first spring keyframe. This causes the emoji to grow in size. The final spring keyframe sets the scale to `1.0`, which returns the emoji back to its original size.\n\nWhen implementing a keyframe animation, include a track for each property that you want to animate. For instance, `AnimationValues` has four properties:\n\nTo animate all four, the animator needs four keyframe tracks as shown in the following code:\n\nThe combination of these keyframe tracks creates an animation that squishes and stretches the emoji, before bouncing it upwards. As the emoji moves towards its peak, it grows larger. When the emoji reaches its peak, it gives a little wiggle. Then the emoji returns to its original location with a slight bounce as it settles back into its original position.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/SwiftUI\/Controlling-the-timing-and-movements-of-your-animations\ncrawled: 2025-12-02T15:32:48Z\n---\n\n# Controlling the timing and movements of your animations\n\n**Sample Code**\n\nBuild sophisticated animations that you control using phase and keyframe animators.\n\n## Overview\n\nSwiftUI provides a collection of useful animations that you can use in your app. These animations help enhance the user experience of your app by providing visual transitions of views and user interface elements. While these standard animations provide a great way to enhancement the user interaction of your app, there are times when you need to have more control over the timing and movement of a visual element. [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator] help give you that control.\n\nA phase animator allows you to define an animation as a collection of discrete steps called phases. The animator cycles through these phases to create a visual transition. With keyframe animator, you create keyframes that define animation values at specific times during the visual transition.\n\n## Create a simple bounce animation\n\nTo better understand how to create animations using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator], start with a simple example that uses standard SwiftUI animations. The following code moves an emoji upwards by setting its offset to `-40.0`. To provide a smooth transition of the movement, the code uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/withAnimation(_:_:)] function to apply a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/bouncy] animation after someone taps the emoji.\n\n```swift\nstruct SimpleAnimationView: View {\n    var emoji: String\n    @State private var offset = 0.0\n\n    var body: some View {\n        EmojiView(emoji: emoji)\n            .offset(y: offset)\n            .onTapGesture {\n                withAnimation(.bouncy) {\n                    offset = -40.0\n                }\n            }\n    }\n}\n```\n\nThis animation has a single, discrete step: move the emoji upward. However, an animation can have multiple steps, such as moving an emoji upwards then back to its original position. For example, the following code sets the offset to `-40.0` to move the emoji upward, and then sets the offset (`0.0`) to return the emoji back to its original position:\n\n```swift\nstruct SimpleAnimationView: View {\n    var emoji: String\n    @State private var offset = 0.0\n\n    var body: some View {\n        EmojiView(emoji: emoji)\n            .offset(y: offset)\n            .onTapGesture {\n                withAnimation(.bouncy) {\n                    offset = -40.0\n                } completion: {\n                    withAnimation {\n                        offset = 0.0\n                    }\n                }\n            }\n    }\n}\n```\n\nThis code uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/withAnimation(_:completionCriteria:_:completion:)] function to animate the two steps of the visual transition. The first step occurs in the `body` closure of the function, setting the offset to `-40.0`. The second step occurs in the `completion` closure, setting the offset to `0.0`.\n\n\n\nHowever, `EmojiView` actually goes through three steps. The first step happens when the view appears for the first time. The offset of the `EmojiView` view is `0.0`. When someone taps the view, the offset changes to `-40.0`; this is the second step. When that animation completes, the third step changes the offset back to `0.0`. However, there are only two discrete steps, based on the offset values (`0.0` and `-40.0`).\n\nWhile this implementation certainly works as expected, using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] is a more convenient way to define discrete steps as phases of an animation.\n\n## Bounce with a phase animator\n\nA [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] automatically advances through a set of given phases to create an animated transition. Use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:content:animation:)] modifier to provide the animator the phases for changing the animation value. For example, the emoji bounce animation shown earlier has two phases: move up and move back. You can represent these phases using the Boolean values, `true` and `false`. When the phase is `true`, the emoji moves up to `-40.0`. When the phase is `false`, the emoji moves back to the original position by setting the offset to `0.0`.\n\n```swift\nstruct TwoPhaseAnimationView: View {\n    var emoji: String\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true]) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            }\n    }\n}\n```\n\nThe phase animator cycles through the list of phases in the order that you provide to the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:content:animation:)] modifier. When the view first appears, the phase animator invokes the `content` closure passing in the first phase. Then the animator calls the closure with the value of the second phase. The animator continues to call the `content` closure for each additional phase. After reaching the last phase, the animator calls `content` one more time with the value of the first phase.\n\nThis means that in the previous code, the phase animator calls `content` with the phase value of `false` when the view first appears. This sets the emoji’s offset to `0.0`. The phase animator then calls `content` with the `true` phase. This phase sets the offset to `-40.0`, causing the emoji to move upwards. After reaching that offset position, the animator calls `content` with the phase of `false`. This causes the emoji to move back to its original position by setting its offset to `0.0`.\n\nThis animation starts when the view appears. To start the animation based on an event, use the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:trigger:content:animation:)] modifier and provide a `trigger` value that animator observes for changes. The animator starts the animation when the value changes. For example, the following code increments the state variable `likeCount` each time a person taps the emoji. The code uses `likeCount` as the value that the phase animator observes for changes. Now whenever someone taps the emoji, it moves up and returns to its original position.\n\n```swift\nstruct TwoPhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true], trigger: likeCount) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\n\n\nSo far, the phase animator uses the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/default] animation to move the emoji. You can change that behavior by providing the `phaseAnimator` modifier an animation closure. In this closure, specify the type of animation to apply for each phase. For instance, the following code applies a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/bouncy] animation when the phase is `true`; otherwise, it applies the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/Animation\/default] animation:\n\n```swift\nstruct TwoPhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator([false, true], trigger: likeCount) { content, phase in\n                content.offset(y: phase ? -40.0 : 0.0)\n            } animation: { phase in\n                phase ? .bouncy : .default\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\n\n\n## Add more phases to the animation\n\nWhile this bounce effect is nice, you can add more pizzazz to it. For instance, you could make the emoji increase in size as it moves upward, and then shrink back to normal size. To do this, you’ll add a third phase to the animation: scale.\n\nTo define the phases, create a custom type that lists the possible phases; for example:\n\n```swift\nprivate enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n}\n```\n\nNext, to help simplify logic and reduce complexity, define computed properties that return the values to animate. For instance, to set the vertical offset to move the emoji, create a computed property that returns the offset based on the current phase:\n\n```swift\nprivate enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n    \n    var verticalOffset: Double {\n        switch self {\n        case .initial: 0\n        case .move, .scale: -64\n        }\n    }\n}\n```\n\nWhen at the initial phase, the offset is `0`, which is the original screen location for the emoji. But when the phase is `move` or `scale`, the offset is `-64`.\n\nYou can use the same approach (creating a computed property) for the scale effect to change the size of the emoji. Initially, the emoji appears at its original size, but increases in size during the move and scale phase, as shown here:\n\n```swift\nprivate enum AnimationPhase: CaseIterable {\n    case initial\n    case move\n    case scale\n    \n    var verticalOffset: Double {\n        switch self {\n        case .initial: 0\n        case .move, .scale: -64\n        }\n    }\n    \n    var scaleEffect: Double {\n        switch self {\n        case .initial: 1\n        case .move, .scale: 1.5\n        }\n    }\n}\n```\n\nTo animate an emoji, apply the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/phaseAnimator(_:trigger:content:animation:)] modifier to the `EmojiView`. Provide the animator all cases from the custom `AnimationPhase` type. Then change the content based on the phase by applying the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/scaleEffect(_:anchor:)] and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/offset(x:y:)] modifiers. The values passed into these modifiers come from the computed properties, which helps keep the view code more readable.\n\n```swift\nstruct ThreePhaseAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .phaseAnimator(AnimationPhase.allCases, trigger: likeCount) { content, phase in\n                content\n                    .scaleEffect(phase.scaleEffect)\n                    .offset(y: phase.verticalOffset)\n            } animation: { phase in\n                switch phase {\n                case .initial: .smooth\n                case .move: .easeInOut(duration: 0.3)\n                case .scale: .spring(duration: 0.3, bounce: 0.7)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\nThe code also applies different animation types based on the phase in the `animation` closure to give the full animation that pizzazz you were looking for.\n\n\n\n\n\nA [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/PhaseAnimator] gives you control of an animation based on discrete phases, which helps you add extra polish to an animation. But if you find that you need even more control over the timing and movement of an animation, use a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator].\n\n## Gain more control with a keyframe animator\n\nYou can define complex, coordinated animations with complete control over timing and movement using a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeAnimator]. This animator allows you to create keyframes that define values at specific times during an animation. The animator use these values to generate interpolated values in between each frame of the animation.\n\nUnlike a phase animator, in which you model separate, discrete states, a keyframe animator generates interpolated values of the type that you specify. While an animation is in progress, the animator provides you with a value of this type on every frame so you can update the animating view by applying modifiers to it.\n\nYou define the type as a structure that contains the properties that you want to independently animate. For example, the following code defines four properties that determine the scale, stretch, position, and angle of an emoji:\n\n```swift\nprivate struct AnimationValues {\n    var scale = 1.0\n    var verticalStretch = 1.0\n    var verticalOffset = 0.0\n    var angle = Angle.zero\n}\n```\n\n\n\nTo create a animation using a keyframe animator, apply either the [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/keyframeAnimator(initialValue:repeating:content:keyframes:)] or [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/View\/keyframeAnimator(initialValue:trigger:content:keyframes:)] modifier to the view that you want to animate. For instance, the following code applies the second modifier to `EmojiView`. The initial value for the animation is a new instance of `AnimationValues`, and the state variable `likeCount` is the value that the animator observes for changes as it did in the previous phase animation example.\n\n```swift\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                \/\/ ...\n            } keyframes: { _ in\n                \/\/ ...\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\nTo apply modifiers to a view during the animation, provide a `content` closure to the keyframe animator. This closure includes two parameters:\n\n\n\nUse these parameters to apply modifiers to the view that SwiftUI is animating. For example, the following code uses these parameters to rotate, scale, stretch, and move an emoji:\n\n```swift\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                \/\/ ...\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\n\n\nNext, define the keyframes. Keyframes let you build sophisticated animations with different keyframe for different properties. To make this possible, you organize the keyframes into tracks. Each track controls a different property of the type that you are animating. You associate a property to a track by providing the key path to the property when creating the track. For example, the following code adds a [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/KeyframeTrack] for the `scale` property:\n\n```swift\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    \/\/ ...\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\nWhen creating a track, you use the declarative syntax in SwiftUI to add keyframes to the track. There are different kinds of keyframes, such as [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/CubicKeyframe], [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/LinearKeyframe], and [doc:\/\/com.apple.SwiftUI\/documentation\/SwiftUI\/SpringKeyframe]. You can mix and match the different kinds of keyframes within a track. For example, the following code adds a track for the `scale` property that performs a combination of linear and spring animations:\n\n```swift\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    LinearKeyframe(1.0, duration: 0.36)\n                    SpringKeyframe(1.5, duration: 0.8,\n                        spring: .bouncy)\n                    SpringKeyframe(1.0, spring: .bouncy)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\nEach keyframe type receives a value. The animator uses this value to generate interpolated values between frames and sets the property specified in the track’s key path before calling the animator’s content closure. For instance, in the previous code listing, the scale value is `1.0` during the linear keyframes, which keeps the emoji at its original size. Then the scale changes to `1.5` during the first spring keyframe. This causes the emoji to grow in size. The final spring keyframe sets the scale to `1.0`, which returns the emoji back to its original size.\n\n\n\nWhen implementing a keyframe animation, include a track for each property that you want to animate. For instance, `AnimationValues` has four properties:\n\n- `scale`\n- `verticalStretch`\n- `verticalOffset`\n- `angle`\n\nTo animate all four, the animator needs four keyframe tracks as shown in the following code:\n\n```swift\nstruct KeyframeAnimationView: View {\n    var emoji: String\n    @State private var likeCount = 1\n    \n    var body: some View {\n        EmojiView(emoji: emoji)\n            .keyframeAnimator(\n                initialValue: AnimationValues(),\n                trigger: likeCount\n            ) { content, value in\n                content\n                    .rotationEffect(value.angle)\n                    .scaleEffect(value.scale)\n                    .scaleEffect(y: value.verticalStretch)\n                    .offset(y: value.verticalOffset)\n            } keyframes: { _ in\n                KeyframeTrack(\\.scale) {\n                    LinearKeyframe(1.0, duration: 0.36)\n                    SpringKeyframe(1.5, duration: 0.8, spring: .bouncy)\n                    SpringKeyframe(1.0, spring: .bouncy)\n                }\n                \n                KeyframeTrack(\\.verticalOffset) {\n                    LinearKeyframe(0.0, duration: 0.1)\n                    SpringKeyframe(20.0, duration: 0.15, spring: .bouncy)\n                    SpringKeyframe(-60.0, duration: 1.0, spring: .bouncy)\n                    SpringKeyframe(0.0, spring: .bouncy)\n                }\n\n                KeyframeTrack(\\.verticalStretch) {\n                    CubicKeyframe(1.0, duration: 0.1)\n                    CubicKeyframe(0.6, duration: 0.15)\n                    CubicKeyframe(1.5, duration: 0.1)\n                    CubicKeyframe(1.05, duration: 0.15)\n                    CubicKeyframe(1.0, duration: 0.88)\n                    CubicKeyframe(0.8, duration: 0.1)\n                    CubicKeyframe(1.04, duration: 0.4)\n                    CubicKeyframe(1.0, duration: 0.22)\n                }\n\n                KeyframeTrack(\\.angle) {\n                    CubicKeyframe(.zero, duration: 0.58)\n                    CubicKeyframe(.degrees(16), duration: 0.125)\n                    CubicKeyframe(.degrees(-16), duration: 0.125)\n                    CubicKeyframe(.degrees(16), duration: 0.125)\n                    CubicKeyframe(.zero, duration: 0.125)\n                }\n            }\n            .onTapGesture {\n                likeCount += 1\n            }\n    }\n}\n```\n\nThe combination of these keyframe tracks creates an animation that squishes and stretches the emoji, before bouncing it upwards. As the emoji moves towards its peak, it grows larger. When the emoji reaches its peak, it gives a little wiggle. Then the emoji returns to its original location with a slight bounce as it settles back into its original position.\n\n\n\n\n\n## Creating phase-based animation\n\n- **phaseAnimator(_:content:animation:)**: Animates effects that you apply to a view over a sequence of phases that change continuously.\n- **phaseAnimator(_:trigger:content:animation:)**: Animates effects that you apply to a view over a sequence of phases that change based on a trigger.\n- **PhaseAnimator**: A container that animates its content by automatically cycling through a collection of phases that you provide, each defining a discrete step within an animation.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Animates effects that you apply to a view over a sequence of phases that change continuously.",
          "name" : "phaseAnimator(_:content:animation:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/View\/phaseAnimator(_:content:animation:)"
        },
        {
          "description" : "Animates effects that you apply to a view over a sequence of phases that change based on a trigger.",
          "name" : "phaseAnimator(_:trigger:content:animation:)",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/View\/phaseAnimator(_:trigger:content:animation:)"
        },
        {
          "description" : "A container that animates its content by automatically cycling through a collection of phases that you provide, each defining a discrete step within an animation.",
          "name" : "PhaseAnimator",
          "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/PhaseAnimator"
        }
      ],
      "title" : "Creating phase-based animation"
    }
  ],
  "source" : "appleJSON",
  "title" : "Controlling the timing and movements of your animations",
  "url" : "https:\/\/developer.apple.com\/documentation\/SwiftUI\/Controlling-the-timing-and-movements-of-your-animations"
}