{
  "abstract" : "Replace a color in one image with the background from another.",
  "codeExamples" : [
    {
      "code" : "- (CIFilter<CIColorCube> *) chromaKeyFilterHuesFrom:(CGFloat)minHue to:(CGFloat)maxHue {\n    \/\/ 1\n    const unsigned int size = 64;\n    const size_t cubeDataSize = size * size * size * 4;\n    NSMutableData* cubeData = [[NSMutableData alloc] initWithCapacity:(cubeDataSize * sizeof(float))];\n    \n    \/\/ 2\n    for (int z = 0; z < size; z++) {\n        CGFloat blue = ((double)z)\/(size-1);\n        for (int y = 0; y < size; y++) {\n            CGFloat green = ((double)y)\/(size-1);\n            for (int x = 0; x < size; x++) {\n                CGFloat red = ((double)x)\/(size-1);\n                \n                \/\/ 3\n                CGFloat hue = [self hueFromRed:red green:green blue:blue];\n                float alpha = (hue >= minHue && hue <= maxHue) ? 0 : 1;\n                \/\/ 4\n                float premultipliedRed = red * alpha;\n                float premultipliedGreen = green * alpha;\n                float premultipliedBlue = blue * alpha;\n                [cubeData appendBytes:&premultipliedRed length:sizeof(float)];\n                [cubeData appendBytes:&premultipliedGreen length:sizeof(float)];\n                [cubeData appendBytes:&premultipliedBlue length:sizeof(float)];\n                [cubeData appendBytes:&alpha length:sizeof(float)];\n            }\n        }\n    }\n\n    \/\/ 5\n    CIFilter<CIColorCube> *colorCubeFilter = CIFilter.colorCubeFilter;\n    colorCubeFilter.cubeDimension = size;\n    colorCubeFilter.cubeData = cubeData;\n    return colorCubeFilter;\n}",
      "language" : "swift"
    },
    {
      "code" : "- (CGFloat) hueFromRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue {\n    UIColor* color = [UIColor colorWithRed:red green:green blue:blue alpha:1];\n    \n    CGFloat hue, saturation, brightness;\n    [color getHue:&hue saturation:&saturation brightness:&brightness alpha:nil];\n    \n    return hue;\n}",
      "language" : "swift"
    },
    {
      "code" : "CIFilter<CIColorCube>* chromaKeyFilter = [self chromaKeyFilterHuesFrom:0.3 to:0.4];\nchromaKeyFilter.inputimage = foregroundCIImage\nCIImage* sourceCIImageWithoutBackground = chromaKeyFilter.outputImage;",
      "language" : "swift"
    },
    {
      "code" : "CIFilter<CICompositeOperation> *compositor = CIFilter.sourceOverCompositingFilter\ncompositor.inputImage = sourceCIImageWithoutBackground\ncompositor.backgroundImage = backgroundCIImage\nCIImage* compositedCIImage = compositor.outputImage;",
      "language" : "swift"
    }
  ],
  "contentHash" : "8586c6d3af7b4dff6424e37a3013dd1dc6369adfc208880e899efe9926247ad6",
  "crawledAt" : "2025-12-04T21:21:21Z",
  "id" : "69629EFF-740D-491B-A23C-FA168B7857A6",
  "kind" : "article",
  "language" : "swift",
  "module" : "Core Image",
  "overview" : "## Overview\n\nUse the chroma key effect, also known as bluescreening or greenscreening, to replace the background of an image by setting a color or range of colors to transparent.\n\n\n\nYou apply this technique in three steps:\n\n### Create a Cube Map\n\nA color cube is a 3D color-lookup table that uses the R, G, and B values from the image to lookup a color. To filter out green from the image, create a color map with the green portion set to transparent pixels.\n\nA simple way to construct a color map with these characteristics is to model colors using an HSV (hue-saturation-value) representation. HSV represents hue as an angle around the central axis, as in a color wheel. In order to make a chroma key color from the source image transparent, set its lookup table value to `0` when its hue is in the correct color range.\n\n\n\nThe value for green in the source image falls within the slice beginning at 108° (`108\/360` = `0.3`) and ending at 144° (`144\/360` = `0.4`). You’ll set transparency to `0` for this range in the color cube.\n\nTo create the color cube, iterate across all values of red, green, and blue, entering a value of 0 for combinations that the filter wiill set to transparent. Refer to the numbered list for details on each step to the routine.\n\n### Remove Green from the Source Image\n\nApply the color cube filter to a foreground image by setting its `inputImage` parameter and then accessing the `outputImage`.\n\nThe output image contains the foreground with all green pixels made transparent.\n\nThe filter passes through each pixel in the input image, looks up its color in the color cube, and replaces the source color with the color in the color cube at the nearest position.\n\n### Composite over a Background Image\n\nChain a [doc:\/\/com.apple.coreimage\/documentation\/CoreImage\/CIFilter-swift.class\/sourceOverCompositing()] filter to the color cube filter to composite a background image to the greenscreened output. The transparency in the colorcube-filtered image allows the composited background image to show through.\n\nThe foreground of the source image now appears in front of the background landscape without any trace of the green screen.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/CoreImage\/applying-a-chroma-key-effect\ncrawled: 2025-12-04T21:21:21Z\n---\n\n# Applying a Chroma Key Effect\n\n**Article**\n\nReplace a color in one image with the background from another.\n\n## Overview\n\nUse the chroma key effect, also known as bluescreening or greenscreening, to replace the background of an image by setting a color or range of colors to transparent.\n\n\n\nYou apply this technique in three steps:\n\n1. Create a cube map for the [doc:\/\/com.apple.coreimage\/documentation\/CoreImage\/CIFilter-swift.class\/colorCube()] filter to determine which colors to set transparent.\n2. Apply the [doc:\/\/com.apple.coreimage\/documentation\/CoreImage\/CIFilter-swift.class\/colorCube()] filter to the image to make pixels transparent.\n3. Use the [doc:\/\/com.apple.coreimage\/documentation\/CoreImage\/CIFilter-swift.class\/sourceOverCompositing()] filter to place the image over the background image.\n\n### Create a Cube Map\n\nA color cube is a 3D color-lookup table that uses the R, G, and B values from the image to lookup a color. To filter out green from the image, create a color map with the green portion set to transparent pixels.\n\nA simple way to construct a color map with these characteristics is to model colors using an HSV (hue-saturation-value) representation. HSV represents hue as an angle around the central axis, as in a color wheel. In order to make a chroma key color from the source image transparent, set its lookup table value to `0` when its hue is in the correct color range.\n\n\n\nThe value for green in the source image falls within the slice beginning at 108° (`108\/360` = `0.3`) and ending at 144° (`144\/360` = `0.4`). You’ll set transparency to `0` for this range in the color cube.\n\nTo create the color cube, iterate across all values of red, green, and blue, entering a value of 0 for combinations that the filter wiill set to transparent. Refer to the numbered list for details on each step to the routine.\n\n```swift\n- (CIFilter<CIColorCube> *) chromaKeyFilterHuesFrom:(CGFloat)minHue to:(CGFloat)maxHue {\n    \/\/ 1\n    const unsigned int size = 64;\n    const size_t cubeDataSize = size * size * size * 4;\n    NSMutableData* cubeData = [[NSMutableData alloc] initWithCapacity:(cubeDataSize * sizeof(float))];\n    \n    \/\/ 2\n    for (int z = 0; z < size; z++) {\n        CGFloat blue = ((double)z)\/(size-1);\n        for (int y = 0; y < size; y++) {\n            CGFloat green = ((double)y)\/(size-1);\n            for (int x = 0; x < size; x++) {\n                CGFloat red = ((double)x)\/(size-1);\n                \n                \/\/ 3\n                CGFloat hue = [self hueFromRed:red green:green blue:blue];\n                float alpha = (hue >= minHue && hue <= maxHue) ? 0 : 1;\n                \/\/ 4\n                float premultipliedRed = red * alpha;\n                float premultipliedGreen = green * alpha;\n                float premultipliedBlue = blue * alpha;\n                [cubeData appendBytes:&premultipliedRed length:sizeof(float)];\n                [cubeData appendBytes:&premultipliedGreen length:sizeof(float)];\n                [cubeData appendBytes:&premultipliedBlue length:sizeof(float)];\n                [cubeData appendBytes:&alpha length:sizeof(float)];\n            }\n        }\n    }\n\n    \/\/ 5\n    CIFilter<CIColorCube> *colorCubeFilter = CIFilter.colorCubeFilter;\n    colorCubeFilter.cubeDimension = size;\n    colorCubeFilter.cubeData = cubeData;\n    return colorCubeFilter;\n}\n```\n\n1. Allocate memory. The color cube has three dimensions, each with four elements of data (RGBA).\n2. Use a for-loop to iterate through each color combination of red, green, and blue, simulating a color gradient.\n3. Convert RGB to HSV, as in the `hueFromRed` function. Even though the color cube exists in RGB color space, it’s easier to isolate and remove color based on hue. Input `0` for green hues to indicate complete removal; use `1` for other hues to leave those colors intact. To specify green as a hue value, convert its angle in the hue pie chart to a range of `0` to `1`. The green in the sample image has hue between `0.3` (`108` out of `360` degrees`)` and `0.4` (`144` out of `360` degrees). Your shade of green may differ, so adjust the range accordingly.\n4. The [doc:\/\/com.apple.coreimage\/documentation\/CoreImage\/CIFilter-swift.class\/colorCube()] filter requires premultiplied alpha values, meaning that the values in the lookup table have their transparency baked into their stored entries rather than applied when accessed.\n5. Create a [doc:\/\/com.apple.coreimage\/documentation\/CoreImage\/CIFilter-swift.class\/colorCube()] filter with the cube data.\n\n\n\n```swift\n- (CGFloat) hueFromRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue {\n    UIColor* color = [UIColor colorWithRed:red green:green blue:blue alpha:1];\n    \n    CGFloat hue, saturation, brightness;\n    [color getHue:&hue saturation:&saturation brightness:&brightness alpha:nil];\n    \n    return hue;\n}\n```\n\n### Remove Green from the Source Image\n\nApply the color cube filter to a foreground image by setting its `inputImage` parameter and then accessing the `outputImage`.\n\n```swift\nCIFilter<CIColorCube>* chromaKeyFilter = [self chromaKeyFilterHuesFrom:0.3 to:0.4];\nchromaKeyFilter.inputimage = foregroundCIImage\nCIImage* sourceCIImageWithoutBackground = chromaKeyFilter.outputImage;\n```\n\nThe output image contains the foreground with all green pixels made transparent.\n\nThe filter passes through each pixel in the input image, looks up its color in the color cube, and replaces the source color with the color in the color cube at the nearest position.\n\n### Composite over a Background Image\n\nChain a [doc:\/\/com.apple.coreimage\/documentation\/CoreImage\/CIFilter-swift.class\/sourceOverCompositing()] filter to the color cube filter to composite a background image to the greenscreened output. The transparency in the colorcube-filtered image allows the composited background image to show through.\n\n```swift\nCIFilter<CICompositeOperation> *compositor = CIFilter.sourceOverCompositingFilter\ncompositor.inputImage = sourceCIImageWithoutBackground\ncompositor.backgroundImage = backgroundCIImage\nCIImage* compositedCIImage = compositor.outputImage;\n```\n\nThe foreground of the source image now appears in front of the background landscape without any trace of the green screen.\n\n## Filter Recipes\n\n- **Selectively Focusing on an Image**: Focus on a part of an image by applying Gaussian blur and gradient masks.\n- **Customizing Image Transitions**: Transition between images in creative ways using Core Image filters.\n- **Simulating Scratchy Analog Film**: Degrade the quality of an image to make it look like dated, analog film.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Focus on a part of an image by applying Gaussian blur and gradient masks.",
          "name" : "Selectively Focusing on an Image",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreImage\/selectively-focusing-on-an-image"
        },
        {
          "description" : "Transition between images in creative ways using Core Image filters.",
          "name" : "Customizing Image Transitions",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreImage\/customizing-image-transitions"
        },
        {
          "description" : "Degrade the quality of an image to make it look like dated, analog film.",
          "name" : "Simulating Scratchy Analog Film",
          "url" : "https:\/\/developer.apple.com\/documentation\/CoreImage\/simulating-scratchy-analog-film"
        }
      ],
      "title" : "Filter Recipes"
    }
  ],
  "source" : "appleJSON",
  "title" : "Applying a Chroma Key Effect",
  "url" : "https:\/\/developer.apple.com\/documentation\/CoreImage\/applying-a-chroma-key-effect"
}