{
  "abstract" : "Add an Intent Extension to your app to handle money transfer requests with Siri.",
  "codeExamples" : [
    {
      "code" : "func resolvePayee(for intent: INSendPaymentIntent, with completion: @escaping (INPersonResolutionResult) -> Void) {\n    if let payee = intent.payee {\n        \/\/ Look up contacts that match the payee.\n        contactLookup.lookup(displayName: payee.displayName) { contacts in\n            \/\/ Build the `INIntentResolutionResult` to pass to the `completion` closure.\n            let result: INPersonResolutionResult\n\n            if let contact = contacts.first, contacts.count == 1 {\n                \/\/ An exact single match.\n                let resolvedPayee = INPerson(contact: contact)\n                result = INPersonResolutionResult.success(with: resolvedPayee)\n            } else if contacts.isEmpty {\n                \/\/ Found no matches.\n                result = INPersonResolutionResult.unsupported()\n            } else {\n                \/\/ Found more than one match; user needs to clarify the intended contact.\n                let people: [INPerson] = contacts.map { contact in\n                    return INPerson(contact: contact)\n                }\n                result = INPersonResolutionResult.disambiguation(with: people)\n            }\n            completion(result)\n        }\n    } else if let mostRecentPayee = paymentProvider.mostRecentPayment?.contact {\n        \/\/ No payee provided; suggest the last payee.\n        let result = INPersonResolutionResult.confirmationRequired(with: INPerson(contact: mostRecentPayee))\n        completion(result)\n    } else {\n        \/\/ No payee provided and there was no previous payee.\n        let result = INPersonResolutionResult.needsValue()\n        completion(result)\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func resolveCurrencyAmount(for intent: INSendPaymentIntent, with completion: @escaping (INCurrencyAmountResolutionResult) -> Void) {\n    let result: INCurrencyAmountResolutionResult\n\n    \/\/ Resolve the currency amount.\n    if let currencyAmount = intent.currencyAmount, let amount = currencyAmount.amount, let currencyCode = currencyAmount.currencyCode {\n        if amount.intValue <= 0 {\n            \/\/ The amount needs to be a positive value.\n            result = INCurrencyAmountResolutionResult.unsupported()\n        } else if let currencyCode = paymentProvider.validate(currencyCode) {\n            \/\/ Make a new `INCurrencyAmount` with the resolved currency code.\n            let resolvedAmount = INCurrencyAmount(amount: amount, currencyCode: currencyCode)\n            result = INCurrencyAmountResolutionResult.success(with: resolvedAmount)\n        } else {\n            \/\/ Unsupported currency.\n            result = INCurrencyAmountResolutionResult.unsupported()\n        }\n    } else if let mostRecentPayment = paymentProvider.mostRecentPayment {\n        \/\/ No amount provided; suggest the last amount sent.\n        let suggestedAmount = INCurrencyAmount(amount: NSDecimalNumber(decimal: mostRecentPayment.amount),\n                                               currencyCode: mostRecentPayment.currencyCode)\n        result = INCurrencyAmountResolutionResult.confirmationRequired(with: suggestedAmount)\n    } else {\n        \/\/ No amount provided and there was no previous payment.\n        result = INCurrencyAmountResolutionResult.needsValue()\n    }\n    completion(result)\n}",
      "language" : "swift"
    },
    {
      "code" : "\/\/ Register names of contacts that may not be in the user's address book.\nlet contactNames = Contact.sampleContacts.map { $0.formattedName }\nINVocabulary.shared().setVocabularyStrings(NSOrderedSet(array: contactNames), of: .contactName)",
      "language" : "swift"
    },
    {
      "code" : "func confirm(intent: INSendPaymentIntent, completion: @escaping (INSendPaymentIntentResponse) -> Void) {\n    guard\n        let payee = intent.payee,\n        let payeeHandle = payee.personHandle,\n        let currencyAmount = intent.currencyAmount,\n        let amount = currencyAmount.amount,\n        let currencyCode = currencyAmount.currencyCode\n        else { completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil)); return }\n\n    contactLookup.lookup(emailAddress: payeeHandle.value!) { contact in\n        guard let contact = contact else {\n            completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n            return\n        }\n\n        let payment = Payment(contact: contact, amount: amount.decimalValue, currencyCode: currencyCode)\n\n        self.paymentProvider.canSend(payment) { success, error in\n            guard success else {\n                completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n                return\n            }\n\n            let response = INSendPaymentIntentResponse(code: .success, userActivity: nil)\n            response.paymentRecord = self.makePaymentRecord(for: intent)\n\n            completion(response)\n        }\n    }\n}",
      "language" : "swift"
    },
    {
      "code" : "func handle(intent: INSendPaymentIntent, completion: @escaping (INSendPaymentIntentResponse) -> Void) {\n    guard\n        let payee = intent.payee,\n        let payeeHandle = payee.personHandle,\n        let currencyAmount = intent.currencyAmount,\n        let amount = currencyAmount.amount,\n        let currencyCode = currencyAmount.currencyCode\n        else { completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil)); return }\n\n    contactLookup.lookup(emailAddress: payeeHandle.value!) { contact in\n        guard let contact = contact else {\n            completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n            return\n        }\n\n        let payment = Payment(contact: contact, amount: amount.decimalValue, currencyCode: currencyCode)\n\n        self.paymentProvider.send(payment) { success, _, _ in\n            guard success else {\n                completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n                return\n            }\n\n            let response = INSendPaymentIntentResponse(code: .success, userActivity: nil)\n            response.paymentRecord = self.makePaymentRecord(for: intent)\n\n            completion(response)\n        }\n    }\n}",
      "language" : "swift"
    }
  ],
  "contentHash" : "00e26ef7053b9c4f728bb067cdbc18a208394d3e1e06616bbccc6b22e0722796",
  "crawledAt" : "2025-12-05T19:40:18Z",
  "id" : "73DF9B1E-BC4D-4D32-A101-F6BFFFA5F135",
  "kind" : "unknown",
  "language" : "swift",
  "module" : "Intents",
  "overview" : "## Overview\n\nThe app in this sample project demonstrates how to send payments between users by implementing [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling]. Users can make payments with Siri and view a list of previously completed payments inside the main app.\n\nThe project consists of three targets:\n\nSee [doc:\/\/com.apple.documentation\/documentation\/SiriKit\/creating-an-intents-app-extension]. for more information on the general process of adding an Intent Extension to your app, including how to enable the Siri capability and configure the `NSExtension` keys in the `Info.plist`.\n\n### Configure the Sample Code Project\n\nThis sample app can be run in the iOS Simulator without any special setup, but in order to run on a device you will need to update the build settings and enable an App Group for the project:\n\n### Resolve Payment Parameters\n\nThe first step in processing a payment with `INSendPaymentIntentHandling` is to obtain the payee for the transaction and the currency amount to send to the payee. Depending on the command that the user speaks to Siri, your app may have to deal with one of the following scenarios:\n\nThe extension resolves each parameter separately by responding to methods from the [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling] protocol. Depending on the initial request and subsequent conversation with Siri, each of the parameter resolution methods may be called multiple times as Siri clarifies the request from the user.\n\nThe extension resolves the payee parameter through calls to [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/resolvePayee(for:with:)-3otmy]. Use this method to take input from Siri, match it to a payee, and asynchronously return an [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult] by calling [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult\/success(with:)], [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult\/confirmationRequired(with:)], or [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult\/disambiguation(with:)].\n\nThe extension resolves the currency amount for the payment through calls to [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/resolveCurrencyAmount(for:with:)-75c7o], and optionally a note to be associated with the transaction is resolved with calls to [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/resolveNote(for:with:)].\n\n### Add Domain-Specific Language\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Intents\/INVocabulary] to aid Siri with recognizing any domain-specific vocabulary users are likely to use in their voice commands. For example, in this sample project payee names are not taken from the user’s contacts but from a predefined list inside the app, so these names are added as additional vocabulary with [doc:\/\/com.apple.documentation\/documentation\/Intents\/INVocabulary\/setVocabularyStrings(_:of:)].\n\nMore information on the types of custom vocabulary that are appropriate to add to Siri can be found in [doc:\/\/com.apple.documentation\/documentation\/SiriKit\/registering-custom-vocabulary-with-sirikit].\n\n### Confirm and Complete the Payment\n\nWhen all parameters have been resolved, the system calls [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/confirm(intent:completion:)] to let the app validate the transaction details. Pass back the status of the transaction by calling the `completion` block with an [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentResponse] object initialized from a [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentResponseCode] and an [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPaymentRecord] in the [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentResponse\/paymentRecord].\n\nFinally, once the payment has been confirmed by the user, the system calls [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/handle(intent:completion:)]. Use this method to perform the confirmed transaction and pass back the status of the transaction by calling the `completion` block.",
  "rawMarkdown" : "---\nsource: https:\/\/developer.apple.com\/documentation\/sirikit\/handling-payment-requests-with-sirikit\ncrawled: 2025-12-05T19:40:18Z\n---\n\n# Handling Payment Requests with SiriKit\n\n**Sample Code**\n\nAdd an Intent Extension to your app to handle money transfer requests with Siri.\n\n## Overview\n\nThe app in this sample project demonstrates how to send payments between users by implementing [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling]. Users can make payments with Siri and view a list of previously completed payments inside the main app.\n\nThe project consists of three targets:\n\n- `Payments`, an iOS app which shows a history of completed payments.\n- `PaymentsIntentsExtension`, an Intent Extension that integrates with SiriKit to send payments.\n- `PaymentsFramework`, an embedded framework containing shared code needed by both the Intent Extension and the main app.\n\nSee [doc:\/\/com.apple.documentation\/documentation\/SiriKit\/creating-an-intents-app-extension]. for more information on the general process of adding an Intent Extension to your app, including how to enable the Siri capability and configure the `NSExtension` keys in the `Info.plist`.\n\n### Configure the Sample Code Project\n\nThis sample app can be run in the iOS Simulator without any special setup, but in order to run on a device you will need to update the build settings and enable an App Group for the project:\n\n1. Open `Payments.xcodeproj` with the latest version of Xcode.\n2. In the project editor, set a new bundle identifier under Identity on the General pane for each of the three targets in the project.\n3. In the Capabilities pane, make sure that App Groups is switched on for the `Payments` and `PaymentsIntentsExtension` targets.\n4. Add an App Group identifier with the format `group.com.example`.\n5. Reference the new App Group identifier in the source code. Open `PaymentProvider.swift` and modify the implementation of the `sharedUserDefaults` property to reference the new identifier.\n\n\n\n### Resolve Payment Parameters\n\nThe first step in processing a payment with `INSendPaymentIntentHandling` is to obtain the payee for the transaction and the currency amount to send to the payee. Depending on the command that the user speaks to Siri, your app may have to deal with one of the following scenarios:\n\n- The initial request specifies all required parameters. For example, the user requests, “Send $50 to Jane with Payments.”\n- The request lacks some required parameters. For example, the user requests, “Send money to Jane with Payments.”\n- The request supplies incorrect or inaccurate parameters. For example, the user requests, “Send money to Dave with Payments,” when no valid contacts match “Dave”.\n- The initial request supplies no parameters. For example, the user requests, “Send money with Payments.”\n\nThe extension resolves each parameter separately by responding to methods from the [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling] protocol. Depending on the initial request and subsequent conversation with Siri, each of the parameter resolution methods may be called multiple times as Siri clarifies the request from the user.\n\nThe extension resolves the payee parameter through calls to [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/resolvePayee(for:with:)-3otmy]. Use this method to take input from Siri, match it to a payee, and asynchronously return an [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult] by calling [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult\/success(with:)], [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult\/confirmationRequired(with:)], or [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPersonResolutionResult\/disambiguation(with:)].\n\n```swift\nfunc resolvePayee(for intent: INSendPaymentIntent, with completion: @escaping (INPersonResolutionResult) -> Void) {\n    if let payee = intent.payee {\n        \/\/ Look up contacts that match the payee.\n        contactLookup.lookup(displayName: payee.displayName) { contacts in\n            \/\/ Build the `INIntentResolutionResult` to pass to the `completion` closure.\n            let result: INPersonResolutionResult\n\n            if let contact = contacts.first, contacts.count == 1 {\n                \/\/ An exact single match.\n                let resolvedPayee = INPerson(contact: contact)\n                result = INPersonResolutionResult.success(with: resolvedPayee)\n            } else if contacts.isEmpty {\n                \/\/ Found no matches.\n                result = INPersonResolutionResult.unsupported()\n            } else {\n                \/\/ Found more than one match; user needs to clarify the intended contact.\n                let people: [INPerson] = contacts.map { contact in\n                    return INPerson(contact: contact)\n                }\n                result = INPersonResolutionResult.disambiguation(with: people)\n            }\n            completion(result)\n        }\n    } else if let mostRecentPayee = paymentProvider.mostRecentPayment?.contact {\n        \/\/ No payee provided; suggest the last payee.\n        let result = INPersonResolutionResult.confirmationRequired(with: INPerson(contact: mostRecentPayee))\n        completion(result)\n    } else {\n        \/\/ No payee provided and there was no previous payee.\n        let result = INPersonResolutionResult.needsValue()\n        completion(result)\n    }\n}\n```\n\nThe extension resolves the currency amount for the payment through calls to [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/resolveCurrencyAmount(for:with:)-75c7o], and optionally a note to be associated with the transaction is resolved with calls to [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/resolveNote(for:with:)].\n\n```swift\nfunc resolveCurrencyAmount(for intent: INSendPaymentIntent, with completion: @escaping (INCurrencyAmountResolutionResult) -> Void) {\n    let result: INCurrencyAmountResolutionResult\n\n    \/\/ Resolve the currency amount.\n    if let currencyAmount = intent.currencyAmount, let amount = currencyAmount.amount, let currencyCode = currencyAmount.currencyCode {\n        if amount.intValue <= 0 {\n            \/\/ The amount needs to be a positive value.\n            result = INCurrencyAmountResolutionResult.unsupported()\n        } else if let currencyCode = paymentProvider.validate(currencyCode) {\n            \/\/ Make a new `INCurrencyAmount` with the resolved currency code.\n            let resolvedAmount = INCurrencyAmount(amount: amount, currencyCode: currencyCode)\n            result = INCurrencyAmountResolutionResult.success(with: resolvedAmount)\n        } else {\n            \/\/ Unsupported currency.\n            result = INCurrencyAmountResolutionResult.unsupported()\n        }\n    } else if let mostRecentPayment = paymentProvider.mostRecentPayment {\n        \/\/ No amount provided; suggest the last amount sent.\n        let suggestedAmount = INCurrencyAmount(amount: NSDecimalNumber(decimal: mostRecentPayment.amount),\n                                               currencyCode: mostRecentPayment.currencyCode)\n        result = INCurrencyAmountResolutionResult.confirmationRequired(with: suggestedAmount)\n    } else {\n        \/\/ No amount provided and there was no previous payment.\n        result = INCurrencyAmountResolutionResult.needsValue()\n    }\n    completion(result)\n}\n```\n\n### Add Domain-Specific Language\n\nUse [doc:\/\/com.apple.documentation\/documentation\/Intents\/INVocabulary] to aid Siri with recognizing any domain-specific vocabulary users are likely to use in their voice commands. For example, in this sample project payee names are not taken from the user’s contacts but from a predefined list inside the app, so these names are added as additional vocabulary with [doc:\/\/com.apple.documentation\/documentation\/Intents\/INVocabulary\/setVocabularyStrings(_:of:)].\n\n```swift\n\/\/ Register names of contacts that may not be in the user's address book.\nlet contactNames = Contact.sampleContacts.map { $0.formattedName }\nINVocabulary.shared().setVocabularyStrings(NSOrderedSet(array: contactNames), of: .contactName)\n```\n\nMore information on the types of custom vocabulary that are appropriate to add to Siri can be found in [doc:\/\/com.apple.documentation\/documentation\/SiriKit\/registering-custom-vocabulary-with-sirikit].\n\n### Confirm and Complete the Payment\n\nWhen all parameters have been resolved, the system calls [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/confirm(intent:completion:)] to let the app validate the transaction details. Pass back the status of the transaction by calling the `completion` block with an [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentResponse] object initialized from a [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentResponseCode] and an [doc:\/\/com.apple.documentation\/documentation\/Intents\/INPaymentRecord] in the [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentResponse\/paymentRecord].\n\n```swift\nfunc confirm(intent: INSendPaymentIntent, completion: @escaping (INSendPaymentIntentResponse) -> Void) {\n    guard\n        let payee = intent.payee,\n        let payeeHandle = payee.personHandle,\n        let currencyAmount = intent.currencyAmount,\n        let amount = currencyAmount.amount,\n        let currencyCode = currencyAmount.currencyCode\n        else { completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil)); return }\n\n    contactLookup.lookup(emailAddress: payeeHandle.value!) { contact in\n        guard let contact = contact else {\n            completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n            return\n        }\n\n        let payment = Payment(contact: contact, amount: amount.decimalValue, currencyCode: currencyCode)\n\n        self.paymentProvider.canSend(payment) { success, error in\n            guard success else {\n                completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n                return\n            }\n\n            let response = INSendPaymentIntentResponse(code: .success, userActivity: nil)\n            response.paymentRecord = self.makePaymentRecord(for: intent)\n\n            completion(response)\n        }\n    }\n}\n```\n\nFinally, once the payment has been confirmed by the user, the system calls [doc:\/\/com.apple.documentation\/documentation\/Intents\/INSendPaymentIntentHandling\/handle(intent:completion:)]. Use this method to perform the confirmed transaction and pass back the status of the transaction by calling the `completion` block.\n\n```swift\nfunc handle(intent: INSendPaymentIntent, completion: @escaping (INSendPaymentIntentResponse) -> Void) {\n    guard\n        let payee = intent.payee,\n        let payeeHandle = payee.personHandle,\n        let currencyAmount = intent.currencyAmount,\n        let amount = currencyAmount.amount,\n        let currencyCode = currencyAmount.currencyCode\n        else { completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil)); return }\n\n    contactLookup.lookup(emailAddress: payeeHandle.value!) { contact in\n        guard let contact = contact else {\n            completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n            return\n        }\n\n        let payment = Payment(contact: contact, amount: amount.decimalValue, currencyCode: currencyCode)\n\n        self.paymentProvider.send(payment) { success, _, _ in\n            guard success else {\n                completion(INSendPaymentIntentResponse(code: .failure, userActivity: nil))\n                return\n            }\n\n            let response = INSendPaymentIntentResponse(code: .success, userActivity: nil)\n            response.paymentRecord = self.makePaymentRecord(for: intent)\n\n            completion(response)\n        }\n    }\n}\n```\n\n## Sample code\n\n- **Adding Shortcuts for Wind Down**: Reveal your app’s shortcuts inside the Health app.\n- **Booking Rides with SiriKit**: Add Intents extensions to your app to handle requests to book rides using Siri and Maps.\n- **Handling Workout Requests with SiriKit**: Add an Intent Extension to your app that handles requests to control workouts with Siri.\n- **Integrating Your App with Siri Event Suggestions**: Donate reservations and provide quick access to event details throughout the system.\n- **Managing Audio with SiriKit**: Control audio playback and handle requests to add media using SiriKit Media Intents.\n- **Providing Hands-Free App Control with Intents**: Resolve, confirm, and handle intents without an extension.\n- **Soup Chef: Accelerating App Interactions with Shortcuts**: Make it easy for people to use Siri with your app by providing shortcuts to your app’s actions.\n- **Soup Chef with App Intents: Migrating custom intents**: Integrating App Intents to provide your appʼs actions to Siri and Shortcuts.\n\n",
  "sections" : [
    {
      "content" : "",
      "items" : [
        {
          "description" : "Reveal your app’s shortcuts inside the Health app.",
          "name" : "Adding Shortcuts for Wind Down",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/adding-shortcuts-for-wind-down"
        },
        {
          "description" : "Add Intents extensions to your app to handle requests to book rides using Siri and Maps.",
          "name" : "Booking Rides with SiriKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/booking-rides-with-sirikit"
        },
        {
          "description" : "Add an Intent Extension to your app that handles requests to control workouts with Siri.",
          "name" : "Handling Workout Requests with SiriKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/handling-workout-requests-with-sirikit"
        },
        {
          "description" : "Donate reservations and provide quick access to event details throughout the system.",
          "name" : "Integrating Your App with Siri Event Suggestions",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/integrating-your-app-with-siri-event-suggestions"
        },
        {
          "description" : "Control audio playback and handle requests to add media using SiriKit Media Intents.",
          "name" : "Managing Audio with SiriKit",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/managing-audio-with-sirikit"
        },
        {
          "description" : "Resolve, confirm, and handle intents without an extension.",
          "name" : "Providing Hands-Free App Control with Intents",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/providing-hands-free-app-control-with-intents"
        },
        {
          "description" : "Make it easy for people to use Siri with your app by providing shortcuts to your app’s actions.",
          "name" : "Soup Chef: Accelerating App Interactions with Shortcuts",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/soup-chef-accelerating-app-interactions-with-shortcuts"
        },
        {
          "description" : "Integrating App Intents to provide your appʼs actions to Siri and Shortcuts.",
          "name" : "Soup Chef with App Intents: Migrating custom intents",
          "url" : "https:\/\/developer.apple.com\/documentation\/SiriKit\/soup-chef-with-app-intents-migrating-custom-intents"
        }
      ],
      "title" : "Sample code"
    }
  ],
  "source" : "appleJSON",
  "title" : "Handling Payment Requests with SiriKit",
  "url" : "https:\/\/developer.apple.com\/documentation\/sirikit\/handling-payment-requests-with-sirikit"
}