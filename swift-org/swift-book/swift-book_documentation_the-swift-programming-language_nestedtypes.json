{
  "abstract" : "Define types inside the scope of another type.",
  "codeExamples" : [

  ],
  "contentHash" : "f42fcfc42d4689151e95170d7f2622fbb60775fcf87b18164dff3b6449d5333e",
  "crawledAt" : "2025-12-02T19:38:12Z",
  "declaration" : {
    "code" : "struct BlackjackCard {\n\n\n    \/\/ nested Suit enumeration\n    enum Suit: Character {\n        case spades = \"♠\", hearts = \"♡\", diamonds = \"♢\", clubs = \"♣\"\n    }\n\n\n    \/\/ nested Rank enumeration\n    enum Rank: Int {\n        case two = 2, three, four, five, six, seven, eight, nine, ten\n        case jack, queen, king, ace\n        struct Values {\n            let first: Int, second: Int?\n        }\n        var values: Values {\n            switch self {\n            case .ace:\n                return Values(first: 1, second: 11)\n            case .jack, .queen, .king:\n                return Values(first: 10, second: nil)\n            default:\n                return Values(first: self.rawValue, second: nil)\n            }\n        }\n    }\n\n\n    \/\/ BlackjackCard properties and methods\n    let rank: Rank, suit: Suit\n    var description: String {\n        var output = \"suit is \\(suit.rawValue),\"\n        output += \" value is \\(rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or \\(second)\"\n        }\n        return output\n    }\n}",
    "language" : "swift"
  },
  "id" : "948DBF1B-909B-489E-B380-38203783BFD0",
  "kind" : "class",
  "overview" : "The Swift Programming Language (6.2.1)  Nested Types  Nested Types Nested TypesDefine types inside the scope of another type.Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility structures purely for use within the context of a more complex type, and protocols that are normally used in conjunction with a specific type. To accomplish this, Swift enables you to define nested types, whereby you nest supporting types like enumerations, structures, and protocols within the definition of the type they support.\n\nTo nest a type within another type, write its definition within the outer braces of the type it supports. Types can be nested to as many levels as are required.\n\nThe example below defines a structure called BlackjackCard, which models a playing card as used in the game of Blackjack. The BlackjackCard structure contains two nested enumeration types called Suit and Rank.",
  "rawMarkdown" : "---\nsource: https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/\ncrawled: 2025-12-02T19:38:12Z\n---\n\n# Nested Types | Documentation\n\n- [ The Swift Programming Language (6.2.1) ](\/swift-book\/documentation\/the-swift-programming-language)\n\n- [ Nested Types ](\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/)\n\n- [ Nested Types ](\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/)\n\n# Nested Types\n\nDefine types inside the scope of another type.Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility structures purely for use within the context of a more complex type, and protocols that are normally used in conjunction with a specific type. To accomplish this, Swift enables you to define *nested types*, whereby you nest supporting types like enumerations, structures, and protocols within the definition of the type they support.\n\nTo nest a type within another type, write its definition within the outer braces of the type it supports. Types can be nested to as many levels as are required.\n\n## [Nested Types in Action](\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/#Nested-Types-in-Action)\n\nThe example below defines a structure called `BlackjackCard`, which models a playing card as used in the game of Blackjack. The `BlackjackCard` structure contains two nested enumeration types called `Suit` and `Rank`.\n\nIn Blackjack, the Ace cards have a value of either one or eleven. This feature is represented by a structure called `Values`, which is nested within the `Rank` enumeration:\n\n\n\n```\nstruct BlackjackCard {\n\n\n    \/\/ nested Suit enumeration\n    enum Suit: Character {\n        case spades = \"♠\", hearts = \"♡\", diamonds = \"♢\", clubs = \"♣\"\n    }\n\n\n    \/\/ nested Rank enumeration\n    enum Rank: Int {\n        case two = 2, three, four, five, six, seven, eight, nine, ten\n        case jack, queen, king, ace\n        struct Values {\n            let first: Int, second: Int?\n        }\n        var values: Values {\n            switch self {\n            case .ace:\n                return Values(first: 1, second: 11)\n            case .jack, .queen, .king:\n                return Values(first: 10, second: nil)\n            default:\n                return Values(first: self.rawValue, second: nil)\n            }\n        }\n    }\n\n\n    \/\/ BlackjackCard properties and methods\n    let rank: Rank, suit: Suit\n    var description: String {\n        var output = \"suit is (suit.rawValue),\"\n        output += \" value is (rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or (second)\"\n        }\n        return output\n    }\n}\n\n```\n\nThe `Suit` enumeration describes the four common playing card suits, together with a raw `Character` value to represent their symbol.\n\nThe `Rank` enumeration describes the thirteen possible playing card ranks, together with a raw `Int` value to represent their face value. (This raw `Int` value isn’t used for the Jack, Queen, King, and Ace cards.)\n\nAs mentioned above, the `Rank` enumeration defines a further nested structure of its own, called `Values`. This structure encapsulates the fact that most cards have one value, but the Ace card has two values. The `Values` structure defines two properties to represent this:\n\n- `first`, of type `Int`\n\n- `second`, of type `Int?`, or “optional `Int`”\n\n`Rank` also defines a computed property, `values`, which returns an instance of the `Values` structure. This computed property considers the rank of the card and initializes a new `Values` instance with appropriate values based on its rank. It uses special values for `jack`, `queen`, `king`, and `ace`. For the numeric cards, it uses the rank’s raw `Int` value.\n\nThe `BlackjackCard` structure itself has two properties — `rank` and `suit`. It also defines a computed property called `description`, which uses the values stored in `rank` and `suit` to build a description of the name and value of the card. The `description` property uses optional binding to check whether there’s a second value to display, and if so, inserts additional description detail for that second value.\n\nBecause `BlackjackCard` is a structure with no custom initializers, it has an implicit memberwise initializer, as described in [Memberwise Initializers for Structure Types](\/swift-book\/documentation\/the-swift-programming-language\/initialization#Memberwise-Initializers-for-Structure-Types). You can use this initializer to initialize a new constant called `theAceOfSpades`:\n\n\n\n```\nlet theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)\nprint(\"theAceOfSpades: (theAceOfSpades.description)\")\n\/\/ Prints \"theAceOfSpades: suit is ♠, value is 1 or 11\".\n\n```\n\nEven though `Rank` and `Suit` are nested within `BlackjackCard`, their type can be inferred from context, and so the initialization of this instance is able to refer to the enumeration cases by their case names (`.ace` and `.spades`) alone. In the example above, the `description` property correctly reports that the Ace of Spades has a value of `1` or `11`.\n\n## [Referring to Nested Types](\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/#Referring-to-Nested-Types)\n\nTo use a nested type outside of its definition context, prefix its name with the name of the type it’s nested within:\n\n\n\n```\nlet heartsSymbol = BlackjackCard.Suit.hearts.rawValue\n\/\/ heartsSymbol is \"♡\"\n\n```\n\nFor the example above, this enables the names of `Suit`, `Rank`, and `Values` to be kept deliberately short, because their names are naturally qualified by the context in which they’re defined.\n\n- [ Nested Types ](\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/#app-top)\n\n- [ Nested Types in Action ](\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/#Nested-Types-in-Action)\n\n- [ Referring to Nested Types ](\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/#Referring-to-Nested-Types)",
  "sections" : [
    {
      "content" : "",
      "title" : "Nested Types in Action"
    },
    {
      "content" : "",
      "title" : "Referring to Nested Types"
    }
  ],
  "source" : "swiftOrg",
  "title" : "Nested Types | Documentation",
  "url" : "https:\/\/docs.swift.org\/swift-book\/documentation\/the-swift-programming-language\/nestedtypes\/"
}